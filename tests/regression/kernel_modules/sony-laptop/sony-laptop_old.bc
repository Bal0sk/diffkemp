; ModuleID = 'drivers/platform/x86/sony-laptop.bc'
source_filename = "drivers/platform/x86/sony-laptop.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.6 }
%union.anon.6 = type { i8* }
%struct.sony_pic_dev = type { %struct.acpi_device*, %struct.sony_pic_irq*, %struct.sony_pic_ioport*, %struct.list_head, %struct.list_head, %struct.mutex, %struct.sonypi_eventtypes*, i32 (i8, i8)*, i32, i16, i8, i8, i8 }
%struct.acpi_device = type { i32, i8*, %struct.acpi_device*, %struct.list_head, %struct.list_head, %struct.list_head, %struct.acpi_device_status, %struct.acpi_device_flags, %struct.acpi_device_pnp, %struct.acpi_device_power, %struct.acpi_device_wakeup, %struct.acpi_device_perf, %struct.acpi_device_dir, %struct.acpi_scan_handler*, %struct.acpi_driver*, i8*, %struct.device, i32, i8, %struct.list_head, %struct.mutex, [1 x i64], %struct.list_head, void (%struct.acpi_device*)* }
%struct.acpi_device_status = type { i32 }
%struct.acpi_device_flags = type { i32 }
%struct.acpi_device_pnp = type { [8 x i8], %struct.acpi_pnp_type, i64, i8*, %struct.list_head, [40 x i8], [20 x i8], %union.acpi_object*, i64 }
%struct.acpi_pnp_type = type { i32 }
%union.acpi_object = type { %struct.anon.52 }
%struct.anon.52 = type { i32, i32, i64, i32 }
%struct.acpi_device_power = type { i32, %struct.acpi_device_power_flags, [5 x %struct.acpi_device_power_state] }
%struct.acpi_device_power_flags = type { i32 }
%struct.acpi_device_power_state = type { %struct.anon.54, i32, i32, %struct.list_head }
%struct.anon.54 = type { i8, i8 }
%struct.acpi_device_wakeup = type { i8*, i64, i64, %struct.list_head, %struct.acpi_device_wakeup_flags, i32 }
%struct.acpi_device_wakeup_flags = type { i8 }
%struct.acpi_device_perf = type { i32, %struct.acpi_device_perf_flags, i32, %struct.acpi_device_perf_state* }
%struct.acpi_device_perf_flags = type { i8 }
%struct.acpi_device_perf_state = type { %struct.anon.55, i8, i8, i32 }
%struct.anon.55 = type { i8 }
%struct.acpi_device_dir = type { %struct.proc_dir_entry* }
%struct.proc_dir_entry = type opaque
%struct.acpi_scan_handler = type { %struct.acpi_device_id*, %struct.list_head, i32 (%struct.acpi_device*, %struct.acpi_device_id*)*, void (%struct.acpi_device*)*, %struct.acpi_hotplug_profile }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.acpi_hotplug_profile = type { %struct.kobject, i8, i32 }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i32 }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.acpi_driver = type { [80 x i8], [80 x i8], %struct.acpi_device_id*, i32, %struct.acpi_device_ops, %struct.device_driver, %struct.module* }
%struct.acpi_device_ops = type { i32 (%struct.acpi_device*)*, i32 (%struct.acpi_device*)*, void (%struct.acpi_device*, i32)* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.driver_private = type opaque
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, %struct.memcg_batch_info, i32, %struct.atomic_t, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.atomic64_t = type { i64 }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file = type { %union.anon.3, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%union.anon.3 = type { %struct.list_head }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.8, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.4, i8* }
%union.anon.4 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.7, i32 }
%union.anon.7 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%union.anon.8 = type { %struct.list_head }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.44, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.45, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.atomic_t, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.44 = type { i32 }
%union.anon.45 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.9 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.9 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.16, i32 }
%union.anon.16 = type { i8* }
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t, i32, i32, i8*, %struct.lockdep_map }
%union.arch_rwlock_t = type { i64 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.17, %union.anon.23, %union.anon.25, i64 }
%struct.anon.17 = type { %union.anon.18, %union.anon.19 }
%union.anon.18 = type { i64 }
%union.anon.19 = type { i64 }
%union.anon.23 = type { %struct.list_head }
%union.anon.25 = type { i64 }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %struct.atomic_t, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.12, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.13, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.14, %union.anon.15 }
%union.anon.12 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.13 = type { i64 }
%union.anon.14 = type { %struct.list_head }
%union.anon.15 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.28 }
%union.anon.28 = type { %struct.anon.29 }
%struct.anon.29 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.31, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.34 }
%union.anon.31 = type { %struct.anon.32 }
%struct.anon.32 = type { i64, i64 }
%union.anon.34 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.36 }
%union.anon.36 = type { %struct.anon.40, [80 x i8] }
%struct.anon.40 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.module_ref = type { i64, i64 }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.dma_attrs*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.dma_attrs = type { [1 x i64] }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.sony_pic_irq = type { %struct.acpi_resource_irq, %struct.list_head }
%struct.acpi_resource_irq = type { i8, i8, i8, i8, i8, i8, [1 x i8] }
%struct.sony_pic_ioport = type { %struct.acpi_resource_io, %struct.acpi_resource_io, %struct.list_head }
%struct.acpi_resource_io = type <{ i8, i8, i8, i16, i16 }>
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.sonypi_eventtypes = type { i8, i64, %struct.sonypi_event* }
%struct.sonypi_event = type { i8, i8 }
%struct.sony_backlight_props = type { %struct.backlight_device*, i32, i32, i8, i8 }
%struct.backlight_device = type { %struct.backlight_properties, %struct.mutex, %struct.mutex, %struct.backlight_ops*, %struct.notifier_block, %struct.device }
%struct.backlight_properties = type { i32, i32, i32, i32, i32, i32 }
%struct.backlight_ops = type { i32, i32 (%struct.backlight_device*)*, i32 (%struct.backlight_device*)*, i32 (%struct.backlight_device*, %struct.fb_info*)* }
%struct.fb_info = type opaque
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.pv_irq_ops = type { %struct.paravirt_callee_save, %struct.paravirt_callee_save, %struct.paravirt_callee_save, %struct.paravirt_callee_save, void ()*, void ()*, void ()* }
%struct.paravirt_callee_save = type { i8* }
%struct.pv_cpu_ops = type { i64 (i32)*, void (i32, i64)*, void ()*, i64 ()*, void (i64)*, i64 ()*, i64 ()*, void (i64)*, i64 ()*, void (i64)*, void ()*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (i8*, i32)*, i64 ()*, void (%struct.thread_struct*, i32)*, void (i32)*, void (%struct.desc_struct*, i32, i8*)*, void (%struct.desc_struct*, i32, i8*, i32)*, void (%struct.gate_struct64*, i32, %struct.gate_struct64*)*, void (%struct.desc_struct*, i32)*, void (%struct.desc_struct*, i32)*, void (%struct.tss_struct*, %struct.thread_struct*)*, void (i32)*, void ()*, void ()*, void (i32*, i32*, i32*, i32*)*, i64 (i32, i32*)*, i32 (i32, i32, i32)*, i64 ()*, i64 (i32)*, i64 (i32*)*, void ()*, void ()*, void ()*, void ()*, void ()*, void (%struct.task_struct*)*, void (%struct.task_struct*)* }
%struct.desc_ptr = type <{ i16, i64 }>
%struct.gate_struct64 = type { i16, i16, i16, i16, i32, i32 }
%struct.tss_struct = type { %struct.x86_hw_tss, [1025 x i64], [64 x i64], [56 x i8] }
%struct.x86_hw_tss = type <{ i32, i64, i64, i64, i64, [7 x i64], i32, i32, i16, i16, [24 x i8] }>
%struct.dmi_system_id = type { {}*, i8*, [4 x %struct.dmi_strmatch], i8* }
%struct.dmi_strmatch = type { i8, [79 x i8] }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, %struct.mfd_cell*, %struct.pdev_archdata }
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.mfd_cell = type opaque
%struct.pdev_archdata = type {}
%struct.sony_laptop_input_s = type { %struct.atomic_t, %struct.input_dev*, %struct.input_dev*, %struct.kfifo, %struct.spinlock, %struct.timer_list }
%struct.input_dev = type { i8*, i8*, i8*, %struct.input_id, [1 x i64], [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i32, i32, i32, i8*, i32 (%struct.input_dev*, %struct.input_keymap_entry*, i32*)*, i32 (%struct.input_dev*, %struct.input_keymap_entry*)*, %struct.ff_device*, i32, %struct.timer_list, [2 x i32], %struct.input_mt*, %struct.input_absinfo*, [12 x i64], [1 x i64], [1 x i64], [1 x i64], i32 (%struct.input_dev*)*, void (%struct.input_dev*)*, i32 (%struct.input_dev*, %struct.file*)*, i32 (%struct.input_dev*, i32, i32, i32)*, %struct.input_handle*, %struct.spinlock, %struct.mutex, i32, i8, %struct.device, %struct.list_head, %struct.list_head, i32, i32, %struct.input_value*, i8 }
%struct.input_id = type { i16, i16, i16, i16 }
%struct.input_keymap_entry = type { i8, i8, i16, i32, [32 x i8] }
%struct.ff_device = type { i32 (%struct.input_dev*, %struct.ff_effect*, %struct.ff_effect*)*, i32 (%struct.input_dev*, i32)*, i32 (%struct.input_dev*, i32, i32)*, void (%struct.input_dev*, i16)*, void (%struct.input_dev*, i16)*, void (%struct.ff_device*)*, i8*, [2 x i64], %struct.mutex, i32, %struct.ff_effect*, [0 x %struct.file*] }
%struct.ff_effect = type { i16, i16, i16, %struct.ff_trigger, %struct.ff_replay, %union.anon.57 }
%struct.ff_trigger = type { i16, i16 }
%struct.ff_replay = type { i16, i16 }
%union.anon.57 = type { %struct.ff_periodic_effect }
%struct.ff_periodic_effect = type { i16, i16, i16, i16, i16, %struct.ff_envelope, i32, i16* }
%struct.ff_envelope = type { i16, i16, i16, i16 }
%struct.input_mt = type opaque
%struct.input_absinfo = type { i32, i32, i32, i32, i32, i32 }
%struct.input_handle = type { i8*, i32, i8*, %struct.input_dev*, %struct.input_handler*, %struct.list_head, %struct.list_head }
%struct.input_handler = type { i8*, void (%struct.input_handle*, i32, i32, i32)*, void (%struct.input_handle*, %struct.input_value*, i32)*, i1 (%struct.input_handle*, i32, i32, i32)*, i1 (%struct.input_handler*, %struct.input_dev*)*, i32 (%struct.input_handler*, %struct.input_dev*, %struct.input_device_id*)*, void (%struct.input_handle*)*, void (%struct.input_handle*)*, i8, i32, i8*, %struct.input_device_id*, %struct.list_head, %struct.list_head }
%struct.input_device_id = type { i64, i16, i16, i16, i16, [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i64 }
%struct.input_value = type { i16, i16, i32 }
%struct.kfifo = type { %union.anon.58, [0 x i8] }
%union.anon.58 = type { %struct.__kfifo }
%struct.__kfifo = type { i32, i32, i32, i32, i8* }
%struct.sonypi_compat_s = type { %struct.fasync_struct*, %struct.kfifo, %struct.spinlock, %struct.__wait_queue_head, %struct.atomic_t }
%struct.miscdevice = type { i32, i8*, %struct.file_operations*, %struct.list_head, %struct.device*, %struct.device*, i8*, i16 }
%struct.acpi_buffer = type { i64, i8* }
%struct.platform_driver = type { i32 (%struct.platform_device*)*, i32 (%struct.platform_device*)*, void (%struct.platform_device*)*, i32 (%struct.platform_device*, i32)*, i32 (%struct.platform_device*)*, %struct.device_driver, %struct.platform_device_id* }
%struct.sony_nc_value = type { i8*, i8**, i8**, i32 (i32, i32)*, i32, i32, i32, %struct.device_attribute }
%struct.sony_nc_handles = type { [16 x i16], %struct.device_attribute }
%struct.touchpad_control = type { %struct.device_attribute, i32 }
%struct.battery_care_control = type { [2 x %struct.device_attribute], i32 }
%struct.snc_lid_resume_control = type { [3 x %struct.device_attribute], i32 }
%struct.snc_thermal_ctrl = type { i32, i32, %struct.device_attribute, %struct.device_attribute }
%struct.snc_gfx_switch_control = type { %struct.device_attribute, i32 }
%struct.rfkill = type opaque
%struct.rfkill_ops = type { void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)*, i32 (i8*, i1)* }
%struct.kbd_backlight = type { i32, i32, i32, i32, %struct.device_attribute, %struct.device_attribute }
%struct.sony_nc_event = type { i8, i8 }
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, %struct.memcg_cache_params*, i32, i32, [1024 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page*, [26 x i32] }
%struct.kmem_cache_order_objects = type { i64 }
%struct.memcg_cache_params = type { i8, %union.anon.26 }
%union.anon.26 = type { %struct.anon.27 }
%struct.anon.27 = type { %struct.mem_cgroup*, %struct.list_head, %struct.kmem_cache*, i8, %struct.atomic_t, %struct.work_struct }
%struct.kmem_cache_node = type opaque
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, [6 x i8], %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, i16, i8, i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, [3 x i8], i16, [2 x i8], %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], %struct.list_head, %struct.kset*, %struct.pci_vpd*, %union.anon.56, %struct.pci_ats*, i64, i64 }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.pci_ops = type { i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.pci_dynids }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)* }
%struct.pci_dynids = type { %struct.spinlock, %struct.list_head }
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.56 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_ats = type opaque
%struct.anon.63 = type { %struct.acpi_resource, %struct.acpi_resource, %struct.acpi_resource, %struct.acpi_resource }
%struct.acpi_resource = type { i32, i32, %union.acpi_resource_data }
%union.acpi_resource_data = type { %struct.acpi_resource_vendor_typed, [40 x i8] }
%struct.acpi_resource_vendor_typed = type { i16, i8, [16 x i8], [1 x i8] }
%struct.acpi_object_list = type { i32, %union.acpi_object* }
%struct.sony_laptop_keypress = type { %struct.input_dev*, i32 }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.mm_segment_t, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.map_segment = type opaque
%struct.mm_segment_t = type { i64 }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.59 }
%union.anon.59 = type { %struct.anon.60 }
%struct.anon.60 = type { i32*, i32, i32, i32, i64, i32* }
%struct.anon.47 = type { i32, i64 }
%struct.acpi_device_info = type { i32, i32, i32, i8, i8, i8, [4 x i8], [5 x i8], i32, i64, %struct.acpi_pnp_device_id, %struct.acpi_pnp_device_id, %struct.acpi_pnp_device_id, %struct.acpi_pnp_device_id_list }
%struct.acpi_pnp_device_id = type { i32, i8* }
%struct.acpi_pnp_device_id_list = type { i32, i32, [1 x %struct.acpi_pnp_device_id] }
%struct.anon.49 = type { i32, i32, i8* }

@__UNIQUE_ID_author91 = internal constant [35 x i8] c"author=Stelian Pop, Mattia Dongili\00", section ".modinfo", align 1
@__UNIQUE_ID_description92 = internal constant [65 x i8] c"description=Sony laptop extras driver (SPIC and SNC ACPI device)\00", section ".modinfo", align 1
@__UNIQUE_ID_license93 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__UNIQUE_ID_version94 = internal constant [12 x i8] c"version=0.6\00", section ".modinfo", align 1
@__param_str_debug = internal constant [6 x i8] c"debug\00", align 1
@param_ops_int = external global %struct.kernel_param_ops, align 8
@debug = internal global i32 0, align 4
@__param_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_debug, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 0, i16 -1, %union.anon.6 { i8* bitcast (i32* @debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_debugtype97 = internal constant [19 x i8] c"parmtype=debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_debug99 = internal constant [87 x i8] c"parm=debug:set this to 1 (and RTFM) if you want to help the development of this driver\00", section ".modinfo", align 1
@__param_str_no_spic = internal constant [8 x i8] c"no_spic\00", align 1
@no_spic = internal global i32 0, align 4
@__param_no_spic = internal constant %struct.kernel_param { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @__param_str_no_spic, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.6 { i8* bitcast (i32* @no_spic to i8*) } }, section "__param", align 8
@__UNIQUE_ID_no_spictype102 = internal constant [21 x i8] c"parmtype=no_spic:int\00", section ".modinfo", align 1
@__UNIQUE_ID_no_spic104 = internal constant [66 x i8] c"parm=no_spic:set this if you don't want to enable the SPIC device\00", section ".modinfo", align 1
@__param_str_compat = internal constant [7 x i8] c"compat\00", align 1
@compat = internal global i32 0, align 4
@__param_compat = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_compat, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.6 { i8* bitcast (i32* @compat to i8*) } }, section "__param", align 8
@__UNIQUE_ID_compattype107 = internal constant [20 x i8] c"parmtype=compat:int\00", section ".modinfo", align 1
@__UNIQUE_ID_compat109 = internal constant [71 x i8] c"parm=compat:set this if you want to enable backward compatibility mode\00", section ".modinfo", align 1
@__param_str_mask = internal constant [5 x i8] c"mask\00", align 1
@param_ops_ulong = external global %struct.kernel_param_ops, align 8
@mask = internal global i64 4294967295, align 8
@__param_mask = internal constant %struct.kernel_param { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @__param_str_mask, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_ulong, i16 420, i16 -1, %union.anon.6 { i8* bitcast (i64* @mask to i8*) } }, section "__param", align 8
@__UNIQUE_ID_masktype112 = internal constant [20 x i8] c"parmtype=mask:ulong\00", section ".modinfo", align 1
@__UNIQUE_ID_mask114 = internal constant [69 x i8] c"parm=mask:set this to the mask of event you want to enable (see doc)\00", section ".modinfo", align 1
@__param_str_camera = internal constant [7 x i8] c"camera\00", align 1
@camera = internal global i32 0, align 4
@__param_camera = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_camera, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.6 { i8* bitcast (i32* @camera to i8*) } }, section "__param", align 8
@__UNIQUE_ID_cameratype117 = internal constant [20 x i8] c"parmtype=camera:int\00", section ".modinfo", align 1
@__UNIQUE_ID_camera120 = internal constant [110 x i8] c"parm=camera:set this to 1 to enable Motion Eye camera controls (only use it if you have a C1VE or C1VN model)\00", section ".modinfo", align 1
@__param_str_minor = internal constant [6 x i8] c"minor\00", align 1
@minor = internal global i32 -1, align 4
@__param_minor = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_minor, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 0, i16 -1, %union.anon.6 { i8* bitcast (i32* @minor to i8*) } }, section "__param", align 8
@__UNIQUE_ID_minortype124 = internal constant [19 x i8] c"parmtype=minor:int\00", section ".modinfo", align 1
@__UNIQUE_ID_minor127 = internal constant [102 x i8] c"parm=minor:minor number of the misc device for the SPIC compatibility code, default is -1 (automatic)\00", section ".modinfo", align 1
@__param_str_kbd_backlight = internal constant [14 x i8] c"kbd_backlight\00", align 1
@kbd_backlight = internal global i32 1, align 4
@__param_kbd_backlight = internal constant %struct.kernel_param { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__param_str_kbd_backlight, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.6 { i8* bitcast (i32* @kbd_backlight to i8*) } }, section "__param", align 8
@__UNIQUE_ID_kbd_backlighttype131 = internal constant [27 x i8] c"parmtype=kbd_backlight:int\00", section ".modinfo", align 1
@__UNIQUE_ID_kbd_backlight134 = internal constant [92 x i8] c"parm=kbd_backlight:set this to 0 to disable keyboard backlight, 1 to enable it (default: 0)\00", section ".modinfo", align 1
@__param_str_kbd_backlight_timeout = internal constant [22 x i8] c"kbd_backlight_timeout\00", align 16
@kbd_backlight_timeout = internal global i32 0, align 4
@__param_kbd_backlight_timeout = internal constant %struct.kernel_param { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__param_str_kbd_backlight_timeout, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.6 { i8* bitcast (i32* @kbd_backlight_timeout to i8*) } }, section "__param", align 8
@__UNIQUE_ID_kbd_backlight_timeouttype137 = internal constant [35 x i8] c"parmtype=kbd_backlight_timeout:int\00", section ".modinfo", align 1
@__UNIQUE_ID_kbd_backlight_timeout141 = internal constant [153 x i8] c"parm=kbd_backlight_timeout:set this to 0 to set the default 10 seconds timeout, 1 for 30 seconds, 2 for 60 seconds and 3 to disable timeout (default: 0)\00", section ".modinfo", align 1
@spic_dev = internal global %struct.sony_pic_dev { %struct.acpi_device* null, %struct.sony_pic_irq* null, %struct.sony_pic_ioport* null, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 24) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 24) to %struct.list_head*) }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 40) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 40) to %struct.list_head*) }, %struct.mutex zeroinitializer, %struct.sonypi_eventtypes* null, i32 (i8, i8)* null, i32 0, i16 0, i8 0, i8 0, i8 0 }, align 8
@.str = private unnamed_addr constant [52 x i8] c"\014sony_laptop: command failed at %s : %s (line %d)\0A\00", align 1
@.str.1 = private unnamed_addr constant [35 x i8] c"drivers/platform/x86/sony-laptop.c\00", align 1
@__func__.sony_pic_camera_command = private unnamed_addr constant [24 x i8] c"sony_pic_camera_command\00", align 1
@.str.2 = private unnamed_addr constant [52 x i8] c"\013sony_laptop: sony_pic_camera_command invalid: %d\0A\00", align 1
@__crc_sony_pic_camera_command = extern_weak global i8*, align 8
@__kcrctab_sony_pic_camera_command = internal constant i64 ptrtoint (i8** @__crc_sony_pic_camera_command to i64), section "___kcrctab+sony_pic_camera_command", align 8
@__kstrtab_sony_pic_camera_command = internal constant [24 x i8] c"sony_pic_camera_command\00", section "__ksymtab_strings", align 1
@__ksymtab_sony_pic_camera_command = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, i8)* @sony_pic_camera_command to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_sony_pic_camera_command, i32 0, i32 0) }, section "___ksymtab+sony_pic_camera_command", align 8
@sony_bl_props = common global %struct.sony_backlight_props zeroinitializer, align 8
@smp_ops = external global %struct.smp_ops, align 8
@pv_irq_ops = external global %struct.pv_irq_ops, align 8
@.str.3 = private unnamed_addr constant [60 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/paravirt.h\00", align 1
@current_task = external global %struct.task_struct*, align 8
@sony_device_ids = internal constant [3 x %struct.acpi_device_id] [%struct.acpi_device_id { [9 x i8] c"SNY5001\00\00", i64 0 }, %struct.acpi_device_id { [9 x i8] c"SNY6001\00\00", i64 0 }, %struct.acpi_device_id zeroinitializer], align 16
@.str.5 = private unnamed_addr constant [43 x i8] c"\014sony_laptop: camera control not enabled\0A\00", align 1
@.str.6 = private unnamed_addr constant [42 x i8] c"\014sony_laptop: failed to power on camera\0A\00", align 1
@__func__.__sony_pic_camera_on = private unnamed_addr constant [21 x i8] c"__sony_pic_camera_on\00", align 1
@__func__.sony_pic_call2 = private unnamed_addr constant [15 x i8] c"sony_pic_call2\00", align 1
@.str.7 = private unnamed_addr constant [56 x i8] c"\014sony_laptop: sony_pic_call2(0x%.2x - 0x%.2x): 0x%.4x\0A\00", align 1
@pv_cpu_ops = external global %struct.pv_cpu_ops, align 8
@__func__.sony_pic_call1 = private unnamed_addr constant [15 x i8] c"sony_pic_call1\00", align 1
@.str.8 = private unnamed_addr constant [47 x i8] c"\014sony_laptop: sony_pic_call1(0x%.2x): 0x%.4x\0A\00", align 1
@__func__.__sony_pic_camera_off = private unnamed_addr constant [22 x i8] c"__sony_pic_camera_off\00", align 1
@__func__.sony_pic_call3 = private unnamed_addr constant [15 x i8] c"sony_pic_call3\00", align 1
@.str.9 = private unnamed_addr constant [65 x i8] c"\014sony_laptop: sony_pic_call3(0x%.2x - 0x%.2x - 0x%.2x): 0x%.4x\0A\00", align 1
@sony_pic_driver = internal global %struct.acpi_driver { [80 x i8] c"Sony Programmable IO Control Driver\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [80 x i8] c"sony-pic\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", %struct.acpi_device_id* getelementptr inbounds ([2 x %struct.acpi_device_id], [2 x %struct.acpi_device_id]* @sony_pic_device_ids, i32 0, i32 0), i32 0, %struct.acpi_device_ops { i32 (%struct.acpi_device*)* @sony_pic_add, i32 (%struct.acpi_device*)* @sony_pic_remove, void (%struct.acpi_device*, i32)* null }, %struct.device_driver { i8* null, %struct.bus_type* null, %struct.module* null, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* @sony_pic_pm, %struct.driver_private* null }, %struct.module* @__this_module }, align 8
@.str.10 = private unnamed_addr constant [47 x i8] c"\013sony_laptop: Unable to register SPIC driver\0A\00", align 1
@spic_drv_registered = internal global i32 0, align 4
@sony_nc_driver = internal global %struct.acpi_driver { [80 x i8] c"Sony Notebook Control Driver\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [80 x i8] c"sony-nc\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", %struct.acpi_device_id* getelementptr inbounds ([2 x %struct.acpi_device_id], [2 x %struct.acpi_device_id]* @sony_nc_device_ids, i32 0, i32 0), i32 0, %struct.acpi_device_ops { i32 (%struct.acpi_device*)* @sony_nc_add, i32 (%struct.acpi_device*)* @sony_nc_remove, void (%struct.acpi_device*, i32)* @sony_nc_notify }, %struct.device_driver { i8* null, %struct.bus_type* null, %struct.module* null, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* @sony_nc_pm, %struct.driver_private* null }, %struct.module* @__this_module }, align 8
@.str.11 = private unnamed_addr constant [46 x i8] c"\013sony_laptop: Unable to register SNC driver\0A\00", align 1
@.str.12 = private unnamed_addr constant [10 x i8] c"Sony Vaio\00", align 1
@sonypi_dmi_table = internal global <{ { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } }> <{ { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } { i32 (%struct.dmi_system_id*)* null, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12, i32 0, i32 0), [4 x %struct.dmi_strmatch] [%struct.dmi_strmatch { i8 4, [79 x i8] c"Sony Corporation\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch { i8 5, [79 x i8] c"PCG-\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch zeroinitializer, %struct.dmi_strmatch zeroinitializer], i8* null }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } { i32 (%struct.dmi_system_id*)* null, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12, i32 0, i32 0), [4 x %struct.dmi_strmatch] [%struct.dmi_strmatch { i8 4, [79 x i8] c"Sony Corporation\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch { i8 5, [79 x i8] c"VGN-\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch zeroinitializer, %struct.dmi_strmatch zeroinitializer], i8* null }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } zeroinitializer }>, section ".init.data", align 16
@sony_pic_device_ids = internal constant [2 x %struct.acpi_device_id] [%struct.acpi_device_id { [9 x i8] c"SNY6001\00\00", i64 0 }, %struct.acpi_device_id zeroinitializer], align 16
@sony_pic_pm = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* @sony_pic_suspend, i32 (%struct.device*)* @sony_pic_resume, i32 (%struct.device*)* @sony_pic_suspend, i32 (%struct.device*)* @sony_pic_resume, i32 (%struct.device*)* @sony_pic_suspend, i32 (%struct.device*)* @sony_pic_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null }, align 8
@__this_module = external global %struct.module, align 8
@.str.14 = private unnamed_addr constant [23 x i8] c"\016sony_laptop: %s v%s\0A\00", align 1
@.str.15 = private unnamed_addr constant [36 x i8] c"Sony Programmable IO Control Driver\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"0.6\00", align 1
@.str.17 = private unnamed_addr constant [12 x i8] c"sony/hotkey\00", align 1
@sony_pic_add.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.18 = private unnamed_addr constant [15 x i8] c"&spic_dev.lock\00", align 1
@.str.19 = private unnamed_addr constant [50 x i8] c"\013sony_laptop: Unable to read possible resources\0A\00", align 1
@.str.20 = private unnamed_addr constant [47 x i8] c"\013sony_laptop: Unable to create input devices\0A\00", align 1
@ioport_resource = external global %struct.resource, align 8
@.str.21 = private unnamed_addr constant [29 x i8] c"Sony Programmable I/O Device\00", align 1
@.str.22 = private unnamed_addr constant [52 x i8] c"\014sony_laptop: I/O port1: 0x%.4x (0x%.4x) + 0x%.2x\0A\00", align 1
@.str.23 = private unnamed_addr constant [52 x i8] c"\014sony_laptop: I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\0A\00", align 1
@.str.24 = private unnamed_addr constant [66 x i8] c"\014sony_laptop: Unable to get I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\0A\00", align 1
@.str.25 = private unnamed_addr constant [41 x i8] c"\013sony_laptop: Failed to request_region\0A\00", align 1
@.str.26 = private unnamed_addr constant [12 x i8] c"sony-laptop\00", align 1
@.str.27 = private unnamed_addr constant [66 x i8] c"\014sony_laptop: IRQ: %d - triggering: %d - polarity: %d - shr: %d\0A\00", align 1
@.str.28 = private unnamed_addr constant [38 x i8] c"\013sony_laptop: Failed to request_irq\0A\00", align 1
@.str.29 = private unnamed_addr constant [39 x i8] c"\013sony_laptop: Couldn't enable device\0A\00", align 1
@sony_pf_device = internal global %struct.platform_device* null, align 8
@spic_attribute_group = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([4 x %struct.attribute*], [4 x %struct.attribute*]* @spic_attributes, i32 0, i32 0) }, align 8
@type1_events = internal global [11 x %struct.sonypi_eventtypes] [%struct.sonypi_eventtypes { i8 0, i64 4294967295, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_releaseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 112, i64 1024, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_meyeev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 48, i64 128, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_lidev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 96, i64 2, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_captureev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 16, i64 1, %struct.sonypi_event* getelementptr inbounds ([14 x %struct.sonypi_event], [14 x %struct.sonypi_event]* @sonypi_joggerev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 32, i64 4, %struct.sonypi_event* getelementptr inbounds ([23 x %struct.sonypi_event], [23 x %struct.sonypi_event]* @sonypi_fnkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 48, i64 8, %struct.sonypi_event* getelementptr inbounds ([4 x %struct.sonypi_event], [4 x %struct.sonypi_event]* @sonypi_blueev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 64, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 48, i64 2048, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_memorystickev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 64, i64 4096, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_batteryev, i32 0, i32 0) }, %struct.sonypi_eventtypes zeroinitializer], align 16
@type2_events = internal global [15 x %struct.sonypi_eventtypes] [%struct.sonypi_eventtypes { i8 0, i64 4294967295, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_releaseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 56, i64 128, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_lidev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 17, i64 1, %struct.sonypi_event* getelementptr inbounds ([14 x %struct.sonypi_event], [14 x %struct.sonypi_event]* @sonypi_joggerev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 97, i64 2, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_captureev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 4, %struct.sonypi_event* getelementptr inbounds ([23 x %struct.sonypi_event], [23 x %struct.sonypi_event]* @sonypi_fnkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 8, %struct.sonypi_event* getelementptr inbounds ([4 x %struct.sonypi_event], [4 x %struct.sonypi_event]* @sonypi_blueev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 8, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 17, i64 32, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_backev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 64, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_helpev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 256, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_zoomev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 32, i64 512, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_thumbphraseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 2048, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_memorystickev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 65, i64 4096, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_batteryev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes zeroinitializer], align 16
@type3_events = internal global [12 x %struct.sonypi_eventtypes] [%struct.sonypi_eventtypes { i8 0, i64 4294967295, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_releaseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 4, %struct.sonypi_event* getelementptr inbounds ([23 x %struct.sonypi_event], [23 x %struct.sonypi_event]* @sonypi_fnkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 8192, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_wlessev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 2048, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_memorystickev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 65, i64 4096, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_batteryev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 256, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_zoomev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 2, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_captureev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 16, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_volumeev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 16, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_brightnessev, i32 0, i32 0) }, %struct.sonypi_eventtypes zeroinitializer], align 16
@.str.30 = private unnamed_addr constant [38 x i8] c"\016sony_laptop: detected Type%d model\0A\00", align 1
@sonypi_releaseev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 0, i8 56 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_meyeev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 0, i8 52 }, %struct.sonypi_event { i8 1, i8 53 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_lidev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 81, i8 36 }, %struct.sonypi_event { i8 80, i8 37 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_captureev = internal global [5 x %struct.sonypi_event] [%struct.sonypi_event { i8 5, i8 9 }, %struct.sonypi_event { i8 7, i8 7 }, %struct.sonypi_event { i8 64, i8 7 }, %struct.sonypi_event { i8 1, i8 10 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_joggerev = internal global [14 x %struct.sonypi_event] [%struct.sonypi_event { i8 31, i8 2 }, %struct.sonypi_event { i8 1, i8 1 }, %struct.sonypi_event { i8 95, i8 4 }, %struct.sonypi_event { i8 65, i8 3 }, %struct.sonypi_event { i8 30, i8 43 }, %struct.sonypi_event { i8 2, i8 42 }, %struct.sonypi_event { i8 94, i8 45 }, %struct.sonypi_event { i8 66, i8 44 }, %struct.sonypi_event { i8 29, i8 47 }, %struct.sonypi_event { i8 3, i8 46 }, %struct.sonypi_event { i8 93, i8 49 }, %struct.sonypi_event { i8 67, i8 48 }, %struct.sonypi_event { i8 64, i8 5 }, %struct.sonypi_event zeroinitializer], align 16
@sonypi_fnkeyev = internal global [23 x %struct.sonypi_event] [%struct.sonypi_event { i8 16, i8 11 }, %struct.sonypi_event { i8 17, i8 12 }, %struct.sonypi_event { i8 18, i8 13 }, %struct.sonypi_event { i8 19, i8 14 }, %struct.sonypi_event { i8 20, i8 15 }, %struct.sonypi_event { i8 21, i8 16 }, %struct.sonypi_event { i8 22, i8 17 }, %struct.sonypi_event { i8 23, i8 18 }, %struct.sonypi_event { i8 24, i8 19 }, %struct.sonypi_event { i8 25, i8 20 }, %struct.sonypi_event { i8 26, i8 21 }, %struct.sonypi_event { i8 27, i8 22 }, %struct.sonypi_event { i8 28, i8 23 }, %struct.sonypi_event { i8 31, i8 59 }, %struct.sonypi_event { i8 33, i8 24 }, %struct.sonypi_event { i8 34, i8 25 }, %struct.sonypi_event { i8 49, i8 26 }, %struct.sonypi_event { i8 50, i8 27 }, %struct.sonypi_event { i8 51, i8 28 }, %struct.sonypi_event { i8 52, i8 29 }, %struct.sonypi_event { i8 53, i8 30 }, %struct.sonypi_event { i8 54, i8 41 }, %struct.sonypi_event zeroinitializer], align 16
@sonypi_blueev = internal global [4 x %struct.sonypi_event] [%struct.sonypi_event { i8 85, i8 31 }, %struct.sonypi_event { i8 89, i8 38 }, %struct.sonypi_event { i8 90, i8 39 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_pkeyev = internal global [5 x %struct.sonypi_event] [%struct.sonypi_event { i8 1, i8 32 }, %struct.sonypi_event { i8 2, i8 33 }, %struct.sonypi_event { i8 4, i8 34 }, %struct.sonypi_event { i8 32, i8 32 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_memorystickev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 83, i8 54 }, %struct.sonypi_event { i8 84, i8 55 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_batteryev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 32, i8 57 }, %struct.sonypi_event { i8 48, i8 58 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_backev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 32, i8 35 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_helpev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 59, i8 40 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_zoomev = internal global [5 x %struct.sonypi_event] [%struct.sonypi_event { i8 57, i8 50 }, %struct.sonypi_event { i8 16, i8 62 }, %struct.sonypi_event { i8 32, i8 63 }, %struct.sonypi_event { i8 4, i8 50 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_thumbphraseev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 58, i8 51 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_wlessev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 89, i8 0 }, %struct.sonypi_event { i8 90, i8 0 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_volumeev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 1, i8 69 }, %struct.sonypi_event { i8 2, i8 70 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_brightnessev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 -128, i8 71 }, %struct.sonypi_event zeroinitializer], align 1
@.str.31 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Evaluating _STA\0A\00", align 1
@.str.32 = private unnamed_addr constant [38 x i8] c"\014sony_laptop: Unable to read status\0A\00", align 1
@.str.33 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Device disabled\0A\00", align 1
@.str.34 = private unnamed_addr constant [31 x i8] c"\014sony_laptop: Device enabled\0A\00", align 1
@.str.35 = private unnamed_addr constant [30 x i8] c"\014sony_laptop: Evaluating %s\0A\00", align 1
@.str.36 = private unnamed_addr constant [5 x i8] c"_PRS\00", align 1
@.str.37 = private unnamed_addr constant [38 x i8] c"\014sony_laptop: Failure evaluating %s\0A\00", align 1
@.str.38 = private unnamed_addr constant [35 x i8] c"\014sony_laptop: Blank IRQ resource\0A\00", align 1
@.str.39 = private unnamed_addr constant [31 x i8] c"\014sony_laptop: Invalid IRQ %d\0A\00", align 1
@.str.40 = private unnamed_addr constant [34 x i8] c"\014sony_laptop: Blank IO resource\0A\00", align 1
@.str.41 = private unnamed_addr constant [39 x i8] c"\014sony_laptop: IO1 at 0x%.4x (0x%.2x)\0A\00", align 1
@.str.42 = private unnamed_addr constant [39 x i8] c"\014sony_laptop: IO2 at 0x%.4x (0x%.2x)\0A\00", align 1
@.str.43 = private unnamed_addr constant [56 x i8] c"\013sony_laptop: Unknown SPIC Type, more than 2 IO Ports\0A\00", align 1
@.str.44 = private unnamed_addr constant [56 x i8] c"\014sony_laptop: Resource %d isn't an IRQ nor an IO port\0A\00", align 1
@sony_laptop_input = internal global %struct.sony_laptop_input_s zeroinitializer, align 8
@sony_laptop_setup_input.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.45 = private unnamed_addr constant [39 x i8] c"&(&sony_laptop_input.fifo_lock)->rlock\00", align 1
@.str.46 = private unnamed_addr constant [35 x i8] c"\013sony_laptop: kfifo_alloc failed\0A\00", align 1
@sony_laptop_setup_input.__key.47 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.48 = private unnamed_addr constant [41 x i8] c"((&sony_laptop_input.release_key_timer))\00", align 1
@.str.49 = private unnamed_addr constant [15 x i8] c"Sony Vaio Keys\00", align 1
@sony_laptop_input_keycode_map = internal global [60 x i32] [i32 212, i32 0, i32 0, i32 0, i32 465, i32 466, i32 467, i32 468, i32 469, i32 470, i32 471, i32 472, i32 473, i32 474, i32 475, i32 476, i32 477, i32 466, i32 467, i32 480, i32 481, i32 482, i32 483, i32 484, i32 237, i32 148, i32 149, i32 202, i32 158, i32 237, i32 237, i32 138, i32 464, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 372, i32 289, i32 0, i32 0, i32 0, i32 0, i32 238, i32 238, i32 418, i32 419, i32 161, i32 183, i32 203, i32 184, i32 185, i32 115, i32 114, i32 226, i32 360], align 16
@.str.50 = private unnamed_addr constant [18 x i8] c"Sony Vaio Jogdial\00", align 1
@jiffies = external global i64, align 8
@sonypi_compat = internal global %struct.sonypi_compat_s zeroinitializer, align 8
@sonypi_compat_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.51 = private unnamed_addr constant [35 x i8] c"&(&sonypi_compat.fifo_lock)->rlock\00", align 1
@sonypi_compat_init.__key.52 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.53 = private unnamed_addr constant [30 x i8] c"&sonypi_compat.fifo_proc_list\00", align 1
@sonypi_misc_device = internal global %struct.miscdevice { i32 255, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.56, i32 0, i32 0), %struct.file_operations* @sonypi_misc_fops, %struct.list_head zeroinitializer, %struct.device* null, %struct.device* null, i8* null, i16 0 }, align 8
@.str.54 = private unnamed_addr constant [37 x i8] c"\013sony_laptop: misc_register failed\0A\00", align 1
@.str.55 = private unnamed_addr constant [45 x i8] c"\016sony_laptop: device allocated minor is %d\0A\00", align 1
@.str.56 = private unnamed_addr constant [7 x i8] c"sonypi\00", align 1
@sonypi_misc_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @noop_llseek, i64 (%struct.file*, i8*, i64, i64*)* @sonypi_misc_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @sonypi_misc_poll, i64 (%struct.file*, i32, i64)* @sonypi_misc_ioctl, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @sonypi_misc_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @sonypi_misc_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* @sonypi_misc_fasync, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@sony_nc_acpi_handle = internal global i8* null, align 8
@.str.57 = private unnamed_addr constant [5 x i8] c"GBRT\00", align 1
@.str.58 = private unnamed_addr constant [5 x i8] c"SBRT\00", align 1
@.str.59 = private unnamed_addr constant [60 x i8] c"\014sony_laptop: Invalid acpi_object: expected 0x%x got 0x%x\0A\00", align 1
@__call_snc_method.output = private unnamed_addr constant %struct.acpi_buffer { i64 -1, i8* null }, align 8
@.str.60 = private unnamed_addr constant [51 x i8] c"\014sony_laptop: __call_snc_method: [%s:0x%.8x%.8x]\0A\00", align 1
@.str.61 = private unnamed_addr constant [40 x i8] c"\014sony_laptop: __call_snc_method: [%s]\0A\00", align 1
@.str.62 = private unnamed_addr constant [40 x i8] c"\013sony_laptop: Failed to evaluate [%s]\0A\00", align 1
@.str.63 = private unnamed_addr constant [38 x i8] c"\014sony_laptop: No return object [%s]\0A\00", align 1
@.str.64 = private unnamed_addr constant [62 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/uaccess_64.h\00", align 1
@.str.65 = private unnamed_addr constant [27 x i8] c"Buffer overflow detected!\0A\00", align 1
@.str.66 = private unnamed_addr constant [62 x i8] c"\014sony_laptop: event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\0A\00", align 1
@.str.67 = private unnamed_addr constant [70 x i8] c"\014sony_laptop: unknown event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\0A\00", align 1
@.str.68 = private unnamed_addr constant [68 x i8] c"\014sony_laptop: sony_laptop_report_input_event, event not known: %d\0A\00", align 1
@sony_laptop_input_index = internal global [74 x i32] [i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 -1, i32 -1, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 -1, i32 -1, i32 -1, i32 -1, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 -1, i32 58, i32 59], align 16
@.str.69 = private unnamed_addr constant [41 x i8] c"\014sony_laptop: unknown input event %.2x\0A\00", align 1
@.str.70 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Evaluating _SRS\0A\00", align 1
@.str.71 = private unnamed_addr constant [38 x i8] c"\013sony_laptop: Error evaluating _SRS\0A\00", align 1
@sony_pf_users = internal global %struct.atomic_t zeroinitializer, align 4
@sony_pf_driver = internal global %struct.platform_driver { i32 (%struct.platform_device*)* null, i32 (%struct.platform_device*)* null, void (%struct.platform_device*)* null, i32 (%struct.platform_device*, i32)* null, i32 (%struct.platform_device*)* null, %struct.device_driver { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.26, i32 0, i32 0), %struct.bus_type* null, %struct.module* @__this_module, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.platform_device_id* null }, align 8
@spic_attributes = internal global [4 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @spic_attr_bluetoothpower, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @spic_attr_wwanpower, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @spic_attr_fanspeed, i32 0, i32 0), %struct.attribute* null], align 16
@spic_attr_bluetoothpower = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.72, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_pic_bluetoothpower_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_pic_bluetoothpower_store }, align 8
@spic_attr_wwanpower = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.74, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_pic_wwanpower_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_pic_wwanpower_store }, align 8
@spic_attr_fanspeed = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.75, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_pic_fanspeed_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_pic_fanspeed_store }, align 8
@.str.72 = private unnamed_addr constant [15 x i8] c"bluetoothpower\00", align 1
@.str.73 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.74 = private unnamed_addr constant [10 x i8] c"wwanpower\00", align 1
@.str.75 = private unnamed_addr constant [9 x i8] c"fanspeed\00", align 1
@.str.76 = private unnamed_addr constant [5 x i8] c"_DIS\00", align 1
@.str.77 = private unnamed_addr constant [40 x i8] c"\013sony_laptop: Couldn't disable device\0A\00", align 1
@.str.78 = private unnamed_addr constant [61 x i8] c"\014sony_laptop: Sony Programmable IO Control Driver removed.\0A\00", align 1
@sony_nc_device_ids = internal constant [2 x %struct.acpi_device_id] [%struct.acpi_device_id { [9 x i8] c"SNY5001\00\00", i64 0 }, %struct.acpi_device_id zeroinitializer], align 16
@sony_nc_pm = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* @sony_nc_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* @sony_nc_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* @sony_nc_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null }, align 8
@.str.79 = private unnamed_addr constant [29 x i8] c"Sony Notebook Control Driver\00", align 1
@sony_nc_acpi_device = internal global %struct.acpi_device* null, align 8
@.str.80 = private unnamed_addr constant [35 x i8] c"\014sony_laptop: Device not present\0A\00", align 1
@.str.81 = private unnamed_addr constant [46 x i8] c"\014sony_laptop: unable to walk acpi resources\0A\00", align 1
@.str.82 = private unnamed_addr constant [5 x i8] c"ECON\00", align 1
@.str.83 = private unnamed_addr constant [35 x i8] c"\014sony_laptop: ECON Method failed\0A\00", align 1
@.str.84 = private unnamed_addr constant [5 x i8] c"SN00\00", align 1
@.str.85 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Doing SNC setup\0A\00", align 1
@.str.86 = private unnamed_addr constant [76 x i8] c"\016sony_laptop: brightness ignored, must be controlled by ACPI video driver\0A\00", align 1
@sony_nc_values = internal global [13 x %struct.sony_nc_value] [%struct.sony_nc_value { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.147, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_brightness_def_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_brightness_def_set, i32 0, i32 0), i32 (i32, i32)* @brightness_default_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.147, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.148, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_fnkey_get, i32 0, i32 0), i8** null, i32 (i32, i32)* null, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.148, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.149, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_cdpower_get, i32 0, i32 0), i8** getelementptr inbounds ([3 x i8*], [3 x i8*]* @snc_cdpower_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.149, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.150, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_audiopower_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_audiopower_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.150, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.151, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_lanpower_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_lanpower_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.151, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.152, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_lidstate_get, i32 0, i32 0), i8** null, i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.152, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.153, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_indicatorlamp_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_indicatorlamp_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.153, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.154, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_gainbass_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_gainbass_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.154, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.155, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_PID_get, i32 0, i32 0), i8** null, i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.155, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.156, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CTR_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CTR_set, i32 0, i32 0), i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.156, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.157, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_PCR_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_PCR_set, i32 0, i32 0), i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.157, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.158, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CMI_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CMI_set, i32 0, i32 0), i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.158, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value zeroinitializer], align 16
@.str.87 = private unnamed_addr constant [36 x i8] c"\014sony_laptop: Found %s getter: %s\0A\00", align 1
@.str.88 = private unnamed_addr constant [36 x i8] c"\014sony_laptop: Found %s setter: %s\0A\00", align 1
@.str.89 = private unnamed_addr constant [45 x i8] c"\014sony_laptop: method: name: %4.4s, args %X\0A\00", align 1
@handles = internal global %struct.sony_nc_handles* null, align 8
@.str.90 = private unnamed_addr constant [55 x i8] c"\014sony_laptop: caching handle 0x%.4x (offset: 0x%.2x)\0A\00", align 1
@sony_nc_handles_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.91 = private unnamed_addr constant [8 x i8] c"handles\00", align 1
@.str.92 = private unnamed_addr constant [8 x i8] c"0x%.4x \00", align 1
@.str.93 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.94 = private unnamed_addr constant [41 x i8] c"\014sony_laptop: setting up handle 0x%.4x\0A\00", align 1
@.str.95 = private unnamed_addr constant [63 x i8] c"\013sony_laptop: couldn't set up touchpad control function (%d)\0A\00", align 1
@.str.96 = private unnamed_addr constant [59 x i8] c"\013sony_laptop: couldn't set up battery care function (%d)\0A\00", align 1
@.str.97 = private unnamed_addr constant [57 x i8] c"\013sony_laptop: couldn't set up lid resume function (%d)\0A\00", align 1
@.str.98 = private unnamed_addr constant [62 x i8] c"\013sony_laptop: couldn't set up thermal profile function (%d)\0A\00", align 1
@.str.99 = private unnamed_addr constant [55 x i8] c"\013sony_laptop: couldn't set up GFX Switch status (%d)\0A\00", align 1
@.str.100 = private unnamed_addr constant [66 x i8] c"\013sony_laptop: couldn't set up high speed charging function (%d)\0A\00", align 1
@.str.101 = private unnamed_addr constant [52 x i8] c"\013sony_laptop: couldn't set up rfkill support (%d)\0A\00", align 1
@.str.102 = private unnamed_addr constant [65 x i8] c"\013sony_laptop: couldn't set up keyboard backlight function (%d)\0A\00", align 1
@.str.103 = private unnamed_addr constant [5 x i8] c"SN02\00", align 1
@.str.104 = private unnamed_addr constant [5 x i8] c"SN07\00", align 1
@.str.105 = private unnamed_addr constant [57 x i8] c"\014sony_laptop: called SN07 with 0x%.4x (result: 0x%.4x)\0A\00", align 1
@.str.106 = private unnamed_addr constant [53 x i8] c"\014sony_laptop: found handle 0x%.4x (offset: 0x%.2x)\0A\00", align 1
@.str.107 = private unnamed_addr constant [40 x i8] c"\014sony_laptop: handle 0x%.4x not found\0A\00", align 1
@tp_ctl = internal global %struct.touchpad_control* null, align 8
@sony_nc_touchpad_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.108 = private unnamed_addr constant [9 x i8] c"touchpad\00", align 1
@bcare_ctl = internal global %struct.battery_care_control* null, align 8
@sony_nc_battery_care_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.109 = private unnamed_addr constant [21 x i8] c"battery_care_limiter\00", align 1
@sony_nc_battery_care_setup.__key.110 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.111 = private unnamed_addr constant [20 x i8] c"battery_care_health\00", align 1
@lid_ctl = internal global %struct.snc_lid_resume_control* null, align 8
@sony_nc_lid_resume_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.112 = private unnamed_addr constant [14 x i8] c"lid_resume_S3\00", align 1
@sony_nc_lid_resume_setup.__key.113 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.114 = private unnamed_addr constant [14 x i8] c"lid_resume_S4\00", align 1
@sony_nc_lid_resume_setup.__key.115 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.116 = private unnamed_addr constant [14 x i8] c"lid_resume_S5\00", align 1
@th_handle = internal global %struct.snc_thermal_ctrl* null, align 8
@.str.117 = private unnamed_addr constant [54 x i8] c"\014sony_laptop: couldn't to read the thermal profiles\0A\00", align 1
@.str.118 = private unnamed_addr constant [60 x i8] c"\014sony_laptop: couldn't to read the current thermal profile\00", align 1
@sony_nc_thermal_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.119 = private unnamed_addr constant [17 x i8] c"thermal_profiles\00", align 1
@sony_nc_thermal_setup.__key.120 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.121 = private unnamed_addr constant [16 x i8] c"thermal_control\00", align 1
@.str.122 = private unnamed_addr constant [4 x i8] c"%s \00", align 1
@snc_thermal_profiles = internal constant [3 x i8*] [i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.123, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.124, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.125, i32 0, i32 0)], align 16
@.str.123 = private unnamed_addr constant [9 x i8] c"balanced\00", align 1
@.str.124 = private unnamed_addr constant [7 x i8] c"silent\00", align 1
@.str.125 = private unnamed_addr constant [12 x i8] c"performance\00", align 1
@.str.126 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@gfxs_ctl = internal global %struct.snc_gfx_switch_control* null, align 8
@sony_nc_gfx_switch_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.127 = private unnamed_addr constant [18 x i8] c"gfx_switch_status\00", align 1
@.str.128 = private unnamed_addr constant [6 x i8] c"speed\00", align 1
@.str.129 = private unnamed_addr constant [8 x i8] c"stamina\00", align 1
@.str.130 = private unnamed_addr constant [33 x i8] c"\014sony_laptop: GFX Status: 0x%x\0A\00", align 1
@.str.131 = private unnamed_addr constant [56 x i8] c"\016sony_laptop: No High Speed Charging capability found\0A\00", align 1
@hsc_handle = internal global %struct.device_attribute* null, align 8
@sony_nc_highspeed_charging_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.132 = private unnamed_addr constant [27 x i8] c"battery_highspeed_charging\00", align 1
@sony_rfkill_handle = internal global i32 0, align 4
@.str.133 = private unnamed_addr constant [5 x i8] c"SN06\00", align 1
@.str.134 = private unnamed_addr constant [44 x i8] c"\014sony_laptop: Radio devices, found 0x%.2x\0A\00", align 1
@sony_rfkill_devices = internal global [4 x %struct.rfkill*] zeroinitializer, align 16
@.str.135 = private unnamed_addr constant [10 x i8] c"sony-wifi\00", align 1
@.str.136 = private unnamed_addr constant [15 x i8] c"sony-bluetooth\00", align 1
@.str.137 = private unnamed_addr constant [10 x i8] c"sony-wwan\00", align 1
@.str.138 = private unnamed_addr constant [11 x i8] c"sony-wimax\00", align 1
@sony_rfkill_ops = internal constant %struct.rfkill_ops { void (%struct.rfkill*, i8*)* null, void (%struct.rfkill*, i8*)* null, i32 (i8*, i1)* @sony_nc_rfkill_set }, align 8
@sony_rfkill_address = internal global [4 x i32] [i32 768, i32 1280, i32 1792, i32 2304], align 16
@.str.139 = private unnamed_addr constant [44 x i8] c"\014sony_laptop: no backlight keyboard found\0A\00", align 1
@kbdbl_ctl = internal global %struct.kbd_backlight* null, align 8
@sony_nc_kbd_backlight_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.140 = private unnamed_addr constant [14 x i8] c"kbd_backlight\00", align 1
@sony_nc_kbd_backlight_setup.__key.141 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.142 = private unnamed_addr constant [22 x i8] c"kbd_backlight_timeout\00", align 1
@sony_backlight_ng_ops = internal constant %struct.backlight_ops { i32 1, i32 (%struct.backlight_device*)* @sony_nc_update_status_ng, i32 (%struct.backlight_device*)* @sony_nc_get_brightness_ng, i32 (%struct.backlight_device*, %struct.fb_info*)* null }, align 8
@sony_backlight_ops = internal constant %struct.backlight_ops { i32 1, i32 (%struct.backlight_device*)* @sony_backlight_update_status, i32 (%struct.backlight_device*)* @sony_backlight_get_brightness, i32 (%struct.backlight_device*, %struct.fb_info*)* null }, align 8
@.str.143 = private unnamed_addr constant [5 x i8] c"sony\00", align 1
@.str.144 = private unnamed_addr constant [52 x i8] c"\014sony_laptop: unable to register backlight device\0A\00", align 1
@.str.145 = private unnamed_addr constant [37 x i8] c"\014sony_laptop: Brightness level: %d\0A\00", align 1
@.str.146 = private unnamed_addr constant [49 x i8] c"\014sony_laptop: Brightness levels: min=%d max=%d\0A\00", align 1
@.str.147 = private unnamed_addr constant [19 x i8] c"brightness_default\00", align 1
@snc_brightness_def_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.159, i32 0, i32 0), i8* null], align 16
@snc_brightness_def_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.160, i32 0, i32 0), i8* null], align 16
@.str.148 = private unnamed_addr constant [6 x i8] c"fnkey\00", align 1
@snc_fnkey_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.161, i32 0, i32 0), i8* null], align 16
@.str.149 = private unnamed_addr constant [8 x i8] c"cdpower\00", align 1
@snc_cdpower_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.162, i32 0, i32 0), i8* null], align 16
@snc_cdpower_set = internal global [3 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.163, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.164, i32 0, i32 0), i8* null], align 16
@.str.150 = private unnamed_addr constant [11 x i8] c"audiopower\00", align 1
@snc_audiopower_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.165, i32 0, i32 0), i8* null], align 16
@snc_audiopower_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.166, i32 0, i32 0), i8* null], align 16
@.str.151 = private unnamed_addr constant [9 x i8] c"lanpower\00", align 1
@snc_lanpower_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.167, i32 0, i32 0), i8* null], align 16
@snc_lanpower_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.168, i32 0, i32 0), i8* null], align 16
@.str.152 = private unnamed_addr constant [9 x i8] c"lidstate\00", align 1
@snc_lidstate_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* null], align 16
@.str.153 = private unnamed_addr constant [14 x i8] c"indicatorlamp\00", align 1
@snc_indicatorlamp_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@snc_indicatorlamp_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.154 = private unnamed_addr constant [9 x i8] c"gainbass\00", align 1
@snc_gainbass_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.172, i32 0, i32 0), i8* null], align 16
@snc_gainbass_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.173, i32 0, i32 0), i8* null], align 16
@.str.155 = private unnamed_addr constant [4 x i8] c"PID\00", align 1
@snc_PID_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.174, i32 0, i32 0), i8* null], align 16
@.str.156 = private unnamed_addr constant [4 x i8] c"CTR\00", align 1
@snc_CTR_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.175, i32 0, i32 0), i8* null], align 16
@snc_CTR_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.176, i32 0, i32 0), i8* null], align 16
@.str.157 = private unnamed_addr constant [4 x i8] c"PCR\00", align 1
@snc_PCR_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.177, i32 0, i32 0), i8* null], align 16
@snc_PCR_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.178, i32 0, i32 0), i8* null], align 16
@.str.158 = private unnamed_addr constant [4 x i8] c"CMI\00", align 1
@snc_CMI_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.179, i32 0, i32 0), i8* null], align 16
@snc_CMI_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.180, i32 0, i32 0), i8* null], align 16
@.str.159 = private unnamed_addr constant [5 x i8] c"GPBR\00", align 1
@.str.160 = private unnamed_addr constant [5 x i8] c"SPBR\00", align 1
@.str.161 = private unnamed_addr constant [5 x i8] c"GHKE\00", align 1
@.str.162 = private unnamed_addr constant [5 x i8] c"GCDP\00", align 1
@.str.163 = private unnamed_addr constant [5 x i8] c"SCDP\00", align 1
@.str.164 = private unnamed_addr constant [5 x i8] c"CDPW\00", align 1
@.str.165 = private unnamed_addr constant [5 x i8] c"GAZP\00", align 1
@.str.166 = private unnamed_addr constant [5 x i8] c"AZPW\00", align 1
@.str.167 = private unnamed_addr constant [5 x i8] c"GLNP\00", align 1
@.str.168 = private unnamed_addr constant [5 x i8] c"LNPW\00", align 1
@.str.169 = private unnamed_addr constant [5 x i8] c"GLID\00", align 1
@.str.170 = private unnamed_addr constant [5 x i8] c"GILS\00", align 1
@.str.171 = private unnamed_addr constant [5 x i8] c"SILS\00", align 1
@.str.172 = private unnamed_addr constant [5 x i8] c"GMGB\00", align 1
@.str.173 = private unnamed_addr constant [5 x i8] c"CMGB\00", align 1
@.str.174 = private unnamed_addr constant [5 x i8] c"GPID\00", align 1
@.str.175 = private unnamed_addr constant [5 x i8] c"GCTR\00", align 1
@.str.176 = private unnamed_addr constant [5 x i8] c"SCTR\00", align 1
@.str.177 = private unnamed_addr constant [5 x i8] c"GPCR\00", align 1
@.str.178 = private unnamed_addr constant [5 x i8] c"SPCR\00", align 1
@.str.179 = private unnamed_addr constant [5 x i8] c"GCMI\00", align 1
@.str.180 = private unnamed_addr constant [5 x i8] c"SCMI\00", align 1
@.str.181 = private unnamed_addr constant [5 x i8] c"SN01\00", align 1
@.str.182 = private unnamed_addr constant [5 x i8] c"SN03\00", align 1
@.str.183 = private unnamed_addr constant [54 x i8] c"\014sony_laptop: Sony Notebook Control Driver removed.\0A\00", align 1
@.str.184 = private unnamed_addr constant [46 x i8] c"\014sony_laptop: sony_nc_notify, event: 0x%.2x\0A\00", align 1
@.str.185 = private unnamed_addr constant [56 x i8] c"\013sony_laptop: Event 0x%x outside of capabilities list\0A\00", align 1
@.str.186 = private unnamed_addr constant [55 x i8] c"\014sony_laptop: GFX switch event received (reason: %s)\0A\00", align 1
@.str.187 = private unnamed_addr constant [14 x i8] c"switch change\00", align 1
@.str.188 = private unnamed_addr constant [14 x i8] c"output switch\00", align 1
@.str.189 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.190 = private unnamed_addr constant [51 x i8] c"\014sony_laptop: Unknown event 0x%x for handle 0x%x\0A\00", align 1
@.str.191 = private unnamed_addr constant [5 x i8] c"SN05\00", align 1
@.str.192 = private unnamed_addr constant [53 x i8] c"\014sony_laptop: Unable to decode event 0x%.2x 0x%.2x\0A\00", align 1
@sony_100_events = internal global [41 x %struct.sony_nc_event] [%struct.sony_nc_event { i8 -112, i8 32 }, %struct.sony_nc_event { i8 16, i8 56 }, %struct.sony_nc_event { i8 -111, i8 33 }, %struct.sony_nc_event { i8 17, i8 56 }, %struct.sony_nc_event { i8 -127, i8 12 }, %struct.sony_nc_event { i8 1, i8 59 }, %struct.sony_nc_event { i8 -126, i8 13 }, %struct.sony_nc_event { i8 2, i8 59 }, %struct.sony_nc_event { i8 -125, i8 14 }, %struct.sony_nc_event { i8 3, i8 59 }, %struct.sony_nc_event { i8 -124, i8 15 }, %struct.sony_nc_event { i8 4, i8 59 }, %struct.sony_nc_event { i8 -123, i8 16 }, %struct.sony_nc_event { i8 5, i8 59 }, %struct.sony_nc_event { i8 -122, i8 17 }, %struct.sony_nc_event { i8 6, i8 59 }, %struct.sony_nc_event { i8 -121, i8 18 }, %struct.sony_nc_event { i8 7, i8 59 }, %struct.sony_nc_event { i8 -120, i8 19 }, %struct.sony_nc_event { i8 8, i8 59 }, %struct.sony_nc_event { i8 -119, i8 20 }, %struct.sony_nc_event { i8 9, i8 59 }, %struct.sony_nc_event { i8 -118, i8 21 }, %struct.sony_nc_event { i8 10, i8 59 }, %struct.sony_nc_event { i8 -117, i8 22 }, %struct.sony_nc_event { i8 11, i8 59 }, %struct.sony_nc_event { i8 -116, i8 23 }, %struct.sony_nc_event { i8 12, i8 59 }, %struct.sony_nc_event { i8 -99, i8 50 }, %struct.sony_nc_event { i8 29, i8 56 }, %struct.sony_nc_event { i8 -97, i8 64 }, %struct.sony_nc_event { i8 31, i8 56 }, %struct.sony_nc_event { i8 -95, i8 72 }, %struct.sony_nc_event { i8 33, i8 56 }, %struct.sony_nc_event { i8 -92, i8 64 }, %struct.sony_nc_event { i8 36, i8 56 }, %struct.sony_nc_event { i8 -91, i8 73 }, %struct.sony_nc_event { i8 37, i8 56 }, %struct.sony_nc_event { i8 -90, i8 40 }, %struct.sony_nc_event { i8 38, i8 56 }, %struct.sony_nc_event zeroinitializer], align 16
@sony_127_events = internal global [15 x %struct.sony_nc_event] [%struct.sony_nc_event { i8 -127, i8 65 }, %struct.sony_nc_event { i8 1, i8 56 }, %struct.sony_nc_event { i8 -126, i8 32 }, %struct.sony_nc_event { i8 2, i8 56 }, %struct.sony_nc_event { i8 -125, i8 33 }, %struct.sony_nc_event { i8 3, i8 56 }, %struct.sony_nc_event { i8 -124, i8 34 }, %struct.sony_nc_event { i8 4, i8 56 }, %struct.sony_nc_event { i8 -123, i8 66 }, %struct.sony_nc_event { i8 5, i8 56 }, %struct.sony_nc_event { i8 -122, i8 67 }, %struct.sony_nc_event { i8 6, i8 56 }, %struct.sony_nc_event { i8 -121, i8 68 }, %struct.sony_nc_event { i8 7, i8 56 }, %struct.sony_nc_event zeroinitializer], align 16
@.str.193 = private unnamed_addr constant [61 x i8] c"\016sony_laptop: Unknown hotkey 0x%.2x/0x%.2x (handle 0x%.2x)\0A\00", align 1
@.str.194 = private unnamed_addr constant [23 x i8] c"\013sony_laptop: %s: %d\0A\00", align 1
@__func__.sony_nc_resume = private unnamed_addr constant [15 x i8] c"sony_nc_resume\00", align 1
@.str.195 = private unnamed_addr constant [36 x i8] c"\014sony_laptop: Resuming SNC device\0A\00", align 1
@llvm.used = appending global [30 x i8*] [i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__UNIQUE_ID_author91, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__UNIQUE_ID_description92, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license93, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_version94, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_debug to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_debugtype97, i32 0, i32 0), i8* getelementptr inbounds ([87 x i8], [87 x i8]* @__UNIQUE_ID_debug99, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_no_spic to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_no_spictype102, i32 0, i32 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @__UNIQUE_ID_no_spic104, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_compat to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_compattype107, i32 0, i32 0), i8* getelementptr inbounds ([71 x i8], [71 x i8]* @__UNIQUE_ID_compat109, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_mask to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_masktype112, i32 0, i32 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @__UNIQUE_ID_mask114, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_camera to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_cameratype117, i32 0, i32 0), i8* getelementptr inbounds ([110 x i8], [110 x i8]* @__UNIQUE_ID_camera120, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_minor to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_minortype124, i32 0, i32 0), i8* getelementptr inbounds ([102 x i8], [102 x i8]* @__UNIQUE_ID_minor127, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_kbd_backlight to i8*), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__UNIQUE_ID_kbd_backlighttype131, i32 0, i32 0), i8* getelementptr inbounds ([92 x i8], [92 x i8]* @__UNIQUE_ID_kbd_backlight134, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_kbd_backlight_timeout to i8*), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__UNIQUE_ID_kbd_backlight_timeouttype137, i32 0, i32 0), i8* getelementptr inbounds ([153 x i8], [153 x i8]* @__UNIQUE_ID_kbd_backlight_timeout141, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_sony_pic_camera_command to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sony_pic_camera_command to i8*)], section "llvm.metadata"

@__mod_acpi_device_table = alias %struct.acpi_device_id, getelementptr inbounds ([3 x %struct.acpi_device_id], [3 x %struct.acpi_device_id]* @sony_device_ids, i32 0, i32 0)
@init_module = alias i32 (), i32 ()* @sony_laptop_init
@cleanup_module = alias void (), void ()* @sony_laptop_exit

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @acpi_os_allocate(i64 %size) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %call = call i64 @arch_local_save_flags()
  %4 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #8
  %5 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #8
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %6 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #8
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call9, 0
  %8 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32, i32 208
  %call10 = call i8* @kmalloc(i64 %size, i32 %cond)
  ret i8* %call10
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @acpi_os_acquire_object(%struct.kmem_cache* %cache) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %call = call i64 @arch_local_save_flags()
  %4 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #8
  %5 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #8
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %6 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #8
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call9, 0
  %8 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32, i32 208
  %call10 = call i8* @kmem_cache_zalloc(%struct.kmem_cache* %cache, i32 %cond)
  ret i8* %call10
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @acpi_os_get_thread_id() #0 {
entry:
  %call = call %struct.task_struct* @get_current()
  %0 = ptrtoint %struct.task_struct* %call to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define i32 @sony_pic_camera_command(i32 %command, i8 zeroext %value) #1 {
entry:
  %0 = load i32, i32* @camera, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %Pivot26 = icmp slt i32 %command, 10
  br i1 %Pivot26, label %NodeBlock9, label %NodeBlock23

NodeBlock23:                                      ; preds = %if.end
  %Pivot24 = icmp slt i32 %command, 14
  br i1 %Pivot24, label %NodeBlock15, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %command, 16
  br i1 %Pivot22, label %LeafBlock17, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %command, 16
  br i1 %SwitchLeaf20, label %sw.bb126, label %sw.default

LeafBlock17:                                      ; preds = %NodeBlock21
  %SwitchLeaf18 = icmp eq i32 %command, 14
  br i1 %SwitchLeaf18, label %sw.bb104, label %sw.default

NodeBlock15:                                      ; preds = %NodeBlock23
  %Pivot16 = icmp slt i32 %command, 12
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %command, 12
  br i1 %SwitchLeaf14, label %sw.bb82, label %sw.default

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %command, 10
  br i1 %SwitchLeaf12, label %sw.bb60, label %sw.default

NodeBlock9:                                       ; preds = %if.end
  %Pivot10 = icmp slt i32 %command, 6
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %command, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %command, 8
  br i1 %SwitchLeaf6, label %sw.bb38, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %command, 6
  br i1 %SwitchLeaf4, label %sw.bb16, label %sw.default

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %command, 4
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %command, 4
  br i1 %SwitchLeaf2, label %sw.bb5, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %command, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %tobool1 = icmp ne i8 %value, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %sw.bb
  %call = call i32 @__sony_pic_camera_on()
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb
  %call3 = call i32 @__sony_pic_camera_off()
  br label %sw.epilog

sw.bb5:                                           ; preds = %LeafBlock1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.bb5
  %n.0 = phi i32 [ 10, %sw.bb5 ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %call7 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 0, i8 zeroext %value)
  %conv = zext i8 %call7 to i32
  %tobool8 = icmp ne i32 %conv, 0
  br i1 %tobool8, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool9 = icmp eq i32 %dec, 0
  %1 = load i32, i32* @debug, align 4
  %tobool11 = icmp ne i32 %1, 0
  %or.cond = and i1 %tobool9, %tobool11
  br i1 %or.cond, label %if.then12, label %sw.epilog

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool11.old = icmp ne i32 %.old, 0
  br i1 %tobool11.old, label %if.then12, label %sw.epilog

if.then12:                                        ; preds = %while.end, %do.body
  %call13 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.sony_pic_camera_command, i32 0, i32 0), i32 3458)
  br label %sw.epilog

sw.bb16:                                          ; preds = %LeafBlock3
  br label %while.cond18

while.cond18:                                     ; preds = %while.body26, %sw.bb16
  %n17.0 = phi i32 [ 10, %sw.bb16 ], [ %dec19, %while.body26 ]
  %dec19 = add i32 %n17.0, -1
  %cond27 = icmp eq i32 %dec19, 0
  br i1 %cond27, label %do.body30, label %land.rhs21

land.rhs21:                                       ; preds = %while.cond18
  %call22 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 1, i8 zeroext %value)
  %conv23 = zext i8 %call22 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  br i1 %tobool24, label %while.body26, label %while.end27

while.body26:                                     ; preds = %land.rhs21
  call void @__const_udelay(i64 4295)
  br label %while.cond18

while.end27:                                      ; preds = %land.rhs21
  %tobool28 = icmp eq i32 %dec19, 0
  %2 = load i32, i32* @debug, align 4
  %tobool31 = icmp ne i32 %2, 0
  %or.cond29 = and i1 %tobool28, %tobool31
  br i1 %or.cond29, label %if.then32, label %sw.epilog

do.body30:                                        ; preds = %while.cond18
  %.old28 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool31.old = icmp ne i32 %.old28, 0
  br i1 %tobool31.old, label %if.then32, label %sw.epilog

if.then32:                                        ; preds = %while.end27, %do.body30
  %call33 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.sony_pic_camera_command, i32 0, i32 0), i32 3462)
  br label %sw.epilog

sw.bb38:                                          ; preds = %LeafBlock5
  br label %while.cond40

while.cond40:                                     ; preds = %while.body48, %sw.bb38
  %n39.0 = phi i32 [ 10, %sw.bb38 ], [ %dec41, %while.body48 ]
  %dec41 = add i32 %n39.0, -1
  %cond30 = icmp eq i32 %dec41, 0
  br i1 %cond30, label %do.body52, label %land.rhs43

land.rhs43:                                       ; preds = %while.cond40
  %call44 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 2, i8 zeroext %value)
  %conv45 = zext i8 %call44 to i32
  %tobool46 = icmp ne i32 %conv45, 0
  br i1 %tobool46, label %while.body48, label %while.end49

while.body48:                                     ; preds = %land.rhs43
  call void @__const_udelay(i64 4295)
  br label %while.cond40

while.end49:                                      ; preds = %land.rhs43
  %tobool50 = icmp eq i32 %dec41, 0
  %3 = load i32, i32* @debug, align 4
  %tobool53 = icmp ne i32 %3, 0
  %or.cond32 = and i1 %tobool50, %tobool53
  br i1 %or.cond32, label %if.then54, label %sw.epilog

do.body52:                                        ; preds = %while.cond40
  %.old31 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool53.old = icmp ne i32 %.old31, 0
  br i1 %tobool53.old, label %if.then54, label %sw.epilog

if.then54:                                        ; preds = %while.end49, %do.body52
  %call55 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.sony_pic_camera_command, i32 0, i32 0), i32 3466)
  br label %sw.epilog

sw.bb60:                                          ; preds = %LeafBlock11
  br label %while.cond62

while.cond62:                                     ; preds = %while.body70, %sw.bb60
  %n61.0 = phi i32 [ 10, %sw.bb60 ], [ %dec63, %while.body70 ]
  %dec63 = add i32 %n61.0, -1
  %cond33 = icmp eq i32 %dec63, 0
  br i1 %cond33, label %do.body74, label %land.rhs65

land.rhs65:                                       ; preds = %while.cond62
  %call66 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 3, i8 zeroext %value)
  %conv67 = zext i8 %call66 to i32
  %tobool68 = icmp ne i32 %conv67, 0
  br i1 %tobool68, label %while.body70, label %while.end71

while.body70:                                     ; preds = %land.rhs65
  call void @__const_udelay(i64 4295)
  br label %while.cond62

while.end71:                                      ; preds = %land.rhs65
  %tobool72 = icmp eq i32 %dec63, 0
  %4 = load i32, i32* @debug, align 4
  %tobool75 = icmp ne i32 %4, 0
  %or.cond35 = and i1 %tobool72, %tobool75
  br i1 %or.cond35, label %if.then76, label %sw.epilog

do.body74:                                        ; preds = %while.cond62
  %.old34 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool75.old = icmp ne i32 %.old34, 0
  br i1 %tobool75.old, label %if.then76, label %sw.epilog

if.then76:                                        ; preds = %while.end71, %do.body74
  %call77 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.sony_pic_camera_command, i32 0, i32 0), i32 3470)
  br label %sw.epilog

sw.bb82:                                          ; preds = %LeafBlock13
  br label %while.cond84

while.cond84:                                     ; preds = %while.body92, %sw.bb82
  %n83.0 = phi i32 [ 10, %sw.bb82 ], [ %dec85, %while.body92 ]
  %dec85 = add i32 %n83.0, -1
  %cond36 = icmp eq i32 %dec85, 0
  br i1 %cond36, label %do.body96, label %land.rhs87

land.rhs87:                                       ; preds = %while.cond84
  %call88 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 4, i8 zeroext %value)
  %conv89 = zext i8 %call88 to i32
  %tobool90 = icmp ne i32 %conv89, 0
  br i1 %tobool90, label %while.body92, label %while.end93

while.body92:                                     ; preds = %land.rhs87
  call void @__const_udelay(i64 4295)
  br label %while.cond84

while.end93:                                      ; preds = %land.rhs87
  %tobool94 = icmp eq i32 %dec85, 0
  %5 = load i32, i32* @debug, align 4
  %tobool97 = icmp ne i32 %5, 0
  %or.cond38 = and i1 %tobool94, %tobool97
  br i1 %or.cond38, label %if.then98, label %sw.epilog

do.body96:                                        ; preds = %while.cond84
  %.old37 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool97.old = icmp ne i32 %.old37, 0
  br i1 %tobool97.old, label %if.then98, label %sw.epilog

if.then98:                                        ; preds = %while.end93, %do.body96
  %call99 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.sony_pic_camera_command, i32 0, i32 0), i32 3474)
  br label %sw.epilog

sw.bb104:                                         ; preds = %LeafBlock17
  br label %while.cond106

while.cond106:                                    ; preds = %while.body114, %sw.bb104
  %n105.0 = phi i32 [ 10, %sw.bb104 ], [ %dec107, %while.body114 ]
  %dec107 = add i32 %n105.0, -1
  %cond39 = icmp eq i32 %dec107, 0
  br i1 %cond39, label %do.body118, label %land.rhs109

land.rhs109:                                      ; preds = %while.cond106
  %call110 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 5, i8 zeroext %value)
  %conv111 = zext i8 %call110 to i32
  %tobool112 = icmp ne i32 %conv111, 0
  br i1 %tobool112, label %while.body114, label %while.end115

while.body114:                                    ; preds = %land.rhs109
  call void @__const_udelay(i64 4295)
  br label %while.cond106

while.end115:                                     ; preds = %land.rhs109
  %tobool116 = icmp eq i32 %dec107, 0
  %6 = load i32, i32* @debug, align 4
  %tobool119 = icmp ne i32 %6, 0
  %or.cond41 = and i1 %tobool116, %tobool119
  br i1 %or.cond41, label %if.then120, label %sw.epilog

do.body118:                                       ; preds = %while.cond106
  %.old40 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool119.old = icmp ne i32 %.old40, 0
  br i1 %tobool119.old, label %if.then120, label %sw.epilog

if.then120:                                       ; preds = %while.end115, %do.body118
  %call121 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.sony_pic_camera_command, i32 0, i32 0), i32 3478)
  br label %sw.epilog

sw.bb126:                                         ; preds = %LeafBlock19
  br label %while.cond128

while.cond128:                                    ; preds = %while.body136, %sw.bb126
  %n127.0 = phi i32 [ 10, %sw.bb126 ], [ %dec129, %while.body136 ]
  %dec129 = add i32 %n127.0, -1
  %cond42 = icmp eq i32 %dec129, 0
  br i1 %cond42, label %do.body140, label %land.rhs131

land.rhs131:                                      ; preds = %while.cond128
  %call132 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 6, i8 zeroext %value)
  %conv133 = zext i8 %call132 to i32
  %tobool134 = icmp ne i32 %conv133, 0
  br i1 %tobool134, label %while.body136, label %while.end137

while.body136:                                    ; preds = %land.rhs131
  call void @__const_udelay(i64 4295)
  br label %while.cond128

while.end137:                                     ; preds = %land.rhs131
  %tobool138 = icmp eq i32 %dec129, 0
  %7 = load i32, i32* @debug, align 4
  %tobool141 = icmp ne i32 %7, 0
  %or.cond44 = and i1 %tobool138, %tobool141
  br i1 %or.cond44, label %if.then142, label %sw.epilog

do.body140:                                       ; preds = %while.cond128
  %.old43 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool141.old = icmp ne i32 %.old43, 0
  br i1 %tobool141.old, label %if.then142, label %sw.epilog

if.then142:                                       ; preds = %while.end137, %do.body140
  %call143 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.sony_pic_camera_command, i32 0, i32 0), i32 3482)
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock11, %LeafBlock13, %LeafBlock17, %LeafBlock19
  %call148 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.2, i32 0, i32 0), i32 %command)
  br label %sw.epilog

sw.epilog:                                        ; preds = %while.end137, %while.end115, %while.end93, %while.end71, %while.end49, %while.end27, %while.end, %if.then142, %do.body140, %if.then120, %do.body118, %if.then98, %do.body96, %if.then76, %do.body74, %if.then54, %do.body52, %if.then32, %do.body30, %if.then12, %do.body, %if.then2, %if.else, %sw.default
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  br label %return

return:                                           ; preds = %entry, %sw.epilog
  %retval.0 = phi i32 [ 0, %sw.epilog ], [ -5, %entry ]
  ret i32 %retval.0
}

declare void @mutex_lock_nested(%struct.mutex*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @__sony_pic_camera_on() #1 {
entry:
  %0 = load i32, i32* @camera, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.5, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %1 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !14
  %tobool1 = icmp ne i8 %1, 0
  br i1 %tobool1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc23, %if.end3
  %j.0 = phi i32 [ 5, %if.end3 ], [ %dec24, %for.inc23 ]
  %cmp = icmp sgt i32 %j.0, 0
  br i1 %cmp, label %for.body, label %for.end25

for.body:                                         ; preds = %for.cond
  br label %for.cond4

for.cond4:                                        ; preds = %for.body8, %for.body
  %x.0 = phi i32 [ 0, %for.body ], [ %inc, %for.body8 ]
  %cmp5 = icmp slt i32 %x.0, 100
  br i1 %cmp5, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond4
  %call6 = call zeroext i8 @sony_pic_call2(i8 zeroext -111, i8 zeroext 1)
  %conv = zext i8 %call6 to i32
  %tobool7 = icmp ne i32 %conv, 0
  br i1 %tobool7, label %for.body8, label %for.end

for.body8:                                        ; preds = %land.rhs
  call void @msleep(i32 10)
  %inc = add nsw i32 %x.0, 1
  br label %for.cond4

for.end:                                          ; preds = %for.cond4, %land.rhs
  %call9 = call zeroext i8 @sony_pic_call1(i8 zeroext -109)
  br label %for.cond10

for.cond10:                                       ; preds = %if.end17, %for.end
  %i.0 = phi i32 [ 400, %for.end ], [ %dec, %if.end17 ]
  %cmp11 = icmp sgt i32 %i.0, 0
  br i1 %cmp11, label %for.body13, label %for.end19

for.body13:                                       ; preds = %for.cond10
  %call14 = call i32 @__sony_pic_camera_ready()
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %for.end19, label %if.end17

if.end17:                                         ; preds = %for.body13
  call void @msleep(i32 10)
  %dec = add nsw i32 %i.0, -1
  br label %for.cond10

for.end19:                                        ; preds = %for.cond10, %for.body13
  %tobool20 = icmp ne i32 %i.0, 0
  br i1 %tobool20, label %for.end25, label %for.inc23

for.inc23:                                        ; preds = %for.end19
  %dec24 = add nsw i32 %j.0, -1
  br label %for.cond

for.end25:                                        ; preds = %for.cond, %for.end19
  %cmp26 = icmp eq i32 %j.0, 0
  br i1 %cmp26, label %if.then28, label %if.end30

if.then28:                                        ; preds = %for.end25
  %call29 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.6, i32 0, i32 0))
  br label %cleanup

if.end30:                                         ; preds = %for.end25
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end30
  %n.0 = phi i32 [ 10, %if.end30 ], [ %dec31, %while.body ]
  %dec31 = add i32 %n.0, -1
  %cond = icmp eq i32 %dec31, 0
  br i1 %cond, label %do.body, label %land.rhs33

land.rhs33:                                       ; preds = %while.cond
  %call34 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 16, i8 zeroext 90)
  %conv35 = zext i8 %call34 to i32
  %tobool36 = icmp ne i32 %conv35, 0
  br i1 %tobool36, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs33
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs33
  %tobool38 = icmp eq i32 %dec31, 0
  %2 = load i32, i32* @debug, align 4
  %tobool40 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool38, %tobool40
  br i1 %or.cond, label %if.then41, label %if.end44

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool40.old = icmp ne i32 %.old, 0
  br i1 %tobool40.old, label %if.then41, label %if.end44

if.then41:                                        ; preds = %while.end, %do.body
  %call42 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.__sony_pic_camera_on, i32 0, i32 0), i32 3435)
  br label %if.end44

if.end44:                                         ; preds = %while.end, %do.body, %if.then41
  store i8 1, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !14
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.end44, %if.then28, %if.then
  %retval.0 = phi i32 [ -19, %if.then28 ], [ 0, %if.end44 ], [ -19, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @__sony_pic_camera_off() #1 {
entry:
  %0 = load i32, i32* @camera, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.5, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %n.0 = phi i32 [ 10, %if.end ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %call2 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 5, i8 zeroext 64)
  %conv = zext i8 %call2 to i32
  %tobool3 = icmp ne i32 %conv, 0
  br i1 %tobool3, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool4 = icmp eq i32 %dec, 0
  %1 = load i32, i32* @debug, align 4
  %tobool6 = icmp ne i32 %1, 0
  %or.cond = and i1 %tobool4, %tobool6
  br i1 %or.cond, label %if.then7, label %if.end10

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool6.old = icmp ne i32 %.old, 0
  br i1 %tobool6.old, label %if.then7, label %if.end10

if.then7:                                         ; preds = %while.end, %do.body
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.__sony_pic_camera_off, i32 0, i32 0), i32 3392)
  br label %if.end10

if.end10:                                         ; preds = %while.end, %do.body, %if.then7
  %2 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !14
  %tobool11 = icmp ne i8 %2, 0
  br i1 %tobool11, label %if.then12, label %return

if.then12:                                        ; preds = %if.end10
  %call13 = call zeroext i8 @sony_pic_call2(i8 zeroext -111, i8 zeroext 0)
  store i8 0, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !14
  br label %return

return:                                           ; preds = %if.end10, %if.then12, %if.then
  %retval.0 = phi i32 [ -19, %if.then ], [ 0, %if.then12 ], [ 0, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

; Function Attrs: nounwind uwtable
define internal zeroext i8 @sony_pic_call3(i8 zeroext %dev, i8 zeroext %fn, i8 zeroext %v) #1 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %n.0 = phi i32 [ 10000, %entry ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %0 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %0, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %1 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv = zext i16 %1 to i32
  %add = add nsw i32 %conv, 4
  %call = call zeroext i8 @inb_p(i32 %add)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp eq i32 %dec, 0
  %2 = load i32, i32* @debug, align 4
  %tobool4 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool3, %tobool4
  br i1 %or.cond, label %if.then5, label %if.end7

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool4.old = icmp ne i32 %.old, 0
  br i1 %tobool4.old, label %if.then5, label %if.end7

if.then5:                                         ; preds = %while.end, %do.body
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.sony_pic_call3, i32 0, i32 0), i32 3243)
  br label %if.end7

if.end7:                                          ; preds = %while.end, %do.body, %if.then5
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io18 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 0
  %minimum9 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io18, i32 0, i32 3
  %4 = load i16, i16* %minimum9, align 1, !tbaa !24
  %conv10 = zext i16 %4 to i32
  %add11 = add nsw i32 %conv10, 4
  call void @outb(i8 zeroext %dev, i32 %add11)
  br label %while.cond13

while.cond13:                                     ; preds = %while.body26, %if.end7
  %n12.0 = phi i32 [ 10000, %if.end7 ], [ %dec14, %while.body26 ]
  %dec14 = add i32 %n12.0, -1
  %cond1 = icmp eq i32 %dec14, 0
  br i1 %cond1, label %do.body30, label %land.rhs16

land.rhs16:                                       ; preds = %while.cond13
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io117 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum18 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io117, i32 0, i32 3
  %6 = load i16, i16* %minimum18, align 1, !tbaa !24
  %conv19 = zext i16 %6 to i32
  %add20 = add nsw i32 %conv19, 4
  %call21 = call zeroext i8 @inb_p(i32 %add20)
  %conv22 = zext i8 %call21 to i32
  %and23 = and i32 %conv22, 2
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %while.body26, label %while.end27

while.body26:                                     ; preds = %land.rhs16
  call void @__const_udelay(i64 4295)
  br label %while.cond13

while.end27:                                      ; preds = %land.rhs16
  %tobool28 = icmp eq i32 %dec14, 0
  %7 = load i32, i32* @debug, align 4
  %tobool31 = icmp ne i32 %7, 0
  %or.cond3 = and i1 %tobool28, %tobool31
  br i1 %or.cond3, label %if.then32, label %if.end37

do.body30:                                        ; preds = %while.cond13
  %.old2 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool31.old = icmp ne i32 %.old2, 0
  br i1 %tobool31.old, label %if.then32, label %if.end37

if.then32:                                        ; preds = %while.end27, %do.body30
  %call33 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.sony_pic_call3, i32 0, i32 0), i32 3245)
  br label %if.end37

if.end37:                                         ; preds = %while.end27, %do.body30, %if.then32
  %8 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io138 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %8, i32 0, i32 0
  %minimum39 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io138, i32 0, i32 3
  %9 = load i16, i16* %minimum39, align 1, !tbaa !24
  %conv40 = zext i16 %9 to i32
  call void @outb(i8 zeroext %fn, i32 %conv40)
  br label %while.cond42

while.cond42:                                     ; preds = %while.body55, %if.end37
  %n41.0 = phi i32 [ 10000, %if.end37 ], [ %dec43, %while.body55 ]
  %dec43 = add i32 %n41.0, -1
  %cond4 = icmp eq i32 %dec43, 0
  br i1 %cond4, label %do.body59, label %land.rhs45

land.rhs45:                                       ; preds = %while.cond42
  %10 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io146 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %10, i32 0, i32 0
  %minimum47 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io146, i32 0, i32 3
  %11 = load i16, i16* %minimum47, align 1, !tbaa !24
  %conv48 = zext i16 %11 to i32
  %add49 = add nsw i32 %conv48, 4
  %call50 = call zeroext i8 @inb_p(i32 %add49)
  %conv51 = zext i8 %call50 to i32
  %and52 = and i32 %conv51, 2
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %while.body55, label %while.end56

while.body55:                                     ; preds = %land.rhs45
  call void @__const_udelay(i64 4295)
  br label %while.cond42

while.end56:                                      ; preds = %land.rhs45
  %tobool57 = icmp eq i32 %dec43, 0
  %12 = load i32, i32* @debug, align 4
  %tobool60 = icmp ne i32 %12, 0
  %or.cond6 = and i1 %tobool57, %tobool60
  br i1 %or.cond6, label %if.then61, label %if.end66

do.body59:                                        ; preds = %while.cond42
  %.old5 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool60.old = icmp ne i32 %.old5, 0
  br i1 %tobool60.old, label %if.then61, label %if.end66

if.then61:                                        ; preds = %while.end56, %do.body59
  %call62 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.sony_pic_call3, i32 0, i32 0), i32 3247)
  br label %if.end66

if.end66:                                         ; preds = %while.end56, %do.body59, %if.then61
  %13 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io167 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %13, i32 0, i32 0
  %minimum68 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io167, i32 0, i32 3
  %14 = load i16, i16* %minimum68, align 1, !tbaa !24
  %conv69 = zext i16 %14 to i32
  call void @outb(i8 zeroext %v, i32 %conv69)
  %15 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io170 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 0
  %minimum71 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io170, i32 0, i32 3
  %16 = load i16, i16* %minimum71, align 1, !tbaa !24
  %conv72 = zext i16 %16 to i32
  %call73 = call zeroext i8 @inb_p(i32 %conv72)
  %17 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool75 = icmp ne i32 %17, 0
  br i1 %tobool75, label %if.then76, label %do.end84

if.then76:                                        ; preds = %if.end66
  %conv77 = zext i8 %dev to i32
  %conv78 = zext i8 %fn to i32
  %conv79 = zext i8 %v to i32
  %conv80 = zext i8 %call73 to i32
  %call81 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.9, i32 0, i32 0), i32 %conv77, i32 %conv78, i32 %conv79, i32 %conv80)
  br label %do.end84

do.end84:                                         ; preds = %if.then76, %if.end66
  ret i8 %call73
}

declare void @__const_udelay(i64) #2

declare i32 @printk(i8*, ...) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

declare void @mutex_unlock(%struct.mutex*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_laptop_init() #4 section ".init.text" {
entry:
  %0 = load i32, i32* @no_spic, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end6, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call = call i32 @dmi_check_system(%struct.dmi_system_id* getelementptr inbounds ([3 x %struct.dmi_system_id], [3 x %struct.dmi_system_id]* bitcast (<{ { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } }>* @sonypi_dmi_table to [3 x %struct.dmi_system_id]*), i32 0, i32 0))
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.then, label %if.end6

if.then:                                          ; preds = %land.lhs.true
  %call2 = call i32 @acpi_bus_register_driver(%struct.acpi_driver* @sony_pic_driver)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %call5 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.10, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %if.then
  store i32 1, i32* @spic_drv_registered, align 4, !tbaa !12
  br label %if.end6

if.end6:                                          ; preds = %if.end, %land.lhs.true, %entry
  %call7 = call i32 @acpi_bus_register_driver(%struct.acpi_driver* @sony_nc_driver)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then9, label %cleanup

if.then9:                                         ; preds = %if.end6
  %call10 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.11, i32 0, i32 0))
  %1 = load i32, i32* @spic_drv_registered, align 4, !tbaa !12
  %tobool12 = icmp ne i32 %1, 0
  br i1 %tobool12, label %if.then13, label %cleanup

if.then13:                                        ; preds = %if.then9
  call void @acpi_bus_unregister_driver(%struct.acpi_driver* @sony_pic_driver)
  br label %cleanup

cleanup:                                          ; preds = %if.then4, %if.then13, %if.then9, %if.end6
  %retval.0 = phi i32 [ 0, %if.end6 ], [ %call2, %if.then4 ], [ %call7, %if.then13 ], [ %call7, %if.then9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_laptop_exit() #4 section ".exit.text" {
entry:
  call void @acpi_bus_unregister_driver(%struct.acpi_driver* @sony_nc_driver)
  %0 = load i32, i32* @spic_drv_registered, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @acpi_bus_unregister_driver(%struct.acpi_driver* @sony_pic_driver)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #5 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags() #0 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !27
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.3, i32 0, i32 0), i32 824, i64 12) #8, !srcloc !30
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 44, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1) #8, !srcloc !31
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags(i64 %flags) #0 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare i8* @__kmalloc(i64, i32) #2

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #6

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmem_cache_zalloc(%struct.kmem_cache* %k, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmem_cache_alloc(%struct.kmem_cache* %k, i32 %or)
  ret i8* %call
}

declare i8* @kmem_cache_alloc(%struct.kmem_cache*, i32) #2

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #5 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !32
  ret %struct.task_struct* %0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @sony_pic_call2(i8 zeroext %dev, i8 zeroext %fn) #1 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %n.0 = phi i32 [ 10000, %entry ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %0 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %0, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %1 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv = zext i16 %1 to i32
  %add = add nsw i32 %conv, 4
  %call = call zeroext i8 @inb_p(i32 %add)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp eq i32 %dec, 0
  %2 = load i32, i32* @debug, align 4
  %tobool4 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool3, %tobool4
  br i1 %or.cond, label %if.then5, label %if.end7

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool4.old = icmp ne i32 %.old, 0
  br i1 %tobool4.old, label %if.then5, label %if.end7

if.then5:                                         ; preds = %while.end, %do.body
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.sony_pic_call2, i32 0, i32 0), i32 3229)
  br label %if.end7

if.end7:                                          ; preds = %while.end, %do.body, %if.then5
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io18 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 0
  %minimum9 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io18, i32 0, i32 3
  %4 = load i16, i16* %minimum9, align 1, !tbaa !24
  %conv10 = zext i16 %4 to i32
  %add11 = add nsw i32 %conv10, 4
  call void @outb(i8 zeroext %dev, i32 %add11)
  br label %while.cond13

while.cond13:                                     ; preds = %while.body26, %if.end7
  %n12.0 = phi i32 [ 10000, %if.end7 ], [ %dec14, %while.body26 ]
  %dec14 = add i32 %n12.0, -1
  %cond1 = icmp eq i32 %dec14, 0
  br i1 %cond1, label %do.body30, label %land.rhs16

land.rhs16:                                       ; preds = %while.cond13
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io117 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum18 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io117, i32 0, i32 3
  %6 = load i16, i16* %minimum18, align 1, !tbaa !24
  %conv19 = zext i16 %6 to i32
  %add20 = add nsw i32 %conv19, 4
  %call21 = call zeroext i8 @inb_p(i32 %add20)
  %conv22 = zext i8 %call21 to i32
  %and23 = and i32 %conv22, 2
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %while.body26, label %while.end27

while.body26:                                     ; preds = %land.rhs16
  call void @__const_udelay(i64 4295)
  br label %while.cond13

while.end27:                                      ; preds = %land.rhs16
  %tobool28 = icmp eq i32 %dec14, 0
  %7 = load i32, i32* @debug, align 4
  %tobool31 = icmp ne i32 %7, 0
  %or.cond3 = and i1 %tobool28, %tobool31
  br i1 %or.cond3, label %if.then32, label %if.end37

do.body30:                                        ; preds = %while.cond13
  %.old2 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool31.old = icmp ne i32 %.old2, 0
  br i1 %tobool31.old, label %if.then32, label %if.end37

if.then32:                                        ; preds = %while.end27, %do.body30
  %call33 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.sony_pic_call2, i32 0, i32 0), i32 3232)
  br label %if.end37

if.end37:                                         ; preds = %while.end27, %do.body30, %if.then32
  %8 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io138 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %8, i32 0, i32 0
  %minimum39 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io138, i32 0, i32 3
  %9 = load i16, i16* %minimum39, align 1, !tbaa !24
  %conv40 = zext i16 %9 to i32
  call void @outb(i8 zeroext %fn, i32 %conv40)
  %10 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io141 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %10, i32 0, i32 0
  %minimum42 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io141, i32 0, i32 3
  %11 = load i16, i16* %minimum42, align 1, !tbaa !24
  %conv43 = zext i16 %11 to i32
  %call44 = call zeroext i8 @inb_p(i32 %conv43)
  %12 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool46 = icmp ne i32 %12, 0
  br i1 %tobool46, label %if.then47, label %do.end54

if.then47:                                        ; preds = %if.end37
  %conv48 = zext i8 %dev to i32
  %conv49 = zext i8 %fn to i32
  %conv50 = zext i8 %call44 to i32
  %call51 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.7, i32 0, i32 0), i32 %conv48, i32 %conv49, i32 %conv50)
  br label %do.end54

do.end54:                                         ; preds = %if.then47, %if.end37
  ret i8 %call44
}

declare void @msleep(i32) #2

; Function Attrs: nounwind uwtable
define internal zeroext i8 @sony_pic_call1(i8 zeroext %dev) #1 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %n.0 = phi i32 [ 10000, %entry ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %0 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %0, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %1 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv = zext i16 %1 to i32
  %add = add nsw i32 %conv, 4
  %call = call zeroext i8 @inb_p(i32 %add)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp eq i32 %dec, 0
  %2 = load i32, i32* @debug, align 4
  %tobool4 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool3, %tobool4
  br i1 %or.cond, label %if.then5, label %if.end7

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool4.old = icmp ne i32 %.old, 0
  br i1 %tobool4.old, label %if.then5, label %if.end7

if.then5:                                         ; preds = %while.end, %do.body
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.sony_pic_call1, i32 0, i32 0), i32 3216)
  br label %if.end7

if.end7:                                          ; preds = %while.end, %do.body, %if.then5
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io18 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 0
  %minimum9 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io18, i32 0, i32 3
  %4 = load i16, i16* %minimum9, align 1, !tbaa !24
  %conv10 = zext i16 %4 to i32
  %add11 = add nsw i32 %conv10, 4
  call void @outb(i8 zeroext %dev, i32 %add11)
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io112 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum13 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io112, i32 0, i32 3
  %6 = load i16, i16* %minimum13, align 1, !tbaa !24
  %conv14 = zext i16 %6 to i32
  %add15 = add nsw i32 %conv14, 4
  %call16 = call zeroext i8 @inb_p(i32 %add15)
  %7 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io117 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %7, i32 0, i32 0
  %minimum18 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io117, i32 0, i32 3
  %8 = load i16, i16* %minimum18, align 1, !tbaa !24
  %conv19 = zext i16 %8 to i32
  %call20 = call zeroext i8 @inb_p(i32 %conv19)
  %9 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool22 = icmp ne i32 %9, 0
  br i1 %tobool22, label %if.then23, label %do.end30

if.then23:                                        ; preds = %if.end7
  %conv24 = zext i8 %dev to i32
  %conv25 = zext i8 %call20 to i32
  %shl = shl i32 %conv25, 8
  %conv26 = zext i8 %call16 to i32
  %or = or i32 %shl, %conv26
  %call27 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.8, i32 0, i32 0), i32 %conv24, i32 %or)
  br label %do.end30

do.end30:                                         ; preds = %if.then23, %if.end7
  ret i8 %call20
}

; Function Attrs: nounwind uwtable
define internal i32 @__sony_pic_camera_ready() #1 {
entry:
  %call = call zeroext i8 @sony_pic_call2(i8 zeroext -113, i8 zeroext 7)
  %conv = zext i8 %call to i32
  %cmp = icmp ne i32 %conv, 255
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %conv2 = zext i8 %call to i32
  %and = and i32 %conv2, 2
  %tobool = icmp ne i32 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %0 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb_p(i32 %port) #0 {
entry:
  %call = call zeroext i8 @inb(i32 %port)
  call void @slow_down_io()
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #0 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #8, !srcloc !33
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #0 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #8, !srcloc !34
  ret i8 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @slow_down_io() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.pv_cpu_ops, %struct.pv_cpu_ops* @pv_cpu_ops, i32 0, i32 26), align 8, !tbaa !35
  call void %0()
  ret void
}

declare i32 @dmi_check_system(%struct.dmi_system_id*) #2

declare i32 @acpi_bus_register_driver(%struct.acpi_driver*) #2

declare void @acpi_bus_unregister_driver(%struct.acpi_driver*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_add(%struct.acpi_device* %device) #1 {
entry:
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0))
  store %struct.acpi_device* %device, %struct.acpi_device** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 0), align 8, !tbaa !37
  %pnp = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 8
  %device_class = getelementptr inbounds %struct.acpi_device_pnp, %struct.acpi_device_pnp* %pnp, i32 0, i32 6
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %device_class, i32 0, i32 0
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.17, i32 0, i32 0))
  call void @sony_pic_detect_device_type(%struct.sony_pic_dev* @spic_dev)
  call void @__mutex_init(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.18, i32 0, i32 0), %struct.lock_class_key* @sony_pic_add.__key)
  %call2 = call i32 @sony_pic_possible_resources(%struct.acpi_device* %device)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.19, i32 0, i32 0))
  br label %err_free_resources

if.end:                                           ; preds = %entry
  %call4 = call i32 @sony_laptop_setup_input(%struct.acpi_device* %device)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.20, i32 0, i32 0))
  br label %err_free_resources

if.end8:                                          ; preds = %if.end
  %call9 = call i32 @sonypi_compat_init()
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %err_remove_input, label %if.end12

if.end12:                                         ; preds = %if.end8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end12
  %prev.sink = phi %struct.list_head** [ %prev, %for.inc ], [ getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4, i32 1), %if.end12 ]
  %0 = load %struct.list_head*, %struct.list_head** %prev.sink, align 8, !tbaa !38
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr90 = getelementptr inbounds i8, i8* %1, i64 -16
  %2 = bitcast i8* %add.ptr90 to %struct.sony_pic_ioport*
  %list = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 2
  %cmp = icmp ne %struct.list_head* %list, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4)
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %3 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv = zext i16 %3 to i64
  %io113 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %address_length = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io113, i32 0, i32 2
  %4 = load i8, i8* %address_length, align 2, !tbaa !39
  %conv14 = zext i8 %4 to i64
  %call15 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv, i64 %conv14, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.21, i32 0, i32 0), i32 0)
  %tobool16 = icmp ne %struct.resource* %call15, null
  br i1 %tobool16, label %do.body18, label %for.inc

do.body18:                                        ; preds = %for.body
  %5 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool19 = icmp ne i32 %5, 0
  br i1 %tobool19, label %if.then20, label %do.end32

if.then20:                                        ; preds = %do.body18
  %io121 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %minimum22 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io121, i32 0, i32 3
  %6 = load i16, i16* %minimum22, align 1, !tbaa !24
  %conv23 = zext i16 %6 to i32
  %io124 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %maximum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io124, i32 0, i32 4
  %7 = load i16, i16* %maximum, align 1, !tbaa !40
  %conv25 = zext i16 %7 to i32
  %io126 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %address_length27 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io126, i32 0, i32 2
  %8 = load i8, i8* %address_length27, align 2, !tbaa !39
  %conv28 = zext i8 %8 to i32
  %call29 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.22, i32 0, i32 0), i32 %conv23, i32 %conv25, i32 %conv28)
  br label %do.end32

do.end32:                                         ; preds = %if.then20, %do.body18
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %minimum33 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %9 = load i16, i16* %minimum33, align 1, !tbaa !41
  %tobool34 = icmp ne i16 %9, 0
  br i1 %tobool34, label %if.then35, label %for.end.sink.split

if.then35:                                        ; preds = %do.end32
  %io236 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %minimum37 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io236, i32 0, i32 3
  %10 = load i16, i16* %minimum37, align 1, !tbaa !41
  %conv38 = zext i16 %10 to i64
  %io239 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %address_length40 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io239, i32 0, i32 2
  %11 = load i8, i8* %address_length40, align 1, !tbaa !42
  %conv41 = zext i8 %11 to i64
  %call42 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv38, i64 %conv41, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.21, i32 0, i32 0), i32 0)
  %tobool43 = icmp ne %struct.resource* %call42, null
  %12 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool46 = icmp ne i32 %12, 0
  br i1 %tobool43, label %do.body45, label %do.body61

do.body45:                                        ; preds = %if.then35
  br i1 %tobool46, label %if.then47, label %for.end.sink.split

if.then47:                                        ; preds = %do.body45
  %io248 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %minimum49 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io248, i32 0, i32 3
  %13 = load i16, i16* %minimum49, align 1, !tbaa !41
  %conv50 = zext i16 %13 to i32
  %io251 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %maximum52 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io251, i32 0, i32 4
  %14 = load i16, i16* %maximum52, align 1, !tbaa !43
  %conv53 = zext i16 %14 to i32
  %io254 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %address_length55 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io254, i32 0, i32 2
  %15 = load i8, i8* %address_length55, align 1, !tbaa !42
  %conv56 = zext i8 %15 to i32
  %call57 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.23, i32 0, i32 0), i32 %conv50, i32 %conv53, i32 %conv56)
  br label %for.end.sink.split

do.body61:                                        ; preds = %if.then35
  br i1 %tobool46, label %if.then63, label %do.end76

if.then63:                                        ; preds = %do.body61
  %io264 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %minimum65 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io264, i32 0, i32 3
  %16 = load i16, i16* %minimum65, align 1, !tbaa !41
  %conv66 = zext i16 %16 to i32
  %io267 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %maximum68 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io267, i32 0, i32 4
  %17 = load i16, i16* %maximum68, align 1, !tbaa !43
  %conv69 = zext i16 %17 to i32
  %io270 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %address_length71 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io270, i32 0, i32 2
  %18 = load i8, i8* %address_length71, align 1, !tbaa !42
  %conv72 = zext i8 %18 to i32
  %call73 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.24, i32 0, i32 0), i32 %conv66, i32 %conv69, i32 %conv72)
  br label %do.end76

do.end76:                                         ; preds = %if.then63, %do.body61
  %io177 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %minimum78 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io177, i32 0, i32 3
  %19 = load i16, i16* %minimum78, align 1, !tbaa !24
  %conv79 = zext i16 %19 to i64
  %io180 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %address_length81 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io180, i32 0, i32 2
  %20 = load i8, i8* %address_length81, align 2, !tbaa !39
  %conv82 = zext i8 %20 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv79, i64 %conv82)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %do.end76
  %list88 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 2
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list88, i32 0, i32 1
  br label %for.cond

for.end.sink.split:                               ; preds = %do.body45, %if.then47, %do.end32
  store %struct.sony_pic_ioport* %2, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  br label %for.end

for.end:                                          ; preds = %for.end.sink.split, %for.cond
  %21 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %tobool91 = icmp ne %struct.sony_pic_ioport* %21, null
  br i1 %tobool91, label %if.end94, label %if.then92

if.then92:                                        ; preds = %for.end
  %call93 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.25, i32 0, i32 0))
  br label %err_remove_compat

if.end94:                                         ; preds = %for.end
  br label %for.cond98

for.cond98:                                       ; preds = %for.inc126, %if.end94
  %prev129.sink = phi %struct.list_head** [ %prev129, %for.inc126 ], [ getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3, i32 1), %if.end94 ]
  %22 = load %struct.list_head*, %struct.list_head** %prev129.sink, align 8, !tbaa !38
  %23 = bitcast %struct.list_head* %22 to i8*
  %add.ptr131 = getelementptr inbounds i8, i8* %23, i64 -8
  %24 = bitcast i8* %add.ptr131 to %struct.sony_pic_irq*
  %list99 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %24, i32 0, i32 1
  %cmp100 = icmp ne %struct.list_head* %list99, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3)
  br i1 %cmp100, label %for.body102, label %for.end132

for.body102:                                      ; preds = %for.cond98
  %irq103 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %24, i32 0, i32 0
  %interrupts = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq103, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts, i64 0, i64 0
  %25 = load i8, i8* %arrayidx, align 2, !tbaa !44
  %conv104 = zext i8 %25 to i32
  %call105 = call i32 @request_irq(i32 %conv104, i32 (i32, i8*)* @sony_pic_irq, i64 0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.26, i32 0, i32 0), i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %for.inc126, label %do.body108

do.body108:                                       ; preds = %for.body102
  %26 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool109 = icmp ne i32 %26, 0
  br i1 %tobool109, label %if.then110, label %do.end124

if.then110:                                       ; preds = %do.body108
  %irq111 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %24, i32 0, i32 0
  %interrupts112 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq111, i32 0, i32 6
  %arrayidx113 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts112, i64 0, i64 0
  %27 = load i8, i8* %arrayidx113, align 2, !tbaa !44
  %conv114 = zext i8 %27 to i32
  %irq115 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %24, i32 0, i32 0
  %triggering = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq115, i32 0, i32 1
  %28 = load i8, i8* %triggering, align 1, !tbaa !45
  %conv116 = zext i8 %28 to i32
  %irq117 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %24, i32 0, i32 0
  %polarity = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq117, i32 0, i32 2
  %29 = load i8, i8* %polarity, align 2, !tbaa !48
  %conv118 = zext i8 %29 to i32
  %irq119 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %24, i32 0, i32 0
  %sharable = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq119, i32 0, i32 3
  %30 = load i8, i8* %sharable, align 1, !tbaa !49
  %conv120 = zext i8 %30 to i32
  %call121 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.27, i32 0, i32 0), i32 %conv114, i32 %conv116, i32 %conv118, i32 %conv120)
  br label %do.end124

do.end124:                                        ; preds = %if.then110, %do.body108
  store %struct.sony_pic_irq* %24, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !50
  br label %for.end132

for.inc126:                                       ; preds = %for.body102
  %list128 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %24, i32 0, i32 1
  %prev129 = getelementptr inbounds %struct.list_head, %struct.list_head* %list128, i32 0, i32 1
  br label %for.cond98

for.end132:                                       ; preds = %for.cond98, %do.end124
  %31 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !50
  %tobool133 = icmp ne %struct.sony_pic_irq* %31, null
  br i1 %tobool133, label %if.end136, label %if.then134

if.then134:                                       ; preds = %for.end132
  %call135 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.28, i32 0, i32 0))
  br label %err_release_region

if.end136:                                        ; preds = %for.end132
  %32 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %33 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !50
  %call137 = call i32 @sony_pic_enable(%struct.acpi_device* %device, %struct.sony_pic_ioport* %32, %struct.sony_pic_irq* %33)
  %tobool138 = icmp ne i32 %call137, 0
  br i1 %tobool138, label %if.then139, label %if.end141

if.then139:                                       ; preds = %if.end136
  %call140 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.29, i32 0, i32 0))
  br label %err_free_irq

if.end141:                                        ; preds = %if.end136
  store i8 -1, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !51
  %call142 = call i32 @sony_pf_add()
  %tobool143 = icmp ne i32 %call142, 0
  br i1 %tobool143, label %err_disable_device, label %if.end145

if.end145:                                        ; preds = %if.end141
  %34 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %34, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call146 = call i32 @sysfs_create_group(%struct.kobject* %kobj, %struct.attribute_group* @spic_attribute_group)
  %tobool147 = icmp ne i32 %call146, 0
  br i1 %tobool147, label %err_remove_pf, label %cleanup

err_remove_pf:                                    ; preds = %if.end145
  call void @sony_pf_remove()
  br label %err_disable_device

err_disable_device:                               ; preds = %if.end141, %err_remove_pf
  %result.0 = phi i32 [ %call146, %err_remove_pf ], [ %call142, %if.end141 ]
  %call150 = call i32 @sony_pic_disable(%struct.acpi_device* %device)
  br label %err_free_irq

err_free_irq:                                     ; preds = %err_disable_device, %if.then139
  %result.1 = phi i32 [ %call137, %if.then139 ], [ %result.0, %err_disable_device ]
  %35 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !50
  %irq151 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %35, i32 0, i32 0
  %interrupts152 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq151, i32 0, i32 6
  %arrayidx153 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts152, i64 0, i64 0
  %36 = load i8, i8* %arrayidx153, align 2, !tbaa !44
  %conv154 = zext i8 %36 to i32
  call void @free_irq(i32 %conv154, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  br label %err_release_region

err_release_region:                               ; preds = %err_free_irq, %if.then134
  %result.2 = phi i32 [ %result.1, %err_free_irq ], [ -19, %if.then134 ]
  %37 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1155 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %37, i32 0, i32 0
  %minimum156 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1155, i32 0, i32 3
  %38 = load i16, i16* %minimum156, align 1, !tbaa !24
  %conv157 = zext i16 %38 to i64
  %39 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1158 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %39, i32 0, i32 0
  %address_length159 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1158, i32 0, i32 2
  %40 = load i8, i8* %address_length159, align 2, !tbaa !39
  %conv160 = zext i8 %40 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv157, i64 %conv160)
  %41 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io2161 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %41, i32 0, i32 1
  %minimum162 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2161, i32 0, i32 3
  %42 = load i16, i16* %minimum162, align 1, !tbaa !41
  %tobool163 = icmp ne i16 %42, 0
  br i1 %tobool163, label %if.then164, label %err_remove_compat

if.then164:                                       ; preds = %err_release_region
  %43 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io2165 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %43, i32 0, i32 1
  %minimum166 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2165, i32 0, i32 3
  %44 = load i16, i16* %minimum166, align 1, !tbaa !41
  %conv167 = zext i16 %44 to i64
  %45 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io2168 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %45, i32 0, i32 1
  %address_length169 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2168, i32 0, i32 2
  %46 = load i8, i8* %address_length169, align 1, !tbaa !42
  %conv170 = zext i8 %46 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv167, i64 %conv170)
  br label %err_remove_compat

err_remove_compat:                                ; preds = %err_release_region, %if.then164, %if.then92
  %result.3 = phi i32 [ -19, %if.then92 ], [ %result.2, %if.then164 ], [ %result.2, %err_release_region ]
  call void @sonypi_compat_exit()
  br label %err_remove_input

err_remove_input:                                 ; preds = %if.end8, %err_remove_compat
  %result.4 = phi i32 [ %result.3, %err_remove_compat ], [ %call4, %if.end8 ]
  call void @sony_laptop_remove_input()
  br label %err_free_resources

err_free_resources:                               ; preds = %err_remove_input, %if.then6, %if.then
  %result.5 = phi i32 [ %call2, %if.then ], [ %call4, %if.then6 ], [ %result.4, %err_remove_input ]
  %47 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4, i32 0), align 8, !tbaa !52
  %48 = bitcast %struct.list_head* %47 to i8*
  %add.ptr174 = getelementptr inbounds i8, i8* %48, i64 -16
  %49 = bitcast i8* %add.ptr174 to %struct.sony_pic_ioport*
  br label %for.cond179

for.cond179:                                      ; preds = %for.body183, %err_free_resources
  %.sink = phi %struct.sony_pic_ioport* [ %52, %for.body183 ], [ %49, %err_free_resources ]
  %io.1 = phi %struct.sony_pic_ioport* [ %49, %err_free_resources ], [ %52, %for.body183 ]
  %list187 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %.sink, i32 0, i32 2
  %next188 = getelementptr inbounds %struct.list_head, %struct.list_head* %list187, i32 0, i32 0
  %50 = load %struct.list_head*, %struct.list_head** %next188, align 8, !tbaa !53
  %51 = bitcast %struct.list_head* %50 to i8*
  %add.ptr190 = getelementptr inbounds i8, i8* %51, i64 -16
  %52 = bitcast i8* %add.ptr190 to %struct.sony_pic_ioport*
  %list180 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.1, i32 0, i32 2
  %cmp181 = icmp ne %struct.list_head* %list180, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4)
  br i1 %cmp181, label %for.body183, label %for.end191

for.body183:                                      ; preds = %for.cond179
  %list184 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.1, i32 0, i32 2
  call void @list_del(%struct.list_head* %list184)
  %53 = bitcast %struct.sony_pic_ioport* %io.1 to i8*
  call void @kfree(i8* %53)
  br label %for.cond179

for.end191:                                       ; preds = %for.cond179
  %54 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3, i32 0), align 8, !tbaa !52
  %55 = bitcast %struct.list_head* %54 to i8*
  %add.ptr194 = getelementptr inbounds i8, i8* %55, i64 -8
  %56 = bitcast i8* %add.ptr194 to %struct.sony_pic_irq*
  br label %for.cond200

for.cond200:                                      ; preds = %for.body204, %for.end191
  %.sink6 = phi %struct.sony_pic_irq* [ %59, %for.body204 ], [ %56, %for.end191 ]
  %irq.1 = phi %struct.sony_pic_irq* [ %56, %for.end191 ], [ %59, %for.body204 ]
  %list208 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %.sink6, i32 0, i32 1
  %next209 = getelementptr inbounds %struct.list_head, %struct.list_head* %list208, i32 0, i32 0
  %57 = load %struct.list_head*, %struct.list_head** %next209, align 8, !tbaa !54
  %58 = bitcast %struct.list_head* %57 to i8*
  %add.ptr211 = getelementptr inbounds i8, i8* %58, i64 -8
  %59 = bitcast i8* %add.ptr211 to %struct.sony_pic_irq*
  %list201 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.1, i32 0, i32 1
  %cmp202 = icmp ne %struct.list_head* %list201, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3)
  br i1 %cmp202, label %for.body204, label %for.end212

for.body204:                                      ; preds = %for.cond200
  %list205 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.1, i32 0, i32 1
  call void @list_del(%struct.list_head* %list205)
  %60 = bitcast %struct.sony_pic_irq* %irq.1 to i8*
  call void @kfree(i8* %60)
  br label %for.cond200

for.end212:                                       ; preds = %for.cond200
  store %struct.sony_pic_ioport* null, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  store %struct.sony_pic_irq* null, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !50
  br label %cleanup

cleanup:                                          ; preds = %if.end145, %for.end212
  %retval.0 = phi i32 [ %result.5, %for.end212 ], [ 0, %if.end145 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_remove(%struct.acpi_device* %device) #1 {
entry:
  %call = call i32 @sony_pic_disable(%struct.acpi_device* %device)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.77, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %0 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !50
  %irq2 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %0, i32 0, i32 0
  %interrupts = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq2, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts, i64 0, i64 0
  %1 = load i8, i8* %arrayidx, align 2, !tbaa !44
  %conv = zext i8 %1 to i32
  call void @free_irq(i32 %conv, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  %2 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %3 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv3 = zext i16 %3 to i64
  %4 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io14 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %4, i32 0, i32 0
  %address_length = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io14, i32 0, i32 2
  %5 = load i8, i8* %address_length, align 2, !tbaa !39
  %conv5 = zext i8 %5 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv3, i64 %conv5)
  %6 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %6, i32 0, i32 1
  %minimum6 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %7 = load i16, i16* %minimum6, align 1, !tbaa !41
  %tobool7 = icmp ne i16 %7, 0
  br i1 %tobool7, label %if.then8, label %if.end15

if.then8:                                         ; preds = %if.end
  %8 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io29 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %8, i32 0, i32 1
  %minimum10 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io29, i32 0, i32 3
  %9 = load i16, i16* %minimum10, align 1, !tbaa !41
  %conv11 = zext i16 %9 to i64
  %10 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io212 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %10, i32 0, i32 1
  %address_length13 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io212, i32 0, i32 2
  %11 = load i8, i8* %address_length13, align 1, !tbaa !42
  %conv14 = zext i8 %11 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv11, i64 %conv14)
  br label %if.end15

if.end15:                                         ; preds = %if.then8, %if.end
  call void @sonypi_compat_exit()
  call void @sony_laptop_remove_input()
  %12 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %12, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj, %struct.attribute_group* @spic_attribute_group)
  call void @sony_pf_remove()
  %13 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4, i32 0), align 8, !tbaa !52
  %14 = bitcast %struct.list_head* %13 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %14, i64 -16
  %15 = bitcast i8* %add.ptr to %struct.sony_pic_ioport*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end15
  %.sink = phi %struct.sony_pic_ioport* [ %18, %for.body ], [ %15, %if.end15 ]
  %io.0 = phi %struct.sony_pic_ioport* [ %15, %if.end15 ], [ %18, %for.body ]
  %list23 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %.sink, i32 0, i32 2
  %next24 = getelementptr inbounds %struct.list_head, %struct.list_head* %list23, i32 0, i32 0
  %16 = load %struct.list_head*, %struct.list_head** %next24, align 8, !tbaa !53
  %17 = bitcast %struct.list_head* %16 to i8*
  %add.ptr26 = getelementptr inbounds i8, i8* %17, i64 -16
  %18 = bitcast i8* %add.ptr26 to %struct.sony_pic_ioport*
  %list19 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.0, i32 0, i32 2
  %cmp = icmp ne %struct.list_head* %list19, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4)
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %list21 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.0, i32 0, i32 2
  call void @list_del(%struct.list_head* %list21)
  %19 = bitcast %struct.sony_pic_ioport* %io.0 to i8*
  call void @kfree(i8* %19)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %20 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3, i32 0), align 8, !tbaa !52
  %21 = bitcast %struct.list_head* %20 to i8*
  %add.ptr29 = getelementptr inbounds i8, i8* %21, i64 -8
  %22 = bitcast i8* %add.ptr29 to %struct.sony_pic_irq*
  br label %for.cond35

for.cond35:                                       ; preds = %for.body39, %for.end
  %.sink4 = phi %struct.sony_pic_irq* [ %25, %for.body39 ], [ %22, %for.end ]
  %irq.0 = phi %struct.sony_pic_irq* [ %22, %for.end ], [ %25, %for.body39 ]
  %list43 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %.sink4, i32 0, i32 1
  %next44 = getelementptr inbounds %struct.list_head, %struct.list_head* %list43, i32 0, i32 0
  %23 = load %struct.list_head*, %struct.list_head** %next44, align 8, !tbaa !54
  %24 = bitcast %struct.list_head* %23 to i8*
  %add.ptr46 = getelementptr inbounds i8, i8* %24, i64 -8
  %25 = bitcast i8* %add.ptr46 to %struct.sony_pic_irq*
  %list36 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.0, i32 0, i32 1
  %cmp37 = icmp ne %struct.list_head* %list36, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3)
  br i1 %cmp37, label %for.body39, label %for.end47

for.body39:                                       ; preds = %for.cond35
  %list40 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.0, i32 0, i32 1
  call void @list_del(%struct.list_head* %list40)
  %26 = bitcast %struct.sony_pic_irq* %irq.0 to i8*
  call void @kfree(i8* %26)
  br label %for.cond35

for.end47:                                        ; preds = %for.cond35
  store %struct.sony_pic_ioport* null, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  store %struct.sony_pic_irq* null, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !50
  %27 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool48 = icmp ne i32 %27, 0
  br i1 %tobool48, label %if.then49, label %cleanup

if.then49:                                        ; preds = %for.end47
  %call50 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.78, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %for.end47, %if.then49, %if.then
  %retval.0 = phi i32 [ -6, %if.then ], [ 0, %if.then49 ], [ 0, %for.end47 ]
  ret i32 %retval.0
}

declare i8* @strcpy(i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @sony_pic_detect_device_type(%struct.sony_pic_dev* %dev) #1 {
entry:
  %call = call %struct.pci_dev* @pci_get_device(i32 32902, i32 28947, %struct.pci_dev* null)
  %tobool = icmp ne %struct.pci_dev* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %model = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 1, i32* %model, align 8, !tbaa !55
  br label %out

if.end:                                           ; preds = %entry
  %call1 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 9793, %struct.pci_dev* null)
  %tobool2 = icmp ne %struct.pci_dev* %call1, null
  br i1 %tobool2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %model4 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 2, i32* %model4, align 8, !tbaa !55
  br label %out

if.end7:                                          ; preds = %if.end
  %call8 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 10169, %struct.pci_dev* null)
  %tobool9 = icmp ne %struct.pci_dev* %call8, null
  br i1 %tobool9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end7
  %model11 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 4, i32* %model11, align 8, !tbaa !55
  %handle_irq = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 7
  store i32 (i8, i8)* @type3_handle_irq, i32 (i8, i8)** %handle_irq, align 8, !tbaa !56
  br label %out

if.end14:                                         ; preds = %if.end7
  %call15 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 10261, %struct.pci_dev* null)
  %tobool16 = icmp ne %struct.pci_dev* %call15, null
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.end14
  %model18 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 4, i32* %model18, align 8, !tbaa !55
  %handle_irq19 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 7
  store i32 (i8, i8)* @type3_handle_irq, i32 (i8, i8)** %handle_irq19, align 8, !tbaa !56
  br label %out

if.end22:                                         ; preds = %if.end14
  %call23 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 10519, %struct.pci_dev* null)
  %tobool24 = icmp ne %struct.pci_dev* %call23, null
  %model26 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  br i1 %tobool24, label %if.then25, label %if.end30

if.then25:                                        ; preds = %if.end22
  store i32 4, i32* %model26, align 8, !tbaa !55
  %handle_irq27 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 7
  store i32 (i8, i8)* @type3_handle_irq, i32 (i8, i8)** %handle_irq27, align 8, !tbaa !56
  br label %out

if.end30:                                         ; preds = %if.end22
  store i32 2, i32* %model26, align 8, !tbaa !55
  br label %out

out:                                              ; preds = %if.end30, %if.then25, %if.then17, %if.then10, %if.then3, %if.then
  %.sink1 = phi i16 [ 18, %if.end30 ], [ 18, %if.then25 ], [ 18, %if.then17 ], [ 18, %if.then10 ], [ 18, %if.then3 ], [ 4, %if.then ]
  %.sink = phi %struct.sonypi_eventtypes* [ getelementptr inbounds ([15 x %struct.sonypi_eventtypes], [15 x %struct.sonypi_eventtypes]* @type2_events, i32 0, i32 0), %if.end30 ], [ getelementptr inbounds ([12 x %struct.sonypi_eventtypes], [12 x %struct.sonypi_eventtypes]* @type3_events, i32 0, i32 0), %if.then25 ], [ getelementptr inbounds ([12 x %struct.sonypi_eventtypes], [12 x %struct.sonypi_eventtypes]* @type3_events, i32 0, i32 0), %if.then17 ], [ getelementptr inbounds ([12 x %struct.sonypi_eventtypes], [12 x %struct.sonypi_eventtypes]* @type3_events, i32 0, i32 0), %if.then10 ], [ getelementptr inbounds ([15 x %struct.sonypi_eventtypes], [15 x %struct.sonypi_eventtypes]* @type2_events, i32 0, i32 0), %if.then3 ], [ getelementptr inbounds ([11 x %struct.sonypi_eventtypes], [11 x %struct.sonypi_eventtypes]* @type1_events, i32 0, i32 0), %if.then ]
  %pcidev.0 = phi %struct.pci_dev* [ %call, %if.then ], [ %call1, %if.then3 ], [ %call8, %if.then10 ], [ %call15, %if.then17 ], [ %call23, %if.then25 ], [ %call23, %if.end30 ]
  %evport_offset32 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 9
  store i16 %.sink1, i16* %evport_offset32, align 4, !tbaa !57
  %event_types33 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 6
  store %struct.sonypi_eventtypes* %.sink, %struct.sonypi_eventtypes** %event_types33, align 8, !tbaa !58
  %tobool34 = icmp ne %struct.pci_dev* %pcidev.0, null
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %out
  call void @pci_dev_put(%struct.pci_dev* %pcidev.0)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %out
  %model37 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  %0 = load i32, i32* %model37, align 8, !tbaa !55
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end36
  %model38 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  %1 = load i32, i32* %model38, align 8, !tbaa !55
  %cmp39 = icmp eq i32 %1, 2
  %2 = zext i1 %cmp39 to i64
  %cond = select i1 %cmp39, i32 2, i32 3
  br label %cond.end

cond.end:                                         ; preds = %if.end36, %cond.false
  %cond40 = phi i32 [ %cond, %cond.false ], [ 1, %if.end36 ]
  %call41 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.30, i32 0, i32 0), i32 %cond40)
  ret void
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_possible_resources(%struct.acpi_device* %device) #1 {
entry:
  %tobool = icmp ne %struct.acpi_device* %device, null
  br i1 %tobool, label %do.body, label %cleanup

do.body:                                          ; preds = %entry
  %0 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %if.then2, label %do.end

if.then2:                                         ; preds = %do.body
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.31, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then2, %do.body
  %call4 = call i32 @acpi_bus_get_status(%struct.acpi_device* %device)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %do.end
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.32, i32 0, i32 0))
  br label %cleanup

if.end8:                                          ; preds = %do.end
  %status9 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 6
  %1 = bitcast %struct.acpi_device_status* %status9 to i32*
  %bf.load = load i32, i32* %1, align 8
  %bf.lshr = lshr i32 %bf.load, 1
  %bf.clear = and i32 %bf.lshr, 1
  %tobool10 = icmp ne i32 %bf.clear, 0
  %2 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool20 = icmp ne i32 %2, 0
  br i1 %tobool10, label %do.body19, label %do.body12

do.body12:                                        ; preds = %if.end8
  br i1 %tobool20, label %if.then14, label %do.body27

if.then14:                                        ; preds = %do.body12
  %call15 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.33, i32 0, i32 0))
  br label %do.body27

do.body19:                                        ; preds = %if.end8
  br i1 %tobool20, label %if.then21, label %do.body27

if.then21:                                        ; preds = %do.body19
  %call22 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.34, i32 0, i32 0))
  br label %do.body27

do.body27:                                        ; preds = %if.then14, %do.body12, %if.then21, %do.body19
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool28 = icmp ne i32 %3, 0
  br i1 %tobool28, label %if.then29, label %do.end33

if.then29:                                        ; preds = %do.body27
  %call30 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.36, i32 0, i32 0))
  br label %do.end33

do.end33:                                         ; preds = %if.then29, %do.body27
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %4 = load i8*, i8** %handle, align 8, !tbaa !59
  %call34 = call i32 @acpi_walk_resources(i8* %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.36, i32 0, i32 0), i32 (%struct.acpi_resource*, i8*)* @sony_pic_read_possible_resource, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.then36, label %cleanup

if.then36:                                        ; preds = %do.end33
  %call37 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.37, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.36, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %if.then36, %do.end33, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ %call4, %if.then6 ], [ -19, %if.then36 ], [ %call4, %do.end33 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_laptop_setup_input(%struct.acpi_device* %acpi_device) #1 {
entry:
  %call = call i32 @atomic_add_return(i32 1, %struct.atomic_t* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 0))
  %cmp = icmp sgt i32 %call, 1
  br i1 %cmp, label %cleanup, label %do.body

do.body:                                          ; preds = %entry
  %call1 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4))
  call void @__raw_spin_lock_init(%struct.raw_spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.45, i32 0, i32 0), %struct.lock_class_key* @sony_laptop_setup_input.__key)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  %call5 = call i32 @__kfifo_alloc(%struct.__kfifo* %kfifo, i32 128, i64 1, i32 208)
  %call6 = call i32 @__kfifo_int_must_check_helper(i32 %call5)
  %tobool = icmp ne i32 %call6, 0
  br i1 %tobool, label %if.then7, label %do.body11

if.then7:                                         ; preds = %do.body
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.46, i32 0, i32 0))
  br label %err_dec_users

do.body11:                                        ; preds = %do.body
  call void @init_timer_key(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5), i32 0, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.48, i32 0, i32 0), %struct.lock_class_key* @sony_laptop_setup_input.__key.47)
  store void (i64)* @do_sony_laptop_release_key, void (i64)** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5, i32 3), align 8, !tbaa !87
  store i64 0, i64* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5, i32 4), align 8, !tbaa !88
  %call16 = call %struct.input_dev* @input_allocate_device()
  %tobool17 = icmp ne %struct.input_dev* %call16, null
  br i1 %tobool17, label %if.end19, label %err_free_kfifo

if.end19:                                         ; preds = %do.body11
  %name = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 0
  store i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.49, i32 0, i32 0), i8** %name, align 8, !tbaa !89
  %id = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 3
  %bustype = getelementptr inbounds %struct.input_id, %struct.input_id* %id, i32 0, i32 0
  store i16 16, i16* %bustype, align 8, !tbaa !92
  %id20 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 3
  %vendor = getelementptr inbounds %struct.input_id, %struct.input_id* %id20, i32 0, i32 1
  store i16 4173, i16* %vendor, align 2, !tbaa !93
  %dev = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %acpi_device, i32 0, i32 16
  %dev21 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 39
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev21, i32 0, i32 0
  store %struct.device* %dev, %struct.device** %parent, align 8, !tbaa !94
  call void @input_set_capability(%struct.input_dev* %call16, i32 4, i32 4)
  %evbit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 5
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %evbit, i32 0, i32 0
  call void @__set_bit(i32 1, i64* %arraydecay)
  %keycodesize = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 16
  store i32 4, i32* %keycodesize, align 8, !tbaa !95
  %keycodemax = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 15
  store i32 60, i32* %keycodemax, align 4, !tbaa !96
  %keycode = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 17
  store i8* bitcast ([60 x i32]* @sony_laptop_input_keycode_map to i8*), i8** %keycode, align 8, !tbaa !97
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end19
  %i.0 = phi i32 [ 0, %if.end19 ], [ %inc, %for.body ]
  %conv = sext i32 %i.0 to i64
  %cmp22 = icmp ult i64 %conv, 60
  br i1 %cmp22, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [60 x i32], [60 x i32]* @sony_laptop_input_keycode_map, i64 0, i64 %idxprom
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %keybit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 6
  %arraydecay24 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit, i32 0, i32 0
  call void @__set_bit(i32 %1, i64* %arraydecay24)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %keybit25 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 6
  %arraydecay26 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit25, i32 0, i32 0
  call void @__clear_bit(i32 0, i64* %arraydecay26)
  %call27 = call i32 @input_register_device(%struct.input_dev* %call16)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %err_free_keydev, label %if.end30

if.end30:                                         ; preds = %for.end
  store %struct.input_dev* %call16, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !98
  %call31 = call %struct.input_dev* @input_allocate_device()
  %tobool32 = icmp ne %struct.input_dev* %call31, null
  br i1 %tobool32, label %if.end34, label %err_unregister_keydev

if.end34:                                         ; preds = %if.end30
  %name35 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call31, i32 0, i32 0
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.50, i32 0, i32 0), i8** %name35, align 8, !tbaa !89
  %id36 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call31, i32 0, i32 3
  %bustype37 = getelementptr inbounds %struct.input_id, %struct.input_id* %id36, i32 0, i32 0
  store i16 16, i16* %bustype37, align 8, !tbaa !92
  %id38 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call31, i32 0, i32 3
  %vendor39 = getelementptr inbounds %struct.input_id, %struct.input_id* %id38, i32 0, i32 1
  store i16 4173, i16* %vendor39, align 2, !tbaa !93
  %dev40 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %acpi_device, i32 0, i32 16
  %dev41 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call31, i32 0, i32 39
  %parent42 = getelementptr inbounds %struct.device, %struct.device* %dev41, i32 0, i32 0
  store %struct.device* %dev40, %struct.device** %parent42, align 8, !tbaa !94
  call void @input_set_capability(%struct.input_dev* %call31, i32 1, i32 274)
  call void @input_set_capability(%struct.input_dev* %call31, i32 2, i32 8)
  %call43 = call i32 @input_register_device(%struct.input_dev* %call31)
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %err_free_jogdev, label %if.end46

if.end46:                                         ; preds = %if.end34
  store %struct.input_dev* %call31, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !101
  br label %cleanup

err_free_jogdev:                                  ; preds = %if.end34
  call void @input_free_device(%struct.input_dev* %call31)
  br label %err_unregister_keydev

err_unregister_keydev:                            ; preds = %if.end30, %err_free_jogdev
  %error.0 = phi i32 [ %call43, %err_free_jogdev ], [ -12, %if.end30 ]
  call void @input_unregister_device(%struct.input_dev* %call16)
  br label %err_free_keydev

err_free_keydev:                                  ; preds = %for.end, %err_unregister_keydev
  %key_dev.0 = phi %struct.input_dev* [ null, %err_unregister_keydev ], [ %call16, %for.end ]
  %error.1 = phi i32 [ %error.0, %err_unregister_keydev ], [ %call27, %for.end ]
  call void @input_free_device(%struct.input_dev* %key_dev.0)
  br label %err_free_kfifo

err_free_kfifo:                                   ; preds = %do.body11, %err_free_keydev
  %error.2 = phi i32 [ %error.1, %err_free_keydev ], [ -12, %do.body11 ]
  %2 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo49 = bitcast %union.anon.58* %2 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo49)
  br label %err_dec_users

err_dec_users:                                    ; preds = %err_free_kfifo, %if.then7
  %error.3 = phi i32 [ %call6, %if.then7 ], [ %error.2, %err_free_kfifo ]
  call void @atomic_dec(%struct.atomic_t* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %entry, %err_dec_users, %if.end46
  %retval.0 = phi i32 [ %error.3, %err_dec_users ], [ 0, %if.end46 ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_compat_init() #1 {
entry:
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2))
  call void @__raw_spin_lock_init(%struct.raw_spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.51, i32 0, i32 0), %struct.lock_class_key* @sonypi_compat_init.__key)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  %call4 = call i32 @__kfifo_alloc(%struct.__kfifo* %kfifo, i32 128, i64 1, i32 208)
  %call5 = call i32 @__kfifo_int_must_check_helper(i32 %call4)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then, label %do.body7

if.then:                                          ; preds = %entry
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.46, i32 0, i32 0))
  br label %cleanup

do.body7:                                         ; preds = %entry
  call void @__init_waitqueue_head(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.53, i32 0, i32 0), %struct.lock_class_key* @sonypi_compat_init.__key.52)
  %1 = load i32, i32* @minor, align 4, !tbaa !12
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %if.then10, label %if.end11

if.then10:                                        ; preds = %do.body7
  %2 = load i32, i32* @minor, align 4, !tbaa !12
  store i32 %2, i32* getelementptr inbounds (%struct.miscdevice, %struct.miscdevice* @sonypi_misc_device, i32 0, i32 0), align 8, !tbaa !102
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %do.body7
  %call12 = call i32 @misc_register(%struct.miscdevice* @sonypi_misc_device)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  %call15 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.54, i32 0, i32 0))
  %3 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo23 = bitcast %union.anon.58* %3 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo23)
  br label %cleanup

if.end16:                                         ; preds = %if.end11
  %4 = load i32, i32* @minor, align 4, !tbaa !12
  %cmp17 = icmp eq i32 %4, -1
  br i1 %cmp17, label %if.then18, label %cleanup

if.then18:                                        ; preds = %if.end16
  %5 = load i32, i32* getelementptr inbounds (%struct.miscdevice, %struct.miscdevice* @sonypi_misc_device, i32 0, i32 0), align 8, !tbaa !102
  %call19 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.55, i32 0, i32 0), i32 %5)
  br label %cleanup

cleanup:                                          ; preds = %if.end16, %if.then18, %if.then14, %if.then
  %retval.0 = phi i32 [ %call5, %if.then ], [ %call12, %if.then14 ], [ 0, %if.then18 ], [ 0, %if.end16 ]
  ret i32 %retval.0
}

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #2

declare void @__release_region(%struct.resource*, i64, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #0 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_irq(i32 %irq, i8* %dev_id) #1 {
entry:
  %0 = bitcast i8* %dev_id to %struct.sony_pic_dev*
  %cur_ioport = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %1 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport, align 8, !tbaa !23
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %1, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %2 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv = zext i16 %2 to i32
  %call = call zeroext i8 @inb_p(i32 %conv)
  %cur_ioport1 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport1, align 8, !tbaa !23
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 1
  %minimum2 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %4 = load i16, i16* %minimum2, align 1, !tbaa !41
  %tobool = icmp ne i16 %4, 0
  %cur_ioport3 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport3, align 8, !tbaa !23
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %io24 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 1
  %minimum5 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io24, i32 0, i32 3
  %6 = load i16, i16* %minimum5, align 1, !tbaa !41
  %conv6 = zext i16 %6 to i32
  br label %if.end

if.else:                                          ; preds = %entry
  %io19 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum10 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io19, i32 0, i32 3
  %7 = load i16, i16* %minimum10, align 1, !tbaa !24
  %conv11 = zext i16 %7 to i32
  %evport_offset = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 9
  %8 = load i16, i16* %evport_offset, align 4, !tbaa !57
  %conv12 = zext i16 %8 to i32
  %add = add nsw i32 %conv11, %conv12
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %add.sink = phi i32 [ %add, %if.else ], [ %conv6, %if.then ]
  %call13 = call zeroext i8 @inb_p(i32 %add.sink)
  %9 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool14 = icmp ne i32 %9, 0
  br i1 %tobool14, label %if.then15, label %do.end

if.then15:                                        ; preds = %if.end
  %conv16 = zext i8 %call to i32
  %conv17 = zext i8 %call13 to i32
  %cur_ioport18 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %10 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport18, align 8, !tbaa !23
  %io119 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %10, i32 0, i32 0
  %minimum20 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io119, i32 0, i32 3
  %11 = load i16, i16* %minimum20, align 1, !tbaa !24
  %conv21 = zext i16 %11 to i32
  %evport_offset22 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 9
  %12 = load i16, i16* %evport_offset22, align 4, !tbaa !57
  %conv23 = zext i16 %12 to i32
  %call24 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.66, i32 0, i32 0), i32 %conv16, i32 %conv17, i32 %conv21, i32 %conv23)
  br label %do.end

do.end:                                           ; preds = %if.then15, %if.end
  %conv26 = zext i8 %call to i32
  %cmp = icmp eq i32 %conv26, 0
  %conv28 = zext i8 %call to i32
  %cmp29 = icmp eq i32 %conv28, 255
  %or.cond = or i1 %cmp, %cmp29
  br i1 %or.cond, label %cleanup, label %if.end32

if.end32:                                         ; preds = %do.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc87, %if.end32
  %i.0 = phi i32 [ 0, %if.end32 ], [ %inc88, %for.inc87 ]
  %event_types = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %13 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types, align 8, !tbaa !58
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %13, i64 %idxprom
  %mask = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx, i32 0, i32 1
  %14 = load i64, i64* %mask, align 8, !tbaa !104
  %tobool33 = icmp ne i64 %14, 0
  br i1 %tobool33, label %for.body, label %for.end89

for.body:                                         ; preds = %for.cond
  %conv34 = zext i8 %call13 to i32
  %event_types35 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %15 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types35, align 8, !tbaa !58
  %idxprom36 = sext i32 %i.0 to i64
  %arrayidx37 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %15, i64 %idxprom36
  %data = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx37, i32 0, i32 0
  %16 = load i8, i8* %data, align 8, !tbaa !106
  %conv38 = zext i8 %16 to i32
  %and = and i32 %conv34, %conv38
  %event_types39 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %17 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types39, align 8, !tbaa !58
  %idxprom40 = sext i32 %i.0 to i64
  %arrayidx41 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %17, i64 %idxprom40
  %data42 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx41, i32 0, i32 0
  %18 = load i8, i8* %data42, align 8, !tbaa !106
  %conv43 = zext i8 %18 to i32
  %cmp44 = icmp ne i32 %and, %conv43
  br i1 %cmp44, label %for.inc87, label %if.end47

if.end47:                                         ; preds = %for.body
  %19 = load i64, i64* @mask, align 8, !tbaa !107
  %event_types48 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %20 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types48, align 8, !tbaa !58
  %idxprom49 = sext i32 %i.0 to i64
  %arrayidx50 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %20, i64 %idxprom49
  %mask51 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx50, i32 0, i32 1
  %21 = load i64, i64* %mask51, align 8, !tbaa !104
  %and52 = and i64 %19, %21
  %tobool53 = icmp ne i64 %and52, 0
  br i1 %tobool53, label %if.end55, label %for.inc87

if.end55:                                         ; preds = %if.end47
  br label %for.cond56

for.cond56:                                       ; preds = %for.inc, %if.end55
  %j.0 = phi i32 [ 0, %if.end55 ], [ %inc, %for.inc ]
  %event_types57 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %22 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types57, align 8, !tbaa !58
  %idxprom58 = sext i32 %i.0 to i64
  %arrayidx59 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %22, i64 %idxprom58
  %events = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx59, i32 0, i32 2
  %23 = load %struct.sonypi_event*, %struct.sonypi_event** %events, align 8, !tbaa !108
  %idxprom60 = sext i32 %j.0 to i64
  %arrayidx61 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %23, i64 %idxprom60
  %event = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %arrayidx61, i32 0, i32 1
  %24 = load i8, i8* %event, align 1, !tbaa !109
  %tobool62 = icmp ne i8 %24, 0
  br i1 %tobool62, label %for.body63, label %for.inc87

for.body63:                                       ; preds = %for.cond56
  %conv64 = zext i8 %call to i32
  %event_types65 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %25 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types65, align 8, !tbaa !58
  %idxprom66 = sext i32 %i.0 to i64
  %arrayidx67 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %25, i64 %idxprom66
  %events68 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx67, i32 0, i32 2
  %26 = load %struct.sonypi_event*, %struct.sonypi_event** %events68, align 8, !tbaa !108
  %idxprom69 = sext i32 %j.0 to i64
  %arrayidx70 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %26, i64 %idxprom69
  %data71 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %arrayidx70, i32 0, i32 0
  %27 = load i8, i8* %data71, align 1, !tbaa !111
  %conv72 = zext i8 %27 to i32
  %cmp73 = icmp eq i32 %conv64, %conv72
  br i1 %cmp73, label %if.then75, label %for.inc

if.then75:                                        ; preds = %for.body63
  %event_types76 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %28 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types76, align 8, !tbaa !58
  %idxprom77 = sext i32 %i.0 to i64
  %arrayidx78 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %28, i64 %idxprom77
  %events79 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx78, i32 0, i32 2
  %29 = load %struct.sonypi_event*, %struct.sonypi_event** %events79, align 8, !tbaa !108
  %idxprom80 = sext i32 %j.0 to i64
  %arrayidx81 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %29, i64 %idxprom80
  %event82 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %arrayidx81, i32 0, i32 1
  %30 = load i8, i8* %event82, align 1, !tbaa !109
  %tobool83 = icmp ne i8 %30, 0
  br i1 %tobool83, label %found, label %cleanup

for.inc:                                          ; preds = %for.body63
  %inc = add nsw i32 %j.0, 1
  br label %for.cond56

for.inc87:                                        ; preds = %for.cond56, %if.end47, %for.body
  %inc88 = add nsw i32 %i.0, 1
  br label %for.cond

for.end89:                                        ; preds = %for.cond
  %handle_irq = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 7
  %31 = load i32 (i8, i8)*, i32 (i8, i8)** %handle_irq, align 8, !tbaa !56
  %tobool90 = icmp ne i32 (i8, i8)* %31, null
  br i1 %tobool90, label %land.lhs.true, label %do.body97

land.lhs.true:                                    ; preds = %for.end89
  %handle_irq91 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 7
  %32 = load i32 (i8, i8)*, i32 (i8, i8)** %handle_irq91, align 8, !tbaa !56
  %call92 = call i32 %32(i8 zeroext %call13, i8 zeroext %call)
  %cmp93 = icmp ne i32 %call92, 0
  %33 = load i32, i32* @debug, align 4
  %tobool98 = icmp ne i32 %33, 0
  %or.cond1 = and i1 %cmp93, %tobool98
  br i1 %or.cond1, label %if.then99, label %cleanup

do.body97:                                        ; preds = %for.end89
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool98.old = icmp ne i32 %.old, 0
  br i1 %tobool98.old, label %if.then99, label %cleanup

if.then99:                                        ; preds = %land.lhs.true, %do.body97
  %conv100 = zext i8 %call to i32
  %conv101 = zext i8 %call13 to i32
  %cur_ioport102 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %34 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport102, align 8, !tbaa !23
  %io1103 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %34, i32 0, i32 0
  %minimum104 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1103, i32 0, i32 3
  %35 = load i16, i16* %minimum104, align 1, !tbaa !24
  %conv105 = zext i16 %35 to i32
  %evport_offset106 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 9
  %36 = load i16, i16* %evport_offset106, align 4, !tbaa !57
  %conv107 = zext i16 %36 to i32
  %call108 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.67, i32 0, i32 0), i32 %conv100, i32 %conv101, i32 %conv105, i32 %conv107)
  br label %cleanup

found:                                            ; preds = %if.then75
  call void @sony_laptop_report_input_event(i8 zeroext %30)
  %acpi_dev = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 0
  %37 = load %struct.acpi_device*, %struct.acpi_device** %acpi_dev, align 8, !tbaa !37
  %conv112 = zext i8 %30 to i32
  %call113 = call i32 @acpi_bus_generate_proc_event(%struct.acpi_device* %37, i8 zeroext 1, i32 %conv112)
  call void @sonypi_compat_report_event(i8 zeroext %30)
  br label %cleanup

cleanup:                                          ; preds = %land.lhs.true, %do.body97, %if.then99, %if.then75, %do.end, %found
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_enable(%struct.acpi_device* %device, %struct.sony_pic_ioport* %ioport, %struct.sony_pic_irq* %irq) #1 {
entry:
  %buffer = alloca %struct.acpi_buffer, align 8
  %0 = bitcast %struct.acpi_buffer* %buffer to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #8
  %1 = bitcast %struct.acpi_buffer* %buffer to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 16, i32 8, i1 false)
  %tobool = icmp ne %struct.sony_pic_ioport* %ioport, null
  %tobool1 = icmp ne %struct.sony_pic_irq* %irq, null
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call = call i8* @kzalloc(i64 273, i32 208)
  %2 = bitcast i8* %call to %struct.anon.63*
  %tobool2 = icmp ne %struct.anon.63* %2, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %length = getelementptr inbounds %struct.acpi_buffer, %struct.acpi_buffer* %buffer, i32 0, i32 0
  store i64 273, i64* %length, align 8, !tbaa !112
  %3 = bitcast %struct.anon.63* %2 to i8*
  %pointer = getelementptr inbounds %struct.acpi_buffer, %struct.acpi_buffer* %buffer, i32 0, i32 1
  store i8* %3, i8** %pointer, align 8, !tbaa !114
  %4 = load i32, i32* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 8), align 8, !tbaa !55
  %cmp = icmp eq i32 %4, 1
  %res1 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 0
  %type = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res1, i32 0, i32 0
  store i32 4, i32* %type, align 1, !tbaa !115
  %res16 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 0
  %length7 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res16, i32 0, i32 1
  store i32 68, i32* %length7, align 1, !tbaa !118
  %cmp8 = icmp uge i64 7, 64
  %res110 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 0
  %data = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res110, i32 0, i32 2
  %io = bitcast %union.acpi_resource_data* %data to %struct.acpi_resource_io*
  %5 = bitcast %struct.acpi_resource_io* %io to i8*
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %ioport, i32 0, i32 0
  %6 = bitcast %struct.acpi_resource_io* %io1 to i8*
  br i1 %cmp, label %if.then5, label %if.else60

if.then5:                                         ; preds = %if.end4
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then5
  %call11 = call i8* @__memcpy(i8* %5, i8* %6, i64 7)
  br label %if.end16

if.else:                                          ; preds = %if.then5
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 7, i32 1, i1 false)
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then9
  %__ret.0 = phi i8* [ %call11, %if.then9 ], [ %5, %if.else ]
  %res2 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 1
  %type17 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res2, i32 0, i32 0
  store i32 4, i32* %type17, align 1, !tbaa !119
  %res218 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 1
  %length19 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res218, i32 0, i32 1
  store i32 68, i32* %length19, align 1, !tbaa !120
  %cmp22 = icmp uge i64 7, 64
  %res224 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 1
  %data25 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res224, i32 0, i32 2
  %io26 = bitcast %union.acpi_resource_data* %data25 to %struct.acpi_resource_io*
  %7 = bitcast %struct.acpi_resource_io* %io26 to i8*
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %ioport, i32 0, i32 1
  %8 = bitcast %struct.acpi_resource_io* %io2 to i8*
  br i1 %cmp22, label %if.then23, label %if.else28

if.then23:                                        ; preds = %if.end16
  %call27 = call i8* @__memcpy(i8* %7, i8* %8, i64 7)
  br label %if.end33

if.else28:                                        ; preds = %if.end16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 7, i32 1, i1 false)
  br label %if.end33

if.end33:                                         ; preds = %if.else28, %if.then23
  %__ret21.0 = phi i8* [ %call27, %if.then23 ], [ %7, %if.else28 ]
  %res3 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 2
  %type35 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res3, i32 0, i32 0
  store i32 0, i32* %type35, align 1, !tbaa !121
  %res336 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 2
  %length37 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res336, i32 0, i32 1
  store i32 68, i32* %length37, align 1, !tbaa !122
  %cmp40 = icmp uge i64 7, 64
  %res342 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 2
  %data43 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res342, i32 0, i32 2
  %irq44 = bitcast %union.acpi_resource_data* %data43 to %struct.acpi_resource_irq*
  %9 = bitcast %struct.acpi_resource_irq* %irq44 to i8*
  %irq45 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq, i32 0, i32 0
  %10 = bitcast %struct.acpi_resource_irq* %irq45 to i8*
  br i1 %cmp40, label %if.then41, label %if.else47

if.then41:                                        ; preds = %if.end33
  %call46 = call i8* @__memcpy(i8* %9, i8* %10, i64 7)
  br label %if.end52

if.else47:                                        ; preds = %if.end33
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 7, i32 1, i1 false)
  br label %if.end52

if.end52:                                         ; preds = %if.else47, %if.then41
  %__ret39.0 = phi i8* [ %call46, %if.then41 ], [ %9, %if.else47 ]
  %res354 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 2
  %data55 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res354, i32 0, i32 2
  %irq56 = bitcast %union.acpi_resource_data* %data55 to %struct.acpi_resource_irq*
  %sharable = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq56, i32 0, i32 3
  store i8 1, i8* %sharable, align 1, !tbaa !44
  %res4 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 3
  %type57 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res4, i32 0, i32 0
  store i32 7, i32* %type57, align 1, !tbaa !123
  %res458 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 3
  br label %if.end109

if.else60:                                        ; preds = %if.end4
  br i1 %cmp8, label %if.then68, label %if.else74

if.then68:                                        ; preds = %if.else60
  %call73 = call i8* @__memcpy(i8* %5, i8* %6, i64 7)
  br label %if.end79

if.else74:                                        ; preds = %if.else60
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 7, i32 1, i1 false)
  br label %if.end79

if.end79:                                         ; preds = %if.else74, %if.then68
  %__ret66.0 = phi i8* [ %call73, %if.then68 ], [ %5, %if.else74 ]
  %res281 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 1
  %type82 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res281, i32 0, i32 0
  store i32 0, i32* %type82, align 1, !tbaa !119
  %res283 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 1
  %length84 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res283, i32 0, i32 1
  store i32 68, i32* %length84, align 1, !tbaa !120
  %cmp87 = icmp uge i64 7, 64
  %res289 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 1
  %data90 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res289, i32 0, i32 2
  %irq91 = bitcast %union.acpi_resource_data* %data90 to %struct.acpi_resource_irq*
  %11 = bitcast %struct.acpi_resource_irq* %irq91 to i8*
  %irq92 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq, i32 0, i32 0
  %12 = bitcast %struct.acpi_resource_irq* %irq92 to i8*
  br i1 %cmp87, label %if.then88, label %if.else94

if.then88:                                        ; preds = %if.end79
  %call93 = call i8* @__memcpy(i8* %11, i8* %12, i64 7)
  br label %if.end99

if.else94:                                        ; preds = %if.end79
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 7, i32 1, i1 false)
  br label %if.end99

if.end99:                                         ; preds = %if.else94, %if.then88
  %__ret86.0 = phi i8* [ %call93, %if.then88 ], [ %11, %if.else94 ]
  %res2101 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 1
  %data102 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res2101, i32 0, i32 2
  %irq103 = bitcast %union.acpi_resource_data* %data102 to %struct.acpi_resource_irq*
  %sharable104 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq103, i32 0, i32 3
  store i8 1, i8* %sharable104, align 1, !tbaa !44
  %res3105 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 2
  %type106 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res3105, i32 0, i32 0
  store i32 7, i32* %type106, align 1, !tbaa !121
  %res3107 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %2, i32 0, i32 2
  br label %if.end109

if.end109:                                        ; preds = %if.end99, %if.end52
  %res3107.sink = phi %struct.acpi_resource* [ %res3107, %if.end99 ], [ %res458, %if.end52 ]
  %length108 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res3107.sink, i32 0, i32 1
  store i32 68, i32* %length108, align 1, !tbaa !12
  %13 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool110 = icmp ne i32 %13, 0
  br i1 %tobool110, label %if.then111, label %do.end

if.then111:                                       ; preds = %if.end109
  %call112 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.70, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then111, %if.end109
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %14 = load i8*, i8** %handle, align 8, !tbaa !59
  %call114 = call i32 @acpi_set_current_resources(i8* %14, %struct.acpi_buffer* %buffer)
  %tobool115 = icmp ne i32 %call114, 0
  br i1 %tobool115, label %if.then116, label %if.end118

if.then116:                                       ; preds = %do.end
  %call117 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.71, i32 0, i32 0))
  br label %end

if.end118:                                        ; preds = %do.end
  %call119 = call zeroext i8 @sony_pic_call1(i8 zeroext -126)
  %call120 = call zeroext i8 @sony_pic_call2(i8 zeroext -127, i8 zeroext -1)
  %15 = load i32, i32* @compat, align 4, !tbaa !12
  %tobool121 = icmp ne i32 %15, 0
  %16 = zext i1 %tobool121 to i64
  %cond = select i1 %tobool121, i32 146, i32 130
  %conv = trunc i32 %cond to i8
  %call122 = call zeroext i8 @sony_pic_call1(i8 zeroext %conv)
  br label %end

end:                                              ; preds = %if.end118, %if.then116
  %result.0 = phi i32 [ -19, %if.then116 ], [ 0, %if.end118 ]
  %17 = bitcast %struct.anon.63* %2 to i8*
  call void @kfree(i8* %17)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %end
  %retval.0 = phi i32 [ %result.0, %end ], [ -22, %entry ], [ -12, %if.end ]
  %18 = bitcast %struct.acpi_buffer* %buffer to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %18) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pf_add() #1 {
entry:
  %call = call i32 @atomic_add_return(i32 1, %struct.atomic_t* @sony_pf_users)
  %cmp = icmp sgt i32 %call, 1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @platform_driver_register(%struct.platform_driver* @sony_pf_driver)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %out, label %if.end3

if.end3:                                          ; preds = %if.end
  %call4 = call %struct.platform_device* @platform_device_alloc(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.26, i32 0, i32 0), i32 -1)
  store %struct.platform_device* %call4, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  %0 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  %tobool5 = icmp ne %struct.platform_device* %0, null
  br i1 %tobool5, label %if.end7, label %out_platform_registered

if.end7:                                          ; preds = %if.end3
  %1 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  %call8 = call i32 @platform_device_add(%struct.platform_device* %1)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %out_platform_alloced, label %cleanup

out_platform_alloced:                             ; preds = %if.end7
  %2 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  call void @platform_device_put(%struct.platform_device* %2)
  store %struct.platform_device* null, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  br label %out_platform_registered

out_platform_registered:                          ; preds = %if.end3, %out_platform_alloced
  %ret.0 = phi i32 [ %call8, %out_platform_alloced ], [ -12, %if.end3 ]
  call void @platform_driver_unregister(%struct.platform_driver* @sony_pf_driver)
  br label %out

out:                                              ; preds = %if.end, %out_platform_registered
  %ret.1 = phi i32 [ %ret.0, %out_platform_registered ], [ %call1, %if.end ]
  call void @atomic_dec(%struct.atomic_t* @sony_pf_users)
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %entry, %out
  %retval.0 = phi i32 [ %ret.1, %out ], [ 0, %entry ], [ 0, %if.end7 ]
  ret i32 %retval.0
}

declare i32 @sysfs_create_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: nounwind uwtable
define internal void @sony_pf_remove() #1 {
entry:
  %call = call i32 @atomic_dec_and_test(%struct.atomic_t* @sony_pf_users)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %0 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  call void @platform_device_unregister(%struct.platform_device* %0)
  call void @platform_driver_unregister(%struct.platform_driver* @sony_pf_driver)
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_disable(%struct.acpi_device* %device) #1 {
entry:
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %0 = load i8*, i8** %handle, align 8, !tbaa !59
  %call = call i32 @acpi_evaluate_object(i8* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.76, i32 0, i32 0), %struct.acpi_object_list* null, %struct.acpi_buffer* null)
  switch i32 %call, label %cleanup [
    i32 0, label %do.body
    i32 5, label %do.body
  ]

do.body:                                          ; preds = %entry, %entry
  %1 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %do.body
  %call3 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.33, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %do.body, %if.then2, %entry
  %retval.0 = phi i32 [ -6, %entry ], [ 0, %if.then2 ], [ 0, %do.body ]
  ret i32 %retval.0
}

declare void @free_irq(i32, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @sonypi_compat_exit() #1 {
entry:
  %call = call i32 @misc_deregister(%struct.miscdevice* @sonypi_misc_device)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_laptop_remove_input() #1 {
entry:
  %kp = alloca %struct.sony_laptop_keypress, align 8
  %0 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #8
  %1 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 16, i32 8, i1 false)
  %call = call i32 @atomic_dec_and_test(%struct.atomic_t* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 0))
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @del_timer_sync(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5))
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %2 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %3 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %3 to %struct.__kfifo*
  %conv = trunc i64 16 to i32
  %call2 = call i32 @__kfifo_out(%struct.__kfifo* %kfifo, i8* %2, i32 %conv)
  %call3 = call i32 @__kfifo_uint_must_check_helper(i32 %call2)
  %conv4 = zext i32 %call3 to i64
  %cmp = icmp eq i64 %conv4, 16
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %dev = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %4 = load %struct.input_dev*, %struct.input_dev** %dev, align 8, !tbaa !124
  %key = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %5 = load i32, i32* %key, align 8, !tbaa !126
  call void @input_report_key(%struct.input_dev* %4, i32 %5, i32 0)
  %dev6 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %6 = load %struct.input_dev*, %struct.input_dev** %dev6, align 8, !tbaa !124
  call void @input_sync(%struct.input_dev* %6)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %7 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !98
  call void @input_unregister_device(%struct.input_dev* %7)
  store %struct.input_dev* null, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !98
  %8 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !101
  %tobool7 = icmp ne %struct.input_dev* %8, null
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %while.end
  %9 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !101
  call void @input_unregister_device(%struct.input_dev* %9)
  store %struct.input_dev* null, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !101
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %while.end
  %10 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo12 = bitcast %union.anon.58* %10 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo12)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end9
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end9 ], [ 1, %entry ]
  %11 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %11) #8
  ret void
}

declare void @list_del(%struct.list_head*) #2

declare void @kfree(i8*) #2

declare %struct.pci_dev* @pci_get_device(i32, i32, %struct.pci_dev*) #2

; Function Attrs: nounwind uwtable
define internal i32 @type3_handle_irq(i8 zeroext %data_mask, i8 zeroext %ev) #1 {
entry:
  %conv = zext i8 %data_mask to i32
  %cmp = icmp eq i32 %conv, 49
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %conv2 = zext i8 %ev to i32
  %cmp3 = icmp eq i32 %conv2, 92
  %conv5 = zext i8 %ev to i32
  %cmp6 = icmp eq i32 %conv5, 95
  %or.cond = or i1 %cmp3, %cmp6
  br i1 %or.cond, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call = call zeroext i8 @sony_pic_call1(i8 zeroext -96)
  br label %return

if.else:                                          ; preds = %if.then
  %conv9 = zext i8 %ev to i32
  %cmp10 = icmp eq i32 %conv9, 97
  br i1 %cmp10, label %if.then12, label %return

if.then12:                                        ; preds = %if.else
  %call13 = call zeroext i8 @sony_pic_call1(i8 zeroext -77)
  br label %return

return:                                           ; preds = %entry, %if.then8, %if.then12, %if.else
  %retval.0 = phi i32 [ 0, %if.else ], [ 0, %if.then12 ], [ 0, %if.then8 ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @pci_dev_put(%struct.pci_dev*) #2

declare i32 @acpi_bus_get_status(%struct.acpi_device*) #2

declare i32 @acpi_walk_resources(i8*, i8*, i32 (%struct.acpi_resource*, i8*)*, i8*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_read_possible_resource(%struct.acpi_resource* %resource, i8* %context) #1 {
entry:
  %0 = bitcast i8* %context to %struct.sony_pic_dev*
  %type = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %resource, i32 0, i32 0
  %1 = load i32, i32* %type, align 1, !tbaa !127
  %Pivot10 = icmp slt i32 %1, 3
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %1, 4
  br i1 %Pivot8, label %cleanup123, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %1, 7
  br i1 %Pivot6, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp ne i32 %1, 7
  %2 = load i32, i32* @debug, align 4
  %tobool115 = icmp ne i32 %2, 0
  %or.cond = and i1 %SwitchLeaf4, %tobool115
  br i1 %or.cond, label %if.then116, label %cleanup123

LeafBlock1:                                       ; preds = %NodeBlock5
  %SwitchLeaf2 = icmp eq i32 %1, 4
  br i1 %SwitchLeaf2, label %sw.bb43, label %do.body114

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %1, 2
  br i1 %Pivot, label %LeafBlock, label %sw.bb

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %1, 0
  br i1 %SwitchLeaf, label %sw.bb2, label %do.body114

sw.bb:                                            ; preds = %NodeBlock
  %call = call i8* @kzalloc(i64 32, i32 208)
  %3 = bitcast i8* %call to %struct.sony_pic_ioport*
  %tobool = icmp ne %struct.sony_pic_ioport* %3, null
  br i1 %tobool, label %if.end, label %cleanup123

if.end:                                           ; preds = %sw.bb
  %list = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 2
  %ioports = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 4
  call void @list_add(%struct.list_head* %list, %struct.list_head* %ioports)
  br label %cleanup123

sw.bb2:                                           ; preds = %LeafBlock
  %data = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %resource, i32 0, i32 2
  %irq = bitcast %union.acpi_resource_data* %data to %struct.acpi_resource_irq*
  %tobool3 = icmp ne %struct.acpi_resource_irq* %irq, null
  br i1 %tobool3, label %lor.lhs.false, label %do.body

lor.lhs.false:                                    ; preds = %sw.bb2
  %interrupt_count = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 5
  %4 = load i8, i8* %interrupt_count, align 1, !tbaa !128
  %tobool4 = icmp ne i8 %4, 0
  br i1 %tobool4, label %if.end10, label %do.body

do.body:                                          ; preds = %sw.bb2, %lor.lhs.false
  %5 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool6 = icmp ne i32 %5, 0
  br i1 %tobool6, label %if.then7, label %cleanup123

if.then7:                                         ; preds = %do.body
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.38, i32 0, i32 0))
  br label %cleanup123

if.end10:                                         ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %i.0 = phi i32 [ 0, %if.end10 ], [ %inc, %for.inc ]
  %interrupt_count11 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 5
  %6 = load i8, i8* %interrupt_count11, align 1, !tbaa !128
  %conv = zext i8 %6 to i32
  %cmp = icmp ult i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup123

for.body:                                         ; preds = %for.cond
  %interrupts = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 6
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts, i64 0, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !44
  %tobool13 = icmp ne i8 %7, 0
  br i1 %tobool13, label %if.end20, label %if.then14

if.then14:                                        ; preds = %for.body
  %interrupts15 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 6
  %idxprom16 = zext i32 %i.0 to i64
  %arrayidx17 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts15, i64 0, i64 %idxprom16
  %8 = load i8, i8* %arrayidx17, align 1, !tbaa !44
  %conv18 = zext i8 %8 to i32
  %call19 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.39, i32 0, i32 0), i32 %conv18)
  br label %for.inc

if.end20:                                         ; preds = %for.body
  %call21 = call i8* @kzalloc(i64 24, i32 208)
  %9 = bitcast i8* %call21 to %struct.sony_pic_irq*
  %tobool22 = icmp ne %struct.sony_pic_irq* %9, null
  br i1 %tobool22, label %if.end24, label %cleanup123

if.end24:                                         ; preds = %if.end20
  %list25 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %9, i32 0, i32 1
  %interrupts26 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 3
  call void @list_add(%struct.list_head* %list25, %struct.list_head* %interrupts26)
  %triggering = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 1
  %10 = load i8, i8* %triggering, align 1, !tbaa !129
  %irq27 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %9, i32 0, i32 0
  %triggering28 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq27, i32 0, i32 1
  store i8 %10, i8* %triggering28, align 1, !tbaa !45
  %polarity = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 2
  %11 = load i8, i8* %polarity, align 1, !tbaa !130
  %irq29 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %9, i32 0, i32 0
  %polarity30 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq29, i32 0, i32 2
  store i8 %11, i8* %polarity30, align 2, !tbaa !48
  %sharable = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 3
  %12 = load i8, i8* %sharable, align 1, !tbaa !131
  %irq31 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %9, i32 0, i32 0
  %sharable32 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq31, i32 0, i32 3
  store i8 %12, i8* %sharable32, align 1, !tbaa !49
  %irq33 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %9, i32 0, i32 0
  %interrupt_count34 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq33, i32 0, i32 5
  store i8 1, i8* %interrupt_count34, align 1, !tbaa !132
  %interrupts35 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 6
  %idxprom36 = zext i32 %i.0 to i64
  %arrayidx37 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts35, i64 0, i64 %idxprom36
  %13 = load i8, i8* %arrayidx37, align 1, !tbaa !44
  %irq38 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %9, i32 0, i32 0
  %interrupts39 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq38, i32 0, i32 6
  %arrayidx40 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts39, i64 0, i64 0
  store i8 %13, i8* %arrayidx40, align 2, !tbaa !44
  br label %for.inc

for.inc:                                          ; preds = %if.end24, %if.then14
  %inc = add i32 %i.0, 1
  br label %for.cond

sw.bb43:                                          ; preds = %LeafBlock1
  %data44 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %resource, i32 0, i32 2
  %io45 = bitcast %union.acpi_resource_data* %data44 to %struct.acpi_resource_io*
  %ioports47 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %ioports47, i32 0, i32 0
  %14 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !52
  %15 = bitcast %struct.list_head* %14 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %15, i64 -16
  %16 = bitcast i8* %add.ptr to %struct.sony_pic_ioport*
  %tobool48 = icmp ne %struct.acpi_resource_io* %io45, null
  br i1 %tobool48, label %if.end57, label %do.body50

do.body50:                                        ; preds = %sw.bb43
  %17 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool51 = icmp ne i32 %17, 0
  br i1 %tobool51, label %if.then52, label %cleanup123

if.then52:                                        ; preds = %do.body50
  %call53 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.40, i32 0, i32 0))
  br label %cleanup123

if.end57:                                         ; preds = %sw.bb43
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %16, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %18 = load i16, i16* %minimum, align 1, !tbaa !24
  %tobool58 = icmp ne i16 %18, 0
  br i1 %tobool58, label %if.else80, label %if.then59

if.then59:                                        ; preds = %if.end57
  %cmp60 = icmp uge i64 7, 64
  %io163 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %16, i32 0, i32 0
  %19 = bitcast %struct.acpi_resource_io* %io163 to i8*
  %20 = bitcast %struct.acpi_resource_io* %io45 to i8*
  br i1 %cmp60, label %if.then62, label %if.else

if.then62:                                        ; preds = %if.then59
  %call64 = call i8* @__memcpy(i8* %19, i8* %20, i64 7)
  br label %do.body68

if.else:                                          ; preds = %if.then59
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* %20, i64 7, i32 1, i1 false)
  br label %do.body68

do.body68:                                        ; preds = %if.then62, %if.else
  %__ret.0 = phi i8* [ %call64, %if.then62 ], [ %19, %if.else ]
  %21 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool69 = icmp ne i32 %21, 0
  br i1 %tobool69, label %if.then70, label %cleanup123

if.then70:                                        ; preds = %do.body68
  %io171 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %16, i32 0, i32 0
  %minimum72 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io171, i32 0, i32 3
  %22 = load i16, i16* %minimum72, align 1, !tbaa !24
  %conv73 = zext i16 %22 to i32
  %io174 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %16, i32 0, i32 0
  %address_length = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io174, i32 0, i32 2
  %23 = load i8, i8* %address_length, align 2, !tbaa !39
  %conv75 = zext i8 %23 to i32
  %call76 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.41, i32 0, i32 0), i32 %conv73, i32 %conv75)
  br label %cleanup123

if.else80:                                        ; preds = %if.end57
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %16, i32 0, i32 1
  %minimum81 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %24 = load i16, i16* %minimum81, align 1, !tbaa !41
  %tobool82 = icmp ne i16 %24, 0
  br i1 %tobool82, label %if.else108, label %if.then83

if.then83:                                        ; preds = %if.else80
  %cmp86 = icmp uge i64 7, 64
  %io289 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %16, i32 0, i32 1
  %25 = bitcast %struct.acpi_resource_io* %io289 to i8*
  %26 = bitcast %struct.acpi_resource_io* %io45 to i8*
  br i1 %cmp86, label %if.then88, label %if.else91

if.then88:                                        ; preds = %if.then83
  %call90 = call i8* @__memcpy(i8* %25, i8* %26, i64 7)
  br label %do.body95

if.else91:                                        ; preds = %if.then83
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %25, i8* %26, i64 7, i32 1, i1 false)
  br label %do.body95

do.body95:                                        ; preds = %if.then88, %if.else91
  %__ret85.0 = phi i8* [ %call90, %if.then88 ], [ %25, %if.else91 ]
  %27 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool96 = icmp ne i32 %27, 0
  br i1 %tobool96, label %if.then97, label %cleanup123

if.then97:                                        ; preds = %do.body95
  %io298 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %16, i32 0, i32 1
  %minimum99 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io298, i32 0, i32 3
  %28 = load i16, i16* %minimum99, align 1, !tbaa !41
  %conv100 = zext i16 %28 to i32
  %io2101 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %16, i32 0, i32 1
  %address_length102 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2101, i32 0, i32 2
  %29 = load i8, i8* %address_length102, align 1, !tbaa !42
  %conv103 = zext i8 %29 to i32
  %call104 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.42, i32 0, i32 0), i32 %conv100, i32 %conv103)
  br label %cleanup123

if.else108:                                       ; preds = %if.else80
  %call109 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.43, i32 0, i32 0))
  br label %cleanup123

do.body114:                                       ; preds = %LeafBlock1, %LeafBlock
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool115.old = icmp ne i32 %.old, 0
  br i1 %tobool115.old, label %if.then116, label %cleanup123

if.then116:                                       ; preds = %LeafBlock3, %do.body114
  %type117 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %resource, i32 0, i32 0
  %30 = load i32, i32* %type117, align 1, !tbaa !127
  %call118 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.44, i32 0, i32 0), i32 %30)
  br label %cleanup123

cleanup123:                                       ; preds = %LeafBlock3, %if.then116, %do.body114, %if.else108, %if.then52, %do.body50, %if.then97, %do.body95, %do.body68, %if.then70, %if.then7, %do.body, %if.end20, %for.cond, %NodeBlock7, %if.end, %sw.bb
  %retval.3 = phi i32 [ 0, %if.end ], [ 1, %sw.bb ], [ 0, %NodeBlock7 ], [ 0, %if.then7 ], [ 0, %do.body ], [ 1, %if.end20 ], [ 0, %for.cond ], [ 1, %if.else108 ], [ 0, %if.then52 ], [ 0, %do.body50 ], [ 0, %if.then97 ], [ 0, %do.body95 ], [ 0, %do.body68 ], [ 0, %if.then70 ], [ 0, %do.body114 ], [ 0, %if.then116 ], [ 0, %LeafBlock3 ]
  ret i32 %retval.3
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #0 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !52
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

declare i8* @__memcpy(i8*, i8*, i64) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #3

declare void @__list_add(%struct.list_head*, %struct.list_head*, %struct.list_head*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return(i32 %i, %struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #8, !srcloc !133
  %add = add nsw i32 %i, %0
  ret i32 %add
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kfifo_int_must_check_helper(i32 %val) #0 {
entry:
  ret i32 %val
}

declare i32 @__kfifo_alloc(%struct.__kfifo*, i32, i64, i32) #2

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal void @do_sony_laptop_release_key(i64 %unused) #1 {
entry:
  %kp = alloca %struct.sony_laptop_keypress, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #8
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #8
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4))
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %5 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %6 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %6 to %struct.__kfifo*
  %conv6 = trunc i64 16 to i32
  %call7 = call i32 @__kfifo_out(%struct.__kfifo* %kfifo, i8* %5, i32 %conv6)
  %call8 = call i32 @__kfifo_uint_must_check_helper(i32 %call7)
  %conv9 = zext i32 %call8 to i64
  %cmp10 = icmp eq i64 %conv9, 16
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %7 = load %struct.input_dev*, %struct.input_dev** %dev, align 8, !tbaa !124
  %key = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %8 = load i32, i32* %key, align 8, !tbaa !126
  call void @input_report_key(%struct.input_dev* %7, i32 %8, i32 0)
  %dev12 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %9 = load %struct.input_dev*, %struct.input_dev** %dev12, align 8, !tbaa !124
  call void @input_sync(%struct.input_dev* %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo14 = bitcast %union.anon.58* %10 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo14, i32 0, i32 0
  %11 = load i32, i32* %in, align 8, !tbaa !44
  %12 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo15 = bitcast %union.anon.58* %12 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo15, i32 0, i32 1
  %13 = load i32, i32* %out, align 4, !tbaa !44
  %sub = sub i32 %11, %13
  %cmp16 = icmp ne i32 %sub, 0
  br i1 %cmp16, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.end
  %14 = load volatile i64, i64* @jiffies, align 8, !tbaa !107
  %call19 = call i64 @msecs_to_jiffies(i32 10)
  %add = add i64 %14, %call19
  %call20 = call i32 @mod_timer(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5), i64 %add)
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %if.end
  call void @spin_unlock_irqrestore(%struct.spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4), i64 %call2)
  %15 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %15) #8
  ret void
}

declare %struct.input_dev* @input_allocate_device() #2

declare void @input_set_capability(%struct.input_dev*, i32, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @__set_bit(i32 %nr, i64* %addr) #0 {
entry:
  call void asm sideeffect "bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #8, !srcloc !134
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__clear_bit(i32 %nr, i64* %addr) #0 {
entry:
  call void asm sideeffect "btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #8, !srcloc !135
  ret void
}

declare i32 @input_register_device(%struct.input_dev*) #2

declare void @input_free_device(%struct.input_dev*) #2

declare void @input_unregister_device(%struct.input_dev*) #2

declare void @__kfifo_free(%struct.__kfifo*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_dec(%struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !136
  ret void
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #2 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kfifo_uint_must_check_helper(i32 %val) #0 {
entry:
  ret i32 %val
}

declare i32 @__kfifo_out(%struct.__kfifo*, i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_key(%struct.input_dev* %dev, i32 %code, i32 %value) #0 {
entry:
  %tobool = icmp ne i32 %value, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  call void @input_event(%struct.input_dev* %dev, i32 1, i32 %code, i32 %lnot.ext)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_sync(%struct.input_dev* %dev) #0 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 0, i32 0, i32 0)
  ret void
}

declare i32 @mod_timer(%struct.timer_list*, i64) #2

declare i64 @msecs_to_jiffies(i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @input_event(%struct.input_dev*, i32, i32, i32) #2

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #2 section ".spinlock.text"

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #2

declare i32 @misc_register(%struct.miscdevice*) #2

declare i64 @noop_llseek(%struct.file*, i64, i32) #2

; Function Attrs: nounwind uwtable
define internal i64 @sonypi_misc_read(%struct.file* %file, i8* %buf, i64 %count, i64* %pos) #1 {
entry:
  %c = alloca i8, align 1
  %__wait = alloca %struct.__wait_queue, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %coerce = alloca %struct.timespec, align 8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #8
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo, i32 0, i32 0
  %1 = load i32, i32* %in, align 8, !tbaa !44
  %2 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo1 = bitcast %union.anon.58* %2 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo1, i32 0, i32 1
  %3 = load i32, i32* %out, align 4, !tbaa !44
  %sub = sub i32 %1, %3
  %cmp = icmp eq i32 %sub, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %4 = load i32, i32* %f_flags, align 8, !tbaa !137
  %and = and i32 %4, 2048
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %5 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo4 = bitcast %union.anon.58* %5 to %struct.__kfifo*
  %in5 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo4, i32 0, i32 0
  %6 = load i32, i32* %in5, align 8, !tbaa !44
  %7 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo6 = bitcast %union.anon.58* %7 to %struct.__kfifo*
  %out7 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo6, i32 0, i32 1
  %8 = load i32, i32* %out7, align 4, !tbaa !44
  %sub8 = sub i32 %6, %8
  %cmp9 = icmp ne i32 %sub8, 0
  br i1 %cmp9, label %if.end28, label %do.body

do.body:                                          ; preds = %if.end
  %9 = bitcast %struct.__wait_queue* %__wait to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %9) #8
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !143
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %call = call %struct.task_struct* @get_current()
  %10 = bitcast %struct.task_struct* %call to i8*
  store i8* %10, i8** %private, align 8, !tbaa !145
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !146
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list11 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list11, %struct.list_head** %next, align 8, !tbaa !52
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list12 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list12, %struct.list_head** %prev, align 8, !tbaa !147
  br label %for.cond

for.cond:                                         ; preds = %if.then26, %do.body
  call void @prepare_to_wait(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), %struct.__wait_queue* %__wait, i32 1)
  %11 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo15 = bitcast %union.anon.58* %11 to %struct.__kfifo*
  %in16 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo15, i32 0, i32 0
  %12 = load i32, i32* %in16, align 8, !tbaa !44
  %13 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo17 = bitcast %union.anon.58* %13 to %struct.__kfifo*
  %out18 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo17, i32 0, i32 1
  %14 = load i32, i32* %out18, align 4, !tbaa !44
  %sub19 = sub i32 %12, %14
  %cmp20 = icmp ne i32 %sub19, 0
  br i1 %cmp20, label %for.end, label %if.end22

if.end22:                                         ; preds = %for.cond
  %call23 = call %struct.task_struct* @get_current()
  %call24 = call i32 @signal_pending(%struct.task_struct* %call23)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %for.end, label %if.then26

if.then26:                                        ; preds = %if.end22
  call void @schedule()
  br label %for.cond

for.end:                                          ; preds = %if.end22, %for.cond
  %__ret.0 = phi i32 [ 0, %for.cond ], [ -512, %if.end22 ]
  call void @finish_wait(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), %struct.__wait_queue* %__wait)
  %15 = bitcast %struct.__wait_queue* %__wait to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %15) #8
  br label %if.end28

if.end28:                                         ; preds = %for.end, %if.end
  %__ret.1 = phi i32 [ 0, %if.end ], [ %__ret.0, %for.end ]
  %conv = sext i32 %__ret.1 to i64
  %tobool30 = icmp ne i64 %conv, 0
  br i1 %tobool30, label %cleanup, label %if.end32

if.end32:                                         ; preds = %if.end28
  br label %while.cond

while.cond:                                       ; preds = %if.end60, %if.end32
  %ret.0 = phi i64 [ %conv, %if.end32 ], [ %inc, %if.end60 ]
  %buf.addr.0 = phi i8* [ %buf, %if.end32 ], [ %incdec.ptr, %if.end60 ]
  %cmp33 = icmp ult i64 %ret.0, %count
  br i1 %cmp33, label %do.body37, label %while.end

do.body37:                                        ; preds = %while.cond
  %16 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #8
  %17 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %17) #8
  %cmp38 = icmp eq i64* %__dummy, %__dummy2
  %conv39 = zext i1 %cmp38 to i32
  %18 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #8
  %19 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %19) #8
  %call41 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2))
  %call42 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call41)
  %20 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo47 = bitcast %union.anon.58* %20 to %struct.__kfifo*
  %conv49 = trunc i64 1 to i32
  %call50 = call i32 @__kfifo_out(%struct.__kfifo* %kfifo47, i8* %c, i32 %conv49)
  %call51 = call i32 @__kfifo_uint_must_check_helper(i32 %call50)
  call void @spin_unlock_irqrestore(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2), i64 %call42)
  %call53 = call i32 @__kfifo_uint_must_check_helper(i32 %call51)
  %conv54 = zext i32 %call53 to i64
  %cmp55 = icmp eq i64 %conv54, 1
  br i1 %cmp55, label %while.body, label %while.end

while.body:                                       ; preds = %do.body37
  call void @might_fault()
  %21 = load i8, i8* %c, align 1, !tbaa !44
  %22 = zext i8 %21 to i32
  %incdec.ptr = getelementptr inbounds i8, i8* %buf.addr.0, i32 1
  %23 = call i32 asm sideeffect "call __put_user_1", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %22, i8* %buf.addr.0) #8, !srcloc !148
  %tobool58 = icmp ne i32 %23, 0
  br i1 %tobool58, label %cleanup, label %if.end60

if.end60:                                         ; preds = %while.body
  %inc = add nsw i64 %ret.0, 1
  br label %while.cond

while.end:                                        ; preds = %while.cond, %do.body37
  %cmp61 = icmp sgt i64 %ret.0, 0
  br i1 %cmp61, label %if.then63, label %cleanup

if.then63:                                        ; preds = %while.end
  %call64 = call %struct.inode* @file_inode(%struct.file* %file)
  %i_atime = getelementptr inbounds %struct.inode, %struct.inode* %call64, i32 0, i32 15
  %i_sb = getelementptr inbounds %struct.inode, %struct.inode* %call64, i32 0, i32 8
  %24 = load %struct.super_block*, %struct.super_block** %i_sb, align 8, !tbaa !149
  %call65 = call { i64, i64 } @current_fs_time(%struct.super_block* %24)
  %25 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call65, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call65, 1
  store i64 %29, i64* %28, align 8
  %30 = bitcast %struct.timespec* %i_atime to i8*
  %31 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 16, i32 8, i1 false), !tbaa.struct !157
  br label %cleanup

cleanup:                                          ; preds = %while.end, %if.then63, %while.body, %if.end28, %land.lhs.true
  %retval.0 = phi i64 [ -11, %land.lhs.true ], [ %conv, %if.end28 ], [ -14, %while.body ], [ %ret.0, %if.then63 ], [ %ret.0, %while.end ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #1 {
entry:
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), %struct.poll_table_struct* %wait)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo, i32 0, i32 0
  %1 = load i32, i32* %in, align 8, !tbaa !44
  %2 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo1 = bitcast %union.anon.58* %2 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo1, i32 0, i32 1
  %3 = load i32, i32* %out, align 4, !tbaa !44
  %sub = sub i32 %1, %3
  %tobool = icmp ne i32 %sub, 0
  %. = select i1 %tobool, i32 65, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i64 @sonypi_misc_ioctl(%struct.file* %fp, i32 %cmd, i64 %arg) #1 {
entry:
  %val8 = alloca i8, align 1
  %val16 = alloca i16, align 2
  %value = alloca i32, align 4
  %0 = inttoptr i64 %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %val8) #8
  %1 = bitcast i16* %val16 to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %1) #8
  %2 = bitcast i32* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #8
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %Pivot34 = icmp slt i32 %cmd, -2147322365
  br i1 %Pivot34, label %NodeBlock13, label %NodeBlock31

NodeBlock31:                                      ; preds = %entry
  %Pivot32 = icmp slt i32 %cmd, 1073837568
  br i1 %Pivot32, label %NodeBlock19, label %NodeBlock29

NodeBlock29:                                      ; preds = %NodeBlock31
  %Pivot30 = icmp slt i32 %cmd, 1073837577
  br i1 %Pivot30, label %LeafBlock21, label %NodeBlock27

NodeBlock27:                                      ; preds = %NodeBlock29
  %Pivot28 = icmp slt i32 %cmd, 1073837579
  br i1 %Pivot28, label %LeafBlock23, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %cmd, 1073837579
  br i1 %SwitchLeaf26, label %sw.bb89, label %sw.epilog

LeafBlock23:                                      ; preds = %NodeBlock27
  %SwitchLeaf24 = icmp eq i32 %cmd, 1073837577
  br i1 %SwitchLeaf24, label %sw.bb75, label %sw.epilog

LeafBlock21:                                      ; preds = %NodeBlock29
  %SwitchLeaf22 = icmp eq i32 %cmd, 1073837568
  br i1 %SwitchLeaf22, label %sw.bb7, label %sw.epilog

NodeBlock19:                                      ; preds = %NodeBlock31
  %Pivot20 = icmp slt i32 %cmd, -2147322364
  br i1 %Pivot20, label %sw.bb31, label %NodeBlock17

NodeBlock17:                                      ; preds = %NodeBlock19
  %Pivot18 = icmp slt i32 %cmd, -2147322363
  br i1 %Pivot18, label %sw.bb40, label %LeafBlock15

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %cmd, -2147322363
  br i1 %SwitchLeaf16, label %sw.bb49, label %sw.epilog

NodeBlock13:                                      ; preds = %entry
  %Pivot14 = icmp slt i32 %cmd, -2147387894
  br i1 %Pivot14, label %NodeBlock3, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %cmd, -2147387892
  br i1 %Pivot12, label %LeafBlock5, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %cmd, -2147322366
  br i1 %Pivot10, label %LeafBlock7, label %sw.bb22

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %cmd, -2147387892
  br i1 %SwitchLeaf8, label %sw.bb99, label %sw.epilog

LeafBlock5:                                       ; preds = %NodeBlock11
  %SwitchLeaf6 = icmp eq i32 %cmd, -2147387894
  br i1 %SwitchLeaf6, label %sw.bb80, label %sw.epilog

NodeBlock3:                                       ; preds = %NodeBlock13
  %Pivot4 = icmp slt i32 %cmd, -2147387897
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cmd, -2147387896
  br i1 %Pivot, label %sw.bb58, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, -2147387896
  br i1 %SwitchLeaf2, label %sw.bb70, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cmd, -2147387904
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %3 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  %cmp = icmp eq %struct.backlight_device* %3, null
  br i1 %cmp, label %sw.epilog, label %if.end

if.end:                                           ; preds = %sw.bb
  %4 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call = call i32 @sony_nc_int_call(i8* %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.57, i32 0, i32 0), i32* null, i32* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %sw.epilog, label %if.end2

if.end2:                                          ; preds = %if.end
  %5 = load i32, i32* %value, align 4, !tbaa !12
  %and = and i32 %5, 255
  %sub = sub nsw i32 %and, 1
  %shl = shl i32 %sub, 5
  %conv = trunc i32 %shl to i8
  store i8 %conv, i8* %val8, align 1, !tbaa !44
  %call3 = call i32 @copy_to_user(i8* %0, i8* %val8, i32 1)
  %tobool4 = icmp ne i32 %call3, 0
  %. = select i1 %tobool4, i32 -14, i32 0
  br label %sw.epilog

sw.bb7:                                           ; preds = %LeafBlock21
  %6 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  %cmp8 = icmp eq %struct.backlight_device* %6, null
  br i1 %cmp8, label %sw.epilog, label %if.end11

if.end11:                                         ; preds = %sw.bb7
  %call12 = call i64 @copy_from_user(i8* %val8, i8* %0, i64 1)
  %tobool13 = icmp ne i64 %call12, 0
  br i1 %tobool13, label %sw.epilog, label %if.end15

if.end15:                                         ; preds = %if.end11
  %7 = load i8, i8* %val8, align 1, !tbaa !44
  %conv16 = zext i8 %7 to i32
  %shr = ashr i32 %conv16, 5
  %add = add nsw i32 %shr, 1
  store i32 %add, i32* %value, align 4, !tbaa !12
  %8 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call17 = call i32 @sony_nc_int_call(i8* %8, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.58, i32 0, i32 0), i32* %value, i32* null)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %sw.epilog, label %if.end20

if.end20:                                         ; preds = %if.end15
  %9 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  %call21 = call i32 @sony_backlight_get_brightness(%struct.backlight_device* %9)
  %10 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  %props = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %10, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 0
  store i32 %call21, i32* %brightness, align 8, !tbaa !160
  br label %sw.epilog

sw.bb22:                                          ; preds = %NodeBlock9
  %call23 = call i32 @ec_read16(i8 zeroext -78, i16* %val16)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %sw.epilog, label %if.end26

if.end26:                                         ; preds = %sw.bb22
  %11 = bitcast i16* %val16 to i8*
  %call27 = call i32 @copy_to_user(i8* %0, i8* %11, i32 2)
  %tobool28 = icmp ne i32 %call27, 0
  %.35 = select i1 %tobool28, i32 -14, i32 0
  br label %sw.epilog

sw.bb31:                                          ; preds = %NodeBlock19
  %call32 = call i32 @ec_read16(i8 zeroext -94, i16* %val16)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %sw.epilog, label %if.end35

if.end35:                                         ; preds = %sw.bb31
  %12 = bitcast i16* %val16 to i8*
  %call36 = call i32 @copy_to_user(i8* %0, i8* %12, i32 2)
  %tobool37 = icmp ne i32 %call36, 0
  %.36 = select i1 %tobool37, i32 -14, i32 0
  br label %sw.epilog

sw.bb40:                                          ; preds = %NodeBlock17
  %call41 = call i32 @ec_read16(i8 zeroext -70, i16* %val16)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %sw.epilog, label %if.end44

if.end44:                                         ; preds = %sw.bb40
  %13 = bitcast i16* %val16 to i8*
  %call45 = call i32 @copy_to_user(i8* %0, i8* %13, i32 2)
  %tobool46 = icmp ne i32 %call45, 0
  %.37 = select i1 %tobool46, i32 -14, i32 0
  br label %sw.epilog

sw.bb49:                                          ; preds = %LeafBlock15
  %call50 = call i32 @ec_read16(i8 zeroext -86, i16* %val16)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %sw.epilog, label %if.end53

if.end53:                                         ; preds = %sw.bb49
  %14 = bitcast i16* %val16 to i8*
  %call54 = call i32 @copy_to_user(i8* %0, i8* %14, i32 2)
  %tobool55 = icmp ne i32 %call54, 0
  %.38 = select i1 %tobool55, i32 -14, i32 0
  br label %sw.epilog

sw.bb58:                                          ; preds = %NodeBlock
  %call59 = call i32 @ec_read(i8 zeroext -127, i8* %val8)
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %sw.epilog, label %if.end62

if.end62:                                         ; preds = %sw.bb58
  %15 = load i8, i8* %val8, align 1, !tbaa !44
  %conv63 = zext i8 %15 to i32
  %and64 = and i32 %conv63, 7
  %conv65 = trunc i32 %and64 to i8
  store i8 %conv65, i8* %val8, align 1, !tbaa !44
  %call66 = call i32 @copy_to_user(i8* %0, i8* %val8, i32 1)
  %tobool67 = icmp ne i32 %call66, 0
  %.39 = select i1 %tobool67, i32 -14, i32 0
  br label %sw.epilog

sw.bb70:                                          ; preds = %LeafBlock1
  %16 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !51
  store i8 %16, i8* %val8, align 1, !tbaa !44
  %call71 = call i32 @copy_to_user(i8* %0, i8* %val8, i32 1)
  %tobool72 = icmp ne i32 %call71, 0
  %.40 = select i1 %tobool72, i32 -14, i32 0
  br label %sw.epilog

sw.bb75:                                          ; preds = %LeafBlock23
  %call76 = call i64 @copy_from_user(i8* %val8, i8* %0, i64 1)
  %tobool77 = icmp ne i64 %call76, 0
  br i1 %tobool77, label %sw.epilog, label %if.end79

if.end79:                                         ; preds = %sw.bb75
  %17 = load i8, i8* %val8, align 1, !tbaa !44
  call void @__sony_pic_set_bluetoothpower(i8 zeroext %17)
  br label %sw.epilog

sw.bb80:                                          ; preds = %LeafBlock5
  %call81 = call i32 @sony_pic_get_fanspeed(i8* %val8)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %sw.epilog, label %if.end84

if.end84:                                         ; preds = %sw.bb80
  %call85 = call i32 @copy_to_user(i8* %0, i8* %val8, i32 1)
  %tobool86 = icmp ne i32 %call85, 0
  %.41 = select i1 %tobool86, i32 -14, i32 0
  br label %sw.epilog

sw.bb89:                                          ; preds = %LeafBlock25
  %call90 = call i64 @copy_from_user(i8* %val8, i8* %0, i64 1)
  %tobool91 = icmp ne i64 %call90, 0
  br i1 %tobool91, label %sw.epilog, label %if.end93

if.end93:                                         ; preds = %sw.bb89
  %18 = load i8, i8* %val8, align 1, !tbaa !44
  %conv94 = zext i8 %18 to i64
  %call95 = call i32 @sony_pic_set_fanspeed(i64 %conv94)
  %tobool96 = icmp ne i32 %call95, 0
  %.42 = select i1 %tobool96, i32 -5, i32 0
  br label %sw.epilog

sw.bb99:                                          ; preds = %LeafBlock7
  %call100 = call i32 @ec_read(i8 zeroext -63, i8* %val8)
  %tobool101 = icmp ne i32 %call100, 0
  br i1 %tobool101, label %sw.epilog, label %if.end103

if.end103:                                        ; preds = %sw.bb99
  %call104 = call i32 @copy_to_user(i8* %0, i8* %val8, i32 1)
  %tobool105 = icmp ne i32 %call104, 0
  %.43 = select i1 %tobool105, i32 -14, i32 0
  br label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock25, %LeafBlock23, %LeafBlock21, %LeafBlock15, %LeafBlock7, %LeafBlock5, %LeafBlock1, %LeafBlock, %sw.bb99, %sw.bb89, %sw.bb80, %sw.bb75, %sw.bb58, %sw.bb49, %sw.bb40, %sw.bb31, %sw.bb22, %if.end15, %if.end11, %sw.bb7, %if.end, %sw.bb, %if.end103, %if.end93, %if.end84, %if.end79, %sw.bb70, %if.end62, %if.end53, %if.end44, %if.end35, %if.end26, %if.end20, %if.end2
  %ret.10 = phi i32 [ %., %if.end2 ], [ %.39, %if.end62 ], [ %.40, %sw.bb70 ], [ %.41, %if.end84 ], [ %.43, %if.end103 ], [ %.35, %if.end26 ], [ %.36, %if.end35 ], [ %.37, %if.end44 ], [ %.38, %if.end53 ], [ 0, %if.end20 ], [ 0, %if.end79 ], [ %.42, %if.end93 ], [ -5, %sw.bb ], [ -5, %if.end ], [ -5, %sw.bb7 ], [ -14, %if.end11 ], [ -5, %if.end15 ], [ -5, %sw.bb22 ], [ -5, %sw.bb31 ], [ -5, %sw.bb40 ], [ -5, %sw.bb49 ], [ -5, %sw.bb58 ], [ -14, %sw.bb75 ], [ -5, %sw.bb80 ], [ -14, %sw.bb89 ], [ -5, %sw.bb99 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock5 ], [ -22, %LeafBlock7 ], [ -22, %LeafBlock15 ], [ -22, %LeafBlock21 ], [ -22, %LeafBlock23 ], [ -22, %LeafBlock25 ]
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  %conv108 = sext i32 %ret.10 to i64
  %19 = bitcast i32* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %19) #8
  %20 = bitcast i16* %val16 to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %20) #8
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %val8) #8
  ret i64 %conv108
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_open(%struct.inode* %inode, %struct.file* %file) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2))
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %call5 = call i32 @atomic_add_return(i32 1, %struct.atomic_t* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 4))
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %4 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo, i32 0, i32 1
  store i32 0, i32* %out, align 4, !tbaa !44
  %5 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo9 = bitcast %union.anon.58* %5 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo9, i32 0, i32 0
  store i32 0, i32* %in, align 8, !tbaa !44
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @spin_unlock_irqrestore(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2), i64 %call2)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_release(%struct.inode* %inode, %struct.file* %file) #1 {
entry:
  call void @atomic_dec(%struct.atomic_t* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 4))
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_fasync(i32 %fd, %struct.file* %filp, i32 %on) #1 {
entry:
  %call = call i32 @fasync_helper(i32 %fd, %struct.file* %filp, i32 %on, %struct.fasync_struct** getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 0))
  ret i32 %call
}

declare i32 @autoremove_wake_function(%struct.__wait_queue*, i32, i32, i8*) #2

declare void @prepare_to_wait(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #0 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

declare void @schedule() #2

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #2

declare void @might_fault() #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #0 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !164
  ret %struct.inode* %0
}

declare { i64, i64 } @current_fs_time(%struct.super_block*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #0 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !165
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #0 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #0 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #8, !srcloc !193
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #0 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !194
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !194
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_int_call(i8* %handle, i8* %name, i32* %value, i32* %result) #1 {
entry:
  %v = alloca i64, align 8
  %tobool = icmp ne i32* %value, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = bitcast i64* %v to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = load i32, i32* %value, align 4, !tbaa !12
  %conv = sext i32 %1 to i64
  store i64 %conv, i64* %v, align 8, !tbaa !196
  %call = call %union.acpi_object* @__call_snc_method(i8* %handle, i8* %name, i64* %v)
  %2 = bitcast i64* %v to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call %union.acpi_object* @__call_snc_method(i8* %handle, i8* %name, i64* null)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %object.0 = phi %union.acpi_object* [ %call, %if.then ], [ %call1, %if.else ]
  %tobool2 = icmp ne %union.acpi_object* %object.0, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %type = bitcast %union.acpi_object* %object.0 to i32*
  %3 = load i32, i32* %type, align 8, !tbaa !44
  %cmp = icmp ne i32 %3, 1
  br i1 %cmp, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end4
  %type7 = bitcast %union.acpi_object* %object.0 to i32*
  %4 = load i32, i32* %type7, align 8, !tbaa !44
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.59, i32 0, i32 0), i32 1, i32 %4)
  %5 = bitcast %union.acpi_object* %object.0 to i8*
  call void @kfree(i8* %5)
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %tobool10 = icmp ne i32* %result, null
  br i1 %tobool10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.end9
  %integer = bitcast %union.acpi_object* %object.0 to %struct.anon.47*
  %value12 = getelementptr inbounds %struct.anon.47, %struct.anon.47* %integer, i32 0, i32 1
  %6 = load i64, i64* %value12, align 8, !tbaa !44
  %conv13 = trunc i64 %6 to i32
  store i32 %conv13, i32* %result, align 4, !tbaa !12
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.end9
  %7 = bitcast %union.acpi_object* %object.0 to i8*
  call void @kfree(i8* %7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.end14, %if.then6
  %retval.0 = phi i32 [ -22, %if.then6 ], [ 0, %if.end14 ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @copy_to_user(i8* %dst, i8* %src, i32 %size) #5 {
entry:
  call void @might_fault()
  %call = call i64 @_copy_to_user(i8* %dst, i8* %src, i32 %size)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #0 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.64, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.65, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  %tobool17 = icmp ne i32 1, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_backlight_get_brightness(%struct.backlight_device* %bd) #1 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast i32* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call = call i32 @sony_nc_int_call(i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.57, i32 0, i32 0), i32* null, i32* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i32, i32* %value, align 4
  %sub = sub nsw i32 %2, 1
  %retval.0 = select i1 %tobool, i32 0, i32 %sub
  %3 = bitcast i32* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ec_read16(i8 zeroext %addr, i16* %value) #1 {
entry:
  %val_lb = alloca i8, align 1
  %val_hb = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %val_lb) #8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %val_hb) #8
  %call = call i32 @ec_read(i8 zeroext %addr, i8* %val_lb)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i8 %addr to i32
  %add = add nsw i32 %conv, 1
  %conv1 = trunc i32 %add to i8
  %call2 = call i32 @ec_read(i8 zeroext %conv1, i8* %val_hb)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %0 = load i8, i8* %val_lb, align 1, !tbaa !44
  %conv6 = zext i8 %0 to i32
  %1 = load i8, i8* %val_hb, align 1, !tbaa !44
  %conv7 = zext i8 %1 to i32
  %shl = shl i32 %conv7, 8
  %or = or i32 %conv6, %shl
  %conv8 = trunc i32 %or to i16
  store i16 %conv8, i16* %value, align 2, !tbaa !197
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end5
  %retval.0 = phi i32 [ 0, %if.end5 ], [ -1, %entry ], [ -1, %if.end ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %val_hb) #8
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %val_lb) #8
  ret i32 %retval.0
}

declare i32 @ec_read(i8 zeroext, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @__sony_pic_set_bluetoothpower(i8 zeroext %state) #1 {
entry:
  %tobool = icmp ne i8 %state, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = trunc i32 %lnot.ext to i8
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !51
  %conv2 = zext i8 %0 to i32
  %conv3 = zext i8 %conv to i32
  %cmp = icmp eq i32 %conv2, %conv3
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = call zeroext i8 @sony_pic_call2(i8 zeroext -106, i8 zeroext %conv)
  %call5 = call zeroext i8 @sony_pic_call1(i8 zeroext -126)
  store i8 %conv, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !51
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_get_fanspeed(i8* %value) #1 {
entry:
  %call = call i32 @ec_read(i8 zeroext -109, i8* %value)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_set_fanspeed(i64 %value) #1 {
entry:
  %conv = trunc i64 %value to i8
  %call = call i32 @ec_write(i8 zeroext -109, i8 zeroext %conv)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal %union.acpi_object* @__call_snc_method(i8* %handle, i8* %method, i64* %value) #1 {
entry:
  %output = alloca %struct.acpi_buffer, align 8
  %params = alloca %struct.acpi_object_list, align 8
  %in = alloca %union.acpi_object, align 8
  %0 = bitcast %struct.acpi_buffer* %output to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #8
  %1 = bitcast %struct.acpi_buffer* %output to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast (%struct.acpi_buffer* @__call_snc_method.output to i8*), i64 16, i32 8, i1 false)
  %tobool = icmp ne i64* %value, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.acpi_object_list* %params to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %2) #8
  %3 = bitcast %union.acpi_object* %in to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %3) #8
  %type = bitcast %union.acpi_object* %in to i32*
  store i32 1, i32* %type, align 8, !tbaa !44
  %4 = load i64, i64* %value, align 8, !tbaa !196
  %integer = bitcast %union.acpi_object* %in to %struct.anon.47*
  %value1 = getelementptr inbounds %struct.anon.47, %struct.anon.47* %integer, i32 0, i32 1
  store i64 %4, i64* %value1, align 8, !tbaa !44
  %count = getelementptr inbounds %struct.acpi_object_list, %struct.acpi_object_list* %params, i32 0, i32 0
  store i32 1, i32* %count, align 8, !tbaa !198
  %pointer = getelementptr inbounds %struct.acpi_object_list, %struct.acpi_object_list* %params, i32 0, i32 1
  store %union.acpi_object* %in, %union.acpi_object** %pointer, align 8, !tbaa !200
  %call = call i32 @acpi_evaluate_object(i8* %handle, i8* %method, %struct.acpi_object_list* %params, %struct.acpi_buffer* %output)
  %5 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %if.then
  %6 = load i64, i64* %value, align 8, !tbaa !196
  %shr = lshr i64 %6, 32
  %conv = trunc i64 %shr to i32
  %7 = load i64, i64* %value, align 8, !tbaa !196
  %conv4 = trunc i64 %7 to i32
  %call5 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.60, i32 0, i32 0), i8* %method, i32 %conv, i32 %conv4)
  br label %do.end

do.end:                                           ; preds = %if.then3, %if.then
  %8 = bitcast %union.acpi_object* %in to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %8) #8
  %9 = bitcast %struct.acpi_object_list* %params to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %9) #8
  br label %if.end14

if.else:                                          ; preds = %entry
  %call6 = call i32 @acpi_evaluate_object(i8* %handle, i8* %method, %struct.acpi_object_list* null, %struct.acpi_buffer* %output)
  %10 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool8 = icmp ne i32 %10, 0
  br i1 %tobool8, label %if.then9, label %if.end14

if.then9:                                         ; preds = %if.else
  %call10 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.61, i32 0, i32 0), i8* %method)
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then9, %do.end
  %status.0 = phi i32 [ %call, %do.end ], [ %call6, %if.then9 ], [ %call6, %if.else ]
  %tobool15 = icmp ne i32 %status.0, 0
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  %call17 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.62, i32 0, i32 0), i8* %method)
  br label %cleanup

if.end18:                                         ; preds = %if.end14
  %pointer19 = getelementptr inbounds %struct.acpi_buffer, %struct.acpi_buffer* %output, i32 0, i32 1
  %11 = load i8*, i8** %pointer19, align 8, !tbaa !114
  %12 = bitcast i8* %11 to %union.acpi_object*
  %tobool20 = icmp eq %union.acpi_object* %12, null
  %13 = load i32, i32* @debug, align 4
  %tobool23 = icmp ne i32 %13, 0
  %or.cond = and i1 %tobool20, %tobool23
  br i1 %or.cond, label %if.then24, label %cleanup

if.then24:                                        ; preds = %if.end18
  %call25 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.63, i32 0, i32 0), i8* %method)
  br label %cleanup

cleanup:                                          ; preds = %if.end18, %if.then24, %if.then16
  %retval.0 = phi %union.acpi_object* [ null, %if.then16 ], [ %12, %if.then24 ], [ %12, %if.end18 ]
  %14 = bitcast %struct.acpi_buffer* %output to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %14) #8
  ret %union.acpi_object* %retval.0
}

declare i32 @acpi_evaluate_object(i8*, i8*, %struct.acpi_object_list*, %struct.acpi_buffer*) #2

declare i64 @_copy_to_user(i8*, i8*, i32) #2

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #7

declare i64 @_copy_from_user(i8*, i8*, i32) #2

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #2

declare i32 @ec_write(i8 zeroext, i8 zeroext) #2

declare i32 @fasync_helper(i32, %struct.file*, i32, %struct.fasync_struct**) #2

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @sony_laptop_report_input_event(i8 zeroext %event) #1 {
entry:
  %kp = alloca %struct.sony_laptop_keypress, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !101
  %1 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !98
  %2 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %2) #8
  %3 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.memset.p0i8.i64(i8* %3, i8 0, i64 16, i32 8, i1 false)
  %conv = zext i8 %event to i32
  %cmp = icmp eq i32 %conv, 59
  %conv2 = zext i8 %event to i32
  %cmp3 = icmp eq i32 %conv2, 56
  %or.cond = or i1 %cmp, %cmp3
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv5 = zext i8 %event to i32
  %Pivot8 = icmp slt i32 %conv5, 3
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end
  %Pivot6 = icmp slt i32 %conv5, 4
  br i1 %Pivot6, label %sw.bb6, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %conv5, 5
  br i1 %Pivot4, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %conv5, 5
  br i1 %SwitchLeaf2, label %sw.bb7, label %sw.default

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %conv5, 2
  br i1 %Pivot, label %LeafBlock, label %sw.bb

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv5, 1
  br i1 %SwitchLeaf, label %sw.bb6, label %sw.default

sw.bb:                                            ; preds = %NodeBlock3, %NodeBlock
  call void @input_report_rel(%struct.input_dev* %0, i32 8, i32 1)
  call void @input_sync(%struct.input_dev* %0)
  br label %cleanup

sw.bb6:                                           ; preds = %NodeBlock5, %LeafBlock
  call void @input_report_rel(%struct.input_dev* %0, i32 8, i32 -1)
  call void @input_sync(%struct.input_dev* %0)
  br label %cleanup

sw.bb7:                                           ; preds = %LeafBlock1
  %key = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  store i32 274, i32* %key, align 8, !tbaa !126
  %dev = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  store %struct.input_dev* %0, %struct.input_dev** %dev, align 8, !tbaa !124
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %conv8 = zext i8 %event to i64
  %cmp9 = icmp uge i64 %conv8, 74
  br i1 %cmp9, label %do.body, label %if.end15

do.body:                                          ; preds = %sw.default
  %4 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then12, label %sw.epilog

if.then12:                                        ; preds = %do.body
  %conv13 = zext i8 %event to i32
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.68, i32 0, i32 0), i32 %conv13)
  br label %sw.epilog

if.end15:                                         ; preds = %sw.default
  %idxprom = zext i8 %event to i64
  %arrayidx = getelementptr inbounds [74 x i32], [74 x i32]* @sony_laptop_input_index, i64 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %cmp16 = icmp ne i32 %5, -1
  br i1 %cmp16, label %if.then18, label %sw.epilog

if.then18:                                        ; preds = %if.end15
  %idxprom19 = sext i32 %5 to i64
  %arrayidx20 = getelementptr inbounds [60 x i32], [60 x i32]* @sony_laptop_input_keycode_map, i64 0, i64 %idxprom19
  %6 = load i32, i32* %arrayidx20, align 4, !tbaa !12
  %key21 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  store i32 %6, i32* %key21, align 8, !tbaa !126
  %key22 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %7 = load i32, i32* %key22, align 8, !tbaa !126
  %cmp23 = icmp ne i32 %7, 240
  br i1 %cmp23, label %if.then25, label %sw.epilog

if.then25:                                        ; preds = %if.then18
  %dev26 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  store %struct.input_dev* %1, %struct.input_dev** %dev26, align 8, !tbaa !124
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end15, %if.then25, %if.then18, %do.body, %if.then12, %sw.bb7
  %scancode.0 = phi i32 [ -1, %sw.bb7 ], [ -1, %if.then12 ], [ -1, %do.body ], [ %5, %if.then18 ], [ %5, %if.then25 ], [ %5, %if.end15 ]
  %dev29 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %8 = load %struct.input_dev*, %struct.input_dev** %dev29, align 8, !tbaa !124
  %tobool30 = icmp ne %struct.input_dev* %8, null
  br i1 %tobool30, label %if.then31, label %do.body56

if.then31:                                        ; preds = %sw.epilog
  %cmp32 = icmp ne i32 %scancode.0, -1
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.then31
  %dev35 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %9 = load %struct.input_dev*, %struct.input_dev** %dev35, align 8, !tbaa !124
  call void @input_event(%struct.input_dev* %9, i32 4, i32 4, i32 %scancode.0)
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.then31
  %dev37 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %10 = load %struct.input_dev*, %struct.input_dev** %dev37, align 8, !tbaa !124
  %key38 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %11 = load i32, i32* %key38, align 8, !tbaa !126
  call void @input_report_key(%struct.input_dev* %10, i32 %11, i32 1)
  %dev39 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %12 = load %struct.input_dev*, %struct.input_dev** %dev39, align 8, !tbaa !124
  call void @input_sync(%struct.input_dev* %12)
  %13 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %13) #8
  %14 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %14) #8
  %cmp42 = icmp eq i64* %__dummy, %__dummy2
  %conv43 = zext i1 %cmp42 to i32
  %15 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #8
  %16 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %16) #8
  %call44 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4))
  %call45 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call44)
  %17 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %18 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %18 to %struct.__kfifo*
  %conv51 = trunc i64 16 to i32
  %call52 = call i32 @__kfifo_in(%struct.__kfifo* %kfifo, i8* %17, i32 %conv51)
  call void @spin_unlock_irqrestore(%struct.spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4), i64 %call45)
  %19 = load volatile i64, i64* @jiffies, align 8, !tbaa !107
  %call54 = call i64 @msecs_to_jiffies(i32 10)
  %add = add i64 %19, %call54
  %call55 = call i32 @mod_timer(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5), i64 %add)
  br label %cleanup

do.body56:                                        ; preds = %sw.epilog
  %20 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool57 = icmp ne i32 %20, 0
  br i1 %tobool57, label %if.then58, label %cleanup

if.then58:                                        ; preds = %do.body56
  %conv59 = zext i8 %event to i32
  %call60 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.69, i32 0, i32 0), i32 %conv59)
  br label %cleanup

cleanup:                                          ; preds = %if.end36, %if.then58, %do.body56, %entry, %sw.bb6, %sw.bb
  %cleanup.dest.slot.0 = phi i32 [ 1, %sw.bb6 ], [ 1, %sw.bb ], [ 1, %entry ], [ 0, %do.body56 ], [ 0, %if.then58 ], [ 0, %if.end36 ]
  %21 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %21) #8
  ret void
}

declare i32 @acpi_bus_generate_proc_event(%struct.acpi_device*, i8 zeroext, i32) #2

; Function Attrs: nounwind uwtable
define internal void @sonypi_compat_report_event(i8 zeroext %event) #1 {
entry:
  %event.addr = alloca i8, align 1
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  store i8 %event, i8* %event.addr, align 1, !tbaa !44
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2))
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %4 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %4 to %struct.__kfifo*
  %conv6 = trunc i64 1 to i32
  %call7 = call i32 @__kfifo_in(%struct.__kfifo* %kfifo, i8* %event.addr, i32 %conv6)
  call void @spin_unlock_irqrestore(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2), i64 %call2)
  call void @kill_fasync(%struct.fasync_struct** getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 0), i32 29, i32 131073)
  call void @__wake_up(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), i32 1, i32 1, i8* null)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_rel(%struct.input_dev* %dev, i32 %code, i32 %value) #0 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 2, i32 %code, i32 %value)
  ret void
}

declare i32 @__kfifo_in(%struct.__kfifo*, i8*, i32) #2

declare void @kill_fasync(%struct.fasync_struct**, i32, i32) #2

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #2

declare i32 @acpi_set_current_resources(i8*, %struct.acpi_buffer*) #2

declare i32 @platform_driver_register(%struct.platform_driver*) #2

declare %struct.platform_device* @platform_device_alloc(i8*, i32) #2

declare i32 @platform_device_add(%struct.platform_device*) #2

declare void @platform_device_put(%struct.platform_device*) #2

declare void @platform_driver_unregister(%struct.platform_driver*) #2

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_bluetoothpower_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !51
  %conv = zext i8 %0 to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_bluetoothpower_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i64, align 8
  %0 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %1 = load i64, i64* %value, align 8, !tbaa !107
  %conv = trunc i64 %1 to i8
  call void @__sony_pic_set_bluetoothpower(i8 zeroext %conv)
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end2
  %retval.0 = phi i64 [ %count, %if.end2 ], [ -22, %entry ], [ -22, %if.end ]
  %2 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  ret i64 %retval.0
}

declare i32 @snprintf(i8*, i64, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #0 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

declare i32 @kstrtoull(i8*, i32, i64*) #2

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_wwanpower_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 12), align 8, !tbaa !201
  %conv = zext i8 %0 to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_wwanpower_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i64, align 8
  %0 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %1 = load i64, i64* %value, align 8, !tbaa !107
  %conv = trunc i64 %1 to i8
  call void @__sony_pic_set_wwanpower(i8 zeroext %conv)
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end2
  %retval.0 = phi i64 [ %count, %if.end2 ], [ -22, %entry ], [ -22, %if.end ]
  %2 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @__sony_pic_set_wwanpower(i8 zeroext %state) #1 {
entry:
  %tobool = icmp ne i8 %state, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = trunc i32 %lnot.ext to i8
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 12), align 8, !tbaa !201
  %conv2 = zext i8 %0 to i32
  %conv3 = zext i8 %conv to i32
  %cmp = icmp eq i32 %conv2, %conv3
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = call zeroext i8 @sony_pic_call2(i8 zeroext -80, i8 zeroext %conv)
  %call5 = call zeroext i8 @sony_pic_call1(i8 zeroext -126)
  store i8 %conv, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 12), align 8, !tbaa !201
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_fanspeed_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %value = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %value) #8
  store i8 0, i8* %value, align 1, !tbaa !44
  %call = call i32 @sony_pic_get_fanspeed(i8* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = load i8, i8* %value, align 1, !tbaa !44
  %conv = zext i8 %0 to i32
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i64 [ %conv2, %if.end ], [ -5, %entry ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %value) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_fanspeed_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i64, align 8
  %0 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %1 = load i64, i64* %value, align 8, !tbaa !107
  %call3 = call i32 @sony_pic_set_fanspeed(i64 %1)
  %tobool4 = icmp ne i32 %call3, 0
  %.count = select i1 %tobool4, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end2 ]
  %2 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test(%struct.atomic_t* %v) #0 {
entry:
  %c = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #8
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #8, !srcloc !202
  %0 = load i8, i8* %c, align 1, !tbaa !44
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #8
  ret i32 %conv1
}

declare void @platform_device_unregister(%struct.platform_device*) #2

declare i32 @misc_deregister(%struct.miscdevice*) #2

declare i32 @del_timer_sync(%struct.timer_list*) #2

declare void @sysfs_remove_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_suspend(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -480
  %1 = bitcast i8* %add.ptr to %struct.acpi_device*
  %call = call i32 @sony_pic_disable(%struct.acpi_device* %1)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 -6, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_resume(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -480
  %1 = bitcast i8* %add.ptr to %struct.acpi_device*
  %2 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %3 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !50
  %call = call i32 @sony_pic_enable(%struct.acpi_device* %1, %struct.sony_pic_ioport* %2, %struct.sony_pic_irq* %3)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_add(%struct.acpi_device* %device) #1 {
entry:
  %handle = alloca i8*, align 8
  %arg = alloca i32, align 4
  %0 = bitcast i8** %handle to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0))
  store %struct.acpi_device* %device, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !38
  %pnp = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 8
  %device_class = getelementptr inbounds %struct.acpi_device_pnp, %struct.acpi_device_pnp* %pnp, i32 0, i32 6
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %device_class, i32 0, i32 0
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.17, i32 0, i32 0))
  %handle2 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %1 = load i8*, i8** %handle2, align 8, !tbaa !59
  store i8* %1, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call3 = call i32 @acpi_bus_get_status(%struct.acpi_device* %device)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %status4 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 6
  %2 = bitcast %struct.acpi_device_status* %status4 to i32*
  %bf.load = load i32, i32* %2, align 8
  %bf.clear = and i32 %bf.load, 1
  %tobool5 = icmp ne i32 %bf.clear, 0
  br i1 %tobool5, label %if.end9, label %do.body

do.body:                                          ; preds = %land.lhs.true
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool6 = icmp ne i32 %3, 0
  br i1 %tobool6, label %if.then7, label %outwalk

if.then7:                                         ; preds = %do.body
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.80, i32 0, i32 0))
  br label %outwalk

if.end9:                                          ; preds = %land.lhs.true, %entry
  %call10 = call i32 @sony_pf_add()
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %outpresent, label %if.end13

if.end13:                                         ; preds = %if.end9
  %4 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool14 = icmp ne i32 %4, 0
  br i1 %tobool14, label %if.then15, label %if.end21

if.then15:                                        ; preds = %if.end13
  %5 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call16 = call i32 @acpi_walk_namespace(i32 8, i8* %5, i32 1, i32 (i8*, i32, i8*, i8**)* @sony_walk_callback, i32 (i8*, i32, i8*, i8**)* null, i8* null, i8** null)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.then15
  %call19 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.81, i32 0, i32 0))
  br label %outpresent

if.end21:                                         ; preds = %if.then15, %if.end13
  %call22 = call i32 @sony_laptop_setup_input(%struct.acpi_device* %device)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end21
  %call25 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.20, i32 0, i32 0))
  br label %outplatform

if.end26:                                         ; preds = %if.end21
  %6 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call27 = call i32 @acpi_get_handle(i8* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.82, i32 0, i32 0), i8** %handle)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.end41, label %if.then29

if.then29:                                        ; preds = %if.end26
  %7 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #8
  store i32 1, i32* %arg, align 4, !tbaa !12
  %8 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call30 = call i32 @sony_nc_int_call(i8* %8, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.82, i32 0, i32 0), i32* %arg, i32* null)
  %tobool31 = icmp ne i32 %call30, 0
  %9 = load i32, i32* @debug, align 4
  %tobool34 = icmp ne i32 %9, 0
  %or.cond = and i1 %tobool31, %tobool34
  br i1 %or.cond, label %if.then35, label %if.end40

if.then35:                                        ; preds = %if.then29
  %call36 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.83, i32 0, i32 0))
  br label %if.end40

if.end40:                                         ; preds = %if.then35, %if.then29
  %10 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %10) #8
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.end26
  %11 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call42 = call i32 @acpi_get_handle(i8* %11, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i8** %handle)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.end56, label %do.body45

do.body45:                                        ; preds = %if.end41
  %12 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool46 = icmp ne i32 %12, 0
  br i1 %tobool46, label %if.then47, label %do.end51

if.then47:                                        ; preds = %do.body45
  %call48 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.85, i32 0, i32 0))
  br label %do.end51

do.end51:                                         ; preds = %if.then47, %do.body45
  %13 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  %call52 = call i32 @sony_nc_handles_setup(%struct.platform_device* %13)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.end56, label %if.then54

if.then54:                                        ; preds = %do.end51
  %14 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  call void @sony_nc_function_setup(%struct.acpi_device* %device, %struct.platform_device* %14)
  br label %if.end56

if.end56:                                         ; preds = %do.end51, %if.then54, %if.end41
  %call57 = call i32 @acpi_video_backlight_support()
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.then59, label %if.else

if.then59:                                        ; preds = %if.end56
  %call60 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.86, i32 0, i32 0))
  br label %if.end61

if.else:                                          ; preds = %if.end56
  call void @sony_nc_backlight_setup()
  br label %if.end61

if.end61:                                         ; preds = %if.else, %if.then59
  br label %for.cond

for.cond:                                         ; preds = %for.inc132, %if.end61
  %item.0 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %if.end61 ], [ %incdec.ptr133, %for.inc132 ]
  %name = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %15 = load i8*, i8** %name, align 8, !tbaa !203
  %tobool62 = icmp ne i8* %15, null
  br i1 %tobool62, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %16 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool63 = icmp ne i32 %16, 0
  br i1 %tobool63, label %if.end67, label %land.lhs.true64

land.lhs.true64:                                  ; preds = %for.body
  %debug = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 6
  %17 = load i32, i32* %debug, align 8, !tbaa !208
  %tobool65 = icmp ne i32 %17, 0
  br i1 %tobool65, label %for.inc132, label %if.end67

if.end67:                                         ; preds = %land.lhs.true64, %for.body
  br label %for.cond68

for.cond68:                                       ; preds = %for.inc, %if.end67
  %acpiget = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %18 = load i8**, i8*** %acpiget, align 8, !tbaa !209
  %tobool69 = icmp ne i8** %18, null
  br i1 %tobool69, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond68
  %acpiget70 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %19 = load i8**, i8*** %acpiget70, align 8, !tbaa !209
  %20 = load i8*, i8** %19, align 8, !tbaa !38
  %tobool71 = icmp ne i8* %20, null
  br i1 %tobool71, label %for.body72, label %for.end

for.body72:                                       ; preds = %land.rhs
  %21 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %acpiget73 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %22 = load i8**, i8*** %acpiget73, align 8, !tbaa !209
  %23 = load i8*, i8** %22, align 8, !tbaa !38
  %call74 = call i32 @acpi_get_handle(i8* %21, i8* %23, i8** %handle)
  %tobool75 = icmp ne i32 %call74, 0
  br i1 %tobool75, label %for.inc, label %do.body77

do.body77:                                        ; preds = %for.body72
  %24 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool78 = icmp ne i32 %24, 0
  br i1 %tobool78, label %if.then79, label %do.end85

if.then79:                                        ; preds = %do.body77
  %name80 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %25 = load i8*, i8** %name80, align 8, !tbaa !203
  %acpiget81 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %26 = load i8**, i8*** %acpiget81, align 8, !tbaa !209
  %27 = load i8*, i8** %26, align 8, !tbaa !38
  %call82 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.87, i32 0, i32 0), i8* %25, i8* %27)
  br label %do.end85

do.end85:                                         ; preds = %if.then79, %do.body77
  %devattr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 1
  %28 = load i16, i16* %mode, align 8, !tbaa !210
  %conv = zext i16 %28 to i32
  %or = or i32 %conv, 292
  %conv86 = trunc i32 %or to i16
  store i16 %conv86, i16* %mode, align 8, !tbaa !210
  br label %for.end

for.inc:                                          ; preds = %for.body72
  %acpiget88 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %29 = load i8**, i8*** %acpiget88, align 8, !tbaa !209
  %incdec.ptr = getelementptr inbounds i8*, i8** %29, i32 1
  store i8** %incdec.ptr, i8*** %acpiget88, align 8, !tbaa !209
  br label %for.cond68

for.end:                                          ; preds = %land.rhs, %for.cond68, %do.end85
  br label %for.cond89

for.cond89:                                       ; preds = %for.inc116, %for.end
  %acpiset = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %30 = load i8**, i8*** %acpiset, align 8, !tbaa !211
  %tobool90 = icmp ne i8** %30, null
  br i1 %tobool90, label %land.rhs91, label %for.end119

land.rhs91:                                       ; preds = %for.cond89
  %acpiset92 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %31 = load i8**, i8*** %acpiset92, align 8, !tbaa !211
  %32 = load i8*, i8** %31, align 8, !tbaa !38
  %tobool93 = icmp ne i8* %32, null
  br i1 %tobool93, label %for.body95, label %for.end119

for.body95:                                       ; preds = %land.rhs91
  %33 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %acpiset96 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %34 = load i8**, i8*** %acpiset96, align 8, !tbaa !211
  %35 = load i8*, i8** %34, align 8, !tbaa !38
  %call97 = call i32 @acpi_get_handle(i8* %33, i8* %35, i8** %handle)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %for.inc116, label %do.body100

do.body100:                                       ; preds = %for.body95
  %36 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool101 = icmp ne i32 %36, 0
  br i1 %tobool101, label %if.then102, label %do.end108

if.then102:                                       ; preds = %do.body100
  %name103 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %37 = load i8*, i8** %name103, align 8, !tbaa !203
  %acpiset104 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %38 = load i8**, i8*** %acpiset104, align 8, !tbaa !211
  %39 = load i8*, i8** %38, align 8, !tbaa !38
  %call105 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.88, i32 0, i32 0), i8* %37, i8* %39)
  br label %do.end108

do.end108:                                        ; preds = %if.then102, %do.body100
  %devattr109 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %attr110 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr109, i32 0, i32 0
  %mode111 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr110, i32 0, i32 1
  %40 = load i16, i16* %mode111, align 8, !tbaa !210
  %conv112 = zext i16 %40 to i32
  %or113 = or i32 %conv112, 128
  %conv114 = trunc i32 %or113 to i16
  store i16 %conv114, i16* %mode111, align 8, !tbaa !210
  br label %for.end119

for.inc116:                                       ; preds = %for.body95
  %acpiset117 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %41 = load i8**, i8*** %acpiset117, align 8, !tbaa !211
  %incdec.ptr118 = getelementptr inbounds i8*, i8** %41, i32 1
  store i8** %incdec.ptr118, i8*** %acpiset117, align 8, !tbaa !211
  br label %for.cond89

for.end119:                                       ; preds = %land.rhs91, %for.cond89, %do.end108
  %devattr120 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %attr121 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr120, i32 0, i32 0
  %mode122 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr121, i32 0, i32 1
  %42 = load i16, i16* %mode122, align 8, !tbaa !210
  %conv123 = zext i16 %42 to i32
  %cmp = icmp ne i32 %conv123, 0
  br i1 %cmp, label %if.then125, label %for.inc132

if.then125:                                       ; preds = %for.end119
  %43 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %43, i32 0, i32 3
  %devattr126 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %call127 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %devattr126)
  %tobool128 = icmp ne i32 %call127, 0
  br i1 %tobool128, label %out_sysfs, label %for.inc132

for.inc132:                                       ; preds = %for.end119, %if.then125, %land.lhs.true64
  %incdec.ptr133 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 1
  br label %for.cond

out_sysfs:                                        ; preds = %if.then125
  br label %for.cond135

for.cond135:                                      ; preds = %for.body138, %out_sysfs
  %item.1 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %out_sysfs ], [ %incdec.ptr142, %for.body138 ]
  %name136 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.1, i32 0, i32 0
  %44 = load i8*, i8** %name136, align 8, !tbaa !203
  %tobool137 = icmp ne i8* %44, null
  br i1 %tobool137, label %for.body138, label %for.end143

for.body138:                                      ; preds = %for.cond135
  %45 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  %dev139 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %45, i32 0, i32 3
  %devattr140 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.1, i32 0, i32 7
  call void @device_remove_file(%struct.device* %dev139, %struct.device_attribute* %devattr140)
  %incdec.ptr142 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.1, i32 1
  br label %for.cond135

for.end143:                                       ; preds = %for.cond135
  call void @sony_nc_backlight_cleanup()
  %46 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  call void @sony_nc_function_cleanup(%struct.platform_device* %46)
  %47 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  %call144 = call i32 @sony_nc_handles_cleanup(%struct.platform_device* %47)
  br label %outplatform

outplatform:                                      ; preds = %for.end143, %if.then24
  %result.0 = phi i32 [ %call22, %if.then24 ], [ %call127, %for.end143 ]
  call void @sony_laptop_remove_input()
  br label %outpresent

outpresent:                                       ; preds = %if.end9, %outplatform, %if.then18
  %result.1 = phi i32 [ -19, %if.then18 ], [ %result.0, %outplatform ], [ %call10, %if.end9 ]
  call void @sony_pf_remove()
  br label %outwalk

outwalk:                                          ; preds = %do.body, %if.then7, %outpresent
  %result.2 = phi i32 [ %result.1, %outpresent ], [ -19, %if.then7 ], [ -19, %do.body ]
  call void @sony_nc_rfkill_cleanup()
  br label %cleanup

cleanup:                                          ; preds = %for.cond, %outwalk
  %retval.0 = phi i32 [ %result.2, %outwalk ], [ 0, %for.cond ]
  %48 = bitcast i8** %handle to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %48) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_remove(%struct.acpi_device* %device) #1 {
entry:
  call void @sony_nc_backlight_cleanup()
  store %struct.acpi_device* null, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !38
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %item.0 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %entry ], [ %incdec.ptr, %for.body ]
  %name = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !203
  %tobool = icmp ne i8* %0, null
  %1 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %1, i32 0, i32 3
  %devattr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %devattr)
  %incdec.ptr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @sony_nc_function_cleanup(%struct.platform_device* %1)
  %2 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !38
  %call = call i32 @sony_nc_handles_cleanup(%struct.platform_device* %2)
  call void @sony_pf_remove()
  call void @sony_laptop_remove_input()
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then, label %do.end

if.then:                                          ; preds = %for.end
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.183, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %for.end
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_notify(%struct.acpi_device* %device, i32 %event) #1 {
entry:
  %result = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.184, i32 0, i32 0), i32 %event)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cmp = icmp uge i32 %event, 144
  br i1 %cmp, label %if.then1, label %if.else54

if.then1:                                         ; preds = %do.end
  %1 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  store i32 0, i32* %result, align 4, !tbaa !12
  %2 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #8
  store i32 0, i32* %arg, align 4, !tbaa !12
  %sub = sub i32 %event, 144
  %conv = zext i32 %sub to i64
  %cmp2 = icmp uge i64 %conv, 16
  br i1 %cmp2, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.then1
  %call5 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.185, i32 0, i32 0), i32 %event)
  br label %cleanup

if.end6:                                          ; preds = %if.then1
  %3 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %3, i32 0, i32 0
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %4 = load i16, i16* %arrayidx, align 2, !tbaa !197
  %conv7 = zext i16 %4 to i32
  %Pivot20 = icmp slt i32 %conv7, 296
  br i1 %Pivot20, label %NodeBlock3, label %NodeBlock17

NodeBlock17:                                      ; preds = %if.end6
  %Pivot18 = icmp slt i32 %conv7, 326
  br i1 %Pivot18, label %NodeBlock9, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %conv7, 347
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %conv7, 347
  br i1 %SwitchLeaf14, label %sw.bb41, label %do.body43

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %conv7, 326
  br i1 %SwitchLeaf12, label %sw.bb20, label %do.body43

NodeBlock9:                                       ; preds = %NodeBlock17
  %Pivot10 = icmp slt i32 %conv7, 309
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv7, 309
  br i1 %SwitchLeaf8, label %sw.bb14, label %do.body43

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv7, 296
  br i1 %SwitchLeaf6, label %sw.bb20, label %do.body43

NodeBlock3:                                       ; preds = %if.end6
  %Pivot4 = icmp slt i32 %conv7, 292
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %conv7, 295
  br i1 %Pivot, label %LeafBlock1, label %sw.bb

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv7, 292
  br i1 %SwitchLeaf2, label %sw.bb14, label %do.body43

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %conv7, 256
  br i1 %SwitchLeaf, label %sw.bb, label %do.body43

sw.bb:                                            ; preds = %NodeBlock, %LeafBlock
  %call8 = call i32 @sony_nc_hotkeys_decode(i32 %event, i32 %conv7)
  %cmp9 = icmp ugt i32 %call8, 0
  br i1 %cmp9, label %if.then11, label %sw.epilog

if.then11:                                        ; preds = %sw.bb
  %conv12 = trunc i32 %call8 to i8
  call void @sony_laptop_report_input_event(i8 zeroext %conv12)
  br label %sw.epilog

sw.bb14:                                          ; preds = %LeafBlock7, %LeafBlock1
  %call15 = call i32 @sony_call_snc_handle(i32 %conv7, i32 256, i32* %result)
  %5 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %5, 3
  %cmp16 = icmp eq i32 %and, 1
  br i1 %cmp16, label %if.then18, label %sw.epilog

if.then18:                                        ; preds = %sw.bb14
  call void @sony_nc_rfkill_update()
  br label %sw.epilog

sw.bb20:                                          ; preds = %LeafBlock11, %LeafBlock5
  %call21 = call i32 @sony_call_snc_handle(i32 %conv7, i32 0, i32* %result)
  %6 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool23 = icmp ne i32 %6, 0
  br i1 %tobool23, label %if.then24, label %do.end39

if.then24:                                        ; preds = %sw.bb20
  %7 = load i32, i32* %result, align 4, !tbaa !12
  %cmp25 = icmp eq i32 %7, 1
  br i1 %cmp25, label %cond.end34, label %cond.false

cond.false:                                       ; preds = %if.then24
  %8 = load i32, i32* %result, align 4, !tbaa !12
  %cmp27 = icmp eq i32 %8, 2
  br i1 %cmp27, label %cond.end34, label %cond.false30

cond.false30:                                     ; preds = %cond.false
  %9 = load i32, i32* %result, align 4, !tbaa !12
  %cmp31 = icmp eq i32 %9, 3
  %10 = zext i1 %cmp31 to i64
  %cond = select i1 %cmp31, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.188, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.189, i32 0, i32 0)
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false30, %cond.false, %if.then24
  %cond35 = phi i8* [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.187, i32 0, i32 0), %if.then24 ], [ %cond, %cond.false30 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.188, i32 0, i32 0), %cond.false ]
  %call36 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.186, i32 0, i32 0), i8* %cond35)
  br label %do.end39

do.end39:                                         ; preds = %cond.end34, %sw.bb20
  %call40 = call i32 @__sony_nc_gfx_switch_status_get()
  br label %sw.epilog

sw.bb41:                                          ; preds = %LeafBlock13
  %call42 = call i32 @__sony_nc_gfx_switch_status_get()
  br label %sw.epilog

do.body43:                                        ; preds = %LeafBlock13, %LeafBlock11, %LeafBlock7, %LeafBlock5, %LeafBlock1, %LeafBlock
  %11 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool44 = icmp ne i32 %11, 0
  br i1 %tobool44, label %if.then45, label %sw.epilog

if.then45:                                        ; preds = %do.body43
  %call46 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.190, i32 0, i32 0), i32 %event, i32 %conv7)
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.body43, %if.then45, %sw.bb14, %if.then18, %if.then11, %sw.bb, %sw.bb41, %do.end39
  %ev_type.0 = phi i8 [ 3, %do.end39 ], [ 3, %sw.bb41 ], [ 1, %sw.bb ], [ 1, %if.then11 ], [ 2, %if.then18 ], [ 2, %sw.bb14 ], [ 0, %if.then45 ], [ 0, %do.body43 ]
  %real_ev.1 = phi i32 [ %call40, %do.end39 ], [ %call42, %sw.bb41 ], [ %call8, %if.then11 ], [ %event, %sw.bb ], [ %and, %if.then18 ], [ %and, %sw.bb14 ], [ %event, %if.then45 ], [ %event, %do.body43 ]
  %shl = shl i32 1, %sub
  store i32 %shl, i32* %arg, align 4, !tbaa !12
  %12 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call50 = call i32 @sony_nc_int_call(i8* %12, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.191, i32 0, i32 0), i32* %arg, i32* %result)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %if.then4
  %ev_type.1 = phi i8 [ 0, %if.then4 ], [ %ev_type.0, %sw.epilog ]
  %real_ev.2 = phi i32 [ %event, %if.then4 ], [ %real_ev.1, %sw.epilog ]
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then4 ], [ 0, %sw.epilog ]
  %13 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %13) #8
  %14 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #8
  %SwitchLeaf23 = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf23, label %if.end56, label %cleanup.cont63

if.else54:                                        ; preds = %do.end
  %conv55 = trunc i32 %event to i8
  call void @sony_laptop_report_input_event(i8 zeroext %conv55)
  br label %if.end56

if.end56:                                         ; preds = %cleanup, %if.else54
  %ev_type.2 = phi i8 [ 1, %if.else54 ], [ %ev_type.1, %cleanup ]
  %real_ev.3 = phi i32 [ %event, %if.else54 ], [ %real_ev.2, %cleanup ]
  %15 = load %struct.acpi_device*, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !38
  %call57 = call i32 @acpi_bus_generate_proc_event(%struct.acpi_device* %15, i8 zeroext %ev_type.2, i32 %real_ev.3)
  %16 = load %struct.acpi_device*, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !38
  %pnp = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %16, i32 0, i32 8
  %device_class = getelementptr inbounds %struct.acpi_device_pnp, %struct.acpi_device_pnp* %pnp, i32 0, i32 6
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %device_class, i32 0, i32 0
  %17 = load %struct.acpi_device*, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !38
  %dev = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %17, i32 0, i32 16
  %call58 = call i8* @dev_name(%struct.device* %dev)
  %call59 = call i32 @acpi_bus_generate_netlink_event(i8* %arraydecay, i8* %call58, i8 zeroext %ev_type.2, i32 %real_ev.3)
  br label %cleanup.cont63

cleanup.cont63:                                   ; preds = %if.end56, %cleanup
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end56 ], [ %cleanup.dest.slot.0, %cleanup ]
  ret void
}

declare i32 @acpi_walk_namespace(i32, i8*, i32, i32 (i8*, i32, i8*, i8**)*, i32 (i8*, i32, i8*, i8**)*, i8*, i8**) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_walk_callback(i8* %handle, i32 %level, i8* %context, i8** %return_value) #1 {
entry:
  %info = alloca %struct.acpi_device_info*, align 8
  %0 = bitcast %struct.acpi_device_info** %info to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %call = call i32 @acpi_get_object_info(i8* %handle, %struct.acpi_device_info** %info)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.acpi_device_info*, %struct.acpi_device_info** %info, align 8, !tbaa !38
  %name = getelementptr inbounds %struct.acpi_device_info, %struct.acpi_device_info* %1, i32 0, i32 1
  %2 = bitcast i32* %name to i8*
  %3 = load %struct.acpi_device_info*, %struct.acpi_device_info** %info, align 8, !tbaa !38
  %param_count = getelementptr inbounds %struct.acpi_device_info, %struct.acpi_device_info* %3, i32 0, i32 3
  %4 = load i8, i8* %param_count, align 4, !tbaa !212
  %conv = zext i8 %4 to i32
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.89, i32 0, i32 0), i8* %2, i32 %conv)
  %5 = load %struct.acpi_device_info*, %struct.acpi_device_info** %info, align 8, !tbaa !38
  %6 = bitcast %struct.acpi_device_info* %5 to i8*
  call void @kfree(i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = bitcast %struct.acpi_device_info** %info to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #8
  ret i32 0
}

declare i32 @acpi_get_handle(i8*, i8*, i8**) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_handles_setup(%struct.platform_device* %pd) #1 {
entry:
  %result = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %call = call i8* @kzalloc(i64 80, i32 208)
  %2 = bitcast i8* %call to %struct.sony_nc_handles*
  store %struct.sony_nc_handles* %2, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %3 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %tobool = icmp ne %struct.sony_nc_handles* %3, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 %i.0, 32
  store i32 %add, i32* %arg, align 4, !tbaa !12
  %4 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call2 = call i32 @sony_nc_int_call(i8* %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i32* %arg, i32* %result)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %for.inc, label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool5 = icmp ne i32 %5, 0
  br i1 %tobool5, label %if.then6, label %do.end

if.then6:                                         ; preds = %do.body
  %6 = load i32, i32* %result, align 4, !tbaa !12
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.90, i32 0, i32 0), i32 %6, i32 %i.0)
  br label %do.end

do.end:                                           ; preds = %if.then6, %do.body
  %7 = load i32, i32* %result, align 4, !tbaa !12
  %conv9 = trunc i32 %7 to i16
  %8 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %8, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  store i16 %conv9, i16* %arrayidx, align 2, !tbaa !197
  br label %for.inc

for.inc:                                          ; preds = %for.body, %do.end
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool11 = icmp ne i32 %9, 0
  br i1 %tobool11, label %do.body13, label %cleanup

do.body13:                                        ; preds = %for.end
  %10 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %devattr = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %10, i32 0, i32 1
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_handles_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !216
  %11 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %devattr16 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %11, i32 0, i32 1
  %attr17 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr16, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr17, i32 0, i32 0
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.91, i32 0, i32 0), i8** %name, align 8, !tbaa !217
  %12 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %devattr18 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %12, i32 0, i32 1
  %attr19 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr18, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr19, i32 0, i32 1
  store i16 292, i16* %mode, align 8, !tbaa !219
  %13 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %devattr20 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %13, i32 0, i32 1
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr20, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_handles_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !220
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %14 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %devattr21 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %14, i32 0, i32 1
  %call22 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %devattr21)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %cleanup

if.then24:                                        ; preds = %do.body13
  %15 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %16 = bitcast %struct.sony_nc_handles* %15 to i8*
  call void @kfree(i8* %16)
  store %struct.sony_nc_handles* null, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  br label %cleanup

cleanup:                                          ; preds = %for.end, %do.body13, %entry, %if.then24
  %retval.0 = phi i32 [ -1, %if.then24 ], [ -12, %entry ], [ 0, %do.body13 ], [ 0, %for.end ]
  %17 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %17) #8
  %18 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %18) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_function_setup(%struct.acpi_device* %device, %struct.platform_device* %pf_device) #1 {
entry:
  %result = alloca i32, align 4
  %bitmask = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i32* %bitmask to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %2 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #8
  %3 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %tobool = icmp ne %struct.sony_nc_handles* %3, null
  br i1 %tobool, label %if.end, label %cleanup65

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock71, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %LeafBlock71 ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %4, i32 0, i32 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %5 = load i16, i16* %arrayidx, align 2, !tbaa !197
  %conv2 = zext i16 %5 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br i1 %tobool3, label %do.body, label %LeafBlock71

do.body:                                          ; preds = %for.body
  %6 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %if.then7, label %NodeBlock68

if.then7:                                         ; preds = %do.body
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.94, i32 0, i32 0), i32 %conv2)
  br label %NodeBlock68

NodeBlock68:                                      ; preds = %do.body, %if.then7
  %Pivot69 = icmp slt i32 %conv2, 309
  br i1 %Pivot69, label %NodeBlock31, label %NodeBlock66

NodeBlock66:                                      ; preds = %NodeBlock68
  %Pivot67 = icmp slt i32 %conv2, 326
  br i1 %Pivot67, label %NodeBlock45, label %NodeBlock64

NodeBlock64:                                      ; preds = %NodeBlock66
  %Pivot65 = icmp slt i32 %conv2, 331
  br i1 %Pivot65, label %NodeBlock51, label %NodeBlock62

NodeBlock62:                                      ; preds = %NodeBlock64
  %Pivot63 = icmp slt i32 %conv2, 347
  br i1 %Pivot63, label %LeafBlock53, label %NodeBlock60

NodeBlock60:                                      ; preds = %NodeBlock62
  %Pivot61 = icmp slt i32 %conv2, 355
  br i1 %Pivot61, label %LeafBlock56, label %LeafBlock58

LeafBlock58:                                      ; preds = %NodeBlock60
  %SwitchLeaf59 = icmp eq i32 %conv2, 355
  br i1 %SwitchLeaf59, label %sw.bb54, label %LeafBlock71

LeafBlock56:                                      ; preds = %NodeBlock60
  %SwitchLeaf57 = icmp eq i32 %conv2, 347
  br i1 %SwitchLeaf57, label %sw.bb36, label %LeafBlock71

LeafBlock53:                                      ; preds = %NodeBlock62
  %.off54 = add i32 %conv2, -331
  %SwitchLeaf55 = icmp ule i32 %.off54, 1
  br i1 %SwitchLeaf55, label %sw.bb54, label %LeafBlock71

NodeBlock51:                                      ; preds = %NodeBlock64
  %Pivot52 = icmp slt i32 %conv2, 328
  br i1 %Pivot52, label %LeafBlock47, label %LeafBlock49

LeafBlock49:                                      ; preds = %NodeBlock51
  %SwitchLeaf50 = icmp eq i32 %conv2, 328
  br i1 %SwitchLeaf50, label %sw.bb12, label %LeafBlock71

LeafBlock47:                                      ; preds = %NodeBlock51
  %SwitchLeaf48 = icmp eq i32 %conv2, 326
  br i1 %SwitchLeaf48, label %sw.bb36, label %LeafBlock71

NodeBlock45:                                      ; preds = %NodeBlock66
  %Pivot46 = icmp slt i32 %conv2, 311
  br i1 %Pivot46, label %NodeBlock33, label %NodeBlock43

NodeBlock43:                                      ; preds = %NodeBlock45
  %Pivot44 = icmp slt i32 %conv2, 319
  br i1 %Pivot44, label %LeafBlock35, label %NodeBlock41

NodeBlock41:                                      ; preds = %NodeBlock43
  %Pivot42 = icmp slt i32 %conv2, 323
  br i1 %Pivot42, label %LeafBlock37, label %LeafBlock39

LeafBlock39:                                      ; preds = %NodeBlock41
  %SwitchLeaf40 = icmp eq i32 %conv2, 323
  br i1 %SwitchLeaf40, label %sw.bb54, label %LeafBlock71

LeafBlock37:                                      ; preds = %NodeBlock41
  %SwitchLeaf38 = icmp eq i32 %conv2, 319
  br i1 %SwitchLeaf38, label %sw.bb18, label %LeafBlock71

LeafBlock35:                                      ; preds = %NodeBlock43
  %SwitchLeaf36 = icmp eq i32 %conv2, 311
  br i1 %SwitchLeaf36, label %sw.bb54, label %LeafBlock71

NodeBlock33:                                      ; preds = %NodeBlock45
  %Pivot34 = icmp slt i32 %conv2, 310
  br i1 %Pivot34, label %sw.bb48, label %sw.bb18

NodeBlock31:                                      ; preds = %NodeBlock68
  %Pivot32 = icmp slt i32 %conv2, 290
  br i1 %Pivot32, label %NodeBlock13, label %NodeBlock29

NodeBlock29:                                      ; preds = %NodeBlock31
  %Pivot30 = icmp slt i32 %conv2, 295
  br i1 %Pivot30, label %NodeBlock19, label %NodeBlock27

NodeBlock27:                                      ; preds = %NodeBlock29
  %Pivot28 = icmp slt i32 %conv2, 296
  br i1 %Pivot28, label %sw.bb, label %NodeBlock25

NodeBlock25:                                      ; preds = %NodeBlock27
  %Pivot26 = icmp slt i32 %conv2, 305
  br i1 %Pivot26, label %LeafBlock21, label %LeafBlock23

LeafBlock23:                                      ; preds = %NodeBlock25
  %SwitchLeaf24 = icmp eq i32 %conv2, 305
  br i1 %SwitchLeaf24, label %sw.bb42, label %LeafBlock71

LeafBlock21:                                      ; preds = %NodeBlock25
  %SwitchLeaf22 = icmp eq i32 %conv2, 296
  br i1 %SwitchLeaf22, label %sw.bb36, label %LeafBlock71

NodeBlock19:                                      ; preds = %NodeBlock29
  %Pivot20 = icmp slt i32 %conv2, 292
  br i1 %Pivot20, label %LeafBlock15, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %conv2, 292
  br i1 %SwitchLeaf18, label %sw.bb48, label %LeafBlock71

LeafBlock15:                                      ; preds = %NodeBlock19
  %SwitchLeaf16 = icmp eq i32 %conv2, 290
  br i1 %SwitchLeaf16, label %sw.bb30, label %LeafBlock71

NodeBlock13:                                      ; preds = %NodeBlock31
  %Pivot14 = icmp slt i32 %conv2, 261
  br i1 %Pivot14, label %NodeBlock, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %conv2, 277
  br i1 %Pivot12, label %LeafBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %conv2, 281
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv2, 281
  br i1 %SwitchLeaf8, label %sw.bb24, label %LeafBlock71

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv2, 277
  br i1 %SwitchLeaf6, label %sw.bb18, label %LeafBlock71

LeafBlock3:                                       ; preds = %NodeBlock11
  %SwitchLeaf4 = icmp eq i32 %conv2, 261
  br i1 %SwitchLeaf4, label %sw.bb12, label %LeafBlock71

NodeBlock:                                        ; preds = %NodeBlock13
  %Pivot = icmp slt i32 %conv2, 258
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv2, 258
  br i1 %SwitchLeaf2, label %sw.bb10, label %LeafBlock71

LeafBlock:                                        ; preds = %NodeBlock
  %.off = add i32 %conv2, -256
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %LeafBlock71

sw.bb:                                            ; preds = %NodeBlock27, %LeafBlock
  %call9 = call i32 @sony_call_snc_handle(i32 %conv2, i32 0, i32* %result)
  br label %LeafBlock71

sw.bb10:                                          ; preds = %LeafBlock1
  %call11 = call i32 @sony_call_snc_handle(i32 %conv2, i32 256, i32* %result)
  br label %LeafBlock71

sw.bb12:                                          ; preds = %LeafBlock49, %LeafBlock3
  %call13 = call i32 @sony_nc_touchpad_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call13, i32* %result, align 4, !tbaa !12
  %7 = load i32, i32* %result, align 4, !tbaa !12
  %tobool14 = icmp ne i32 %7, 0
  br i1 %tobool14, label %if.then15, label %LeafBlock71

if.then15:                                        ; preds = %sw.bb12
  %8 = load i32, i32* %result, align 4, !tbaa !12
  %call16 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.95, i32 0, i32 0), i32 %8)
  br label %LeafBlock71

sw.bb18:                                          ; preds = %LeafBlock37, %NodeBlock33, %LeafBlock5
  %call19 = call i32 @sony_nc_battery_care_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call19, i32* %result, align 4, !tbaa !12
  %9 = load i32, i32* %result, align 4, !tbaa !12
  %tobool20 = icmp ne i32 %9, 0
  br i1 %tobool20, label %if.then21, label %LeafBlock71

if.then21:                                        ; preds = %sw.bb18
  %10 = load i32, i32* %result, align 4, !tbaa !12
  %call22 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.96, i32 0, i32 0), i32 %10)
  br label %LeafBlock71

sw.bb24:                                          ; preds = %LeafBlock7
  %call25 = call i32 @sony_nc_lid_resume_setup(%struct.platform_device* %pf_device)
  store i32 %call25, i32* %result, align 4, !tbaa !12
  %11 = load i32, i32* %result, align 4, !tbaa !12
  %tobool26 = icmp ne i32 %11, 0
  br i1 %tobool26, label %if.then27, label %LeafBlock71

if.then27:                                        ; preds = %sw.bb24
  %12 = load i32, i32* %result, align 4, !tbaa !12
  %call28 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.97, i32 0, i32 0), i32 %12)
  br label %LeafBlock71

sw.bb30:                                          ; preds = %LeafBlock15
  %call31 = call i32 @sony_nc_thermal_setup(%struct.platform_device* %pf_device)
  store i32 %call31, i32* %result, align 4, !tbaa !12
  %13 = load i32, i32* %result, align 4, !tbaa !12
  %tobool32 = icmp ne i32 %13, 0
  br i1 %tobool32, label %if.then33, label %LeafBlock71

if.then33:                                        ; preds = %sw.bb30
  %14 = load i32, i32* %result, align 4, !tbaa !12
  %call34 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.98, i32 0, i32 0), i32 %14)
  br label %LeafBlock71

sw.bb36:                                          ; preds = %LeafBlock56, %LeafBlock47, %LeafBlock21
  %call37 = call i32 @sony_nc_gfx_switch_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call37, i32* %result, align 4, !tbaa !12
  %15 = load i32, i32* %result, align 4, !tbaa !12
  %tobool38 = icmp ne i32 %15, 0
  br i1 %tobool38, label %if.then39, label %LeafBlock71

if.then39:                                        ; preds = %sw.bb36
  %16 = load i32, i32* %result, align 4, !tbaa !12
  %call40 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.99, i32 0, i32 0), i32 %16)
  br label %LeafBlock71

sw.bb42:                                          ; preds = %LeafBlock23
  %call43 = call i32 @sony_nc_highspeed_charging_setup(%struct.platform_device* %pf_device)
  store i32 %call43, i32* %result, align 4, !tbaa !12
  %17 = load i32, i32* %result, align 4, !tbaa !12
  %tobool44 = icmp ne i32 %17, 0
  br i1 %tobool44, label %if.then45, label %LeafBlock71

if.then45:                                        ; preds = %sw.bb42
  %18 = load i32, i32* %result, align 4, !tbaa !12
  %call46 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.100, i32 0, i32 0), i32 %18)
  br label %LeafBlock71

sw.bb48:                                          ; preds = %NodeBlock33, %LeafBlock17
  %call49 = call i32 @sony_nc_rfkill_setup(%struct.acpi_device* %device, i32 %conv2)
  store i32 %call49, i32* %result, align 4, !tbaa !12
  %19 = load i32, i32* %result, align 4, !tbaa !12
  %tobool50 = icmp ne i32 %19, 0
  br i1 %tobool50, label %if.then51, label %LeafBlock71

if.then51:                                        ; preds = %sw.bb48
  %20 = load i32, i32* %result, align 4, !tbaa !12
  %call52 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.101, i32 0, i32 0), i32 %20)
  br label %LeafBlock71

sw.bb54:                                          ; preds = %LeafBlock58, %LeafBlock53, %LeafBlock39, %LeafBlock35
  %call55 = call i32 @sony_nc_kbd_backlight_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call55, i32* %result, align 4, !tbaa !12
  %21 = load i32, i32* %result, align 4, !tbaa !12
  %tobool56 = icmp ne i32 %21, 0
  br i1 %tobool56, label %if.then57, label %LeafBlock71

if.then57:                                        ; preds = %sw.bb54
  %22 = load i32, i32* %result, align 4, !tbaa !12
  %call58 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.102, i32 0, i32 0), i32 %22)
  br label %LeafBlock71

LeafBlock71:                                      ; preds = %for.body, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock7, %LeafBlock15, %LeafBlock17, %LeafBlock21, %LeafBlock23, %LeafBlock35, %LeafBlock37, %LeafBlock39, %LeafBlock47, %LeafBlock49, %LeafBlock53, %LeafBlock56, %LeafBlock58, %sw.bb54, %if.then57, %sw.bb48, %if.then51, %sw.bb42, %if.then45, %sw.bb36, %if.then39, %sw.bb30, %if.then33, %sw.bb24, %if.then27, %sw.bb18, %if.then21, %sw.bb12, %if.then15, %sw.bb10, %sw.bb
  %cleanup.dest.slot.0 = phi i32 [ 4, %for.body ], [ 4, %LeafBlock ], [ 4, %LeafBlock1 ], [ 4, %LeafBlock3 ], [ 4, %LeafBlock5 ], [ 4, %LeafBlock7 ], [ 4, %LeafBlock15 ], [ 4, %LeafBlock17 ], [ 4, %LeafBlock21 ], [ 4, %LeafBlock23 ], [ 4, %LeafBlock35 ], [ 4, %LeafBlock37 ], [ 4, %LeafBlock39 ], [ 4, %LeafBlock47 ], [ 4, %LeafBlock49 ], [ 4, %LeafBlock53 ], [ 4, %LeafBlock56 ], [ 4, %LeafBlock58 ], [ 0, %sw.bb54 ], [ 0, %if.then57 ], [ 0, %sw.bb48 ], [ 0, %if.then51 ], [ 0, %sw.bb42 ], [ 0, %if.then45 ], [ 0, %sw.bb36 ], [ 0, %if.then39 ], [ 0, %sw.bb30 ], [ 0, %if.then33 ], [ 0, %sw.bb24 ], [ 0, %if.then27 ], [ 0, %sw.bb18 ], [ 0, %if.then21 ], [ 0, %sw.bb12 ], [ 0, %if.then15 ], [ 0, %sw.bb10 ], [ 0, %sw.bb ]
  %SwitchLeaf72 = icmp eq i32 %cleanup.dest.slot.0, 4
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 16, i32* %arg, align 4, !tbaa !12
  %23 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call60 = call i32 @sony_nc_int_call(i8* %23, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i32* %arg, i32* %bitmask)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %cleanup65, label %if.then62

if.then62:                                        ; preds = %for.end
  %24 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call63 = call i32 @sony_nc_int_call(i8* %24, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.103, i32 0, i32 0), i32* %bitmask, i32* %result)
  br label %cleanup65

cleanup65:                                        ; preds = %for.end, %if.then62, %entry
  %cleanup.dest.slot.1 = phi i32 [ 1, %entry ], [ 0, %if.then62 ], [ 0, %for.end ]
  %25 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %25) #8
  %26 = bitcast i32* %bitmask to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %26) #8
  %27 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %27) #8
  ret void
}

declare i32 @acpi_video_backlight_support() #2

; Function Attrs: nounwind uwtable
define internal void @sony_nc_backlight_setup() #1 {
entry:
  %unused = alloca i8*, align 8
  %props = alloca %struct.backlight_properties, align 4
  %0 = bitcast i8** %unused to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast %struct.backlight_properties* %props to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %1) #8
  %call = call i32 @sony_find_snc_handle(i32 303)
  %cmp = icmp sge i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 256, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !221
  call void @sony_nc_backlight_ng_read_limits(i32 303, %struct.sony_backlight_props* @sony_bl_props)
  %2 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !222
  %conv = zext i8 %2 to i32
  %3 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !223
  %conv1 = zext i8 %3 to i32
  %sub = sub nsw i32 %conv, %conv1
  br label %if.end41

if.else:                                          ; preds = %entry
  %call2 = call i32 @sony_find_snc_handle(i32 311)
  %cmp3 = icmp sge i32 %call2, 0
  br i1 %cmp3, label %if.then5, label %if.else9

if.then5:                                         ; preds = %if.else
  store i32 256, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !221
  call void @sony_nc_backlight_ng_read_limits(i32 311, %struct.sony_backlight_props* @sony_bl_props)
  %4 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !222
  %conv6 = zext i8 %4 to i32
  %5 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !223
  %conv7 = zext i8 %5 to i32
  %sub8 = sub nsw i32 %conv6, %conv7
  br label %if.end41

if.else9:                                         ; preds = %if.else
  %call10 = call i32 @sony_find_snc_handle(i32 323)
  %cmp11 = icmp sge i32 %call10, 0
  br i1 %cmp11, label %if.then13, label %if.else17

if.then13:                                        ; preds = %if.else9
  store i32 12288, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !221
  call void @sony_nc_backlight_ng_read_limits(i32 323, %struct.sony_backlight_props* @sony_bl_props)
  %6 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !222
  %conv14 = zext i8 %6 to i32
  %7 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !223
  %conv15 = zext i8 %7 to i32
  %sub16 = sub nsw i32 %conv14, %conv15
  br label %if.end41

if.else17:                                        ; preds = %if.else9
  %call18 = call i32 @sony_find_snc_handle(i32 331)
  %cmp19 = icmp sge i32 %call18, 0
  br i1 %cmp19, label %if.then21, label %if.else25

if.then21:                                        ; preds = %if.else17
  store i32 12288, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !221
  call void @sony_nc_backlight_ng_read_limits(i32 331, %struct.sony_backlight_props* @sony_bl_props)
  %8 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !222
  %conv22 = zext i8 %8 to i32
  %9 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !223
  %conv23 = zext i8 %9 to i32
  %sub24 = sub nsw i32 %conv22, %conv23
  br label %if.end41

if.else25:                                        ; preds = %if.else17
  %call26 = call i32 @sony_find_snc_handle(i32 332)
  %cmp27 = icmp sge i32 %call26, 0
  br i1 %cmp27, label %if.then29, label %if.else33

if.then29:                                        ; preds = %if.else25
  store i32 12288, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !221
  call void @sony_nc_backlight_ng_read_limits(i32 332, %struct.sony_backlight_props* @sony_bl_props)
  %10 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !222
  %conv30 = zext i8 %10 to i32
  %11 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !223
  %conv31 = zext i8 %11 to i32
  %sub32 = sub nsw i32 %conv30, %conv31
  br label %if.end41

if.else33:                                        ; preds = %if.else25
  %12 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call34 = call i32 @acpi_get_handle(i8* %12, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.57, i32 0, i32 0), i8** %unused)
  %tobool = icmp ne i32 %call34, 0
  br i1 %tobool, label %cleanup, label %if.end41

if.end41:                                         ; preds = %if.then5, %if.then21, %if.else33, %if.then29, %if.then13, %if.then
  %ops.4 = phi %struct.backlight_ops* [ @sony_backlight_ng_ops, %if.then ], [ @sony_backlight_ng_ops, %if.then5 ], [ @sony_backlight_ng_ops, %if.then13 ], [ @sony_backlight_ng_ops, %if.then21 ], [ @sony_backlight_ng_ops, %if.then29 ], [ @sony_backlight_ops, %if.else33 ]
  %max_brightness.4 = phi i32 [ %sub, %if.then ], [ %sub8, %if.then5 ], [ %sub16, %if.then13 ], [ %sub24, %if.then21 ], [ %sub32, %if.then29 ], [ 7, %if.else33 ]
  %13 = bitcast %struct.backlight_properties* %props to i8*
  call void @llvm.memset.p0i8.i64(i8* %13, i8 0, i64 24, i32 4, i1 false)
  %type = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 4
  store i32 2, i32* %type, align 4, !tbaa !224
  %max_brightness42 = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 1
  store i32 %max_brightness.4, i32* %max_brightness42, align 4, !tbaa !225
  %call43 = call %struct.backlight_device* @backlight_device_register(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.143, i32 0, i32 0), %struct.device* null, i8* bitcast (%struct.sony_backlight_props* @sony_bl_props to i8*), %struct.backlight_ops* %ops.4, %struct.backlight_properties* %props)
  store %struct.backlight_device* %call43, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  %14 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  %15 = bitcast %struct.backlight_device* %14 to i8*
  %call44 = call i64 @IS_ERR(i8* %15)
  %tobool45 = icmp ne i64 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.else48

if.then46:                                        ; preds = %if.end41
  %call47 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.144, i32 0, i32 0))
  store %struct.backlight_device* null, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  br label %cleanup

if.else48:                                        ; preds = %if.end41
  %get_brightness = getelementptr inbounds %struct.backlight_ops, %struct.backlight_ops* %ops.4, i32 0, i32 2
  %16 = load i32 (%struct.backlight_device*)*, i32 (%struct.backlight_device*)** %get_brightness, align 8, !tbaa !226
  %17 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  %call49 = call i32 %16(%struct.backlight_device* %17)
  %18 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  %props50 = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %18, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props50, i32 0, i32 0
  store i32 %call49, i32* %brightness, align 8, !tbaa !160
  br label %cleanup

cleanup:                                          ; preds = %if.then46, %if.else48, %if.else33
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.else33 ], [ 0, %if.else48 ], [ 0, %if.then46 ]
  %19 = bitcast %struct.backlight_properties* %props to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %19) #8
  %20 = bitcast i8** %unused to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #8
  ret void
}

declare i32 @device_create_file(%struct.device*, %struct.device_attribute*) #2

declare void @device_remove_file(%struct.device*, %struct.device_attribute*) #2

; Function Attrs: nounwind uwtable
define internal void @sony_nc_backlight_cleanup() #1 {
entry:
  %0 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  %tobool = icmp ne %struct.backlight_device* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !158
  call void @backlight_device_unregister(%struct.backlight_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_function_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %result = alloca i32, align 4
  %bitmask = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i32* %bitmask to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %2 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call = call i32 @sony_nc_int_call(i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.181, i32 0, i32 0), i32* null, i32* %bitmask)
  %3 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call1 = call i32 @sony_nc_int_call(i8* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.182, i32 0, i32 0), i32* %bitmask, i32* %result)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %4, i32 0, i32 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %5 = load i16, i16* %arrayidx, align 2, !tbaa !197
  %conv3 = zext i16 %5 to i32
  %tobool = icmp ne i32 %conv3, 0
  br i1 %tobool, label %NodeBlock57, label %for.inc

NodeBlock57:                                      ; preds = %for.body
  %Pivot58 = icmp slt i32 %conv3, 310
  br i1 %Pivot58, label %NodeBlock23, label %NodeBlock55

NodeBlock55:                                      ; preds = %NodeBlock57
  %Pivot56 = icmp slt i32 %conv3, 326
  br i1 %Pivot56, label %NodeBlock35, label %NodeBlock53

NodeBlock53:                                      ; preds = %NodeBlock55
  %Pivot54 = icmp slt i32 %conv3, 331
  br i1 %Pivot54, label %NodeBlock41, label %NodeBlock51

NodeBlock51:                                      ; preds = %NodeBlock53
  %Pivot52 = icmp slt i32 %conv3, 347
  br i1 %Pivot52, label %LeafBlock43, label %NodeBlock49

NodeBlock49:                                      ; preds = %NodeBlock51
  %Pivot50 = icmp slt i32 %conv3, 355
  br i1 %Pivot50, label %LeafBlock45, label %LeafBlock47

LeafBlock47:                                      ; preds = %NodeBlock49
  %SwitchLeaf48 = icmp eq i32 %conv3, 355
  br i1 %SwitchLeaf48, label %sw.bb10, label %for.inc

LeafBlock45:                                      ; preds = %NodeBlock49
  %SwitchLeaf46 = icmp eq i32 %conv3, 347
  br i1 %SwitchLeaf46, label %sw.bb7, label %for.inc

LeafBlock43:                                      ; preds = %NodeBlock51
  %.off = add i32 %conv3, -331
  %SwitchLeaf44 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf44, label %sw.bb10, label %for.inc

NodeBlock41:                                      ; preds = %NodeBlock53
  %Pivot42 = icmp slt i32 %conv3, 328
  br i1 %Pivot42, label %LeafBlock37, label %LeafBlock39

LeafBlock39:                                      ; preds = %NodeBlock41
  %SwitchLeaf40 = icmp eq i32 %conv3, 328
  br i1 %SwitchLeaf40, label %sw.bb, label %for.inc

LeafBlock37:                                      ; preds = %NodeBlock41
  %SwitchLeaf38 = icmp eq i32 %conv3, 326
  br i1 %SwitchLeaf38, label %sw.bb7, label %for.inc

NodeBlock35:                                      ; preds = %NodeBlock55
  %Pivot36 = icmp slt i32 %conv3, 319
  br i1 %Pivot36, label %NodeBlock27, label %NodeBlock33

NodeBlock33:                                      ; preds = %NodeBlock35
  %Pivot34 = icmp slt i32 %conv3, 323
  br i1 %Pivot34, label %LeafBlock29, label %LeafBlock31

LeafBlock31:                                      ; preds = %NodeBlock33
  %SwitchLeaf32 = icmp eq i32 %conv3, 323
  br i1 %SwitchLeaf32, label %sw.bb10, label %for.inc

LeafBlock29:                                      ; preds = %NodeBlock33
  %SwitchLeaf30 = icmp eq i32 %conv3, 319
  br i1 %SwitchLeaf30, label %sw.bb4, label %for.inc

NodeBlock27:                                      ; preds = %NodeBlock35
  %Pivot28 = icmp slt i32 %conv3, 311
  br i1 %Pivot28, label %sw.bb4, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %conv3, 311
  br i1 %SwitchLeaf26, label %sw.bb10, label %for.inc

NodeBlock23:                                      ; preds = %NodeBlock57
  %Pivot24 = icmp slt i32 %conv3, 292
  br i1 %Pivot24, label %NodeBlock9, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %conv3, 305
  br i1 %Pivot22, label %NodeBlock15, label %NodeBlock19

NodeBlock19:                                      ; preds = %NodeBlock21
  %Pivot20 = icmp slt i32 %conv3, 309
  br i1 %Pivot20, label %LeafBlock17, label %sw.bb9

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %conv3, 305
  br i1 %SwitchLeaf18, label %sw.bb8, label %for.inc

NodeBlock15:                                      ; preds = %NodeBlock21
  %Pivot16 = icmp slt i32 %conv3, 296
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %conv3, 296
  br i1 %SwitchLeaf14, label %sw.bb7, label %for.inc

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %conv3, 292
  br i1 %SwitchLeaf12, label %sw.bb9, label %for.inc

NodeBlock9:                                       ; preds = %NodeBlock23
  %Pivot10 = icmp slt i32 %conv3, 281
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %conv3, 290
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %conv3, 290
  br i1 %SwitchLeaf6, label %sw.bb6, label %for.inc

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %conv3, 281
  br i1 %SwitchLeaf4, label %sw.bb5, label %for.inc

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %conv3, 277
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv3, 277
  br i1 %SwitchLeaf2, label %sw.bb4, label %for.inc

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv3, 261
  br i1 %SwitchLeaf, label %sw.bb, label %for.inc

sw.bb:                                            ; preds = %LeafBlock39, %LeafBlock
  call void @sony_nc_touchpad_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb4:                                           ; preds = %LeafBlock29, %NodeBlock27, %LeafBlock1
  call void @sony_nc_battery_care_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb5:                                           ; preds = %LeafBlock3
  call void @sony_nc_lid_resume_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb6:                                           ; preds = %LeafBlock5
  call void @sony_nc_thermal_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb7:                                           ; preds = %LeafBlock45, %LeafBlock37, %LeafBlock13
  call void @sony_nc_gfx_switch_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb8:                                           ; preds = %LeafBlock17
  call void @sony_nc_highspeed_charging_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb9:                                           ; preds = %NodeBlock19, %LeafBlock11
  call void @sony_nc_rfkill_cleanup()
  br label %for.inc

sw.bb10:                                          ; preds = %LeafBlock47, %LeafBlock43, %LeafBlock31, %LeafBlock25
  call void @sony_nc_kbd_backlight_cleanup(%struct.platform_device* %pd)
  br label %for.inc

for.inc:                                          ; preds = %sw.bb, %sw.bb4, %sw.bb5, %sw.bb6, %sw.bb7, %sw.bb8, %sw.bb9, %sw.bb10, %LeafBlock47, %LeafBlock45, %LeafBlock43, %LeafBlock39, %LeafBlock37, %LeafBlock31, %LeafBlock29, %LeafBlock25, %LeafBlock17, %LeafBlock13, %LeafBlock11, %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call11 = call i32 @sony_nc_handles_cleanup(%struct.platform_device* %pd)
  %6 = bitcast i32* %bitmask to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #8
  %7 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_handles_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %tobool = icmp ne %struct.sony_nc_handles* %0, null
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %1 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %2 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %devattr = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %2, i32 0, i32 1
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %devattr)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %3 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %4 = bitcast %struct.sony_nc_handles* %3 to i8*
  call void @kfree(i8* %4)
  store %struct.sony_nc_handles* null, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_rfkill_cleanup() #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom
  %0 = load %struct.rfkill*, %struct.rfkill** %arrayidx, align 8, !tbaa !38
  %tobool = icmp ne %struct.rfkill* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %idxprom1 = sext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom1
  %1 = load %struct.rfkill*, %struct.rfkill** %arrayidx2, align 8, !tbaa !38
  call void @rfkill_unregister(%struct.rfkill* %1)
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom3
  %2 = load %struct.rfkill*, %struct.rfkill** %arrayidx4, align 8, !tbaa !38
  call void @rfkill_destroy(%struct.rfkill* %2)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare i32 @acpi_get_object_info(i8*, %struct.acpi_device_info**) #2

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_handles_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %len.0 = phi i64 [ 0, %entry ], [ %add, %for.body ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %len.0
  %sub = sub i64 4096, %len.0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %0, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %1 = load i16, i16* %arrayidx, align 2, !tbaa !197
  %conv2 = zext i16 %1 to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr, i64 %sub, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.92, i32 0, i32 0), i32 %conv2)
  %conv3 = sext i32 %call to i64
  %add = add nsw i64 %len.0, %conv3
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr, i64 %sub, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.93, i32 0, i32 0))
  %conv7 = sext i32 %call6 to i64
  %add8 = add nsw i64 %len.0, %conv7
  ret i64 %add8
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_call_snc_handle(i32 %handle, i32 %argument, i32* %result) #1 {
entry:
  %arg = alloca i32, align 4
  %0 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %call = call i32 @sony_find_snc_handle(i32 %handle)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %or = or i32 %call, %argument
  store i32 %or, i32* %arg, align 4, !tbaa !12
  %1 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call1 = call i32 @sony_nc_int_call(i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i32 0, i32 0), i32* %arg, i32* %result)
  %2 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then2, label %cleanup

if.then2:                                         ; preds = %if.end
  %3 = load i32, i32* %arg, align 4, !tbaa !12
  %4 = load i32, i32* %result, align 4, !tbaa !12
  %call3 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.105, i32 0, i32 0), i32 %3, i32 %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then2, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %call1, %if.then2 ], [ %call1, %if.end ]
  %5 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %5) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_touchpad_setup(%struct.platform_device* %pd, i32 %handle) #1 {
entry:
  %call = call i8* @kzalloc(i64 56, i32 208)
  %0 = bitcast i8* %call to %struct.touchpad_control*
  store %struct.touchpad_control* %0, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %1 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %tobool = icmp ne %struct.touchpad_control* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %handle1 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %2, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !228
  %3 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %attr = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %3, i32 0, i32 0
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_touchpad_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !216
  %4 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %attr3 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %4, i32 0, i32 0
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.108, i32 0, i32 0), i8** %name, align 8, !tbaa !230
  %5 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %attr5 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %5, i32 0, i32 0
  %attr6 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr5, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr6, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !231
  %6 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %attr7 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %6, i32 0, i32 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr7, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_touchpad_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !232
  %7 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %attr8 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %7, i32 0, i32 0
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr8, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_touchpad_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !233
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %8 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %attr9 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %8, i32 0, i32 0
  %call10 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %attr9)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %cleanup

if.then12:                                        ; preds = %if.end
  %9 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %10 = bitcast %struct.touchpad_control* %9 to i8*
  call void @kfree(i8* %10)
  store %struct.touchpad_control* null, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then12, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %call10, %if.then12 ], [ %call10, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_battery_care_setup(%struct.platform_device* %pd, i32 %handle) #1 {
entry:
  %call = call i8* @kzalloc(i64 104, i32 208)
  %0 = bitcast i8* %call to %struct.battery_care_control*
  store %struct.battery_care_control* %0, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %1 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %tobool = icmp ne %struct.battery_care_control* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %handle1 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %2, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !234
  %3 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %3, i32 0, i32 0
  %arrayidx = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs, i64 0, i64 0
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_battery_care_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !216
  %4 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs2 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %4, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs2, i64 0, i64 0
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  store i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.109, i32 0, i32 0), i8** %name, align 8, !tbaa !236
  %5 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs5 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %5, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs5, i64 0, i64 0
  %attr7 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx6, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr7, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !237
  %6 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs8 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %6, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs8, i64 0, i64 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx9, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_battery_care_limit_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !238
  %7 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs10 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %7, i32 0, i32 0
  %arrayidx11 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs10, i64 0, i64 0
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx11, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_battery_care_limit_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !239
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %8 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs12 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %8, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs12, i64 0, i64 0
  %call14 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %arrayidx13)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %outkzalloc, label %if.end17

if.end17:                                         ; preds = %if.end
  %cmp = icmp eq i32 %handle, 277
  br i1 %cmp, label %cleanup, label %do.body20

do.body20:                                        ; preds = %if.end17
  %9 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs21 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %9, i32 0, i32 0
  %arrayidx22 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs21, i64 0, i64 1
  %attr23 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx22, i32 0, i32 0
  %key24 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr23, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_battery_care_setup.__key.110, %struct.lock_class_key** %key24, align 8, !tbaa !216
  %10 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs27 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %10, i32 0, i32 0
  %arrayidx28 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs27, i64 0, i64 1
  %attr29 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx28, i32 0, i32 0
  %name30 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr29, i32 0, i32 0
  store i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.111, i32 0, i32 0), i8** %name30, align 8, !tbaa !236
  %11 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs31 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %11, i32 0, i32 0
  %arrayidx32 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs31, i64 0, i64 1
  %attr33 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx32, i32 0, i32 0
  %mode34 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr33, i32 0, i32 1
  store i16 292, i16* %mode34, align 8, !tbaa !237
  %12 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs35 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %12, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs35, i64 0, i64 1
  %show37 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx36, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_battery_care_health_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show37, align 8, !tbaa !238
  %dev38 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %13 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs39 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %13, i32 0, i32 0
  %arrayidx40 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs39, i64 0, i64 1
  %call41 = call i32 @device_create_file(%struct.device* %dev38, %struct.device_attribute* %arrayidx40)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %outlimiter, label %cleanup

outlimiter:                                       ; preds = %do.body20
  %dev45 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %14 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs46 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %14, i32 0, i32 0
  %arrayidx47 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs46, i64 0, i64 0
  call void @device_remove_file(%struct.device* %dev45, %struct.device_attribute* %arrayidx47)
  br label %outkzalloc

outkzalloc:                                       ; preds = %if.end, %outlimiter
  %ret.0 = phi i32 [ %call41, %outlimiter ], [ %call14, %if.end ]
  %15 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %16 = bitcast %struct.battery_care_control* %15 to i8*
  call void @kfree(i8* %16)
  store %struct.battery_care_control* null, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  br label %cleanup

cleanup:                                          ; preds = %do.body20, %if.end17, %entry, %outkzalloc
  %retval.0 = phi i32 [ %ret.0, %outkzalloc ], [ -12, %entry ], [ 0, %if.end17 ], [ 0, %do.body20 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_lid_resume_setup(%struct.platform_device* %pd) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %call = call i32 @sony_call_snc_handle(i32 281, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i8* @kzalloc(i64 152, i32 208)
  %1 = bitcast i8* %call1 to %struct.snc_lid_resume_control*
  store %struct.snc_lid_resume_control* %1, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %2 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %tobool2 = icmp ne %struct.snc_lid_resume_control* %2, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %3 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %3, 7
  %4 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %status = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %4, i32 0, i32 1
  store i32 %and, i32* %status, align 8, !tbaa !240
  %5 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %5, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs, i64 0, i64 0
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_lid_resume_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !216
  %6 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs5 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %6, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs5, i64 0, i64 0
  %attr7 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx6, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr7, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.112, i32 0, i32 0), i8** %name, align 8, !tbaa !236
  %7 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs8 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %7, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs8, i64 0, i64 0
  %attr10 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx9, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr10, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !237
  %8 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs11 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %8, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs11, i64 0, i64 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx12, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_lid_resume_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !238
  %9 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs13 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %9, i32 0, i32 0
  %arrayidx14 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs13, i64 0, i64 0
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx14, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_lid_resume_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !239
  %10 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs16 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %10, i32 0, i32 0
  %arrayidx17 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs16, i64 0, i64 1
  %attr18 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx17, i32 0, i32 0
  %key19 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr18, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_lid_resume_setup.__key.113, %struct.lock_class_key** %key19, align 8, !tbaa !216
  %11 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs22 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %11, i32 0, i32 0
  %arrayidx23 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs22, i64 0, i64 1
  %attr24 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx23, i32 0, i32 0
  %name25 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr24, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.114, i32 0, i32 0), i8** %name25, align 8, !tbaa !236
  %12 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs26 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %12, i32 0, i32 0
  %arrayidx27 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs26, i64 0, i64 1
  %attr28 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx27, i32 0, i32 0
  %mode29 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr28, i32 0, i32 1
  store i16 420, i16* %mode29, align 8, !tbaa !237
  %13 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs30 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %13, i32 0, i32 0
  %arrayidx31 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs30, i64 0, i64 1
  %show32 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx31, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_lid_resume_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show32, align 8, !tbaa !238
  %14 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs33 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %14, i32 0, i32 0
  %arrayidx34 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs33, i64 0, i64 1
  %store35 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx34, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_lid_resume_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store35, align 8, !tbaa !239
  %15 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs37 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %15, i32 0, i32 0
  %arrayidx38 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs37, i64 0, i64 2
  %attr39 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx38, i32 0, i32 0
  %key40 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr39, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_lid_resume_setup.__key.115, %struct.lock_class_key** %key40, align 8, !tbaa !216
  %16 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs43 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %16, i32 0, i32 0
  %arrayidx44 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs43, i64 0, i64 2
  %attr45 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx44, i32 0, i32 0
  %name46 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr45, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.116, i32 0, i32 0), i8** %name46, align 8, !tbaa !236
  %17 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs47 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %17, i32 0, i32 0
  %arrayidx48 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs47, i64 0, i64 2
  %attr49 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx48, i32 0, i32 0
  %mode50 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr49, i32 0, i32 1
  store i16 420, i16* %mode50, align 8, !tbaa !237
  %18 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs51 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %18, i32 0, i32 0
  %arrayidx52 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs51, i64 0, i64 2
  %show53 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx52, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_lid_resume_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show53, align 8, !tbaa !238
  %19 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs54 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %19, i32 0, i32 0
  %arrayidx55 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs54, i64 0, i64 2
  %store56 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx55, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_lid_resume_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store56, align 8, !tbaa !239
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %i.0 = phi i32 [ 0, %if.end4 ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %20 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs57 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %20, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx58 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs57, i64 0, i64 %idxprom
  %call59 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %arrayidx58)
  store i32 %call59, i32* %result, align 4, !tbaa !12
  %21 = load i32, i32* %result, align 4, !tbaa !12
  %tobool60 = icmp ne i32 %21, 0
  br i1 %tobool60, label %liderror, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

liderror:                                         ; preds = %for.body
  br label %for.cond63

for.cond63:                                       ; preds = %for.body65, %liderror
  %i.1.sink = phi i32 [ %dec71, %for.body65 ], [ %i.0, %liderror ]
  %dec71 = add nsw i32 %i.1.sink, -1
  %cmp64 = icmp sge i32 %dec71, 0
  br i1 %cmp64, label %for.body65, label %for.end72

for.body65:                                       ; preds = %for.cond63
  %dev66 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %22 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs67 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %22, i32 0, i32 0
  %idxprom68 = sext i32 %dec71 to i64
  %arrayidx69 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs67, i64 0, i64 %idxprom68
  call void @device_remove_file(%struct.device* %dev66, %struct.device_attribute* %arrayidx69)
  br label %for.cond63

for.end72:                                        ; preds = %for.cond63
  %23 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %24 = bitcast %struct.snc_lid_resume_control* %23 to i8*
  call void @kfree(i8* %24)
  store %struct.snc_lid_resume_control* null, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %25 = load i32, i32* %result, align 4, !tbaa !12
  br label %cleanup

cleanup:                                          ; preds = %for.cond, %if.end, %entry, %for.end72
  %retval.0 = phi i32 [ %25, %for.end72 ], [ -5, %entry ], [ -12, %if.end ], [ 0, %for.cond ]
  %26 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %26) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_thermal_setup(%struct.platform_device* %pd) #1 {
entry:
  %call = call i8* @kzalloc(i64 104, i32 208)
  %0 = bitcast i8* %call to %struct.snc_thermal_ctrl*
  store %struct.snc_thermal_ctrl* %0, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %1 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %tobool = icmp ne %struct.snc_thermal_ctrl* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %profiles = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %2, i32 0, i32 1
  %call1 = call i32 @sony_call_snc_handle(i32 290, i32 0, i32* %profiles)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.117, i32 0, i32 0))
  br label %outkzalloc

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @sony_nc_thermal_mode_get()
  %cmp = icmp slt i32 %call6, 0
  br i1 %cmp, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end5
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.118, i32 0, i32 0))
  br label %outkzalloc

if.end9:                                          ; preds = %if.end5
  %3 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %3, i32 0, i32 0
  store i32 %call6, i32* %mode, align 8, !tbaa !242
  %4 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %profiles_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %4, i32 0, i32 3
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_thermal_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !216
  %5 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %profiles_attr10 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %5, i32 0, i32 3
  %attr11 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr10, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr11, i32 0, i32 0
  store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.119, i32 0, i32 0), i8** %name, align 8, !tbaa !244
  %6 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %profiles_attr12 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %6, i32 0, i32 3
  %attr13 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr12, i32 0, i32 0
  %mode14 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr13, i32 0, i32 1
  store i16 292, i16* %mode14, align 8, !tbaa !245
  %7 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %profiles_attr15 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %7, i32 0, i32 3
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr15, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_thermal_profiles_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !246
  %8 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %8, i32 0, i32 2
  %attr17 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr, i32 0, i32 0
  %key18 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr17, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_thermal_setup.__key.120, %struct.lock_class_key** %key18, align 8, !tbaa !216
  %9 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode_attr21 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %9, i32 0, i32 2
  %attr22 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr21, i32 0, i32 0
  %name23 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr22, i32 0, i32 0
  store i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.121, i32 0, i32 0), i8** %name23, align 8, !tbaa !247
  %10 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode_attr24 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %10, i32 0, i32 2
  %attr25 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr24, i32 0, i32 0
  %mode26 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr25, i32 0, i32 1
  store i16 420, i16* %mode26, align 8, !tbaa !248
  %11 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode_attr27 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %11, i32 0, i32 2
  %show28 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr27, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_thermal_mode_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show28, align 8, !tbaa !249
  %12 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode_attr29 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %12, i32 0, i32 2
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr29, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_thermal_mode_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !250
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %13 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %profiles_attr30 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %13, i32 0, i32 3
  %call31 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %profiles_attr30)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %outkzalloc, label %if.end34

if.end34:                                         ; preds = %if.end9
  %dev35 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %14 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode_attr36 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %14, i32 0, i32 2
  %call37 = call i32 @device_create_file(%struct.device* %dev35, %struct.device_attribute* %mode_attr36)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %outprofiles, label %cleanup

outprofiles:                                      ; preds = %if.end34
  %dev41 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %15 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %profiles_attr42 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %15, i32 0, i32 3
  call void @device_remove_file(%struct.device* %dev41, %struct.device_attribute* %profiles_attr42)
  br label %outkzalloc

outkzalloc:                                       ; preds = %if.end9, %outprofiles, %if.then7, %if.then3
  %ret.0 = phi i32 [ %call1, %if.then3 ], [ %call6, %if.then7 ], [ %call37, %outprofiles ], [ %call31, %if.end9 ]
  %16 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %17 = bitcast %struct.snc_thermal_ctrl* %16 to i8*
  call void @kfree(i8* %17)
  store %struct.snc_thermal_ctrl* null, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  br label %cleanup

cleanup:                                          ; preds = %if.end34, %entry, %outkzalloc
  %retval.0 = phi i32 [ %ret.0, %outkzalloc ], [ -12, %entry ], [ 0, %if.end34 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_gfx_switch_setup(%struct.platform_device* %pd, i32 %handle) #1 {
entry:
  %call = call i8* @kzalloc(i64 56, i32 208)
  %0 = bitcast i8* %call to %struct.snc_gfx_switch_control*
  store %struct.snc_gfx_switch_control* %0, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %1 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %tobool = icmp ne %struct.snc_gfx_switch_control* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %handle1 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %2, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !251
  %3 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %attr = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %3, i32 0, i32 0
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_gfx_switch_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !216
  %4 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %attr3 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %4, i32 0, i32 0
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.127, i32 0, i32 0), i8** %name, align 8, !tbaa !253
  %5 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %attr5 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %5, i32 0, i32 0
  %attr6 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr5, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr6, i32 0, i32 1
  store i16 292, i16* %mode, align 8, !tbaa !254
  %6 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %attr7 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %6, i32 0, i32 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr7, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_gfx_switch_status_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !255
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %7 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %attr8 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %7, i32 0, i32 0
  %call9 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %attr8)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %gfxerror, label %cleanup

gfxerror:                                         ; preds = %if.end
  %8 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %9 = bitcast %struct.snc_gfx_switch_control* %8 to i8*
  call void @kfree(i8* %9)
  store %struct.snc_gfx_switch_control* null, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %gfxerror
  %retval.0 = phi i32 [ %call9, %gfxerror ], [ -12, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_highspeed_charging_setup(%struct.platform_device* %pd) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %call = call i32 @sony_call_snc_handle(i32 305, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %1, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.131, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %call3 = call i8* @kzalloc(i64 48, i32 208)
  %2 = bitcast i8* %call3 to %struct.device_attribute*
  store %struct.device_attribute* %2, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %3 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %tobool4 = icmp ne %struct.device_attribute* %3, null
  br i1 %tobool4, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %4 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %4, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_highspeed_charging_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !216
  %5 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %attr7 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %5, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr7, i32 0, i32 0
  store i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.132, i32 0, i32 0), i8** %name, align 8, !tbaa !236
  %6 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %attr8 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %6, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr8, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !237
  %7 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %7, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_highspeed_charging_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !238
  %8 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %8, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_highspeed_charging_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !239
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %9 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %call9 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %9)
  store i32 %call9, i32* %result, align 4, !tbaa !12
  %10 = load i32, i32* %result, align 4, !tbaa !12
  %tobool10 = icmp ne i32 %10, 0
  br i1 %tobool10, label %if.then11, label %cleanup

if.then11:                                        ; preds = %do.body
  %11 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %12 = bitcast %struct.device_attribute* %11 to i8*
  call void @kfree(i8* %12)
  store %struct.device_attribute* null, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %13 = load i32, i32* %result, align 4, !tbaa !12
  br label %cleanup

cleanup:                                          ; preds = %do.body, %if.end, %if.then11, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %13, %if.then11 ], [ -12, %if.end ], [ 0, %do.body ]
  %14 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_rfkill_setup(%struct.acpi_device* %device, i32 %handle) #1 {
entry:
  %offset = alloca i64, align 8
  %buffer = alloca [32 x i8], align 16
  %0 = bitcast i64* %offset to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast [32 x i8]* %buffer to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %1) #8
  %2 = bitcast [32 x i8]* %buffer to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 32, i32 16, i1 false)
  %call = call i32 @sony_find_snc_handle(i32 %handle)
  %conv = sext i32 %call to i64
  store i64 %conv, i64* %offset, align 8, !tbaa !196
  store i32 %handle, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %3 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i32 0, i32 0
  %call1 = call i32 @sony_nc_buffer_call(i8* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.133, i32 0, i32 0), i64* %offset, i8* %arraydecay, i64 32)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv3 = sext i32 %i.0 to i64
  %cmp4 = icmp ult i64 %conv3, 32
  br i1 %cmp4, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !44
  %conv6 = zext i8 %4 to i32
  %cmp7 = icmp eq i32 %conv6, 255
  br i1 %cmp7, label %cleanup, label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  %idxprom12 = sext i32 %i.0 to i64
  %arrayidx13 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom12
  %6 = load i8, i8* %arrayidx13, align 1, !tbaa !44
  %conv14 = zext i8 %6 to i32
  %call15 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.134, i32 0, i32 0), i32 %conv14)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %idxprom17 = sext i32 %i.0 to i64
  %arrayidx18 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom17
  %7 = load i8, i8* %arrayidx18, align 1, !tbaa !44
  %conv19 = zext i8 %7 to i32
  %cmp20 = icmp ne i32 %conv19, 0
  %8 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 0), align 16
  %tobool22 = icmp ne %struct.rfkill* %8, null
  %or.cond = or i1 %cmp20, %tobool22
  br i1 %or.cond, label %if.end25, label %if.then23

if.then23:                                        ; preds = %do.end
  %call24 = call i32 @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 0)
  br label %if.end25

if.end25:                                         ; preds = %do.end, %if.then23
  %idxprom26 = sext i32 %i.0 to i64
  %arrayidx27 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom26
  %9 = load i8, i8* %arrayidx27, align 1, !tbaa !44
  %conv28 = zext i8 %9 to i32
  %cmp29 = icmp ne i32 %conv28, 16
  %10 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 1), align 8
  %tobool32 = icmp ne %struct.rfkill* %10, null
  %or.cond1 = or i1 %cmp29, %tobool32
  br i1 %or.cond1, label %if.end35, label %if.then33

if.then33:                                        ; preds = %if.end25
  %call34 = call i32 @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 1)
  br label %if.end35

if.end35:                                         ; preds = %if.end25, %if.then33
  %idxprom36 = sext i32 %i.0 to i64
  %arrayidx37 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom36
  %11 = load i8, i8* %arrayidx37, align 1, !tbaa !44
  %conv38 = zext i8 %11 to i32
  %and = and i32 240, %conv38
  %cmp39 = icmp eq i32 %and, 32
  br i1 %cmp39, label %land.lhs.true47, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end35
  %idxprom41 = sext i32 %i.0 to i64
  %arrayidx42 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom41
  %12 = load i8, i8* %arrayidx42, align 1, !tbaa !44
  %conv43 = zext i8 %12 to i32
  %and44 = and i32 240, %conv43
  %cmp45 = icmp ne i32 %and44, 80
  %13 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 2), align 16
  %tobool48 = icmp ne %struct.rfkill* %13, null
  %or.cond2 = or i1 %cmp45, %tobool48
  br i1 %or.cond2, label %if.end51, label %if.then49

land.lhs.true47:                                  ; preds = %if.end35
  %.old = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 2), align 16, !tbaa !38
  %tobool48.old = icmp ne %struct.rfkill* %.old, null
  br i1 %tobool48.old, label %if.end51, label %if.then49

if.then49:                                        ; preds = %lor.lhs.false, %land.lhs.true47
  %call50 = call i32 @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 2)
  br label %if.end51

if.end51:                                         ; preds = %lor.lhs.false, %if.then49, %land.lhs.true47
  %idxprom52 = sext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom52
  %14 = load i8, i8* %arrayidx53, align 1, !tbaa !44
  %conv54 = zext i8 %14 to i32
  %cmp55 = icmp ne i32 %conv54, 48
  %15 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 3), align 8
  %tobool58 = icmp ne %struct.rfkill* %15, null
  %or.cond4 = or i1 %cmp55, %tobool58
  br i1 %or.cond4, label %for.inc, label %if.then59

if.then59:                                        ; preds = %if.end51
  %call60 = call i32 @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 3)
  br label %for.inc

for.inc:                                          ; preds = %if.then59, %if.end51
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond, %entry
  %retval.0 = phi i32 [ %call1, %entry ], [ 0, %for.cond ], [ 0, %for.body ]
  %16 = bitcast [32 x i8]* %buffer to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %16) #8
  %17 = bitcast i64* %offset to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_kbd_backlight_setup(%struct.platform_device* %pd, i32 %handle) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %cmp = icmp eq i32 %handle, 311
  %1 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 2816, i32 256
  %call = call i32 @sony_call_snc_handle(i32 %handle, i32 %cond, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq i32 %handle, 311
  br i1 %cmp1, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end
  %2 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %2, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %lor.lhs.false, label %do.body

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end
  %3 = load i32, i32* %result, align 4, !tbaa !12
  %and3 = and i32 %3, 1
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.end10, label %do.body

do.body:                                          ; preds = %land.lhs.true, %lor.lhs.false
  %4 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool6 = icmp ne i32 %4, 0
  br i1 %tobool6, label %if.then7, label %cleanup

if.then7:                                         ; preds = %do.body
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.139, i32 0, i32 0))
  br label %cleanup

if.end10:                                         ; preds = %lor.lhs.false
  %call11 = call i8* @kzalloc(i64 112, i32 208)
  %5 = bitcast i8* %call11 to %struct.kbd_backlight*
  store %struct.kbd_backlight* %5, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %6 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %tobool12 = icmp ne %struct.kbd_backlight* %6, null
  br i1 %tobool12, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end10
  %7 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %handle15 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %7, i32 0, i32 0
  store i32 %handle, i32* %handle15, align 8, !tbaa !256
  %cmp16 = icmp eq i32 %handle, 311
  %8 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %8, i32 0, i32 1
  %.sink = select i1 %cmp16, i32 3072, i32 16384
  store i32 %.sink, i32* %base, align 4, !tbaa !258
  %9 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %9, i32 0, i32 4
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_kbd_backlight_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !216
  %10 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode_attr23 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %10, i32 0, i32 4
  %attr24 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr23, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr24, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.140, i32 0, i32 0), i8** %name, align 8, !tbaa !259
  %11 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode_attr25 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %11, i32 0, i32 4
  %attr26 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr25, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr26, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !260
  %12 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode_attr27 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %12, i32 0, i32 4
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr27, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_kbd_backlight_mode_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !261
  %13 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode_attr28 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %13, i32 0, i32 4
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr28, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_kbd_backlight_mode_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !262
  %14 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %14, i32 0, i32 5
  %attr30 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr, i32 0, i32 0
  %key31 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr30, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_kbd_backlight_setup.__key.141, %struct.lock_class_key** %key31, align 8, !tbaa !216
  %15 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout_attr34 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %15, i32 0, i32 5
  %attr35 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr34, i32 0, i32 0
  %name36 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr35, i32 0, i32 0
  store i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.142, i32 0, i32 0), i8** %name36, align 8, !tbaa !263
  %16 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout_attr37 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %16, i32 0, i32 5
  %attr38 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr37, i32 0, i32 0
  %mode39 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr38, i32 0, i32 1
  store i16 420, i16* %mode39, align 8, !tbaa !264
  %17 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout_attr40 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %17, i32 0, i32 5
  %show41 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr40, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_kbd_backlight_timeout_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show41, align 8, !tbaa !265
  %18 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout_attr42 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %18, i32 0, i32 5
  %store43 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr42, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_kbd_backlight_timeout_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store43, align 8, !tbaa !266
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %19 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode_attr44 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %19, i32 0, i32 4
  %call45 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %mode_attr44)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %outkzalloc, label %if.end48

if.end48:                                         ; preds = %if.end14
  %dev49 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %20 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout_attr50 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %20, i32 0, i32 5
  %call51 = call i32 @device_create_file(%struct.device* %dev49, %struct.device_attribute* %timeout_attr50)
  %tobool52 = icmp ne i32 %call51, 0
  br i1 %tobool52, label %outmode, label %if.end54

if.end54:                                         ; preds = %if.end48
  %21 = load i32, i32* @kbd_backlight, align 4, !tbaa !12
  %conv = trunc i32 %21 to i8
  %call55 = call i64 @__sony_nc_kbd_backlight_mode_set(i8 zeroext %conv)
  %22 = load i32, i32* @kbd_backlight_timeout, align 4, !tbaa !12
  %conv56 = trunc i32 %22 to i8
  %call57 = call i32 @__sony_nc_kbd_backlight_timeout_set(i8 zeroext %conv56)
  br label %cleanup

outmode:                                          ; preds = %if.end48
  %dev58 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %23 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode_attr59 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %23, i32 0, i32 4
  call void @device_remove_file(%struct.device* %dev58, %struct.device_attribute* %mode_attr59)
  br label %outkzalloc

outkzalloc:                                       ; preds = %if.end14, %outmode
  %ret.0 = phi i32 [ %call51, %outmode ], [ %call45, %if.end14 ]
  %24 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %25 = bitcast %struct.kbd_backlight* %24 to i8*
  call void @kfree(i8* %25)
  store %struct.kbd_backlight* null, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %do.body, %if.then7, %entry, %outkzalloc, %if.end54
  %retval.0 = phi i32 [ %ret.0, %outkzalloc ], [ 0, %if.end54 ], [ %call, %entry ], [ 0, %if.then7 ], [ 0, %do.body ], [ -12, %if.end10 ]
  %26 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %26) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_find_snc_handle(i32 %handle) #1 {
entry:
  %0 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %tobool = icmp ne %struct.sony_nc_handles* %0, null
  %tobool1 = icmp ne i32 %handle, 0
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %for.body, label %do.body9

for.body:                                         ; preds = %for.cond
  %1 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %1, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %2 = load i16, i16* %arrayidx, align 2, !tbaa !197
  %conv = zext i16 %2 to i32
  %cmp2 = icmp eq i32 %conv, %handle
  br i1 %cmp2, label %do.body, label %for.inc

do.body:                                          ; preds = %for.body
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool5 = icmp ne i32 %3, 0
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %do.body
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.106, i32 0, i32 0), i32 %handle, i32 %i.0)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

do.body9:                                         ; preds = %for.cond
  %4 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool10 = icmp ne i32 %4, 0
  br i1 %tobool10, label %if.then11, label %cleanup

if.then11:                                        ; preds = %do.body9
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.107, i32 0, i32 0), i32 %handle)
  br label %cleanup

cleanup:                                          ; preds = %do.body9, %if.then11, %do.body, %if.then6, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ %i.0, %if.then6 ], [ %i.0, %do.body ], [ -22, %if.then11 ], [ -22, %do.body9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_touchpad_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !228
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %3, 1
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot.ext = zext i1 %lnot to i32
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %lnot.ext)
  %conv = sext i32 %call2 to i64
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i64 [ %conv, %if.end ], [ -22, %entry ]
  %4 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_touchpad_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %2, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %3, i32 0, i32 1
  %4 = load i32, i32* %handle, align 8, !tbaa !228
  %5 = load i64, i64* %value, align 8, !tbaa !107
  %tobool4 = icmp ne i64 %5, 0
  %lnot = xor i1 %tobool4, true
  %lnot.ext = zext i1 %lnot to i32
  %shl = shl i32 %lnot.ext, 16
  %or = or i32 %shl, 256
  %call5 = call i32 @sony_call_snc_handle(i32 %4, i32 %or, i32* %result)
  %tobool6 = icmp ne i32 %call5, 0
  %.count = select i1 %tobool6, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end3 ]
  %6 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_battery_care_limit_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !234
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %3, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %cond.true, label %NodeBlock3

cond.true:                                        ; preds = %if.end
  %4 = load i32, i32* %result, align 4, !tbaa !12
  %and2 = and i32 %4, 48
  %shr = lshr i32 %and2, 4
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %cond.true, %if.end
  %cond = phi i32 [ %shr, %cond.true ], [ 0, %if.end ]
  %Pivot4 = icmp slt i32 %cond, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cond, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cond, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cond, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock1, %NodeBlock, %LeafBlock, %sw.default
  %status.0 = phi i32 [ 0, %sw.default ], [ 80, %LeafBlock ], [ 50, %NodeBlock ], [ 100, %LeafBlock1 ]
  %call5 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %status.0)
  %conv = sext i32 %call5 to i64
  br label %cleanup

cleanup:                                          ; preds = %entry, %sw.epilog
  %retval.0 = phi i64 [ %conv, %sw.epilog ], [ -5, %entry ]
  %5 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %5) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_battery_care_limit_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %2 = load i64, i64* %value, align 8, !tbaa !107
  %cmp3 = icmp ugt i64 %2, 0
  br i1 %cmp3, label %if.then4, label %if.end21

if.then4:                                         ; preds = %if.end2
  %3 = load i64, i64* %value, align 8, !tbaa !107
  %cmp5 = icmp ule i64 %3, 50
  br i1 %cmp5, label %if.end15, label %if.else

if.else:                                          ; preds = %if.then4
  %4 = load i64, i64* %value, align 8, !tbaa !107
  %cmp7 = icmp ule i64 %4, 80
  br i1 %cmp7, label %if.end15, label %if.else9

if.else9:                                         ; preds = %if.else
  %5 = load i64, i64* %value, align 8, !tbaa !107
  %cmp10 = icmp ule i64 %5, 100
  br i1 %cmp10, label %if.end15, label %cleanup

if.end15:                                         ; preds = %if.else, %if.else9, %if.then4
  %cmd.1 = phi i32 [ 32, %if.then4 ], [ 16, %if.else ], [ 48, %if.else9 ]
  %6 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %6, i32 0, i32 1
  %7 = load i32, i32* %handle, align 8, !tbaa !234
  %cmp16 = icmp ne i32 %7, 319
  %shl = shl i32 %cmd.1, 2
  %or = or i32 %cmd.1, %shl
  %cmd.2 = select i1 %cmp16, i32 %or, i32 %cmd.1
  %or19 = or i32 %cmd.2, 1
  %shl20 = shl i32 %or19, 16
  br label %if.end21

if.end21:                                         ; preds = %if.end15, %if.end2
  %cmd.3 = phi i32 [ %shl20, %if.end15 ], [ 0, %if.end2 ]
  %8 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %handle22 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %8, i32 0, i32 1
  %9 = load i32, i32* %handle22, align 8, !tbaa !234
  %or23 = or i32 %cmd.3, 256
  %call24 = call i32 @sony_call_snc_handle(i32 %9, i32 %or23, i32* %result)
  %tobool25 = icmp ne i32 %call24, 0
  %.count = select i1 %tobool25, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %if.else9, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ -22, %if.else9 ], [ %.count, %if.end21 ]
  %10 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #8
  %11 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %11) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_battery_care_health_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %health = alloca i32, align 4
  %0 = bitcast i32* %health to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !234
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 512, i32* %health)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %health, align 4, !tbaa !12
  %and = and i32 %3, 255
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  %4 = bitcast i32* %health to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_lid_resume_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %attr1 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr1, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !236
  %call = call i32 @strcmp(i8* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.112, i32 0, i32 0))
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.end15, label %if.else

if.else:                                          ; preds = %entry
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name3 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 0
  %1 = load i8*, i8** %name3, align 8, !tbaa !236
  %call4 = call i32 @strcmp(i8* %1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.114, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.end15, label %if.else7

if.else7:                                         ; preds = %if.else
  %attr8 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name9 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr8, i32 0, i32 0
  %2 = load i8*, i8** %name9, align 8, !tbaa !236
  %call10 = call i32 @strcmp(i8* %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.116, i32 0, i32 0))
  %cmp11 = icmp eq i32 %call10, 0
  br i1 %cmp11, label %if.end15, label %cleanup

if.end15:                                         ; preds = %if.else, %if.else7, %entry
  %pos.1 = phi i32 [ 2, %entry ], [ 1, %if.else ], [ 0, %if.else7 ]
  %3 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %status = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %3, i32 0, i32 1
  %4 = load i32, i32* %status, align 8, !tbaa !240
  %shr = lshr i32 %4, %pos.1
  %and = and i32 %shr, 1
  %call16 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call16 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.else7, %if.end15
  %retval.0 = phi i64 [ %conv, %if.end15 ], [ -22, %if.else7 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_lid_resume_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %2, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  %3 = load i8*, i8** %name, align 8, !tbaa !236
  %call5 = call i32 @strcmp(i8* %3, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.112, i32 0, i32 0))
  %cmp6 = icmp eq i32 %call5, 0
  br i1 %cmp6, label %if.end22, label %if.else

if.else:                                          ; preds = %if.end3
  %attr8 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name9 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr8, i32 0, i32 0
  %4 = load i8*, i8** %name9, align 8, !tbaa !236
  %call10 = call i32 @strcmp(i8* %4, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.114, i32 0, i32 0))
  %cmp11 = icmp eq i32 %call10, 0
  br i1 %cmp11, label %if.end22, label %if.else13

if.else13:                                        ; preds = %if.else
  %attr14 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name15 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr14, i32 0, i32 0
  %5 = load i8*, i8** %name15, align 8, !tbaa !236
  %call16 = call i32 @strcmp(i8* %5, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.116, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.end22, label %cleanup

if.end22:                                         ; preds = %if.else, %if.else13, %if.end3
  %pos.1 = phi i32 [ 2, %if.end3 ], [ 1, %if.else ], [ 0, %if.else13 ]
  %6 = load i64, i64* %value, align 8, !tbaa !107
  %tobool23 = icmp ne i64 %6, 0
  %7 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %status = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %7, i32 0, i32 1
  %8 = load i32, i32* %status, align 8, !tbaa !240
  %shl = shl i32 1, %pos.1
  br i1 %tobool23, label %if.then24, label %if.else25

if.then24:                                        ; preds = %if.end22
  %or = or i32 %8, %shl
  %conv = zext i32 %or to i64
  store i64 %conv, i64* %value, align 8, !tbaa !107
  br label %if.end29

if.else25:                                        ; preds = %if.end22
  %neg = xor i32 %shl, -1
  %and = and i32 %8, %neg
  %conv28 = zext i32 %and to i64
  store i64 %conv28, i64* %value, align 8, !tbaa !107
  br label %if.end29

if.end29:                                         ; preds = %if.else25, %if.then24
  %9 = load i64, i64* %value, align 8, !tbaa !107
  %shl30 = shl i64 %9, 16
  %or31 = or i64 %shl30, 256
  %conv32 = trunc i64 %or31 to i32
  %call33 = call i32 @sony_call_snc_handle(i32 281, i32 %conv32, i32* %result)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %cleanup, label %if.end36

if.end36:                                         ; preds = %if.end29
  %10 = load i64, i64* %value, align 8, !tbaa !107
  %conv37 = trunc i64 %10 to i32
  %11 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %status38 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %11, i32 0, i32 1
  store i32 %conv37, i32* %status38, align 8, !tbaa !240
  br label %cleanup

cleanup:                                          ; preds = %if.end29, %if.else13, %if.end, %entry, %if.end36
  %retval.0 = phi i64 [ %count, %if.end36 ], [ -22, %entry ], [ -22, %if.end ], [ -22, %if.else13 ], [ -5, %if.end29 ]
  %12 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #8
  %13 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %13) #8
  ret i64 %retval.0
}

declare i32 @strcmp(i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_thermal_mode_get() #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %call = call i32 @sony_call_snc_handle(i32 290, i32 256, i32* %result)
  %tobool = icmp ne i32 %call, 0
  %1 = load i32, i32* %result, align 4
  %and = and i32 %1, 255
  %retval.0 = select i1 %tobool, i32 -5, i32 %and
  %2 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %2) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_thermal_profiles_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %cnt.0 = phi i16 [ 0, %entry ], [ %inc, %for.inc ]
  %idx.0 = phi i64 [ 0, %entry ], [ %idx.1, %for.inc ]
  %conv = sext i16 %cnt.0 to i32
  %cmp = icmp slt i32 %conv, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %tobool = icmp ne i16 %cnt.0, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %for.body
  %0 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %profiles = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %0, i32 0, i32 1
  %1 = load i32, i32* %profiles, align 4, !tbaa !267
  %conv2 = sext i16 %cnt.0 to i32
  %and = and i32 %1, %conv2
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then, label %for.inc

if.then:                                          ; preds = %lor.lhs.false, %for.body
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %idx.0
  %sub = sub i64 4096, %idx.0
  %idxprom = sext i16 %cnt.0 to i64
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @snc_thermal_profiles, i64 0, i64 %idxprom
  %2 = load i8*, i8** %arrayidx, align 8, !tbaa !38
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr, i64 %sub, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.122, i32 0, i32 0), i8* %2)
  %conv4 = sext i32 %call to i64
  %add = add i64 %idx.0, %conv4
  br label %for.inc

for.inc:                                          ; preds = %lor.lhs.false, %if.then
  %idx.1 = phi i64 [ %add, %if.then ], [ %idx.0, %lor.lhs.false ]
  %inc = add i16 %cnt.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %add.ptr5 = getelementptr inbounds i8, i8* %buffer, i64 %idx.0
  %sub6 = sub i64 4096, %idx.0
  %call7 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr5, i64 %sub6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.93, i32 0, i32 0))
  %conv8 = sext i32 %call7 to i64
  %add9 = add i64 %idx.0, %conv8
  ret i64 %add9
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_thermal_mode_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %call = call i32 @sony_nc_thermal_mode_get()
  %cmp = icmp slt i32 %call, 0
  %conv = sext i32 %call to i64
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @snc_thermal_profiles, i64 0, i64 %conv
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !38
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i32 0, i32 0), i8* %0)
  %conv2 = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i64 [ %conv2, %if.end ], [ %conv, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_thermal_mode_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %cmp = icmp eq i64 %count, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sub = sub i64 %count, 1
  %arrayidx = getelementptr inbounds i8, i8* %buffer, i64 %sub
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !44
  %conv = sext i8 %0 to i32
  %cmp1 = icmp eq i32 %conv, 10
  %dec = add i64 %count, -1
  %dec.count = select i1 %cmp1, i64 %dec, i64 %count
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %cmd.0 = phi i16 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv5 = zext i16 %cmd.0 to i32
  %cmp6 = icmp slt i32 %conv5, 3
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i16 %cmd.0 to i64
  %arrayidx8 = getelementptr inbounds [3 x i8*], [3 x i8*]* @snc_thermal_profiles, i64 0, i64 %idxprom
  %1 = load i8*, i8** %arrayidx8, align 8, !tbaa !38
  %call = call i32 @strncmp(i8* %buffer, i8* %1, i64 %dec.count)
  %cmp9 = icmp eq i32 %call, 0
  br i1 %cmp9, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add i16 %cmd.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %call13 = call i32 @sony_nc_thermal_mode_set(i16 zeroext %cmd.0)
  %tobool = icmp ne i32 %call13, 0
  %.count = select i1 %tobool, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ %.count, %for.end ]
  ret i64 %retval.0
}

declare i32 @strncmp(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_thermal_mode_set(i16 zeroext %mode) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %conv = zext i16 %mode to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %profiles = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %1, i32 0, i32 1
  %2 = load i32, i32* %profiles, align 4, !tbaa !267
  %conv1 = zext i16 %mode to i32
  %and = and i32 %2, %conv1
  %tobool2 = icmp eq i32 %and, 0
  %conv3 = zext i16 %mode to i32
  %cmp = icmp sge i32 %conv3, 3
  %or.cond = or i1 %tobool2, %cmp
  br i1 %or.cond, label %cleanup, label %if.end

lor.lhs.false:                                    ; preds = %entry
  %.old = zext i16 %mode to i32
  %cmp.old = icmp sge i32 %.old, 3
  br i1 %cmp.old, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %conv5 = zext i16 %mode to i32
  %shl = shl i32 %conv5, 16
  %or = or i32 %shl, 512
  %call = call i32 @sony_call_snc_handle(i32 290, i32 %or, i32* %result)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end
  %conv9 = zext i16 %mode to i32
  %3 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode10 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %3, i32 0, i32 0
  store i32 %conv9, i32* %mode10, align 8, !tbaa !242
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %land.lhs.true, %if.end8
  %retval.0 = phi i32 [ 0, %if.end8 ], [ -22, %land.lhs.true ], [ -22, %lor.lhs.false ], [ -5, %if.end ]
  %4 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_gfx_switch_status_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %call = call i32 @__sony_nc_gfx_switch_status_get()
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %tobool = icmp ne i32 %call, 0
  %0 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.128, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.129, i32 0, i32 0)
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i32 0, i32 0), i8* %cond)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %call1.sink = phi i32 [ %call1, %if.end ], [ %call, %entry ]
  %conv2 = sext i32 %call1.sink to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i32 @__sony_nc_gfx_switch_status_get() #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !251
  %3 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %handle1 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %3, i32 0, i32 1
  %4 = load i32, i32* %handle1, align 8, !tbaa !251
  %cmp = icmp eq i32 %4, 347
  %5 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 0, i32 256
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 %cond, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %6 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %handle2 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %6, i32 0, i32 1
  %7 = load i32, i32* %handle2, align 8, !tbaa !251
  %Pivot6 = icmp slt i32 %7, 326
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %7, 347
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %7, 347
  br i1 %SwitchLeaf4, label %sw.bb5, label %cleanup

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %7, 326
  br i1 %SwitchLeaf2, label %sw.bb, label %cleanup

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %7, 296
  br i1 %SwitchLeaf, label %do.body, label %cleanup

sw.bb:                                            ; preds = %LeafBlock1
  %8 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %8, 1
  %tobool3 = icmp ne i32 %and, 0
  %9 = zext i1 %tobool3 to i64
  %cond4 = select i1 %tobool3, i32 0, i32 1
  br label %cleanup

sw.bb5:                                           ; preds = %LeafBlock3
  %10 = load i32, i32* %result, align 4, !tbaa !12
  %and6 = and i32 %10, 1
  %tobool7 = icmp ne i32 %and6, 0
  %11 = zext i1 %tobool7 to i64
  %cond8 = select i1 %tobool7, i32 1, i32 0
  br label %cleanup

do.body:                                          ; preds = %LeafBlock
  %12 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool10 = icmp ne i32 %12, 0
  br i1 %tobool10, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  %13 = load i32, i32* %result, align 4, !tbaa !12
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.130, i32 0, i32 0), i32 %13)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %14 = load i32, i32* %result, align 4, !tbaa !12
  %and14 = and i32 %14, 128
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %cleanup, label %cond.false

cond.false:                                       ; preds = %do.end
  %15 = load i32, i32* %result, align 4, !tbaa !12
  %and16 = and i32 %15, 2
  %tobool17 = icmp ne i32 %and16, 0
  %16 = zext i1 %tobool17 to i64
  %cond18 = select i1 %tobool17, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock, %cond.false, %do.end, %entry, %sw.bb5, %sw.bb
  %retval.0 = phi i32 [ %cond4, %sw.bb ], [ %cond8, %sw.bb5 ], [ -5, %entry ], [ %cond18, %cond.false ], [ 2, %do.end ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock3 ]
  %17 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %17) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_highspeed_charging_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %call = call i32 @sony_call_snc_handle(i32 305, i32 256, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %1, 1
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  %2 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %2) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_highspeed_charging_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %2, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = load i64, i64* %value, align 8, !tbaa !107
  %shl = shl i64 %3, 16
  %or = or i64 %shl, 512
  %conv = trunc i64 %or to i32
  %call4 = call i32 @sony_call_snc_handle(i32 305, i32 %conv, i32* %result)
  %tobool5 = icmp ne i32 %call4, 0
  %.count = select i1 %tobool5, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end3 ]
  %4 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #8
  %5 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %5) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_buffer_call(i8* %handle, i8* %name, i64* %value, i8* %buffer, i64 %buflen) #1 {
entry:
  %call = call %union.acpi_object* @__call_snc_method(i8* %handle, i8* %name, i64* %value)
  %tobool = icmp ne %union.acpi_object* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %type = bitcast %union.acpi_object* %call to i32*
  %0 = load i32, i32* %type, align 8, !tbaa !44
  %cmp = icmp eq i32 %0, 3
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %buffer2 = bitcast %union.acpi_object* %call to %struct.anon.49*
  %length = getelementptr inbounds %struct.anon.49, %struct.anon.49* %buffer2, i32 0, i32 1
  %1 = load i32, i32* %length, align 4, !tbaa !44
  %conv = zext i32 %1 to i64
  %cmp3 = icmp ugt i64 %buflen, %conv
  br i1 %cmp3, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then1
  %buffer5 = bitcast %union.acpi_object* %call to %struct.anon.49*
  %length6 = getelementptr inbounds %struct.anon.49, %struct.anon.49* %buffer5, i32 0, i32 1
  %2 = load i32, i32* %length6, align 4, !tbaa !44
  %conv7 = zext i32 %2 to i64
  br label %cond.end

cond.end:                                         ; preds = %if.then1, %cond.true
  %cond = phi i64 [ %conv7, %cond.true ], [ %buflen, %if.then1 ]
  %buffer8 = bitcast %union.acpi_object* %call to %struct.anon.49*
  %pointer = getelementptr inbounds %struct.anon.49, %struct.anon.49* %buffer8, i32 0, i32 2
  %3 = load i8*, i8** %pointer, align 8, !tbaa !44
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %buffer, i8* %3, i64 %cond, i32 1, i1 false)
  br label %if.end27

if.else:                                          ; preds = %if.end
  %type9 = bitcast %union.acpi_object* %call to i32*
  %4 = load i32, i32* %type9, align 8, !tbaa !44
  %cmp10 = icmp eq i32 %4, 1
  br i1 %cmp10, label %if.then12, label %if.else23

if.then12:                                        ; preds = %if.else
  %cmp13 = icmp ugt i64 %buflen, 8
  %.buflen = select i1 %cmp13, i64 8, i64 %buflen
  %integer = bitcast %union.acpi_object* %call to %struct.anon.47*
  %value21 = getelementptr inbounds %struct.anon.47, %struct.anon.47* %integer, i32 0, i32 1
  %5 = bitcast i64* %value21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %buffer, i8* %5, i64 %.buflen, i32 1, i1 false)
  br label %if.end27

if.else23:                                        ; preds = %if.else
  %type24 = bitcast %union.acpi_object* %call to i32*
  %6 = load i32, i32* %type24, align 8, !tbaa !44
  %call25 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.59, i32 0, i32 0), i32 3, i32 %6)
  br label %if.end27

if.end27:                                         ; preds = %if.then12, %if.else23, %cond.end
  %ret.1 = phi i32 [ 0, %cond.end ], [ 0, %if.then12 ], [ -22, %if.else23 ]
  %7 = bitcast %union.acpi_object* %call to i8*
  call void @kfree(i8* %7)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end27
  %retval.0 = phi i32 [ %ret.1, %if.end27 ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 %nc_type) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %Pivot6 = icmp slt i32 %nc_type, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %nc_type, 3
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %nc_type, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %cleanup

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %nc_type, 1
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %nc_type, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %cleanup

sw.epilog:                                        ; preds = %LeafBlock1, %NodeBlock3, %NodeBlock, %LeafBlock
  %type.0 = phi i32 [ 1, %LeafBlock ], [ 2, %NodeBlock ], [ 5, %NodeBlock3 ], [ 4, %LeafBlock1 ]
  %name.0 = phi i8* [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.135, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([15 x i8], [15 x i8]* @.str.136, i32 0, i32 0), %NodeBlock ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.137, i32 0, i32 0), %NodeBlock3 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.138, i32 0, i32 0), %LeafBlock1 ]
  %dev = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 16
  %conv = zext i32 %nc_type to i64
  %1 = inttoptr i64 %conv to i8*
  %call = call %struct.rfkill* @rfkill_alloc(i8* %name.0, %struct.device* %dev, i32 %type.0, %struct.rfkill_ops* @sony_rfkill_ops, i8* %1)
  %tobool = icmp ne %struct.rfkill* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %sw.epilog
  %2 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %call4 = call i32 @sony_call_snc_handle(i32 %2, i32 512, i32* %result)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  call void @rfkill_destroy(%struct.rfkill* %call)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %3 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %3, 1
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %frombool = zext i1 %lnot to i8
  %4 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %idxprom = zext i32 %nc_type to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @sony_rfkill_address, i64 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %call9 = call i32 @sony_call_snc_handle(i32 %4, i32 %5, i32* %result)
  %cmp10 = icmp slt i32 %call9, 0
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end7
  call void @rfkill_destroy(%struct.rfkill* %call)
  br label %cleanup

if.end13:                                         ; preds = %if.end7
  %6 = load i32, i32* %result, align 4, !tbaa !12
  %and14 = and i32 %6, 2
  %tobool15 = icmp ne i32 %and14, 0
  %lnot16 = xor i1 %tobool15, true
  %frombool17 = zext i1 %lnot16 to i8
  %tobool18 = trunc i8 %frombool17 to i1
  call void @rfkill_init_sw_state(%struct.rfkill* %call, i1 zeroext %tobool18)
  %tobool19 = trunc i8 %frombool to i1
  %call20 = call zeroext i1 @rfkill_set_hw_state(%struct.rfkill* %call, i1 zeroext %tobool19)
  %call21 = call i32 @rfkill_register(%struct.rfkill* %call)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end13
  call void @rfkill_destroy(%struct.rfkill* %call)
  br label %cleanup

if.end24:                                         ; preds = %if.end13
  %idxprom25 = zext i32 %nc_type to i64
  %arrayidx26 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom25
  store %struct.rfkill* %call, %struct.rfkill** %arrayidx26, align 8, !tbaa !38
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %LeafBlock1, %LeafBlock, %if.end24, %if.then23, %if.then12, %if.then6
  %retval.0 = phi i32 [ -1, %if.then6 ], [ -1, %if.then12 ], [ %call21, %if.then23 ], [ %call21, %if.end24 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -12, %sw.epilog ]
  %7 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #8
  ret i32 %retval.0
}

declare %struct.rfkill* @rfkill_alloc(i8*, %struct.device*, i32, %struct.rfkill_ops*, i8*) #2

declare void @rfkill_destroy(%struct.rfkill*) #2

declare void @rfkill_init_sw_state(%struct.rfkill*, i1 zeroext) #2

declare zeroext i1 @rfkill_set_hw_state(%struct.rfkill*, i1 zeroext) #2

declare i32 @rfkill_register(%struct.rfkill*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_rfkill_set(i8* %data, i1 zeroext %blocked) #1 {
entry:
  %result = alloca i32, align 4
  %frombool = zext i1 %blocked to i8
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = ptrtoint i8* %data to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @sony_rfkill_address, i64 0, i64 %1
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %add = add nsw i32 %2, 256
  %tobool = trunc i8 %frombool to i1
  %or = or i32 %add, 458752
  %add.or = select i1 %tobool, i32 %add, i32 %or
  %3 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %call = call i32 @sony_call_snc_handle(i32 %3, i32 %add.or, i32* %result)
  %4 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #8
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_mode_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %0, i32 0, i32 2
  %1 = load i32, i32* %mode, align 8, !tbaa !268
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %1)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_mode_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i64, align 8
  %0 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %1 = load i64, i64* %value, align 8, !tbaa !107
  %conv = trunc i64 %1 to i8
  %call3 = call i64 @__sony_nc_kbd_backlight_mode_set(i8 zeroext %conv)
  %conv4 = trunc i64 %call3 to i32
  %cmp5 = icmp slt i32 %conv4, 0
  %conv8 = sext i32 %conv4 to i64
  %conv8.count = select i1 %cmp5, i64 %conv8, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %conv8.count, %if.end2 ]
  %2 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_timeout_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %0, i32 0, i32 3
  %1 = load i32, i32* %timeout, align 4, !tbaa !269
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %1)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_timeout_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i64, align 8
  %0 = bitcast i64* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %1 = load i64, i64* %value, align 8, !tbaa !107
  %conv = trunc i64 %1 to i8
  %call3 = call i32 @__sony_nc_kbd_backlight_timeout_set(i8 zeroext %conv)
  %cmp4 = icmp slt i32 %call3, 0
  %conv7 = sext i32 %call3 to i64
  %conv7.count = select i1 %cmp4, i64 %conv7, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %conv7.count, %if.end2 ]
  %2 = bitcast i64* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @__sony_nc_kbd_backlight_mode_set(i8 zeroext %value) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %conv = zext i8 %value to i32
  %cmp = icmp sgt i32 %conv, 1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %1, i32 0, i32 0
  %2 = load i32, i32* %handle, align 8, !tbaa !256
  %conv2 = zext i8 %value to i32
  %shl = shl i32 %conv2, 16
  %3 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %3, i32 0, i32 1
  %4 = load i32, i32* %base, align 4, !tbaa !258
  %or = or i32 %shl, %4
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 %or, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %5 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %handle5 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %5, i32 0, i32 0
  %6 = load i32, i32* %handle5, align 8, !tbaa !256
  %conv6 = zext i8 %value to i32
  %shl7 = shl i32 %conv6, 16
  %7 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %base8 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %7, i32 0, i32 1
  %8 = load i32, i32* %base8, align 4, !tbaa !258
  %add = add i32 %8, 256
  %or9 = or i32 %shl7, %add
  %call10 = call i32 @sony_call_snc_handle(i32 %6, i32 %or9, i32* %result)
  %conv11 = zext i8 %value to i32
  %9 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %9, i32 0, i32 2
  store i32 %conv11, i32* %mode, align 8, !tbaa !268
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end4
  %retval.0 = phi i64 [ 0, %if.end4 ], [ -22, %entry ], [ -5, %if.end ]
  %10 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %10) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @__sony_nc_kbd_backlight_timeout_set(i8 zeroext %value) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %conv = zext i8 %value to i32
  %cmp = icmp sgt i32 %conv, 3
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %1, i32 0, i32 0
  %2 = load i32, i32* %handle, align 8, !tbaa !256
  %conv2 = zext i8 %value to i32
  %shl = shl i32 %conv2, 16
  %3 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %3, i32 0, i32 1
  %4 = load i32, i32* %base, align 4, !tbaa !258
  %add = add i32 %4, 512
  %or = or i32 %shl, %add
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 %or, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %conv5 = zext i8 %value to i32
  %5 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %5, i32 0, i32 3
  store i32 %conv5, i32* %timeout, align 4, !tbaa !269
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end4
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -22, %entry ], [ -5, %if.end ]
  %6 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_backlight_ng_read_limits(i32 %handle, %struct.sony_backlight_props* %props) #1 {
entry:
  %offset = alloca i64, align 8
  %buffer = alloca [32 x i8], align 16
  %0 = bitcast i64* %offset to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast [32 x i8]* %buffer to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %1) #8
  %2 = bitcast [32 x i8]* %buffer to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 32, i32 16, i1 false)
  %handle1 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !270
  %offset2 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 3
  store i8 0, i8* %offset2, align 8, !tbaa !223
  %maxlvl = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 4
  store i8 -1, i8* %maxlvl, align 1, !tbaa !222
  %call = call i32 @sony_find_snc_handle(i32 %handle)
  %conv = sext i32 %call to i64
  store i64 %conv, i64* %offset, align 8, !tbaa !196
  %3 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i32 0, i32 0
  %call3 = call i32 @sony_nc_buffer_call(i8* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.133, i32 0, i32 0), i64* %offset, i8* %arraydecay, i64 32)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %cleanup, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %handle, 323
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %handle, 331
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %.off = add i32 %handle, -331
  %SwitchLeaf6 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf6, label %sw.epilog, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %handle, 323
  br i1 %SwitchLeaf4, label %sw.epilog, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %handle, 311
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %handle, 311
  br i1 %SwitchLeaf2, label %sw.epilog, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %handle, 303
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock3, %LeafBlock5, %LeafBlock, %LeafBlock1, %NewDefault
  %lvl_table_len.0 = phi i32 [ 0, %NewDefault ], [ 9, %LeafBlock1 ], [ 9, %LeafBlock ], [ 16, %LeafBlock5 ], [ 16, %LeafBlock3 ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %min.0 = phi i8 [ -1, %sw.epilog ], [ %min.1, %for.inc ]
  %i.0 = phi i32 [ 0, %sw.epilog ], [ %inc, %for.inc ]
  %max.0 = phi i8 [ 0, %sw.epilog ], [ %max.1, %for.inc ]
  %cmp6 = icmp slt i32 %i.0, %lvl_table_len.0
  %conv8 = sext i32 %i.0 to i64
  %cmp9 = icmp ult i64 %conv8, 32
  %4 = select i1 %cmp6, i1 %cmp9, i1 false
  br i1 %4, label %do.body, label %for.end

do.body:                                          ; preds = %for.cond
  %5 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1, !tbaa !44
  %conv12 = zext i8 %6 to i32
  %call13 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.145, i32 0, i32 0), i32 %conv12)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %idxprom15 = sext i32 %i.0 to i64
  %arrayidx16 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom15
  %7 = load i8, i8* %arrayidx16, align 1, !tbaa !44
  %tobool17 = icmp ne i8 %7, 0
  br i1 %tobool17, label %if.end19, label %for.end

if.end19:                                         ; preds = %do.end
  %idxprom20 = sext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom20
  %8 = load i8, i8* %arrayidx21, align 1, !tbaa !44
  %conv22 = zext i8 %8 to i32
  %conv23 = zext i8 %max.0 to i32
  %cmp24 = icmp sgt i32 %conv22, %conv23
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end19
  %idxprom27 = sext i32 %i.0 to i64
  %arrayidx28 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom27
  %9 = load i8, i8* %arrayidx28, align 1, !tbaa !44
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end19
  %max.1 = phi i8 [ %9, %if.then26 ], [ %max.0, %if.end19 ]
  %idxprom30 = sext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom30
  %10 = load i8, i8* %arrayidx31, align 1, !tbaa !44
  %conv32 = zext i8 %10 to i32
  %conv33 = zext i8 %min.0 to i32
  %cmp34 = icmp slt i32 %conv32, %conv33
  br i1 %cmp34, label %if.then36, label %for.inc

if.then36:                                        ; preds = %if.end29
  %idxprom37 = sext i32 %i.0 to i64
  %arrayidx38 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom37
  %11 = load i8, i8* %arrayidx38, align 1, !tbaa !44
  br label %for.inc

for.inc:                                          ; preds = %if.end29, %if.then36
  %min.1 = phi i8 [ %11, %if.then36 ], [ %min.0, %if.end29 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %do.end
  %offset40 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 3
  store i8 %min.0, i8* %offset40, align 8, !tbaa !223
  %maxlvl41 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 4
  store i8 %max.0, i8* %maxlvl41, align 1, !tbaa !222
  %12 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool43 = icmp ne i32 %12, 0
  br i1 %tobool43, label %if.then44, label %cleanup

if.then44:                                        ; preds = %for.end
  %offset45 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 3
  %13 = load i8, i8* %offset45, align 8, !tbaa !223
  %conv46 = zext i8 %13 to i32
  %maxlvl47 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 4
  %14 = load i8, i8* %maxlvl47, align 1, !tbaa !222
  %conv48 = zext i8 %14 to i32
  %call49 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.146, i32 0, i32 0), i32 %conv46, i32 %conv48)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then44, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %entry ], [ 0, %if.then44 ], [ 0, %for.end ]
  %15 = bitcast [32 x i8]* %buffer to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %15) #8
  %16 = bitcast i64* %offset to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %16) #8
  ret void
}

declare %struct.backlight_device* @backlight_device_register(i8*, %struct.device*, i8*, %struct.backlight_ops*, %struct.backlight_properties*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_update_status_ng(%struct.backlight_device* %bd) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %call = call i8* @bl_get_data(%struct.backlight_device* %bd)
  %1 = bitcast i8* %call to %struct.sony_backlight_props*
  %props = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %bd, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 0
  %2 = load i32, i32* %brightness, align 8, !tbaa !160
  %offset = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 3
  %3 = load i8, i8* %offset, align 8, !tbaa !223
  %conv = zext i8 %3 to i32
  %add = add nsw i32 %2, %conv
  %handle = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 1
  %4 = load i32, i32* %handle, align 8, !tbaa !270
  %cmd_base = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 2
  %5 = load i32, i32* %cmd_base, align 4, !tbaa !221
  %shl = shl i32 %add, 16
  %or = or i32 %5, %shl
  %call1 = call i32 @sony_call_snc_handle(i32 %4, i32 %or, i32* %result)
  %tobool = icmp ne i32 %call1, 0
  %.add = select i1 %tobool, i32 -5, i32 %add
  %6 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #8
  ret i32 %.add
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_get_brightness_ng(%struct.backlight_device* %bd) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %call = call i8* @bl_get_data(%struct.backlight_device* %bd)
  %1 = bitcast i8* %call to %struct.sony_backlight_props*
  %handle = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !270
  %cmd_base = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 2
  %3 = load i32, i32* %cmd_base, align 4, !tbaa !221
  %add = add nsw i32 %3, 256
  %call1 = call i32 @sony_call_snc_handle(i32 %2, i32 %add, i32* %result)
  %4 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %4, 255
  %offset = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 3
  %5 = load i8, i8* %offset, align 8, !tbaa !223
  %conv = zext i8 %5 to i32
  %sub = sub nsw i32 %and, %conv
  %6 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #8
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @bl_get_data(%struct.backlight_device* %bl_dev) #0 {
entry:
  %dev = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %bl_dev, i32 0, i32 5
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare i8* @dev_get_drvdata(%struct.device*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_backlight_update_status(%struct.backlight_device* %bd) #1 {
entry:
  %arg = alloca i32, align 4
  %0 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %props = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %bd, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 0
  %1 = load i32, i32* %brightness, align 8, !tbaa !160
  %add = add nsw i32 %1, 1
  store i32 %add, i32* %arg, align 4, !tbaa !12
  %2 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call = call i32 @sony_nc_int_call(i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.58, i32 0, i32 0), i32* %arg, i32* null)
  %3 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #8
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @brightness_default_validate(i32 %direction, i32 %value) #1 {
entry:
  %Pivot = icmp slt i32 %direction, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %direction, 1
  %sub = sub nsw i32 %value, 1
  %sub. = select i1 %SwitchLeaf2, i32 %sub, i32 -22
  ret i32 %sub.

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %direction, 0
  br i1 %SwitchLeaf, label %sw.bb1, label %return

sw.bb1:                                           ; preds = %LeafBlock
  %cmp = icmp sge i32 %value, 0
  %cmp2 = icmp slt i32 %value, 8
  %or.cond = and i1 %cmp, %cmp2
  %add = add nsw i32 %value, 1
  %add. = select i1 %or.cond, i32 %add, i32 -22
  br label %return

return:                                           ; preds = %sw.bb1, %LeafBlock
  %retval.0 = phi i32 [ -22, %LeafBlock ], [ %add., %sw.bb1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_sysfs_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast i32* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -48
  %2 = bitcast i8* %add.ptr to %struct.sony_nc_value*
  %acpiget = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 1
  %3 = load i8**, i8*** %acpiget, align 8, !tbaa !209
  %4 = load i8*, i8** %3, align 8, !tbaa !38
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %5 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %acpiget1 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 1
  %6 = load i8**, i8*** %acpiget1, align 8, !tbaa !209
  %7 = load i8*, i8** %6, align 8, !tbaa !38
  %call = call i32 @sony_nc_int_call(i8* %5, i8* %7, i32* null, i32* %value)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %validate = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 3
  %8 = load i32 (i32, i32)*, i32 (i32, i32)** %validate, align 8, !tbaa !271
  %tobool4 = icmp ne i32 (i32, i32)* %8, null
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end3
  %validate6 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 3
  %9 = load i32 (i32, i32)*, i32 (i32, i32)** %validate6, align 8, !tbaa !271
  %10 = load i32, i32* %value, align 4, !tbaa !12
  %call7 = call i32 %9(i32 1, i32 %10)
  store i32 %call7, i32* %value, align 4, !tbaa !12
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end3
  %11 = load i32, i32* %value, align 4, !tbaa !12
  %call9 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %11)
  %conv = sext i32 %call9 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end8
  %retval.0 = phi i64 [ %conv, %if.end8 ], [ -5, %entry ], [ -5, %if.end ]
  %12 = bitcast i32* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_sysfs_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast i32* %value to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -48
  %2 = bitcast i8* %add.ptr to %struct.sony_nc_value*
  %acpiset = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 2
  %3 = load i8**, i8*** %acpiset, align 8, !tbaa !211
  %tobool = icmp ne i8** %3, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %call = call i32 @kstrtoint(i8* %buffer, i32 10, i32* %value)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end2
  %validate = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 3
  %4 = load i32 (i32, i32)*, i32 (i32, i32)** %validate, align 8, !tbaa !271
  %tobool6 = icmp ne i32 (i32, i32)* %4, null
  br i1 %tobool6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end5
  %validate8 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 3
  %5 = load i32 (i32, i32)*, i32 (i32, i32)** %validate8, align 8, !tbaa !271
  %6 = load i32, i32* %value, align 4, !tbaa !12
  %call9 = call i32 %5(i32 0, i32 %6)
  store i32 %call9, i32* %value, align 4, !tbaa !12
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end5
  %7 = load i32, i32* %value, align 4, !tbaa !12
  %cmp11 = icmp slt i32 %7, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  %8 = load i32, i32* %value, align 4, !tbaa !12
  %conv = sext i32 %8 to i64
  br label %cleanup

if.end13:                                         ; preds = %if.end10
  %9 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %acpiset14 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 2
  %10 = load i8**, i8*** %acpiset14, align 8, !tbaa !211
  %11 = load i8*, i8** %10, align 8, !tbaa !38
  %call15 = call i32 @sony_nc_int_call(i8* %9, i8* %11, i32* %value, i32* null)
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end13
  %12 = load i32, i32* %value, align 4, !tbaa !12
  %value20 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 4
  store i32 %12, i32* %value20, align 8, !tbaa !272
  %valid = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 5
  store i32 1, i32* %valid, align 4, !tbaa !273
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %if.end2, %if.end, %entry, %if.end19, %if.then12
  %retval.0 = phi i64 [ %conv, %if.then12 ], [ %count, %if.end19 ], [ -5, %entry ], [ -22, %if.end ], [ -22, %if.end2 ], [ -5, %if.end13 ]
  %13 = bitcast i32* %value to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %13) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @boolean_validate(i32 %direction, i32 %value) #1 {
entry:
  %cmp = icmp ne i32 %direction, 0
  %switch = icmp ult i32 %value, 2
  %or.cond = or i1 %cmp, %switch
  %retval.0 = select i1 %or.cond, i32 %value, i32 -22
  ret i32 %retval.0
}

declare i32 @kstrtoint(i8*, i32, i32*) #2

declare void @backlight_device_unregister(%struct.backlight_device*) #2

; Function Attrs: nounwind uwtable
define internal void @sony_nc_touchpad_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %tobool = icmp ne %struct.touchpad_control* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %attr = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %1, i32 0, i32 0
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %attr)
  %2 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  %3 = bitcast %struct.touchpad_control* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.touchpad_control* null, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_battery_care_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %tobool = icmp ne %struct.battery_care_control* %0, null
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs, i64 0, i64 0
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %arrayidx)
  %2 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %2, i32 0, i32 1
  %3 = load i32, i32* %handle, align 8, !tbaa !234
  %cmp = icmp ne i32 %3, 277
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %dev2 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %4 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %attrs3 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %4, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs3, i64 0, i64 1
  call void @device_remove_file(%struct.device* %dev2, %struct.device_attribute* %arrayidx4)
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %5 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  %6 = bitcast %struct.battery_care_control* %5 to i8*
  call void @kfree(i8* %6)
  store %struct.battery_care_control* null, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !38
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_lid_resume_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %tobool = icmp ne %struct.snc_lid_resume_control* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %attrs = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %1, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs, i64 0, i64 %idxprom
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %arrayidx)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %2 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  %3 = bitcast %struct.snc_lid_resume_control* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.snc_lid_resume_control* null, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !38
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_thermal_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %tobool = icmp ne %struct.snc_thermal_ctrl* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %profiles_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %1, i32 0, i32 3
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %profiles_attr)
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %2 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %2, i32 0, i32 2
  call void @device_remove_file(%struct.device* %dev1, %struct.device_attribute* %mode_attr)
  %3 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %4 = bitcast %struct.snc_thermal_ctrl* %3 to i8*
  call void @kfree(i8* %4)
  store %struct.snc_thermal_ctrl* null, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_gfx_switch_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %tobool = icmp ne %struct.snc_gfx_switch_control* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %attr = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %1, i32 0, i32 0
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %attr)
  %2 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  %3 = bitcast %struct.snc_gfx_switch_control* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.snc_gfx_switch_control* null, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_highspeed_charging_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %tobool = icmp ne %struct.device_attribute* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %1)
  %2 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  %3 = bitcast %struct.device_attribute* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.device_attribute* null, %struct.device_attribute** @hsc_handle, align 8, !tbaa !38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_kbd_backlight_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %result = alloca i32, align 4
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %tobool = icmp ne %struct.kbd_backlight* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %2 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %2, i32 0, i32 4
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %mode_attr)
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %3 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %3, i32 0, i32 5
  call void @device_remove_file(%struct.device* %dev1, %struct.device_attribute* %timeout_attr)
  %4 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %4, i32 0, i32 0
  %5 = load i32, i32* %handle, align 8, !tbaa !256
  %6 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %6, i32 0, i32 1
  %7 = load i32, i32* %base, align 4, !tbaa !258
  %or = or i32 %7, 65536
  %call = call i32 @sony_call_snc_handle(i32 %5, i32 %or, i32* %result)
  %8 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %handle2 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %8, i32 0, i32 0
  %9 = load i32, i32* %handle2, align 8, !tbaa !256
  %10 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %base3 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %10, i32 0, i32 1
  %11 = load i32, i32* %base3, align 4, !tbaa !258
  %add = add i32 %11, 512
  %call4 = call i32 @sony_call_snc_handle(i32 %9, i32 %add, i32* %result)
  %12 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %13 = bitcast %struct.kbd_backlight* %12 to i8*
  call void @kfree(i8* %13)
  store %struct.kbd_backlight* null, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %14 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @rfkill_unregister(%struct.rfkill*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_hotkeys_decode(i32 %event, i32 %handle) #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  store i32 0, i32* %result, align 4, !tbaa !12
  %call = call i32 @sony_call_snc_handle(i32 %handle, i32 512, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %do.body, label %if.end4

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %do.body
  %call3 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.192, i32 0, i32 0), i32 %handle, i32 %event)
  br label %cleanup

if.end4:                                          ; preds = %entry
  %2 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %2, 255
  store i32 %and, i32* %result, align 4, !tbaa !12
  %cmp = icmp eq i32 %handle, 256
  %. = select i1 %cmp, %struct.sony_nc_event* getelementptr inbounds ([41 x %struct.sony_nc_event], [41 x %struct.sony_nc_event]* @sony_100_events, i32 0, i32 0), %struct.sony_nc_event* getelementptr inbounds ([15 x %struct.sony_nc_event], [15 x %struct.sony_nc_event]* @sony_127_events, i32 0, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %key_event.1 = phi %struct.sony_nc_event* [ %., %if.end4 ], [ %incdec.ptr, %for.inc ]
  %data = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 0
  %3 = load i8, i8* %data, align 1, !tbaa !274
  %tobool7 = icmp ne i8 %3, 0
  br i1 %tobool7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %data8 = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 0
  %4 = load i8, i8* %data8, align 1, !tbaa !274
  %conv = zext i8 %4 to i32
  %5 = load i32, i32* %result, align 4, !tbaa !12
  %cmp9 = icmp eq i32 %conv, %5
  br i1 %cmp9, label %if.then11, label %for.inc

if.then11:                                        ; preds = %for.body
  %event12 = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 1
  %6 = load i8, i8* %event12, align 1, !tbaa !276
  %conv13 = zext i8 %6 to i32
  br label %for.end

for.inc:                                          ; preds = %for.body
  %incdec.ptr = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then11
  %ret.0 = phi i32 [ %conv13, %if.then11 ], [ -22, %for.cond ]
  %data15 = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 0
  %7 = load i8, i8* %data15, align 1, !tbaa !274
  %tobool16 = icmp ne i8 %7, 0
  br i1 %tobool16, label %cleanup, label %if.then17

if.then17:                                        ; preds = %for.end
  %8 = load i32, i32* %result, align 4, !tbaa !12
  %call18 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.193, i32 0, i32 0), i32 %event, i32 %8, i32 %handle)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then17, %do.body, %if.then2
  %retval.0 = phi i32 [ -22, %if.then2 ], [ -22, %do.body ], [ %ret.0, %if.then17 ], [ %ret.0, %for.end ]
  %9 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_rfkill_update() #1 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %call = call i32 @sony_call_snc_handle(i32 %1, i32 512, i32* %result)
  %2 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %LeafBlock ]
  %cmp = icmp ult i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @sony_rfkill_address, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %idxprom1 = zext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom1
  %4 = load %struct.rfkill*, %struct.rfkill** %arrayidx2, align 8, !tbaa !38
  %tobool3 = icmp ne %struct.rfkill* %4, null
  br i1 %tobool3, label %if.end, label %LeafBlock

if.end:                                           ; preds = %for.body
  %tobool4 = trunc i8 %frombool to i1
  br i1 %tobool4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end
  %idxprom6 = zext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom6
  %5 = load %struct.rfkill*, %struct.rfkill** %arrayidx7, align 8, !tbaa !38
  %call8 = call zeroext i1 @rfkill_set_hw_state(%struct.rfkill* %5, i1 zeroext true)
  br label %LeafBlock

if.end11:                                         ; preds = %if.end
  %6 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %call12 = call i32 @sony_call_snc_handle(i32 %6, i32 %3, i32* %result)
  %idxprom13 = zext i32 %i.0 to i64
  %arrayidx14 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom13
  %7 = load %struct.rfkill*, %struct.rfkill** %arrayidx14, align 8, !tbaa !38
  %8 = load i32, i32* %result, align 4, !tbaa !12
  %and15 = and i32 %8, 2
  %tobool16 = icmp ne i32 %and15, 0
  %lnot17 = xor i1 %tobool16, true
  call void @rfkill_set_states(%struct.rfkill* %7, i1 zeroext %lnot17, i1 zeroext false)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then5, %if.end11, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 4, %if.then5 ], [ 0, %if.end11 ], [ 4, %for.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 4
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #8
  ret void
}

declare i32 @acpi_bus_generate_netlink_event(i8*, i8*, i8 zeroext, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name(%struct.device* %dev) #0 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !277
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !277
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

declare void @rfkill_set_states(%struct.rfkill*, i1 zeroext, i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name(%struct.kobject* %kobj) #0 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !278
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_resume(%struct.device* %dev) #1 {
entry:
  %handle = alloca i8*, align 8
  %arg = alloca i32, align 4
  %0 = bitcast i8** %handle to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %item.0 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %entry ], [ %incdec.ptr, %for.inc ]
  %name = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %1 = load i8*, i8** %name, align 8, !tbaa !203
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %valid = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 5
  %2 = load i32, i32* %valid, align 4, !tbaa !273
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %if.end, label %NodeBlock

if.end:                                           ; preds = %for.body
  %3 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %acpiset = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %4 = load i8**, i8*** %acpiset, align 8, !tbaa !211
  %5 = load i8*, i8** %4, align 8, !tbaa !38
  %value = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 4
  %call = call i32 @sony_nc_int_call(i8* %3, i8* %5, i32* %value, i32* null)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then2, label %NodeBlock

if.then2:                                         ; preds = %if.end
  %call3 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.194, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.sony_nc_resume, i32 0, i32 0), i32 %call)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.then2, %for.body, %if.end
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then2 ], [ 4, %for.body ], [ 0, %if.end ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 4
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  %or.cond = and i1 %Pivot, %SwitchLeaf
  br i1 %or.cond, label %for.end, label %for.inc

for.inc:                                          ; preds = %NodeBlock
  %incdec.ptr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %NodeBlock, %for.cond
  %6 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call5 = call i32 @acpi_get_handle(i8* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.82, i32 0, i32 0), i8** %handle)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end16, label %if.then7

if.then7:                                         ; preds = %for.end
  %7 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #8
  store i32 1, i32* %arg, align 4, !tbaa !12
  %8 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call8 = call i32 @sony_nc_int_call(i8* %8, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.82, i32 0, i32 0), i32* %arg, i32* null)
  %tobool9 = icmp ne i32 %call8, 0
  %9 = load i32, i32* @debug, align 4
  %tobool11 = icmp ne i32 %9, 0
  %or.cond1 = and i1 %tobool9, %tobool11
  br i1 %or.cond1, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.then7
  %call13 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.83, i32 0, i32 0))
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.then7
  %10 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %10) #8
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %for.end
  %11 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call17 = call i32 @acpi_get_handle(i8* %11, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i8** %handle)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end16
  call void @sony_nc_function_resume()
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %if.end16
  %12 = bitcast i8** %handle to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #8
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_function_resume() #1 {
entry:
  %result = alloca i32, align 4
  %bitmask = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i32* %bitmask to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %2 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #8
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.195, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock37, %do.end
  %i.0 = phi i32 [ 0, %do.end ], [ %inc, %LeafBlock37 ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !38
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %4, i32 0, i32 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %5 = load i16, i16* %arrayidx, align 2, !tbaa !197
  %conv2 = zext i16 %5 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br i1 %tobool3, label %NodeBlock34, label %LeafBlock37

NodeBlock34:                                      ; preds = %for.body
  %Pivot35 = icmp slt i32 %conv2, 309
  br i1 %Pivot35, label %NodeBlock13, label %NodeBlock32

NodeBlock32:                                      ; preds = %NodeBlock34
  %Pivot33 = icmp slt i32 %conv2, 323
  br i1 %Pivot33, label %NodeBlock19, label %NodeBlock30

NodeBlock30:                                      ; preds = %NodeBlock32
  %Pivot31 = icmp slt i32 %conv2, 331
  br i1 %Pivot31, label %LeafBlock21, label %NodeBlock28

NodeBlock28:                                      ; preds = %NodeBlock30
  %Pivot29 = icmp slt i32 %conv2, 355
  br i1 %Pivot29, label %LeafBlock23, label %LeafBlock26

LeafBlock26:                                      ; preds = %NodeBlock28
  %SwitchLeaf27 = icmp eq i32 %conv2, 355
  br i1 %SwitchLeaf27, label %sw.bb11, label %LeafBlock37

LeafBlock23:                                      ; preds = %NodeBlock28
  %.off24 = add i32 %conv2, -331
  %SwitchLeaf25 = icmp ule i32 %.off24, 1
  br i1 %SwitchLeaf25, label %sw.bb11, label %LeafBlock37

LeafBlock21:                                      ; preds = %NodeBlock30
  %SwitchLeaf22 = icmp eq i32 %conv2, 323
  br i1 %SwitchLeaf22, label %sw.bb11, label %LeafBlock37

NodeBlock19:                                      ; preds = %NodeBlock32
  %Pivot20 = icmp slt i32 %conv2, 311
  br i1 %Pivot20, label %LeafBlock15, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %conv2, 311
  br i1 %SwitchLeaf18, label %sw.bb11, label %LeafBlock37

LeafBlock15:                                      ; preds = %NodeBlock19
  %SwitchLeaf16 = icmp eq i32 %conv2, 309
  br i1 %SwitchLeaf16, label %sw.bb10, label %LeafBlock37

NodeBlock13:                                      ; preds = %NodeBlock34
  %Pivot14 = icmp slt i32 %conv2, 290
  br i1 %Pivot14, label %NodeBlock, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %conv2, 292
  br i1 %Pivot12, label %LeafBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %conv2, 295
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv2, 295
  br i1 %SwitchLeaf8, label %sw.bb, label %LeafBlock37

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv2, 292
  br i1 %SwitchLeaf6, label %sw.bb10, label %LeafBlock37

LeafBlock3:                                       ; preds = %NodeBlock11
  %SwitchLeaf4 = icmp eq i32 %conv2, 290
  br i1 %SwitchLeaf4, label %sw.bb9, label %LeafBlock37

NodeBlock:                                        ; preds = %NodeBlock13
  %Pivot = icmp slt i32 %conv2, 258
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv2, 258
  br i1 %SwitchLeaf2, label %sw.bb7, label %LeafBlock37

LeafBlock:                                        ; preds = %NodeBlock
  %.off = add i32 %conv2, -256
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %LeafBlock37

sw.bb:                                            ; preds = %LeafBlock7, %LeafBlock
  %call6 = call i32 @sony_call_snc_handle(i32 %conv2, i32 0, i32* %result)
  br label %LeafBlock37

sw.bb7:                                           ; preds = %LeafBlock1
  %call8 = call i32 @sony_call_snc_handle(i32 %conv2, i32 256, i32* %result)
  br label %LeafBlock37

sw.bb9:                                           ; preds = %LeafBlock3
  call void @sony_nc_thermal_resume()
  br label %LeafBlock37

sw.bb10:                                          ; preds = %LeafBlock15, %LeafBlock5
  call void @sony_nc_rfkill_update()
  br label %LeafBlock37

sw.bb11:                                          ; preds = %LeafBlock26, %LeafBlock23, %LeafBlock21, %LeafBlock17
  call void @sony_nc_kbd_backlight_resume()
  br label %LeafBlock37

LeafBlock37:                                      ; preds = %for.body, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock7, %LeafBlock15, %LeafBlock17, %LeafBlock21, %LeafBlock23, %LeafBlock26, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb7, %sw.bb
  %cleanup.dest.slot.0 = phi i32 [ 6, %for.body ], [ 6, %LeafBlock ], [ 6, %LeafBlock1 ], [ 6, %LeafBlock3 ], [ 6, %LeafBlock5 ], [ 6, %LeafBlock7 ], [ 6, %LeafBlock15 ], [ 6, %LeafBlock17 ], [ 6, %LeafBlock21 ], [ 6, %LeafBlock23 ], [ 6, %LeafBlock26 ], [ 0, %sw.bb11 ], [ 0, %sw.bb10 ], [ 0, %sw.bb9 ], [ 0, %sw.bb7 ], [ 0, %sw.bb ]
  %SwitchLeaf38 = icmp eq i32 %cleanup.dest.slot.0, 6
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 16, i32* %arg, align 4, !tbaa !12
  %6 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call12 = call i32 @sony_nc_int_call(i8* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i32* %arg, i32* %bitmask)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end16, label %if.then14

if.then14:                                        ; preds = %for.end
  %7 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !38
  %call15 = call i32 @sony_nc_int_call(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.103, i32 0, i32 0), i32* %bitmask, i32* %result)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %for.end
  %8 = bitcast i32* %arg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #8
  %9 = bitcast i32* %bitmask to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #8
  %10 = bitcast i32* %result to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %10) #8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_thermal_resume() #1 {
entry:
  %call = call i32 @sony_nc_thermal_mode_get()
  %0 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %0, i32 0, i32 0
  %1 = load i32, i32* %mode, align 8, !tbaa !242
  %cmp = icmp ne i32 %call, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !38
  %mode1 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %2, i32 0, i32 0
  %3 = load i32, i32* %mode1, align 8, !tbaa !242
  %conv = trunc i32 %3 to i16
  %call2 = call i32 @sony_nc_thermal_mode_set(i16 zeroext %conv)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_kbd_backlight_resume() #1 {
entry:
  %ignore = alloca i32, align 4
  %0 = bitcast i32* %ignore to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  store i32 0, i32* %ignore, align 4, !tbaa !12
  %1 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %tobool = icmp ne %struct.kbd_backlight* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %mode = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %2, i32 0, i32 2
  %3 = load i32, i32* %mode, align 8, !tbaa !268
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %4 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %handle = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %4, i32 0, i32 0
  %5 = load i32, i32* %handle, align 8, !tbaa !256
  %6 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %6, i32 0, i32 1
  %7 = load i32, i32* %base, align 4, !tbaa !258
  %call = call i32 @sony_call_snc_handle(i32 %5, i32 %7, i32* %ignore)
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %8 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %8, i32 0, i32 3
  %9 = load i32, i32* %timeout, align 4, !tbaa !269
  %cmp3 = icmp ne i32 %9, 0
  br i1 %cmp3, label %if.then4, label %cleanup

if.then4:                                         ; preds = %if.end2
  %10 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %handle5 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %10, i32 0, i32 0
  %11 = load i32, i32* %handle5, align 8, !tbaa !256
  %12 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %base6 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %12, i32 0, i32 1
  %13 = load i32, i32* %base6, align 4, !tbaa !258
  %add = add i32 %13, 512
  %14 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !38
  %timeout7 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %14, i32 0, i32 3
  %15 = load i32, i32* %timeout7, align 4, !tbaa !269
  %shl = shl i32 %15, 16
  %or = or i32 %add, %shl
  %call8 = call i32 @sony_call_snc_handle(i32 %11, i32 %or, i32* %ignore)
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.then4, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %entry ], [ 0, %if.then4 ], [ 0, %if.end2 ]
  %16 = bitcast i32* %ignore to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %16) #8
  ret void
}

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readnone }
attributes #7 = { nounwind readnone speculatable }
attributes #8 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !13, i64 0}
!13 = !{!"int", !5, i64 0}
!14 = !{!15, !5, i64 246}
!15 = !{!"sony_pic_dev", !4, i64 0, !4, i64 8, !4, i64 16, !16, i64 24, !16, i64 40, !17, i64 56, !4, i64 224, !4, i64 232, !13, i64 240, !22, i64 244, !5, i64 246, !5, i64 247, !5, i64 248}
!16 = !{!"list_head", !4, i64 0, !4, i64 8}
!17 = !{!"mutex", !18, i64 0, !19, i64 8, !16, i64 80, !4, i64 96, !4, i64 104, !4, i64 112, !20, i64 120}
!18 = !{!"", !13, i64 0}
!19 = !{!"spinlock", !5, i64 0}
!20 = !{!"lockdep_map", !4, i64 0, !5, i64 8, !4, i64 24, !13, i64 32, !21, i64 40}
!21 = !{!"long", !5, i64 0}
!22 = !{!"short", !5, i64 0}
!23 = !{!15, !4, i64 16}
!24 = !{!25, !22, i64 3}
!25 = !{!"sony_pic_ioport", !26, i64 0, !26, i64 7, !16, i64 16}
!26 = !{!"acpi_resource_io", !5, i64 0, !5, i64 1, !5, i64 2, !22, i64 3, !22, i64 5}
!27 = !{!28, !4, i64 0}
!28 = !{!"pv_irq_ops", !29, i64 0, !29, i64 8, !29, i64 16, !29, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!29 = !{!"paravirt_callee_save", !4, i64 0}
!30 = !{i32 -2146180388, i32 -2146180363, i32 -2146180093, i32 -2146180296, i32 -2146180265, i32 -2146180235}
!31 = !{i32 -2146180808, i32 -2146178830, i32 -2146178808, i32 -2146178795, i32 -2146178472, i32 -2146178405, i32 -2146178703, i32 -2146178676, i32 -2146178648, i32 -2146178618}
!32 = !{i32 -2146649451}
!33 = !{i32 -2145463055}
!34 = !{i32 -2145462853}
!35 = !{!36, !4, i64 208}
!36 = !{!"pv_cpu_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184, !4, i64 192, !4, i64 200, !4, i64 208, !4, i64 216, !4, i64 224, !4, i64 232, !4, i64 240, !4, i64 248, !4, i64 256, !4, i64 264, !4, i64 272, !4, i64 280, !4, i64 288, !4, i64 296, !4, i64 304, !4, i64 312}
!37 = !{!15, !4, i64 0}
!38 = !{!4, !4, i64 0}
!39 = !{!25, !5, i64 2}
!40 = !{!25, !22, i64 5}
!41 = !{!25, !22, i64 10}
!42 = !{!25, !5, i64 9}
!43 = !{!25, !22, i64 12}
!44 = !{!5, !5, i64 0}
!45 = !{!46, !5, i64 1}
!46 = !{!"sony_pic_irq", !47, i64 0, !16, i64 8}
!47 = !{!"acpi_resource_irq", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6}
!48 = !{!46, !5, i64 2}
!49 = !{!46, !5, i64 3}
!50 = !{!15, !4, i64 8}
!51 = !{!15, !5, i64 247}
!52 = !{!16, !4, i64 0}
!53 = !{!25, !4, i64 16}
!54 = !{!46, !4, i64 8}
!55 = !{!15, !13, i64 240}
!56 = !{!15, !4, i64 232}
!57 = !{!15, !22, i64 244}
!58 = !{!15, !4, i64 224}
!59 = !{!60, !4, i64 8}
!60 = !{!"acpi_device", !13, i64 0, !4, i64 8, !4, i64 16, !16, i64 24, !16, i64 40, !16, i64 56, !61, i64 72, !62, i64 76, !63, i64 80, !65, i64 208, !67, i64 376, !70, i64 424, !72, i64 448, !4, i64 456, !4, i64 464, !4, i64 472, !73, i64 480, !5, i64 1616, !5, i64 1620, !16, i64 1624, !17, i64 1640, !5, i64 1808, !16, i64 1816, !4, i64 1832}
!61 = !{!"acpi_device_status", !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0}
!62 = !{!"acpi_device_flags", !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 1}
!63 = !{!"acpi_device_pnp", !5, i64 0, !64, i64 8, !21, i64 16, !4, i64 24, !16, i64 32, !5, i64 48, !5, i64 88, !4, i64 112, !21, i64 120}
!64 = !{!"acpi_pnp_type", !13, i64 0, !13, i64 0, !13, i64 0}
!65 = !{!"acpi_device_power", !13, i64 0, !66, i64 4, !5, i64 8}
!66 = !{!"acpi_device_power_flags", !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0}
!67 = !{!"acpi_device_wakeup", !4, i64 0, !68, i64 8, !68, i64 16, !16, i64 24, !69, i64 40, !13, i64 44}
!68 = !{!"long long", !5, i64 0}
!69 = !{!"acpi_device_wakeup_flags", !5, i64 0, !5, i64 0, !5, i64 0}
!70 = !{!"acpi_device_perf", !13, i64 0, !71, i64 4, !13, i64 8, !4, i64 16}
!71 = !{!"acpi_device_perf_flags", !5, i64 0}
!72 = !{!"acpi_device_dir", !4, i64 0}
!73 = !{!"device", !4, i64 0, !4, i64 8, !74, i64 16, !4, i64 80, !4, i64 88, !17, i64 96, !4, i64 264, !4, i64 272, !4, i64 280, !76, i64 288, !4, i64 880, !13, i64 888, !4, i64 896, !68, i64 904, !4, i64 912, !16, i64 920, !4, i64 936, !84, i64 944, !4, i64 960, !85, i64 968, !13, i64 976, !13, i64 980, !19, i64 984, !16, i64 1056, !86, i64 1072, !4, i64 1104, !4, i64 1112, !4, i64 1120, !4, i64 1128}
!74 = !{!"kobject", !4, i64 0, !16, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !75, i64 56, !13, i64 60, !13, i64 60, !13, i64 60, !13, i64 60, !13, i64 60}
!75 = !{!"kref", !18, i64 0}
!76 = !{!"dev_pm_info", !77, i64 0, !13, i64 4, !13, i64 4, !78, i64 4, !78, i64 4, !78, i64 4, !78, i64 4, !19, i64 8, !16, i64 80, !79, i64 96, !4, i64 192, !78, i64 200, !78, i64 200, !81, i64 208, !21, i64 336, !82, i64 344, !80, i64 424, !18, i64 512, !18, i64 516, !13, i64 520, !13, i64 520, !13, i64 520, !13, i64 520, !13, i64 520, !13, i64 520, !13, i64 521, !13, i64 521, !13, i64 521, !13, i64 521, !13, i64 521, !5, i64 524, !5, i64 528, !13, i64 532, !13, i64 536, !21, i64 544, !21, i64 552, !21, i64 560, !21, i64 568, !4, i64 576, !4, i64 584}
!77 = !{!"pm_message", !13, i64 0}
!78 = !{!"_Bool", !5, i64 0}
!79 = !{!"completion", !13, i64 0, !80, i64 8}
!80 = !{!"__wait_queue_head", !19, i64 0, !16, i64 72}
!81 = !{!"timer_list", !16, i64 0, !21, i64 16, !4, i64 24, !4, i64 32, !21, i64 40, !13, i64 48, !13, i64 52, !4, i64 56, !5, i64 64, !20, i64 80}
!82 = !{!"work_struct", !83, i64 0, !16, i64 8, !4, i64 24, !20, i64 32}
!83 = !{!"", !21, i64 0}
!84 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!85 = !{!"acpi_dev_node", !4, i64 0}
!86 = !{!"klist_node", !4, i64 0, !16, i64 8, !75, i64 24}
!87 = !{!81, !4, i64 32}
!88 = !{!81, !21, i64 40}
!89 = !{!90, !4, i64 0}
!90 = !{!"input_dev", !4, i64 0, !4, i64 8, !4, i64 16, !91, i64 24, !5, i64 32, !5, i64 40, !5, i64 48, !5, i64 144, !5, i64 152, !5, i64 160, !5, i64 168, !5, i64 176, !5, i64 184, !5, i64 200, !13, i64 208, !13, i64 212, !13, i64 216, !4, i64 224, !4, i64 232, !4, i64 240, !4, i64 248, !13, i64 256, !81, i64 264, !5, i64 392, !4, i64 400, !4, i64 408, !5, i64 416, !5, i64 512, !5, i64 520, !5, i64 528, !4, i64 536, !4, i64 544, !4, i64 552, !4, i64 560, !4, i64 568, !19, i64 576, !17, i64 648, !13, i64 816, !78, i64 820, !73, i64 824, !16, i64 1960, !16, i64 1976, !13, i64 1992, !13, i64 1996, !4, i64 2000, !78, i64 2008}
!91 = !{!"input_id", !22, i64 0, !22, i64 2, !22, i64 4, !22, i64 6}
!92 = !{!90, !22, i64 24}
!93 = !{!90, !22, i64 26}
!94 = !{!90, !4, i64 824}
!95 = !{!90, !13, i64 216}
!96 = !{!90, !13, i64 212}
!97 = !{!90, !4, i64 224}
!98 = !{!99, !4, i64 16}
!99 = !{!"sony_laptop_input_s", !18, i64 0, !4, i64 8, !4, i64 16, !100, i64 24, !19, i64 48, !81, i64 120}
!100 = !{!"kfifo", !5, i64 0, !5, i64 24}
!101 = !{!99, !4, i64 8}
!102 = !{!103, !13, i64 0}
!103 = !{!"miscdevice", !13, i64 0, !4, i64 8, !4, i64 16, !16, i64 24, !4, i64 40, !4, i64 48, !4, i64 56, !22, i64 64}
!104 = !{!105, !21, i64 8}
!105 = !{!"sonypi_eventtypes", !5, i64 0, !21, i64 8, !4, i64 16}
!106 = !{!105, !5, i64 0}
!107 = !{!21, !21, i64 0}
!108 = !{!105, !4, i64 16}
!109 = !{!110, !5, i64 1}
!110 = !{!"sonypi_event", !5, i64 0, !5, i64 1}
!111 = !{!110, !5, i64 0}
!112 = !{!113, !68, i64 0}
!113 = !{!"acpi_buffer", !68, i64 0, !4, i64 8}
!114 = !{!113, !4, i64 8}
!115 = !{!116, !13, i64 0}
!116 = !{!"", !117, i64 0, !117, i64 68, !117, i64 136, !117, i64 204}
!117 = !{!"acpi_resource", !13, i64 0, !13, i64 4, !5, i64 8}
!118 = !{!116, !13, i64 4}
!119 = !{!116, !13, i64 68}
!120 = !{!116, !13, i64 72}
!121 = !{!116, !13, i64 136}
!122 = !{!116, !13, i64 140}
!123 = !{!116, !13, i64 204}
!124 = !{!125, !4, i64 0}
!125 = !{!"sony_laptop_keypress", !4, i64 0, !13, i64 8}
!126 = !{!125, !13, i64 8}
!127 = !{!117, !13, i64 0}
!128 = !{!47, !5, i64 5}
!129 = !{!47, !5, i64 1}
!130 = !{!47, !5, i64 2}
!131 = !{!47, !5, i64 3}
!132 = !{!46, !5, i64 5}
!133 = !{i32 -2146106807, i32 -2146106768, i32 -2146106747, i32 -2146106710, i32 -2146106687, i32 -2146106678}
!134 = !{i32 427566}
!135 = !{i32 428746}
!136 = !{i32 -2146109230, i32 -2146109191, i32 -2146109170, i32 -2146109133, i32 -2146109110, i32 -2146109240}
!137 = !{!138, !13, i64 136}
!138 = !{!"file", !5, i64 0, !139, i64 16, !4, i64 32, !4, i64 40, !19, i64 48, !13, i64 120, !83, i64 128, !13, i64 136, !13, i64 140, !68, i64 144, !140, i64 152, !4, i64 248, !142, i64 256, !68, i64 288, !4, i64 296, !4, i64 304, !16, i64 312, !16, i64 328, !4, i64 344, !21, i64 352}
!139 = !{!"path", !4, i64 0, !4, i64 8}
!140 = !{!"fown_struct", !141, i64 0, !4, i64 72, !5, i64 80, !13, i64 84, !13, i64 88, !13, i64 92}
!141 = !{!"", !5, i64 0, !13, i64 8, !13, i64 12, !4, i64 16, !20, i64 24}
!142 = !{!"file_ra_state", !21, i64 0, !13, i64 8, !13, i64 12, !13, i64 16, !13, i64 20, !68, i64 24}
!143 = !{!144, !13, i64 0}
!144 = !{!"__wait_queue", !13, i64 0, !4, i64 8, !4, i64 16, !16, i64 24}
!145 = !{!144, !4, i64 8}
!146 = !{!144, !4, i64 16}
!147 = !{!16, !4, i64 8}
!148 = !{i32 -2143016959}
!149 = !{!150, !4, i64 40}
!150 = !{!"inode", !22, i64 0, !22, i64 2, !13, i64 4, !13, i64 8, !13, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !21, i64 64, !5, i64 72, !13, i64 76, !68, i64 80, !151, i64 88, !151, i64 104, !151, i64 120, !19, i64 136, !22, i64 208, !13, i64 212, !21, i64 216, !21, i64 224, !17, i64 232, !21, i64 400, !152, i64 408, !16, i64 424, !16, i64 440, !16, i64 456, !5, i64 472, !68, i64 488, !18, i64 496, !18, i64 500, !18, i64 504, !4, i64 512, !4, i64 520, !153, i64 528, !5, i64 960, !16, i64 976, !5, i64 992, !13, i64 1000, !13, i64 1004, !156, i64 1008, !18, i64 1016, !4, i64 1024}
!151 = !{!"timespec", !21, i64 0, !21, i64 8}
!152 = !{!"hlist_node", !4, i64 0, !4, i64 8}
!153 = !{!"address_space", !4, i64 0, !154, i64 8, !19, i64 24, !13, i64 96, !155, i64 104, !16, i64 112, !17, i64 128, !21, i64 296, !21, i64 304, !4, i64 312, !21, i64 320, !4, i64 328, !19, i64 336, !16, i64 408, !4, i64 424}
!154 = !{!"radix_tree_root", !13, i64 0, !13, i64 4, !4, i64 8}
!155 = !{!"rb_root", !4, i64 0}
!156 = !{!"hlist_head", !4, i64 0}
!157 = !{i64 0, i64 8, !107, i64 8, i64 8, !107}
!158 = !{!159, !4, i64 0}
!159 = !{!"sony_backlight_props", !4, i64 0, !13, i64 8, !13, i64 12, !5, i64 16, !5, i64 17}
!160 = !{!161, !13, i64 0}
!161 = !{!"backlight_device", !162, i64 0, !17, i64 24, !17, i64 192, !4, i64 360, !163, i64 368, !73, i64 392}
!162 = !{!"backlight_properties", !13, i64 0, !13, i64 4, !13, i64 8, !13, i64 12, !5, i64 16, !13, i64 20}
!163 = !{!"notifier_block", !4, i64 0, !4, i64 8, !13, i64 16}
!164 = !{!138, !4, i64 32}
!165 = !{!166, !4, i64 8}
!166 = !{!"task_struct", !21, i64 0, !4, i64 8, !18, i64 16, !13, i64 20, !13, i64 24, !167, i64 32, !13, i64 40, !13, i64 44, !13, i64 48, !13, i64 52, !13, i64 56, !13, i64 60, !4, i64 64, !168, i64 72, !173, i64 448, !4, i64 520, !156, i64 528, !5, i64 536, !13, i64 540, !13, i64 544, !13, i64 548, !174, i64 552, !175, i64 1064, !16, i64 1096, !176, i64 1112, !4, i64 1152, !4, i64 1160, !13, i64 1168, !13, i64 1172, !13, i64 1176, !13, i64 1180, !13, i64 1184, !13, i64 1188, !13, i64 1192, !13, i64 1196, !13, i64 1196, !13, i64 1196, !13, i64 1196, !13, i64 1196, !13, i64 1196, !13, i64 1200, !13, i64 1204, !21, i64 1208, !4, i64 1216, !4, i64 1224, !16, i64 1232, !16, i64 1248, !4, i64 1264, !16, i64 1272, !16, i64 1288, !5, i64 1304, !16, i64 1376, !4, i64 1392, !4, i64 1400, !4, i64 1408, !21, i64 1416, !21, i64 1424, !21, i64 1432, !21, i64 1440, !21, i64 1448, !177, i64 1456, !21, i64 1472, !21, i64 1480, !151, i64 1488, !151, i64 1504, !21, i64 1520, !21, i64 1528, !178, i64 1536, !5, i64 1560, !4, i64 1608, !4, i64 1616, !5, i64 1624, !13, i64 1640, !13, i64 1644, !179, i64 1648, !21, i64 1656, !180, i64 1664, !4, i64 1848, !4, i64 1856, !4, i64 1864, !4, i64 1872, !4, i64 1880, !182, i64 1888, !182, i64 1896, !182, i64 1904, !183, i64 1912, !21, i64 1936, !21, i64 1944, !4, i64 1952, !4, i64 1960, !4, i64 1968, !4, i64 1976, !4, i64 1984, !13, i64 1992, !13, i64 1996, !184, i64 2000, !13, i64 2016, !13, i64 2020, !19, i64 2024, !185, i64 2096, !187, i64 2168, !4, i64 2184, !4, i64 2192, !13, i64 2200, !21, i64 2208, !21, i64 2216, !13, i64 2224, !13, i64 2228, !13, i64 2232, !13, i64 2236, !21, i64 2240, !21, i64 2248, !13, i64 2256, !13, i64 2260, !13, i64 2264, !13, i64 2268, !68, i64 2272, !13, i64 2280, !13, i64 2284, !5, i64 2288, !13, i64 4976, !4, i64 4984, !4, i64 4992, !4, i64 5000, !4, i64 5008, !4, i64 5016, !4, i64 5024, !21, i64 5032, !4, i64 5040, !188, i64 5048, !68, i64 5104, !68, i64 5112, !21, i64 5120, !182, i64 5128, !189, i64 5256, !13, i64 5260, !13, i64 5264, !4, i64 5272, !16, i64 5280, !4, i64 5296, !4, i64 5304, !16, i64 5312, !4, i64 5328, !5, i64 5336, !17, i64 5352, !16, i64 5520, !4, i64 5536, !22, i64 5544, !22, i64 5546, !13, i64 5548, !13, i64 5552, !13, i64 5556, !68, i64 5560, !190, i64 5568, !190, i64 5584, !4, i64 5600, !191, i64 5608, !4, i64 5624, !13, i64 5632, !13, i64 5636, !13, i64 5640, !21, i64 5648, !13, i64 5656, !5, i64 5664, !21, i64 9504, !21, i64 9512, !13, i64 9520, !4, i64 9528, !68, i64 9536, !18, i64 9544, !18, i64 9548, !21, i64 9552, !21, i64 9560, !192, i64 9568, !13, i64 9600, !18, i64 9604, !4, i64 9608, !13, i64 9616, !13, i64 9620}
!167 = !{!"llist_node", !4, i64 0}
!168 = !{!"sched_entity", !169, i64 0, !170, i64 16, !16, i64 40, !13, i64 56, !68, i64 64, !68, i64 72, !68, i64 80, !68, i64 88, !68, i64 96, !171, i64 104, !4, i64 320, !4, i64 328, !4, i64 336, !172, i64 344}
!169 = !{!"load_weight", !21, i64 0, !21, i64 8}
!170 = !{!"rb_node", !21, i64 0, !4, i64 8, !4, i64 16}
!171 = !{!"sched_statistics", !68, i64 0, !68, i64 8, !68, i64 16, !68, i64 24, !68, i64 32, !68, i64 40, !68, i64 48, !68, i64 56, !68, i64 64, !68, i64 72, !68, i64 80, !68, i64 88, !68, i64 96, !68, i64 104, !68, i64 112, !68, i64 120, !68, i64 128, !68, i64 136, !68, i64 144, !68, i64 152, !68, i64 160, !68, i64 168, !68, i64 176, !68, i64 184, !68, i64 192, !68, i64 200, !68, i64 208}
!172 = !{!"sched_avg", !13, i64 0, !13, i64 4, !68, i64 8, !68, i64 16, !21, i64 24}
!173 = !{!"sched_rt_entity", !16, i64 0, !21, i64 16, !21, i64 24, !13, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64}
!174 = !{!"cpumask", !5, i64 0}
!175 = !{!"sched_info", !21, i64 0, !68, i64 8, !68, i64 16, !68, i64 24}
!176 = !{!"plist_node", !13, i64 0, !16, i64 8, !16, i64 24}
!177 = !{!"cputime", !21, i64 0, !21, i64 8}
!178 = !{!"task_cputime", !21, i64 0, !21, i64 8, !68, i64 16}
!179 = !{!"sysv_sem", !4, i64 0}
!180 = !{!"thread_struct", !5, i64 0, !21, i64 24, !21, i64 32, !21, i64 40, !22, i64 48, !22, i64 50, !22, i64 52, !22, i64 54, !21, i64 56, !21, i64 64, !5, i64 72, !21, i64 104, !21, i64 112, !21, i64 120, !21, i64 128, !21, i64 136, !181, i64 144, !4, i64 160, !21, i64 168, !13, i64 176}
!181 = !{!"fpu", !13, i64 0, !13, i64 4, !4, i64 8}
!182 = !{!"", !5, i64 0}
!183 = !{!"sigpending", !16, i64 0, !182, i64 16}
!184 = !{!"seccomp", !13, i64 0, !4, i64 8}
!185 = !{!"raw_spinlock", !186, i64 0, !13, i64 4, !13, i64 8, !4, i64 16, !20, i64 24}
!186 = !{!"arch_spinlock", !5, i64 0}
!187 = !{!"plist_head", !16, i64 0}
!188 = !{!"task_io_accounting", !68, i64 0, !68, i64 8, !68, i64 16, !68, i64 24, !68, i64 32, !68, i64 40, !68, i64 48}
!189 = !{!"seqcount", !13, i64 0}
!190 = !{!"callback_head", !4, i64 0, !4, i64 8}
!191 = !{!"page_frag", !4, i64 0, !13, i64 8, !13, i64 12}
!192 = !{!"memcg_batch_info", !13, i64 0, !4, i64 8, !21, i64 16, !21, i64 24}
!193 = !{i32 434035, i32 434046}
!194 = !{!195, !4, i64 0}
!195 = !{!"poll_table_struct", !4, i64 0, !21, i64 8}
!196 = !{!68, !68, i64 0}
!197 = !{!22, !22, i64 0}
!198 = !{!199, !13, i64 0}
!199 = !{!"acpi_object_list", !13, i64 0, !4, i64 8}
!200 = !{!199, !4, i64 8}
!201 = !{!15, !5, i64 248}
!202 = !{i32 -2146109018, i32 -2146108979, i32 -2146108958, i32 -2146108921, i32 -2146108898, i32 -2146109028}
!203 = !{!204, !4, i64 0}
!204 = !{!"sony_nc_value", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !13, i64 32, !13, i64 36, !13, i64 40, !205, i64 48}
!205 = !{!"device_attribute", !206, i64 0, !4, i64 32, !4, i64 40}
!206 = !{!"attribute", !4, i64 0, !22, i64 8, !78, i64 10, !4, i64 16, !207, i64 24}
!207 = !{!"lock_class_key", !5, i64 0}
!208 = !{!204, !13, i64 40}
!209 = !{!204, !4, i64 8}
!210 = !{!204, !22, i64 56}
!211 = !{!204, !4, i64 16}
!212 = !{!213, !5, i64 12}
!213 = !{!"acpi_device_info", !13, i64 0, !13, i64 4, !13, i64 8, !5, i64 12, !5, i64 13, !5, i64 14, !5, i64 15, !5, i64 19, !13, i64 24, !68, i64 32, !214, i64 40, !214, i64 56, !214, i64 72, !215, i64 88}
!214 = !{!"acpi_pnp_device_id", !13, i64 0, !4, i64 8}
!215 = !{!"acpi_pnp_device_id_list", !13, i64 0, !13, i64 4, !5, i64 8}
!216 = !{!206, !4, i64 16}
!217 = !{!218, !4, i64 32}
!218 = !{!"sony_nc_handles", !5, i64 0, !205, i64 32}
!219 = !{!218, !22, i64 40}
!220 = !{!218, !4, i64 64}
!221 = !{!159, !13, i64 12}
!222 = !{!159, !5, i64 17}
!223 = !{!159, !5, i64 16}
!224 = !{!162, !5, i64 16}
!225 = !{!162, !13, i64 4}
!226 = !{!227, !4, i64 16}
!227 = !{!"backlight_ops", !13, i64 0, !4, i64 8, !4, i64 16, !4, i64 24}
!228 = !{!229, !13, i64 48}
!229 = !{!"touchpad_control", !205, i64 0, !13, i64 48}
!230 = !{!229, !4, i64 0}
!231 = !{!229, !22, i64 8}
!232 = !{!229, !4, i64 32}
!233 = !{!229, !4, i64 40}
!234 = !{!235, !13, i64 96}
!235 = !{!"battery_care_control", !5, i64 0, !13, i64 96}
!236 = !{!205, !4, i64 0}
!237 = !{!205, !22, i64 8}
!238 = !{!205, !4, i64 32}
!239 = !{!205, !4, i64 40}
!240 = !{!241, !13, i64 144}
!241 = !{!"snc_lid_resume_control", !5, i64 0, !13, i64 144}
!242 = !{!243, !13, i64 0}
!243 = !{!"snc_thermal_ctrl", !13, i64 0, !13, i64 4, !205, i64 8, !205, i64 56}
!244 = !{!243, !4, i64 56}
!245 = !{!243, !22, i64 64}
!246 = !{!243, !4, i64 88}
!247 = !{!243, !4, i64 8}
!248 = !{!243, !22, i64 16}
!249 = !{!243, !4, i64 40}
!250 = !{!243, !4, i64 48}
!251 = !{!252, !13, i64 48}
!252 = !{!"snc_gfx_switch_control", !205, i64 0, !13, i64 48}
!253 = !{!252, !4, i64 0}
!254 = !{!252, !22, i64 8}
!255 = !{!252, !4, i64 32}
!256 = !{!257, !13, i64 0}
!257 = !{!"kbd_backlight", !13, i64 0, !13, i64 4, !13, i64 8, !13, i64 12, !205, i64 16, !205, i64 64}
!258 = !{!257, !13, i64 4}
!259 = !{!257, !4, i64 16}
!260 = !{!257, !22, i64 24}
!261 = !{!257, !4, i64 48}
!262 = !{!257, !4, i64 56}
!263 = !{!257, !4, i64 64}
!264 = !{!257, !22, i64 72}
!265 = !{!257, !4, i64 96}
!266 = !{!257, !4, i64 104}
!267 = !{!243, !13, i64 4}
!268 = !{!257, !13, i64 8}
!269 = !{!257, !13, i64 12}
!270 = !{!159, !13, i64 8}
!271 = !{!204, !4, i64 24}
!272 = !{!204, !13, i64 32}
!273 = !{!204, !13, i64 36}
!274 = !{!275, !5, i64 0}
!275 = !{!"sony_nc_event", !5, i64 0, !5, i64 1}
!276 = !{!275, !5, i64 1}
!277 = !{!73, !4, i64 80}
!278 = !{!74, !4, i64 0}
