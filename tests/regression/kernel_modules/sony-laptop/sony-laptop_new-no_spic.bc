; ModuleID = 'tests/regression/kernel_modules/sony-laptop/sony-laptop_new-no_spic.bc'
source_filename = "drivers/platform/x86/sony-laptop.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm "\09.section \22___kcrctab+sony_pic_camera_command\22, \22a\22\09"
module asm "\09.weak\09__crc_sony_pic_camera_command\09"
module asm "\09.long\09__crc_sony_pic_camera_command\09"
module asm "\09.previous\09\09\09\09\09"

%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.49, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.5, i32 }
%union.anon.5 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.32, %union.anon.33, %union.anon.37, %union.anon.41, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%union.anon.32 = type { i64 }
%union.anon.33 = type { i64 }
%union.anon.37 = type { %struct.list_head }
%union.anon.41 = type { i64 }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct*, %struct.lockdep_map }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.7, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon.7 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.12 }
%union.anon.12 = type { %struct.anon.16, [80 x i8] }
%struct.anon.16 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.22, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.22 = type { %struct.anon.23 }
%struct.anon.23 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.anon.29 }
%struct.anon.29 = type { i64, i64 }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.49 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.42, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.43, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.kgid_t = type { i32 }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.42 = type { i32 }
%struct.timespec = type { i64, i64 }
%struct.bdi_writeback = type opaque
%union.anon.43 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%union.anon.0 = type { %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.53, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.53 = type { i64 }
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, i64, %struct.atomic64_t, %struct.key*, %struct.key*, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %struct.pmd_t*, %struct.pud_t*, %struct.pte_t, %struct.page*, %struct.mem_cgroup*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%struct.pte_t = type { i64 }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head, i8*, %struct.lockdep_map }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.51 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.sony_pic_dev = type { %struct.acpi_device*, %struct.sony_pic_irq*, %struct.sony_pic_ioport*, %struct.list_head, %struct.list_head, %struct.mutex, %struct.sonypi_eventtypes*, i32 (i8, i8)*, i32, i16, i8, i8, i8 }
%struct.acpi_device = type { i32, i8*, %struct.fwnode_handle, %struct.acpi_device*, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.acpi_device_status, %struct.acpi_device_flags, %struct.acpi_device_pnp, %struct.acpi_device_power, %struct.acpi_device_wakeup, %struct.acpi_device_perf, %struct.acpi_device_dir, %struct.acpi_device_data, %struct.acpi_scan_handler*, %struct.acpi_hotplug_context*, %struct.acpi_driver*, %struct.acpi_gpio_mapping*, i8*, %struct.device, i32, i32, %struct.list_head, %struct.mutex, void (%struct.acpi_device*)* }
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.acpi_device_status = type { i32 }
%struct.acpi_device_flags = type { i32 }
%struct.acpi_device_pnp = type { [8 x i8], %struct.acpi_pnp_type, i64, i8*, %struct.list_head, [40 x i8], [20 x i8], %union.acpi_object* }
%struct.acpi_pnp_type = type { i32 }
%union.acpi_object = type { %struct.anon.63 }
%struct.anon.63 = type { i32, i32, i64, i32 }
%struct.acpi_device_power = type { i32, %struct.acpi_device_power_flags, [5 x %struct.acpi_device_power_state] }
%struct.acpi_device_power_flags = type { i32 }
%struct.acpi_device_power_state = type { %struct.anon.65, i32, i32, %struct.list_head }
%struct.anon.65 = type { i8 }
%struct.acpi_device_wakeup = type { i8*, i64, i64, %struct.list_head, %struct.acpi_device_wakeup_flags, %struct.acpi_device_wakeup_context, %struct.wakeup_source*, i32 }
%struct.acpi_device_wakeup_flags = type { i8 }
%struct.acpi_device_wakeup_context = type { %struct.work_struct, %struct.device* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.acpi_device_perf = type { i32, %struct.acpi_device_perf_flags, i32, %struct.acpi_device_perf_state* }
%struct.acpi_device_perf_flags = type { i8 }
%struct.acpi_device_perf_state = type { %struct.anon.66, i8, i8, i32 }
%struct.anon.66 = type { i8 }
%struct.acpi_device_dir = type { %struct.proc_dir_entry* }
%struct.proc_dir_entry = type opaque
%struct.acpi_device_data = type { %union.acpi_object*, %union.acpi_object*, %union.acpi_object*, %struct.list_head }
%struct.acpi_scan_handler = type { %struct.acpi_device_id*, %struct.list_head, i1 (i8*, %struct.acpi_device_id**)*, i32 (%struct.acpi_device*, %struct.acpi_device_id*)*, void (%struct.acpi_device*)*, void (%struct.device*)*, void (%struct.device*)*, %struct.acpi_hotplug_profile }
%struct.acpi_hotplug_profile = type { %struct.kobject, i32 (%struct.acpi_device*)*, void (%struct.acpi_device*)*, i8 }
%struct.acpi_hotplug_context = type { %struct.acpi_device*, i32 (%struct.acpi_device*, i32)*, void (%struct.acpi_device*, i32)*, void (%struct.acpi_device*)* }
%struct.acpi_driver = type { [80 x i8], [80 x i8], %struct.acpi_device_id*, i32, %struct.acpi_device_ops, %struct.device_driver, %struct.module* }
%struct.acpi_device_ops = type { i32 (%struct.acpi_device*)*, i32 (%struct.acpi_device*)*, void (%struct.acpi_device*, i32)* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.driver_private = type opaque
%struct.acpi_gpio_mapping = type { i8*, %struct.acpi_gpio_params*, i32 }
%struct.acpi_gpio_params = type { i32, i32, i8 }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type { %struct.list_head, i8*, %struct.irq_domain_ops*, i8*, i32, %struct.fwnode_handle*, i32, %struct.irq_domain_chip_generic*, %struct.irq_domain*, i64, i32, i32, %struct.radix_tree_root, [0 x i32] }
%struct.irq_domain_ops = type { i32 (%struct.irq_domain*, %struct.device_node*, i32)*, i32 (%struct.irq_domain*, %struct.irq_fwspec*, i32)*, i32 (%struct.irq_domain*, i32, i64)*, void (%struct.irq_domain*, i32)*, i32 (%struct.irq_domain*, %struct.device_node*, i32*, i32, i64*, i32*)*, i32 (%struct.irq_domain*, i32, i32, i8*)*, void (%struct.irq_domain*, i32, i32)*, void (%struct.irq_domain*, %struct.irq_data*)*, void (%struct.irq_domain*, %struct.irq_data*)*, i32 (%struct.irq_domain*, %struct.irq_fwspec*, i64*, i32*)* }
%struct.irq_fwspec = type { %struct.fwnode_handle*, i32, [16 x i32] }
%struct.irq_data = type { i32, i32, i64, %struct.irq_common_data*, %struct.irq_chip*, %struct.irq_domain*, %struct.irq_data*, i8* }
%struct.irq_common_data = type { i32, i32, i8*, %struct.msi_desc*, %struct.cpumask* }
%struct.msi_desc = type opaque
%struct.irq_chip = type { %struct.device*, i8*, i32 (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, i32 (%struct.irq_data*, %struct.cpumask*, i1)*, i32 (%struct.irq_data*)*, i32 (%struct.irq_data*, i32)*, i32 (%struct.irq_data*, i32)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*, %struct.seq_file*)*, i32 (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*, %struct.msi_msg*)*, void (%struct.irq_data*, %struct.msi_msg*)*, i32 (%struct.irq_data*, i32, i8*)*, i32 (%struct.irq_data*, i32, i1)*, i32 (%struct.irq_data*, i8*)*, void (%struct.irq_data*, i32)*, void (%struct.irq_data*, %struct.cpumask*)*, i64 }
%struct.msi_msg = type opaque
%struct.irq_domain_chip_generic = type { i32, i32, i32, i32, i32, [0 x %struct.irq_chip_generic*] }
%struct.irq_chip_generic = type { %struct.raw_spinlock, i8*, i32 (i8*)*, void (i32, i8*)*, void (%struct.irq_chip_generic*)*, void (%struct.irq_chip_generic*)*, i32, i32, i32, i32, i32, i32, i32, i32, i8*, i64, i64, %struct.irq_domain*, %struct.list_head, [0 x %struct.irq_chip_type] }
%struct.irq_chip_type = type { %struct.irq_chip, %struct.irq_chip_regs, void (%struct.irq_desc*)*, i32, i32, i32* }
%struct.irq_chip_regs = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.irq_desc = type { %struct.irq_common_data, %struct.irq_data, i32*, {}*, %struct.irqaction*, i32, i32, i32, i32, i32, i64, i32, %struct.atomic_t, i32, %struct.raw_spinlock, %struct.cpumask*, %struct.cpumask*, %struct.cpumask*, %struct.irq_affinity_notify*, %struct.cpumask*, i64, %struct.atomic_t, %struct.__wait_queue_head, i32, i32, i32, i32, %struct.proc_dir_entry*, %struct.callback_head, %struct.kobject, i32, %struct.module*, i8*, [3392 x i8] }
%struct.irqaction = type { i32 (i32, i8*)*, i8*, i8*, %struct.irqaction*, i32 (i32, i8*)*, %struct.task_struct*, %struct.irqaction*, i32, i32, i64, i64, i8*, %struct.proc_dir_entry*, [4000 x i8] }
%struct.irq_affinity_notify = type { i32, %struct.kref, %struct.work_struct, void (%struct.irq_affinity_notify*, %struct.cpumask*)*, void (%struct.kref*)* }
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.fwnode_handle, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.kobject, i64, i8* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32, %struct.bin_attribute }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.sony_pic_irq = type { %struct.acpi_resource_irq, %struct.list_head }
%struct.acpi_resource_irq = type { i8, i8, i8, i8, i8, i8, [1 x i8] }
%struct.sony_pic_ioport = type { %struct.acpi_resource_io, %struct.acpi_resource_io, %struct.list_head }
%struct.acpi_resource_io = type <{ i8, i8, i8, i16, i16 }>
%struct.sonypi_eventtypes = type { i8, i64, %struct.sonypi_event* }
%struct.sonypi_event = type { i8, i8 }
%struct.pv_cpu_ops = type { i64 (i32)*, void (i32, i64)*, i64 ()*, void (i64)*, i64 ()*, void (i64)*, i64 ()*, void (i64)*, void ()*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (i8*, i32)*, i64 ()*, void (%struct.thread_struct*, i32)*, void (i32)*, void (%struct.desc_struct*, i32, i8*)*, void (%struct.desc_struct*, i32, i8*, i32)*, void (%struct.gate_struct64*, i32, %struct.gate_struct64*)*, void (%struct.desc_struct*, i32)*, void (%struct.desc_struct*, i32)*, void (%struct.tss_struct*, %struct.thread_struct*)*, void (i32)*, void ()*, void ()*, void (i32*, i32*, i32*, i32*)*, i64 (i32)*, void (i32, i32, i32)*, i64 (i32, i32*)*, i32 (i32, i32, i32)*, i64 (i32)*, void ()*, void ()*, void ()*, void (%struct.task_struct*)*, void (%struct.task_struct*)* }
%struct.desc_ptr = type <{ i16, i64 }>
%struct.gate_struct64 = type { i16, i16, i16, i16, i32, i32 }
%struct.tss_struct = type { %struct.x86_hw_tss, [1025 x i64], [16 x i8] }
%struct.x86_hw_tss = type <{ i32, i64, i64, i64, i64, [7 x i64], i32, i32, i16, i16 }>
%struct.dmi_system_id = type { {}*, i8*, [4 x %struct.dmi_strmatch], i8* }
%struct.dmi_strmatch = type { i8, [79 x i8] }
%struct.resource = type { i64, i64, i8*, i64, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, i8*, %struct.mfd_cell*, %struct.pdev_archdata }
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.mfd_cell = type opaque
%struct.pdev_archdata = type {}
%struct.sony_laptop_input_s = type { %struct.atomic_t, %struct.input_dev*, %struct.input_dev*, %struct.kfifo, %struct.spinlock, %struct.timer_list }
%struct.input_dev = type { i8*, i8*, i8*, %struct.input_id, [1 x i64], [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i32, i32, i32, i8*, i32 (%struct.input_dev*, %struct.input_keymap_entry*, i32*)*, i32 (%struct.input_dev*, %struct.input_keymap_entry*)*, %struct.ff_device*, i32, %struct.timer_list, [2 x i32], %struct.input_mt*, %struct.input_absinfo*, [12 x i64], [1 x i64], [1 x i64], [1 x i64], i32 (%struct.input_dev*)*, void (%struct.input_dev*)*, i32 (%struct.input_dev*, %struct.file*)*, i32 (%struct.input_dev*, i32, i32, i32)*, %struct.input_handle*, %struct.spinlock, %struct.mutex, i32, i8, %struct.device, %struct.list_head, %struct.list_head, i32, i32, %struct.input_value*, i8 }
%struct.input_id = type { i16, i16, i16, i16 }
%struct.input_keymap_entry = type { i8, i8, i16, i32, [32 x i8] }
%struct.ff_device = type { i32 (%struct.input_dev*, %struct.ff_effect*, %struct.ff_effect*)*, i32 (%struct.input_dev*, i32)*, i32 (%struct.input_dev*, i32, i32)*, void (%struct.input_dev*, i16)*, void (%struct.input_dev*, i16)*, void (%struct.ff_device*)*, i8*, [2 x i64], %struct.mutex, i32, %struct.ff_effect*, [0 x %struct.file*] }
%struct.ff_effect = type { i16, i16, i16, %struct.ff_trigger, %struct.ff_replay, %union.anon.69 }
%struct.ff_trigger = type { i16, i16 }
%struct.ff_replay = type { i16, i16 }
%union.anon.69 = type { %struct.ff_periodic_effect }
%struct.ff_periodic_effect = type { i16, i16, i16, i16, i16, %struct.ff_envelope, i32, i16* }
%struct.ff_envelope = type { i16, i16, i16, i16 }
%struct.input_mt = type opaque
%struct.input_absinfo = type { i32, i32, i32, i32, i32, i32 }
%struct.input_handle = type { i8*, i32, i8*, %struct.input_dev*, %struct.input_handler*, %struct.list_head, %struct.list_head }
%struct.input_handler = type { i8*, void (%struct.input_handle*, i32, i32, i32)*, void (%struct.input_handle*, %struct.input_value*, i32)*, i1 (%struct.input_handle*, i32, i32, i32)*, i1 (%struct.input_handler*, %struct.input_dev*)*, i32 (%struct.input_handler*, %struct.input_dev*, %struct.input_device_id*)*, void (%struct.input_handle*)*, void (%struct.input_handle*)*, i8, i32, i8*, %struct.input_device_id*, %struct.list_head, %struct.list_head }
%struct.input_device_id = type { i64, i16, i16, i16, i16, [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i64 }
%struct.input_value = type { i16, i16, i32 }
%struct.kfifo = type { %union.anon.70, [0 x i8] }
%union.anon.70 = type { %struct.__kfifo }
%struct.__kfifo = type { i32, i32, i32, i32, i8* }
%struct.sonypi_compat_s = type { %struct.fasync_struct*, %struct.kfifo, %struct.spinlock, %struct.__wait_queue_head, %struct.atomic_t }
%struct.miscdevice = type { i32, i8*, %struct.file_operations*, %struct.list_head, %struct.device*, %struct.device*, %struct.attribute_group**, i8*, i16 }
%struct.sony_backlight_props = type { %struct.backlight_device*, i32, i32, i8, i8 }
%struct.backlight_device = type { %struct.backlight_properties, %struct.mutex, %struct.mutex, %struct.backlight_ops*, %struct.notifier_block, %struct.list_head, %struct.device, [32 x i8], i32 }
%struct.backlight_properties = type { i32, i32, i32, i32, i32, i32 }
%struct.backlight_ops = type { i32, i32 (%struct.backlight_device*)*, i32 (%struct.backlight_device*)*, i32 (%struct.backlight_device*, %struct.fb_info*)* }
%struct.fb_info = type { %struct.atomic_t, i32, i32, %struct.mutex, %struct.mutex, %struct.fb_var_screeninfo, %struct.fb_fix_screeninfo, %struct.fb_monspecs, %struct.work_struct, %struct.fb_pixmap, %struct.fb_pixmap, %struct.fb_cmap, %struct.list_head, %struct.fb_videomode*, %struct.backlight_device*, %struct.mutex, [128 x i8], %struct.delayed_work, %struct.fb_deferred_io*, %struct.fb_ops*, %struct.device*, %struct.device*, i32, %struct.fb_tile_ops*, %union.anon.71, i64, i8*, i32, i8*, i8*, %struct.apertures_struct*, i8 }
%struct.fb_var_screeninfo = type { i32, i32, i32, i32, i32, i32, i32, i32, %struct.fb_bitfield, %struct.fb_bitfield, %struct.fb_bitfield, %struct.fb_bitfield, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [4 x i32] }
%struct.fb_bitfield = type { i32, i32, i32 }
%struct.fb_fix_screeninfo = type { [16 x i8], i64, i32, i32, i32, i32, i16, i16, i16, i32, i64, i32, i32, i16, [2 x i16] }
%struct.fb_monspecs = type { %struct.fb_chroma, %struct.fb_videomode*, [4 x i8], [14 x i8], [14 x i8], [14 x i8], i32, i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i8, i16, i8, i8, i8, i8 }
%struct.fb_chroma = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.fb_pixmap = type { i8*, i32, i32, i32, i32, i32, i32, i32, i32, void (%struct.fb_info*, i8*, i8*, i32)*, void (%struct.fb_info*, i8*, i8*, i32)* }
%struct.fb_cmap = type { i32, i32, i16*, i16*, i16*, i16* }
%struct.fb_videomode = type { i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.fb_deferred_io = type { i64, %struct.mutex, %struct.list_head, void (%struct.fb_info*)*, void (%struct.fb_info*, %struct.list_head*)* }
%struct.fb_ops = type { %struct.module*, i32 (%struct.fb_info*, i32)*, i32 (%struct.fb_info*, i32)*, i64 (%struct.fb_info*, i8*, i64, i64*)*, i64 (%struct.fb_info*, i8*, i64, i64*)*, i32 (%struct.fb_var_screeninfo*, %struct.fb_info*)*, i32 (%struct.fb_info*)*, i32 (i32, i32, i32, i32, i32, %struct.fb_info*)*, i32 (%struct.fb_cmap*, %struct.fb_info*)*, i32 (i32, %struct.fb_info*)*, i32 (%struct.fb_var_screeninfo*, %struct.fb_info*)*, void (%struct.fb_info*, %struct.fb_fillrect*)*, void (%struct.fb_info*, %struct.fb_copyarea*)*, void (%struct.fb_info*, %struct.fb_image*)*, i32 (%struct.fb_info*, %struct.fb_cursor*)*, i32 (%struct.fb_info*)*, i32 (%struct.fb_info*, i32, i64)*, i32 (%struct.fb_info*, i32, i64)*, i32 (%struct.fb_info*, %struct.vm_area_struct*)*, void (%struct.fb_info*, %struct.fb_blit_caps*, %struct.fb_var_screeninfo*)*, void (%struct.fb_info*)*, i32 (%struct.fb_info*)*, i32 (%struct.fb_info*)* }
%struct.fb_fillrect = type { i32, i32, i32, i32, i32, i32 }
%struct.fb_copyarea = type { i32, i32, i32, i32, i32, i32 }
%struct.fb_image = type { i32, i32, i32, i32, i32, i32, i8, i8*, %struct.fb_cmap }
%struct.fb_cursor = type { i16, i16, i16, i8*, %struct.fbcurpos, %struct.fb_image }
%struct.fbcurpos = type { i16, i16 }
%struct.fb_blit_caps = type { i32, i32, i32, i32 }
%struct.fb_tile_ops = type { void (%struct.fb_info*, %struct.fb_tilemap*)*, void (%struct.fb_info*, %struct.fb_tilearea*)*, void (%struct.fb_info*, %struct.fb_tilerect*)*, void (%struct.fb_info*, %struct.fb_tileblit*)*, void (%struct.fb_info*, %struct.fb_tilecursor*)*, i32 (%struct.fb_info*)* }
%struct.fb_tilemap = type { i32, i32, i32, i32, i8* }
%struct.fb_tilearea = type { i32, i32, i32, i32, i32, i32 }
%struct.fb_tilerect = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.fb_tileblit = type { i32, i32, i32, i32, i32, i32, i32, i32* }
%struct.fb_tilecursor = type { i32, i32, i32, i32, i32, i32 }
%union.anon.71 = type { i8* }
%struct.apertures_struct = type { i32, [0 x %struct.aperture] }
%struct.aperture = type { i64, i64 }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.acpi_buffer = type { i64, i8* }
%struct.platform_driver = type { i32 (%struct.platform_device*)*, i32 (%struct.platform_device*)*, void (%struct.platform_device*)*, i32 (%struct.platform_device*, i32)*, i32 (%struct.platform_device*)*, %struct.device_driver, %struct.platform_device_id*, i8 }
%struct.sony_nc_value = type { i8*, i8**, i8**, i32 (i32, i32)*, i32, i32, i32, %struct.device_attribute }
%struct.sony_nc_handles = type { [16 x i16], %struct.device_attribute }
%struct.touchpad_control = type { %struct.device_attribute, i32 }
%struct.battery_care_control = type { [2 x %struct.device_attribute], i32 }
%struct.snc_lid_resume_control = type { [3 x %struct.device_attribute], i32, i32 }
%struct.snc_thermal_ctrl = type { i32, i32, %struct.device_attribute, %struct.device_attribute }
%struct.snc_gfx_switch_control = type { %struct.device_attribute, i32 }
%struct.rfkill = type opaque
%struct.rfkill_ops = type { void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)*, i32 (i8*, i1)* }
%struct.kbd_backlight = type { i32, i32, i32, i32, i32, %struct.device_attribute, %struct.device_attribute }
%struct.sony_nc_event = type { i8, i8 }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i16, i8, i8, i8, i8, i8, i8, i16, [4 x i8], i64*, %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, [3 x i8], i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, i32, i8, i16, %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], i8, i8, [6 x i8], %struct.attribute_group**, %struct.pci_vpd*, %union.anon.67, i16, i8, i8, %struct.atomic_t, i64, i64, i8* }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, %struct.msi_controller*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.pci_ops = type { i32 (%struct.pci_bus*)*, void (%struct.pci_bus*)*, i8* (%struct.pci_bus*, i32, i32)*, i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.msi_controller = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.pci_dynids }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*, i1)*, void (%struct.pci_dev*)* }
%struct.pci_dynids = type { %struct.spinlock, %struct.list_head }
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.67 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.anon.72 = type { %struct.acpi_resource, %struct.acpi_resource, %struct.acpi_resource, %struct.acpi_resource }
%struct.acpi_resource = type { i32, i32, %union.acpi_resource_data }
%union.acpi_resource_data = type { %struct.acpi_resource_vendor_typed, [40 x i8] }
%struct.acpi_resource_vendor_typed = type { i16, i8, [16 x i8], [1 x i8] }
%struct.acpi_object_list = type { i32, %union.acpi_object* }
%struct.sony_laptop_keypress = type { %struct.input_dev*, i32 }
%union.anon.68 = type { %struct.list_head* }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.anon.58 = type { i32, i64 }
%union.anon.73 = type { %struct.list_head* }
%struct.acpi_device_info = type { i32, i32, i32, i8, i16, i8, [4 x i8], [5 x i8], i32, i64, %struct.acpi_pnp_device_id, %struct.acpi_pnp_device_id, %struct.acpi_pnp_device_id, %struct.acpi_pnp_device_id_list }
%struct.acpi_pnp_device_id = type { i32, i8* }
%struct.acpi_pnp_device_id_list = type { i32, i32, [1 x %struct.acpi_pnp_device_id] }
%struct.anon.60 = type { i32, i32, i8* }

@__UNIQUE_ID_author12 = internal constant [35 x i8] c"author=Stelian Pop, Mattia Dongili\00", section ".modinfo", align 1
@__UNIQUE_ID_description13 = internal constant [65 x i8] c"description=Sony laptop extras driver (SPIC and SNC ACPI device)\00", section ".modinfo", align 1
@__UNIQUE_ID_license14 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__param_str_debug = internal constant [6 x i8] c"debug\00", align 1
@__this_module = external global %struct.module, align 64
@param_ops_int = external constant %struct.kernel_param_ops, align 8
@debug = internal global i32 0, align 4
@__param_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_debug, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 0, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_debugtype15 = internal constant [19 x i8] c"parmtype=debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_debug16 = internal constant [87 x i8] c"parm=debug:set this to 1 (and RTFM) if you want to help the development of this driver\00", section ".modinfo", align 1
@__param_str_no_spic = internal constant [8 x i8] c"no_spic\00", align 1
@no_spic = internal global i32 0, align 4
@__param_no_spic = internal constant %struct.kernel_param { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @__param_str_no_spic, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @no_spic to i8*) } }, section "__param", align 8
@__UNIQUE_ID_no_spictype17 = internal constant [21 x i8] c"parmtype=no_spic:int\00", section ".modinfo", align 1
@__UNIQUE_ID_no_spic18 = internal constant [66 x i8] c"parm=no_spic:set this if you don't want to enable the SPIC device\00", section ".modinfo", align 1
@__param_str_compat = internal constant [7 x i8] c"compat\00", align 1
@compat = internal global i32 0, align 4
@__param_compat = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_compat, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @compat to i8*) } }, section "__param", align 8
@__UNIQUE_ID_compattype19 = internal constant [20 x i8] c"parmtype=compat:int\00", section ".modinfo", align 1
@__UNIQUE_ID_compat20 = internal constant [71 x i8] c"parm=compat:set this if you want to enable backward compatibility mode\00", section ".modinfo", align 1
@__param_str_mask = internal constant [5 x i8] c"mask\00", align 1
@param_ops_ulong = external constant %struct.kernel_param_ops, align 8
@mask = internal global i64 4294967295, align 8
@__param_mask = internal constant %struct.kernel_param { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @__param_str_mask, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_ulong, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i64* @mask to i8*) } }, section "__param", align 8
@__UNIQUE_ID_masktype21 = internal constant [20 x i8] c"parmtype=mask:ulong\00", section ".modinfo", align 1
@__UNIQUE_ID_mask22 = internal constant [69 x i8] c"parm=mask:set this to the mask of event you want to enable (see doc)\00", section ".modinfo", align 1
@__param_str_camera = internal constant [7 x i8] c"camera\00", align 1
@camera = internal global i32 0, align 4
@__param_camera = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_camera, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @camera to i8*) } }, section "__param", align 8
@__UNIQUE_ID_cameratype23 = internal constant [20 x i8] c"parmtype=camera:int\00", section ".modinfo", align 1
@__UNIQUE_ID_camera24 = internal constant [110 x i8] c"parm=camera:set this to 1 to enable Motion Eye camera controls (only use it if you have a C1VE or C1VN model)\00", section ".modinfo", align 1
@__param_str_minor = internal constant [6 x i8] c"minor\00", align 1
@minor = internal global i32 -1, align 4
@__param_minor = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_minor, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 0, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @minor to i8*) } }, section "__param", align 8
@__UNIQUE_ID_minortype25 = internal constant [19 x i8] c"parmtype=minor:int\00", section ".modinfo", align 1
@__UNIQUE_ID_minor26 = internal constant [102 x i8] c"parm=minor:minor number of the misc device for the SPIC compatibility code, default is -1 (automatic)\00", section ".modinfo", align 1
@__param_str_kbd_backlight = internal constant [14 x i8] c"kbd_backlight\00", align 1
@kbd_backlight = internal global i32 -1, align 4
@__param_kbd_backlight = internal constant %struct.kernel_param { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__param_str_kbd_backlight, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @kbd_backlight to i8*) } }, section "__param", align 8
@__UNIQUE_ID_kbd_backlighttype27 = internal constant [27 x i8] c"parmtype=kbd_backlight:int\00", section ".modinfo", align 1
@__UNIQUE_ID_kbd_backlight28 = internal constant [169 x i8] c"parm=kbd_backlight:set this to 0 to disable keyboard backlight, 1 to enable it with automatic control and 2 to have it always on (default: no change from current value)\00", section ".modinfo", align 1
@__param_str_kbd_backlight_timeout = internal constant [22 x i8] c"kbd_backlight_timeout\00", align 16
@kbd_backlight_timeout = internal global i32 -1, align 4
@__param_kbd_backlight_timeout = internal constant %struct.kernel_param { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__param_str_kbd_backlight_timeout, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @kbd_backlight_timeout to i8*) } }, section "__param", align 8
@__UNIQUE_ID_kbd_backlight_timeouttype29 = internal constant [35 x i8] c"parmtype=kbd_backlight_timeout:int\00", section ".modinfo", align 1
@__UNIQUE_ID_kbd_backlight_timeout30 = internal constant [141 x i8] c"parm=kbd_backlight_timeout:meaningful values vary from 0 to 3 and their meaning depends on the model (default: no change from current value)\00", section ".modinfo", align 1
@sony_device_ids = internal constant [3 x %struct.acpi_device_id] [%struct.acpi_device_id { [9 x i8] c"SNY5001\00\00", i64 0, i32 0, i32 0 }, %struct.acpi_device_id { [9 x i8] c"SNY6001\00\00", i64 0, i32 0, i32 0 }, %struct.acpi_device_id zeroinitializer], align 16
@spic_dev = internal global %struct.sony_pic_dev { %struct.acpi_device* null, %struct.sony_pic_irq* null, %struct.sony_pic_ioport* null, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 24) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 24) to %struct.list_head*) }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 40) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 40) to %struct.list_head*) }, %struct.mutex zeroinitializer, %struct.sonypi_eventtypes* null, i32 (i8, i8)* null, i32 0, i16 0, i8 0, i8 0, i8 0 }, align 8
@.str = private unnamed_addr constant [52 x i8] c"\014sony_laptop: command failed at %s : %s (line %d)\0A\00", align 1
@.str.1 = private unnamed_addr constant [35 x i8] c"drivers/platform/x86/sony-laptop.c\00", align 1
@__func__.sony_pic_camera_command = private unnamed_addr constant [24 x i8] c"sony_pic_camera_command\00", align 1
@.str.2 = private unnamed_addr constant [52 x i8] c"\013sony_laptop: sony_pic_camera_command invalid: %d\0A\00", align 1
@__kstrtab_sony_pic_camera_command = internal constant [24 x i8] c"sony_pic_camera_command\00", section "__ksymtab_strings", align 1
@__ksymtab_sony_pic_camera_command = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, i8)* @sony_pic_camera_command to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_sony_pic_camera_command, i32 0, i32 0) }, section "___ksymtab+sony_pic_camera_command", align 8
@.str.3 = private unnamed_addr constant [43 x i8] c"\014sony_laptop: camera control not enabled\0A\00", align 1
@.str.4 = private unnamed_addr constant [42 x i8] c"\014sony_laptop: failed to power on camera\0A\00", align 1
@__func__.__sony_pic_camera_on = private unnamed_addr constant [21 x i8] c"__sony_pic_camera_on\00", align 1
@__func__.sony_pic_call2 = private unnamed_addr constant [15 x i8] c"sony_pic_call2\00", align 1
@.str.5 = private unnamed_addr constant [56 x i8] c"\014sony_laptop: sony_pic_call2(0x%.2x - 0x%.2x): 0x%.4x\0A\00", align 1
@pv_cpu_ops = external global %struct.pv_cpu_ops, align 8
@__func__.sony_pic_call1 = private unnamed_addr constant [15 x i8] c"sony_pic_call1\00", align 1
@.str.6 = private unnamed_addr constant [47 x i8] c"\014sony_laptop: sony_pic_call1(0x%.2x): 0x%.4x\0A\00", align 1
@__func__.__sony_pic_camera_off = private unnamed_addr constant [22 x i8] c"__sony_pic_camera_off\00", align 1
@__func__.sony_pic_call3 = private unnamed_addr constant [15 x i8] c"sony_pic_call3\00", align 1
@.str.7 = private unnamed_addr constant [65 x i8] c"\014sony_laptop: sony_pic_call3(0x%.2x - 0x%.2x - 0x%.2x): 0x%.4x\0A\00", align 1
@sony_pic_driver = internal global %struct.acpi_driver { [80 x i8] c"Sony Programmable IO Control Driver\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [80 x i8] c"sony-pic\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", %struct.acpi_device_id* getelementptr inbounds ([2 x %struct.acpi_device_id], [2 x %struct.acpi_device_id]* @sony_pic_device_ids, i32 0, i32 0), i32 0, %struct.acpi_device_ops { i32 (%struct.acpi_device*)* @sony_pic_add, i32 (%struct.acpi_device*)* @sony_pic_remove, void (%struct.acpi_device*, i32)* null }, %struct.device_driver { i8* null, %struct.bus_type* null, %struct.module* null, i8* null, i8 0, i32 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* @sony_pic_pm, %struct.driver_private* null }, %struct.module* @__this_module }, align 8
@.str.8 = private unnamed_addr constant [47 x i8] c"\013sony_laptop: Unable to register SPIC driver\0A\00", align 1
@spic_drv_registered = internal global i32 0, align 4
@sony_nc_driver = internal global %struct.acpi_driver { [80 x i8] c"Sony Notebook Control Driver\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [80 x i8] c"sony-nc\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", %struct.acpi_device_id* getelementptr inbounds ([2 x %struct.acpi_device_id], [2 x %struct.acpi_device_id]* @sony_nc_device_ids, i32 0, i32 0), i32 0, %struct.acpi_device_ops { i32 (%struct.acpi_device*)* @sony_nc_add, i32 (%struct.acpi_device*)* @sony_nc_remove, void (%struct.acpi_device*, i32)* @sony_nc_notify }, %struct.device_driver { i8* null, %struct.bus_type* null, %struct.module* null, i8* null, i8 0, i32 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* @sony_nc_pm, %struct.driver_private* null }, %struct.module* @__this_module }, align 8
@.str.9 = private unnamed_addr constant [46 x i8] c"\013sony_laptop: Unable to register SNC driver\0A\00", align 1
@.str.10 = private unnamed_addr constant [10 x i8] c"Sony Vaio\00", align 1
@sonypi_dmi_table = internal global <{ { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } }> <{ { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } { i32 (%struct.dmi_system_id*)* null, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), [4 x %struct.dmi_strmatch] [%struct.dmi_strmatch { i8 4, [79 x i8] c"Sony Corporation\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch { i8 5, [79 x i8] c"PCG-\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch zeroinitializer, %struct.dmi_strmatch zeroinitializer], i8* null }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } { i32 (%struct.dmi_system_id*)* null, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), [4 x %struct.dmi_strmatch] [%struct.dmi_strmatch { i8 4, [79 x i8] c"Sony Corporation\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch { i8 5, [79 x i8] c"VGN-\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch zeroinitializer, %struct.dmi_strmatch zeroinitializer], i8* null }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } zeroinitializer }>, section ".init.data", align 16
@sony_pic_device_ids = internal constant [2 x %struct.acpi_device_id] [%struct.acpi_device_id { [9 x i8] c"SNY6001\00\00", i64 0, i32 0, i32 0 }, %struct.acpi_device_id zeroinitializer], align 16
@sony_pic_pm = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* @sony_pic_suspend, i32 (%struct.device*)* @sony_pic_resume, i32 (%struct.device*)* @sony_pic_suspend, i32 (%struct.device*)* @sony_pic_resume, i32 (%struct.device*)* @sony_pic_suspend, i32 (%struct.device*)* @sony_pic_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null }, align 8
@.str.12 = private unnamed_addr constant [12 x i8] c"sony/hotkey\00", align 1
@sony_pic_add.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.13 = private unnamed_addr constant [15 x i8] c"&spic_dev.lock\00", align 1
@.str.14 = private unnamed_addr constant [50 x i8] c"\013sony_laptop: Unable to read possible resources\0A\00", align 1
@.str.15 = private unnamed_addr constant [47 x i8] c"\013sony_laptop: Unable to create input devices\0A\00", align 1
@ioport_resource = external global %struct.resource, align 8
@.str.16 = private unnamed_addr constant [29 x i8] c"Sony Programmable I/O Device\00", align 1
@.str.17 = private unnamed_addr constant [52 x i8] c"\014sony_laptop: I/O port1: 0x%.4x (0x%.4x) + 0x%.2x\0A\00", align 1
@.str.18 = private unnamed_addr constant [52 x i8] c"\014sony_laptop: I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\0A\00", align 1
@.str.19 = private unnamed_addr constant [66 x i8] c"\014sony_laptop: Unable to get I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\0A\00", align 1
@.str.20 = private unnamed_addr constant [41 x i8] c"\013sony_laptop: Failed to request_region\0A\00", align 1
@.str.21 = private unnamed_addr constant [12 x i8] c"sony-laptop\00", align 1
@.str.22 = private unnamed_addr constant [66 x i8] c"\014sony_laptop: IRQ: %d - triggering: %d - polarity: %d - shr: %d\0A\00", align 1
@.str.23 = private unnamed_addr constant [38 x i8] c"\013sony_laptop: Failed to request_irq\0A\00", align 1
@.str.24 = private unnamed_addr constant [39 x i8] c"\013sony_laptop: Couldn't enable device\0A\00", align 1
@sony_pf_device = internal global %struct.platform_device* null, align 8
@spic_attribute_group = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([4 x %struct.attribute*], [4 x %struct.attribute*]* @spic_attributes, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@.str.25 = private unnamed_addr constant [33 x i8] c"\016sony_laptop: SPIC setup done.\0A\00", align 1
@type1_events = internal global [11 x %struct.sonypi_eventtypes] [%struct.sonypi_eventtypes { i8 0, i64 4294967295, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_releaseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 112, i64 1024, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_meyeev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 48, i64 128, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_lidev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 96, i64 2, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_captureev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 16, i64 1, %struct.sonypi_event* getelementptr inbounds ([14 x %struct.sonypi_event], [14 x %struct.sonypi_event]* @sonypi_joggerev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 32, i64 4, %struct.sonypi_event* getelementptr inbounds ([23 x %struct.sonypi_event], [23 x %struct.sonypi_event]* @sonypi_fnkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 48, i64 8, %struct.sonypi_event* getelementptr inbounds ([4 x %struct.sonypi_event], [4 x %struct.sonypi_event]* @sonypi_blueev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 64, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 48, i64 2048, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_memorystickev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 64, i64 4096, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_batteryev, i32 0, i32 0) }, %struct.sonypi_eventtypes zeroinitializer], align 16
@type2_events = internal global [15 x %struct.sonypi_eventtypes] [%struct.sonypi_eventtypes { i8 0, i64 4294967295, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_releaseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 56, i64 128, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_lidev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 17, i64 1, %struct.sonypi_event* getelementptr inbounds ([14 x %struct.sonypi_event], [14 x %struct.sonypi_event]* @sonypi_joggerev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 97, i64 2, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_captureev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 4, %struct.sonypi_event* getelementptr inbounds ([23 x %struct.sonypi_event], [23 x %struct.sonypi_event]* @sonypi_fnkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 8, %struct.sonypi_event* getelementptr inbounds ([4 x %struct.sonypi_event], [4 x %struct.sonypi_event]* @sonypi_blueev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 8, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 17, i64 32, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_backev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 64, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_helpev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 256, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_zoomev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 32, i64 512, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_thumbphraseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 2048, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_memorystickev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 65, i64 4096, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_batteryev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes zeroinitializer], align 16
@type3_events = internal global [12 x %struct.sonypi_eventtypes] [%struct.sonypi_eventtypes { i8 0, i64 4294967295, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_releaseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 4, %struct.sonypi_event* getelementptr inbounds ([23 x %struct.sonypi_event], [23 x %struct.sonypi_event]* @sonypi_fnkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 8192, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_wlessev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 2048, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_memorystickev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 65, i64 4096, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_batteryev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 256, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_zoomev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 2, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_captureev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 16, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_volumeev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 16, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_brightnessev, i32 0, i32 0) }, %struct.sonypi_eventtypes zeroinitializer], align 16
@.str.26 = private unnamed_addr constant [38 x i8] c"\016sony_laptop: detected Type%d model\0A\00", align 1
@sonypi_releaseev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 0, i8 56 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_meyeev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 0, i8 52 }, %struct.sonypi_event { i8 1, i8 53 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_lidev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 81, i8 36 }, %struct.sonypi_event { i8 80, i8 37 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_captureev = internal global [5 x %struct.sonypi_event] [%struct.sonypi_event { i8 5, i8 9 }, %struct.sonypi_event { i8 7, i8 7 }, %struct.sonypi_event { i8 64, i8 7 }, %struct.sonypi_event { i8 1, i8 10 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_joggerev = internal global [14 x %struct.sonypi_event] [%struct.sonypi_event { i8 31, i8 2 }, %struct.sonypi_event { i8 1, i8 1 }, %struct.sonypi_event { i8 95, i8 4 }, %struct.sonypi_event { i8 65, i8 3 }, %struct.sonypi_event { i8 30, i8 43 }, %struct.sonypi_event { i8 2, i8 42 }, %struct.sonypi_event { i8 94, i8 45 }, %struct.sonypi_event { i8 66, i8 44 }, %struct.sonypi_event { i8 29, i8 47 }, %struct.sonypi_event { i8 3, i8 46 }, %struct.sonypi_event { i8 93, i8 49 }, %struct.sonypi_event { i8 67, i8 48 }, %struct.sonypi_event { i8 64, i8 5 }, %struct.sonypi_event zeroinitializer], align 16
@sonypi_fnkeyev = internal global [23 x %struct.sonypi_event] [%struct.sonypi_event { i8 16, i8 11 }, %struct.sonypi_event { i8 17, i8 12 }, %struct.sonypi_event { i8 18, i8 13 }, %struct.sonypi_event { i8 19, i8 14 }, %struct.sonypi_event { i8 20, i8 15 }, %struct.sonypi_event { i8 21, i8 16 }, %struct.sonypi_event { i8 22, i8 17 }, %struct.sonypi_event { i8 23, i8 18 }, %struct.sonypi_event { i8 24, i8 19 }, %struct.sonypi_event { i8 25, i8 20 }, %struct.sonypi_event { i8 26, i8 21 }, %struct.sonypi_event { i8 27, i8 22 }, %struct.sonypi_event { i8 28, i8 23 }, %struct.sonypi_event { i8 31, i8 59 }, %struct.sonypi_event { i8 33, i8 24 }, %struct.sonypi_event { i8 34, i8 25 }, %struct.sonypi_event { i8 49, i8 26 }, %struct.sonypi_event { i8 50, i8 27 }, %struct.sonypi_event { i8 51, i8 28 }, %struct.sonypi_event { i8 52, i8 29 }, %struct.sonypi_event { i8 53, i8 30 }, %struct.sonypi_event { i8 54, i8 41 }, %struct.sonypi_event zeroinitializer], align 16
@sonypi_blueev = internal global [4 x %struct.sonypi_event] [%struct.sonypi_event { i8 85, i8 31 }, %struct.sonypi_event { i8 89, i8 38 }, %struct.sonypi_event { i8 90, i8 39 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_pkeyev = internal global [5 x %struct.sonypi_event] [%struct.sonypi_event { i8 1, i8 32 }, %struct.sonypi_event { i8 2, i8 33 }, %struct.sonypi_event { i8 4, i8 34 }, %struct.sonypi_event { i8 32, i8 32 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_memorystickev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 83, i8 54 }, %struct.sonypi_event { i8 84, i8 55 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_batteryev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 32, i8 57 }, %struct.sonypi_event { i8 48, i8 58 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_backev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 32, i8 35 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_helpev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 59, i8 40 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_zoomev = internal global [5 x %struct.sonypi_event] [%struct.sonypi_event { i8 57, i8 50 }, %struct.sonypi_event { i8 16, i8 62 }, %struct.sonypi_event { i8 32, i8 63 }, %struct.sonypi_event { i8 4, i8 50 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_thumbphraseev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 58, i8 51 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_wlessev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 89, i8 0 }, %struct.sonypi_event { i8 90, i8 0 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_volumeev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 1, i8 69 }, %struct.sonypi_event { i8 2, i8 70 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_brightnessev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 -128, i8 71 }, %struct.sonypi_event zeroinitializer], align 1
@.str.27 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Evaluating _STA\0A\00", align 1
@.str.28 = private unnamed_addr constant [38 x i8] c"\014sony_laptop: Unable to read status\0A\00", align 1
@.str.29 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Device disabled\0A\00", align 1
@.str.30 = private unnamed_addr constant [31 x i8] c"\014sony_laptop: Device enabled\0A\00", align 1
@.str.31 = private unnamed_addr constant [30 x i8] c"\014sony_laptop: Evaluating %s\0A\00", align 1
@.str.32 = private unnamed_addr constant [5 x i8] c"_PRS\00", align 1
@.str.33 = private unnamed_addr constant [38 x i8] c"\014sony_laptop: Failure evaluating %s\0A\00", align 1
@.str.34 = private unnamed_addr constant [35 x i8] c"\014sony_laptop: Blank IRQ resource\0A\00", align 1
@.str.35 = private unnamed_addr constant [31 x i8] c"\014sony_laptop: Invalid IRQ %d\0A\00", align 1
@.str.36 = private unnamed_addr constant [34 x i8] c"\014sony_laptop: Blank IO resource\0A\00", align 1
@.str.37 = private unnamed_addr constant [39 x i8] c"\014sony_laptop: IO1 at 0x%.4x (0x%.2x)\0A\00", align 1
@.str.38 = private unnamed_addr constant [39 x i8] c"\014sony_laptop: IO2 at 0x%.4x (0x%.2x)\0A\00", align 1
@.str.39 = private unnamed_addr constant [56 x i8] c"\013sony_laptop: Unknown SPIC Type, more than 2 IO Ports\0A\00", align 1
@.str.40 = private unnamed_addr constant [56 x i8] c"\014sony_laptop: Resource %d isn't an IRQ nor an IO port\0A\00", align 1
@sony_laptop_input = internal global %struct.sony_laptop_input_s zeroinitializer, align 8
@sony_laptop_setup_input.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.41 = private unnamed_addr constant [39 x i8] c"&(&sony_laptop_input.fifo_lock)->rlock\00", align 1
@.str.42 = private unnamed_addr constant [35 x i8] c"\013sony_laptop: kfifo_alloc failed\0A\00", align 1
@sony_laptop_setup_input.__key.43 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.44 = private unnamed_addr constant [41 x i8] c"((&sony_laptop_input.release_key_timer))\00", align 1
@.str.45 = private unnamed_addr constant [15 x i8] c"Sony Vaio Keys\00", align 1
@sony_laptop_input_keycode_map = internal global [60 x i32] [i32 212, i32 0, i32 0, i32 0, i32 465, i32 466, i32 467, i32 468, i32 469, i32 470, i32 471, i32 472, i32 473, i32 474, i32 475, i32 476, i32 477, i32 478, i32 479, i32 480, i32 481, i32 482, i32 483, i32 484, i32 237, i32 148, i32 149, i32 202, i32 158, i32 237, i32 237, i32 138, i32 464, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 372, i32 289, i32 0, i32 0, i32 0, i32 0, i32 238, i32 238, i32 418, i32 419, i32 161, i32 183, i32 203, i32 184, i32 185, i32 115, i32 114, i32 226, i32 360], align 16
@.str.46 = private unnamed_addr constant [18 x i8] c"Sony Vaio Jogdial\00", align 1
@jiffies = external global i64, align 8
@sonypi_compat = internal global %struct.sonypi_compat_s zeroinitializer, align 8
@sonypi_compat_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.47 = private unnamed_addr constant [35 x i8] c"&(&sonypi_compat.fifo_lock)->rlock\00", align 1
@sonypi_compat_init.__key.48 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.49 = private unnamed_addr constant [30 x i8] c"&sonypi_compat.fifo_proc_list\00", align 1
@sonypi_misc_device = internal global %struct.miscdevice { i32 255, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.52, i32 0, i32 0), %struct.file_operations* @sonypi_misc_fops, %struct.list_head zeroinitializer, %struct.device* null, %struct.device* null, %struct.attribute_group** null, i8* null, i16 0 }, align 8
@.str.50 = private unnamed_addr constant [37 x i8] c"\013sony_laptop: misc_register failed\0A\00", align 1
@.str.51 = private unnamed_addr constant [45 x i8] c"\016sony_laptop: device allocated minor is %d\0A\00", align 1
@.str.52 = private unnamed_addr constant [7 x i8] c"sonypi\00", align 1
@sonypi_misc_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @noop_llseek, i64 (%struct.file*, i8*, i64, i64*)* @sonypi_misc_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @sonypi_misc_poll, i64 (%struct.file*, i32, i64)* @sonypi_misc_ioctl, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @sonypi_misc_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @sonypi_misc_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* @sonypi_misc_fasync, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@sony_bl_props = internal global %struct.sony_backlight_props zeroinitializer, align 8
@sony_nc_acpi_handle = internal global i8* null, align 8
@.str.53 = private unnamed_addr constant [5 x i8] c"GBRT\00", align 1
@.str.54 = private unnamed_addr constant [5 x i8] c"SBRT\00", align 1
@.str.55 = private unnamed_addr constant [60 x i8] c"\014sony_laptop: Invalid acpi_object: expected 0x%x got 0x%x\0A\00", align 1
@__call_snc_method.output = private unnamed_addr constant %struct.acpi_buffer { i64 -1, i8* null }, align 8
@.str.56 = private unnamed_addr constant [51 x i8] c"\014sony_laptop: __call_snc_method: [%s:0x%.8x%.8x]\0A\00", align 1
@.str.57 = private unnamed_addr constant [40 x i8] c"\014sony_laptop: __call_snc_method: [%s]\0A\00", align 1
@.str.58 = private unnamed_addr constant [40 x i8] c"\013sony_laptop: Failed to evaluate [%s]\0A\00", align 1
@.str.59 = private unnamed_addr constant [38 x i8] c"\014sony_laptop: No return object [%s]\0A\00", align 1
@.str.60 = private unnamed_addr constant [33 x i8] c"./arch/x86/include/asm/uaccess.h\00", align 1
@.str.61 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@.str.62 = private unnamed_addr constant [62 x i8] c"\014sony_laptop: event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\0A\00", align 1
@.str.63 = private unnamed_addr constant [70 x i8] c"\014sony_laptop: unknown event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\0A\00", align 1
@.str.64 = private unnamed_addr constant [68 x i8] c"\014sony_laptop: sony_laptop_report_input_event, event not known: %d\0A\00", align 1
@sony_laptop_input_index = internal global [74 x i32] [i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 -1, i32 -1, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 -1, i32 -1, i32 -1, i32 -1, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 -1, i32 58, i32 59], align 16
@.str.65 = private unnamed_addr constant [41 x i8] c"\014sony_laptop: unknown input event %.2x\0A\00", align 1
@.str.66 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Evaluating _SRS\0A\00", align 1
@.str.67 = private unnamed_addr constant [38 x i8] c"\013sony_laptop: Error evaluating _SRS\0A\00", align 1
@sony_pf_users = internal global %struct.atomic_t zeroinitializer, align 4
@sony_pf_driver = internal global %struct.platform_driver { i32 (%struct.platform_device*)* null, i32 (%struct.platform_device*)* null, void (%struct.platform_device*)* null, i32 (%struct.platform_device*, i32)* null, i32 (%struct.platform_device*)* null, %struct.device_driver { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.21, i32 0, i32 0), %struct.bus_type* null, %struct.module* null, i8* null, i8 0, i32 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.platform_device_id* null, i8 0 }, align 8
@spic_attributes = internal global [4 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @spic_attr_bluetoothpower, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @spic_attr_wwanpower, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @spic_attr_fanspeed, i32 0, i32 0), %struct.attribute* null], align 16
@spic_attr_bluetoothpower = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.68, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_pic_bluetoothpower_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_pic_bluetoothpower_store }, align 8
@spic_attr_wwanpower = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.70, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_pic_wwanpower_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_pic_wwanpower_store }, align 8
@spic_attr_fanspeed = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.71, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_pic_fanspeed_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_pic_fanspeed_store }, align 8
@.str.68 = private unnamed_addr constant [15 x i8] c"bluetoothpower\00", align 1
@.str.69 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.70 = private unnamed_addr constant [10 x i8] c"wwanpower\00", align 1
@.str.71 = private unnamed_addr constant [9 x i8] c"fanspeed\00", align 1
@.str.72 = private unnamed_addr constant [5 x i8] c"_DIS\00", align 1
@.str.73 = private unnamed_addr constant [40 x i8] c"\013sony_laptop: Couldn't disable device\0A\00", align 1
@.str.74 = private unnamed_addr constant [61 x i8] c"\014sony_laptop: Sony Programmable IO Control Driver removed.\0A\00", align 1
@sony_nc_device_ids = internal constant [2 x %struct.acpi_device_id] [%struct.acpi_device_id { [9 x i8] c"SNY5001\00\00", i64 0, i32 0, i32 0 }, %struct.acpi_device_id zeroinitializer], align 16
@sony_nc_pm = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* @sony_nc_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* @sony_nc_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* @sony_nc_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null }, align 8
@sony_nc_acpi_device = internal global %struct.acpi_device* null, align 8
@.str.75 = private unnamed_addr constant [35 x i8] c"\014sony_laptop: Device not present\0A\00", align 1
@.str.76 = private unnamed_addr constant [46 x i8] c"\014sony_laptop: unable to walk acpi resources\0A\00", align 1
@.str.77 = private unnamed_addr constant [5 x i8] c"ECON\00", align 1
@.str.78 = private unnamed_addr constant [35 x i8] c"\014sony_laptop: ECON Method failed\0A\00", align 1
@.str.79 = private unnamed_addr constant [5 x i8] c"SN00\00", align 1
@.str.80 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Doing SNC setup\0A\00", align 1
@sony_nc_values = internal global [13 x %struct.sony_nc_value] [%struct.sony_nc_value { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.157, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_brightness_def_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_brightness_def_set, i32 0, i32 0), i32 (i32, i32)* @brightness_default_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.157, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_fnkey_get, i32 0, i32 0), i8** null, i32 (i32, i32)* null, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_cdpower_get, i32 0, i32 0), i8** getelementptr inbounds ([3 x i8*], [3 x i8*]* @snc_cdpower_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.160, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_audiopower_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_audiopower_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.160, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.161, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_lanpower_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_lanpower_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.161, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.162, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_lidstate_get, i32 0, i32 0), i8** null, i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.162, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.163, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_indicatorlamp_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_indicatorlamp_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.163, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.164, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_gainbass_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_gainbass_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.164, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.165, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_PID_get, i32 0, i32 0), i8** null, i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.165, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.166, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CTR_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CTR_set, i32 0, i32 0), i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.166, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.167, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_PCR_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_PCR_set, i32 0, i32 0), i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.167, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.168, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CMI_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CMI_set, i32 0, i32 0), i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.168, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value zeroinitializer], align 16
@.str.81 = private unnamed_addr constant [36 x i8] c"\014sony_laptop: Found %s getter: %s\0A\00", align 1
@.str.82 = private unnamed_addr constant [36 x i8] c"\014sony_laptop: Found %s setter: %s\0A\00", align 1
@.str.83 = private unnamed_addr constant [32 x i8] c"\016sony_laptop: SNC setup done.\0A\00", align 1
@.str.84 = private unnamed_addr constant [45 x i8] c"\014sony_laptop: method: name: %4.4s, args %X\0A\00", align 1
@handles = internal global %struct.sony_nc_handles* null, align 8
@.str.85 = private unnamed_addr constant [55 x i8] c"\014sony_laptop: caching handle 0x%.4x (offset: 0x%.2x)\0A\00", align 1
@sony_nc_handles_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.86 = private unnamed_addr constant [8 x i8] c"handles\00", align 1
@.str.87 = private unnamed_addr constant [8 x i8] c"0x%.4x \00", align 1
@.str.88 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.89 = private unnamed_addr constant [41 x i8] c"\014sony_laptop: setting up handle 0x%.4x\0A\00", align 1
@.str.90 = private unnamed_addr constant [63 x i8] c"\013sony_laptop: couldn't set up touchpad control function (%d)\0A\00", align 1
@.str.91 = private unnamed_addr constant [59 x i8] c"\013sony_laptop: couldn't set up battery care function (%d)\0A\00", align 1
@.str.92 = private unnamed_addr constant [57 x i8] c"\013sony_laptop: couldn't set up lid resume function (%d)\0A\00", align 1
@.str.93 = private unnamed_addr constant [62 x i8] c"\013sony_laptop: couldn't set up thermal profile function (%d)\0A\00", align 1
@.str.94 = private unnamed_addr constant [55 x i8] c"\013sony_laptop: couldn't set up GFX Switch status (%d)\0A\00", align 1
@.str.95 = private unnamed_addr constant [66 x i8] c"\013sony_laptop: couldn't set up high speed charging function (%d)\0A\00", align 1
@.str.96 = private unnamed_addr constant [52 x i8] c"\013sony_laptop: couldn't set up rfkill support (%d)\0A\00", align 1
@.str.97 = private unnamed_addr constant [65 x i8] c"\013sony_laptop: couldn't set up keyboard backlight function (%d)\0A\00", align 1
@.str.98 = private unnamed_addr constant [58 x i8] c"\013sony_laptop: couldn't set up low battery function (%d)\0A\00", align 1
@.str.99 = private unnamed_addr constant [56 x i8] c"\013sony_laptop: couldn't set up fan speed function (%d)\0A\00", align 1
@.str.100 = private unnamed_addr constant [56 x i8] c"\013sony_laptop: couldn't set up USB charge support (%d)\0A\00", align 1
@.str.101 = private unnamed_addr constant [55 x i8] c"\013sony_laptop: couldn't set up panel ID function (%d)\0A\00", align 1
@.str.102 = private unnamed_addr constant [59 x i8] c"\013sony_laptop: couldn't set up smart connect support (%d)\0A\00", align 1
@.str.103 = private unnamed_addr constant [5 x i8] c"SN02\00", align 1
@.str.104 = private unnamed_addr constant [5 x i8] c"SN07\00", align 1
@.str.105 = private unnamed_addr constant [57 x i8] c"\014sony_laptop: called SN07 with 0x%.4x (result: 0x%.4x)\0A\00", align 1
@.str.106 = private unnamed_addr constant [53 x i8] c"\014sony_laptop: found handle 0x%.4x (offset: 0x%.2x)\0A\00", align 1
@.str.107 = private unnamed_addr constant [40 x i8] c"\014sony_laptop: handle 0x%.4x not found\0A\00", align 1
@tp_ctl = internal global %struct.touchpad_control* null, align 8
@sony_nc_touchpad_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.108 = private unnamed_addr constant [9 x i8] c"touchpad\00", align 1
@bcare_ctl = internal global %struct.battery_care_control* null, align 8
@sony_nc_battery_care_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.109 = private unnamed_addr constant [21 x i8] c"battery_care_limiter\00", align 1
@sony_nc_battery_care_setup.__key.110 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.111 = private unnamed_addr constant [20 x i8] c"battery_care_health\00", align 1
@lid_ctl = internal global %struct.snc_lid_resume_control* null, align 8
@sony_nc_lid_resume_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.112 = private unnamed_addr constant [14 x i8] c"lid_resume_S5\00", align 1
@sony_nc_lid_resume_setup.__key.113 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.114 = private unnamed_addr constant [14 x i8] c"lid_resume_S4\00", align 1
@sony_nc_lid_resume_setup.__key.115 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.116 = private unnamed_addr constant [14 x i8] c"lid_resume_S3\00", align 1
@th_handle = internal global %struct.snc_thermal_ctrl* null, align 8
@.str.117 = private unnamed_addr constant [54 x i8] c"\014sony_laptop: couldn't to read the thermal profiles\0A\00", align 1
@.str.118 = private unnamed_addr constant [60 x i8] c"\014sony_laptop: couldn't to read the current thermal profile\00", align 1
@sony_nc_thermal_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.119 = private unnamed_addr constant [17 x i8] c"thermal_profiles\00", align 1
@sony_nc_thermal_setup.__key.120 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.121 = private unnamed_addr constant [16 x i8] c"thermal_control\00", align 1
@.str.122 = private unnamed_addr constant [4 x i8] c"%s \00", align 1
@snc_thermal_profiles = internal constant [3 x i8*] [i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.123, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.124, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.125, i32 0, i32 0)], align 16
@.str.123 = private unnamed_addr constant [9 x i8] c"balanced\00", align 1
@.str.124 = private unnamed_addr constant [7 x i8] c"silent\00", align 1
@.str.125 = private unnamed_addr constant [12 x i8] c"performance\00", align 1
@.str.126 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@gfxs_ctl = internal global %struct.snc_gfx_switch_control* null, align 8
@sony_nc_gfx_switch_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.127 = private unnamed_addr constant [18 x i8] c"gfx_switch_status\00", align 1
@.str.128 = private unnamed_addr constant [6 x i8] c"speed\00", align 1
@.str.129 = private unnamed_addr constant [8 x i8] c"stamina\00", align 1
@.str.130 = private unnamed_addr constant [5 x i8] c"auto\00", align 1
@.str.131 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.132 = private unnamed_addr constant [33 x i8] c"\014sony_laptop: GFX Status: 0x%x\0A\00", align 1
@.str.133 = private unnamed_addr constant [56 x i8] c"\016sony_laptop: No High Speed Charging capability found\0A\00", align 1
@hsc_handle = internal global %struct.device_attribute* null, align 8
@sony_nc_highspeed_charging_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.134 = private unnamed_addr constant [27 x i8] c"battery_highspeed_charging\00", align 1
@sony_rfkill_handle = internal global i32 0, align 4
@.str.135 = private unnamed_addr constant [5 x i8] c"SN06\00", align 1
@.str.136 = private unnamed_addr constant [44 x i8] c"\014sony_laptop: Radio devices, found 0x%.2x\0A\00", align 1
@sony_rfkill_devices = internal global [4 x %struct.rfkill*] zeroinitializer, align 16
@.str.137 = private unnamed_addr constant [10 x i8] c"sony-wifi\00", align 1
@.str.138 = private unnamed_addr constant [15 x i8] c"sony-bluetooth\00", align 1
@.str.139 = private unnamed_addr constant [10 x i8] c"sony-wwan\00", align 1
@.str.140 = private unnamed_addr constant [11 x i8] c"sony-wimax\00", align 1
@sony_rfkill_ops = internal constant %struct.rfkill_ops { void (%struct.rfkill*, i8*)* null, void (%struct.rfkill*, i8*)* null, i32 (i8*, i1)* @sony_nc_rfkill_set }, align 8
@sony_rfkill_address = internal global [4 x i32] [i32 768, i32 1280, i32 1792, i32 2304], align 16
@kbdbl_ctl = internal global %struct.kbd_backlight* null, align 8
@.str.141 = private unnamed_addr constant [80 x i8] c"\014sony_laptop: handle 0x%.4x: keyboard backlight setup already done for 0x%.4x\0A\00", align 1
@.str.142 = private unnamed_addr constant [44 x i8] c"\014sony_laptop: no backlight keyboard found\0A\00", align 1
@sony_nc_kbd_backlight_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.143 = private unnamed_addr constant [14 x i8] c"kbd_backlight\00", align 1
@sony_nc_kbd_backlight_setup.__key.144 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.145 = private unnamed_addr constant [22 x i8] c"kbd_backlight_timeout\00", align 1
@lowbatt_handle = internal global %struct.device_attribute* null, align 8
@sony_nc_lowbatt_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.146 = private unnamed_addr constant [18 x i8] c"lowbatt_hibernate\00", align 1
@fan_handle = internal global %struct.device_attribute* null, align 8
@hsf_handle = internal global %struct.device_attribute* null, align 8
@sony_nc_fanspeed_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@sony_nc_fanspeed_setup.__key.147 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.148 = private unnamed_addr constant [11 x i8] c"fan_forced\00", align 1
@.str.149 = private unnamed_addr constant [47 x i8] c"\016sony_laptop: No USB Charge capability found\0A\00", align 1
@uc_handle = internal global %struct.device_attribute* null, align 8
@sony_nc_usb_charge_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.150 = private unnamed_addr constant [11 x i8] c"usb_charge\00", align 1
@panel_handle = internal global %struct.device_attribute* null, align 8
@sony_nc_panelid_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.151 = private unnamed_addr constant [9 x i8] c"panel_id\00", align 1
@sc_handle = internal global %struct.device_attribute* null, align 8
@sony_nc_smart_conn_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.152 = private unnamed_addr constant [14 x i8] c"smart_connect\00", align 1
@sony_backlight_ng_ops = internal constant %struct.backlight_ops { i32 1, i32 (%struct.backlight_device*)* @sony_nc_update_status_ng, i32 (%struct.backlight_device*)* @sony_nc_get_brightness_ng, i32 (%struct.backlight_device*, %struct.fb_info*)* null }, align 8
@sony_backlight_ops = internal constant %struct.backlight_ops { i32 1, i32 (%struct.backlight_device*)* @sony_backlight_update_status, i32 (%struct.backlight_device*)* @sony_backlight_get_brightness, i32 (%struct.backlight_device*, %struct.fb_info*)* null }, align 8
@.str.153 = private unnamed_addr constant [5 x i8] c"sony\00", align 1
@.str.154 = private unnamed_addr constant [52 x i8] c"\014sony_laptop: unable to register backlight device\0A\00", align 1
@.str.155 = private unnamed_addr constant [37 x i8] c"\014sony_laptop: Brightness level: %d\0A\00", align 1
@.str.156 = private unnamed_addr constant [49 x i8] c"\014sony_laptop: Brightness levels: min=%d max=%d\0A\00", align 1
@.str.157 = private unnamed_addr constant [19 x i8] c"brightness_default\00", align 1
@snc_brightness_def_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* null], align 16
@snc_brightness_def_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@.str.158 = private unnamed_addr constant [6 x i8] c"fnkey\00", align 1
@snc_fnkey_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.159 = private unnamed_addr constant [8 x i8] c"cdpower\00", align 1
@snc_cdpower_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.172, i32 0, i32 0), i8* null], align 16
@snc_cdpower_set = internal global [3 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.173, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.174, i32 0, i32 0), i8* null], align 16
@.str.160 = private unnamed_addr constant [11 x i8] c"audiopower\00", align 1
@snc_audiopower_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.175, i32 0, i32 0), i8* null], align 16
@snc_audiopower_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.176, i32 0, i32 0), i8* null], align 16
@.str.161 = private unnamed_addr constant [9 x i8] c"lanpower\00", align 1
@snc_lanpower_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.177, i32 0, i32 0), i8* null], align 16
@snc_lanpower_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.178, i32 0, i32 0), i8* null], align 16
@.str.162 = private unnamed_addr constant [9 x i8] c"lidstate\00", align 1
@snc_lidstate_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.179, i32 0, i32 0), i8* null], align 16
@.str.163 = private unnamed_addr constant [14 x i8] c"indicatorlamp\00", align 1
@snc_indicatorlamp_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.180, i32 0, i32 0), i8* null], align 16
@snc_indicatorlamp_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.181, i32 0, i32 0), i8* null], align 16
@.str.164 = private unnamed_addr constant [9 x i8] c"gainbass\00", align 1
@snc_gainbass_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.182, i32 0, i32 0), i8* null], align 16
@snc_gainbass_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.183, i32 0, i32 0), i8* null], align 16
@.str.165 = private unnamed_addr constant [4 x i8] c"PID\00", align 1
@snc_PID_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.184, i32 0, i32 0), i8* null], align 16
@.str.166 = private unnamed_addr constant [4 x i8] c"CTR\00", align 1
@snc_CTR_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.185, i32 0, i32 0), i8* null], align 16
@snc_CTR_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.186, i32 0, i32 0), i8* null], align 16
@.str.167 = private unnamed_addr constant [4 x i8] c"PCR\00", align 1
@snc_PCR_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.187, i32 0, i32 0), i8* null], align 16
@snc_PCR_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.188, i32 0, i32 0), i8* null], align 16
@.str.168 = private unnamed_addr constant [4 x i8] c"CMI\00", align 1
@snc_CMI_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.189, i32 0, i32 0), i8* null], align 16
@snc_CMI_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.190, i32 0, i32 0), i8* null], align 16
@.str.169 = private unnamed_addr constant [5 x i8] c"GPBR\00", align 1
@.str.170 = private unnamed_addr constant [5 x i8] c"SPBR\00", align 1
@.str.171 = private unnamed_addr constant [5 x i8] c"GHKE\00", align 1
@.str.172 = private unnamed_addr constant [5 x i8] c"GCDP\00", align 1
@.str.173 = private unnamed_addr constant [5 x i8] c"SCDP\00", align 1
@.str.174 = private unnamed_addr constant [5 x i8] c"CDPW\00", align 1
@.str.175 = private unnamed_addr constant [5 x i8] c"GAZP\00", align 1
@.str.176 = private unnamed_addr constant [5 x i8] c"AZPW\00", align 1
@.str.177 = private unnamed_addr constant [5 x i8] c"GLNP\00", align 1
@.str.178 = private unnamed_addr constant [5 x i8] c"LNPW\00", align 1
@.str.179 = private unnamed_addr constant [5 x i8] c"GLID\00", align 1
@.str.180 = private unnamed_addr constant [5 x i8] c"GILS\00", align 1
@.str.181 = private unnamed_addr constant [5 x i8] c"SILS\00", align 1
@.str.182 = private unnamed_addr constant [5 x i8] c"GMGB\00", align 1
@.str.183 = private unnamed_addr constant [5 x i8] c"CMGB\00", align 1
@.str.184 = private unnamed_addr constant [5 x i8] c"GPID\00", align 1
@.str.185 = private unnamed_addr constant [5 x i8] c"GCTR\00", align 1
@.str.186 = private unnamed_addr constant [5 x i8] c"SCTR\00", align 1
@.str.187 = private unnamed_addr constant [5 x i8] c"GPCR\00", align 1
@.str.188 = private unnamed_addr constant [5 x i8] c"SPCR\00", align 1
@.str.189 = private unnamed_addr constant [5 x i8] c"GCMI\00", align 1
@.str.190 = private unnamed_addr constant [5 x i8] c"SCMI\00", align 1
@.str.191 = private unnamed_addr constant [5 x i8] c"SN01\00", align 1
@.str.192 = private unnamed_addr constant [5 x i8] c"SN03\00", align 1
@.str.193 = private unnamed_addr constant [54 x i8] c"\014sony_laptop: Sony Notebook Control Driver removed.\0A\00", align 1
@.str.194 = private unnamed_addr constant [46 x i8] c"\014sony_laptop: sony_nc_notify, event: 0x%.2x\0A\00", align 1
@.str.195 = private unnamed_addr constant [56 x i8] c"\013sony_laptop: Event 0x%x outside of capabilities list\0A\00", align 1
@.str.196 = private unnamed_addr constant [55 x i8] c"\014sony_laptop: GFX switch event received (reason: %s)\0A\00", align 1
@.str.197 = private unnamed_addr constant [14 x i8] c"switch change\00", align 1
@.str.198 = private unnamed_addr constant [14 x i8] c"output switch\00", align 1
@.str.199 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.200 = private unnamed_addr constant [51 x i8] c"\014sony_laptop: Unknown event 0x%x for handle 0x%x\0A\00", align 1
@.str.201 = private unnamed_addr constant [5 x i8] c"SN05\00", align 1
@.str.202 = private unnamed_addr constant [53 x i8] c"\014sony_laptop: Unable to decode event 0x%.2x 0x%.2x\0A\00", align 1
@sony_100_events = internal global [43 x %struct.sony_nc_event] [%struct.sony_nc_event { i8 -112, i8 32 }, %struct.sony_nc_event { i8 16, i8 56 }, %struct.sony_nc_event { i8 -111, i8 33 }, %struct.sony_nc_event { i8 17, i8 56 }, %struct.sony_nc_event { i8 -127, i8 12 }, %struct.sony_nc_event { i8 1, i8 59 }, %struct.sony_nc_event { i8 -126, i8 13 }, %struct.sony_nc_event { i8 2, i8 59 }, %struct.sony_nc_event { i8 -125, i8 14 }, %struct.sony_nc_event { i8 3, i8 59 }, %struct.sony_nc_event { i8 -124, i8 15 }, %struct.sony_nc_event { i8 4, i8 59 }, %struct.sony_nc_event { i8 -123, i8 16 }, %struct.sony_nc_event { i8 5, i8 59 }, %struct.sony_nc_event { i8 -122, i8 17 }, %struct.sony_nc_event { i8 6, i8 59 }, %struct.sony_nc_event { i8 -121, i8 18 }, %struct.sony_nc_event { i8 7, i8 59 }, %struct.sony_nc_event { i8 -120, i8 19 }, %struct.sony_nc_event { i8 8, i8 59 }, %struct.sony_nc_event { i8 -119, i8 20 }, %struct.sony_nc_event { i8 9, i8 59 }, %struct.sony_nc_event { i8 -118, i8 21 }, %struct.sony_nc_event { i8 10, i8 59 }, %struct.sony_nc_event { i8 -117, i8 22 }, %struct.sony_nc_event { i8 11, i8 59 }, %struct.sony_nc_event { i8 -116, i8 23 }, %struct.sony_nc_event { i8 12, i8 59 }, %struct.sony_nc_event { i8 -99, i8 50 }, %struct.sony_nc_event { i8 29, i8 56 }, %struct.sony_nc_event { i8 -97, i8 64 }, %struct.sony_nc_event { i8 31, i8 56 }, %struct.sony_nc_event { i8 -95, i8 72 }, %struct.sony_nc_event { i8 33, i8 56 }, %struct.sony_nc_event { i8 -92, i8 64 }, %struct.sony_nc_event { i8 36, i8 56 }, %struct.sony_nc_event { i8 -91, i8 73 }, %struct.sony_nc_event { i8 37, i8 56 }, %struct.sony_nc_event { i8 -90, i8 40 }, %struct.sony_nc_event { i8 38, i8 56 }, %struct.sony_nc_event { i8 -88, i8 24 }, %struct.sony_nc_event { i8 40, i8 56 }, %struct.sony_nc_event zeroinitializer], align 16
@sony_127_events = internal global [15 x %struct.sony_nc_event] [%struct.sony_nc_event { i8 -127, i8 65 }, %struct.sony_nc_event { i8 1, i8 56 }, %struct.sony_nc_event { i8 -126, i8 32 }, %struct.sony_nc_event { i8 2, i8 56 }, %struct.sony_nc_event { i8 -125, i8 33 }, %struct.sony_nc_event { i8 3, i8 56 }, %struct.sony_nc_event { i8 -124, i8 34 }, %struct.sony_nc_event { i8 4, i8 56 }, %struct.sony_nc_event { i8 -123, i8 66 }, %struct.sony_nc_event { i8 5, i8 56 }, %struct.sony_nc_event { i8 -122, i8 67 }, %struct.sony_nc_event { i8 6, i8 56 }, %struct.sony_nc_event { i8 -121, i8 68 }, %struct.sony_nc_event { i8 7, i8 56 }, %struct.sony_nc_event zeroinitializer], align 16
@.str.203 = private unnamed_addr constant [61 x i8] c"\016sony_laptop: Unknown hotkey 0x%.2x/0x%.2x (handle 0x%.2x)\0A\00", align 1
@.str.204 = private unnamed_addr constant [23 x i8] c"\013sony_laptop: %s: %d\0A\00", align 1
@__func__.sony_nc_resume = private unnamed_addr constant [15 x i8] c"sony_nc_resume\00", align 1
@.str.205 = private unnamed_addr constant [36 x i8] c"\014sony_laptop: Resuming SNC device\0A\00", align 1
@llvm.used = appending global [28 x i8*] [i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__UNIQUE_ID_author12, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__UNIQUE_ID_description13, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license14, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_debug to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_debugtype15, i32 0, i32 0), i8* getelementptr inbounds ([87 x i8], [87 x i8]* @__UNIQUE_ID_debug16, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_no_spic to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_no_spictype17, i32 0, i32 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @__UNIQUE_ID_no_spic18, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_compat to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_compattype19, i32 0, i32 0), i8* getelementptr inbounds ([71 x i8], [71 x i8]* @__UNIQUE_ID_compat20, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_mask to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_masktype21, i32 0, i32 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @__UNIQUE_ID_mask22, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_camera to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_cameratype23, i32 0, i32 0), i8* getelementptr inbounds ([110 x i8], [110 x i8]* @__UNIQUE_ID_camera24, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_minor to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_minortype25, i32 0, i32 0), i8* getelementptr inbounds ([102 x i8], [102 x i8]* @__UNIQUE_ID_minor26, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_kbd_backlight to i8*), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__UNIQUE_ID_kbd_backlighttype27, i32 0, i32 0), i8* getelementptr inbounds ([169 x i8], [169 x i8]* @__UNIQUE_ID_kbd_backlight28, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_kbd_backlight_timeout to i8*), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__UNIQUE_ID_kbd_backlight_timeouttype29, i32 0, i32 0), i8* getelementptr inbounds ([141 x i8], [141 x i8]* @__UNIQUE_ID_kbd_backlight_timeout30, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sony_pic_camera_command to i8*)], section "llvm.metadata"

@__mod_acpi__sony_device_ids_device_table = alias [3 x %struct.acpi_device_id], [3 x %struct.acpi_device_id]* @sony_device_ids
@cleanup_module = alias void (), void ()* @sony_laptop_exit

; Function Attrs: nounwind uwtable
define i32 @sony_pic_camera_command(i32 %command, i8 zeroext %value) #0 {
entry:
  %0 = load i32, i32* @camera, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %Pivot26 = icmp slt i32 %command, 10
  br i1 %Pivot26, label %NodeBlock9, label %NodeBlock23

NodeBlock23:                                      ; preds = %if.end
  %Pivot24 = icmp slt i32 %command, 14
  br i1 %Pivot24, label %NodeBlock15, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %command, 16
  br i1 %Pivot22, label %LeafBlock17, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %command, 16
  br i1 %SwitchLeaf20, label %sw.bb126, label %sw.default

LeafBlock17:                                      ; preds = %NodeBlock21
  %SwitchLeaf18 = icmp eq i32 %command, 14
  br i1 %SwitchLeaf18, label %sw.bb104, label %sw.default

NodeBlock15:                                      ; preds = %NodeBlock23
  %Pivot16 = icmp slt i32 %command, 12
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %command, 12
  br i1 %SwitchLeaf14, label %sw.bb82, label %sw.default

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %command, 10
  br i1 %SwitchLeaf12, label %sw.bb60, label %sw.default

NodeBlock9:                                       ; preds = %if.end
  %Pivot10 = icmp slt i32 %command, 6
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %command, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %command, 8
  br i1 %SwitchLeaf6, label %sw.bb38, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %command, 6
  br i1 %SwitchLeaf4, label %sw.bb16, label %sw.default

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %command, 4
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %command, 4
  br i1 %SwitchLeaf2, label %sw.bb5, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %command, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %tobool1 = icmp ne i8 %value, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %sw.bb
  call void @__sony_pic_camera_on()
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb
  call void @__sony_pic_camera_off()
  br label %sw.epilog

sw.bb5:                                           ; preds = %LeafBlock1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.bb5
  %n.0 = phi i32 [ 10, %sw.bb5 ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %call7 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 0, i8 zeroext %value)
  %conv = zext i8 %call7 to i32
  %tobool8 = icmp ne i32 %conv, 0
  br i1 %tobool8, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool9 = icmp eq i32 %dec, 0
  %1 = load i32, i32* @debug, align 4
  %tobool11 = icmp ne i32 %1, 0
  %or.cond = and i1 %tobool9, %tobool11
  br i1 %or.cond, label %if.then12, label %sw.epilog

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !2
  %tobool11.old = icmp ne i32 %.old, 0
  br i1 %tobool11.old, label %if.then12, label %sw.epilog

if.then12:                                        ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb16:                                          ; preds = %LeafBlock3
  br label %while.cond18

while.cond18:                                     ; preds = %while.body26, %sw.bb16
  %n17.0 = phi i32 [ 10, %sw.bb16 ], [ %dec19, %while.body26 ]
  %dec19 = add i32 %n17.0, -1
  %cond27 = icmp eq i32 %dec19, 0
  br i1 %cond27, label %do.body30, label %land.rhs21

land.rhs21:                                       ; preds = %while.cond18
  %call22 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 1, i8 zeroext %value)
  %conv23 = zext i8 %call22 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  br i1 %tobool24, label %while.body26, label %while.end27

while.body26:                                     ; preds = %land.rhs21
  call void @__const_udelay(i64 4295)
  br label %while.cond18

while.end27:                                      ; preds = %land.rhs21
  %tobool28 = icmp eq i32 %dec19, 0
  %2 = load i32, i32* @debug, align 4
  %tobool31 = icmp ne i32 %2, 0
  %or.cond29 = and i1 %tobool28, %tobool31
  br i1 %or.cond29, label %if.then32, label %sw.epilog

do.body30:                                        ; preds = %while.cond18
  %.old28 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool31.old = icmp ne i32 %.old28, 0
  br i1 %tobool31.old, label %if.then32, label %sw.epilog

if.then32:                                        ; preds = %do.body30, %while.end27
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb38:                                          ; preds = %LeafBlock5
  br label %while.cond40

while.cond40:                                     ; preds = %while.body48, %sw.bb38
  %n39.0 = phi i32 [ 10, %sw.bb38 ], [ %dec41, %while.body48 ]
  %dec41 = add i32 %n39.0, -1
  %cond30 = icmp eq i32 %dec41, 0
  br i1 %cond30, label %do.body52, label %land.rhs43

land.rhs43:                                       ; preds = %while.cond40
  %call44 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 2, i8 zeroext %value)
  %conv45 = zext i8 %call44 to i32
  %tobool46 = icmp ne i32 %conv45, 0
  br i1 %tobool46, label %while.body48, label %while.end49

while.body48:                                     ; preds = %land.rhs43
  call void @__const_udelay(i64 4295)
  br label %while.cond40

while.end49:                                      ; preds = %land.rhs43
  %tobool50 = icmp eq i32 %dec41, 0
  %3 = load i32, i32* @debug, align 4
  %tobool53 = icmp ne i32 %3, 0
  %or.cond32 = and i1 %tobool50, %tobool53
  br i1 %or.cond32, label %if.then54, label %sw.epilog

do.body52:                                        ; preds = %while.cond40
  %.old31 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool53.old = icmp ne i32 %.old31, 0
  br i1 %tobool53.old, label %if.then54, label %sw.epilog

if.then54:                                        ; preds = %do.body52, %while.end49
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb60:                                          ; preds = %LeafBlock11
  br label %while.cond62

while.cond62:                                     ; preds = %while.body70, %sw.bb60
  %n61.0 = phi i32 [ 10, %sw.bb60 ], [ %dec63, %while.body70 ]
  %dec63 = add i32 %n61.0, -1
  %cond33 = icmp eq i32 %dec63, 0
  br i1 %cond33, label %do.body74, label %land.rhs65

land.rhs65:                                       ; preds = %while.cond62
  %call66 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 3, i8 zeroext %value)
  %conv67 = zext i8 %call66 to i32
  %tobool68 = icmp ne i32 %conv67, 0
  br i1 %tobool68, label %while.body70, label %while.end71

while.body70:                                     ; preds = %land.rhs65
  call void @__const_udelay(i64 4295)
  br label %while.cond62

while.end71:                                      ; preds = %land.rhs65
  %tobool72 = icmp eq i32 %dec63, 0
  %4 = load i32, i32* @debug, align 4
  %tobool75 = icmp ne i32 %4, 0
  %or.cond35 = and i1 %tobool72, %tobool75
  br i1 %or.cond35, label %if.then76, label %sw.epilog

do.body74:                                        ; preds = %while.cond62
  %.old34 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool75.old = icmp ne i32 %.old34, 0
  br i1 %tobool75.old, label %if.then76, label %sw.epilog

if.then76:                                        ; preds = %do.body74, %while.end71
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb82:                                          ; preds = %LeafBlock13
  br label %while.cond84

while.cond84:                                     ; preds = %while.body92, %sw.bb82
  %n83.0 = phi i32 [ 10, %sw.bb82 ], [ %dec85, %while.body92 ]
  %dec85 = add i32 %n83.0, -1
  %cond36 = icmp eq i32 %dec85, 0
  br i1 %cond36, label %do.body96, label %land.rhs87

land.rhs87:                                       ; preds = %while.cond84
  %call88 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 4, i8 zeroext %value)
  %conv89 = zext i8 %call88 to i32
  %tobool90 = icmp ne i32 %conv89, 0
  br i1 %tobool90, label %while.body92, label %while.end93

while.body92:                                     ; preds = %land.rhs87
  call void @__const_udelay(i64 4295)
  br label %while.cond84

while.end93:                                      ; preds = %land.rhs87
  %tobool94 = icmp eq i32 %dec85, 0
  %5 = load i32, i32* @debug, align 4
  %tobool97 = icmp ne i32 %5, 0
  %or.cond38 = and i1 %tobool94, %tobool97
  br i1 %or.cond38, label %if.then98, label %sw.epilog

do.body96:                                        ; preds = %while.cond84
  %.old37 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool97.old = icmp ne i32 %.old37, 0
  br i1 %tobool97.old, label %if.then98, label %sw.epilog

if.then98:                                        ; preds = %do.body96, %while.end93
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb104:                                         ; preds = %LeafBlock17
  br label %while.cond106

while.cond106:                                    ; preds = %while.body114, %sw.bb104
  %n105.0 = phi i32 [ 10, %sw.bb104 ], [ %dec107, %while.body114 ]
  %dec107 = add i32 %n105.0, -1
  %cond39 = icmp eq i32 %dec107, 0
  br i1 %cond39, label %do.body118, label %land.rhs109

land.rhs109:                                      ; preds = %while.cond106
  %call110 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 5, i8 zeroext %value)
  %conv111 = zext i8 %call110 to i32
  %tobool112 = icmp ne i32 %conv111, 0
  br i1 %tobool112, label %while.body114, label %while.end115

while.body114:                                    ; preds = %land.rhs109
  call void @__const_udelay(i64 4295)
  br label %while.cond106

while.end115:                                     ; preds = %land.rhs109
  %tobool116 = icmp eq i32 %dec107, 0
  %6 = load i32, i32* @debug, align 4
  %tobool119 = icmp ne i32 %6, 0
  %or.cond41 = and i1 %tobool116, %tobool119
  br i1 %or.cond41, label %if.then120, label %sw.epilog

do.body118:                                       ; preds = %while.cond106
  %.old40 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool119.old = icmp ne i32 %.old40, 0
  br i1 %tobool119.old, label %if.then120, label %sw.epilog

if.then120:                                       ; preds = %do.body118, %while.end115
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb126:                                         ; preds = %LeafBlock19
  br label %while.cond128

while.cond128:                                    ; preds = %while.body136, %sw.bb126
  %n127.0 = phi i32 [ 10, %sw.bb126 ], [ %dec129, %while.body136 ]
  %dec129 = add i32 %n127.0, -1
  %cond42 = icmp eq i32 %dec129, 0
  br i1 %cond42, label %do.body140, label %land.rhs131

land.rhs131:                                      ; preds = %while.cond128
  %call132 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 6, i8 zeroext %value)
  %conv133 = zext i8 %call132 to i32
  %tobool134 = icmp ne i32 %conv133, 0
  br i1 %tobool134, label %while.body136, label %while.end137

while.body136:                                    ; preds = %land.rhs131
  call void @__const_udelay(i64 4295)
  br label %while.cond128

while.end137:                                     ; preds = %land.rhs131
  %tobool138 = icmp eq i32 %dec129, 0
  %7 = load i32, i32* @debug, align 4
  %tobool141 = icmp ne i32 %7, 0
  %or.cond44 = and i1 %tobool138, %tobool141
  br i1 %or.cond44, label %if.then142, label %sw.epilog

do.body140:                                       ; preds = %while.cond128
  %.old43 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool141.old = icmp ne i32 %.old43, 0
  br i1 %tobool141.old, label %if.then142, label %sw.epilog

if.then142:                                       ; preds = %do.body140, %while.end137
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock11, %LeafBlock13, %LeafBlock17, %LeafBlock19
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.then142, %do.body140, %while.end137, %if.then120, %do.body118, %while.end115, %if.then98, %do.body96, %while.end93, %if.then76, %do.body74, %while.end71, %if.then54, %do.body52, %while.end49, %if.then32, %do.body30, %while.end27, %if.then12, %do.body, %while.end, %if.else, %if.then2
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  br label %return

return:                                           ; preds = %sw.epilog, %entry
  %retval.0 = phi i32 [ 0, %sw.epilog ], [ -5, %entry ]
  ret i32 %retval.0
}

declare void @mutex_lock_nested(%struct.mutex*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @__sony_pic_camera_on() #0 {
entry:
  %0 = load i32, i32* @camera, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %1 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !6
  %tobool1 = icmp ne i8 %1, 0
  br i1 %tobool1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc23, %if.end3
  %j.0 = phi i32 [ 5, %if.end3 ], [ %dec24, %for.inc23 ]
  %cmp = icmp sgt i32 %j.0, 0
  br i1 %cmp, label %for.body, label %for.end25

for.body:                                         ; preds = %for.cond
  br label %for.cond4

for.cond4:                                        ; preds = %for.body8, %for.body
  %x.0 = phi i32 [ 0, %for.body ], [ %inc, %for.body8 ]
  %cmp5 = icmp slt i32 %x.0, 100
  br i1 %cmp5, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond4
  %call6 = call zeroext i8 @sony_pic_call2(i8 zeroext -111, i8 zeroext 1)
  %conv = zext i8 %call6 to i32
  %tobool7 = icmp ne i32 %conv, 0
  br i1 %tobool7, label %for.body8, label %for.end

for.body8:                                        ; preds = %land.rhs
  call void @msleep(i32 10)
  %inc = add nsw i32 %x.0, 1
  br label %for.cond4

for.end:                                          ; preds = %land.rhs, %for.cond4
  call void @sony_pic_call1(i8 zeroext -109)
  br label %for.cond10

for.cond10:                                       ; preds = %if.end17, %for.end
  %i.0 = phi i32 [ 400, %for.end ], [ %dec, %if.end17 ]
  %cmp11 = icmp sgt i32 %i.0, 0
  br i1 %cmp11, label %for.body13, label %for.end19

for.body13:                                       ; preds = %for.cond10
  %call14 = call i32 @__sony_pic_camera_ready()
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %for.end19, label %if.end17

if.end17:                                         ; preds = %for.body13
  call void @msleep(i32 10)
  %dec = add nsw i32 %i.0, -1
  br label %for.cond10

for.end19:                                        ; preds = %for.body13, %for.cond10
  %tobool20 = icmp ne i32 %i.0, 0
  br i1 %tobool20, label %for.end25, label %for.inc23

for.inc23:                                        ; preds = %for.end19
  %dec24 = add nsw i32 %j.0, -1
  br label %for.cond

for.end25:                                        ; preds = %for.end19, %for.cond
  %cmp26 = icmp eq i32 %j.0, 0
  br i1 %cmp26, label %if.then28, label %if.end30

if.then28:                                        ; preds = %for.end25
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end30:                                         ; preds = %for.end25
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end30
  %n.0 = phi i32 [ 10, %if.end30 ], [ %dec31, %while.body ]
  %dec31 = add i32 %n.0, -1
  %cond = icmp eq i32 %dec31, 0
  br i1 %cond, label %do.body, label %land.rhs33

land.rhs33:                                       ; preds = %while.cond
  %call34 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 16, i8 zeroext 90)
  %conv35 = zext i8 %call34 to i32
  %tobool36 = icmp ne i32 %conv35, 0
  br i1 %tobool36, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs33
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs33
  %tobool38 = icmp eq i32 %dec31, 0
  %2 = load i32, i32* @debug, align 4
  %tobool40 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool38, %tobool40
  br i1 %or.cond, label %if.then41, label %if.end44

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !2
  %tobool40.old = icmp ne i32 %.old, 0
  br i1 %tobool40.old, label %if.then41, label %if.end44

if.then41:                                        ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %if.end44

if.end44:                                         ; preds = %if.then41, %do.body, %while.end
  store i8 1, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !6
  br label %cleanup

cleanup:                                          ; preds = %if.end44, %if.then28, %if.end, %if.then
  %retval.0 = phi i32 [ -19, %if.then28 ], [ 0, %if.end44 ], [ -19, %if.then ], [ 0, %if.end ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__sony_pic_camera_off() #0 {
entry:
  %0 = load i32, i32* @camera, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %n.0 = phi i32 [ 10, %if.end ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %call2 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 5, i8 zeroext 64)
  %conv = zext i8 %call2 to i32
  %tobool3 = icmp ne i32 %conv, 0
  br i1 %tobool3, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool4 = icmp eq i32 %dec, 0
  %1 = load i32, i32* @debug, align 4
  %tobool6 = icmp ne i32 %1, 0
  %or.cond = and i1 %tobool4, %tobool6
  br i1 %or.cond, label %if.then7, label %if.end10

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !2
  %tobool6.old = icmp ne i32 %.old, 0
  br i1 %tobool6.old, label %if.then7, label %if.end10

if.then7:                                         ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %do.body, %while.end
  %2 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !6
  %tobool11 = icmp ne i8 %2, 0
  br i1 %tobool11, label %if.then12, label %return

if.then12:                                        ; preds = %if.end10
  %call13 = call zeroext i8 @sony_pic_call2(i8 zeroext -111, i8 zeroext 0)
  store i8 0, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !6
  br label %return

return:                                           ; preds = %if.then12, %if.end10, %if.then
  %retval.0 = phi i32 [ -19, %if.then ], [ 0, %if.then12 ], [ 0, %if.end10 ]
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

; Function Attrs: nounwind uwtable
define internal zeroext i8 @sony_pic_call3(i8 zeroext %dev, i8 zeroext %fn, i8 zeroext %v) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %n.0 = phi i32 [ 10000, %entry ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %0 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %0, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %1 = load i16, i16* %minimum, align 1, !tbaa !19
  %conv = zext i16 %1 to i32
  %add = add nsw i32 %conv, 4
  %call = call zeroext i8 @inb_p(i32 %add)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp eq i32 %dec, 0
  %2 = load i32, i32* @debug, align 4
  %tobool4 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool3, %tobool4
  br i1 %or.cond, label %if.then5, label %if.end7

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !2
  %tobool4.old = icmp ne i32 %.old, 0
  br i1 %tobool4.old, label %if.then5, label %if.end7

if.then5:                                         ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %do.body, %while.end
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io18 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 0
  %minimum9 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io18, i32 0, i32 3
  %4 = load i16, i16* %minimum9, align 1, !tbaa !19
  %conv10 = zext i16 %4 to i32
  %add11 = add nsw i32 %conv10, 4
  call void @outb(i8 zeroext %dev, i32 %add11)
  br label %while.cond13

while.cond13:                                     ; preds = %while.body26, %if.end7
  %n12.0 = phi i32 [ 10000, %if.end7 ], [ %dec14, %while.body26 ]
  %dec14 = add i32 %n12.0, -1
  %cond1 = icmp eq i32 %dec14, 0
  br i1 %cond1, label %do.body30, label %land.rhs16

land.rhs16:                                       ; preds = %while.cond13
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io117 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum18 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io117, i32 0, i32 3
  %6 = load i16, i16* %minimum18, align 1, !tbaa !19
  %conv19 = zext i16 %6 to i32
  %add20 = add nsw i32 %conv19, 4
  %call21 = call zeroext i8 @inb_p(i32 %add20)
  %conv22 = zext i8 %call21 to i32
  %and23 = and i32 %conv22, 2
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %while.body26, label %while.end27

while.body26:                                     ; preds = %land.rhs16
  call void @__const_udelay(i64 4295)
  br label %while.cond13

while.end27:                                      ; preds = %land.rhs16
  %tobool28 = icmp eq i32 %dec14, 0
  %7 = load i32, i32* @debug, align 4
  %tobool31 = icmp ne i32 %7, 0
  %or.cond3 = and i1 %tobool28, %tobool31
  br i1 %or.cond3, label %if.then32, label %if.end37

do.body30:                                        ; preds = %while.cond13
  %.old2 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool31.old = icmp ne i32 %.old2, 0
  br i1 %tobool31.old, label %if.then32, label %if.end37

if.then32:                                        ; preds = %do.body30, %while.end27
  call void (i8*, ...) @printk(i8* null)
  br label %if.end37

if.end37:                                         ; preds = %if.then32, %do.body30, %while.end27
  %8 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io138 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %8, i32 0, i32 0
  %minimum39 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io138, i32 0, i32 3
  %9 = load i16, i16* %minimum39, align 1, !tbaa !19
  %conv40 = zext i16 %9 to i32
  call void @outb(i8 zeroext %fn, i32 %conv40)
  br label %while.cond42

while.cond42:                                     ; preds = %while.body55, %if.end37
  %n41.0 = phi i32 [ 10000, %if.end37 ], [ %dec43, %while.body55 ]
  %dec43 = add i32 %n41.0, -1
  %cond4 = icmp eq i32 %dec43, 0
  br i1 %cond4, label %do.body59, label %land.rhs45

land.rhs45:                                       ; preds = %while.cond42
  %10 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io146 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %10, i32 0, i32 0
  %minimum47 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io146, i32 0, i32 3
  %11 = load i16, i16* %minimum47, align 1, !tbaa !19
  %conv48 = zext i16 %11 to i32
  %add49 = add nsw i32 %conv48, 4
  %call50 = call zeroext i8 @inb_p(i32 %add49)
  %conv51 = zext i8 %call50 to i32
  %and52 = and i32 %conv51, 2
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %while.body55, label %while.end56

while.body55:                                     ; preds = %land.rhs45
  call void @__const_udelay(i64 4295)
  br label %while.cond42

while.end56:                                      ; preds = %land.rhs45
  %tobool57 = icmp eq i32 %dec43, 0
  %12 = load i32, i32* @debug, align 4
  %tobool60 = icmp ne i32 %12, 0
  %or.cond6 = and i1 %tobool57, %tobool60
  br i1 %or.cond6, label %if.then61, label %if.end66

do.body59:                                        ; preds = %while.cond42
  %.old5 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool60.old = icmp ne i32 %.old5, 0
  br i1 %tobool60.old, label %if.then61, label %if.end66

if.then61:                                        ; preds = %do.body59, %while.end56
  call void (i8*, ...) @printk(i8* null)
  br label %if.end66

if.end66:                                         ; preds = %if.then61, %do.body59, %while.end56
  %13 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io167 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %13, i32 0, i32 0
  %minimum68 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io167, i32 0, i32 3
  %14 = load i16, i16* %minimum68, align 1, !tbaa !19
  %conv69 = zext i16 %14 to i32
  call void @outb(i8 zeroext %v, i32 %conv69)
  %15 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io170 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 0
  %minimum71 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io170, i32 0, i32 3
  %16 = load i16, i16* %minimum71, align 1, !tbaa !19
  %conv72 = zext i16 %16 to i32
  %call73 = call zeroext i8 @inb_p(i32 %conv72)
  %17 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool75 = icmp ne i32 %17, 0
  br i1 %tobool75, label %if.then76, label %do.end84

if.then76:                                        ; preds = %if.end66
  call void (i8*, ...) @printk(i8* null)
  br label %do.end84

do.end84:                                         ; preds = %if.then76, %if.end66
  ret i8 %call73
}

declare void @__const_udelay(i64) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: nounwind uwtable
declare i32 @sony_laptop_init() #3 section ".init.text"

; Function Attrs: nounwind uwtable
define internal void @sony_laptop_exit() #3 section ".exit.text" {
entry:
  call void @acpi_bus_unregister_driver(%struct.acpi_driver* @sony_nc_driver)
  %0 = load i32, i32* @spic_drv_registered, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @acpi_bus_unregister_driver(%struct.acpi_driver* @sony_pic_driver)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @sony_pic_call2(i8 zeroext %dev, i8 zeroext %fn) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %n.0 = phi i32 [ 10000, %entry ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %0 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %0, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %1 = load i16, i16* %minimum, align 1, !tbaa !19
  %conv = zext i16 %1 to i32
  %add = add nsw i32 %conv, 4
  %call = call zeroext i8 @inb_p(i32 %add)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp eq i32 %dec, 0
  %2 = load i32, i32* @debug, align 4
  %tobool4 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool3, %tobool4
  br i1 %or.cond, label %if.then5, label %if.end7

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !2
  %tobool4.old = icmp ne i32 %.old, 0
  br i1 %tobool4.old, label %if.then5, label %if.end7

if.then5:                                         ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %do.body, %while.end
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io18 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 0
  %minimum9 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io18, i32 0, i32 3
  %4 = load i16, i16* %minimum9, align 1, !tbaa !19
  %conv10 = zext i16 %4 to i32
  %add11 = add nsw i32 %conv10, 4
  call void @outb(i8 zeroext %dev, i32 %add11)
  br label %while.cond13

while.cond13:                                     ; preds = %while.body26, %if.end7
  %n12.0 = phi i32 [ 10000, %if.end7 ], [ %dec14, %while.body26 ]
  %dec14 = add i32 %n12.0, -1
  %cond1 = icmp eq i32 %dec14, 0
  br i1 %cond1, label %do.body30, label %land.rhs16

land.rhs16:                                       ; preds = %while.cond13
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io117 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum18 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io117, i32 0, i32 3
  %6 = load i16, i16* %minimum18, align 1, !tbaa !19
  %conv19 = zext i16 %6 to i32
  %add20 = add nsw i32 %conv19, 4
  %call21 = call zeroext i8 @inb_p(i32 %add20)
  %conv22 = zext i8 %call21 to i32
  %and23 = and i32 %conv22, 2
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %while.body26, label %while.end27

while.body26:                                     ; preds = %land.rhs16
  call void @__const_udelay(i64 4295)
  br label %while.cond13

while.end27:                                      ; preds = %land.rhs16
  %tobool28 = icmp eq i32 %dec14, 0
  %7 = load i32, i32* @debug, align 4
  %tobool31 = icmp ne i32 %7, 0
  %or.cond3 = and i1 %tobool28, %tobool31
  br i1 %or.cond3, label %if.then32, label %if.end37

do.body30:                                        ; preds = %while.cond13
  %.old2 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool31.old = icmp ne i32 %.old2, 0
  br i1 %tobool31.old, label %if.then32, label %if.end37

if.then32:                                        ; preds = %do.body30, %while.end27
  call void (i8*, ...) @printk(i8* null)
  br label %if.end37

if.end37:                                         ; preds = %if.then32, %do.body30, %while.end27
  %8 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io138 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %8, i32 0, i32 0
  %minimum39 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io138, i32 0, i32 3
  %9 = load i16, i16* %minimum39, align 1, !tbaa !19
  %conv40 = zext i16 %9 to i32
  call void @outb(i8 zeroext %fn, i32 %conv40)
  %10 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io141 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %10, i32 0, i32 0
  %minimum42 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io141, i32 0, i32 3
  %11 = load i16, i16* %minimum42, align 1, !tbaa !19
  %conv43 = zext i16 %11 to i32
  %call44 = call zeroext i8 @inb_p(i32 %conv43)
  %12 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool46 = icmp ne i32 %12, 0
  br i1 %tobool46, label %if.then47, label %do.end54

if.then47:                                        ; preds = %if.end37
  call void (i8*, ...) @printk(i8* null)
  br label %do.end54

do.end54:                                         ; preds = %if.then47, %if.end37
  ret i8 %call44
}

declare void @msleep(i32) #1

; Function Attrs: nounwind uwtable
define internal void @sony_pic_call1(i8 zeroext %dev) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %n.0 = phi i32 [ 10000, %entry ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %0 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %0, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %1 = load i16, i16* %minimum, align 1, !tbaa !19
  %conv = zext i16 %1 to i32
  %add = add nsw i32 %conv, 4
  %call = call zeroext i8 @inb_p(i32 %add)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp eq i32 %dec, 0
  %2 = load i32, i32* @debug, align 4
  %tobool4 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool3, %tobool4
  br i1 %or.cond, label %if.then5, label %if.end7

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !2
  %tobool4.old = icmp ne i32 %.old, 0
  br i1 %tobool4.old, label %if.then5, label %if.end7

if.then5:                                         ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %do.body, %while.end
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io18 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 0
  %minimum9 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io18, i32 0, i32 3
  %4 = load i16, i16* %minimum9, align 1, !tbaa !19
  %conv10 = zext i16 %4 to i32
  %add11 = add nsw i32 %conv10, 4
  call void @outb(i8 zeroext %dev, i32 %add11)
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io112 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum13 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io112, i32 0, i32 3
  %6 = load i16, i16* %minimum13, align 1, !tbaa !19
  %conv14 = zext i16 %6 to i32
  %add15 = add nsw i32 %conv14, 4
  %call16 = call zeroext i8 @inb_p(i32 %add15)
  %7 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io117 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %7, i32 0, i32 0
  %minimum18 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io117, i32 0, i32 3
  %8 = load i16, i16* %minimum18, align 1, !tbaa !19
  %conv19 = zext i16 %8 to i32
  %call20 = call zeroext i8 @inb_p(i32 %conv19)
  %9 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool22 = icmp ne i32 %9, 0
  br i1 %tobool22, label %if.then23, label %do.end30

if.then23:                                        ; preds = %if.end7
  call void (i8*, ...) @printk(i8* null)
  br label %do.end30

do.end30:                                         ; preds = %if.then23, %if.end7
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @__sony_pic_camera_ready() #0 {
entry:
  %call = call zeroext i8 @sony_pic_call2(i8 zeroext -113, i8 zeroext 7)
  %conv = zext i8 %call to i32
  %cmp = icmp ne i32 %conv, 255
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %conv2 = zext i8 %call to i32
  %and = and i32 %conv2, 2
  %tobool = icmp ne i32 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %0 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb_p(i32 %port) #4 {
entry:
  %call = call zeroext i8 @inb(i32 %port)
  call void @slow_down_io()
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #4 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #7, !srcloc !22
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #4 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #7, !srcloc !23
  ret i8 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @slow_down_io() #4 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.pv_cpu_ops, %struct.pv_cpu_ops* @pv_cpu_ops, i32 0, i32 24), align 8, !tbaa !24
  call void %0()
  ret void
}

declare i32 @dmi_check_system(%struct.dmi_system_id*) #1

declare i32 @acpi_bus_register_driver(%struct.acpi_driver*) #1

declare void @acpi_bus_unregister_driver(%struct.acpi_driver*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_add(%struct.acpi_device* %device) #0 {
entry:
  store %struct.acpi_device* %device, %struct.acpi_device** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 0), align 8, !tbaa !26
  %pnp = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 10
  %device_class = getelementptr inbounds %struct.acpi_device_pnp, %struct.acpi_device_pnp* %pnp, i32 0, i32 6
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %device_class, i32 0, i32 0
  %call = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.12, i32 0, i32 0))
  call void @sony_pic_detect_device_type(%struct.sony_pic_dev* @spic_dev)
  call void @__mutex_init(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.13, i32 0, i32 0), %struct.lock_class_key* @sony_pic_add.__key)
  %call1 = call i32 @sony_pic_possible_resources(%struct.acpi_device* %device)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %err_free_resources

if.end:                                           ; preds = %entry
  %call3 = call i32 @sony_laptop_setup_input(%struct.acpi_device* %device)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  call void (i8*, ...) @printk(i8* null)
  br label %err_free_resources

if.end7:                                          ; preds = %if.end
  %call8 = call i32 @sonypi_compat_init()
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %err_remove_input, label %if.end11

if.end11:                                         ; preds = %if.end7
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end11
  %prev.sink = phi %struct.list_head** [ %prev, %for.inc ], [ getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4, i32 1), %if.end11 ]
  %0 = load %struct.list_head*, %struct.list_head** %prev.sink, align 8, !tbaa !27
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr89 = getelementptr inbounds i8, i8* %1, i64 -16
  %2 = bitcast i8* %add.ptr89 to %struct.sony_pic_ioport*
  %list = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 2
  %cmp = icmp ne %struct.list_head* %list, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4)
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %3 = load i16, i16* %minimum, align 1, !tbaa !19
  %conv = zext i16 %3 to i64
  %io112 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %address_length = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io112, i32 0, i32 2
  %4 = load i8, i8* %address_length, align 2, !tbaa !28
  %conv13 = zext i8 %4 to i64
  %call14 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv, i64 %conv13, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.16, i32 0, i32 0), i32 0)
  %tobool15 = icmp ne %struct.resource* %call14, null
  br i1 %tobool15, label %do.body17, label %for.inc

do.body17:                                        ; preds = %for.body
  %5 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool18 = icmp ne i32 %5, 0
  br i1 %tobool18, label %if.then19, label %do.end31

if.then19:                                        ; preds = %do.body17
  call void (i8*, ...) @printk(i8* null)
  br label %do.end31

do.end31:                                         ; preds = %if.then19, %do.body17
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %minimum32 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %6 = load i16, i16* %minimum32, align 1, !tbaa !29
  %tobool33 = icmp ne i16 %6, 0
  br i1 %tobool33, label %if.then34, label %for.end.sink.split

if.then34:                                        ; preds = %do.end31
  %io235 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %minimum36 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io235, i32 0, i32 3
  %7 = load i16, i16* %minimum36, align 1, !tbaa !29
  %conv37 = zext i16 %7 to i64
  %io238 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %address_length39 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io238, i32 0, i32 2
  %8 = load i8, i8* %address_length39, align 1, !tbaa !30
  %conv40 = zext i8 %8 to i64
  %call41 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv37, i64 %conv40, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.16, i32 0, i32 0), i32 0)
  %tobool42 = icmp ne %struct.resource* %call41, null
  %9 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool45 = icmp ne i32 %9, 0
  br i1 %tobool42, label %do.body44, label %do.body60

do.body44:                                        ; preds = %if.then34
  br i1 %tobool45, label %if.then46, label %for.end.sink.split

if.then46:                                        ; preds = %do.body44
  call void (i8*, ...) @printk(i8* null)
  br label %for.end.sink.split

do.body60:                                        ; preds = %if.then34
  br i1 %tobool45, label %if.then62, label %do.end75

if.then62:                                        ; preds = %do.body60
  call void (i8*, ...) @printk(i8* null)
  br label %do.end75

do.end75:                                         ; preds = %if.then62, %do.body60
  %io176 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %minimum77 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io176, i32 0, i32 3
  %10 = load i16, i16* %minimum77, align 1, !tbaa !19
  %conv78 = zext i16 %10 to i64
  %io179 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %address_length80 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io179, i32 0, i32 2
  %11 = load i8, i8* %address_length80, align 2, !tbaa !28
  %conv81 = zext i8 %11 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv78, i64 %conv81)
  br label %for.inc

for.inc:                                          ; preds = %do.end75, %for.body
  %list87 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 2
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list87, i32 0, i32 1
  br label %for.cond

for.end.sink.split:                               ; preds = %if.then46, %do.body44, %do.end31
  store %struct.sony_pic_ioport* %2, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  br label %for.end

for.end:                                          ; preds = %for.end.sink.split, %for.cond
  %12 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %tobool90 = icmp ne %struct.sony_pic_ioport* %12, null
  br i1 %tobool90, label %if.end93, label %if.then91

if.then91:                                        ; preds = %for.end
  call void (i8*, ...) @printk(i8* null)
  br label %err_remove_compat

if.end93:                                         ; preds = %for.end
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc125, %if.end93
  %prev128.sink = phi %struct.list_head** [ %prev128, %for.inc125 ], [ getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3, i32 1), %if.end93 ]
  %13 = load %struct.list_head*, %struct.list_head** %prev128.sink, align 8, !tbaa !27
  %14 = bitcast %struct.list_head* %13 to i8*
  %add.ptr130 = getelementptr inbounds i8, i8* %14, i64 -8
  %15 = bitcast i8* %add.ptr130 to %struct.sony_pic_irq*
  %list98 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %15, i32 0, i32 1
  %cmp99 = icmp ne %struct.list_head* %list98, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3)
  br i1 %cmp99, label %for.body101, label %for.end131

for.body101:                                      ; preds = %for.cond97
  %irq102 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %15, i32 0, i32 0
  %interrupts = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq102, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts, i64 0, i64 0
  %16 = load i8, i8* %arrayidx, align 2, !tbaa !31
  %conv103 = zext i8 %16 to i32
  %call104 = call i32 @request_irq(i32 %conv103, i32 (i32, i8*)* @sony_pic_irq, i64 0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.21, i32 0, i32 0), i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  %tobool105 = icmp ne i32 %call104, 0
  br i1 %tobool105, label %for.inc125, label %do.body107

do.body107:                                       ; preds = %for.body101
  %17 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool108 = icmp ne i32 %17, 0
  br i1 %tobool108, label %if.then109, label %do.end123

if.then109:                                       ; preds = %do.body107
  call void (i8*, ...) @printk(i8* null)
  br label %do.end123

do.end123:                                        ; preds = %if.then109, %do.body107
  store %struct.sony_pic_irq* %15, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !32
  br label %for.end131

for.inc125:                                       ; preds = %for.body101
  %list127 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %15, i32 0, i32 1
  %prev128 = getelementptr inbounds %struct.list_head, %struct.list_head* %list127, i32 0, i32 1
  br label %for.cond97

for.end131:                                       ; preds = %do.end123, %for.cond97
  %18 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !32
  %tobool132 = icmp ne %struct.sony_pic_irq* %18, null
  br i1 %tobool132, label %if.end135, label %if.then133

if.then133:                                       ; preds = %for.end131
  call void (i8*, ...) @printk(i8* null)
  br label %err_release_region

if.end135:                                        ; preds = %for.end131
  %19 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %20 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !32
  %call136 = call i32 @sony_pic_enable(%struct.acpi_device* %device, %struct.sony_pic_ioport* %19, %struct.sony_pic_irq* %20)
  %tobool137 = icmp ne i32 %call136, 0
  br i1 %tobool137, label %if.then138, label %if.end140

if.then138:                                       ; preds = %if.end135
  call void (i8*, ...) @printk(i8* null)
  br label %err_free_irq

if.end140:                                        ; preds = %if.end135
  store i8 -1, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !33
  %call141 = call i32 @sony_pf_add()
  %tobool142 = icmp ne i32 %call141, 0
  br i1 %tobool142, label %err_disable_device, label %if.end144

if.end144:                                        ; preds = %if.end140
  %21 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %21, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call145 = call i32 @sysfs_create_group(%struct.kobject* %kobj, %struct.attribute_group* @spic_attribute_group)
  %tobool146 = icmp ne i32 %call145, 0
  br i1 %tobool146, label %err_remove_pf, label %if.end148

if.end148:                                        ; preds = %if.end144
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

err_remove_pf:                                    ; preds = %if.end144
  call void @sony_pf_remove()
  br label %err_disable_device

err_disable_device:                               ; preds = %err_remove_pf, %if.end140
  %result.0 = phi i32 [ %call145, %err_remove_pf ], [ %call141, %if.end140 ]
  %call150 = call i32 @sony_pic_disable(%struct.acpi_device* %device)
  br label %err_free_irq

err_free_irq:                                     ; preds = %err_disable_device, %if.then138
  %result.1 = phi i32 [ %call136, %if.then138 ], [ %result.0, %err_disable_device ]
  %22 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !32
  %irq151 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %22, i32 0, i32 0
  %interrupts152 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq151, i32 0, i32 6
  %arrayidx153 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts152, i64 0, i64 0
  %23 = load i8, i8* %arrayidx153, align 2, !tbaa !31
  %conv154 = zext i8 %23 to i32
  call void @free_irq(i32 %conv154, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  br label %err_release_region

err_release_region:                               ; preds = %err_free_irq, %if.then133
  %result.2 = phi i32 [ %result.1, %err_free_irq ], [ -19, %if.then133 ]
  %24 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io1155 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %24, i32 0, i32 0
  %minimum156 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1155, i32 0, i32 3
  %25 = load i16, i16* %minimum156, align 1, !tbaa !19
  %conv157 = zext i16 %25 to i64
  %26 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io1158 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %26, i32 0, i32 0
  %address_length159 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1158, i32 0, i32 2
  %27 = load i8, i8* %address_length159, align 2, !tbaa !28
  %conv160 = zext i8 %27 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv157, i64 %conv160)
  %28 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io2161 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %28, i32 0, i32 1
  %minimum162 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2161, i32 0, i32 3
  %29 = load i16, i16* %minimum162, align 1, !tbaa !29
  %tobool163 = icmp ne i16 %29, 0
  br i1 %tobool163, label %if.then164, label %err_remove_compat

if.then164:                                       ; preds = %err_release_region
  %30 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io2165 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %30, i32 0, i32 1
  %minimum166 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2165, i32 0, i32 3
  %31 = load i16, i16* %minimum166, align 1, !tbaa !29
  %conv167 = zext i16 %31 to i64
  %32 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io2168 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %32, i32 0, i32 1
  %address_length169 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2168, i32 0, i32 2
  %33 = load i8, i8* %address_length169, align 1, !tbaa !30
  %conv170 = zext i8 %33 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv167, i64 %conv170)
  br label %err_remove_compat

err_remove_compat:                                ; preds = %if.then164, %err_release_region, %if.then91
  %result.3 = phi i32 [ -19, %if.then91 ], [ %result.2, %if.then164 ], [ %result.2, %err_release_region ]
  call void @sonypi_compat_exit()
  br label %err_remove_input

err_remove_input:                                 ; preds = %err_remove_compat, %if.end7
  %result.4 = phi i32 [ %result.3, %err_remove_compat ], [ %call8, %if.end7 ]
  call void @sony_laptop_remove_input()
  br label %err_free_resources

err_free_resources:                               ; preds = %err_remove_input, %if.then5, %if.then
  %result.5 = phi i32 [ %call1, %if.then ], [ %call3, %if.then5 ], [ %result.4, %err_remove_input ]
  %34 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4, i32 0), align 8, !tbaa !34
  %35 = bitcast %struct.list_head* %34 to i8*
  %add.ptr174 = getelementptr inbounds i8, i8* %35, i64 -16
  %36 = bitcast i8* %add.ptr174 to %struct.sony_pic_ioport*
  br label %for.cond179

for.cond179:                                      ; preds = %for.body183, %err_free_resources
  %.sink = phi %struct.sony_pic_ioport* [ %39, %for.body183 ], [ %36, %err_free_resources ]
  %io.1 = phi %struct.sony_pic_ioport* [ %36, %err_free_resources ], [ %39, %for.body183 ]
  %list187 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %.sink, i32 0, i32 2
  %next188 = getelementptr inbounds %struct.list_head, %struct.list_head* %list187, i32 0, i32 0
  %37 = load %struct.list_head*, %struct.list_head** %next188, align 8, !tbaa !35
  %38 = bitcast %struct.list_head* %37 to i8*
  %add.ptr190 = getelementptr inbounds i8, i8* %38, i64 -16
  %39 = bitcast i8* %add.ptr190 to %struct.sony_pic_ioport*
  %list180 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.1, i32 0, i32 2
  %cmp181 = icmp ne %struct.list_head* %list180, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4)
  br i1 %cmp181, label %for.body183, label %for.end191

for.body183:                                      ; preds = %for.cond179
  %list184 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.1, i32 0, i32 2
  call void @list_del(%struct.list_head* %list184)
  %40 = bitcast %struct.sony_pic_ioport* %io.1 to i8*
  call void @kfree(i8* %40)
  br label %for.cond179

for.end191:                                       ; preds = %for.cond179
  %41 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3, i32 0), align 8, !tbaa !34
  %42 = bitcast %struct.list_head* %41 to i8*
  %add.ptr194 = getelementptr inbounds i8, i8* %42, i64 -8
  %43 = bitcast i8* %add.ptr194 to %struct.sony_pic_irq*
  br label %for.cond200

for.cond200:                                      ; preds = %for.body204, %for.end191
  %.sink6 = phi %struct.sony_pic_irq* [ %46, %for.body204 ], [ %43, %for.end191 ]
  %irq.1 = phi %struct.sony_pic_irq* [ %43, %for.end191 ], [ %46, %for.body204 ]
  %list208 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %.sink6, i32 0, i32 1
  %next209 = getelementptr inbounds %struct.list_head, %struct.list_head* %list208, i32 0, i32 0
  %44 = load %struct.list_head*, %struct.list_head** %next209, align 8, !tbaa !36
  %45 = bitcast %struct.list_head* %44 to i8*
  %add.ptr211 = getelementptr inbounds i8, i8* %45, i64 -8
  %46 = bitcast i8* %add.ptr211 to %struct.sony_pic_irq*
  %list201 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.1, i32 0, i32 1
  %cmp202 = icmp ne %struct.list_head* %list201, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3)
  br i1 %cmp202, label %for.body204, label %for.end212

for.body204:                                      ; preds = %for.cond200
  %list205 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.1, i32 0, i32 1
  call void @list_del(%struct.list_head* %list205)
  %47 = bitcast %struct.sony_pic_irq* %irq.1 to i8*
  call void @kfree(i8* %47)
  br label %for.cond200

for.end212:                                       ; preds = %for.cond200
  store %struct.sony_pic_ioport* null, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  store %struct.sony_pic_irq* null, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !32
  br label %cleanup

cleanup:                                          ; preds = %for.end212, %if.end148
  %retval.0 = phi i32 [ %result.5, %for.end212 ], [ 0, %if.end148 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_remove(%struct.acpi_device* %device) #0 {
entry:
  %call = call i32 @sony_pic_disable(%struct.acpi_device* %device)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %0 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !32
  %irq2 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %0, i32 0, i32 0
  %interrupts = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq2, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts, i64 0, i64 0
  %1 = load i8, i8* %arrayidx, align 2, !tbaa !31
  %conv = zext i8 %1 to i32
  call void @free_irq(i32 %conv, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  %2 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %3 = load i16, i16* %minimum, align 1, !tbaa !19
  %conv3 = zext i16 %3 to i64
  %4 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io14 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %4, i32 0, i32 0
  %address_length = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io14, i32 0, i32 2
  %5 = load i8, i8* %address_length, align 2, !tbaa !28
  %conv5 = zext i8 %5 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv3, i64 %conv5)
  %6 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %6, i32 0, i32 1
  %minimum6 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %7 = load i16, i16* %minimum6, align 1, !tbaa !29
  %tobool7 = icmp ne i16 %7, 0
  br i1 %tobool7, label %if.then8, label %if.end15

if.then8:                                         ; preds = %if.end
  %8 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io29 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %8, i32 0, i32 1
  %minimum10 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io29, i32 0, i32 3
  %9 = load i16, i16* %minimum10, align 1, !tbaa !29
  %conv11 = zext i16 %9 to i64
  %10 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %io212 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %10, i32 0, i32 1
  %address_length13 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io212, i32 0, i32 2
  %11 = load i8, i8* %address_length13, align 1, !tbaa !30
  %conv14 = zext i8 %11 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv11, i64 %conv14)
  br label %if.end15

if.end15:                                         ; preds = %if.then8, %if.end
  call void @sonypi_compat_exit()
  call void @sony_laptop_remove_input()
  %12 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %12, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj, %struct.attribute_group* @spic_attribute_group)
  call void @sony_pf_remove()
  %13 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4, i32 0), align 8, !tbaa !34
  %14 = bitcast %struct.list_head* %13 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %14, i64 -16
  %15 = bitcast i8* %add.ptr to %struct.sony_pic_ioport*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end15
  %.sink = phi %struct.sony_pic_ioport* [ %18, %for.body ], [ %15, %if.end15 ]
  %io.0 = phi %struct.sony_pic_ioport* [ %15, %if.end15 ], [ %18, %for.body ]
  %list23 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %.sink, i32 0, i32 2
  %next24 = getelementptr inbounds %struct.list_head, %struct.list_head* %list23, i32 0, i32 0
  %16 = load %struct.list_head*, %struct.list_head** %next24, align 8, !tbaa !35
  %17 = bitcast %struct.list_head* %16 to i8*
  %add.ptr26 = getelementptr inbounds i8, i8* %17, i64 -16
  %18 = bitcast i8* %add.ptr26 to %struct.sony_pic_ioport*
  %list19 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.0, i32 0, i32 2
  %cmp = icmp ne %struct.list_head* %list19, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4)
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %list21 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.0, i32 0, i32 2
  call void @list_del(%struct.list_head* %list21)
  %19 = bitcast %struct.sony_pic_ioport* %io.0 to i8*
  call void @kfree(i8* %19)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %20 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3, i32 0), align 8, !tbaa !34
  %21 = bitcast %struct.list_head* %20 to i8*
  %add.ptr29 = getelementptr inbounds i8, i8* %21, i64 -8
  %22 = bitcast i8* %add.ptr29 to %struct.sony_pic_irq*
  br label %for.cond35

for.cond35:                                       ; preds = %for.body39, %for.end
  %.sink4 = phi %struct.sony_pic_irq* [ %25, %for.body39 ], [ %22, %for.end ]
  %irq.0 = phi %struct.sony_pic_irq* [ %22, %for.end ], [ %25, %for.body39 ]
  %list43 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %.sink4, i32 0, i32 1
  %next44 = getelementptr inbounds %struct.list_head, %struct.list_head* %list43, i32 0, i32 0
  %23 = load %struct.list_head*, %struct.list_head** %next44, align 8, !tbaa !36
  %24 = bitcast %struct.list_head* %23 to i8*
  %add.ptr46 = getelementptr inbounds i8, i8* %24, i64 -8
  %25 = bitcast i8* %add.ptr46 to %struct.sony_pic_irq*
  %list36 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.0, i32 0, i32 1
  %cmp37 = icmp ne %struct.list_head* %list36, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3)
  br i1 %cmp37, label %for.body39, label %for.end47

for.body39:                                       ; preds = %for.cond35
  %list40 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.0, i32 0, i32 1
  call void @list_del(%struct.list_head* %list40)
  %26 = bitcast %struct.sony_pic_irq* %irq.0 to i8*
  call void @kfree(i8* %26)
  br label %for.cond35

for.end47:                                        ; preds = %for.cond35
  store %struct.sony_pic_ioport* null, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  store %struct.sony_pic_irq* null, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !32
  %27 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool48 = icmp ne i32 %27, 0
  br i1 %tobool48, label %if.then49, label %cleanup

if.then49:                                        ; preds = %for.end47
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then49, %for.end47, %if.then
  %retval.0 = phi i32 [ -6, %if.then ], [ 0, %if.then49 ], [ 0, %for.end47 ]
  ret i32 %retval.0
}

declare i8* @strcpy(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @sony_pic_detect_device_type(%struct.sony_pic_dev* %dev) #0 {
entry:
  %call = call %struct.pci_dev* @pci_get_device(i32 32902, i32 28947, %struct.pci_dev* null)
  %tobool = icmp ne %struct.pci_dev* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %model = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 1, i32* %model, align 8, !tbaa !39
  br label %out

if.end:                                           ; preds = %entry
  %call1 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 9793, %struct.pci_dev* null)
  %tobool2 = icmp ne %struct.pci_dev* %call1, null
  br i1 %tobool2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %model4 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 2, i32* %model4, align 8, !tbaa !39
  br label %out

if.end7:                                          ; preds = %if.end
  %call8 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 10169, %struct.pci_dev* null)
  %tobool9 = icmp ne %struct.pci_dev* %call8, null
  br i1 %tobool9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end7
  %model11 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 4, i32* %model11, align 8, !tbaa !39
  %handle_irq = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 7
  store i32 (i8, i8)* @type3_handle_irq, i32 (i8, i8)** %handle_irq, align 8, !tbaa !40
  br label %out

if.end14:                                         ; preds = %if.end7
  %call15 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 10261, %struct.pci_dev* null)
  %tobool16 = icmp ne %struct.pci_dev* %call15, null
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.end14
  %model18 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 4, i32* %model18, align 8, !tbaa !39
  %handle_irq19 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 7
  store i32 (i8, i8)* @type3_handle_irq, i32 (i8, i8)** %handle_irq19, align 8, !tbaa !40
  br label %out

if.end22:                                         ; preds = %if.end14
  %call23 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 10519, %struct.pci_dev* null)
  %tobool24 = icmp ne %struct.pci_dev* %call23, null
  %model26 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  br i1 %tobool24, label %if.then25, label %if.end30

if.then25:                                        ; preds = %if.end22
  store i32 4, i32* %model26, align 8, !tbaa !39
  %handle_irq27 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 7
  store i32 (i8, i8)* @type3_handle_irq, i32 (i8, i8)** %handle_irq27, align 8, !tbaa !40
  br label %out

if.end30:                                         ; preds = %if.end22
  store i32 2, i32* %model26, align 8, !tbaa !39
  br label %out

out:                                              ; preds = %if.end30, %if.then25, %if.then17, %if.then10, %if.then3, %if.then
  %.sink1 = phi i16 [ 18, %if.end30 ], [ 18, %if.then25 ], [ 18, %if.then17 ], [ 18, %if.then10 ], [ 18, %if.then3 ], [ 4, %if.then ]
  %.sink = phi %struct.sonypi_eventtypes* [ getelementptr inbounds ([15 x %struct.sonypi_eventtypes], [15 x %struct.sonypi_eventtypes]* @type2_events, i32 0, i32 0), %if.end30 ], [ getelementptr inbounds ([12 x %struct.sonypi_eventtypes], [12 x %struct.sonypi_eventtypes]* @type3_events, i32 0, i32 0), %if.then25 ], [ getelementptr inbounds ([12 x %struct.sonypi_eventtypes], [12 x %struct.sonypi_eventtypes]* @type3_events, i32 0, i32 0), %if.then17 ], [ getelementptr inbounds ([12 x %struct.sonypi_eventtypes], [12 x %struct.sonypi_eventtypes]* @type3_events, i32 0, i32 0), %if.then10 ], [ getelementptr inbounds ([15 x %struct.sonypi_eventtypes], [15 x %struct.sonypi_eventtypes]* @type2_events, i32 0, i32 0), %if.then3 ], [ getelementptr inbounds ([11 x %struct.sonypi_eventtypes], [11 x %struct.sonypi_eventtypes]* @type1_events, i32 0, i32 0), %if.then ]
  %pcidev.0 = phi %struct.pci_dev* [ %call, %if.then ], [ %call1, %if.then3 ], [ %call8, %if.then10 ], [ %call15, %if.then17 ], [ %call23, %if.then25 ], [ %call23, %if.end30 ]
  %evport_offset32 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 9
  store i16 %.sink1, i16* %evport_offset32, align 4, !tbaa !41
  %event_types33 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 6
  store %struct.sonypi_eventtypes* %.sink, %struct.sonypi_eventtypes** %event_types33, align 8, !tbaa !42
  call void @pci_dev_put(%struct.pci_dev* %pcidev.0)
  %model34 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  %0 = load i32, i32* %model34, align 8, !tbaa !39
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %out
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %out
  call void (i8*, ...) @printk(i8* null)
  ret void
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_possible_resources(%struct.acpi_device* %device) #0 {
entry:
  %tobool = icmp ne %struct.acpi_device* %device, null
  br i1 %tobool, label %do.body, label %cleanup

do.body:                                          ; preds = %entry
  %0 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %if.then2, label %do.end

if.then2:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then2, %do.body
  %call4 = call i32 @acpi_bus_get_status(%struct.acpi_device* %device)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %do.end
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end8:                                          ; preds = %do.end
  %status9 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 8
  %1 = bitcast %struct.acpi_device_status* %status9 to i32*
  %bf.load = load i32, i32* %1, align 8
  %bf.lshr = lshr i32 %bf.load, 1
  %bf.clear = and i32 %bf.lshr, 1
  %tobool10 = icmp ne i32 %bf.clear, 0
  %2 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool20 = icmp ne i32 %2, 0
  br i1 %tobool10, label %do.body19, label %do.body12

do.body12:                                        ; preds = %if.end8
  br i1 %tobool20, label %if.then14, label %do.body27

if.then14:                                        ; preds = %do.body12
  call void (i8*, ...) @printk(i8* null)
  br label %do.body27

do.body19:                                        ; preds = %if.end8
  br i1 %tobool20, label %if.then21, label %do.body27

if.then21:                                        ; preds = %do.body19
  call void (i8*, ...) @printk(i8* null)
  br label %do.body27

do.body27:                                        ; preds = %if.then21, %do.body19, %if.then14, %do.body12
  %3 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool28 = icmp ne i32 %3, 0
  br i1 %tobool28, label %if.then29, label %do.end33

if.then29:                                        ; preds = %do.body27
  call void (i8*, ...) @printk(i8* null)
  br label %do.end33

do.end33:                                         ; preds = %if.then29, %do.body27
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %4 = load i8*, i8** %handle, align 8, !tbaa !43
  %call34 = call i32 @acpi_walk_resources(i8* %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.32, i32 0, i32 0), i32 (%struct.acpi_resource*, i8*)* @sony_pic_read_possible_resource, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.then36, label %cleanup

if.then36:                                        ; preds = %do.end33
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then36, %do.end33, %if.then6, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ %call4, %if.then6 ], [ -19, %if.then36 ], [ %call4, %do.end33 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_laptop_setup_input(%struct.acpi_device* %acpi_device) #0 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i64 0, i32 0, i32 0), i32 1, i32* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i64 0, i32 0, i32 0)) #7, !srcloc !76
  %add.i = add nsw i32 1, %0
  %cmp = icmp sgt i32 %add.i, 1
  br i1 %cmp, label %cleanup, label %do.body

do.body:                                          ; preds = %entry
  call void @__raw_spin_lock_init(%struct.raw_spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.41, i32 0, i32 0), %struct.lock_class_key* @sony_laptop_setup_input.__key)
  %1 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.70* %1 to %struct.__kfifo*
  %call5 = call i32 @__kfifo_alloc(%struct.__kfifo* %kfifo, i32 128, i64 1, i32 20971712)
  %call6 = call i32 @__kfifo_int_must_check_helper(i32 %call5)
  %tobool = icmp ne i32 %call6, 0
  br i1 %tobool, label %if.then7, label %do.body11

if.then7:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %err_dec_users

do.body11:                                        ; preds = %do.body
  call void @init_timer_key(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5), i32 0, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.44, i32 0, i32 0), %struct.lock_class_key* @sony_laptop_setup_input.__key.43)
  store void (i64)* @do_sony_laptop_release_key, void (i64)** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5, i32 2), align 8, !tbaa !77
  store i64 0, i64* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5, i32 3), align 8, !tbaa !78
  %call16 = call %struct.input_dev* @input_allocate_device()
  %tobool17 = icmp ne %struct.input_dev* %call16, null
  br i1 %tobool17, label %if.end19, label %err_free_kfifo

if.end19:                                         ; preds = %do.body11
  %name = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 0
  store i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.45, i32 0, i32 0), i8** %name, align 8, !tbaa !79
  %id = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 3
  %bustype = getelementptr inbounds %struct.input_id, %struct.input_id* %id, i32 0, i32 0
  store i16 16, i16* %bustype, align 8, !tbaa !82
  %id20 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 3
  %vendor = getelementptr inbounds %struct.input_id, %struct.input_id* %id20, i32 0, i32 1
  store i16 4173, i16* %vendor, align 2, !tbaa !83
  %dev = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %acpi_device, i32 0, i32 21
  %dev21 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 39
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev21, i32 0, i32 0
  store %struct.device* %dev, %struct.device** %parent, align 8, !tbaa !84
  call void @input_set_capability(%struct.input_dev* %call16, i32 4, i32 4)
  %evbit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 5
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %evbit, i32 0, i32 0
  call void asm sideeffect "bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay, i64 1, i64* %arraydecay) #7, !srcloc !85
  %keycodesize = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 16
  store i32 4, i32* %keycodesize, align 8, !tbaa !86
  %keycodemax = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 15
  store i32 60, i32* %keycodemax, align 4, !tbaa !87
  %keycode = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 17
  store i8* bitcast ([60 x i32]* @sony_laptop_input_keycode_map to i8*), i8** %keycode, align 8, !tbaa !88
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end19
  %i.0 = phi i32 [ 0, %if.end19 ], [ %inc, %for.body ]
  %conv = sext i32 %i.0 to i64
  %cmp22 = icmp ult i64 %conv, 60
  br i1 %cmp22, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [60 x i32], [60 x i32]* @sony_laptop_input_keycode_map, i64 0, i64 %idxprom
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %conv24 = sext i32 %2 to i64
  %keybit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 6
  %arraydecay25 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit, i32 0, i32 0
  call void asm sideeffect "bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay25, i64 %conv24, i64* %arraydecay25) #7, !srcloc !85
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %keybit26 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 6
  %arraydecay27 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit26, i32 0, i32 0
  call void asm sideeffect "btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arraydecay27, i64 0, i64* %arraydecay27) #7, !srcloc !89
  %call28 = call i32 @input_register_device(%struct.input_dev* %call16)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %err_free_keydev, label %if.end31

if.end31:                                         ; preds = %for.end
  store %struct.input_dev* %call16, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !90
  %call32 = call %struct.input_dev* @input_allocate_device()
  %tobool33 = icmp ne %struct.input_dev* %call32, null
  br i1 %tobool33, label %if.end35, label %err_unregister_keydev

if.end35:                                         ; preds = %if.end31
  %name36 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call32, i32 0, i32 0
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.46, i32 0, i32 0), i8** %name36, align 8, !tbaa !79
  %id37 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call32, i32 0, i32 3
  %bustype38 = getelementptr inbounds %struct.input_id, %struct.input_id* %id37, i32 0, i32 0
  store i16 16, i16* %bustype38, align 8, !tbaa !82
  %id39 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call32, i32 0, i32 3
  %vendor40 = getelementptr inbounds %struct.input_id, %struct.input_id* %id39, i32 0, i32 1
  store i16 4173, i16* %vendor40, align 2, !tbaa !83
  %dev41 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %acpi_device, i32 0, i32 21
  %dev42 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call32, i32 0, i32 39
  %parent43 = getelementptr inbounds %struct.device, %struct.device* %dev42, i32 0, i32 0
  store %struct.device* %dev41, %struct.device** %parent43, align 8, !tbaa !84
  call void @input_set_capability(%struct.input_dev* %call32, i32 1, i32 274)
  call void @input_set_capability(%struct.input_dev* %call32, i32 2, i32 8)
  %call44 = call i32 @input_register_device(%struct.input_dev* %call32)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %err_free_jogdev, label %if.end47

if.end47:                                         ; preds = %if.end35
  store %struct.input_dev* %call32, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !93
  br label %cleanup

err_free_jogdev:                                  ; preds = %if.end35
  call void @input_free_device(%struct.input_dev* %call32)
  br label %err_unregister_keydev

err_unregister_keydev:                            ; preds = %err_free_jogdev, %if.end31
  %error.0 = phi i32 [ %call44, %err_free_jogdev ], [ -12, %if.end31 ]
  call void @input_unregister_device(%struct.input_dev* %call16)
  br label %err_free_keydev

err_free_keydev:                                  ; preds = %err_unregister_keydev, %for.end
  %key_dev.0 = phi %struct.input_dev* [ null, %err_unregister_keydev ], [ %call16, %for.end ]
  %error.1 = phi i32 [ %error.0, %err_unregister_keydev ], [ %call28, %for.end ]
  call void @input_free_device(%struct.input_dev* %key_dev.0)
  br label %err_free_kfifo

err_free_kfifo:                                   ; preds = %err_free_keydev, %do.body11
  %error.2 = phi i32 [ %error.1, %err_free_keydev ], [ -12, %do.body11 ]
  %3 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo50 = bitcast %union.anon.70* %3 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo50)
  br label %err_dec_users

err_dec_users:                                    ; preds = %err_free_kfifo, %if.then7
  %error.3 = phi i32 [ %call6, %if.then7 ], [ %error.2, %err_free_kfifo ]
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i64 0, i32 0, i32 0), i32* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i64 0, i32 0, i32 0)) #7, !srcloc !94
  br label %cleanup

cleanup:                                          ; preds = %err_dec_users, %if.end47, %entry
  %retval.0 = phi i32 [ %error.3, %err_dec_users ], [ 0, %if.end47 ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_compat_init() #0 {
entry:
  call void @__raw_spin_lock_init(%struct.raw_spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.47, i32 0, i32 0), %struct.lock_class_key* @sonypi_compat_init.__key)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.70* %0 to %struct.__kfifo*
  %call4 = call i32 @__kfifo_alloc(%struct.__kfifo* %kfifo, i32 128, i64 1, i32 20971712)
  %call5 = call i32 @__kfifo_int_must_check_helper(i32 %call4)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then, label %do.body7

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

do.body7:                                         ; preds = %entry
  call void @__init_waitqueue_head(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.49, i32 0, i32 0), %struct.lock_class_key* @sonypi_compat_init.__key.48)
  %1 = load i32, i32* @minor, align 4, !tbaa !2
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %if.then10, label %if.end11

if.then10:                                        ; preds = %do.body7
  %2 = load i32, i32* @minor, align 4, !tbaa !2
  store i32 %2, i32* getelementptr inbounds (%struct.miscdevice, %struct.miscdevice* @sonypi_misc_device, i32 0, i32 0), align 8, !tbaa !95
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %do.body7
  %call12 = call i32 @misc_register(%struct.miscdevice* @sonypi_misc_device)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  call void (i8*, ...) @printk(i8* null)
  %3 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo23 = bitcast %union.anon.70* %3 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo23)
  br label %cleanup

if.end16:                                         ; preds = %if.end11
  %4 = load i32, i32* @minor, align 4, !tbaa !2
  %cmp17 = icmp eq i32 %4, -1
  br i1 %cmp17, label %if.then18, label %cleanup

if.then18:                                        ; preds = %if.end16
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then18, %if.end16, %if.then14, %if.then
  %retval.0 = phi i32 [ %call5, %if.then ], [ %call12, %if.then14 ], [ 0, %if.then18 ], [ 0, %if.end16 ]
  ret i32 %retval.0
}

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #1

declare void @__release_region(%struct.resource*, i64, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #4 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_irq(i32 %irq, i8* %dev_id) #0 {
entry:
  %0 = bitcast i8* %dev_id to %struct.sony_pic_dev*
  %cur_ioport = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %1 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport, align 8, !tbaa !18
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %1, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %2 = load i16, i16* %minimum, align 1, !tbaa !19
  %conv = zext i16 %2 to i32
  %call = call zeroext i8 @inb_p(i32 %conv)
  %cur_ioport1 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport1, align 8, !tbaa !18
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 1
  %minimum2 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %4 = load i16, i16* %minimum2, align 1, !tbaa !29
  %tobool = icmp ne i16 %4, 0
  %cur_ioport3 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport3, align 8, !tbaa !18
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %io24 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 1
  %minimum5 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io24, i32 0, i32 3
  %6 = load i16, i16* %minimum5, align 1, !tbaa !29
  %conv6 = zext i16 %6 to i32
  br label %if.end

if.else:                                          ; preds = %entry
  %io19 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum10 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io19, i32 0, i32 3
  %7 = load i16, i16* %minimum10, align 1, !tbaa !19
  %conv11 = zext i16 %7 to i32
  %evport_offset = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 9
  %8 = load i16, i16* %evport_offset, align 4, !tbaa !41
  %conv12 = zext i16 %8 to i32
  %add = add nsw i32 %conv11, %conv12
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %add.sink = phi i32 [ %add, %if.else ], [ %conv6, %if.then ]
  %call13 = call zeroext i8 @inb_p(i32 %add.sink)
  %9 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool14 = icmp ne i32 %9, 0
  br i1 %tobool14, label %if.then15, label %do.end

if.then15:                                        ; preds = %if.end
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then15, %if.end
  %conv26 = zext i8 %call to i32
  %cmp = icmp eq i32 %conv26, 0
  %conv28 = zext i8 %call to i32
  %cmp29 = icmp eq i32 %conv28, 255
  %or.cond = or i1 %cmp, %cmp29
  br i1 %or.cond, label %cleanup, label %if.end32

if.end32:                                         ; preds = %do.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc87, %if.end32
  %i.0 = phi i32 [ 0, %if.end32 ], [ %inc88, %for.inc87 ]
  %event_types = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %10 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types, align 8, !tbaa !42
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %10, i64 %idxprom
  %mask = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx, i32 0, i32 1
  %11 = load i64, i64* %mask, align 8, !tbaa !97
  %tobool33 = icmp ne i64 %11, 0
  br i1 %tobool33, label %for.body, label %for.end89

for.body:                                         ; preds = %for.cond
  %conv34 = zext i8 %call13 to i32
  %event_types35 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %12 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types35, align 8, !tbaa !42
  %idxprom36 = sext i32 %i.0 to i64
  %arrayidx37 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %12, i64 %idxprom36
  %data = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx37, i32 0, i32 0
  %13 = load i8, i8* %data, align 8, !tbaa !99
  %conv38 = zext i8 %13 to i32
  %and = and i32 %conv34, %conv38
  %event_types39 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %14 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types39, align 8, !tbaa !42
  %idxprom40 = sext i32 %i.0 to i64
  %arrayidx41 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %14, i64 %idxprom40
  %data42 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx41, i32 0, i32 0
  %15 = load i8, i8* %data42, align 8, !tbaa !99
  %conv43 = zext i8 %15 to i32
  %cmp44 = icmp ne i32 %and, %conv43
  br i1 %cmp44, label %for.inc87, label %if.end47

if.end47:                                         ; preds = %for.body
  %16 = load i64, i64* @mask, align 8, !tbaa !100
  %event_types48 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %17 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types48, align 8, !tbaa !42
  %idxprom49 = sext i32 %i.0 to i64
  %arrayidx50 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %17, i64 %idxprom49
  %mask51 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx50, i32 0, i32 1
  %18 = load i64, i64* %mask51, align 8, !tbaa !97
  %and52 = and i64 %16, %18
  %tobool53 = icmp ne i64 %and52, 0
  br i1 %tobool53, label %if.end55, label %for.inc87

if.end55:                                         ; preds = %if.end47
  br label %for.cond56

for.cond56:                                       ; preds = %for.inc, %if.end55
  %j.0 = phi i32 [ 0, %if.end55 ], [ %inc, %for.inc ]
  %event_types57 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %19 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types57, align 8, !tbaa !42
  %idxprom58 = sext i32 %i.0 to i64
  %arrayidx59 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %19, i64 %idxprom58
  %events = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx59, i32 0, i32 2
  %20 = load %struct.sonypi_event*, %struct.sonypi_event** %events, align 8, !tbaa !101
  %idxprom60 = sext i32 %j.0 to i64
  %arrayidx61 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %20, i64 %idxprom60
  %event = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %arrayidx61, i32 0, i32 1
  %21 = load i8, i8* %event, align 1, !tbaa !102
  %tobool62 = icmp ne i8 %21, 0
  br i1 %tobool62, label %for.body63, label %for.inc87

for.body63:                                       ; preds = %for.cond56
  %conv64 = zext i8 %call to i32
  %event_types65 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %22 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types65, align 8, !tbaa !42
  %idxprom66 = sext i32 %i.0 to i64
  %arrayidx67 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %22, i64 %idxprom66
  %events68 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx67, i32 0, i32 2
  %23 = load %struct.sonypi_event*, %struct.sonypi_event** %events68, align 8, !tbaa !101
  %idxprom69 = sext i32 %j.0 to i64
  %arrayidx70 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %23, i64 %idxprom69
  %data71 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %arrayidx70, i32 0, i32 0
  %24 = load i8, i8* %data71, align 1, !tbaa !104
  %conv72 = zext i8 %24 to i32
  %cmp73 = icmp eq i32 %conv64, %conv72
  br i1 %cmp73, label %if.then75, label %for.inc

if.then75:                                        ; preds = %for.body63
  %event_types76 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %25 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types76, align 8, !tbaa !42
  %idxprom77 = sext i32 %i.0 to i64
  %arrayidx78 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %25, i64 %idxprom77
  %events79 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx78, i32 0, i32 2
  %26 = load %struct.sonypi_event*, %struct.sonypi_event** %events79, align 8, !tbaa !101
  %idxprom80 = sext i32 %j.0 to i64
  %arrayidx81 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %26, i64 %idxprom80
  %event82 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %arrayidx81, i32 0, i32 1
  %27 = load i8, i8* %event82, align 1, !tbaa !102
  %tobool83 = icmp ne i8 %27, 0
  br i1 %tobool83, label %found, label %cleanup

for.inc:                                          ; preds = %for.body63
  %inc = add nsw i32 %j.0, 1
  br label %for.cond56

for.inc87:                                        ; preds = %for.cond56, %if.end47, %for.body
  %inc88 = add nsw i32 %i.0, 1
  br label %for.cond

for.end89:                                        ; preds = %for.cond
  %handle_irq = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 7
  %28 = load i32 (i8, i8)*, i32 (i8, i8)** %handle_irq, align 8, !tbaa !40
  %tobool90 = icmp ne i32 (i8, i8)* %28, null
  br i1 %tobool90, label %land.lhs.true, label %do.body97

land.lhs.true:                                    ; preds = %for.end89
  %handle_irq91 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 7
  %29 = load i32 (i8, i8)*, i32 (i8, i8)** %handle_irq91, align 8, !tbaa !40
  %call92 = call i32 %29(i8 zeroext %call13, i8 zeroext %call)
  %cmp93 = icmp ne i32 %call92, 0
  %30 = load i32, i32* @debug, align 4
  %tobool98 = icmp ne i32 %30, 0
  %or.cond1 = and i1 %cmp93, %tobool98
  br i1 %or.cond1, label %if.then99, label %cleanup

do.body97:                                        ; preds = %for.end89
  %.old = load i32, i32* @debug, align 4, !tbaa !2
  %tobool98.old = icmp ne i32 %.old, 0
  br i1 %tobool98.old, label %if.then99, label %cleanup

if.then99:                                        ; preds = %do.body97, %land.lhs.true
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

found:                                            ; preds = %if.then75
  call void @sony_laptop_report_input_event(i8 zeroext %27)
  call void @sonypi_compat_report_event(i8 zeroext %27)
  br label %cleanup

cleanup:                                          ; preds = %found, %if.then99, %do.body97, %land.lhs.true, %if.then75, %do.end
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_enable(%struct.acpi_device* %device, %struct.sony_pic_ioport* %ioport, %struct.sony_pic_irq* %irq) #0 {
entry:
  %buffer = alloca %struct.acpi_buffer, align 8
  %0 = bitcast %struct.acpi_buffer* %buffer to i8*
  %1 = bitcast %struct.acpi_buffer* %buffer to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 16, i32 8, i1 false)
  %tobool = icmp ne %struct.sony_pic_ioport* %ioport, null
  %tobool1 = icmp ne %struct.sony_pic_irq* %irq, null
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call = call i8* @kzalloc(i64 273, i32 20971712)
  %2 = bitcast i8* %call to %struct.anon.72*
  %tobool2 = icmp ne %struct.anon.72* %2, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %length = getelementptr inbounds %struct.acpi_buffer, %struct.acpi_buffer* %buffer, i32 0, i32 0
  store i64 273, i64* %length, align 8, !tbaa !105
  %3 = bitcast %struct.anon.72* %2 to i8*
  %pointer = getelementptr inbounds %struct.acpi_buffer, %struct.acpi_buffer* %buffer, i32 0, i32 1
  store i8* %3, i8** %pointer, align 8, !tbaa !107
  %4 = load i32, i32* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 8), align 8, !tbaa !39
  %cmp = icmp eq i32 %4, 1
  %res1 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 0
  %type = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res1, i32 0, i32 0
  store i32 4, i32* %type, align 1, !tbaa !108
  %res16 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 0
  %length7 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res16, i32 0, i32 1
  store i32 68, i32* %length7, align 1, !tbaa !111
  %res18 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 0
  %data = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res18, i32 0, i32 2
  %io = bitcast %union.acpi_resource_data* %data to %struct.acpi_resource_io*
  %5 = bitcast %struct.acpi_resource_io* %io to i8*
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %ioport, i32 0, i32 0
  %6 = bitcast %struct.acpi_resource_io* %io1 to i8*
  %call9 = call i8* @__memcpy(i8* %5, i8* %6, i64 7)
  %res2 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 1
  %type10 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res2, i32 0, i32 0
  br i1 %cmp, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end4
  store i32 4, i32* %type10, align 1, !tbaa !112
  %res211 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 1
  %length12 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res211, i32 0, i32 1
  store i32 68, i32* %length12, align 1, !tbaa !113
  %res213 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 1
  %data14 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res213, i32 0, i32 2
  %io15 = bitcast %union.acpi_resource_data* %data14 to %struct.acpi_resource_io*
  %7 = bitcast %struct.acpi_resource_io* %io15 to i8*
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %ioport, i32 0, i32 1
  %8 = bitcast %struct.acpi_resource_io* %io2 to i8*
  %call16 = call i8* @__memcpy(i8* %7, i8* %8, i64 7)
  %res3 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 2
  %type17 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res3, i32 0, i32 0
  store i32 0, i32* %type17, align 1, !tbaa !114
  %res318 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 2
  %length19 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res318, i32 0, i32 1
  store i32 68, i32* %length19, align 1, !tbaa !115
  %res320 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 2
  %data21 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res320, i32 0, i32 2
  %irq22 = bitcast %union.acpi_resource_data* %data21 to %struct.acpi_resource_irq*
  %9 = bitcast %struct.acpi_resource_irq* %irq22 to i8*
  %irq23 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq, i32 0, i32 0
  %10 = bitcast %struct.acpi_resource_irq* %irq23 to i8*
  %call24 = call i8* @__memcpy(i8* %9, i8* %10, i64 7)
  %res325 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 2
  %data26 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res325, i32 0, i32 2
  %irq27 = bitcast %union.acpi_resource_data* %data26 to %struct.acpi_resource_irq*
  %sharable = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq27, i32 0, i32 3
  store i8 1, i8* %sharable, align 1, !tbaa !31
  %res4 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 3
  %type28 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res4, i32 0, i32 0
  store i32 7, i32* %type28, align 1, !tbaa !116
  %res429 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 3
  br label %if.end57

if.else:                                          ; preds = %if.end4
  store i32 0, i32* %type10, align 1, !tbaa !112
  %res242 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 1
  %length43 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res242, i32 0, i32 1
  store i32 68, i32* %length43, align 1, !tbaa !113
  %res244 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 1
  %data45 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res244, i32 0, i32 2
  %irq46 = bitcast %union.acpi_resource_data* %data45 to %struct.acpi_resource_irq*
  %11 = bitcast %struct.acpi_resource_irq* %irq46 to i8*
  %irq47 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq, i32 0, i32 0
  %12 = bitcast %struct.acpi_resource_irq* %irq47 to i8*
  %call48 = call i8* @__memcpy(i8* %11, i8* %12, i64 7)
  %res249 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 1
  %data50 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res249, i32 0, i32 2
  %irq51 = bitcast %union.acpi_resource_data* %data50 to %struct.acpi_resource_irq*
  %sharable52 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq51, i32 0, i32 3
  store i8 1, i8* %sharable52, align 1, !tbaa !31
  %res353 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 2
  %type54 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res353, i32 0, i32 0
  store i32 7, i32* %type54, align 1, !tbaa !114
  %res355 = getelementptr inbounds %struct.anon.72, %struct.anon.72* %2, i32 0, i32 2
  br label %if.end57

if.end57:                                         ; preds = %if.else, %if.then5
  %res355.sink = phi %struct.acpi_resource* [ %res355, %if.else ], [ %res429, %if.then5 ]
  %length56 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res355.sink, i32 0, i32 1
  store i32 68, i32* %length56, align 1, !tbaa !2
  %13 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool58 = icmp ne i32 %13, 0
  br i1 %tobool58, label %if.then59, label %do.end

if.then59:                                        ; preds = %if.end57
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then59, %if.end57
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %14 = load i8*, i8** %handle, align 8, !tbaa !43
  %call62 = call i32 @acpi_set_current_resources(i8* %14, %struct.acpi_buffer* %buffer)
  %tobool63 = icmp ne i32 %call62, 0
  br i1 %tobool63, label %if.then64, label %if.end66

if.then64:                                        ; preds = %do.end
  call void (i8*, ...) @printk(i8* null)
  br label %end

if.end66:                                         ; preds = %do.end
  call void @sony_pic_call1(i8 zeroext -126)
  %call68 = call zeroext i8 @sony_pic_call2(i8 zeroext -127, i8 zeroext -1)
  %15 = load i32, i32* @compat, align 4, !tbaa !2
  %tobool69 = icmp ne i32 %15, 0
  %cond = select i1 %tobool69, i32 146, i32 130
  %conv = trunc i32 %cond to i8
  call void @sony_pic_call1(i8 zeroext %conv)
  br label %end

end:                                              ; preds = %if.end66, %if.then64
  %result.0 = phi i32 [ -19, %if.then64 ], [ 0, %if.end66 ]
  %16 = bitcast %struct.anon.72* %2 to i8*
  call void @kfree(i8* %16)
  br label %cleanup

cleanup:                                          ; preds = %end, %if.end, %entry
  %retval.0 = phi i32 [ %result.0, %end ], [ -22, %entry ], [ -12, %if.end ]
  %17 = bitcast %struct.acpi_buffer* %buffer to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pf_add() #0 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @sony_pf_users, i64 0, i32 0), i32 1, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @sony_pf_users, i64 0, i32 0)) #7, !srcloc !76
  %add.i = add nsw i32 1, %0
  %cmp = icmp sgt i32 %add.i, 1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @__platform_driver_register(%struct.platform_driver* @sony_pf_driver, %struct.module* @__this_module)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %out, label %if.end3

if.end3:                                          ; preds = %if.end
  %call4 = call %struct.platform_device* @platform_device_alloc(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.21, i32 0, i32 0), i32 -1)
  store %struct.platform_device* %call4, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  %1 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  %tobool5 = icmp ne %struct.platform_device* %1, null
  br i1 %tobool5, label %if.end7, label %out_platform_registered

if.end7:                                          ; preds = %if.end3
  %2 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  %call8 = call i32 @platform_device_add(%struct.platform_device* %2)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %out_platform_alloced, label %cleanup

out_platform_alloced:                             ; preds = %if.end7
  %3 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  call void @platform_device_put(%struct.platform_device* %3)
  store %struct.platform_device* null, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  br label %out_platform_registered

out_platform_registered:                          ; preds = %out_platform_alloced, %if.end3
  %ret.0 = phi i32 [ %call8, %out_platform_alloced ], [ -12, %if.end3 ]
  call void @platform_driver_unregister(%struct.platform_driver* @sony_pf_driver)
  br label %out

out:                                              ; preds = %out_platform_registered, %if.end
  %ret.1 = phi i32 [ %ret.0, %out_platform_registered ], [ %call1, %if.end ]
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @sony_pf_users, i64 0, i32 0), i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @sony_pf_users, i64 0, i32 0)) #7, !srcloc !94
  br label %cleanup

cleanup:                                          ; preds = %out, %if.end7, %entry
  %retval.0 = phi i32 [ %ret.1, %out ], [ 0, %entry ], [ 0, %if.end7 ]
  ret i32 %retval.0
}

declare i32 @sysfs_create_group(%struct.kobject*, %struct.attribute_group*) #1

; Function Attrs: nounwind uwtable
define internal void @sony_pf_remove() #0 {
entry:
  %c.i = alloca i8, align 1
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0;\0A\09sete $1\0A", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @sony_pf_users, i64 0, i32 0), i8* %c.i, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @sony_pf_users, i64 0, i32 0)) #7, !srcloc !117
  %0 = load i8, i8* %c.i, align 1, !tbaa !118, !range !119
  %tobool.i = trunc i8 %0 to i1
  br i1 %tobool.i, label %if.end, label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  call void @platform_device_unregister(%struct.platform_device* %1)
  call void @platform_driver_unregister(%struct.platform_driver* @sony_pf_driver)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_disable(%struct.acpi_device* %device) #0 {
entry:
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %0 = load i8*, i8** %handle, align 8, !tbaa !43
  %call = call i32 @acpi_evaluate_object(i8* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.72, i32 0, i32 0), %struct.acpi_object_list* null, %struct.acpi_buffer* null)
  switch i32 %call, label %cleanup [
    i32 0, label %do.body
    i32 5, label %do.body
  ]

do.body:                                          ; preds = %entry, %entry
  %1 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then2, %do.body, %entry
  %retval.0 = phi i32 [ -6, %entry ], [ 0, %if.then2 ], [ 0, %do.body ]
  ret i32 %retval.0
}

declare void @free_irq(i32, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @sonypi_compat_exit() #0 {
entry:
  call void @misc_deregister(%struct.miscdevice* @sonypi_misc_device)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.70* %0 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_laptop_remove_input() #0 {
entry:
  %c.i = alloca i8, align 1
  %kp = alloca %struct.sony_laptop_keypress, align 8
  %0 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %1 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 16, i32 8, i1 false)
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0;\0A\09sete $1\0A", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i64 0, i32 0, i32 0), i8* %c.i, i32* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i64 0, i32 0, i32 0)) #7, !srcloc !117
  %2 = load i8, i8* %c.i, align 1, !tbaa !118, !range !119
  %tobool.i = trunc i8 %2 to i1
  br i1 %tobool.i, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @del_timer_sync(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5))
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %3 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %4 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.70* %4 to %struct.__kfifo*
  %conv = trunc i64 16 to i32
  %call2 = call i32 @__kfifo_out(%struct.__kfifo* %kfifo, i8* %3, i32 %conv)
  %call3 = call i32 @__kfifo_uint_must_check_helper(i32 %call2)
  %conv4 = zext i32 %call3 to i64
  %cmp = icmp eq i64 %conv4, 16
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %dev = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %5 = load %struct.input_dev*, %struct.input_dev** %dev, align 8, !tbaa !120
  %key = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %6 = load i32, i32* %key, align 8, !tbaa !122
  call void @input_report_key(%struct.input_dev* %5, i32 %6, i32 0)
  %dev6 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %7 = load %struct.input_dev*, %struct.input_dev** %dev6, align 8, !tbaa !120
  call void @input_sync(%struct.input_dev* %7)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %8 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !90
  call void @input_unregister_device(%struct.input_dev* %8)
  store %struct.input_dev* null, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !90
  %9 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !93
  %tobool = icmp ne %struct.input_dev* %9, null
  br i1 %tobool, label %if.then7, label %if.end8

if.then7:                                         ; preds = %while.end
  %10 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !93
  call void @input_unregister_device(%struct.input_dev* %10)
  store %struct.input_dev* null, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !93
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %while.end
  %11 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo11 = bitcast %union.anon.70* %11 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo11)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %entry
  %12 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del(%struct.list_head* %entry1) #4 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !34
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !123
  ret void
}

declare void @kfree(i8*) #1

declare %struct.pci_dev* @pci_get_device(i32, i32, %struct.pci_dev*) #1

; Function Attrs: nounwind uwtable
define internal i32 @type3_handle_irq(i8 zeroext %data_mask, i8 zeroext %ev) #0 {
entry:
  %conv = zext i8 %data_mask to i32
  %cmp = icmp eq i32 %conv, 49
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %conv2 = zext i8 %ev to i32
  %cmp3 = icmp eq i32 %conv2, 92
  %conv5 = zext i8 %ev to i32
  %cmp6 = icmp eq i32 %conv5, 95
  %or.cond = or i1 %cmp3, %cmp6
  br i1 %or.cond, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  call void @sony_pic_call1(i8 zeroext -96)
  br label %return

if.else:                                          ; preds = %if.then
  %conv9 = zext i8 %ev to i32
  %cmp10 = icmp eq i32 %conv9, 97
  br i1 %cmp10, label %if.then12, label %return

if.then12:                                        ; preds = %if.else
  call void @sony_pic_call1(i8 zeroext -77)
  br label %return

return:                                           ; preds = %if.then12, %if.else, %if.then8, %entry
  %retval.0 = phi i32 [ 0, %if.else ], [ 0, %if.then12 ], [ 0, %if.then8 ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @pci_dev_put(%struct.pci_dev*) #1

declare i32 @acpi_bus_get_status(%struct.acpi_device*) #1

declare i32 @acpi_walk_resources(i8*, i8*, i32 (%struct.acpi_resource*, i8*)*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_read_possible_resource(%struct.acpi_resource* %resource, i8* %context) #0 {
entry:
  %0 = bitcast i8* %context to %struct.sony_pic_dev*
  %type = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %resource, i32 0, i32 0
  %1 = load i32, i32* %type, align 1, !tbaa !124
  %Pivot10 = icmp slt i32 %1, 3
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %1, 4
  br i1 %Pivot8, label %cleanup107, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %1, 7
  br i1 %Pivot6, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp ne i32 %1, 7
  %2 = load i32, i32* @debug, align 4
  %tobool99 = icmp ne i32 %2, 0
  %or.cond = and i1 %SwitchLeaf4, %tobool99
  br i1 %or.cond, label %if.then100, label %cleanup107

LeafBlock1:                                       ; preds = %NodeBlock5
  %SwitchLeaf2 = icmp eq i32 %1, 4
  br i1 %SwitchLeaf2, label %sw.bb43, label %do.body98

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %1, 2
  br i1 %Pivot, label %LeafBlock, label %sw.bb

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %1, 0
  br i1 %SwitchLeaf, label %sw.bb2, label %do.body98

sw.bb:                                            ; preds = %NodeBlock
  %call = call i8* @kzalloc(i64 32, i32 20971712)
  %3 = bitcast i8* %call to %struct.sony_pic_ioport*
  %tobool = icmp ne %struct.sony_pic_ioport* %3, null
  br i1 %tobool, label %if.end, label %cleanup107

if.end:                                           ; preds = %sw.bb
  %list = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 2
  %ioports = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 4
  call void @list_add(%struct.list_head* %list, %struct.list_head* %ioports)
  br label %cleanup107

sw.bb2:                                           ; preds = %LeafBlock
  %data = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %resource, i32 0, i32 2
  %irq = bitcast %union.acpi_resource_data* %data to %struct.acpi_resource_irq*
  %tobool3 = icmp ne %struct.acpi_resource_irq* %irq, null
  br i1 %tobool3, label %lor.lhs.false, label %do.body

lor.lhs.false:                                    ; preds = %sw.bb2
  %interrupt_count = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 5
  %4 = load i8, i8* %interrupt_count, align 1, !tbaa !125
  %tobool4 = icmp ne i8 %4, 0
  br i1 %tobool4, label %if.end10, label %do.body

do.body:                                          ; preds = %lor.lhs.false, %sw.bb2
  %5 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool6 = icmp ne i32 %5, 0
  br i1 %tobool6, label %if.then7, label %cleanup107

if.then7:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup107

if.end10:                                         ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %i.0 = phi i32 [ 0, %if.end10 ], [ %inc, %for.inc ]
  %interrupt_count11 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 5
  %6 = load i8, i8* %interrupt_count11, align 1, !tbaa !125
  %conv = zext i8 %6 to i32
  %cmp = icmp ult i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup107

for.body:                                         ; preds = %for.cond
  %interrupts = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 6
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts, i64 0, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !31
  %tobool13 = icmp ne i8 %7, 0
  br i1 %tobool13, label %if.end20, label %if.then14

if.then14:                                        ; preds = %for.body
  call void (i8*, ...) @printk(i8* null)
  br label %for.inc

if.end20:                                         ; preds = %for.body
  %call21 = call i8* @kzalloc(i64 24, i32 20971712)
  %8 = bitcast i8* %call21 to %struct.sony_pic_irq*
  %tobool22 = icmp ne %struct.sony_pic_irq* %8, null
  br i1 %tobool22, label %if.end24, label %cleanup107

if.end24:                                         ; preds = %if.end20
  %list25 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 1
  %interrupts26 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 3
  call void @list_add(%struct.list_head* %list25, %struct.list_head* %interrupts26)
  %triggering = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 1
  %9 = load i8, i8* %triggering, align 1, !tbaa !126
  %irq27 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 0
  %triggering28 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq27, i32 0, i32 1
  store i8 %9, i8* %triggering28, align 1, !tbaa !127
  %polarity = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 2
  %10 = load i8, i8* %polarity, align 1, !tbaa !128
  %irq29 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 0
  %polarity30 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq29, i32 0, i32 2
  store i8 %10, i8* %polarity30, align 2, !tbaa !129
  %sharable = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 3
  %11 = load i8, i8* %sharable, align 1, !tbaa !130
  %irq31 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 0
  %sharable32 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq31, i32 0, i32 3
  store i8 %11, i8* %sharable32, align 1, !tbaa !131
  %irq33 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 0
  %interrupt_count34 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq33, i32 0, i32 5
  store i8 1, i8* %interrupt_count34, align 1, !tbaa !132
  %interrupts35 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 6
  %idxprom36 = zext i32 %i.0 to i64
  %arrayidx37 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts35, i64 0, i64 %idxprom36
  %12 = load i8, i8* %arrayidx37, align 1, !tbaa !31
  %irq38 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 0
  %interrupts39 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq38, i32 0, i32 6
  %arrayidx40 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts39, i64 0, i64 0
  store i8 %12, i8* %arrayidx40, align 2, !tbaa !31
  br label %for.inc

for.inc:                                          ; preds = %if.end24, %if.then14
  %inc = add i32 %i.0, 1
  br label %for.cond

sw.bb43:                                          ; preds = %LeafBlock1
  %data44 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %resource, i32 0, i32 2
  %io45 = bitcast %union.acpi_resource_data* %data44 to %struct.acpi_resource_io*
  %ioports47 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %ioports47, i32 0, i32 0
  %13 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !34
  %14 = bitcast %struct.list_head* %13 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %14, i64 -16
  %15 = bitcast i8* %add.ptr to %struct.sony_pic_ioport*
  %tobool48 = icmp ne %struct.acpi_resource_io* %io45, null
  br i1 %tobool48, label %if.end57, label %do.body50

do.body50:                                        ; preds = %sw.bb43
  %16 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool51 = icmp ne i32 %16, 0
  br i1 %tobool51, label %if.then52, label %cleanup107

if.then52:                                        ; preds = %do.body50
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup107

if.end57:                                         ; preds = %sw.bb43
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %17 = load i16, i16* %minimum, align 1, !tbaa !19
  %tobool58 = icmp ne i16 %17, 0
  br i1 %tobool58, label %if.else, label %if.then59

if.then59:                                        ; preds = %if.end57
  %io160 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 0
  %18 = bitcast %struct.acpi_resource_io* %io160 to i8*
  %19 = bitcast %struct.acpi_resource_io* %io45 to i8*
  %call61 = call i8* @__memcpy(i8* %18, i8* %19, i64 7)
  %20 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool63 = icmp ne i32 %20, 0
  br i1 %tobool63, label %if.then64, label %cleanup107

if.then64:                                        ; preds = %if.then59
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup107

if.else:                                          ; preds = %if.end57
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 1
  %minimum74 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %21 = load i16, i16* %minimum74, align 1, !tbaa !29
  %tobool75 = icmp ne i16 %21, 0
  br i1 %tobool75, label %if.else92, label %if.then76

if.then76:                                        ; preds = %if.else
  %io277 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 1
  %22 = bitcast %struct.acpi_resource_io* %io277 to i8*
  %23 = bitcast %struct.acpi_resource_io* %io45 to i8*
  %call78 = call i8* @__memcpy(i8* %22, i8* %23, i64 7)
  %24 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool80 = icmp ne i32 %24, 0
  br i1 %tobool80, label %if.then81, label %cleanup107

if.then81:                                        ; preds = %if.then76
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup107

if.else92:                                        ; preds = %if.else
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup107

do.body98:                                        ; preds = %LeafBlock, %LeafBlock1
  %.old = load i32, i32* @debug, align 4, !tbaa !2
  %tobool99.old = icmp ne i32 %.old, 0
  br i1 %tobool99.old, label %if.then100, label %cleanup107

if.then100:                                       ; preds = %do.body98, %LeafBlock3
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup107

cleanup107:                                       ; preds = %if.then100, %do.body98, %if.else92, %if.then81, %if.then76, %if.then64, %if.then59, %if.then52, %do.body50, %if.end20, %for.cond, %if.then7, %do.body, %if.end, %sw.bb, %LeafBlock3, %NodeBlock7
  %retval.3 = phi i32 [ 0, %if.end ], [ 1, %sw.bb ], [ 0, %NodeBlock7 ], [ 0, %if.then7 ], [ 0, %do.body ], [ 1, %if.end20 ], [ 0, %for.cond ], [ 1, %if.else92 ], [ 0, %if.then52 ], [ 0, %do.body50 ], [ 0, %if.then81 ], [ 0, %if.then76 ], [ 0, %if.then59 ], [ 0, %if.then64 ], [ 0, %do.body98 ], [ 0, %if.then100 ], [ 0, %LeafBlock3 ]
  ret i32 %retval.3
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #4 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #4 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !34
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

declare i8* @__memcpy(i8*, i8*, i64) #1

declare noalias i8* @__kmalloc(i64, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #4 {
entry:
  %__u = alloca %union.anon.68, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !123
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !34
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !123
  %0 = bitcast %union.anon.68* %__u to i8*
  %__val = bitcast %union.anon.68* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !31
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.68* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %2 = bitcast i8* %arraydecay to i64*
  %3 = load i64, i64* %2, align 8, !tbaa !133
  %4 = bitcast i8* %1 to i64*
  store volatile i64 %3, i64* %4, align 8, !tbaa !133
  %5 = bitcast %union.anon.68* %__u to i8*
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_add_valid(%struct.list_head*, %struct.list_head*, %struct.list_head*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kfifo_int_must_check_helper(i32 %val) #4 {
entry:
  ret i32 %val
}

declare i32 @__kfifo_alloc(%struct.__kfifo*, i32, i64, i32) #1

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #1

; Function Attrs: nounwind uwtable
define internal void @do_sony_laptop_release_key(i64 %unused) #0 {
entry:
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %kp = alloca %struct.sony_laptop_keypress, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %1 = bitcast i64* %__dummy to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy2 to i8*
  %4 = bitcast i64* %__dummy to i8*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i64 0, i32 4, i32 0, i32 0))
  %5 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %6 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.70* %6 to %struct.__kfifo*
  %conv6 = trunc i64 16 to i32
  %call7 = call i32 @__kfifo_out(%struct.__kfifo* %kfifo, i8* %5, i32 %conv6)
  %call8 = call i32 @__kfifo_uint_must_check_helper(i32 %call7)
  %conv9 = zext i32 %call8 to i64
  %cmp10 = icmp eq i64 %conv9, 16
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %7 = load %struct.input_dev*, %struct.input_dev** %dev, align 8, !tbaa !120
  %key = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %8 = load i32, i32* %key, align 8, !tbaa !122
  call void @input_report_key(%struct.input_dev* %7, i32 %8, i32 0)
  %dev12 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %9 = load %struct.input_dev*, %struct.input_dev** %dev12, align 8, !tbaa !120
  call void @input_sync(%struct.input_dev* %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo14 = bitcast %union.anon.70* %10 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo14, i32 0, i32 0
  %11 = load i32, i32* %in, align 8, !tbaa !31
  %12 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo15 = bitcast %union.anon.70* %12 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo15, i32 0, i32 1
  %13 = load i32, i32* %out, align 4, !tbaa !31
  %sub = sub i32 %11, %13
  %cmp16 = icmp ne i32 %sub, 0
  br i1 %cmp16, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.end
  %14 = load volatile i64, i64* @jiffies, align 8, !tbaa !100
  %call.i = call i64 @__msecs_to_jiffies(i32 10) #7
  %add = add i64 %14, %call.i
  %call20 = call i32 @mod_timer(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5), i64 %add)
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %if.end
  %15 = bitcast i64* %__dummy.i to i8*
  %16 = bitcast i64* %__dummy2.i to i8*
  %17 = bitcast i64* %__dummy2.i to i8*
  %18 = bitcast i64* %__dummy.i to i8*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i64 0, i32 4, i32 0, i32 0), i64 %call2) #7
  %19 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  ret void
}

declare %struct.input_dev* @input_allocate_device() #1

declare void @input_set_capability(%struct.input_dev*, i32, i32) #1

declare i32 @input_register_device(%struct.input_dev*) #1

declare void @input_free_device(%struct.input_dev*) #1

declare void @input_unregister_device(%struct.input_dev*) #1

declare void @__kfifo_free(%struct.__kfifo*) #1

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kfifo_uint_must_check_helper(i32 %val) #4 {
entry:
  ret i32 %val
}

declare i32 @__kfifo_out(%struct.__kfifo*, i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_key(%struct.input_dev* %dev, i32 %code, i32 %value) #4 {
entry:
  %tobool = icmp ne i32 %value, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  call void @input_event(%struct.input_dev* %dev, i32 1, i32 %code, i32 %lnot.ext)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_sync(%struct.input_dev* %dev) #4 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 0, i32 0, i32 0)
  ret void
}

declare i32 @mod_timer(%struct.timer_list*, i64) #1

declare void @input_event(%struct.input_dev*, i32, i32, i32) #1

declare i64 @__msecs_to_jiffies(i32) #1

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

declare i32 @misc_register(%struct.miscdevice*) #1

declare i64 @noop_llseek(%struct.file*, i64, i32) #1

; Function Attrs: nounwind uwtable
define internal i64 @sonypi_misc_read(%struct.file* %file, i8* %buf, i64 %count, i64* %pos) #0 {
entry:
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %c = alloca i8, align 1
  %__wait = alloca %struct.__wait_queue, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %coerce = alloca %struct.timespec, align 8
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.70* %0 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo, i32 0, i32 0
  %1 = load i32, i32* %in, align 8, !tbaa !31
  %2 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo1 = bitcast %union.anon.70* %2 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo1, i32 0, i32 1
  %3 = load i32, i32* %out, align 4, !tbaa !31
  %sub = sub i32 %1, %3
  %cmp = icmp eq i32 %sub, 0
  br i1 %cmp, label %land.lhs.true, label %do.body

land.lhs.true:                                    ; preds = %entry
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 6
  %4 = load i32, i32* %f_flags, align 8, !tbaa !134
  %and = and i32 %4, 2048
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cleanup70, label %do.body

do.body:                                          ; preds = %land.lhs.true, %entry
  call void @__might_sleep(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i32 4105, i32 0)
  %5 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo7 = bitcast %union.anon.70* %5 to %struct.__kfifo*
  %in8 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo7, i32 0, i32 0
  %6 = load i32, i32* %in8, align 8, !tbaa !31
  %7 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo9 = bitcast %union.anon.70* %7 to %struct.__kfifo*
  %out10 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo9, i32 0, i32 1
  %8 = load i32, i32* %out10, align 4, !tbaa !31
  %sub11 = sub i32 %6, %8
  %cmp12 = icmp ne i32 %sub11, 0
  br i1 %cmp12, label %if.end29, label %if.then13

if.then13:                                        ; preds = %do.body
  %9 = bitcast %struct.__wait_queue* %__wait to i8*
  call void @init_wait_entry(%struct.__wait_queue* %__wait, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.then13
  %__ret14.0 = phi i64 [ 0, %if.then13 ], [ %__ret14.1, %cleanup.cont ]
  %call = call i64 @prepare_to_wait_event(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), %struct.__wait_queue* %__wait, i32 1)
  %10 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo17 = bitcast %union.anon.70* %10 to %struct.__kfifo*
  %in18 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo17, i32 0, i32 0
  %11 = load i32, i32* %in18, align 8, !tbaa !31
  %12 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo19 = bitcast %union.anon.70* %12 to %struct.__kfifo*
  %out20 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo19, i32 0, i32 1
  %13 = load i32, i32* %out20, align 4, !tbaa !31
  %sub21 = sub i32 %11, %13
  %cmp22 = icmp ne i32 %sub21, 0
  br i1 %cmp22, label %NodeBlock, label %if.end24

if.end24:                                         ; preds = %for.cond
  %tobool25 = icmp ne i64 %call, 0
  br i1 %tobool25, label %NodeBlock, label %if.end27

if.end27:                                         ; preds = %if.end24
  call void @schedule()
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end27, %if.end24, %for.cond
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end27 ], [ 6, %for.cond ], [ 8, %if.end24 ]
  %__ret14.1 = phi i64 [ %__ret14.0, %if.end27 ], [ %__ret14.0, %for.cond ], [ %call, %if.end24 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 8
  br i1 %Pivot, label %LeafBlock, label %__out

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 6
  br i1 %SwitchLeaf, label %for.end, label %cleanup.cont

cleanup.cont:                                     ; preds = %LeafBlock
  br label %for.cond

for.end:                                          ; preds = %LeafBlock
  call void @finish_wait(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), %struct.__wait_queue* %__wait)
  br label %__out

__out:                                            ; preds = %for.end, %NodeBlock
  %14 = bitcast %struct.__wait_queue* %__wait to i8*
  %conv = trunc i64 %__ret14.1 to i32
  br label %if.end29

if.end29:                                         ; preds = %__out, %do.body
  %__ret.0 = phi i32 [ 0, %do.body ], [ %conv, %__out ]
  %conv31 = sext i32 %__ret.0 to i64
  %tobool32 = icmp ne i64 %conv31, 0
  br i1 %tobool32, label %cleanup70, label %if.end34

if.end34:                                         ; preds = %if.end29
  br label %while.cond

while.cond:                                       ; preds = %if.end63, %if.end34
  %ret.0 = phi i64 [ %conv31, %if.end34 ], [ %inc, %if.end63 ]
  %buf.addr.0 = phi i8* [ %buf, %if.end34 ], [ %incdec.ptr, %if.end63 ]
  %cmp35 = icmp ult i64 %ret.0, %count
  br i1 %cmp35, label %do.body39, label %while.end

do.body39:                                        ; preds = %while.cond
  %15 = bitcast i64* %__dummy to i8*
  %16 = bitcast i64* %__dummy2 to i8*
  %17 = bitcast i64* %__dummy2 to i8*
  %18 = bitcast i64* %__dummy to i8*
  %call44 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i64 0, i32 2, i32 0, i32 0))
  %19 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo49 = bitcast %union.anon.70* %19 to %struct.__kfifo*
  %conv51 = trunc i64 1 to i32
  %call52 = call i32 @__kfifo_out(%struct.__kfifo* %kfifo49, i8* %c, i32 %conv51)
  %call53 = call i32 @__kfifo_uint_must_check_helper(i32 %call52)
  %20 = bitcast i64* %__dummy.i to i8*
  %21 = bitcast i64* %__dummy2.i to i8*
  %22 = bitcast i64* %__dummy2.i to i8*
  %23 = bitcast i64* %__dummy.i to i8*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i64 0, i32 2, i32 0, i32 0), i64 %call44) #7
  %call55 = call i32 @__kfifo_uint_must_check_helper(i32 %call53)
  %conv56 = zext i32 %call55 to i64
  %cmp57 = icmp eq i64 %conv56, 1
  br i1 %cmp57, label %while.body, label %while.end

while.body:                                       ; preds = %do.body39
  call void @__might_fault(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.1, i32 0, i32 0), i32 4112)
  %24 = load i8, i8* %c, align 1, !tbaa !31
  %25 = zext i8 %24 to i32
  %incdec.ptr = getelementptr inbounds i8, i8* %buf.addr.0, i32 1
  %26 = call i32 asm sideeffect "call __put_user_1", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %25, i8* %buf.addr.0) #7, !srcloc !142
  %conv60 = sext i32 %26 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv60, i64 0)
  %tobool61 = icmp ne i64 %expval, 0
  br i1 %tobool61, label %cleanup70, label %if.end63

if.end63:                                         ; preds = %while.body
  %inc = add nsw i64 %ret.0, 1
  br label %while.cond

while.end:                                        ; preds = %do.body39, %while.cond
  %cmp64 = icmp sgt i64 %ret.0, 0
  br i1 %cmp64, label %if.then66, label %cleanup70

if.then66:                                        ; preds = %while.end
  %call67 = call %struct.inode* @file_inode(%struct.file* %file)
  %i_atime = getelementptr inbounds %struct.inode, %struct.inode* %call67, i32 0, i32 15
  %call68 = call { i64, i64 } @current_time(%struct.inode* %call67)
  %27 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 0
  %29 = extractvalue { i64, i64 } %call68, 0
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %27, i32 0, i32 1
  %31 = extractvalue { i64, i64 } %call68, 1
  store i64 %31, i64* %30, align 8
  %32 = bitcast %struct.timespec* %i_atime to i8*
  %33 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %32, i8* %33, i64 16, i32 8, i1 false), !tbaa.struct !143
  br label %cleanup70

cleanup70:                                        ; preds = %if.then66, %while.end, %while.body, %if.end29, %land.lhs.true
  %retval.0 = phi i64 [ -11, %land.lhs.true ], [ %conv31, %if.end29 ], [ -14, %while.body ], [ %ret.0, %if.then66 ], [ %ret.0, %while.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), %struct.poll_table_struct* %wait)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.70* %0 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo, i32 0, i32 0
  %1 = load i32, i32* %in, align 8, !tbaa !31
  %2 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo1 = bitcast %union.anon.70* %2 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo1, i32 0, i32 1
  %3 = load i32, i32* %out, align 4, !tbaa !31
  %sub = sub i32 %1, %3
  %tobool = icmp ne i32 %sub, 0
  %. = select i1 %tobool, i32 65, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i64 @sonypi_misc_ioctl(%struct.file* %fp, i32 %cmd, i64 %arg) #0 {
entry:
  %val8 = alloca i8, align 1
  %val16 = alloca i16, align 2
  %value = alloca i32, align 4
  %0 = inttoptr i64 %arg to i8*
  %1 = bitcast i16* %val16 to i8*
  %2 = bitcast i32* %value to i8*
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %Pivot34 = icmp slt i32 %cmd, -2147322365
  br i1 %Pivot34, label %NodeBlock13, label %NodeBlock31

NodeBlock31:                                      ; preds = %entry
  %Pivot32 = icmp slt i32 %cmd, 1073837568
  br i1 %Pivot32, label %NodeBlock19, label %NodeBlock29

NodeBlock29:                                      ; preds = %NodeBlock31
  %Pivot30 = icmp slt i32 %cmd, 1073837577
  br i1 %Pivot30, label %LeafBlock21, label %NodeBlock27

NodeBlock27:                                      ; preds = %NodeBlock29
  %Pivot28 = icmp slt i32 %cmd, 1073837579
  br i1 %Pivot28, label %LeafBlock23, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %cmd, 1073837579
  br i1 %SwitchLeaf26, label %sw.bb89, label %sw.epilog

LeafBlock23:                                      ; preds = %NodeBlock27
  %SwitchLeaf24 = icmp eq i32 %cmd, 1073837577
  br i1 %SwitchLeaf24, label %sw.bb75, label %sw.epilog

LeafBlock21:                                      ; preds = %NodeBlock29
  %SwitchLeaf22 = icmp eq i32 %cmd, 1073837568
  br i1 %SwitchLeaf22, label %sw.bb7, label %sw.epilog

NodeBlock19:                                      ; preds = %NodeBlock31
  %Pivot20 = icmp slt i32 %cmd, -2147322364
  br i1 %Pivot20, label %sw.bb31, label %NodeBlock17

NodeBlock17:                                      ; preds = %NodeBlock19
  %Pivot18 = icmp slt i32 %cmd, -2147322363
  br i1 %Pivot18, label %sw.bb40, label %LeafBlock15

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %cmd, -2147322363
  br i1 %SwitchLeaf16, label %sw.bb49, label %sw.epilog

NodeBlock13:                                      ; preds = %entry
  %Pivot14 = icmp slt i32 %cmd, -2147387894
  br i1 %Pivot14, label %NodeBlock3, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %cmd, -2147387892
  br i1 %Pivot12, label %LeafBlock5, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %cmd, -2147322366
  br i1 %Pivot10, label %LeafBlock7, label %sw.bb22

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %cmd, -2147387892
  br i1 %SwitchLeaf8, label %sw.bb99, label %sw.epilog

LeafBlock5:                                       ; preds = %NodeBlock11
  %SwitchLeaf6 = icmp eq i32 %cmd, -2147387894
  br i1 %SwitchLeaf6, label %sw.bb80, label %sw.epilog

NodeBlock3:                                       ; preds = %NodeBlock13
  %Pivot4 = icmp slt i32 %cmd, -2147387897
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cmd, -2147387896
  br i1 %Pivot, label %sw.bb58, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, -2147387896
  br i1 %SwitchLeaf2, label %sw.bb70, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cmd, -2147387904
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %3 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !144
  %cmp = icmp eq %struct.backlight_device* %3, null
  br i1 %cmp, label %sw.epilog, label %if.end

if.end:                                           ; preds = %sw.bb
  %4 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call = call i32 @sony_nc_int_call(i8* %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.53, i32 0, i32 0), i32* null, i32* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %sw.epilog, label %if.end2

if.end2:                                          ; preds = %if.end
  %5 = load i32, i32* %value, align 4, !tbaa !2
  %and = and i32 %5, 255
  %sub = sub nsw i32 %and, 1
  %shl = shl i32 %sub, 5
  %conv = trunc i32 %shl to i8
  store i8 %conv, i8* %val8, align 1, !tbaa !31
  %6 = call i64 @llvm.objectsize.i64.p0i8(i8* %val8, i1 false, i1 true) #7
  %conv.i99 = trunc i64 %6 to i32
  call void @kasan_check_read(i8* %val8, i32 1) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 718) #7
  %cmp.i100 = icmp slt i32 %conv.i99, 0
  %conv3.i101 = sext i32 %conv.i99 to i64
  %cmp4.i102 = icmp uge i64 %conv3.i101, 1
  %7 = select i1 %cmp.i100, i1 true, i1 %cmp4.i102
  %lnot.i103 = xor i1 %7, true
  %lnot.ext.i104 = zext i1 %7 to i32
  %conv7.i105 = sext i32 %lnot.ext.i104 to i64
  %expval.i106 = call i64 @llvm.expect.i64(i64 %conv7.i105, i64 1) #7
  %tobool.i107 = icmp ne i64 %expval.i106, 0
  br i1 %tobool.i107, label %if.then.i109, label %if.else.i110

if.then.i109:                                     ; preds = %if.end2
  call void @__check_object_size(i8* %val8, i64 1, i1 zeroext true) #7
  %call.i108 = call i64 @_copy_to_user(i8* %0, i8* %val8, i32 1) #7
  br label %copy_to_user.exit112

if.else.i110:                                     ; preds = %if.end2
  call void @copy_user_overflow(i32 %conv.i99, i64 1) #7
  br label %copy_to_user.exit112

copy_to_user.exit112:                             ; preds = %if.else.i110, %if.then.i109
  %n.addr.0.i111 = phi i64 [ %call.i108, %if.then.i109 ], [ 1, %if.else.i110 ]
  %tobool4 = icmp ne i64 %n.addr.0.i111, 0
  %. = select i1 %tobool4, i32 -14, i32 0
  br label %sw.epilog

sw.bb7:                                           ; preds = %LeafBlock21
  %8 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !144
  %cmp8 = icmp eq %struct.backlight_device* %8, null
  br i1 %cmp8, label %sw.epilog, label %if.end11

if.end11:                                         ; preds = %sw.bb7
  %9 = call i64 @llvm.objectsize.i64.p0i8(i8* %val8, i1 false, i1 true) #7
  %conv.i140 = trunc i64 %9 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 696) #7
  call void @kasan_check_write(i8* %val8, i32 1) #7
  %cmp.i141 = icmp slt i32 %conv.i140, 0
  %conv3.i142 = sext i32 %conv.i140 to i64
  %cmp4.i143 = icmp uge i64 %conv3.i142, 1
  %10 = select i1 %cmp.i141, i1 true, i1 %cmp4.i143
  %lnot.i144 = xor i1 %10, true
  %lnot.ext.i145 = zext i1 %10 to i32
  %conv7.i146 = sext i32 %lnot.ext.i145 to i64
  %expval.i147 = call i64 @llvm.expect.i64(i64 %conv7.i146, i64 1) #7
  %tobool.i148 = icmp ne i64 %expval.i147, 0
  br i1 %tobool.i148, label %if.then.i150, label %if.else.i151

if.then.i150:                                     ; preds = %if.end11
  call void @__check_object_size(i8* %val8, i64 1, i1 zeroext false) #7
  %call.i149 = call i64 @_copy_from_user(i8* %val8, i8* %0, i32 1) #7
  br label %copy_from_user.exit153

if.else.i151:                                     ; preds = %if.end11
  call void @copy_user_overflow(i32 %conv.i140, i64 1) #7
  br label %copy_from_user.exit153

copy_from_user.exit153:                           ; preds = %if.else.i151, %if.then.i150
  %n.addr.0.i152 = phi i64 [ %call.i149, %if.then.i150 ], [ 1, %if.else.i151 ]
  %tobool13 = icmp ne i64 %n.addr.0.i152, 0
  br i1 %tobool13, label %sw.epilog, label %if.end15

if.end15:                                         ; preds = %copy_from_user.exit153
  %11 = load i8, i8* %val8, align 1, !tbaa !31
  %conv16 = zext i8 %11 to i32
  %shr = ashr i32 %conv16, 5
  %add = add nsw i32 %shr, 1
  store i32 %add, i32* %value, align 4, !tbaa !2
  %12 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call17 = call i32 @sony_nc_int_call(i8* %12, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.54, i32 0, i32 0), i32* %value, i32* null)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %sw.epilog, label %if.end20

if.end20:                                         ; preds = %if.end15
  %13 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !144
  %call21 = call i32 @sony_backlight_get_brightness(%struct.backlight_device* %13)
  %14 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !144
  %props = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %14, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 0
  store i32 %call21, i32* %brightness, align 8, !tbaa !146
  br label %sw.epilog

sw.bb22:                                          ; preds = %NodeBlock9
  %call23 = call i32 @ec_read16(i8 zeroext -78, i16* %val16)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %sw.epilog, label %if.end26

if.end26:                                         ; preds = %sw.bb22
  %15 = bitcast i16* %val16 to i8*
  %16 = call i64 @llvm.objectsize.i64.p0i8(i8* %15, i1 false, i1 true) #7
  %conv.i85 = trunc i64 %16 to i32
  call void @kasan_check_read(i8* %15, i32 2) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 718) #7
  %cmp.i86 = icmp slt i32 %conv.i85, 0
  %conv3.i87 = sext i32 %conv.i85 to i64
  %cmp4.i88 = icmp uge i64 %conv3.i87, 2
  %17 = select i1 %cmp.i86, i1 true, i1 %cmp4.i88
  %lnot.i89 = xor i1 %17, true
  %lnot.ext.i90 = zext i1 %17 to i32
  %conv7.i91 = sext i32 %lnot.ext.i90 to i64
  %expval.i92 = call i64 @llvm.expect.i64(i64 %conv7.i91, i64 1) #7
  %tobool.i93 = icmp ne i64 %expval.i92, 0
  br i1 %tobool.i93, label %if.then.i95, label %if.else.i96

if.then.i95:                                      ; preds = %if.end26
  call void @__check_object_size(i8* %15, i64 2, i1 zeroext true) #7
  %call.i94 = call i64 @_copy_to_user(i8* %0, i8* %15, i32 2) #7
  br label %copy_to_user.exit98

if.else.i96:                                      ; preds = %if.end26
  call void @copy_user_overflow(i32 %conv.i85, i64 2) #7
  br label %copy_to_user.exit98

copy_to_user.exit98:                              ; preds = %if.else.i96, %if.then.i95
  %n.addr.0.i97 = phi i64 [ %call.i94, %if.then.i95 ], [ 2, %if.else.i96 ]
  %tobool28 = icmp ne i64 %n.addr.0.i97, 0
  %.35 = select i1 %tobool28, i32 -14, i32 0
  br label %sw.epilog

sw.bb31:                                          ; preds = %NodeBlock19
  %call32 = call i32 @ec_read16(i8 zeroext -94, i16* %val16)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %sw.epilog, label %if.end35

if.end35:                                         ; preds = %sw.bb31
  %18 = bitcast i16* %val16 to i8*
  %19 = call i64 @llvm.objectsize.i64.p0i8(i8* %18, i1 false, i1 true) #7
  %conv.i71 = trunc i64 %19 to i32
  call void @kasan_check_read(i8* %18, i32 2) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 718) #7
  %cmp.i72 = icmp slt i32 %conv.i71, 0
  %conv3.i73 = sext i32 %conv.i71 to i64
  %cmp4.i74 = icmp uge i64 %conv3.i73, 2
  %20 = select i1 %cmp.i72, i1 true, i1 %cmp4.i74
  %lnot.i75 = xor i1 %20, true
  %lnot.ext.i76 = zext i1 %20 to i32
  %conv7.i77 = sext i32 %lnot.ext.i76 to i64
  %expval.i78 = call i64 @llvm.expect.i64(i64 %conv7.i77, i64 1) #7
  %tobool.i79 = icmp ne i64 %expval.i78, 0
  br i1 %tobool.i79, label %if.then.i81, label %if.else.i82

if.then.i81:                                      ; preds = %if.end35
  call void @__check_object_size(i8* %18, i64 2, i1 zeroext true) #7
  %call.i80 = call i64 @_copy_to_user(i8* %0, i8* %18, i32 2) #7
  br label %copy_to_user.exit84

if.else.i82:                                      ; preds = %if.end35
  call void @copy_user_overflow(i32 %conv.i71, i64 2) #7
  br label %copy_to_user.exit84

copy_to_user.exit84:                              ; preds = %if.else.i82, %if.then.i81
  %n.addr.0.i83 = phi i64 [ %call.i80, %if.then.i81 ], [ 2, %if.else.i82 ]
  %tobool37 = icmp ne i64 %n.addr.0.i83, 0
  %.36 = select i1 %tobool37, i32 -14, i32 0
  br label %sw.epilog

sw.bb40:                                          ; preds = %NodeBlock17
  %call41 = call i32 @ec_read16(i8 zeroext -70, i16* %val16)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %sw.epilog, label %if.end44

if.end44:                                         ; preds = %sw.bb40
  %21 = bitcast i16* %val16 to i8*
  %22 = call i64 @llvm.objectsize.i64.p0i8(i8* %21, i1 false, i1 true) #7
  %conv.i57 = trunc i64 %22 to i32
  call void @kasan_check_read(i8* %21, i32 2) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 718) #7
  %cmp.i58 = icmp slt i32 %conv.i57, 0
  %conv3.i59 = sext i32 %conv.i57 to i64
  %cmp4.i60 = icmp uge i64 %conv3.i59, 2
  %23 = select i1 %cmp.i58, i1 true, i1 %cmp4.i60
  %lnot.i61 = xor i1 %23, true
  %lnot.ext.i62 = zext i1 %23 to i32
  %conv7.i63 = sext i32 %lnot.ext.i62 to i64
  %expval.i64 = call i64 @llvm.expect.i64(i64 %conv7.i63, i64 1) #7
  %tobool.i65 = icmp ne i64 %expval.i64, 0
  br i1 %tobool.i65, label %if.then.i67, label %if.else.i68

if.then.i67:                                      ; preds = %if.end44
  call void @__check_object_size(i8* %21, i64 2, i1 zeroext true) #7
  %call.i66 = call i64 @_copy_to_user(i8* %0, i8* %21, i32 2) #7
  br label %copy_to_user.exit70

if.else.i68:                                      ; preds = %if.end44
  call void @copy_user_overflow(i32 %conv.i57, i64 2) #7
  br label %copy_to_user.exit70

copy_to_user.exit70:                              ; preds = %if.else.i68, %if.then.i67
  %n.addr.0.i69 = phi i64 [ %call.i66, %if.then.i67 ], [ 2, %if.else.i68 ]
  %tobool46 = icmp ne i64 %n.addr.0.i69, 0
  %.37 = select i1 %tobool46, i32 -14, i32 0
  br label %sw.epilog

sw.bb49:                                          ; preds = %LeafBlock15
  %call50 = call i32 @ec_read16(i8 zeroext -86, i16* %val16)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %sw.epilog, label %if.end53

if.end53:                                         ; preds = %sw.bb49
  %24 = bitcast i16* %val16 to i8*
  %25 = call i64 @llvm.objectsize.i64.p0i8(i8* %24, i1 false, i1 true) #7
  %conv.i43 = trunc i64 %25 to i32
  call void @kasan_check_read(i8* %24, i32 2) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 718) #7
  %cmp.i44 = icmp slt i32 %conv.i43, 0
  %conv3.i45 = sext i32 %conv.i43 to i64
  %cmp4.i46 = icmp uge i64 %conv3.i45, 2
  %26 = select i1 %cmp.i44, i1 true, i1 %cmp4.i46
  %lnot.i47 = xor i1 %26, true
  %lnot.ext.i48 = zext i1 %26 to i32
  %conv7.i49 = sext i32 %lnot.ext.i48 to i64
  %expval.i50 = call i64 @llvm.expect.i64(i64 %conv7.i49, i64 1) #7
  %tobool.i51 = icmp ne i64 %expval.i50, 0
  br i1 %tobool.i51, label %if.then.i53, label %if.else.i54

if.then.i53:                                      ; preds = %if.end53
  call void @__check_object_size(i8* %24, i64 2, i1 zeroext true) #7
  %call.i52 = call i64 @_copy_to_user(i8* %0, i8* %24, i32 2) #7
  br label %copy_to_user.exit56

if.else.i54:                                      ; preds = %if.end53
  call void @copy_user_overflow(i32 %conv.i43, i64 2) #7
  br label %copy_to_user.exit56

copy_to_user.exit56:                              ; preds = %if.else.i54, %if.then.i53
  %n.addr.0.i55 = phi i64 [ %call.i52, %if.then.i53 ], [ 2, %if.else.i54 ]
  %tobool55 = icmp ne i64 %n.addr.0.i55, 0
  %.38 = select i1 %tobool55, i32 -14, i32 0
  br label %sw.epilog

sw.bb58:                                          ; preds = %NodeBlock
  %call59 = call i32 @ec_read(i8 zeroext -127, i8* %val8)
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %sw.epilog, label %if.end62

if.end62:                                         ; preds = %sw.bb58
  %27 = load i8, i8* %val8, align 1, !tbaa !31
  %conv63 = zext i8 %27 to i32
  %and64 = and i32 %conv63, 7
  %conv65 = trunc i32 %and64 to i8
  store i8 %conv65, i8* %val8, align 1, !tbaa !31
  %28 = call i64 @llvm.objectsize.i64.p0i8(i8* %val8, i1 false, i1 true) #7
  %conv.i29 = trunc i64 %28 to i32
  call void @kasan_check_read(i8* %val8, i32 1) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 718) #7
  %cmp.i30 = icmp slt i32 %conv.i29, 0
  %conv3.i31 = sext i32 %conv.i29 to i64
  %cmp4.i32 = icmp uge i64 %conv3.i31, 1
  %29 = select i1 %cmp.i30, i1 true, i1 %cmp4.i32
  %lnot.i33 = xor i1 %29, true
  %lnot.ext.i34 = zext i1 %29 to i32
  %conv7.i35 = sext i32 %lnot.ext.i34 to i64
  %expval.i36 = call i64 @llvm.expect.i64(i64 %conv7.i35, i64 1) #7
  %tobool.i37 = icmp ne i64 %expval.i36, 0
  br i1 %tobool.i37, label %if.then.i39, label %if.else.i40

if.then.i39:                                      ; preds = %if.end62
  call void @__check_object_size(i8* %val8, i64 1, i1 zeroext true) #7
  %call.i38 = call i64 @_copy_to_user(i8* %0, i8* %val8, i32 1) #7
  br label %copy_to_user.exit42

if.else.i40:                                      ; preds = %if.end62
  call void @copy_user_overflow(i32 %conv.i29, i64 1) #7
  br label %copy_to_user.exit42

copy_to_user.exit42:                              ; preds = %if.else.i40, %if.then.i39
  %n.addr.0.i41 = phi i64 [ %call.i38, %if.then.i39 ], [ 1, %if.else.i40 ]
  %tobool67 = icmp ne i64 %n.addr.0.i41, 0
  %.39 = select i1 %tobool67, i32 -14, i32 0
  br label %sw.epilog

sw.bb70:                                          ; preds = %LeafBlock1
  %30 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !33
  store i8 %30, i8* %val8, align 1, !tbaa !31
  %31 = call i64 @llvm.objectsize.i64.p0i8(i8* %val8, i1 false, i1 true) #7
  %conv.i15 = trunc i64 %31 to i32
  call void @kasan_check_read(i8* %val8, i32 1) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 718) #7
  %cmp.i16 = icmp slt i32 %conv.i15, 0
  %conv3.i17 = sext i32 %conv.i15 to i64
  %cmp4.i18 = icmp uge i64 %conv3.i17, 1
  %32 = select i1 %cmp.i16, i1 true, i1 %cmp4.i18
  %lnot.i19 = xor i1 %32, true
  %lnot.ext.i20 = zext i1 %32 to i32
  %conv7.i21 = sext i32 %lnot.ext.i20 to i64
  %expval.i22 = call i64 @llvm.expect.i64(i64 %conv7.i21, i64 1) #7
  %tobool.i23 = icmp ne i64 %expval.i22, 0
  br i1 %tobool.i23, label %if.then.i25, label %if.else.i26

if.then.i25:                                      ; preds = %sw.bb70
  call void @__check_object_size(i8* %val8, i64 1, i1 zeroext true) #7
  %call.i24 = call i64 @_copy_to_user(i8* %0, i8* %val8, i32 1) #7
  br label %copy_to_user.exit28

if.else.i26:                                      ; preds = %sw.bb70
  call void @copy_user_overflow(i32 %conv.i15, i64 1) #7
  br label %copy_to_user.exit28

copy_to_user.exit28:                              ; preds = %if.else.i26, %if.then.i25
  %n.addr.0.i27 = phi i64 [ %call.i24, %if.then.i25 ], [ 1, %if.else.i26 ]
  %tobool72 = icmp ne i64 %n.addr.0.i27, 0
  %.40 = select i1 %tobool72, i32 -14, i32 0
  br label %sw.epilog

sw.bb75:                                          ; preds = %LeafBlock23
  %33 = call i64 @llvm.objectsize.i64.p0i8(i8* %val8, i1 false, i1 true) #7
  %conv.i126 = trunc i64 %33 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 696) #7
  call void @kasan_check_write(i8* %val8, i32 1) #7
  %cmp.i127 = icmp slt i32 %conv.i126, 0
  %conv3.i128 = sext i32 %conv.i126 to i64
  %cmp4.i129 = icmp uge i64 %conv3.i128, 1
  %34 = select i1 %cmp.i127, i1 true, i1 %cmp4.i129
  %lnot.i130 = xor i1 %34, true
  %lnot.ext.i131 = zext i1 %34 to i32
  %conv7.i132 = sext i32 %lnot.ext.i131 to i64
  %expval.i133 = call i64 @llvm.expect.i64(i64 %conv7.i132, i64 1) #7
  %tobool.i134 = icmp ne i64 %expval.i133, 0
  br i1 %tobool.i134, label %if.then.i136, label %if.else.i137

if.then.i136:                                     ; preds = %sw.bb75
  call void @__check_object_size(i8* %val8, i64 1, i1 zeroext false) #7
  %call.i135 = call i64 @_copy_from_user(i8* %val8, i8* %0, i32 1) #7
  br label %copy_from_user.exit139

if.else.i137:                                     ; preds = %sw.bb75
  call void @copy_user_overflow(i32 %conv.i126, i64 1) #7
  br label %copy_from_user.exit139

copy_from_user.exit139:                           ; preds = %if.else.i137, %if.then.i136
  %n.addr.0.i138 = phi i64 [ %call.i135, %if.then.i136 ], [ 1, %if.else.i137 ]
  %tobool77 = icmp ne i64 %n.addr.0.i138, 0
  br i1 %tobool77, label %sw.epilog, label %if.end79

if.end79:                                         ; preds = %copy_from_user.exit139
  %35 = load i8, i8* %val8, align 1, !tbaa !31
  call void @__sony_pic_set_bluetoothpower(i8 zeroext %35)
  br label %sw.epilog

sw.bb80:                                          ; preds = %LeafBlock5
  %call81 = call i32 @sony_pic_get_fanspeed(i8* %val8)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %sw.epilog, label %if.end84

if.end84:                                         ; preds = %sw.bb80
  %36 = call i64 @llvm.objectsize.i64.p0i8(i8* %val8, i1 false, i1 true) #7
  %conv.i1 = trunc i64 %36 to i32
  call void @kasan_check_read(i8* %val8, i32 1) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 718) #7
  %cmp.i2 = icmp slt i32 %conv.i1, 0
  %conv3.i3 = sext i32 %conv.i1 to i64
  %cmp4.i4 = icmp uge i64 %conv3.i3, 1
  %37 = select i1 %cmp.i2, i1 true, i1 %cmp4.i4
  %lnot.i5 = xor i1 %37, true
  %lnot.ext.i6 = zext i1 %37 to i32
  %conv7.i7 = sext i32 %lnot.ext.i6 to i64
  %expval.i8 = call i64 @llvm.expect.i64(i64 %conv7.i7, i64 1) #7
  %tobool.i9 = icmp ne i64 %expval.i8, 0
  br i1 %tobool.i9, label %if.then.i11, label %if.else.i12

if.then.i11:                                      ; preds = %if.end84
  call void @__check_object_size(i8* %val8, i64 1, i1 zeroext true) #7
  %call.i10 = call i64 @_copy_to_user(i8* %0, i8* %val8, i32 1) #7
  br label %copy_to_user.exit14

if.else.i12:                                      ; preds = %if.end84
  call void @copy_user_overflow(i32 %conv.i1, i64 1) #7
  br label %copy_to_user.exit14

copy_to_user.exit14:                              ; preds = %if.else.i12, %if.then.i11
  %n.addr.0.i13 = phi i64 [ %call.i10, %if.then.i11 ], [ 1, %if.else.i12 ]
  %tobool86 = icmp ne i64 %n.addr.0.i13, 0
  %.41 = select i1 %tobool86, i32 -14, i32 0
  br label %sw.epilog

sw.bb89:                                          ; preds = %LeafBlock25
  %38 = call i64 @llvm.objectsize.i64.p0i8(i8* %val8, i1 false, i1 true) #7
  %conv.i113 = trunc i64 %38 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 696) #7
  call void @kasan_check_write(i8* %val8, i32 1) #7
  %cmp.i114 = icmp slt i32 %conv.i113, 0
  %conv3.i115 = sext i32 %conv.i113 to i64
  %cmp4.i116 = icmp uge i64 %conv3.i115, 1
  %39 = select i1 %cmp.i114, i1 true, i1 %cmp4.i116
  %lnot.i117 = xor i1 %39, true
  %lnot.ext.i118 = zext i1 %39 to i32
  %conv7.i119 = sext i32 %lnot.ext.i118 to i64
  %expval.i120 = call i64 @llvm.expect.i64(i64 %conv7.i119, i64 1) #7
  %tobool.i121 = icmp ne i64 %expval.i120, 0
  br i1 %tobool.i121, label %if.then.i123, label %if.else.i124

if.then.i123:                                     ; preds = %sw.bb89
  call void @__check_object_size(i8* %val8, i64 1, i1 zeroext false) #7
  %call.i122 = call i64 @_copy_from_user(i8* %val8, i8* %0, i32 1) #7
  br label %copy_from_user.exit

if.else.i124:                                     ; preds = %sw.bb89
  call void @copy_user_overflow(i32 %conv.i113, i64 1) #7
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i124, %if.then.i123
  %n.addr.0.i125 = phi i64 [ %call.i122, %if.then.i123 ], [ 1, %if.else.i124 ]
  %tobool91 = icmp ne i64 %n.addr.0.i125, 0
  br i1 %tobool91, label %sw.epilog, label %if.end93

if.end93:                                         ; preds = %copy_from_user.exit
  %40 = load i8, i8* %val8, align 1, !tbaa !31
  %conv94 = zext i8 %40 to i64
  %call95 = call i32 @sony_pic_set_fanspeed(i64 %conv94)
  %tobool96 = icmp ne i32 %call95, 0
  %.42 = select i1 %tobool96, i32 -5, i32 0
  br label %sw.epilog

sw.bb99:                                          ; preds = %LeafBlock7
  %call100 = call i32 @ec_read(i8 zeroext -63, i8* %val8)
  %tobool101 = icmp ne i32 %call100, 0
  br i1 %tobool101, label %sw.epilog, label %if.end103

if.end103:                                        ; preds = %sw.bb99
  %41 = call i64 @llvm.objectsize.i64.p0i8(i8* %val8, i1 false, i1 true) #7
  %conv.i = trunc i64 %41 to i32
  call void @kasan_check_read(i8* %val8, i32 1) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 718) #7
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 1
  %42 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.i = xor i1 %42, true
  %lnot.ext.i = zext i1 %42 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #7
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.end103
  call void @__check_object_size(i8* %val8, i64 1, i1 zeroext true) #7
  %call.i = call i64 @_copy_to_user(i8* %0, i8* %val8, i32 1) #7
  br label %copy_to_user.exit

if.else.i:                                        ; preds = %if.end103
  call void @copy_user_overflow(i32 %conv.i, i64 1) #7
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 1, %if.else.i ]
  %tobool105 = icmp ne i64 %n.addr.0.i, 0
  %.43 = select i1 %tobool105, i32 -14, i32 0
  br label %sw.epilog

sw.epilog:                                        ; preds = %copy_to_user.exit, %sw.bb99, %if.end93, %copy_from_user.exit, %copy_to_user.exit14, %sw.bb80, %if.end79, %copy_from_user.exit139, %copy_to_user.exit28, %copy_to_user.exit42, %sw.bb58, %copy_to_user.exit56, %sw.bb49, %copy_to_user.exit70, %sw.bb40, %copy_to_user.exit84, %sw.bb31, %copy_to_user.exit98, %sw.bb22, %if.end20, %if.end15, %copy_from_user.exit153, %sw.bb7, %copy_to_user.exit112, %if.end, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock5, %LeafBlock7, %LeafBlock15, %LeafBlock21, %LeafBlock23, %LeafBlock25
  %ret.10 = phi i32 [ %., %copy_to_user.exit112 ], [ %.39, %copy_to_user.exit42 ], [ %.40, %copy_to_user.exit28 ], [ %.41, %copy_to_user.exit14 ], [ %.43, %copy_to_user.exit ], [ %.35, %copy_to_user.exit98 ], [ %.36, %copy_to_user.exit84 ], [ %.37, %copy_to_user.exit70 ], [ %.38, %copy_to_user.exit56 ], [ 0, %if.end20 ], [ 0, %if.end79 ], [ %.42, %if.end93 ], [ -5, %sw.bb ], [ -5, %if.end ], [ -5, %sw.bb7 ], [ -14, %copy_from_user.exit153 ], [ -5, %if.end15 ], [ -5, %sw.bb22 ], [ -5, %sw.bb31 ], [ -5, %sw.bb40 ], [ -5, %sw.bb49 ], [ -5, %sw.bb58 ], [ -14, %copy_from_user.exit139 ], [ -5, %sw.bb80 ], [ -14, %copy_from_user.exit ], [ -5, %sw.bb99 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock5 ], [ -22, %LeafBlock7 ], [ -22, %LeafBlock15 ], [ -22, %LeafBlock21 ], [ -22, %LeafBlock23 ], [ -22, %LeafBlock25 ]
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  %conv108 = sext i32 %ret.10 to i64
  %43 = bitcast i32* %value to i8*
  %44 = bitcast i16* %val16 to i8*
  ret i64 %conv108
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i64 0, i32 2, i32 0, i32 0))
  %4 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i64 0, i32 4, i32 0), i32 1, i32* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i64 0, i32 4, i32 0)) #7, !srcloc !76
  %add.i = add nsw i32 1, %4
  %cmp6 = icmp eq i32 %add.i, 1
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.70* %5 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo, i32 0, i32 1
  store i32 0, i32* %out, align 4, !tbaa !31
  %6 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo9 = bitcast %union.anon.70* %6 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo9, i32 0, i32 0
  store i32 0, i32* %in, align 8, !tbaa !31
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = bitcast i64* %__dummy.i to i8*
  %8 = bitcast i64* %__dummy2.i to i8*
  %9 = bitcast i64* %__dummy2.i to i8*
  %10 = bitcast i64* %__dummy.i to i8*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i64 0, i32 2, i32 0, i32 0), i64 %call2) #7
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i64 0, i32 4, i32 0), i32* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i64 0, i32 4, i32 0)) #7, !srcloc !94
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_fasync(i32 %fd, %struct.file* %filp, i32 %on) #0 {
entry:
  %call = call i32 @fasync_helper(i32 %fd, %struct.file* %filp, i32 %on, %struct.fasync_struct** getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 0))
  ret i32 %call
}

declare void @__might_sleep(i8*, i32, i32) #1

declare void @init_wait_entry(%struct.__wait_queue*, i32) #1

declare i64 @prepare_to_wait_event(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #1

declare void @schedule() #1

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

declare void @__might_fault(i8*, i32) #1

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #4 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !150
  ret %struct.inode* %0
}

declare { i64, i64 } @current_time(%struct.inode*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #4 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !151
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !151
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_int_call(i8* %handle, i8* %name, i32* %value, i32* %result) #0 {
entry:
  %v = alloca i64, align 8
  %tobool = icmp ne i32* %value, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = bitcast i64* %v to i8*
  %1 = load i32, i32* %value, align 4, !tbaa !2
  %conv = sext i32 %1 to i64
  store i64 %conv, i64* %v, align 8, !tbaa !133
  %call = call %union.acpi_object* @__call_snc_method(i8* %handle, i8* %name, i64* %v)
  %2 = bitcast i64* %v to i8*
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call %union.acpi_object* @__call_snc_method(i8* %handle, i8* %name, i64* null)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %object.0 = phi %union.acpi_object* [ %call, %if.then ], [ %call1, %if.else ]
  %tobool2 = icmp ne %union.acpi_object* %object.0, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %type = bitcast %union.acpi_object* %object.0 to i32*
  %3 = load i32, i32* %type, align 8, !tbaa !31
  %cmp = icmp ne i32 %3, 1
  br i1 %cmp, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end4
  call void (i8*, ...) @printk(i8* null)
  %4 = bitcast %union.acpi_object* %object.0 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %tobool10 = icmp ne i32* %result, null
  br i1 %tobool10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.end9
  %integer = bitcast %union.acpi_object* %object.0 to %struct.anon.58*
  %value12 = getelementptr inbounds %struct.anon.58, %struct.anon.58* %integer, i32 0, i32 1
  %5 = load i64, i64* %value12, align 8, !tbaa !31
  %conv13 = trunc i64 %5 to i32
  store i32 %conv13, i32* %result, align 4, !tbaa !2
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.end9
  %6 = bitcast %union.acpi_object* %object.0 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.then6, %if.end
  %retval.0 = phi i32 [ -22, %if.then6 ], [ 0, %if.end14 ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_backlight_get_brightness(%struct.backlight_device* %bd) #0 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast i32* %value to i8*
  %1 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call = call i32 @sony_nc_int_call(i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.53, i32 0, i32 0), i32* null, i32* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i32, i32* %value, align 4
  %sub = sub nsw i32 %2, 1
  %retval.0 = select i1 %tobool, i32 0, i32 %sub
  %3 = bitcast i32* %value to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ec_read16(i8 zeroext %addr, i16* %value) #0 {
entry:
  %val_lb = alloca i8, align 1
  %val_hb = alloca i8, align 1
  %call = call i32 @ec_read(i8 zeroext %addr, i8* %val_lb)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i8 %addr to i32
  %add = add nsw i32 %conv, 1
  %conv1 = trunc i32 %add to i8
  %call2 = call i32 @ec_read(i8 zeroext %conv1, i8* %val_hb)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %0 = load i8, i8* %val_lb, align 1, !tbaa !31
  %conv6 = zext i8 %0 to i32
  %1 = load i8, i8* %val_hb, align 1, !tbaa !31
  %conv7 = zext i8 %1 to i32
  %shl = shl i32 %conv7, 8
  %or = or i32 %conv6, %shl
  %conv8 = trunc i32 %or to i16
  store i16 %conv8, i16* %value, align 2, !tbaa !153
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end5 ], [ -1, %entry ], [ -1, %if.end ]
  ret i32 %retval.0
}

declare i32 @ec_read(i8 zeroext, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @__sony_pic_set_bluetoothpower(i8 zeroext %state) #0 {
entry:
  %tobool = icmp ne i8 %state, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = trunc i32 %lnot.ext to i8
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !33
  %conv2 = zext i8 %0 to i32
  %conv3 = zext i8 %conv to i32
  %cmp = icmp eq i32 %conv2, %conv3
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = call zeroext i8 @sony_pic_call2(i8 zeroext -106, i8 zeroext %conv)
  call void @sony_pic_call1(i8 zeroext -126)
  store i8 %conv, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !33
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_get_fanspeed(i8* %value) #0 {
entry:
  %call = call i32 @ec_read(i8 zeroext -109, i8* %value)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_set_fanspeed(i64 %value) #0 {
entry:
  %conv = trunc i64 %value to i8
  %call = call i32 @ec_write(i8 zeroext -109, i8 zeroext %conv)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal %union.acpi_object* @__call_snc_method(i8* %handle, i8* %method, i64* %value) #0 {
entry:
  %output = alloca %struct.acpi_buffer, align 8
  %params = alloca %struct.acpi_object_list, align 8
  %in = alloca %union.acpi_object, align 8
  %0 = bitcast %struct.acpi_buffer* %output to i8*
  %1 = bitcast %struct.acpi_buffer* %output to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast (%struct.acpi_buffer* @__call_snc_method.output to i8*), i64 16, i32 8, i1 false)
  %tobool = icmp ne i64* %value, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.acpi_object_list* %params to i8*
  %3 = bitcast %union.acpi_object* %in to i8*
  %type = bitcast %union.acpi_object* %in to i32*
  store i32 1, i32* %type, align 8, !tbaa !31
  %4 = load i64, i64* %value, align 8, !tbaa !133
  %integer = bitcast %union.acpi_object* %in to %struct.anon.58*
  %value1 = getelementptr inbounds %struct.anon.58, %struct.anon.58* %integer, i32 0, i32 1
  store i64 %4, i64* %value1, align 8, !tbaa !31
  %count = getelementptr inbounds %struct.acpi_object_list, %struct.acpi_object_list* %params, i32 0, i32 0
  store i32 1, i32* %count, align 8, !tbaa !154
  %pointer = getelementptr inbounds %struct.acpi_object_list, %struct.acpi_object_list* %params, i32 0, i32 1
  store %union.acpi_object* %in, %union.acpi_object** %pointer, align 8, !tbaa !156
  %call = call i32 @acpi_evaluate_object(i8* %handle, i8* %method, %struct.acpi_object_list* %params, %struct.acpi_buffer* %output)
  %5 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %if.then
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %if.then
  %6 = bitcast %union.acpi_object* %in to i8*
  %7 = bitcast %struct.acpi_object_list* %params to i8*
  br label %if.end14

if.else:                                          ; preds = %entry
  %call6 = call i32 @acpi_evaluate_object(i8* %handle, i8* %method, %struct.acpi_object_list* null, %struct.acpi_buffer* %output)
  %8 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool8 = icmp ne i32 %8, 0
  br i1 %tobool8, label %if.then9, label %if.end14

if.then9:                                         ; preds = %if.else
  call void (i8*, ...) @printk(i8* null)
  br label %if.end14

if.end14:                                         ; preds = %if.then9, %if.else, %do.end
  %status.0 = phi i32 [ %call, %do.end ], [ %call6, %if.then9 ], [ %call6, %if.else ]
  %tobool15 = icmp ne i32 %status.0, 0
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end18:                                         ; preds = %if.end14
  %pointer19 = getelementptr inbounds %struct.acpi_buffer, %struct.acpi_buffer* %output, i32 0, i32 1
  %9 = load i8*, i8** %pointer19, align 8, !tbaa !107
  %10 = bitcast i8* %9 to %union.acpi_object*
  %tobool20 = icmp eq %union.acpi_object* %10, null
  %11 = load i32, i32* @debug, align 4
  %tobool23 = icmp ne i32 %11, 0
  %or.cond = and i1 %tobool20, %tobool23
  br i1 %or.cond, label %if.then24, label %cleanup

if.then24:                                        ; preds = %if.end18
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then24, %if.end18, %if.then16
  %retval.0 = phi %union.acpi_object* [ null, %if.then16 ], [ %10, %if.then24 ], [ %10, %if.end18 ]
  %12 = bitcast %struct.acpi_buffer* %output to i8*
  ret %union.acpi_object* %retval.0
}

declare i32 @acpi_evaluate_object(i8*, i8*, %struct.acpi_object_list*, %struct.acpi_buffer*) #1

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #6

declare void @kasan_check_read(i8*, i32) #1

declare i64 @_copy_to_user(i8*, i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @copy_user_overflow(i32 %size, i64 %count) #4 {
entry:
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.60, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.61, i32 0, i32 0), i32 %size, i64 %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @__check_object_size(i8*, i64, i1 zeroext) #1

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #1

declare void @kasan_check_write(i8*, i32) #1

declare i64 @_copy_from_user(i8*, i8*, i32) #1

declare i32 @ec_write(i8 zeroext, i8 zeroext) #1

declare i32 @fasync_helper(i32, %struct.file*, i32, %struct.fasync_struct**) #1

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @sony_laptop_report_input_event(i8 zeroext %event) #0 {
entry:
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %kp = alloca %struct.sony_laptop_keypress, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !93
  %1 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !90
  %2 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %3 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.memset.p0i8.i64(i8* %3, i8 0, i64 16, i32 8, i1 false)
  %conv = zext i8 %event to i32
  %cmp = icmp eq i32 %conv, 59
  %conv2 = zext i8 %event to i32
  %cmp3 = icmp eq i32 %conv2, 56
  %or.cond = or i1 %cmp, %cmp3
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv5 = zext i8 %event to i32
  %Pivot8 = icmp slt i32 %conv5, 3
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end
  %Pivot6 = icmp slt i32 %conv5, 4
  br i1 %Pivot6, label %sw.bb6, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %conv5, 5
  br i1 %Pivot4, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %conv5, 5
  br i1 %SwitchLeaf2, label %sw.bb7, label %sw.default

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %conv5, 2
  br i1 %Pivot, label %LeafBlock, label %sw.bb

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv5, 1
  br i1 %SwitchLeaf, label %sw.bb6, label %sw.default

sw.bb:                                            ; preds = %NodeBlock, %NodeBlock3
  call void @input_report_rel(%struct.input_dev* %0, i32 8, i32 1)
  call void @input_sync(%struct.input_dev* %0)
  br label %cleanup

sw.bb6:                                           ; preds = %LeafBlock, %NodeBlock5
  call void @input_report_rel(%struct.input_dev* %0, i32 8, i32 -1)
  call void @input_sync(%struct.input_dev* %0)
  br label %cleanup

sw.bb7:                                           ; preds = %LeafBlock1
  %key = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  store i32 274, i32* %key, align 8, !tbaa !122
  %dev = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  store %struct.input_dev* %0, %struct.input_dev** %dev, align 8, !tbaa !120
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %conv8 = zext i8 %event to i64
  %cmp9 = icmp uge i64 %conv8, 74
  br i1 %cmp9, label %do.body, label %if.end15

do.body:                                          ; preds = %sw.default
  %4 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then12, label %sw.epilog

if.then12:                                        ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

if.end15:                                         ; preds = %sw.default
  %idxprom = zext i8 %event to i64
  %arrayidx = getelementptr inbounds [74 x i32], [74 x i32]* @sony_laptop_input_index, i64 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %cmp16 = icmp ne i32 %5, -1
  br i1 %cmp16, label %if.then18, label %sw.epilog

if.then18:                                        ; preds = %if.end15
  %idxprom19 = sext i32 %5 to i64
  %arrayidx20 = getelementptr inbounds [60 x i32], [60 x i32]* @sony_laptop_input_keycode_map, i64 0, i64 %idxprom19
  %6 = load i32, i32* %arrayidx20, align 4, !tbaa !2
  %key21 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  store i32 %6, i32* %key21, align 8, !tbaa !122
  %key22 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %7 = load i32, i32* %key22, align 8, !tbaa !122
  %cmp23 = icmp ne i32 %7, 240
  br i1 %cmp23, label %if.then25, label %sw.epilog

if.then25:                                        ; preds = %if.then18
  %dev26 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  store %struct.input_dev* %1, %struct.input_dev** %dev26, align 8, !tbaa !120
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then25, %if.then18, %if.end15, %if.then12, %do.body, %sw.bb7
  %scancode.0 = phi i32 [ -1, %sw.bb7 ], [ -1, %if.then12 ], [ -1, %do.body ], [ %5, %if.then18 ], [ %5, %if.then25 ], [ %5, %if.end15 ]
  %dev29 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %8 = load %struct.input_dev*, %struct.input_dev** %dev29, align 8, !tbaa !120
  %tobool30 = icmp ne %struct.input_dev* %8, null
  br i1 %tobool30, label %if.then31, label %do.body56

if.then31:                                        ; preds = %sw.epilog
  %cmp32 = icmp ne i32 %scancode.0, -1
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.then31
  %dev35 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %9 = load %struct.input_dev*, %struct.input_dev** %dev35, align 8, !tbaa !120
  call void @input_event(%struct.input_dev* %9, i32 4, i32 4, i32 %scancode.0)
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.then31
  %dev37 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %10 = load %struct.input_dev*, %struct.input_dev** %dev37, align 8, !tbaa !120
  %key38 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %11 = load i32, i32* %key38, align 8, !tbaa !122
  call void @input_report_key(%struct.input_dev* %10, i32 %11, i32 1)
  %dev39 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %12 = load %struct.input_dev*, %struct.input_dev** %dev39, align 8, !tbaa !120
  call void @input_sync(%struct.input_dev* %12)
  %13 = bitcast i64* %__dummy to i8*
  %14 = bitcast i64* %__dummy2 to i8*
  %15 = bitcast i64* %__dummy2 to i8*
  %16 = bitcast i64* %__dummy to i8*
  %call45 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i64 0, i32 4, i32 0, i32 0))
  %17 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %18 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.70* %18 to %struct.__kfifo*
  %conv51 = trunc i64 16 to i32
  %call52 = call i32 @__kfifo_in(%struct.__kfifo* %kfifo, i8* %17, i32 %conv51)
  %19 = bitcast i64* %__dummy.i to i8*
  %20 = bitcast i64* %__dummy2.i to i8*
  %21 = bitcast i64* %__dummy2.i to i8*
  %22 = bitcast i64* %__dummy.i to i8*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i64 0, i32 4, i32 0, i32 0), i64 %call45) #7
  %23 = load volatile i64, i64* @jiffies, align 8, !tbaa !100
  %call.i = call i64 @__msecs_to_jiffies(i32 10) #7
  %add = add i64 %23, %call.i
  %call55 = call i32 @mod_timer(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5), i64 %add)
  br label %cleanup

do.body56:                                        ; preds = %sw.epilog
  %24 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool57 = icmp ne i32 %24, 0
  br i1 %tobool57, label %if.then58, label %cleanup

if.then58:                                        ; preds = %do.body56
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then58, %do.body56, %if.end36, %sw.bb6, %sw.bb, %entry
  %25 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sonypi_compat_report_event(i8 zeroext %event) #0 {
entry:
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %event.addr = alloca i8, align 1
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  store i8 %event, i8* %event.addr, align 1, !tbaa !31
  %0 = bitcast i64* %__dummy to i8*
  %1 = bitcast i64* %__dummy2 to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy to i8*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i64 0, i32 2, i32 0, i32 0))
  %4 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.70* %4 to %struct.__kfifo*
  %conv6 = trunc i64 1 to i32
  %call7 = call i32 @__kfifo_in(%struct.__kfifo* %kfifo, i8* %event.addr, i32 %conv6)
  %5 = bitcast i64* %__dummy.i to i8*
  %6 = bitcast i64* %__dummy2.i to i8*
  %7 = bitcast i64* %__dummy2.i to i8*
  %8 = bitcast i64* %__dummy.i to i8*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i64 0, i32 2, i32 0, i32 0), i64 %call2) #7
  call void @kill_fasync(%struct.fasync_struct** getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 0), i32 29, i32 131073)
  call void @__wake_up(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), i32 1, i32 1, i8* null)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_rel(%struct.input_dev* %dev, i32 %code, i32 %value) #4 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 2, i32 %code, i32 %value)
  ret void
}

declare i32 @__kfifo_in(%struct.__kfifo*, i8*, i32) #1

declare void @kill_fasync(%struct.fasync_struct**, i32, i32) #1

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

declare i32 @acpi_set_current_resources(i8*, %struct.acpi_buffer*) #1

declare i32 @__platform_driver_register(%struct.platform_driver*, %struct.module*) #1

declare %struct.platform_device* @platform_device_alloc(i8*, i32) #1

declare i32 @platform_device_add(%struct.platform_device*) #1

declare void @platform_device_put(%struct.platform_device*) #1

declare void @platform_driver_unregister(%struct.platform_driver*) #1

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_bluetoothpower_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !33
  %conv = zext i8 %0 to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_bluetoothpower_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %value = alloca i64, align 8
  %0 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %1 = load i64, i64* %value, align 8, !tbaa !100
  %conv = trunc i64 %1 to i8
  call void @__sony_pic_set_bluetoothpower(i8 zeroext %conv)
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end2 ], [ -22, %entry ], [ -22, %if.end ]
  %2 = bitcast i64* %value to i8*
  ret i64 %retval.0
}

declare i32 @snprintf(i8*, i64, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #4 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

declare i32 @kstrtoull(i8*, i32, i64*) #1

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_wwanpower_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 12), align 8, !tbaa !157
  %conv = zext i8 %0 to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_wwanpower_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %value = alloca i64, align 8
  %0 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %1 = load i64, i64* %value, align 8, !tbaa !100
  %conv = trunc i64 %1 to i8
  call void @__sony_pic_set_wwanpower(i8 zeroext %conv)
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end2 ], [ -22, %entry ], [ -22, %if.end ]
  %2 = bitcast i64* %value to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @__sony_pic_set_wwanpower(i8 zeroext %state) #0 {
entry:
  %tobool = icmp ne i8 %state, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = trunc i32 %lnot.ext to i8
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 12), align 8, !tbaa !157
  %conv2 = zext i8 %0 to i32
  %conv3 = zext i8 %conv to i32
  %cmp = icmp eq i32 %conv2, %conv3
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = call zeroext i8 @sony_pic_call2(i8 zeroext -80, i8 zeroext %conv)
  call void @sony_pic_call1(i8 zeroext -126)
  store i8 %conv, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 12), align 8, !tbaa !157
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_fanspeed_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %value = alloca i8, align 1
  store i8 0, i8* %value, align 1, !tbaa !31
  %call = call i32 @sony_pic_get_fanspeed(i8* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = load i8, i8* %value, align 1, !tbaa !31
  %conv = zext i8 %0 to i32
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv2, %if.end ], [ -5, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_fanspeed_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %value = alloca i64, align 8
  %0 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %1 = load i64, i64* %value, align 8, !tbaa !100
  %call3 = call i32 @sony_pic_set_fanspeed(i64 %1)
  %tobool4 = icmp ne i32 %call3, 0
  %.count = select i1 %tobool4, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end2 ]
  %2 = bitcast i64* %value to i8*
  ret i64 %retval.0
}

declare void @platform_device_unregister(%struct.platform_device*) #1

declare void @misc_deregister(%struct.miscdevice*) #1

declare i32 @del_timer_sync(%struct.timer_list*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #4 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !123
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !34
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_del_entry_valid(%struct.list_head*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #4 {
entry:
  %__u = alloca %union.anon.73, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !123
  %0 = bitcast %union.anon.73* %__u to i8*
  %__val = bitcast %union.anon.73* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !31
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.73* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %2 = bitcast i8* %arraydecay to i64*
  %3 = load i64, i64* %2, align 8, !tbaa !133
  %4 = bitcast i8* %1 to i64*
  store volatile i64 %3, i64* %4, align 8, !tbaa !133
  %5 = bitcast %union.anon.73* %__u to i8*
  ret void
}

declare void @sysfs_remove_group(%struct.kobject*, %struct.attribute_group*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_suspend(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -664
  %1 = bitcast i8* %add.ptr to %struct.acpi_device*
  %call = call i32 @sony_pic_disable(%struct.acpi_device* %1)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 -6, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_resume(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -664
  %1 = bitcast i8* %add.ptr to %struct.acpi_device*
  %2 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !18
  %3 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !32
  %call = call i32 @sony_pic_enable(%struct.acpi_device* %1, %struct.sony_pic_ioport* %2, %struct.sony_pic_irq* %3)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_add(%struct.acpi_device* %device) #0 {
entry:
  %arg = alloca i32, align 4
  store %struct.acpi_device* %device, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !27
  %pnp = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 10
  %device_class = getelementptr inbounds %struct.acpi_device_pnp, %struct.acpi_device_pnp* %pnp, i32 0, i32 6
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %device_class, i32 0, i32 0
  %call = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.12, i32 0, i32 0))
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %0 = load i8*, i8** %handle, align 8, !tbaa !43
  store i8* %0, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call1 = call i32 @acpi_bus_get_status(%struct.acpi_device* %device)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %status2 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 8
  %1 = bitcast %struct.acpi_device_status* %status2 to i32*
  %bf.load = load i32, i32* %1, align 8
  %bf.clear = and i32 %bf.load, 1
  %tobool3 = icmp ne i32 %bf.clear, 0
  br i1 %tobool3, label %if.end7, label %do.body

do.body:                                          ; preds = %land.lhs.true
  %2 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool4 = icmp ne i32 %2, 0
  br i1 %tobool4, label %if.then5, label %outwalk

if.then5:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %outwalk

if.end7:                                          ; preds = %land.lhs.true, %entry
  %call8 = call i32 @sony_pf_add()
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %outpresent, label %if.end11

if.end11:                                         ; preds = %if.end7
  %3 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool12 = icmp ne i32 %3, 0
  br i1 %tobool12, label %if.then13, label %if.end19

if.then13:                                        ; preds = %if.end11
  %4 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call14 = call i32 @acpi_walk_namespace(i32 8, i8* %4, i32 1, i32 (i8*, i32, i8*, i8**)* @sony_walk_callback, i32 (i8*, i32, i8*, i8**)* null, i8* null, i8** null)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.then13
  call void (i8*, ...) @printk(i8* null)
  br label %outpresent

if.end19:                                         ; preds = %if.then13, %if.end11
  %call20 = call i32 @sony_laptop_setup_input(%struct.acpi_device* %device)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end19
  call void (i8*, ...) @printk(i8* null)
  br label %outplatform

if.end24:                                         ; preds = %if.end19
  %5 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call25 = call zeroext i1 @acpi_has_method(i8* %5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.77, i32 0, i32 0))
  br i1 %call25, label %if.then26, label %if.end38

if.then26:                                        ; preds = %if.end24
  %6 = bitcast i32* %arg to i8*
  store i32 1, i32* %arg, align 4, !tbaa !2
  %7 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call27 = call i32 @sony_nc_int_call(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.77, i32 0, i32 0), i32* %arg, i32* null)
  %tobool28 = icmp ne i32 %call27, 0
  %8 = load i32, i32* @debug, align 4
  %tobool31 = icmp ne i32 %8, 0
  %or.cond = and i1 %tobool28, %tobool31
  br i1 %or.cond, label %if.then32, label %if.end37

if.then32:                                        ; preds = %if.then26
  call void (i8*, ...) @printk(i8* null)
  br label %if.end37

if.end37:                                         ; preds = %if.then32, %if.then26
  %9 = bitcast i32* %arg to i8*
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.end24
  %10 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call39 = call zeroext i1 @acpi_has_method(i8* %10, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.79, i32 0, i32 0))
  br i1 %call39, label %do.body41, label %if.end52

do.body41:                                        ; preds = %if.end38
  %11 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool42 = icmp ne i32 %11, 0
  br i1 %tobool42, label %if.then43, label %do.end47

if.then43:                                        ; preds = %do.body41
  call void (i8*, ...) @printk(i8* null)
  br label %do.end47

do.end47:                                         ; preds = %if.then43, %do.body41
  %12 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  %call48 = call i32 @sony_nc_handles_setup(%struct.platform_device* %12)
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.end52, label %if.then50

if.then50:                                        ; preds = %do.end47
  %13 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  call void @sony_nc_function_setup(%struct.acpi_device* %device, %struct.platform_device* %13)
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %do.end47, %if.end38
  %call53 = call i32 @acpi_video_get_backlight_type()
  %cmp = icmp eq i32 %call53, 2
  br i1 %cmp, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.end52
  call void @sony_nc_backlight_setup()
  br label %if.end55

if.end55:                                         ; preds = %if.then54, %if.end52
  br label %for.cond

for.cond:                                         ; preds = %for.inc125, %if.end55
  %item.0 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %if.end55 ], [ %incdec.ptr126, %for.inc125 ]
  %name = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %14 = load i8*, i8** %name, align 8, !tbaa !158
  %tobool56 = icmp ne i8* %14, null
  br i1 %tobool56, label %for.body, label %for.end127

for.body:                                         ; preds = %for.cond
  %15 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool57 = icmp ne i32 %15, 0
  br i1 %tobool57, label %if.end61, label %land.lhs.true58

land.lhs.true58:                                  ; preds = %for.body
  %debug = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 6
  %16 = load i32, i32* %debug, align 8, !tbaa !163
  %tobool59 = icmp ne i32 %16, 0
  br i1 %tobool59, label %for.inc125, label %if.end61

if.end61:                                         ; preds = %land.lhs.true58, %for.body
  br label %for.cond62

for.cond62:                                       ; preds = %for.inc, %if.end61
  %acpiget = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %17 = load i8**, i8*** %acpiget, align 8, !tbaa !164
  %tobool63 = icmp ne i8** %17, null
  br i1 %tobool63, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond62
  %acpiget64 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %18 = load i8**, i8*** %acpiget64, align 8, !tbaa !164
  %19 = load i8*, i8** %18, align 8, !tbaa !27
  %tobool65 = icmp ne i8* %19, null
  br i1 %tobool65, label %for.body66, label %for.end

for.body66:                                       ; preds = %land.rhs
  %20 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %acpiget67 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %21 = load i8**, i8*** %acpiget67, align 8, !tbaa !164
  %22 = load i8*, i8** %21, align 8, !tbaa !27
  %call68 = call zeroext i1 @acpi_has_method(i8* %20, i8* %22)
  br i1 %call68, label %do.body70, label %for.inc

do.body70:                                        ; preds = %for.body66
  %23 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool71 = icmp ne i32 %23, 0
  br i1 %tobool71, label %if.then72, label %do.end78

if.then72:                                        ; preds = %do.body70
  call void (i8*, ...) @printk(i8* null)
  br label %do.end78

do.end78:                                         ; preds = %if.then72, %do.body70
  %devattr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 1
  %24 = load i16, i16* %mode, align 8, !tbaa !165
  %conv = zext i16 %24 to i32
  %or = or i32 %conv, 292
  %conv79 = trunc i32 %or to i16
  store i16 %conv79, i16* %mode, align 8, !tbaa !165
  br label %for.end

for.inc:                                          ; preds = %for.body66
  %acpiget81 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %25 = load i8**, i8*** %acpiget81, align 8, !tbaa !164
  %incdec.ptr = getelementptr inbounds i8*, i8** %25, i32 1
  store i8** %incdec.ptr, i8*** %acpiget81, align 8, !tbaa !164
  br label %for.cond62

for.end:                                          ; preds = %do.end78, %land.rhs, %for.cond62
  br label %for.cond82

for.cond82:                                       ; preds = %for.inc108, %for.end
  %acpiset = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %26 = load i8**, i8*** %acpiset, align 8, !tbaa !166
  %tobool83 = icmp ne i8** %26, null
  br i1 %tobool83, label %land.rhs84, label %for.end111

land.rhs84:                                       ; preds = %for.cond82
  %acpiset85 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %27 = load i8**, i8*** %acpiset85, align 8, !tbaa !166
  %28 = load i8*, i8** %27, align 8, !tbaa !27
  %tobool86 = icmp ne i8* %28, null
  br i1 %tobool86, label %for.body88, label %for.end111

for.body88:                                       ; preds = %land.rhs84
  %29 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %acpiset89 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %30 = load i8**, i8*** %acpiset89, align 8, !tbaa !166
  %31 = load i8*, i8** %30, align 8, !tbaa !27
  %call90 = call zeroext i1 @acpi_has_method(i8* %29, i8* %31)
  br i1 %call90, label %do.body92, label %for.inc108

do.body92:                                        ; preds = %for.body88
  %32 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool93 = icmp ne i32 %32, 0
  br i1 %tobool93, label %if.then94, label %do.end100

if.then94:                                        ; preds = %do.body92
  call void (i8*, ...) @printk(i8* null)
  br label %do.end100

do.end100:                                        ; preds = %if.then94, %do.body92
  %devattr101 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %attr102 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr101, i32 0, i32 0
  %mode103 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr102, i32 0, i32 1
  %33 = load i16, i16* %mode103, align 8, !tbaa !165
  %conv104 = zext i16 %33 to i32
  %or105 = or i32 %conv104, 128
  %conv106 = trunc i32 %or105 to i16
  store i16 %conv106, i16* %mode103, align 8, !tbaa !165
  br label %for.end111

for.inc108:                                       ; preds = %for.body88
  %acpiset109 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %34 = load i8**, i8*** %acpiset109, align 8, !tbaa !166
  %incdec.ptr110 = getelementptr inbounds i8*, i8** %34, i32 1
  store i8** %incdec.ptr110, i8*** %acpiset109, align 8, !tbaa !166
  br label %for.cond82

for.end111:                                       ; preds = %do.end100, %land.rhs84, %for.cond82
  %devattr112 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %attr113 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr112, i32 0, i32 0
  %mode114 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr113, i32 0, i32 1
  %35 = load i16, i16* %mode114, align 8, !tbaa !165
  %conv115 = zext i16 %35 to i32
  %cmp116 = icmp ne i32 %conv115, 0
  br i1 %cmp116, label %if.then118, label %for.inc125

if.then118:                                       ; preds = %for.end111
  %36 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %36, i32 0, i32 3
  %devattr119 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %call120 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %devattr119)
  %tobool121 = icmp ne i32 %call120, 0
  br i1 %tobool121, label %out_sysfs, label %for.inc125

for.inc125:                                       ; preds = %if.then118, %for.end111, %land.lhs.true58
  %incdec.ptr126 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 1
  br label %for.cond

for.end127:                                       ; preds = %for.cond
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

out_sysfs:                                        ; preds = %if.then118
  br label %for.cond129

for.cond129:                                      ; preds = %for.body132, %out_sysfs
  %item.1 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %out_sysfs ], [ %incdec.ptr136, %for.body132 ]
  %name130 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.1, i32 0, i32 0
  %37 = load i8*, i8** %name130, align 8, !tbaa !158
  %tobool131 = icmp ne i8* %37, null
  br i1 %tobool131, label %for.body132, label %for.end137

for.body132:                                      ; preds = %for.cond129
  %38 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  %dev133 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %38, i32 0, i32 3
  %devattr134 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.1, i32 0, i32 7
  call void @device_remove_file(%struct.device* %dev133, %struct.device_attribute* %devattr134)
  %incdec.ptr136 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.1, i32 1
  br label %for.cond129

for.end137:                                       ; preds = %for.cond129
  call void @sony_nc_backlight_cleanup()
  %39 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  call void @sony_nc_function_cleanup(%struct.platform_device* %39)
  %40 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  call void @sony_nc_handles_cleanup(%struct.platform_device* %40)
  br label %outplatform

outplatform:                                      ; preds = %for.end137, %if.then22
  %result.0 = phi i32 [ %call20, %if.then22 ], [ %call120, %for.end137 ]
  call void @sony_laptop_remove_input()
  br label %outpresent

outpresent:                                       ; preds = %outplatform, %if.then16, %if.end7
  %result.1 = phi i32 [ -19, %if.then16 ], [ %result.0, %outplatform ], [ %call8, %if.end7 ]
  call void @sony_pf_remove()
  br label %outwalk

outwalk:                                          ; preds = %outpresent, %if.then5, %do.body
  %result.2 = phi i32 [ %result.1, %outpresent ], [ -19, %if.then5 ], [ -19, %do.body ]
  call void @sony_nc_rfkill_cleanup()
  br label %cleanup

cleanup:                                          ; preds = %outwalk, %for.end127
  %retval.0 = phi i32 [ %result.2, %outwalk ], [ 0, %for.end127 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_remove(%struct.acpi_device* %device) #0 {
entry:
  call void @sony_nc_backlight_cleanup()
  store %struct.acpi_device* null, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !27
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %item.0 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %entry ], [ %incdec.ptr, %for.body ]
  %name = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !158
  %tobool = icmp ne i8* %0, null
  %1 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %1, i32 0, i32 3
  %devattr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %devattr)
  %incdec.ptr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @sony_nc_function_cleanup(%struct.platform_device* %1)
  %2 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !27
  call void @sony_nc_handles_cleanup(%struct.platform_device* %2)
  call void @sony_pf_remove()
  call void @sony_laptop_remove_input()
  %3 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then, label %do.end

if.then:                                          ; preds = %for.end
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %for.end
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_notify(%struct.acpi_device* %device, i32 %event) #0 {
entry:
  %result = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cmp = icmp uge i32 %event, 144
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %do.end
  %1 = bitcast i32* %result to i8*
  store i32 0, i32* %result, align 4, !tbaa !2
  %2 = bitcast i32* %arg to i8*
  store i32 0, i32* %arg, align 4, !tbaa !2
  %sub = sub i32 %event, 144
  %conv = zext i32 %sub to i64
  %cmp2 = icmp uge i64 %conv, 16
  br i1 %cmp2, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.then1
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end6:                                          ; preds = %if.then1
  %3 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %3, i32 0, i32 0
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %4 = load i16, i16* %arrayidx, align 2, !tbaa !153
  %conv7 = zext i16 %4 to i32
  %Pivot20 = icmp slt i32 %conv7, 296
  br i1 %Pivot20, label %NodeBlock3, label %NodeBlock17

NodeBlock17:                                      ; preds = %if.end6
  %Pivot18 = icmp slt i32 %conv7, 326
  br i1 %Pivot18, label %NodeBlock9, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %conv7, 347
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %conv7, 347
  br i1 %SwitchLeaf14, label %sw.bb41, label %do.body43

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %conv7, 326
  br i1 %SwitchLeaf12, label %sw.bb20, label %do.body43

NodeBlock9:                                       ; preds = %NodeBlock17
  %Pivot10 = icmp slt i32 %conv7, 309
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv7, 309
  br i1 %SwitchLeaf8, label %sw.bb14, label %do.body43

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv7, 296
  br i1 %SwitchLeaf6, label %sw.bb20, label %do.body43

NodeBlock3:                                       ; preds = %if.end6
  %Pivot4 = icmp slt i32 %conv7, 292
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %conv7, 295
  br i1 %Pivot, label %LeafBlock1, label %sw.bb

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv7, 292
  br i1 %SwitchLeaf2, label %sw.bb14, label %do.body43

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %conv7, 256
  br i1 %SwitchLeaf, label %sw.bb, label %do.body43

sw.bb:                                            ; preds = %LeafBlock, %NodeBlock
  %call8 = call i32 @sony_nc_hotkeys_decode(i32 %conv7)
  %cmp9 = icmp sgt i32 %call8, 0
  br i1 %cmp9, label %if.then11, label %sw.epilog

if.then11:                                        ; preds = %sw.bb
  %conv12 = trunc i32 %call8 to i8
  call void @sony_laptop_report_input_event(i8 zeroext %conv12)
  br label %sw.epilog

sw.bb14:                                          ; preds = %LeafBlock1, %LeafBlock7
  %call15 = call i32 @sony_call_snc_handle(i32 %conv7, i32 256, i32* %result)
  %5 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %5, 3
  %cmp16 = icmp eq i32 %and, 1
  br i1 %cmp16, label %if.then18, label %sw.epilog

if.then18:                                        ; preds = %sw.bb14
  call void @sony_nc_rfkill_update()
  br label %sw.epilog

sw.bb20:                                          ; preds = %LeafBlock5, %LeafBlock11
  %call21 = call i32 @sony_call_snc_handle(i32 %conv7, i32 0, i32* %result)
  %6 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool23 = icmp ne i32 %6, 0
  br i1 %tobool23, label %if.then24, label %do.end39

if.then24:                                        ; preds = %sw.bb20
  %7 = load i32, i32* %result, align 4, !tbaa !2
  %cmp25 = icmp eq i32 %7, 1
  br i1 %cmp25, label %cond.end34, label %cond.false

cond.false:                                       ; preds = %if.then24
  %8 = load i32, i32* %result, align 4, !tbaa !2
  %cmp27 = icmp eq i32 %8, 2
  br i1 %cmp27, label %cond.end34, label %cond.false30

cond.false30:                                     ; preds = %cond.false
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false30, %cond.false, %if.then24
  call void (i8*, ...) @printk(i8* null)
  br label %do.end39

do.end39:                                         ; preds = %cond.end34, %sw.bb20
  %call40 = call i32 @__sony_nc_gfx_switch_status_get()
  br label %sw.epilog

sw.bb41:                                          ; preds = %LeafBlock13
  %call42 = call i32 @__sony_nc_gfx_switch_status_get()
  br label %sw.epilog

do.body43:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock5, %LeafBlock7, %LeafBlock11, %LeafBlock13
  %9 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool44 = icmp ne i32 %9, 0
  br i1 %tobool44, label %if.then45, label %sw.epilog

if.then45:                                        ; preds = %do.body43
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then45, %do.body43, %sw.bb41, %do.end39, %if.then18, %sw.bb14, %if.then11, %sw.bb
  %ev_type.0 = phi i8 [ 3, %do.end39 ], [ 3, %sw.bb41 ], [ 1, %if.then11 ], [ 1, %sw.bb ], [ 2, %if.then18 ], [ 2, %sw.bb14 ], [ 0, %if.then45 ], [ 0, %do.body43 ]
  %real_ev.1 = phi i32 [ %call40, %do.end39 ], [ %call42, %sw.bb41 ], [ %call8, %if.then11 ], [ %event, %sw.bb ], [ %and, %if.then18 ], [ %and, %sw.bb14 ], [ %event, %if.then45 ], [ %event, %do.body43 ]
  %shl = shl i32 1, %sub
  store i32 %shl, i32* %arg, align 4, !tbaa !2
  %10 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call50 = call i32 @sony_nc_int_call(i8* %10, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.201, i32 0, i32 0), i32* %arg, i32* %result)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %if.then4
  %ev_type.1 = phi i8 [ 0, %if.then4 ], [ %ev_type.0, %sw.epilog ]
  %real_ev.2 = phi i32 [ %event, %if.then4 ], [ %real_ev.1, %sw.epilog ]
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then4 ], [ 0, %sw.epilog ]
  %11 = bitcast i32* %arg to i8*
  %12 = bitcast i32* %result to i8*
  %SwitchLeaf23 = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf23, label %if.end55, label %cleanup.cont62

if.else:                                          ; preds = %do.end
  %conv54 = trunc i32 %event to i8
  call void @sony_laptop_report_input_event(i8 zeroext %conv54)
  br label %if.end55

if.end55:                                         ; preds = %if.else, %cleanup
  %ev_type.2 = phi i8 [ 1, %if.else ], [ %ev_type.1, %cleanup ]
  %real_ev.3 = phi i32 [ %event, %if.else ], [ %real_ev.2, %cleanup ]
  %13 = load %struct.acpi_device*, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !27
  %pnp = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %13, i32 0, i32 10
  %device_class = getelementptr inbounds %struct.acpi_device_pnp, %struct.acpi_device_pnp* %pnp, i32 0, i32 6
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %device_class, i32 0, i32 0
  %14 = load %struct.acpi_device*, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !27
  %dev = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %14, i32 0, i32 21
  %call56 = call i8* @dev_name(%struct.device* %dev)
  %call57 = call i32 @acpi_bus_generate_netlink_event(i8* %arraydecay, i8* %call56, i8 zeroext %ev_type.2, i32 %real_ev.3)
  br label %cleanup.cont62

cleanup.cont62:                                   ; preds = %if.end55, %cleanup
  ret void
}

declare i32 @acpi_walk_namespace(i32, i8*, i32, i32 (i8*, i32, i8*, i8**)*, i32 (i8*, i32, i8*, i8**)*, i8*, i8**) #1

; Function Attrs: nounwind uwtable
define internal i32 @sony_walk_callback(i8* %handle, i32 %level, i8* %context, i8** %return_value) #0 {
entry:
  %info = alloca %struct.acpi_device_info*, align 8
  %0 = bitcast %struct.acpi_device_info** %info to i8*
  %call = call i32 @acpi_get_object_info(i8* %handle, %struct.acpi_device_info** %info)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  %1 = load %struct.acpi_device_info*, %struct.acpi_device_info** %info, align 8, !tbaa !27
  %2 = bitcast %struct.acpi_device_info* %1 to i8*
  call void @kfree(i8* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = bitcast %struct.acpi_device_info** %info to i8*
  ret i32 0
}

declare zeroext i1 @acpi_has_method(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_handles_setup(%struct.platform_device* %pd) #0 {
entry:
  %result = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i32* %arg to i8*
  %call = call i8* @kzalloc(i64 80, i32 20971712)
  %2 = bitcast i8* %call to %struct.sony_nc_handles*
  store %struct.sony_nc_handles* %2, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %3 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %tobool = icmp ne %struct.sony_nc_handles* %3, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 %i.0, 32
  store i32 %add, i32* %arg, align 4, !tbaa !2
  %4 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call2 = call i32 @sony_nc_int_call(i8* %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.79, i32 0, i32 0), i32* %arg, i32* %result)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %for.inc, label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool5 = icmp ne i32 %5, 0
  br i1 %tobool5, label %if.then6, label %do.end

if.then6:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then6, %do.body
  %6 = load i32, i32* %result, align 4, !tbaa !2
  %conv9 = trunc i32 %6 to i16
  %7 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %7, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  store i16 %conv9, i16* %arrayidx, align 2, !tbaa !153
  br label %for.inc

for.inc:                                          ; preds = %do.end, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool11 = icmp ne i32 %8, 0
  br i1 %tobool11, label %do.body13, label %cleanup

do.body13:                                        ; preds = %for.end
  %9 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %devattr = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %9, i32 0, i32 1
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_handles_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %10 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %devattr16 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %10, i32 0, i32 1
  %attr17 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr16, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr17, i32 0, i32 0
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.86, i32 0, i32 0), i8** %name, align 8, !tbaa !168
  %11 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %devattr18 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %11, i32 0, i32 1
  %attr19 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr18, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr19, i32 0, i32 1
  store i16 292, i16* %mode, align 8, !tbaa !170
  %12 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %devattr20 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %12, i32 0, i32 1
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr20, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_handles_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !171
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %13 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %devattr21 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %13, i32 0, i32 1
  %call22 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %devattr21)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %cleanup

if.then24:                                        ; preds = %do.body13
  %14 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %15 = bitcast %struct.sony_nc_handles* %14 to i8*
  call void @kfree(i8* %15)
  store %struct.sony_nc_handles* null, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %if.then24, %do.body13, %for.end, %entry
  %retval.0 = phi i32 [ -1, %if.then24 ], [ -12, %entry ], [ 0, %do.body13 ], [ 0, %for.end ]
  %16 = bitcast i32* %arg to i8*
  %17 = bitcast i32* %result to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_function_setup(%struct.acpi_device* %device, %struct.platform_device* %pf_device) #0 {
entry:
  %result = alloca i32, align 4
  %bitmask = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i32* %bitmask to i8*
  %2 = bitcast i32* %arg to i8*
  %3 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %tobool = icmp ne %struct.sony_nc_handles* %3, null
  br i1 %tobool, label %if.end, label %cleanup95

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock95, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %LeafBlock95 ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %4, i32 0, i32 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %5 = load i16, i16* %arrayidx, align 2, !tbaa !153
  %conv2 = zext i16 %5 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br i1 %tobool3, label %do.body, label %LeafBlock95

do.body:                                          ; preds = %for.body
  %6 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %if.then7, label %NodeBlock92

if.then7:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %NodeBlock92

NodeBlock92:                                      ; preds = %if.then7, %do.body
  %Pivot93 = icmp slt i32 %conv2, 310
  br i1 %Pivot93, label %NodeBlock39, label %NodeBlock90

NodeBlock90:                                      ; preds = %NodeBlock92
  %Pivot91 = icmp slt i32 %conv2, 331
  br i1 %Pivot91, label %NodeBlock61, label %NodeBlock88

NodeBlock88:                                      ; preds = %NodeBlock90
  %Pivot89 = icmp slt i32 %conv2, 347
  br i1 %Pivot89, label %NodeBlock72, label %NodeBlock86

NodeBlock86:                                      ; preds = %NodeBlock88
  %Pivot87 = icmp slt i32 %conv2, 355
  br i1 %Pivot87, label %NodeBlock78, label %NodeBlock84

NodeBlock84:                                      ; preds = %NodeBlock86
  %Pivot85 = icmp slt i32 %conv2, 360
  br i1 %Pivot85, label %LeafBlock80, label %LeafBlock82

LeafBlock82:                                      ; preds = %NodeBlock84
  %SwitchLeaf83 = icmp eq i32 %conv2, 360
  br i1 %SwitchLeaf83, label %sw.bb84, label %LeafBlock95

LeafBlock80:                                      ; preds = %NodeBlock84
  %SwitchLeaf81 = icmp eq i32 %conv2, 355
  br i1 %SwitchLeaf81, label %sw.bb54, label %LeafBlock95

NodeBlock78:                                      ; preds = %NodeBlock86
  %Pivot79 = icmp slt i32 %conv2, 349
  br i1 %Pivot79, label %LeafBlock74, label %LeafBlock76

LeafBlock76:                                      ; preds = %NodeBlock78
  %SwitchLeaf77 = icmp eq i32 %conv2, 349
  br i1 %SwitchLeaf77, label %sw.bb24, label %LeafBlock95

LeafBlock74:                                      ; preds = %NodeBlock78
  %SwitchLeaf75 = icmp eq i32 %conv2, 347
  br i1 %SwitchLeaf75, label %sw.bb36, label %LeafBlock95

NodeBlock72:                                      ; preds = %NodeBlock88
  %Pivot73 = icmp slt i32 %conv2, 339
  br i1 %Pivot73, label %LeafBlock63, label %NodeBlock70

NodeBlock70:                                      ; preds = %NodeBlock72
  %Pivot71 = icmp slt i32 %conv2, 341
  br i1 %Pivot71, label %LeafBlock66, label %LeafBlock68

LeafBlock68:                                      ; preds = %NodeBlock70
  %SwitchLeaf69 = icmp eq i32 %conv2, 341
  br i1 %SwitchLeaf69, label %sw.bb72, label %LeafBlock95

LeafBlock66:                                      ; preds = %NodeBlock70
  %SwitchLeaf67 = icmp eq i32 %conv2, 339
  br i1 %SwitchLeaf67, label %sw.bb54, label %LeafBlock95

LeafBlock63:                                      ; preds = %NodeBlock72
  %.off64 = add i32 %conv2, -331
  %SwitchLeaf65 = icmp ule i32 %.off64, 1
  br i1 %SwitchLeaf65, label %sw.bb54, label %LeafBlock95

NodeBlock61:                                      ; preds = %NodeBlock90
  %Pivot62 = icmp slt i32 %conv2, 323
  br i1 %Pivot62, label %NodeBlock47, label %NodeBlock59

NodeBlock59:                                      ; preds = %NodeBlock61
  %Pivot60 = icmp slt i32 %conv2, 328
  br i1 %Pivot60, label %NodeBlock53, label %NodeBlock57

NodeBlock57:                                      ; preds = %NodeBlock59
  %Pivot58 = icmp slt i32 %conv2, 329
  br i1 %Pivot58, label %sw.bb12, label %LeafBlock55

LeafBlock55:                                      ; preds = %NodeBlock57
  %SwitchLeaf56 = icmp eq i32 %conv2, 329
  br i1 %SwitchLeaf56, label %sw.bb66, label %LeafBlock95

NodeBlock53:                                      ; preds = %NodeBlock59
  %Pivot54 = icmp slt i32 %conv2, 326
  br i1 %Pivot54, label %LeafBlock49, label %LeafBlock51

LeafBlock51:                                      ; preds = %NodeBlock53
  %SwitchLeaf52 = icmp eq i32 %conv2, 326
  br i1 %SwitchLeaf52, label %sw.bb36, label %LeafBlock95

LeafBlock49:                                      ; preds = %NodeBlock53
  %SwitchLeaf50 = icmp eq i32 %conv2, 323
  br i1 %SwitchLeaf50, label %sw.bb54, label %LeafBlock95

NodeBlock47:                                      ; preds = %NodeBlock61
  %Pivot48 = icmp slt i32 %conv2, 311
  br i1 %Pivot48, label %sw.bb18, label %NodeBlock45

NodeBlock45:                                      ; preds = %NodeBlock47
  %Pivot46 = icmp slt i32 %conv2, 319
  br i1 %Pivot46, label %LeafBlock41, label %LeafBlock43

LeafBlock43:                                      ; preds = %NodeBlock45
  %SwitchLeaf44 = icmp eq i32 %conv2, 319
  br i1 %SwitchLeaf44, label %sw.bb18, label %LeafBlock95

LeafBlock41:                                      ; preds = %NodeBlock45
  %SwitchLeaf42 = icmp eq i32 %conv2, 311
  br i1 %SwitchLeaf42, label %sw.bb54, label %LeafBlock95

NodeBlock39:                                      ; preds = %NodeBlock92
  %Pivot40 = icmp slt i32 %conv2, 289
  br i1 %Pivot40, label %NodeBlock17, label %NodeBlock37

NodeBlock37:                                      ; preds = %NodeBlock39
  %Pivot38 = icmp slt i32 %conv2, 295
  br i1 %Pivot38, label %NodeBlock25, label %NodeBlock35

NodeBlock35:                                      ; preds = %NodeBlock37
  %Pivot36 = icmp slt i32 %conv2, 305
  br i1 %Pivot36, label %NodeBlock29, label %NodeBlock33

NodeBlock33:                                      ; preds = %NodeBlock35
  %Pivot34 = icmp slt i32 %conv2, 309
  br i1 %Pivot34, label %LeafBlock31, label %sw.bb48

LeafBlock31:                                      ; preds = %NodeBlock33
  %SwitchLeaf32 = icmp eq i32 %conv2, 305
  br i1 %SwitchLeaf32, label %sw.bb42, label %LeafBlock95

NodeBlock29:                                      ; preds = %NodeBlock35
  %Pivot30 = icmp slt i32 %conv2, 296
  br i1 %Pivot30, label %sw.bb, label %LeafBlock27

LeafBlock27:                                      ; preds = %NodeBlock29
  %SwitchLeaf28 = icmp eq i32 %conv2, 296
  br i1 %SwitchLeaf28, label %sw.bb36, label %LeafBlock95

NodeBlock25:                                      ; preds = %NodeBlock37
  %Pivot26 = icmp slt i32 %conv2, 290
  br i1 %Pivot26, label %sw.bb60, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %conv2, 292
  br i1 %Pivot24, label %LeafBlock19, label %LeafBlock21

LeafBlock21:                                      ; preds = %NodeBlock23
  %SwitchLeaf22 = icmp eq i32 %conv2, 292
  br i1 %SwitchLeaf22, label %sw.bb48, label %LeafBlock95

LeafBlock19:                                      ; preds = %NodeBlock23
  %SwitchLeaf20 = icmp eq i32 %conv2, 290
  br i1 %SwitchLeaf20, label %sw.bb30, label %LeafBlock95

NodeBlock17:                                      ; preds = %NodeBlock39
  %Pivot18 = icmp slt i32 %conv2, 277
  br i1 %Pivot18, label %NodeBlock5, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %conv2, 281
  br i1 %Pivot16, label %LeafBlock7, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %conv2, 285
  br i1 %Pivot14, label %LeafBlock9, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %conv2, 285
  br i1 %SwitchLeaf12, label %sw.bb78, label %LeafBlock95

LeafBlock9:                                       ; preds = %NodeBlock13
  %SwitchLeaf10 = icmp eq i32 %conv2, 281
  br i1 %SwitchLeaf10, label %sw.bb24, label %LeafBlock95

LeafBlock7:                                       ; preds = %NodeBlock15
  %SwitchLeaf8 = icmp eq i32 %conv2, 277
  br i1 %SwitchLeaf8, label %sw.bb18, label %LeafBlock95

NodeBlock5:                                       ; preds = %NodeBlock17
  %Pivot6 = icmp slt i32 %conv2, 258
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv2, 261
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv2, 261
  br i1 %SwitchLeaf4, label %sw.bb12, label %LeafBlock95

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv2, 258
  br i1 %SwitchLeaf2, label %sw.bb10, label %LeafBlock95

LeafBlock:                                        ; preds = %NodeBlock5
  %.off = add i32 %conv2, -256
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %LeafBlock95

sw.bb:                                            ; preds = %LeafBlock, %NodeBlock29
  %call9 = call i32 @sony_call_snc_handle(i32 %conv2, i32 0, i32* %result)
  br label %LeafBlock95

sw.bb10:                                          ; preds = %LeafBlock1
  %call11 = call i32 @sony_call_snc_handle(i32 %conv2, i32 256, i32* %result)
  br label %LeafBlock95

sw.bb12:                                          ; preds = %LeafBlock3, %NodeBlock57
  %call13 = call i32 @sony_nc_touchpad_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call13, i32* %result, align 4, !tbaa !2
  %7 = load i32, i32* %result, align 4, !tbaa !2
  %tobool14 = icmp ne i32 %7, 0
  br i1 %tobool14, label %if.then15, label %LeafBlock95

if.then15:                                        ; preds = %sw.bb12
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb18:                                          ; preds = %LeafBlock7, %LeafBlock43, %NodeBlock47
  %call19 = call i32 @sony_nc_battery_care_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call19, i32* %result, align 4, !tbaa !2
  %8 = load i32, i32* %result, align 4, !tbaa !2
  %tobool20 = icmp ne i32 %8, 0
  br i1 %tobool20, label %if.then21, label %LeafBlock95

if.then21:                                        ; preds = %sw.bb18
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb24:                                          ; preds = %LeafBlock9, %LeafBlock76
  %call25 = call i32 @sony_nc_lid_resume_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call25, i32* %result, align 4, !tbaa !2
  %9 = load i32, i32* %result, align 4, !tbaa !2
  %tobool26 = icmp ne i32 %9, 0
  br i1 %tobool26, label %if.then27, label %LeafBlock95

if.then27:                                        ; preds = %sw.bb24
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb30:                                          ; preds = %LeafBlock19
  %call31 = call i32 @sony_nc_thermal_setup(%struct.platform_device* %pf_device)
  store i32 %call31, i32* %result, align 4, !tbaa !2
  %10 = load i32, i32* %result, align 4, !tbaa !2
  %tobool32 = icmp ne i32 %10, 0
  br i1 %tobool32, label %if.then33, label %LeafBlock95

if.then33:                                        ; preds = %sw.bb30
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb36:                                          ; preds = %LeafBlock27, %LeafBlock51, %LeafBlock74
  %call37 = call i32 @sony_nc_gfx_switch_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call37, i32* %result, align 4, !tbaa !2
  %11 = load i32, i32* %result, align 4, !tbaa !2
  %tobool38 = icmp ne i32 %11, 0
  br i1 %tobool38, label %if.then39, label %LeafBlock95

if.then39:                                        ; preds = %sw.bb36
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb42:                                          ; preds = %LeafBlock31
  %call43 = call i32 @sony_nc_highspeed_charging_setup(%struct.platform_device* %pf_device)
  store i32 %call43, i32* %result, align 4, !tbaa !2
  %12 = load i32, i32* %result, align 4, !tbaa !2
  %tobool44 = icmp ne i32 %12, 0
  br i1 %tobool44, label %if.then45, label %LeafBlock95

if.then45:                                        ; preds = %sw.bb42
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb48:                                          ; preds = %LeafBlock21, %NodeBlock33
  %call49 = call i32 @sony_nc_rfkill_setup(%struct.acpi_device* %device, i32 %conv2)
  store i32 %call49, i32* %result, align 4, !tbaa !2
  %13 = load i32, i32* %result, align 4, !tbaa !2
  %tobool50 = icmp ne i32 %13, 0
  br i1 %tobool50, label %if.then51, label %LeafBlock95

if.then51:                                        ; preds = %sw.bb48
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb54:                                          ; preds = %LeafBlock41, %LeafBlock49, %LeafBlock63, %LeafBlock66, %LeafBlock80
  %call55 = call i32 @sony_nc_kbd_backlight_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call55, i32* %result, align 4, !tbaa !2
  %14 = load i32, i32* %result, align 4, !tbaa !2
  %tobool56 = icmp ne i32 %14, 0
  br i1 %tobool56, label %if.then57, label %LeafBlock95

if.then57:                                        ; preds = %sw.bb54
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb60:                                          ; preds = %NodeBlock25
  %call61 = call i32 @sony_nc_lowbatt_setup(%struct.platform_device* %pf_device)
  store i32 %call61, i32* %result, align 4, !tbaa !2
  %15 = load i32, i32* %result, align 4, !tbaa !2
  %tobool62 = icmp ne i32 %15, 0
  br i1 %tobool62, label %if.then63, label %LeafBlock95

if.then63:                                        ; preds = %sw.bb60
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb66:                                          ; preds = %LeafBlock55
  %call67 = call i32 @sony_nc_fanspeed_setup(%struct.platform_device* %pf_device)
  store i32 %call67, i32* %result, align 4, !tbaa !2
  %16 = load i32, i32* %result, align 4, !tbaa !2
  %tobool68 = icmp ne i32 %16, 0
  br i1 %tobool68, label %if.then69, label %LeafBlock95

if.then69:                                        ; preds = %sw.bb66
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb72:                                          ; preds = %LeafBlock68
  %call73 = call i32 @sony_nc_usb_charge_setup(%struct.platform_device* %pf_device)
  store i32 %call73, i32* %result, align 4, !tbaa !2
  %17 = load i32, i32* %result, align 4, !tbaa !2
  %tobool74 = icmp ne i32 %17, 0
  br i1 %tobool74, label %if.then75, label %LeafBlock95

if.then75:                                        ; preds = %sw.bb72
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb78:                                          ; preds = %LeafBlock11
  %call79 = call i32 @sony_nc_panelid_setup(%struct.platform_device* %pf_device)
  store i32 %call79, i32* %result, align 4, !tbaa !2
  %18 = load i32, i32* %result, align 4, !tbaa !2
  %tobool80 = icmp ne i32 %18, 0
  br i1 %tobool80, label %if.then81, label %LeafBlock95

if.then81:                                        ; preds = %sw.bb78
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

sw.bb84:                                          ; preds = %LeafBlock82
  %call85 = call i32 @sony_nc_smart_conn_setup(%struct.platform_device* %pf_device)
  store i32 %call85, i32* %result, align 4, !tbaa !2
  %19 = load i32, i32* %result, align 4, !tbaa !2
  %tobool86 = icmp ne i32 %19, 0
  br i1 %tobool86, label %if.then87, label %LeafBlock95

if.then87:                                        ; preds = %sw.bb84
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock95

LeafBlock95:                                      ; preds = %if.then87, %sw.bb84, %if.then81, %sw.bb78, %if.then75, %sw.bb72, %if.then69, %sw.bb66, %if.then63, %sw.bb60, %if.then57, %sw.bb54, %if.then51, %sw.bb48, %if.then45, %sw.bb42, %if.then39, %sw.bb36, %if.then33, %sw.bb30, %if.then27, %sw.bb24, %if.then21, %sw.bb18, %if.then15, %sw.bb12, %sw.bb10, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11, %LeafBlock19, %LeafBlock21, %LeafBlock27, %LeafBlock31, %LeafBlock41, %LeafBlock43, %LeafBlock49, %LeafBlock51, %LeafBlock55, %LeafBlock63, %LeafBlock66, %LeafBlock68, %LeafBlock74, %LeafBlock76, %LeafBlock80, %LeafBlock82, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 16, i32* %arg, align 4, !tbaa !2
  %20 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call90 = call i32 @sony_nc_int_call(i8* %20, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.79, i32 0, i32 0), i32* %arg, i32* %bitmask)
  %tobool91 = icmp ne i32 %call90, 0
  br i1 %tobool91, label %cleanup95, label %if.then92

if.then92:                                        ; preds = %for.end
  %21 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call93 = call i32 @sony_nc_int_call(i8* %21, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.103, i32 0, i32 0), i32* %bitmask, i32* %result)
  br label %cleanup95

cleanup95:                                        ; preds = %if.then92, %for.end, %entry
  %22 = bitcast i32* %arg to i8*
  %23 = bitcast i32* %bitmask to i8*
  %24 = bitcast i32* %result to i8*
  ret void
}

declare i32 @acpi_video_get_backlight_type() #1

; Function Attrs: nounwind uwtable
define internal void @sony_nc_backlight_setup() #0 {
entry:
  %props = alloca %struct.backlight_properties, align 4
  %0 = bitcast %struct.backlight_properties* %props to i8*
  %call = call i32 @sony_find_snc_handle(i32 303)
  %cmp = icmp sge i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 256, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !172
  call void @sony_nc_backlight_ng_read_limits(i32 303, %struct.sony_backlight_props* @sony_bl_props)
  %1 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !173
  %conv = zext i8 %1 to i32
  %2 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !174
  %conv1 = zext i8 %2 to i32
  %sub = sub nsw i32 %conv, %conv1
  br label %if.end41

if.else:                                          ; preds = %entry
  %call2 = call i32 @sony_find_snc_handle(i32 311)
  %cmp3 = icmp sge i32 %call2, 0
  br i1 %cmp3, label %if.then5, label %if.else9

if.then5:                                         ; preds = %if.else
  store i32 256, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !172
  call void @sony_nc_backlight_ng_read_limits(i32 311, %struct.sony_backlight_props* @sony_bl_props)
  %3 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !173
  %conv6 = zext i8 %3 to i32
  %4 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !174
  %conv7 = zext i8 %4 to i32
  %sub8 = sub nsw i32 %conv6, %conv7
  br label %if.end41

if.else9:                                         ; preds = %if.else
  %call10 = call i32 @sony_find_snc_handle(i32 323)
  %cmp11 = icmp sge i32 %call10, 0
  br i1 %cmp11, label %if.then13, label %if.else17

if.then13:                                        ; preds = %if.else9
  store i32 12288, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !172
  call void @sony_nc_backlight_ng_read_limits(i32 323, %struct.sony_backlight_props* @sony_bl_props)
  %5 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !173
  %conv14 = zext i8 %5 to i32
  %6 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !174
  %conv15 = zext i8 %6 to i32
  %sub16 = sub nsw i32 %conv14, %conv15
  br label %if.end41

if.else17:                                        ; preds = %if.else9
  %call18 = call i32 @sony_find_snc_handle(i32 331)
  %cmp19 = icmp sge i32 %call18, 0
  br i1 %cmp19, label %if.then21, label %if.else25

if.then21:                                        ; preds = %if.else17
  store i32 12288, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !172
  call void @sony_nc_backlight_ng_read_limits(i32 331, %struct.sony_backlight_props* @sony_bl_props)
  %7 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !173
  %conv22 = zext i8 %7 to i32
  %8 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !174
  %conv23 = zext i8 %8 to i32
  %sub24 = sub nsw i32 %conv22, %conv23
  br label %if.end41

if.else25:                                        ; preds = %if.else17
  %call26 = call i32 @sony_find_snc_handle(i32 332)
  %cmp27 = icmp sge i32 %call26, 0
  br i1 %cmp27, label %if.then29, label %if.else33

if.then29:                                        ; preds = %if.else25
  store i32 12288, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !172
  call void @sony_nc_backlight_ng_read_limits(i32 332, %struct.sony_backlight_props* @sony_bl_props)
  %9 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !173
  %conv30 = zext i8 %9 to i32
  %10 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !174
  %conv31 = zext i8 %10 to i32
  %sub32 = sub nsw i32 %conv30, %conv31
  br label %if.end41

if.else33:                                        ; preds = %if.else25
  %11 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call34 = call zeroext i1 @acpi_has_method(i8* %11, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.53, i32 0, i32 0))
  br i1 %call34, label %if.end41, label %cleanup

if.end41:                                         ; preds = %if.else33, %if.then29, %if.then21, %if.then13, %if.then5, %if.then
  %ops.4 = phi %struct.backlight_ops* [ @sony_backlight_ng_ops, %if.then ], [ @sony_backlight_ng_ops, %if.then5 ], [ @sony_backlight_ng_ops, %if.then13 ], [ @sony_backlight_ng_ops, %if.then21 ], [ @sony_backlight_ng_ops, %if.then29 ], [ @sony_backlight_ops, %if.else33 ]
  %max_brightness.4 = phi i32 [ %sub, %if.then ], [ %sub8, %if.then5 ], [ %sub16, %if.then13 ], [ %sub24, %if.then21 ], [ %sub32, %if.then29 ], [ 7, %if.else33 ]
  %12 = bitcast %struct.backlight_properties* %props to i8*
  %call42 = call i8* @__memset(i8* %12, i32 0, i64 24)
  %type = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 4
  store i32 2, i32* %type, align 4, !tbaa !175
  %max_brightness43 = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 1
  store i32 %max_brightness.4, i32* %max_brightness43, align 4, !tbaa !176
  %call44 = call %struct.backlight_device* @backlight_device_register(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.153, i32 0, i32 0), %struct.device* null, i8* bitcast (%struct.sony_backlight_props* @sony_bl_props to i8*), %struct.backlight_ops* %ops.4, %struct.backlight_properties* %props)
  store %struct.backlight_device* %call44, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !144
  %13 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !144
  %14 = bitcast %struct.backlight_device* %13 to i8*
  %call45 = call zeroext i1 @IS_ERR(i8* %14)
  br i1 %call45, label %if.then46, label %if.else48

if.then46:                                        ; preds = %if.end41
  call void (i8*, ...) @printk(i8* null)
  store %struct.backlight_device* null, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !144
  br label %cleanup

if.else48:                                        ; preds = %if.end41
  %get_brightness = getelementptr inbounds %struct.backlight_ops, %struct.backlight_ops* %ops.4, i32 0, i32 2
  %15 = load i32 (%struct.backlight_device*)*, i32 (%struct.backlight_device*)** %get_brightness, align 8, !tbaa !177
  %16 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !144
  %call49 = call i32 %15(%struct.backlight_device* %16)
  %17 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !144
  %props50 = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %17, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props50, i32 0, i32 0
  store i32 %call49, i32* %brightness, align 8, !tbaa !146
  br label %cleanup

cleanup:                                          ; preds = %if.else48, %if.then46, %if.else33
  %18 = bitcast %struct.backlight_properties* %props to i8*
  ret void
}

declare i32 @device_create_file(%struct.device*, %struct.device_attribute*) #1

declare void @device_remove_file(%struct.device*, %struct.device_attribute*) #1

; Function Attrs: nounwind uwtable
define internal void @sony_nc_backlight_cleanup() #0 {
entry:
  %0 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !144
  call void @backlight_device_unregister(%struct.backlight_device* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_function_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %result = alloca i32, align 4
  %bitmask = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i32* %bitmask to i8*
  %2 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %tobool = icmp ne %struct.sony_nc_handles* %2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %3 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call = call i32 @sony_nc_int_call(i8* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.191, i32 0, i32 0), i32* null, i32* %bitmask)
  %4 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call1 = call i32 @sony_nc_int_call(i8* %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.192, i32 0, i32 0), i32* %bitmask, i32* %result)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %5, i32 0, i32 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2, !tbaa !153
  %conv3 = zext i16 %6 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %NodeBlock81, label %for.inc

NodeBlock81:                                      ; preds = %for.body
  %Pivot82 = icmp slt i32 %conv3, 319
  br i1 %Pivot82, label %NodeBlock35, label %NodeBlock79

NodeBlock79:                                      ; preds = %NodeBlock81
  %Pivot80 = icmp slt i32 %conv3, 339
  br i1 %Pivot80, label %NodeBlock55, label %NodeBlock77

NodeBlock77:                                      ; preds = %NodeBlock79
  %Pivot78 = icmp slt i32 %conv3, 349
  br i1 %Pivot78, label %NodeBlock65, label %NodeBlock75

NodeBlock75:                                      ; preds = %NodeBlock77
  %Pivot76 = icmp slt i32 %conv3, 355
  br i1 %Pivot76, label %LeafBlock67, label %NodeBlock73

NodeBlock73:                                      ; preds = %NodeBlock75
  %Pivot74 = icmp slt i32 %conv3, 360
  br i1 %Pivot74, label %LeafBlock69, label %LeafBlock71

LeafBlock71:                                      ; preds = %NodeBlock73
  %SwitchLeaf72 = icmp eq i32 %conv3, 360
  br i1 %SwitchLeaf72, label %sw.bb18, label %for.inc

LeafBlock69:                                      ; preds = %NodeBlock73
  %SwitchLeaf70 = icmp eq i32 %conv3, 355
  br i1 %SwitchLeaf70, label %sw.bb13, label %for.inc

LeafBlock67:                                      ; preds = %NodeBlock75
  %SwitchLeaf68 = icmp eq i32 %conv3, 349
  br i1 %SwitchLeaf68, label %sw.bb8, label %for.inc

NodeBlock65:                                      ; preds = %NodeBlock77
  %Pivot66 = icmp slt i32 %conv3, 341
  br i1 %Pivot66, label %LeafBlock57, label %NodeBlock63

NodeBlock63:                                      ; preds = %NodeBlock65
  %Pivot64 = icmp slt i32 %conv3, 347
  br i1 %Pivot64, label %LeafBlock59, label %LeafBlock61

LeafBlock61:                                      ; preds = %NodeBlock63
  %SwitchLeaf62 = icmp eq i32 %conv3, 347
  br i1 %SwitchLeaf62, label %sw.bb10, label %for.inc

LeafBlock59:                                      ; preds = %NodeBlock63
  %SwitchLeaf60 = icmp eq i32 %conv3, 341
  br i1 %SwitchLeaf60, label %sw.bb16, label %for.inc

LeafBlock57:                                      ; preds = %NodeBlock65
  %SwitchLeaf58 = icmp eq i32 %conv3, 339
  br i1 %SwitchLeaf58, label %sw.bb13, label %for.inc

NodeBlock55:                                      ; preds = %NodeBlock79
  %Pivot56 = icmp slt i32 %conv3, 328
  br i1 %Pivot56, label %NodeBlock45, label %NodeBlock53

NodeBlock53:                                      ; preds = %NodeBlock55
  %Pivot54 = icmp slt i32 %conv3, 329
  br i1 %Pivot54, label %sw.bb, label %NodeBlock51

NodeBlock51:                                      ; preds = %NodeBlock53
  %Pivot52 = icmp slt i32 %conv3, 331
  br i1 %Pivot52, label %LeafBlock47, label %LeafBlock49

LeafBlock49:                                      ; preds = %NodeBlock51
  %.off = add i32 %conv3, -331
  %SwitchLeaf50 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf50, label %sw.bb13, label %for.inc

LeafBlock47:                                      ; preds = %NodeBlock51
  %SwitchLeaf48 = icmp eq i32 %conv3, 329
  br i1 %SwitchLeaf48, label %sw.bb15, label %for.inc

NodeBlock45:                                      ; preds = %NodeBlock55
  %Pivot46 = icmp slt i32 %conv3, 323
  br i1 %Pivot46, label %LeafBlock37, label %NodeBlock43

NodeBlock43:                                      ; preds = %NodeBlock45
  %Pivot44 = icmp slt i32 %conv3, 326
  br i1 %Pivot44, label %LeafBlock39, label %LeafBlock41

LeafBlock41:                                      ; preds = %NodeBlock43
  %SwitchLeaf42 = icmp eq i32 %conv3, 326
  br i1 %SwitchLeaf42, label %sw.bb10, label %for.inc

LeafBlock39:                                      ; preds = %NodeBlock43
  %SwitchLeaf40 = icmp eq i32 %conv3, 323
  br i1 %SwitchLeaf40, label %sw.bb13, label %for.inc

LeafBlock37:                                      ; preds = %NodeBlock45
  %SwitchLeaf38 = icmp eq i32 %conv3, 319
  br i1 %SwitchLeaf38, label %sw.bb7, label %for.inc

NodeBlock35:                                      ; preds = %NodeBlock81
  %Pivot36 = icmp slt i32 %conv3, 292
  br i1 %Pivot36, label %NodeBlock15, label %NodeBlock33

NodeBlock33:                                      ; preds = %NodeBlock35
  %Pivot34 = icmp slt i32 %conv3, 309
  br i1 %Pivot34, label %NodeBlock25, label %NodeBlock31

NodeBlock31:                                      ; preds = %NodeBlock33
  %Pivot32 = icmp slt i32 %conv3, 310
  br i1 %Pivot32, label %sw.bb12, label %NodeBlock29

NodeBlock29:                                      ; preds = %NodeBlock31
  %Pivot30 = icmp slt i32 %conv3, 311
  br i1 %Pivot30, label %sw.bb7, label %LeafBlock27

LeafBlock27:                                      ; preds = %NodeBlock29
  %SwitchLeaf28 = icmp eq i32 %conv3, 311
  br i1 %SwitchLeaf28, label %sw.bb13, label %for.inc

NodeBlock25:                                      ; preds = %NodeBlock33
  %Pivot26 = icmp slt i32 %conv3, 296
  br i1 %Pivot26, label %LeafBlock17, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %conv3, 305
  br i1 %Pivot24, label %LeafBlock19, label %LeafBlock21

LeafBlock21:                                      ; preds = %NodeBlock23
  %SwitchLeaf22 = icmp eq i32 %conv3, 305
  br i1 %SwitchLeaf22, label %sw.bb11, label %for.inc

LeafBlock19:                                      ; preds = %NodeBlock23
  %SwitchLeaf20 = icmp eq i32 %conv3, 296
  br i1 %SwitchLeaf20, label %sw.bb10, label %for.inc

LeafBlock17:                                      ; preds = %NodeBlock25
  %SwitchLeaf18 = icmp eq i32 %conv3, 292
  br i1 %SwitchLeaf18, label %sw.bb12, label %for.inc

NodeBlock15:                                      ; preds = %NodeBlock35
  %Pivot16 = icmp slt i32 %conv3, 285
  br i1 %Pivot16, label %NodeBlock5, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %conv3, 289
  br i1 %Pivot14, label %LeafBlock7, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %conv3, 290
  br i1 %Pivot12, label %sw.bb14, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock11
  %SwitchLeaf10 = icmp eq i32 %conv3, 290
  br i1 %SwitchLeaf10, label %sw.bb9, label %for.inc

LeafBlock7:                                       ; preds = %NodeBlock13
  %SwitchLeaf8 = icmp eq i32 %conv3, 285
  br i1 %SwitchLeaf8, label %sw.bb17, label %for.inc

NodeBlock5:                                       ; preds = %NodeBlock15
  %Pivot6 = icmp slt i32 %conv3, 277
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv3, 281
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv3, 281
  br i1 %SwitchLeaf4, label %sw.bb8, label %for.inc

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv3, 277
  br i1 %SwitchLeaf2, label %sw.bb7, label %for.inc

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %conv3, 261
  br i1 %SwitchLeaf, label %sw.bb, label %for.inc

sw.bb:                                            ; preds = %LeafBlock, %NodeBlock53
  call void @sony_nc_touchpad_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb7:                                           ; preds = %LeafBlock1, %NodeBlock29, %LeafBlock37
  call void @sony_nc_battery_care_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb8:                                           ; preds = %LeafBlock3, %LeafBlock67
  call void @sony_nc_lid_resume_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb9:                                           ; preds = %LeafBlock9
  call void @sony_nc_thermal_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb10:                                          ; preds = %LeafBlock19, %LeafBlock41, %LeafBlock61
  call void @sony_nc_gfx_switch_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb11:                                          ; preds = %LeafBlock21
  call void @sony_nc_highspeed_charging_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb12:                                          ; preds = %LeafBlock17, %NodeBlock31
  call void @sony_nc_rfkill_cleanup()
  br label %for.inc

sw.bb13:                                          ; preds = %LeafBlock27, %LeafBlock39, %LeafBlock49, %LeafBlock57, %LeafBlock69
  call void @sony_nc_kbd_backlight_cleanup(%struct.platform_device* %pd, i32 %conv3)
  br label %for.inc

sw.bb14:                                          ; preds = %NodeBlock11
  call void @sony_nc_lowbatt_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb15:                                          ; preds = %LeafBlock47
  call void @sony_nc_fanspeed_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb16:                                          ; preds = %LeafBlock59
  call void @sony_nc_usb_charge_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb17:                                          ; preds = %LeafBlock7
  call void @sony_nc_panelid_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb18:                                          ; preds = %LeafBlock71
  call void @sony_nc_smart_conn_cleanup(%struct.platform_device* %pd)
  br label %for.inc

for.inc:                                          ; preds = %sw.bb18, %sw.bb17, %sw.bb16, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock17, %LeafBlock19, %LeafBlock21, %LeafBlock27, %LeafBlock37, %LeafBlock39, %LeafBlock41, %LeafBlock47, %LeafBlock49, %LeafBlock57, %LeafBlock59, %LeafBlock61, %LeafBlock67, %LeafBlock69, %LeafBlock71, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @sony_nc_handles_cleanup(%struct.platform_device* %pd)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %7 = bitcast i32* %bitmask to i8*
  %8 = bitcast i32* %result to i8*
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_handles_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %tobool = icmp ne %struct.sony_nc_handles* %0, null
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %1 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %2 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %devattr = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %2, i32 0, i32 1
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %devattr)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %3 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %4 = bitcast %struct.sony_nc_handles* %3 to i8*
  call void @kfree(i8* %4)
  store %struct.sony_nc_handles* null, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_rfkill_cleanup() #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom
  %0 = load %struct.rfkill*, %struct.rfkill** %arrayidx, align 8, !tbaa !27
  %tobool = icmp ne %struct.rfkill* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %idxprom1 = sext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom1
  %1 = load %struct.rfkill*, %struct.rfkill** %arrayidx2, align 8, !tbaa !27
  call void @rfkill_unregister(%struct.rfkill* %1)
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom3
  %2 = load %struct.rfkill*, %struct.rfkill** %arrayidx4, align 8, !tbaa !27
  call void @rfkill_destroy(%struct.rfkill* %2)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare i32 @acpi_get_object_info(i8*, %struct.acpi_device_info**) #1

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_handles_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %len.0 = phi i64 [ 0, %entry ], [ %add, %for.body ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %len.0
  %sub = sub i64 4096, %len.0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %0, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %1 = load i16, i16* %arrayidx, align 2, !tbaa !153
  %conv2 = zext i16 %1 to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr, i64 %sub, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.87, i32 0, i32 0), i32 %conv2)
  %conv3 = sext i32 %call to i64
  %add = add nsw i64 %len.0, %conv3
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr, i64 %sub, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.88, i32 0, i32 0))
  %conv7 = sext i32 %call6 to i64
  %add8 = add nsw i64 %len.0, %conv7
  ret i64 %add8
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_call_snc_handle(i32 %handle, i32 %argument, i32* %result) #0 {
entry:
  %arg = alloca i32, align 4
  %0 = bitcast i32* %arg to i8*
  %call = call i32 @sony_find_snc_handle(i32 %handle)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %or = or i32 %call, %argument
  store i32 %or, i32* %arg, align 4, !tbaa !2
  %1 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call1 = call i32 @sony_nc_int_call(i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i32 0, i32 0), i32* %arg, i32* %result)
  %2 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then2, label %cleanup

if.then2:                                         ; preds = %if.end
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then2, %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %call1, %if.then2 ], [ %call1, %if.end ]
  %3 = bitcast i32* %arg to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_touchpad_setup(%struct.platform_device* %pd, i32 %handle) #0 {
entry:
  %call = call i8* @kzalloc(i64 56, i32 20971712)
  %0 = bitcast i8* %call to %struct.touchpad_control*
  store %struct.touchpad_control* %0, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %1 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %tobool = icmp ne %struct.touchpad_control* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %handle1 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %2, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !179
  %3 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %attr = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %3, i32 0, i32 0
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_touchpad_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %4 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %attr3 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %4, i32 0, i32 0
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.108, i32 0, i32 0), i8** %name, align 8, !tbaa !181
  %5 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %attr5 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %5, i32 0, i32 0
  %attr6 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr5, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr6, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !182
  %6 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %attr7 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %6, i32 0, i32 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr7, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_touchpad_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !183
  %7 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %attr8 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %7, i32 0, i32 0
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr8, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_touchpad_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !184
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %8 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %attr9 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %8, i32 0, i32 0
  %call10 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %attr9)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %cleanup

if.then12:                                        ; preds = %if.end
  %9 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %10 = bitcast %struct.touchpad_control* %9 to i8*
  call void @kfree(i8* %10)
  store %struct.touchpad_control* null, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %if.then12, %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %call10, %if.then12 ], [ %call10, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_battery_care_setup(%struct.platform_device* %pd, i32 %handle) #0 {
entry:
  %call = call i8* @kzalloc(i64 104, i32 20971712)
  %0 = bitcast i8* %call to %struct.battery_care_control*
  store %struct.battery_care_control* %0, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %1 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %tobool = icmp ne %struct.battery_care_control* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %handle1 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %2, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !185
  %3 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %3, i32 0, i32 0
  %arrayidx = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs, i64 0, i64 0
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_battery_care_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %4 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs2 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %4, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs2, i64 0, i64 0
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  store i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.109, i32 0, i32 0), i8** %name, align 8, !tbaa !187
  %5 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs5 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %5, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs5, i64 0, i64 0
  %attr7 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx6, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr7, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !188
  %6 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs8 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %6, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs8, i64 0, i64 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx9, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_battery_care_limit_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !189
  %7 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs10 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %7, i32 0, i32 0
  %arrayidx11 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs10, i64 0, i64 0
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx11, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_battery_care_limit_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !190
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %8 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs12 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %8, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs12, i64 0, i64 0
  %call14 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %arrayidx13)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %outkzalloc, label %if.end17

if.end17:                                         ; preds = %if.end
  %cmp = icmp eq i32 %handle, 277
  br i1 %cmp, label %cleanup, label %do.body20

do.body20:                                        ; preds = %if.end17
  %9 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs21 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %9, i32 0, i32 0
  %arrayidx22 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs21, i64 0, i64 1
  %attr23 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx22, i32 0, i32 0
  %key24 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr23, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_battery_care_setup.__key.110, %struct.lock_class_key** %key24, align 8, !tbaa !167
  %10 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs27 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %10, i32 0, i32 0
  %arrayidx28 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs27, i64 0, i64 1
  %attr29 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx28, i32 0, i32 0
  %name30 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr29, i32 0, i32 0
  store i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.111, i32 0, i32 0), i8** %name30, align 8, !tbaa !187
  %11 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs31 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %11, i32 0, i32 0
  %arrayidx32 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs31, i64 0, i64 1
  %attr33 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx32, i32 0, i32 0
  %mode34 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr33, i32 0, i32 1
  store i16 292, i16* %mode34, align 8, !tbaa !188
  %12 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs35 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %12, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs35, i64 0, i64 1
  %show37 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx36, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_battery_care_health_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show37, align 8, !tbaa !189
  %dev38 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %13 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs39 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %13, i32 0, i32 0
  %arrayidx40 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs39, i64 0, i64 1
  %call41 = call i32 @device_create_file(%struct.device* %dev38, %struct.device_attribute* %arrayidx40)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %outlimiter, label %cleanup

outlimiter:                                       ; preds = %do.body20
  %dev45 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %14 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs46 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %14, i32 0, i32 0
  %arrayidx47 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs46, i64 0, i64 0
  call void @device_remove_file(%struct.device* %dev45, %struct.device_attribute* %arrayidx47)
  br label %outkzalloc

outkzalloc:                                       ; preds = %outlimiter, %if.end
  %ret.0 = phi i32 [ %call41, %outlimiter ], [ %call14, %if.end ]
  %15 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %16 = bitcast %struct.battery_care_control* %15 to i8*
  call void @kfree(i8* %16)
  store %struct.battery_care_control* null, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %outkzalloc, %do.body20, %if.end17, %entry
  %retval.0 = phi i32 [ %ret.0, %outkzalloc ], [ -12, %entry ], [ 0, %if.end17 ], [ 0, %do.body20 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_lid_resume_setup(%struct.platform_device* %pd, i32 %handle) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i32 @sony_call_snc_handle(i32 %handle, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i8* @kzalloc(i64 152, i32 20971712)
  %1 = bitcast i8* %call1 to %struct.snc_lid_resume_control*
  store %struct.snc_lid_resume_control* %1, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %2 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %tobool2 = icmp ne %struct.snc_lid_resume_control* %2, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %3 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %3, 7
  %4 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %status = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %4, i32 0, i32 1
  store i32 %and, i32* %status, align 8, !tbaa !191
  %5 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %handle5 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %5, i32 0, i32 2
  store i32 %handle, i32* %handle5, align 4, !tbaa !193
  %6 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %6, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs, i64 0, i64 0
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_lid_resume_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %7 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs6 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %7, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs6, i64 0, i64 0
  %attr8 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx7, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr8, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.112, i32 0, i32 0), i8** %name, align 8, !tbaa !187
  %8 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs9 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %8, i32 0, i32 0
  %arrayidx10 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs9, i64 0, i64 0
  %attr11 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx10, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr11, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !188
  %9 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs12 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %9, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs12, i64 0, i64 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx13, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_lid_resume_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !189
  %10 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs14 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %10, i32 0, i32 0
  %arrayidx15 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs14, i64 0, i64 0
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx15, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_lid_resume_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !190
  %cmp = icmp eq i32 %handle, 281
  br i1 %cmp, label %do.body17, label %if.end59

do.body17:                                        ; preds = %if.end4
  %11 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs18 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %11, i32 0, i32 0
  %arrayidx19 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs18, i64 0, i64 1
  %attr20 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx19, i32 0, i32 0
  %key21 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr20, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_lid_resume_setup.__key.113, %struct.lock_class_key** %key21, align 8, !tbaa !167
  %12 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs24 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %12, i32 0, i32 0
  %arrayidx25 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs24, i64 0, i64 1
  %attr26 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx25, i32 0, i32 0
  %name27 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr26, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.114, i32 0, i32 0), i8** %name27, align 8, !tbaa !187
  %13 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs28 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %13, i32 0, i32 0
  %arrayidx29 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs28, i64 0, i64 1
  %attr30 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx29, i32 0, i32 0
  %mode31 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr30, i32 0, i32 1
  store i16 420, i16* %mode31, align 8, !tbaa !188
  %14 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs32 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %14, i32 0, i32 0
  %arrayidx33 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs32, i64 0, i64 1
  %show34 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx33, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_lid_resume_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show34, align 8, !tbaa !189
  %15 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs35 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %15, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs35, i64 0, i64 1
  %store37 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx36, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_lid_resume_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store37, align 8, !tbaa !190
  %16 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs39 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %16, i32 0, i32 0
  %arrayidx40 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs39, i64 0, i64 2
  %attr41 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx40, i32 0, i32 0
  %key42 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr41, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_lid_resume_setup.__key.115, %struct.lock_class_key** %key42, align 8, !tbaa !167
  %17 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs45 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %17, i32 0, i32 0
  %arrayidx46 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs45, i64 0, i64 2
  %attr47 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx46, i32 0, i32 0
  %name48 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr47, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.116, i32 0, i32 0), i8** %name48, align 8, !tbaa !187
  %18 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs49 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %18, i32 0, i32 0
  %arrayidx50 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs49, i64 0, i64 2
  %attr51 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx50, i32 0, i32 0
  %mode52 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr51, i32 0, i32 1
  store i16 420, i16* %mode52, align 8, !tbaa !188
  %19 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs53 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %19, i32 0, i32 0
  %arrayidx54 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs53, i64 0, i64 2
  %show55 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx54, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_lid_resume_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show55, align 8, !tbaa !189
  %20 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs56 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %20, i32 0, i32 0
  %arrayidx57 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs56, i64 0, i64 2
  %store58 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx57, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_lid_resume_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store58, align 8, !tbaa !190
  br label %if.end59

if.end59:                                         ; preds = %do.body17, %if.end4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end59
  %i.0 = phi i32 [ 0, %if.end59 ], [ %inc, %for.inc ]
  %cmp60 = icmp slt i32 %i.0, 3
  br i1 %cmp60, label %land.rhs, label %cleanup

land.rhs:                                         ; preds = %for.cond
  %21 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs61 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %21, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx62 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs61, i64 0, i64 %idxprom
  %attr63 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx62, i32 0, i32 0
  %name64 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr63, i32 0, i32 0
  %22 = load i8*, i8** %name64, align 8, !tbaa !187
  %tobool65 = icmp ne i8* %22, null
  br i1 %tobool65, label %for.body, label %cleanup

for.body:                                         ; preds = %land.rhs
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %23 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs66 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %23, i32 0, i32 0
  %idxprom67 = sext i32 %i.0 to i64
  %arrayidx68 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs66, i64 0, i64 %idxprom67
  %call69 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %arrayidx68)
  store i32 %call69, i32* %result, align 4, !tbaa !2
  %24 = load i32, i32* %result, align 4, !tbaa !2
  %tobool70 = icmp ne i32 %24, 0
  br i1 %tobool70, label %liderror, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

liderror:                                         ; preds = %for.body
  br label %for.cond73

for.cond73:                                       ; preds = %for.body75, %liderror
  %i.1.sink = phi i32 [ %dec81, %for.body75 ], [ %i.0, %liderror ]
  %dec81 = add nsw i32 %i.1.sink, -1
  %cmp74 = icmp sge i32 %dec81, 0
  br i1 %cmp74, label %for.body75, label %for.end82

for.body75:                                       ; preds = %for.cond73
  %dev76 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %25 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs77 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %25, i32 0, i32 0
  %idxprom78 = sext i32 %dec81 to i64
  %arrayidx79 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs77, i64 0, i64 %idxprom78
  call void @device_remove_file(%struct.device* %dev76, %struct.device_attribute* %arrayidx79)
  br label %for.cond73

for.end82:                                        ; preds = %for.cond73
  %26 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %27 = bitcast %struct.snc_lid_resume_control* %26 to i8*
  call void @kfree(i8* %27)
  store %struct.snc_lid_resume_control* null, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %28 = load i32, i32* %result, align 4, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %for.end82, %land.rhs, %for.cond, %if.end, %entry
  %retval.0 = phi i32 [ %28, %for.end82 ], [ -5, %entry ], [ -12, %if.end ], [ 0, %for.cond ], [ 0, %land.rhs ]
  %29 = bitcast i32* %result to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_thermal_setup(%struct.platform_device* %pd) #0 {
entry:
  %call = call i8* @kzalloc(i64 104, i32 20971712)
  %0 = bitcast i8* %call to %struct.snc_thermal_ctrl*
  store %struct.snc_thermal_ctrl* %0, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %1 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.snc_thermal_ctrl* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %profiles = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %2, i32 0, i32 1
  %call1 = call i32 @sony_call_snc_handle(i32 290, i32 0, i32* %profiles)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  call void (i8*, ...) @printk(i8* null)
  br label %outkzalloc

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @sony_nc_thermal_mode_get()
  %cmp = icmp slt i32 %call6, 0
  br i1 %cmp, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end5
  call void (i8*, ...) @printk(i8* null)
  br label %outkzalloc

if.end9:                                          ; preds = %if.end5
  %3 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %3, i32 0, i32 0
  store i32 %call6, i32* %mode, align 8, !tbaa !194
  %4 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %profiles_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %4, i32 0, i32 3
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_thermal_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %5 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %profiles_attr10 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %5, i32 0, i32 3
  %attr11 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr10, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr11, i32 0, i32 0
  store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.119, i32 0, i32 0), i8** %name, align 8, !tbaa !196
  %6 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %profiles_attr12 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %6, i32 0, i32 3
  %attr13 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr12, i32 0, i32 0
  %mode14 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr13, i32 0, i32 1
  store i16 292, i16* %mode14, align 8, !tbaa !197
  %7 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %profiles_attr15 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %7, i32 0, i32 3
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr15, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_thermal_profiles_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !198
  %8 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %8, i32 0, i32 2
  %attr17 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr, i32 0, i32 0
  %key18 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr17, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_thermal_setup.__key.120, %struct.lock_class_key** %key18, align 8, !tbaa !167
  %9 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode_attr21 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %9, i32 0, i32 2
  %attr22 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr21, i32 0, i32 0
  %name23 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr22, i32 0, i32 0
  store i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.121, i32 0, i32 0), i8** %name23, align 8, !tbaa !199
  %10 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode_attr24 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %10, i32 0, i32 2
  %attr25 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr24, i32 0, i32 0
  %mode26 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr25, i32 0, i32 1
  store i16 420, i16* %mode26, align 8, !tbaa !200
  %11 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode_attr27 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %11, i32 0, i32 2
  %show28 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr27, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_thermal_mode_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show28, align 8, !tbaa !201
  %12 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode_attr29 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %12, i32 0, i32 2
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr29, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_thermal_mode_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !202
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %13 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %profiles_attr30 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %13, i32 0, i32 3
  %call31 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %profiles_attr30)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %outkzalloc, label %if.end34

if.end34:                                         ; preds = %if.end9
  %dev35 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %14 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode_attr36 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %14, i32 0, i32 2
  %call37 = call i32 @device_create_file(%struct.device* %dev35, %struct.device_attribute* %mode_attr36)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %outprofiles, label %cleanup

outprofiles:                                      ; preds = %if.end34
  %dev41 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %15 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %profiles_attr42 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %15, i32 0, i32 3
  call void @device_remove_file(%struct.device* %dev41, %struct.device_attribute* %profiles_attr42)
  br label %outkzalloc

outkzalloc:                                       ; preds = %outprofiles, %if.end9, %if.then7, %if.then3
  %ret.0 = phi i32 [ %call1, %if.then3 ], [ %call6, %if.then7 ], [ %call37, %outprofiles ], [ %call31, %if.end9 ]
  %16 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %17 = bitcast %struct.snc_thermal_ctrl* %16 to i8*
  call void @kfree(i8* %17)
  store %struct.snc_thermal_ctrl* null, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %outkzalloc, %if.end34, %entry
  %retval.0 = phi i32 [ %ret.0, %outkzalloc ], [ -12, %entry ], [ 0, %if.end34 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_gfx_switch_setup(%struct.platform_device* %pd, i32 %handle) #0 {
entry:
  %call = call i8* @kzalloc(i64 56, i32 20971712)
  %0 = bitcast i8* %call to %struct.snc_gfx_switch_control*
  store %struct.snc_gfx_switch_control* %0, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %1 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %tobool = icmp ne %struct.snc_gfx_switch_control* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %handle1 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %2, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !203
  %3 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %attr = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %3, i32 0, i32 0
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_gfx_switch_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %4 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %attr3 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %4, i32 0, i32 0
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.127, i32 0, i32 0), i8** %name, align 8, !tbaa !205
  %5 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %attr5 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %5, i32 0, i32 0
  %attr6 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr5, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr6, i32 0, i32 1
  store i16 292, i16* %mode, align 8, !tbaa !206
  %6 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %attr7 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %6, i32 0, i32 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr7, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_gfx_switch_status_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !207
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %7 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %attr8 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %7, i32 0, i32 0
  %call9 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %attr8)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %gfxerror, label %cleanup

gfxerror:                                         ; preds = %if.end
  %8 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %9 = bitcast %struct.snc_gfx_switch_control* %8 to i8*
  call void @kfree(i8* %9)
  store %struct.snc_gfx_switch_control* null, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %gfxerror, %if.end, %entry
  %retval.0 = phi i32 [ %call9, %gfxerror ], [ -12, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_highspeed_charging_setup(%struct.platform_device* %pd) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i32 @sony_call_snc_handle(i32 305, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %1, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %call3 = call i8* @kzalloc(i64 48, i32 20971712)
  %2 = bitcast i8* %call3 to %struct.device_attribute*
  store %struct.device_attribute* %2, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %3 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %tobool4 = icmp ne %struct.device_attribute* %3, null
  br i1 %tobool4, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %4 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %4, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_highspeed_charging_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %5 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %attr7 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %5, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr7, i32 0, i32 0
  store i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.134, i32 0, i32 0), i8** %name, align 8, !tbaa !187
  %6 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %attr8 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %6, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr8, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !188
  %7 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %7, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_highspeed_charging_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !189
  %8 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %8, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_highspeed_charging_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !190
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %9 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %call9 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %9)
  store i32 %call9, i32* %result, align 4, !tbaa !2
  %10 = load i32, i32* %result, align 4, !tbaa !2
  %tobool10 = icmp ne i32 %10, 0
  br i1 %tobool10, label %if.then11, label %cleanup

if.then11:                                        ; preds = %do.body
  %11 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %12 = bitcast %struct.device_attribute* %11 to i8*
  call void @kfree(i8* %12)
  store %struct.device_attribute* null, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %13 = load i32, i32* %result, align 4, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.then11, %do.body, %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %13, %if.then11 ], [ -12, %if.end ], [ 0, %do.body ]
  %14 = bitcast i32* %result to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_rfkill_setup(%struct.acpi_device* %device, i32 %handle) #0 {
entry:
  %offset = alloca i64, align 8
  %buffer = alloca [32 x i8], align 16
  %0 = bitcast i64* %offset to i8*
  %1 = bitcast [32 x i8]* %buffer to i8*
  %2 = bitcast [32 x i8]* %buffer to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 32, i32 16, i1 false)
  %call = call i32 @sony_find_snc_handle(i32 %handle)
  %conv = sext i32 %call to i64
  store i64 %conv, i64* %offset, align 8, !tbaa !133
  store i32 %handle, i32* @sony_rfkill_handle, align 4, !tbaa !2
  %3 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i32 0, i32 0
  %call1 = call i32 @sony_nc_buffer_call(i8* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.135, i32 0, i32 0), i64* %offset, i8* %arraydecay, i64 32)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv3 = sext i32 %i.0 to i64
  %cmp4 = icmp ult i64 %conv3, 32
  br i1 %cmp4, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !31
  %conv6 = zext i8 %4 to i32
  %cmp7 = icmp eq i32 %conv6, 255
  br i1 %cmp7, label %cleanup, label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %idxprom17 = sext i32 %i.0 to i64
  %arrayidx18 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom17
  %6 = load i8, i8* %arrayidx18, align 1, !tbaa !31
  %conv19 = zext i8 %6 to i32
  %cmp20 = icmp ne i32 %conv19, 0
  %7 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 0), align 16
  %tobool22 = icmp ne %struct.rfkill* %7, null
  %or.cond = or i1 %cmp20, %tobool22
  br i1 %or.cond, label %if.end25, label %if.then23

if.then23:                                        ; preds = %do.end
  call void @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 0)
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %do.end
  %idxprom26 = sext i32 %i.0 to i64
  %arrayidx27 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom26
  %8 = load i8, i8* %arrayidx27, align 1, !tbaa !31
  %conv28 = zext i8 %8 to i32
  %cmp29 = icmp ne i32 %conv28, 16
  %9 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 1), align 8
  %tobool32 = icmp ne %struct.rfkill* %9, null
  %or.cond1 = or i1 %cmp29, %tobool32
  br i1 %or.cond1, label %if.end35, label %if.then33

if.then33:                                        ; preds = %if.end25
  call void @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 1)
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.end25
  %idxprom36 = sext i32 %i.0 to i64
  %arrayidx37 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom36
  %10 = load i8, i8* %arrayidx37, align 1, !tbaa !31
  %conv38 = zext i8 %10 to i32
  %and = and i32 240, %conv38
  %cmp39 = icmp eq i32 %and, 32
  br i1 %cmp39, label %land.lhs.true47, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end35
  %idxprom41 = sext i32 %i.0 to i64
  %arrayidx42 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom41
  %11 = load i8, i8* %arrayidx42, align 1, !tbaa !31
  %conv43 = zext i8 %11 to i32
  %and44 = and i32 240, %conv43
  %cmp45 = icmp ne i32 %and44, 80
  %12 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 2), align 16
  %tobool48 = icmp ne %struct.rfkill* %12, null
  %or.cond2 = or i1 %cmp45, %tobool48
  br i1 %or.cond2, label %if.end51, label %if.then49

land.lhs.true47:                                  ; preds = %if.end35
  %.old = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 2), align 16, !tbaa !27
  %tobool48.old = icmp ne %struct.rfkill* %.old, null
  br i1 %tobool48.old, label %if.end51, label %if.then49

if.then49:                                        ; preds = %land.lhs.true47, %lor.lhs.false
  call void @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 2)
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %land.lhs.true47, %lor.lhs.false
  %idxprom52 = sext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom52
  %13 = load i8, i8* %arrayidx53, align 1, !tbaa !31
  %conv54 = zext i8 %13 to i32
  %cmp55 = icmp ne i32 %conv54, 48
  %14 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 3), align 8
  %tobool58 = icmp ne %struct.rfkill* %14, null
  %or.cond4 = or i1 %cmp55, %tobool58
  br i1 %or.cond4, label %for.inc, label %if.then59

if.then59:                                        ; preds = %if.end51
  call void @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 3)
  br label %for.inc

for.inc:                                          ; preds = %if.then59, %if.end51
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond, %entry
  %retval.0 = phi i32 [ %call1, %entry ], [ 0, %for.cond ], [ 0, %for.body ]
  %15 = bitcast [32 x i8]* %buffer to i8*
  %16 = bitcast i64* %offset to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_kbd_backlight_setup(%struct.platform_device* %pd, i32 %handle) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %1 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %tobool = icmp ne %struct.kbd_backlight* %1, null
  br i1 %tobool, label %if.then, label %NodeBlock

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %handle, 339
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %handle, 339
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %handle, 311
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1
  %ctl_base.0 = phi i32 [ 16384, %sw.default ], [ 0, %LeafBlock1 ], [ 3072, %LeafBlock ]
  %probe_base.0 = phi i32 [ 256, %sw.default ], [ 0, %LeafBlock1 ], [ 2816, %LeafBlock ]
  %call3 = call i32 @sony_call_snc_handle(i32 %handle, i32 %probe_base.0, i32* %result)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %sw.epilog
  %cmp = icmp eq i32 %handle, 311
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end6
  %2 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %2, 2
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %lor.lhs.false, label %do.body

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end6
  %3 = load i32, i32* %result, align 4, !tbaa !2
  %and8 = and i32 %3, 1
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.end15, label %do.body

do.body:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %4 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool11 = icmp ne i32 %4, 0
  br i1 %tobool11, label %if.then12, label %cleanup

if.then12:                                        ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end15:                                         ; preds = %lor.lhs.false
  %call16 = call i8* @kzalloc(i64 120, i32 20971712)
  %5 = bitcast i8* %call16 to %struct.kbd_backlight*
  store %struct.kbd_backlight* %5, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %6 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %tobool17 = icmp ne %struct.kbd_backlight* %6, null
  br i1 %tobool17, label %if.end19, label %cleanup

if.end19:                                         ; preds = %if.end15
  %7 = load i32, i32* @kbd_backlight, align 4, !tbaa !2
  %8 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %8, i32 0, i32 2
  store i32 %7, i32* %mode, align 8, !tbaa !208
  %9 = load i32, i32* @kbd_backlight_timeout, align 4, !tbaa !2
  %10 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %10, i32 0, i32 3
  store i32 %9, i32* %timeout, align 4, !tbaa !210
  %11 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %handle20 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %11, i32 0, i32 0
  store i32 %handle, i32* %handle20, align 8, !tbaa !211
  %12 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %12, i32 0, i32 1
  store i32 %ctl_base.0, i32* %base, align 4, !tbaa !212
  %cmp21 = icmp ne i32 %handle, 339
  %conv = zext i1 %cmp21 to i32
  %13 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %has_timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %13, i32 0, i32 4
  store i32 %conv, i32* %has_timeout, align 8, !tbaa !213
  %14 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %14, i32 0, i32 5
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_kbd_backlight_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %15 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode_attr25 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %15, i32 0, i32 5
  %attr26 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr25, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr26, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.143, i32 0, i32 0), i8** %name, align 8, !tbaa !214
  %16 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode_attr27 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %16, i32 0, i32 5
  %attr28 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr27, i32 0, i32 0
  %mode29 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr28, i32 0, i32 1
  store i16 420, i16* %mode29, align 8, !tbaa !215
  %17 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode_attr30 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %17, i32 0, i32 5
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr30, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_kbd_backlight_mode_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !216
  %18 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode_attr31 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %18, i32 0, i32 5
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr31, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_kbd_backlight_mode_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !217
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %19 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode_attr32 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %19, i32 0, i32 5
  %call33 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %mode_attr32)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %outkzalloc, label %if.end36

if.end36:                                         ; preds = %if.end19
  %20 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode37 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %20, i32 0, i32 2
  %21 = load i32, i32* %mode37, align 8, !tbaa !208
  %conv38 = trunc i32 %21 to i8
  %call39 = call i64 @__sony_nc_kbd_backlight_mode_set(i8 zeroext %conv38)
  %22 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %has_timeout40 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %22, i32 0, i32 4
  %23 = load i32, i32* %has_timeout40, align 8, !tbaa !213
  %tobool41 = icmp ne i32 %23, 0
  br i1 %tobool41, label %do.body43, label %cleanup

do.body43:                                        ; preds = %if.end36
  %24 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %24, i32 0, i32 6
  %attr44 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr, i32 0, i32 0
  %key45 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr44, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_kbd_backlight_setup.__key.144, %struct.lock_class_key** %key45, align 8, !tbaa !167
  %25 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout_attr48 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %25, i32 0, i32 6
  %attr49 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr48, i32 0, i32 0
  %name50 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr49, i32 0, i32 0
  store i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.145, i32 0, i32 0), i8** %name50, align 8, !tbaa !218
  %26 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout_attr51 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %26, i32 0, i32 6
  %attr52 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr51, i32 0, i32 0
  %mode53 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr52, i32 0, i32 1
  store i16 420, i16* %mode53, align 8, !tbaa !219
  %27 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout_attr54 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %27, i32 0, i32 6
  %show55 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr54, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_kbd_backlight_timeout_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show55, align 8, !tbaa !220
  %28 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout_attr56 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %28, i32 0, i32 6
  %store57 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr56, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_kbd_backlight_timeout_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store57, align 8, !tbaa !221
  %dev58 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %29 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout_attr59 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %29, i32 0, i32 6
  %call60 = call i32 @device_create_file(%struct.device* %dev58, %struct.device_attribute* %timeout_attr59)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %outmode, label %if.end63

if.end63:                                         ; preds = %do.body43
  %30 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout64 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %30, i32 0, i32 3
  %31 = load i32, i32* %timeout64, align 4, !tbaa !210
  %conv65 = trunc i32 %31 to i8
  %call66 = call i32 @__sony_nc_kbd_backlight_timeout_set(i8 zeroext %conv65)
  br label %cleanup

outmode:                                          ; preds = %do.body43
  %dev68 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %32 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode_attr69 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %32, i32 0, i32 5
  call void @device_remove_file(%struct.device* %dev68, %struct.device_attribute* %mode_attr69)
  br label %outkzalloc

outkzalloc:                                       ; preds = %outmode, %if.end19
  %ret.0 = phi i32 [ %call60, %outmode ], [ %call33, %if.end19 ]
  %33 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %34 = bitcast %struct.kbd_backlight* %33 to i8*
  call void @kfree(i8* %34)
  store %struct.kbd_backlight* null, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %outkzalloc, %if.end63, %if.end36, %if.end15, %if.then12, %do.body, %sw.epilog, %if.then
  %retval.0 = phi i32 [ -16, %if.then ], [ %ret.0, %outkzalloc ], [ %call3, %sw.epilog ], [ 0, %if.then12 ], [ 0, %do.body ], [ -12, %if.end15 ], [ 0, %if.end63 ], [ 0, %if.end36 ]
  %35 = bitcast i32* %result to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_lowbatt_setup(%struct.platform_device* %pd) #0 {
entry:
  %call = call i8* @kzalloc(i64 48, i32 20971712)
  %0 = bitcast i8* %call to %struct.device_attribute*
  store %struct.device_attribute* %0, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %1 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.device_attribute* %1, null
  br i1 %tobool, label %do.body, label %cleanup

do.body:                                          ; preds = %entry
  %2 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %2, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_lowbatt_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %3 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %attr1 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr1, i32 0, i32 0
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.146, i32 0, i32 0), i8** %name, align 8, !tbaa !187
  %4 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %4, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !188
  %5 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %5, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_lowbatt_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !189
  %6 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %6, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_lowbatt_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !190
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %7 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %call3 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %7)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %do.body
  %8 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %9 = bitcast %struct.device_attribute* %8 to i8*
  call void @kfree(i8* %9)
  store %struct.device_attribute* null, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %do.body, %entry
  %retval.0 = phi i32 [ %call3, %if.then5 ], [ -12, %entry ], [ 0, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_fanspeed_setup(%struct.platform_device* %pd) #0 {
entry:
  %call = call i8* @kzalloc(i64 48, i32 20971712)
  %0 = bitcast i8* %call to %struct.device_attribute*
  store %struct.device_attribute* %0, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %1 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.device_attribute* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i8* @kzalloc(i64 48, i32 20971712)
  %2 = bitcast i8* %call1 to %struct.device_attribute*
  store %struct.device_attribute* %2, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %3 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %tobool2 = icmp ne %struct.device_attribute* %3, null
  br i1 %tobool2, label %do.body, label %out_hsf_handle_alloc

do.body:                                          ; preds = %if.end
  %4 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %4, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_fanspeed_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %5 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %attr5 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %5, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr5, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.71, i32 0, i32 0), i8** %name, align 8, !tbaa !187
  %6 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %attr6 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %6, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr6, i32 0, i32 1
  store i16 292, i16* %mode, align 8, !tbaa !188
  %7 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %7, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_fanspeed_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !189
  %8 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %8, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !190
  %9 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %attr8 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %9, i32 0, i32 0
  %key9 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr8, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_fanspeed_setup.__key.147, %struct.lock_class_key** %key9, align 8, !tbaa !167
  %10 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %attr12 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %10, i32 0, i32 0
  %name13 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr12, i32 0, i32 0
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.148, i32 0, i32 0), i8** %name13, align 8, !tbaa !187
  %11 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %attr14 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %11, i32 0, i32 0
  %mode15 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr14, i32 0, i32 1
  store i16 420, i16* %mode15, align 8, !tbaa !188
  %12 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %show16 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %12, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_hsfan_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show16, align 8, !tbaa !189
  %13 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %store17 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %13, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_hsfan_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store17, align 8, !tbaa !190
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %14 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %call18 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %14)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %out_fan_handle, label %if.end21

if.end21:                                         ; preds = %do.body
  %dev22 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %15 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %call23 = call i32 @device_create_file(%struct.device* %dev22, %struct.device_attribute* %15)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %out_hsf_handle, label %cleanup

out_hsf_handle:                                   ; preds = %if.end21
  %dev27 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %16 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  call void @device_remove_file(%struct.device* %dev27, %struct.device_attribute* %16)
  br label %out_fan_handle

out_fan_handle:                                   ; preds = %out_hsf_handle, %do.body
  %result.0 = phi i32 [ %call23, %out_hsf_handle ], [ %call18, %do.body ]
  %17 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %18 = bitcast %struct.device_attribute* %17 to i8*
  call void @kfree(i8* %18)
  store %struct.device_attribute* null, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  br label %out_hsf_handle_alloc

out_hsf_handle_alloc:                             ; preds = %out_fan_handle, %if.end
  %result.1 = phi i32 [ %result.0, %out_fan_handle ], [ -12, %if.end ]
  %19 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %20 = bitcast %struct.device_attribute* %19 to i8*
  call void @kfree(i8* %20)
  store %struct.device_attribute* null, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %out_hsf_handle_alloc, %if.end21, %entry
  %retval.0 = phi i32 [ %result.1, %out_hsf_handle_alloc ], [ -12, %entry ], [ 0, %if.end21 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_usb_charge_setup(%struct.platform_device* %pd) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i32 @sony_call_snc_handle(i32 341, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %1, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %call3 = call i8* @kzalloc(i64 48, i32 20971712)
  %2 = bitcast i8* %call3 to %struct.device_attribute*
  store %struct.device_attribute* %2, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %3 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %tobool4 = icmp ne %struct.device_attribute* %3, null
  br i1 %tobool4, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %4 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %4, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_usb_charge_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %5 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %attr7 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %5, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr7, i32 0, i32 0
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.150, i32 0, i32 0), i8** %name, align 8, !tbaa !187
  %6 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %attr8 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %6, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr8, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !188
  %7 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %7, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_usb_charge_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !189
  %8 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %8, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_usb_charge_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !190
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %9 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %call9 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %9)
  store i32 %call9, i32* %result, align 4, !tbaa !2
  %10 = load i32, i32* %result, align 4, !tbaa !2
  %tobool10 = icmp ne i32 %10, 0
  br i1 %tobool10, label %if.then11, label %cleanup

if.then11:                                        ; preds = %do.body
  %11 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %12 = bitcast %struct.device_attribute* %11 to i8*
  call void @kfree(i8* %12)
  store %struct.device_attribute* null, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %13 = load i32, i32* %result, align 4, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.then11, %do.body, %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %13, %if.then11 ], [ -12, %if.end ], [ 0, %do.body ]
  %14 = bitcast i32* %result to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_panelid_setup(%struct.platform_device* %pd) #0 {
entry:
  %call = call i8* @kzalloc(i64 48, i32 20971712)
  %0 = bitcast i8* %call to %struct.device_attribute*
  store %struct.device_attribute* %0, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %1 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.device_attribute* %1, null
  br i1 %tobool, label %do.body, label %cleanup

do.body:                                          ; preds = %entry
  %2 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %2, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_panelid_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %3 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %attr1 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr1, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.151, i32 0, i32 0), i8** %name, align 8, !tbaa !187
  %4 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %4, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 1
  store i16 292, i16* %mode, align 8, !tbaa !188
  %5 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %5, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_panelid_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !189
  %6 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %6, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !190
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %7 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %call3 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %7)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %do.body
  %8 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %9 = bitcast %struct.device_attribute* %8 to i8*
  call void @kfree(i8* %9)
  store %struct.device_attribute* null, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %do.body, %entry
  %retval.0 = phi i32 [ %call3, %if.then5 ], [ -12, %entry ], [ 0, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_smart_conn_setup(%struct.platform_device* %pd) #0 {
entry:
  %call = call i8* @kzalloc(i64 48, i32 20971712)
  %0 = bitcast i8* %call to %struct.device_attribute*
  store %struct.device_attribute* %0, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %1 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.device_attribute* %1, null
  br i1 %tobool, label %do.body, label %cleanup

do.body:                                          ; preds = %entry
  %2 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %2, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_smart_conn_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !167
  %3 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %attr1 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr1, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.152, i32 0, i32 0), i8** %name, align 8, !tbaa !187
  %4 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %4, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 1
  store i16 128, i16* %mode, align 8, !tbaa !188
  %5 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %5, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* null, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !189
  %6 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %6, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_smart_conn_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !190
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %7 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %call3 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %7)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %do.body
  %8 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %9 = bitcast %struct.device_attribute* %8 to i8*
  call void @kfree(i8* %9)
  store %struct.device_attribute* null, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %do.body, %entry
  %retval.0 = phi i32 [ %call3, %if.then5 ], [ -12, %entry ], [ 0, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_find_snc_handle(i32 %handle) #0 {
entry:
  %0 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %tobool = icmp ne %struct.sony_nc_handles* %0, null
  %tobool1 = icmp ne i32 %handle, 0
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %for.body, label %do.body9

for.body:                                         ; preds = %for.cond
  %1 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %1, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %2 = load i16, i16* %arrayidx, align 2, !tbaa !153
  %conv = zext i16 %2 to i32
  %cmp2 = icmp eq i32 %conv, %handle
  br i1 %cmp2, label %do.body, label %for.inc

do.body:                                          ; preds = %for.body
  %3 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool5 = icmp ne i32 %3, 0
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

do.body9:                                         ; preds = %for.cond
  %4 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool10 = icmp ne i32 %4, 0
  br i1 %tobool10, label %if.then11, label %cleanup

if.then11:                                        ; preds = %do.body9
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then11, %do.body9, %if.then6, %do.body, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ %i.0, %if.then6 ], [ %i.0, %do.body ], [ -22, %if.then11 ], [ -22, %do.body9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_touchpad_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %1 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %handle = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !179
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %3, 1
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot.ext = zext i1 %lnot to i32
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %lnot.ext)
  %conv = sext i32 %call2 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -22, %entry ]
  %4 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_touchpad_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %2, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %handle = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %3, i32 0, i32 1
  %4 = load i32, i32* %handle, align 8, !tbaa !179
  %5 = load i64, i64* %value, align 8, !tbaa !100
  %tobool4 = icmp ne i64 %5, 0
  %lnot = xor i1 %tobool4, true
  %lnot.ext = zext i1 %lnot to i32
  %shl = shl i32 %lnot.ext, 16
  %or = or i32 %shl, 256
  %call5 = call i32 @sony_call_snc_handle(i32 %4, i32 %or, i32* %result)
  %tobool6 = icmp ne i32 %call5, 0
  %.count = select i1 %tobool6, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end3 ]
  %6 = bitcast i64* %value to i8*
  %7 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_battery_care_limit_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %1 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !185
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %3, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %cond.true, label %NodeBlock3

cond.true:                                        ; preds = %if.end
  %4 = load i32, i32* %result, align 4, !tbaa !2
  %and2 = and i32 %4, 48
  %shr = lshr i32 %and2, 4
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %cond.true, %if.end
  %cond = phi i32 [ %shr, %cond.true ], [ 0, %if.end ]
  %Pivot4 = icmp slt i32 %cond, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cond, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cond, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cond, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1, %NodeBlock
  %status.0 = phi i32 [ 0, %sw.default ], [ 80, %LeafBlock ], [ 50, %NodeBlock ], [ 100, %LeafBlock1 ]
  %call5 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %status.0)
  %conv = sext i32 %call5 to i64
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %entry
  %retval.0 = phi i64 [ %conv, %sw.epilog ], [ -5, %entry ]
  %5 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_battery_care_limit_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %2 = load i64, i64* %value, align 8, !tbaa !100
  %cmp3 = icmp ugt i64 %2, 0
  br i1 %cmp3, label %if.then4, label %if.end21

if.then4:                                         ; preds = %if.end2
  %3 = load i64, i64* %value, align 8, !tbaa !100
  %cmp5 = icmp ule i64 %3, 50
  br i1 %cmp5, label %if.end15, label %if.else

if.else:                                          ; preds = %if.then4
  %4 = load i64, i64* %value, align 8, !tbaa !100
  %cmp7 = icmp ule i64 %4, 80
  br i1 %cmp7, label %if.end15, label %if.else9

if.else9:                                         ; preds = %if.else
  %5 = load i64, i64* %value, align 8, !tbaa !100
  %cmp10 = icmp ule i64 %5, 100
  br i1 %cmp10, label %if.end15, label %cleanup

if.end15:                                         ; preds = %if.else9, %if.else, %if.then4
  %cmd.1 = phi i32 [ 32, %if.then4 ], [ 16, %if.else ], [ 48, %if.else9 ]
  %6 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %6, i32 0, i32 1
  %7 = load i32, i32* %handle, align 8, !tbaa !185
  %cmp16 = icmp ne i32 %7, 319
  %shl = shl i32 %cmd.1, 2
  %or = or i32 %cmd.1, %shl
  %cmd.2 = select i1 %cmp16, i32 %or, i32 %cmd.1
  %or19 = or i32 %cmd.2, 1
  %shl20 = shl i32 %or19, 16
  br label %if.end21

if.end21:                                         ; preds = %if.end15, %if.end2
  %cmd.3 = phi i32 [ %shl20, %if.end15 ], [ 0, %if.end2 ]
  %8 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %handle22 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %8, i32 0, i32 1
  %9 = load i32, i32* %handle22, align 8, !tbaa !185
  %or23 = or i32 %cmd.3, 256
  %call24 = call i32 @sony_call_snc_handle(i32 %9, i32 %or23, i32* %result)
  %tobool25 = icmp ne i32 %call24, 0
  %.count = select i1 %tobool25, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %if.else9, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ -22, %if.else9 ], [ %.count, %if.end21 ]
  %10 = bitcast i64* %value to i8*
  %11 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_battery_care_health_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %health = alloca i32, align 4
  %0 = bitcast i32* %health to i8*
  %1 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !185
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 512, i32* %health)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %health, align 4, !tbaa !2
  %and = and i32 %3, 255
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  %4 = bitcast i32* %health to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_lid_resume_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %pos.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %cmp = icmp ult i32 %pos.0, 3
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %0 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %0, i32 0, i32 0
  %idxprom = zext i32 %pos.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs, i64 0, i64 %idxprom
  %attr1 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx, i32 0, i32 0
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %cmp3 = icmp eq %struct.attribute* %attr1, %attr2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %1 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %status = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %1, i32 0, i32 1
  %2 = load i32, i32* %status, align 8, !tbaa !191
  %shr = lshr i32 %2, %pos.0
  %and = and i32 %shr, 1
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call to i64
  br label %cleanup

if.end:                                           ; preds = %while.body
  %inc = add i32 %pos.0, 1
  br label %while.cond

cleanup:                                          ; preds = %if.then, %while.cond
  %retval.0 = phi i64 [ %conv, %if.then ], [ -22, %while.cond ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_lid_resume_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %2, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end9, %if.end3
  %pos.0 = phi i32 [ 0, %if.end3 ], [ %inc, %if.end9 ]
  %cmp4 = icmp ult i32 %pos.0, 3
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %3, i32 0, i32 0
  %idxprom = zext i32 %pos.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs, i64 0, i64 %idxprom
  %attr5 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx, i32 0, i32 0
  %attr6 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %cmp7 = icmp eq %struct.attribute* %attr5, %attr6
  br i1 %cmp7, label %while.end, label %if.end9

if.end9:                                          ; preds = %while.body
  %inc = add i32 %pos.0, 1
  br label %while.cond

while.end:                                        ; preds = %while.body, %while.cond
  %cmp10 = icmp eq i32 %pos.0, 3
  br i1 %cmp10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %while.end
  %4 = load i64, i64* %value, align 8, !tbaa !100
  %tobool13 = icmp ne i64 %4, 0
  %5 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %status = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %5, i32 0, i32 1
  %6 = load i32, i32* %status, align 8, !tbaa !191
  %shl = shl i32 1, %pos.0
  br i1 %tobool13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end12
  %or = or i32 %6, %shl
  %conv = zext i32 %or to i64
  store i64 %conv, i64* %value, align 8, !tbaa !100
  br label %if.end18

if.else:                                          ; preds = %if.end12
  %neg = xor i32 %shl, -1
  %and = and i32 %6, %neg
  %conv17 = zext i32 %and to i64
  store i64 %conv17, i64* %value, align 8, !tbaa !100
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then14
  %7 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %handle = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %7, i32 0, i32 2
  %8 = load i32, i32* %handle, align 4, !tbaa !193
  %9 = load i64, i64* %value, align 8, !tbaa !100
  %shl19 = shl i64 %9, 16
  %or20 = or i64 %shl19, 256
  %conv21 = trunc i64 %or20 to i32
  %call22 = call i32 @sony_call_snc_handle(i32 %8, i32 %conv21, i32* %result)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %cleanup, label %if.end25

if.end25:                                         ; preds = %if.end18
  %10 = load i64, i64* %value, align 8, !tbaa !100
  %conv26 = trunc i64 %10 to i32
  %11 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %status27 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %11, i32 0, i32 1
  store i32 %conv26, i32* %status27, align 8, !tbaa !191
  br label %cleanup

cleanup:                                          ; preds = %if.end25, %if.end18, %while.end, %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end25 ], [ -22, %entry ], [ -22, %if.end ], [ -22, %while.end ], [ -5, %if.end18 ]
  %12 = bitcast i64* %value to i8*
  %13 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_thermal_mode_get() #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i32 @sony_call_snc_handle(i32 290, i32 256, i32* %result)
  %tobool = icmp ne i32 %call, 0
  %1 = load i32, i32* %result, align 4
  %and = and i32 %1, 255
  %retval.0 = select i1 %tobool, i32 -5, i32 %and
  %2 = bitcast i32* %result to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_thermal_profiles_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %cnt.0 = phi i16 [ 0, %entry ], [ %inc, %for.inc ]
  %idx.0 = phi i64 [ 0, %entry ], [ %idx.1, %for.inc ]
  %conv = sext i16 %cnt.0 to i32
  %cmp = icmp slt i32 %conv, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %tobool = icmp ne i16 %cnt.0, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %for.body
  %0 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %profiles = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %0, i32 0, i32 1
  %1 = load i32, i32* %profiles, align 4, !tbaa !222
  %conv2 = sext i16 %cnt.0 to i32
  %and = and i32 %1, %conv2
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then, label %for.inc

if.then:                                          ; preds = %lor.lhs.false, %for.body
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %idx.0
  %sub = sub i64 4096, %idx.0
  %idxprom = sext i16 %cnt.0 to i64
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @snc_thermal_profiles, i64 0, i64 %idxprom
  %2 = load i8*, i8** %arrayidx, align 8, !tbaa !27
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr, i64 %sub, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.122, i32 0, i32 0), i8* %2)
  %conv4 = sext i32 %call to i64
  %add = add i64 %idx.0, %conv4
  br label %for.inc

for.inc:                                          ; preds = %if.then, %lor.lhs.false
  %idx.1 = phi i64 [ %add, %if.then ], [ %idx.0, %lor.lhs.false ]
  %inc = add i16 %cnt.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %add.ptr5 = getelementptr inbounds i8, i8* %buffer, i64 %idx.0
  %sub6 = sub i64 4096, %idx.0
  %call7 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr5, i64 %sub6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.88, i32 0, i32 0))
  %conv8 = sext i32 %call7 to i64
  %add9 = add i64 %idx.0, %conv8
  ret i64 %add9
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_thermal_mode_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %call = call i32 @sony_nc_thermal_mode_get()
  %cmp = icmp slt i32 %call, 0
  %conv = sext i32 %call to i64
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @snc_thermal_profiles, i64 0, i64 %conv
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !27
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i32 0, i32 0), i8* %0)
  %conv2 = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv2, %if.end ], [ %conv, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_thermal_mode_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %cmp = icmp eq i64 %count, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sub = sub i64 %count, 1
  %arrayidx = getelementptr inbounds i8, i8* %buffer, i64 %sub
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !31
  %conv = sext i8 %0 to i32
  %cmp1 = icmp eq i32 %conv, 10
  %dec = add i64 %count, -1
  %dec.count = select i1 %cmp1, i64 %dec, i64 %count
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %cmd.0 = phi i16 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv5 = zext i16 %cmd.0 to i32
  %cmp6 = icmp slt i32 %conv5, 3
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i16 %cmd.0 to i64
  %arrayidx8 = getelementptr inbounds [3 x i8*], [3 x i8*]* @snc_thermal_profiles, i64 0, i64 %idxprom
  %1 = load i8*, i8** %arrayidx8, align 8, !tbaa !27
  %call = call i32 @strncmp(i8* %buffer, i8* %1, i64 %dec.count)
  %cmp9 = icmp eq i32 %call, 0
  br i1 %cmp9, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add i16 %cmd.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %call13 = call i32 @sony_nc_thermal_mode_set(i16 zeroext %cmd.0)
  %tobool = icmp ne i32 %call13, 0
  %.count = select i1 %tobool, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ %.count, %for.end ]
  ret i64 %retval.0
}

declare i32 @strncmp(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_thermal_mode_set(i16 zeroext %mode) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %conv = zext i16 %mode to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %profiles = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %1, i32 0, i32 1
  %2 = load i32, i32* %profiles, align 4, !tbaa !222
  %conv1 = zext i16 %mode to i32
  %and = and i32 %2, %conv1
  %tobool2 = icmp eq i32 %and, 0
  %conv3 = zext i16 %mode to i32
  %cmp = icmp sge i32 %conv3, 3
  %or.cond = or i1 %tobool2, %cmp
  br i1 %or.cond, label %cleanup, label %if.end

lor.lhs.false:                                    ; preds = %entry
  %.old = zext i16 %mode to i32
  %cmp.old = icmp sge i32 %.old, 3
  br i1 %cmp.old, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %conv5 = zext i16 %mode to i32
  %shl = shl i32 %conv5, 16
  %or = or i32 %shl, 512
  %call = call i32 @sony_call_snc_handle(i32 290, i32 %or, i32* %result)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end
  %conv9 = zext i16 %mode to i32
  %3 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode10 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %3, i32 0, i32 0
  store i32 %conv9, i32* %mode10, align 8, !tbaa !194
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end, %lor.lhs.false, %land.lhs.true
  %retval.0 = phi i32 [ 0, %if.end8 ], [ -22, %land.lhs.true ], [ -22, %lor.lhs.false ], [ -5, %if.end ]
  %4 = bitcast i32* %result to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_gfx_switch_status_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %call = call i32 @__sony_nc_gfx_switch_status_get()
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  switch i32 %call, label %cond.false6 [
    i32 0, label %cond.end10
    i32 1, label %cond.end
  ]

cond.false6:                                      ; preds = %if.end
  %cmp7 = icmp eq i32 %call, 2
  %cond = select i1 %cmp7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.130, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.131, i32 0, i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false6, %if.end
  %cond9 = phi i8* [ %cond, %cond.false6 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.129, i32 0, i32 0), %if.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end, %if.end
  %cond11 = phi i8* [ %cond9, %cond.end ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.128, i32 0, i32 0), %if.end ]
  %call12 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i32 0, i32 0), i8* %cond11)
  br label %cleanup

cleanup:                                          ; preds = %cond.end10, %entry
  %call12.sink = phi i32 [ %call12, %cond.end10 ], [ %call, %entry ]
  %conv13 = sext i32 %call12.sink to i64
  ret i64 %conv13
}

; Function Attrs: nounwind uwtable
define internal i32 @__sony_nc_gfx_switch_status_get() #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %1 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %handle = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !203
  %3 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %handle1 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %3, i32 0, i32 1
  %4 = load i32, i32* %handle1, align 8, !tbaa !203
  %cmp = icmp eq i32 %4, 347
  %cond = select i1 %cmp, i32 0, i32 256
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 %cond, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %5 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %handle2 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %5, i32 0, i32 1
  %6 = load i32, i32* %handle2, align 8, !tbaa !203
  %Pivot6 = icmp slt i32 %6, 326
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %6, 347
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %6, 347
  br i1 %SwitchLeaf4, label %sw.bb5, label %cleanup

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %6, 326
  br i1 %SwitchLeaf2, label %sw.bb, label %cleanup

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %6, 296
  br i1 %SwitchLeaf, label %do.body, label %cleanup

sw.bb:                                            ; preds = %LeafBlock1
  %7 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %7, 1
  %tobool3 = icmp ne i32 %and, 0
  %cond4 = select i1 %tobool3, i32 0, i32 1
  br label %cleanup

sw.bb5:                                           ; preds = %LeafBlock3
  %8 = load i32, i32* %result, align 4, !tbaa !2
  %and6 = and i32 %8, 1
  %tobool7 = icmp ne i32 %and6, 0
  %cond8 = select i1 %tobool7, i32 1, i32 0
  br label %cleanup

do.body:                                          ; preds = %LeafBlock
  %9 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool10 = icmp ne i32 %9, 0
  br i1 %tobool10, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %10 = load i32, i32* %result, align 4, !tbaa !2
  %and14 = and i32 %10, 128
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %cleanup, label %cond.false

cond.false:                                       ; preds = %do.end
  %11 = load i32, i32* %result, align 4, !tbaa !2
  %and16 = and i32 %11, 2
  %tobool17 = icmp ne i32 %and16, 0
  %cond18 = select i1 %tobool17, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %cond.false, %do.end, %sw.bb5, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %entry
  %retval.0 = phi i32 [ %cond4, %sw.bb ], [ %cond8, %sw.bb5 ], [ -5, %entry ], [ %cond18, %cond.false ], [ 2, %do.end ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock3 ]
  %12 = bitcast i32* %result to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_highspeed_charging_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i32 @sony_call_snc_handle(i32 305, i32 256, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %1, 1
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  %2 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_highspeed_charging_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %2, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = load i64, i64* %value, align 8, !tbaa !100
  %shl = shl i64 %3, 16
  %or = or i64 %shl, 512
  %conv = trunc i64 %or to i32
  %call4 = call i32 @sony_call_snc_handle(i32 305, i32 %conv, i32* %result)
  %tobool5 = icmp ne i32 %call4, 0
  %.count = select i1 %tobool5, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end3 ]
  %4 = bitcast i64* %value to i8*
  %5 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_buffer_call(i8* %handle, i8* %name, i64* %value, i8* %buffer, i64 %buflen) #0 {
entry:
  %call = call %union.acpi_object* @__call_snc_method(i8* %handle, i8* %name, i64* %value)
  %tobool = icmp ne %union.acpi_object* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %type = bitcast %union.acpi_object* %call to i32*
  %0 = load i32, i32* %type, align 8, !tbaa !31
  %cmp = icmp eq i32 %0, 3
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %buffer2 = bitcast %union.acpi_object* %call to %struct.anon.60*
  %length = getelementptr inbounds %struct.anon.60, %struct.anon.60* %buffer2, i32 0, i32 1
  %1 = load i32, i32* %length, align 4, !tbaa !31
  %conv = zext i32 %1 to i64
  %cmp3 = icmp ugt i64 %buflen, %conv
  br i1 %cmp3, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then1
  %buffer5 = bitcast %union.acpi_object* %call to %struct.anon.60*
  %length6 = getelementptr inbounds %struct.anon.60, %struct.anon.60* %buffer5, i32 0, i32 1
  %2 = load i32, i32* %length6, align 4, !tbaa !31
  %conv7 = zext i32 %2 to i64
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.then1
  %cond = phi i64 [ %conv7, %cond.true ], [ %buflen, %if.then1 ]
  %buffer8 = bitcast %union.acpi_object* %call to %struct.anon.60*
  %pointer = getelementptr inbounds %struct.anon.60, %struct.anon.60* %buffer8, i32 0, i32 2
  %3 = load i8*, i8** %pointer, align 8, !tbaa !31
  %call9 = call i8* @__memcpy(i8* %buffer, i8* %3, i64 %cond)
  br label %if.end26

if.else:                                          ; preds = %if.end
  %type10 = bitcast %union.acpi_object* %call to i32*
  %4 = load i32, i32* %type10, align 8, !tbaa !31
  %cmp11 = icmp eq i32 %4, 1
  br i1 %cmp11, label %if.then13, label %if.else22

if.then13:                                        ; preds = %if.else
  %cmp14 = icmp ugt i64 %buflen, 8
  %.buflen = select i1 %cmp14, i64 8, i64 %buflen
  %integer = bitcast %union.acpi_object* %call to %struct.anon.58*
  %value20 = getelementptr inbounds %struct.anon.58, %struct.anon.58* %integer, i32 0, i32 1
  %5 = bitcast i64* %value20 to i8*
  %call21 = call i8* @__memcpy(i8* %buffer, i8* %5, i64 %.buflen)
  br label %if.end26

if.else22:                                        ; preds = %if.else
  call void (i8*, ...) @printk(i8* null)
  br label %if.end26

if.end26:                                         ; preds = %if.else22, %if.then13, %cond.end
  %ret.1 = phi i32 [ 0, %cond.end ], [ 0, %if.then13 ], [ -22, %if.else22 ]
  %6 = bitcast %union.acpi_object* %call to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %entry
  %retval.0 = phi i32 [ %ret.1, %if.end26 ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 %nc_type) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %Pivot6 = icmp slt i32 %nc_type, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %nc_type, 3
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %nc_type, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %cleanup

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %nc_type, 1
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %nc_type, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3
  %type.0 = phi i32 [ 1, %LeafBlock ], [ 2, %NodeBlock ], [ 5, %NodeBlock3 ], [ 4, %LeafBlock1 ]
  %name.0 = phi i8* [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.137, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([15 x i8], [15 x i8]* @.str.138, i32 0, i32 0), %NodeBlock ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.139, i32 0, i32 0), %NodeBlock3 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.140, i32 0, i32 0), %LeafBlock1 ]
  %dev = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 21
  %conv = zext i32 %nc_type to i64
  %1 = inttoptr i64 %conv to i8*
  %call = call %struct.rfkill* @rfkill_alloc(i8* %name.0, %struct.device* %dev, i32 %type.0, %struct.rfkill_ops* @sony_rfkill_ops, i8* %1)
  %tobool = icmp ne %struct.rfkill* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %sw.epilog
  %2 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !2
  %call4 = call i32 @sony_call_snc_handle(i32 %2, i32 512, i32* %result)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  call void @rfkill_destroy(%struct.rfkill* %call)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %3 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %3, 1
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %frombool = zext i1 %lnot to i8
  %4 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !2
  %idxprom = zext i32 %nc_type to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @sony_rfkill_address, i64 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %call9 = call i32 @sony_call_snc_handle(i32 %4, i32 %5, i32* %result)
  %cmp10 = icmp slt i32 %call9, 0
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end7
  call void @rfkill_destroy(%struct.rfkill* %call)
  br label %cleanup

if.end13:                                         ; preds = %if.end7
  %6 = load i32, i32* %result, align 4, !tbaa !2
  %and14 = and i32 %6, 2
  %tobool15 = icmp ne i32 %and14, 0
  %lnot16 = xor i1 %tobool15, true
  %frombool17 = zext i1 %lnot16 to i8
  %tobool18 = trunc i8 %frombool17 to i1
  call void @rfkill_init_sw_state(%struct.rfkill* %call, i1 zeroext %tobool18)
  %tobool19 = trunc i8 %frombool to i1
  %call20 = call zeroext i1 @rfkill_set_hw_state(%struct.rfkill* %call, i1 zeroext %tobool19)
  %call21 = call i32 @rfkill_register(%struct.rfkill* %call)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end13
  call void @rfkill_destroy(%struct.rfkill* %call)
  br label %cleanup

if.end24:                                         ; preds = %if.end13
  %idxprom25 = zext i32 %nc_type to i64
  %arrayidx26 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom25
  store %struct.rfkill* %call, %struct.rfkill** %arrayidx26, align 8, !tbaa !27
  br label %cleanup

cleanup:                                          ; preds = %if.end24, %if.then23, %if.then12, %if.then6, %sw.epilog, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ -1, %if.then6 ], [ -1, %if.then12 ], [ %call21, %if.then23 ], [ %call21, %if.end24 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -12, %sw.epilog ]
  %7 = bitcast i32* %result to i8*
  ret void
}

declare %struct.rfkill* @rfkill_alloc(i8*, %struct.device*, i32, %struct.rfkill_ops*, i8*) #1

declare void @rfkill_destroy(%struct.rfkill*) #1

declare void @rfkill_init_sw_state(%struct.rfkill*, i1 zeroext) #1

declare zeroext i1 @rfkill_set_hw_state(%struct.rfkill*, i1 zeroext) #1

declare i32 @rfkill_register(%struct.rfkill*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_rfkill_set(i8* %data, i1 zeroext %blocked) #0 {
entry:
  %result = alloca i32, align 4
  %frombool = zext i1 %blocked to i8
  %0 = bitcast i32* %result to i8*
  %1 = ptrtoint i8* %data to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @sony_rfkill_address, i64 0, i64 %1
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %add = add nsw i32 %2, 256
  %tobool = trunc i8 %frombool to i1
  %or = or i32 %add, 458752
  %add.or = select i1 %tobool, i32 %add, i32 %or
  %3 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !2
  %call = call i32 @sony_call_snc_handle(i32 %3, i32 %add.or, i32* %result)
  %4 = bitcast i32* %result to i8*
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_mode_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %0, i32 0, i32 2
  %1 = load i32, i32* %mode, align 8, !tbaa !208
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %1)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_mode_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %value = alloca i64, align 8
  %0 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %1 = load i64, i64* %value, align 8, !tbaa !100
  %conv = trunc i64 %1 to i8
  %call3 = call i64 @__sony_nc_kbd_backlight_mode_set(i8 zeroext %conv)
  %conv4 = trunc i64 %call3 to i32
  %cmp5 = icmp slt i32 %conv4, 0
  %conv8 = sext i32 %conv4 to i64
  %conv8.count = select i1 %cmp5, i64 %conv8, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %conv8.count, %if.end2 ]
  %2 = bitcast i64* %value to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @__sony_nc_kbd_backlight_mode_set(i8 zeroext %value) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %conv = zext i8 %value to i32
  %cmp = icmp sgt i32 %conv, 2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %handle = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %1, i32 0, i32 0
  %2 = load i32, i32* %handle, align 8, !tbaa !211
  %conv2 = zext i8 %value to i32
  %shl = shl i32 %conv2, 16
  %3 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %3, i32 0, i32 1
  %4 = load i32, i32* %base, align 4, !tbaa !212
  %or = or i32 %shl, %4
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 %or, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %conv5 = zext i8 %value to i32
  %cmp6 = icmp ne i32 %conv5, 1
  br i1 %cmp6, label %if.then8, label %if.end15

if.then8:                                         ; preds = %if.end4
  %5 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %handle9 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %5, i32 0, i32 0
  %6 = load i32, i32* %handle9, align 8, !tbaa !211
  %conv10 = zext i8 %value to i32
  %shl11 = shl i32 %conv10, 15
  %7 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %base12 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %7, i32 0, i32 1
  %8 = load i32, i32* %base12, align 4, !tbaa !212
  %add = add i32 %8, 256
  %or13 = or i32 %shl11, %add
  %call14 = call i32 @sony_call_snc_handle(i32 %6, i32 %or13, i32* %result)
  br label %if.end15

if.end15:                                         ; preds = %if.then8, %if.end4
  %conv16 = zext i8 %value to i32
  %9 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %9, i32 0, i32 2
  store i32 %conv16, i32* %mode, align 8, !tbaa !208
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.end, %entry
  %retval.0 = phi i64 [ 0, %if.end15 ], [ -22, %entry ], [ -5, %if.end ]
  %10 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_timeout_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %0, i32 0, i32 3
  %1 = load i32, i32* %timeout, align 4, !tbaa !210
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %1)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_timeout_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %value = alloca i64, align 8
  %0 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %1 = load i64, i64* %value, align 8, !tbaa !100
  %conv = trunc i64 %1 to i8
  %call3 = call i32 @__sony_nc_kbd_backlight_timeout_set(i8 zeroext %conv)
  %cmp4 = icmp slt i32 %call3, 0
  %conv7 = sext i32 %call3 to i64
  %conv7.count = select i1 %cmp4, i64 %conv7, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %conv7.count, %if.end2 ]
  %2 = bitcast i64* %value to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @__sony_nc_kbd_backlight_timeout_set(i8 zeroext %value) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %conv = zext i8 %value to i32
  %cmp = icmp sgt i32 %conv, 3
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %handle = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %1, i32 0, i32 0
  %2 = load i32, i32* %handle, align 8, !tbaa !211
  %conv2 = zext i8 %value to i32
  %shl = shl i32 %conv2, 16
  %3 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %3, i32 0, i32 1
  %4 = load i32, i32* %base, align 4, !tbaa !212
  %add = add i32 %4, 512
  %or = or i32 %shl, %add
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 %or, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %conv5 = zext i8 %value to i32
  %5 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %5, i32 0, i32 3
  store i32 %conv5, i32* %timeout, align 4, !tbaa !210
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -22, %entry ], [ -5, %if.end ]
  %6 = bitcast i32* %result to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_lowbatt_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i32 @sony_call_snc_handle(i32 289, i32 512, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %1, 1
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  %2 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_lowbatt_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %2, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = load i64, i64* %value, align 8, !tbaa !100
  %shl = shl i64 %3, 8
  %conv = trunc i64 %shl to i32
  %call4 = call i32 @sony_call_snc_handle(i32 289, i32 %conv, i32* %result)
  %tobool5 = icmp ne i32 %call4, 0
  %.count = select i1 %tobool5, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end3 ]
  %4 = bitcast i64* %value to i8*
  %5 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_fanspeed_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i32 @sony_call_snc_handle(i32 329, i32 768, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %1, 255
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  %2 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_hsfan_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i32 @sony_call_snc_handle(i32 329, i32 256, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %1, 1
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  %2 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_hsfan_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %2, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = load i64, i64* %value, align 8, !tbaa !100
  %shl = shl i64 %3, 16
  %or = or i64 %shl, 512
  %conv = trunc i64 %or to i32
  %call4 = call i32 @sony_call_snc_handle(i32 329, i32 %conv, i32* %result)
  %tobool5 = icmp ne i32 %call4, 0
  %.count = select i1 %tobool5, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end3 ]
  %4 = bitcast i64* %value to i8*
  %5 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_usb_charge_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i32 @sony_call_snc_handle(i32 341, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %1, 1
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  %2 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_usb_charge_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %2, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = load i64, i64* %value, align 8, !tbaa !100
  %shl = shl i64 %3, 16
  %or = or i64 %shl, 256
  %conv = trunc i64 %or to i32
  %call4 = call i32 @sony_call_snc_handle(i32 341, i32 %conv, i32* %result)
  %tobool5 = icmp ne i32 %call4, 0
  %.count = select i1 %tobool5, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end3 ]
  %4 = bitcast i64* %value to i8*
  %5 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_panelid_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i32 @sony_call_snc_handle(i32 285, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !2
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %1)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  %2 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_smart_conn_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i64* %value to i8*
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %2 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %2, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = load i64, i64* %value, align 8, !tbaa !100
  %shl = shl i64 %3, 16
  %conv = trunc i64 %shl to i32
  %call4 = call i32 @sony_call_snc_handle(i32 360, i32 %conv, i32* %result)
  %tobool5 = icmp ne i32 %call4, 0
  %.count = select i1 %tobool5, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end3 ]
  %4 = bitcast i64* %value to i8*
  %5 = bitcast i32* %result to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_backlight_ng_read_limits(i32 %handle, %struct.sony_backlight_props* %props) #0 {
entry:
  %offset = alloca i64, align 8
  %buffer = alloca [32 x i8], align 16
  %0 = bitcast i64* %offset to i8*
  %1 = bitcast [32 x i8]* %buffer to i8*
  %2 = bitcast [32 x i8]* %buffer to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 32, i32 16, i1 false)
  %handle1 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !223
  %offset2 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 3
  store i8 0, i8* %offset2, align 8, !tbaa !174
  %maxlvl = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 4
  store i8 -1, i8* %maxlvl, align 1, !tbaa !173
  %call = call i32 @sony_find_snc_handle(i32 %handle)
  %conv = sext i32 %call to i64
  store i64 %conv, i64* %offset, align 8, !tbaa !133
  %3 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i32 0, i32 0
  %call3 = call i32 @sony_nc_buffer_call(i8* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.135, i32 0, i32 0), i64* %offset, i8* %arraydecay, i64 32)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %cleanup, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %handle, 323
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %handle, 331
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %.off = add i32 %handle, -331
  %SwitchLeaf6 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf6, label %sw.epilog, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %handle, 323
  br i1 %SwitchLeaf4, label %sw.epilog, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %handle, 311
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %handle, 311
  br i1 %SwitchLeaf2, label %sw.epilog, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %handle, 303
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %lvl_table_len.0 = phi i32 [ 0, %NewDefault ], [ 9, %LeafBlock1 ], [ 9, %LeafBlock ], [ 16, %LeafBlock5 ], [ 16, %LeafBlock3 ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %min.0 = phi i8 [ -1, %sw.epilog ], [ %min.1, %for.inc ]
  %i.0 = phi i32 [ 0, %sw.epilog ], [ %inc, %for.inc ]
  %max.0 = phi i8 [ 0, %sw.epilog ], [ %max.1, %for.inc ]
  %cmp6 = icmp slt i32 %i.0, %lvl_table_len.0
  %conv8 = sext i32 %i.0 to i64
  %cmp9 = icmp ult i64 %conv8, 32
  %4 = select i1 %cmp6, i1 %cmp9, i1 false
  br i1 %4, label %do.body, label %for.end

do.body:                                          ; preds = %for.cond
  %5 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %idxprom15 = sext i32 %i.0 to i64
  %arrayidx16 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom15
  %6 = load i8, i8* %arrayidx16, align 1, !tbaa !31
  %tobool17 = icmp ne i8 %6, 0
  br i1 %tobool17, label %if.end19, label %for.end

if.end19:                                         ; preds = %do.end
  %idxprom20 = sext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom20
  %7 = load i8, i8* %arrayidx21, align 1, !tbaa !31
  %conv22 = zext i8 %7 to i32
  %conv23 = zext i8 %max.0 to i32
  %cmp24 = icmp sgt i32 %conv22, %conv23
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end19
  %idxprom27 = sext i32 %i.0 to i64
  %arrayidx28 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom27
  %8 = load i8, i8* %arrayidx28, align 1, !tbaa !31
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end19
  %max.1 = phi i8 [ %8, %if.then26 ], [ %max.0, %if.end19 ]
  %idxprom30 = sext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom30
  %9 = load i8, i8* %arrayidx31, align 1, !tbaa !31
  %conv32 = zext i8 %9 to i32
  %conv33 = zext i8 %min.0 to i32
  %cmp34 = icmp slt i32 %conv32, %conv33
  br i1 %cmp34, label %if.then36, label %for.inc

if.then36:                                        ; preds = %if.end29
  %idxprom37 = sext i32 %i.0 to i64
  %arrayidx38 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom37
  %10 = load i8, i8* %arrayidx38, align 1, !tbaa !31
  br label %for.inc

for.inc:                                          ; preds = %if.then36, %if.end29
  %min.1 = phi i8 [ %10, %if.then36 ], [ %min.0, %if.end29 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %do.end, %for.cond
  %offset40 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 3
  store i8 %min.0, i8* %offset40, align 8, !tbaa !174
  %maxlvl41 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 4
  store i8 %max.0, i8* %maxlvl41, align 1, !tbaa !173
  %11 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool43 = icmp ne i32 %11, 0
  br i1 %tobool43, label %if.then44, label %cleanup

if.then44:                                        ; preds = %for.end
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then44, %for.end, %entry
  %12 = bitcast [32 x i8]* %buffer to i8*
  %13 = bitcast i64* %offset to i8*
  ret void
}

declare i8* @__memset(i8*, i32, i64) #1

declare %struct.backlight_device* @backlight_device_register(i8*, %struct.device*, i8*, %struct.backlight_ops*, %struct.backlight_properties*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #4 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_update_status_ng(%struct.backlight_device* %bd) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i8* @bl_get_data(%struct.backlight_device* %bd)
  %1 = bitcast i8* %call to %struct.sony_backlight_props*
  %props = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %bd, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 0
  %2 = load i32, i32* %brightness, align 8, !tbaa !146
  %offset = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 3
  %3 = load i8, i8* %offset, align 8, !tbaa !174
  %conv = zext i8 %3 to i32
  %add = add nsw i32 %2, %conv
  %handle = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 1
  %4 = load i32, i32* %handle, align 8, !tbaa !223
  %cmd_base = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 2
  %5 = load i32, i32* %cmd_base, align 4, !tbaa !172
  %shl = shl i32 %add, 16
  %or = or i32 %5, %shl
  %call1 = call i32 @sony_call_snc_handle(i32 %4, i32 %or, i32* %result)
  %tobool = icmp ne i32 %call1, 0
  %.add = select i1 %tobool, i32 -5, i32 %add
  %6 = bitcast i32* %result to i8*
  ret i32 %.add
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_get_brightness_ng(%struct.backlight_device* %bd) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %call = call i8* @bl_get_data(%struct.backlight_device* %bd)
  %1 = bitcast i8* %call to %struct.sony_backlight_props*
  %handle = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !223
  %cmd_base = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 2
  %3 = load i32, i32* %cmd_base, align 4, !tbaa !172
  %add = add nsw i32 %3, 256
  %call1 = call i32 @sony_call_snc_handle(i32 %2, i32 %add, i32* %result)
  %4 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %4, 255
  %offset = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %1, i32 0, i32 3
  %5 = load i8, i8* %offset, align 8, !tbaa !174
  %conv = zext i8 %5 to i32
  %sub = sub nsw i32 %and, %conv
  %6 = bitcast i32* %result to i8*
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @bl_get_data(%struct.backlight_device* %bl_dev) #4 {
entry:
  %dev = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %bl_dev, i32 0, i32 6
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !224
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_backlight_update_status(%struct.backlight_device* %bd) #0 {
entry:
  %arg = alloca i32, align 4
  %0 = bitcast i32* %arg to i8*
  %props = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %bd, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 0
  %1 = load i32, i32* %brightness, align 8, !tbaa !146
  %add = add nsw i32 %1, 1
  store i32 %add, i32* %arg, align 4, !tbaa !2
  %2 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call = call i32 @sony_nc_int_call(i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.54, i32 0, i32 0), i32* %arg, i32* null)
  %3 = bitcast i32* %arg to i8*
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @brightness_default_validate(i32 %direction, i32 %value) #0 {
entry:
  %Pivot = icmp slt i32 %direction, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %direction, 1
  %sub = sub nsw i32 %value, 1
  %sub. = select i1 %SwitchLeaf2, i32 %sub, i32 -22
  ret i32 %sub.

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %direction, 0
  br i1 %SwitchLeaf, label %sw.bb1, label %return

sw.bb1:                                           ; preds = %LeafBlock
  %cmp = icmp sge i32 %value, 0
  %cmp2 = icmp slt i32 %value, 8
  %or.cond = and i1 %cmp, %cmp2
  %add = add nsw i32 %value, 1
  %add. = select i1 %or.cond, i32 %add, i32 -22
  br label %return

return:                                           ; preds = %sw.bb1, %LeafBlock
  %retval.0 = phi i32 [ -22, %LeafBlock ], [ %add., %sw.bb1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_sysfs_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #0 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast i32* %value to i8*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -48
  %2 = bitcast i8* %add.ptr to %struct.sony_nc_value*
  %acpiget = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 1
  %3 = load i8**, i8*** %acpiget, align 8, !tbaa !164
  %4 = load i8*, i8** %3, align 8, !tbaa !27
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %5 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %acpiget1 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 1
  %6 = load i8**, i8*** %acpiget1, align 8, !tbaa !164
  %7 = load i8*, i8** %6, align 8, !tbaa !27
  %call = call i32 @sony_nc_int_call(i8* %5, i8* %7, i32* null, i32* %value)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %validate = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 3
  %8 = load i32 (i32, i32)*, i32 (i32, i32)** %validate, align 8, !tbaa !225
  %tobool4 = icmp ne i32 (i32, i32)* %8, null
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end3
  %validate6 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 3
  %9 = load i32 (i32, i32)*, i32 (i32, i32)** %validate6, align 8, !tbaa !225
  %10 = load i32, i32* %value, align 4, !tbaa !2
  %call7 = call i32 %9(i32 1, i32 %10)
  store i32 %call7, i32* %value, align 4, !tbaa !2
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end3
  %11 = load i32, i32* %value, align 4, !tbaa !2
  %call9 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.69, i32 0, i32 0), i32 %11)
  %conv = sext i32 %call9 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end8 ], [ -5, %entry ], [ -5, %if.end ]
  %12 = bitcast i32* %value to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_sysfs_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #0 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast i32* %value to i8*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -48
  %2 = bitcast i8* %add.ptr to %struct.sony_nc_value*
  %acpiset = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 2
  %3 = load i8**, i8*** %acpiset, align 8, !tbaa !166
  %tobool = icmp ne i8** %3, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %call = call i32 @kstrtoint(i8* %buffer, i32 10, i32* %value)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end2
  %validate = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 3
  %4 = load i32 (i32, i32)*, i32 (i32, i32)** %validate, align 8, !tbaa !225
  %tobool6 = icmp ne i32 (i32, i32)* %4, null
  br i1 %tobool6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end5
  %validate8 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 3
  %5 = load i32 (i32, i32)*, i32 (i32, i32)** %validate8, align 8, !tbaa !225
  %6 = load i32, i32* %value, align 4, !tbaa !2
  %call9 = call i32 %5(i32 0, i32 %6)
  store i32 %call9, i32* %value, align 4, !tbaa !2
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end5
  %7 = load i32, i32* %value, align 4, !tbaa !2
  %cmp11 = icmp slt i32 %7, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  %8 = load i32, i32* %value, align 4, !tbaa !2
  %conv = sext i32 %8 to i64
  br label %cleanup

if.end13:                                         ; preds = %if.end10
  %9 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %acpiset14 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 2
  %10 = load i8**, i8*** %acpiset14, align 8, !tbaa !166
  %11 = load i8*, i8** %10, align 8, !tbaa !27
  %call15 = call i32 @sony_nc_int_call(i8* %9, i8* %11, i32* %value, i32* null)
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end13
  %12 = load i32, i32* %value, align 4, !tbaa !2
  %value20 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 4
  store i32 %12, i32* %value20, align 8, !tbaa !226
  %valid = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %2, i32 0, i32 5
  store i32 1, i32* %valid, align 4, !tbaa !227
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.end13, %if.then12, %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.then12 ], [ %count, %if.end19 ], [ -5, %entry ], [ -22, %if.end ], [ -22, %if.end2 ], [ -5, %if.end13 ]
  %13 = bitcast i32* %value to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @boolean_validate(i32 %direction, i32 %value) #0 {
entry:
  %cmp = icmp ne i32 %direction, 0
  %switch = icmp ult i32 %value, 2
  %or.cond = or i1 %cmp, %switch
  %retval.0 = select i1 %or.cond, i32 %value, i32 -22
  ret i32 %retval.0
}

declare i32 @kstrtoint(i8*, i32, i32*) #1

declare void @backlight_device_unregister(%struct.backlight_device*) #1

; Function Attrs: nounwind uwtable
define internal void @sony_nc_touchpad_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %tobool = icmp ne %struct.touchpad_control* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %attr = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %1, i32 0, i32 0
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %attr)
  %2 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  %3 = bitcast %struct.touchpad_control* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.touchpad_control* null, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_battery_care_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %tobool = icmp ne %struct.battery_care_control* %0, null
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs, i64 0, i64 0
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %arrayidx)
  %2 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %2, i32 0, i32 1
  %3 = load i32, i32* %handle, align 8, !tbaa !185
  %cmp = icmp ne i32 %3, 277
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %dev2 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %4 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %attrs3 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %4, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs3, i64 0, i64 1
  call void @device_remove_file(%struct.device* %dev2, %struct.device_attribute* %arrayidx4)
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %5 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  %6 = bitcast %struct.battery_care_control* %5 to i8*
  call void @kfree(i8* %6)
  store %struct.battery_care_control* null, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !27
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_lid_resume_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %tobool = icmp ne %struct.snc_lid_resume_control* %0, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %if.end ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %1, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs, i64 0, i64 %idxprom
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 0
  %2 = load i8*, i8** %name, align 8, !tbaa !187
  %tobool1 = icmp ne i8* %2, null
  br i1 %tobool1, label %if.end, label %for.end

if.end:                                           ; preds = %for.body
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %3 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %attrs3 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %3, i32 0, i32 0
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs3, i64 0, i64 %idxprom4
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %arrayidx5)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %4 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  %5 = bitcast %struct.snc_lid_resume_control* %4 to i8*
  call void @kfree(i8* %5)
  store %struct.snc_lid_resume_control* null, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !27
  br label %if.end6

if.end6:                                          ; preds = %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_thermal_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.snc_thermal_ctrl* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %profiles_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %1, i32 0, i32 3
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %profiles_attr)
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %2 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %2, i32 0, i32 2
  call void @device_remove_file(%struct.device* %dev1, %struct.device_attribute* %mode_attr)
  %3 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %4 = bitcast %struct.snc_thermal_ctrl* %3 to i8*
  call void @kfree(i8* %4)
  store %struct.snc_thermal_ctrl* null, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_gfx_switch_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %tobool = icmp ne %struct.snc_gfx_switch_control* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %attr = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %1, i32 0, i32 0
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %attr)
  %2 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  %3 = bitcast %struct.snc_gfx_switch_control* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.snc_gfx_switch_control* null, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_highspeed_charging_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.device_attribute* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %1)
  %2 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  %3 = bitcast %struct.device_attribute* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.device_attribute* null, %struct.device_attribute** @hsc_handle, align 8, !tbaa !27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_kbd_backlight_cleanup(%struct.platform_device* %pd, i32 %handle) #0 {
entry:
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %tobool = icmp ne %struct.kbd_backlight* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %handle1 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %1, i32 0, i32 0
  %2 = load i32, i32* %handle1, align 8, !tbaa !211
  %cmp = icmp eq i32 %handle, %2
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %land.lhs.true
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %3 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %mode_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %3, i32 0, i32 5
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %mode_attr)
  %4 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %has_timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %4, i32 0, i32 4
  %5 = load i32, i32* %has_timeout, align 8, !tbaa !213
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %dev4 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %6 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %timeout_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %6, i32 0, i32 6
  call void @device_remove_file(%struct.device* %dev4, %struct.device_attribute* %timeout_attr)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %7 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  %8 = bitcast %struct.kbd_backlight* %7 to i8*
  call void @kfree(i8* %8)
  store %struct.kbd_backlight* null, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !27
  br label %if.end5

if.end5:                                          ; preds = %if.end, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_lowbatt_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.device_attribute* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %1)
  %2 = load %struct.device_attribute*, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  %3 = bitcast %struct.device_attribute* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.device_attribute* null, %struct.device_attribute** @lowbatt_handle, align 8, !tbaa !27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_fanspeed_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.device_attribute* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %1)
  %2 = load %struct.device_attribute*, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  %3 = bitcast %struct.device_attribute* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.device_attribute* null, %struct.device_attribute** @fan_handle, align 8, !tbaa !27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %tobool1 = icmp ne %struct.device_attribute* %4, null
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %dev3 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %5 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  call void @device_remove_file(%struct.device* %dev3, %struct.device_attribute* %5)
  %6 = load %struct.device_attribute*, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  %7 = bitcast %struct.device_attribute* %6 to i8*
  call void @kfree(i8* %7)
  store %struct.device_attribute* null, %struct.device_attribute** @hsf_handle, align 8, !tbaa !27
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_usb_charge_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.device_attribute* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %1)
  %2 = load %struct.device_attribute*, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  %3 = bitcast %struct.device_attribute* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.device_attribute* null, %struct.device_attribute** @uc_handle, align 8, !tbaa !27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_panelid_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.device_attribute* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %1)
  %2 = load %struct.device_attribute*, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  %3 = bitcast %struct.device_attribute* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.device_attribute* null, %struct.device_attribute** @panel_handle, align 8, !tbaa !27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_smart_conn_cleanup(%struct.platform_device* %pd) #0 {
entry:
  %0 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %tobool = icmp ne %struct.device_attribute* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %1)
  %2 = load %struct.device_attribute*, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  %3 = bitcast %struct.device_attribute* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.device_attribute* null, %struct.device_attribute** @sc_handle, align 8, !tbaa !27
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @rfkill_unregister(%struct.rfkill*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_hotkeys_decode(i32 %handle) #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  store i32 0, i32* %result, align 4, !tbaa !2
  %call = call i32 @sony_call_snc_handle(i32 %handle, i32 512, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %do.body, label %if.end4

do.body:                                          ; preds = %entry
  %1 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end4:                                          ; preds = %entry
  %2 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %2, 255
  store i32 %and, i32* %result, align 4, !tbaa !2
  %cmp = icmp eq i32 %handle, 256
  %. = select i1 %cmp, %struct.sony_nc_event* getelementptr inbounds ([43 x %struct.sony_nc_event], [43 x %struct.sony_nc_event]* @sony_100_events, i32 0, i32 0), %struct.sony_nc_event* getelementptr inbounds ([15 x %struct.sony_nc_event], [15 x %struct.sony_nc_event]* @sony_127_events, i32 0, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %key_event.1 = phi %struct.sony_nc_event* [ %., %if.end4 ], [ %incdec.ptr, %for.inc ]
  %data = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 0
  %3 = load i8, i8* %data, align 1, !tbaa !228
  %tobool7 = icmp ne i8 %3, 0
  br i1 %tobool7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %data8 = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 0
  %4 = load i8, i8* %data8, align 1, !tbaa !228
  %conv = zext i8 %4 to i32
  %5 = load i32, i32* %result, align 4, !tbaa !2
  %cmp9 = icmp eq i32 %conv, %5
  br i1 %cmp9, label %if.then11, label %for.inc

if.then11:                                        ; preds = %for.body
  %event12 = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 1
  %6 = load i8, i8* %event12, align 1, !tbaa !230
  %conv13 = zext i8 %6 to i32
  br label %for.end

for.inc:                                          ; preds = %for.body
  %incdec.ptr = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 1
  br label %for.cond

for.end:                                          ; preds = %if.then11, %for.cond
  %ret.0 = phi i32 [ %conv13, %if.then11 ], [ -22, %for.cond ]
  %data15 = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 0
  %7 = load i8, i8* %data15, align 1, !tbaa !228
  %tobool16 = icmp ne i8 %7, 0
  br i1 %tobool16, label %cleanup, label %if.then17

if.then17:                                        ; preds = %for.end
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then17, %for.end, %if.then2, %do.body
  %retval.0 = phi i32 [ -22, %if.then2 ], [ -22, %do.body ], [ %ret.0, %if.then17 ], [ %ret.0, %for.end ]
  %8 = bitcast i32* %result to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_rfkill_update() #0 {
entry:
  %result = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %1 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !2
  %call = call i32 @sony_call_snc_handle(i32 %1, i32 512, i32* %result)
  %2 = load i32, i32* %result, align 4, !tbaa !2
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %LeafBlock ]
  %cmp = icmp ult i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @sony_rfkill_address, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %idxprom1 = zext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom1
  %4 = load %struct.rfkill*, %struct.rfkill** %arrayidx2, align 8, !tbaa !27
  %tobool3 = icmp ne %struct.rfkill* %4, null
  br i1 %tobool3, label %if.end, label %LeafBlock

if.end:                                           ; preds = %for.body
  %tobool4 = trunc i8 %frombool to i1
  br i1 %tobool4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end
  %idxprom6 = zext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom6
  %5 = load %struct.rfkill*, %struct.rfkill** %arrayidx7, align 8, !tbaa !27
  %call8 = call zeroext i1 @rfkill_set_hw_state(%struct.rfkill* %5, i1 zeroext true)
  br label %LeafBlock

if.end11:                                         ; preds = %if.end
  %6 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !2
  %call12 = call i32 @sony_call_snc_handle(i32 %6, i32 %3, i32* %result)
  %idxprom13 = zext i32 %i.0 to i64
  %arrayidx14 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom13
  %7 = load %struct.rfkill*, %struct.rfkill** %arrayidx14, align 8, !tbaa !27
  %8 = load i32, i32* %result, align 4, !tbaa !2
  %and15 = and i32 %8, 2
  %tobool16 = icmp ne i32 %and15, 0
  %lnot17 = xor i1 %tobool16, true
  call void @rfkill_set_states(%struct.rfkill* %7, i1 zeroext %lnot17, i1 zeroext false)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end11, %if.then5, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = bitcast i32* %result to i8*
  ret void
}

declare i32 @acpi_bus_generate_netlink_event(i8*, i8*, i8 zeroext, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name(%struct.device* %dev) #4 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !231
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !231
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

declare void @rfkill_set_states(%struct.rfkill*, i1 zeroext, i1 zeroext) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name(%struct.kobject* %kobj) #4 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !232
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_resume(%struct.device* %dev) #0 {
entry:
  %arg = alloca i32, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %item.0 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %entry ], [ %incdec.ptr, %for.inc ]
  %name = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !158
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %valid = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 5
  %1 = load i32, i32* %valid, align 4, !tbaa !227
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.end, label %NodeBlock

if.end:                                           ; preds = %for.body
  %2 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %acpiset = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %3 = load i8**, i8*** %acpiset, align 8, !tbaa !166
  %4 = load i8*, i8** %3, align 8, !tbaa !27
  %value = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 4
  %call = call i32 @sony_nc_int_call(i8* %2, i8* %4, i32* %value, i32* null)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then2, label %NodeBlock

if.then2:                                         ; preds = %if.end
  call void (i8*, ...) @printk(i8* null)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.then2, %if.end, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then2 ], [ 4, %for.body ], [ 0, %if.end ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 4
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  %or.cond = and i1 %Pivot, %SwitchLeaf
  br i1 %or.cond, label %for.end, label %for.inc

for.inc:                                          ; preds = %NodeBlock
  %incdec.ptr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %NodeBlock, %for.cond
  %5 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call5 = call zeroext i1 @acpi_has_method(i8* %5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.77, i32 0, i32 0))
  br i1 %call5, label %if.then6, label %if.end15

if.then6:                                         ; preds = %for.end
  %6 = bitcast i32* %arg to i8*
  store i32 1, i32* %arg, align 4, !tbaa !2
  %7 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call7 = call i32 @sony_nc_int_call(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.77, i32 0, i32 0), i32* %arg, i32* null)
  %tobool8 = icmp ne i32 %call7, 0
  %8 = load i32, i32* @debug, align 4
  %tobool10 = icmp ne i32 %8, 0
  %or.cond1 = and i1 %tobool8, %tobool10
  br i1 %or.cond1, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.then6
  call void (i8*, ...) @printk(i8* null)
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.then6
  %9 = bitcast i32* %arg to i8*
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %for.end
  %10 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call16 = call zeroext i1 @acpi_has_method(i8* %10, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.79, i32 0, i32 0))
  br i1 %call16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  call void @sony_nc_function_resume()
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end15
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_function_resume() #0 {
entry:
  %result = alloca i32, align 4
  %bitmask = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = bitcast i32* %result to i8*
  %1 = bitcast i32* %bitmask to i8*
  %2 = bitcast i32* %arg to i8*
  %3 = load i32, i32* @debug, align 4, !tbaa !2
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock20, %do.end
  %i.0 = phi i32 [ 0, %do.end ], [ %inc, %LeafBlock20 ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !27
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %4, i32 0, i32 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %5 = load i16, i16* %arrayidx, align 2, !tbaa !153
  %conv2 = zext i16 %5 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br i1 %tobool3, label %NodeBlock17, label %LeafBlock20

NodeBlock17:                                      ; preds = %for.body
  %Pivot18 = icmp slt i32 %conv2, 292
  br i1 %Pivot18, label %NodeBlock5, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %conv2, 295
  br i1 %Pivot16, label %LeafBlock7, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %conv2, 309
  br i1 %Pivot14, label %LeafBlock9, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %conv2, 309
  br i1 %SwitchLeaf12, label %sw.bb10, label %LeafBlock20

LeafBlock9:                                       ; preds = %NodeBlock13
  %SwitchLeaf10 = icmp eq i32 %conv2, 295
  br i1 %SwitchLeaf10, label %sw.bb, label %LeafBlock20

LeafBlock7:                                       ; preds = %NodeBlock15
  %SwitchLeaf8 = icmp eq i32 %conv2, 292
  br i1 %SwitchLeaf8, label %sw.bb10, label %LeafBlock20

NodeBlock5:                                       ; preds = %NodeBlock17
  %Pivot6 = icmp slt i32 %conv2, 258
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv2, 290
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv2, 290
  br i1 %SwitchLeaf4, label %sw.bb9, label %LeafBlock20

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv2, 258
  br i1 %SwitchLeaf2, label %sw.bb7, label %LeafBlock20

LeafBlock:                                        ; preds = %NodeBlock5
  %.off = add i32 %conv2, -256
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %LeafBlock20

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock9
  %call6 = call i32 @sony_call_snc_handle(i32 %conv2, i32 0, i32* %result)
  br label %LeafBlock20

sw.bb7:                                           ; preds = %LeafBlock1
  %call8 = call i32 @sony_call_snc_handle(i32 %conv2, i32 256, i32* %result)
  br label %LeafBlock20

sw.bb9:                                           ; preds = %LeafBlock3
  call void @sony_nc_thermal_resume()
  br label %LeafBlock20

sw.bb10:                                          ; preds = %LeafBlock7, %LeafBlock11
  call void @sony_nc_rfkill_update()
  br label %LeafBlock20

LeafBlock20:                                      ; preds = %sw.bb10, %sw.bb9, %sw.bb7, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock11, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 16, i32* %arg, align 4, !tbaa !2
  %6 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call11 = call i32 @sony_nc_int_call(i8* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.79, i32 0, i32 0), i32* %arg, i32* %bitmask)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end15, label %if.then13

if.then13:                                        ; preds = %for.end
  %7 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !27
  %call14 = call i32 @sony_nc_int_call(i8* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.103, i32 0, i32 0), i32* %bitmask, i32* %result)
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %for.end
  %8 = bitcast i32* %arg to i8*
  %9 = bitcast i32* %bitmask to i8*
  %10 = bitcast i32* %result to i8*
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_thermal_resume() #0 {
entry:
  %call = call i32 @sony_nc_thermal_mode_get()
  %0 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %0, i32 0, i32 0
  %1 = load i32, i32* %mode, align 8, !tbaa !194
  %cmp = icmp ne i32 %call, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !27
  %mode1 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %2, i32 0, i32 0
  %3 = load i32, i32* %mode1, align 8, !tbaa !194
  %conv = trunc i32 %3 to i16
  %call2 = call i32 @sony_nc_thermal_mode_set(i16 zeroext %conv)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @printk(i8*, ...) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !4, i64 238}
!7 = !{!"sony_pic_dev", !8, i64 0, !8, i64 8, !8, i64 16, !9, i64 24, !9, i64 40, !10, i64 56, !8, i64 216, !8, i64 224, !3, i64 232, !17, i64 236, !4, i64 238, !4, i64 239, !4, i64 240}
!8 = !{!"any pointer", !4, i64 0}
!9 = !{!"list_head", !8, i64 0, !8, i64 8}
!10 = !{!"mutex", !11, i64 0, !13, i64 8, !14, i64 80, !9, i64 88, !8, i64 104, !16, i64 112}
!11 = !{!"", !12, i64 0}
!12 = !{!"long", !4, i64 0}
!13 = !{!"spinlock", !4, i64 0}
!14 = !{!"optimistic_spin_queue", !15, i64 0}
!15 = !{!"", !3, i64 0}
!16 = !{!"lockdep_map", !8, i64 0, !4, i64 8, !8, i64 24, !3, i64 32, !12, i64 40}
!17 = !{!"short", !4, i64 0}
!18 = !{!7, !8, i64 16}
!19 = !{!20, !17, i64 3}
!20 = !{!"sony_pic_ioport", !21, i64 0, !21, i64 7, !9, i64 16}
!21 = !{!"acpi_resource_io", !4, i64 0, !4, i64 1, !4, i64 2, !17, i64 3, !17, i64 5}
!22 = !{i32 -2145035713}
!23 = !{i32 -2145035511}
!24 = !{!25, !8, i64 192}
!25 = !{!"pv_cpu_ops", !8, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !8, i64 56, !8, i64 64, !8, i64 72, !8, i64 80, !8, i64 88, !8, i64 96, !8, i64 104, !8, i64 112, !8, i64 120, !8, i64 128, !8, i64 136, !8, i64 144, !8, i64 152, !8, i64 160, !8, i64 168, !8, i64 176, !8, i64 184, !8, i64 192, !8, i64 200, !8, i64 208, !8, i64 216, !8, i64 224, !8, i64 232, !8, i64 240, !8, i64 248, !8, i64 256, !8, i64 264, !8, i64 272, !8, i64 280}
!26 = !{!7, !8, i64 0}
!27 = !{!8, !8, i64 0}
!28 = !{!20, !4, i64 2}
!29 = !{!20, !17, i64 10}
!30 = !{!20, !4, i64 9}
!31 = !{!4, !4, i64 0}
!32 = !{!7, !8, i64 8}
!33 = !{!7, !4, i64 239}
!34 = !{!9, !8, i64 0}
!35 = !{!20, !8, i64 16}
!36 = !{!37, !8, i64 8}
!37 = !{!"sony_pic_irq", !38, i64 0, !9, i64 8}
!38 = !{!"acpi_resource_irq", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3, !4, i64 4, !4, i64 5, !4, i64 6}
!39 = !{!7, !3, i64 232}
!40 = !{!7, !8, i64 224}
!41 = !{!7, !17, i64 236}
!42 = !{!7, !8, i64 216}
!43 = !{!44, !8, i64 8}
!44 = !{!"acpi_device", !3, i64 0, !8, i64 8, !45, i64 16, !8, i64 32, !9, i64 40, !9, i64 56, !9, i64 72, !9, i64 88, !46, i64 104, !47, i64 108, !48, i64 112, !50, i64 232, !52, i64 400, !57, i64 552, !59, i64 576, !60, i64 584, !8, i64 624, !8, i64 632, !8, i64 640, !8, i64 648, !8, i64 656, !61, i64 664, !3, i64 2088, !3, i64 2092, !9, i64 2096, !10, i64 2112, !8, i64 2272}
!45 = !{!"fwnode_handle", !4, i64 0, !8, i64 8}
!46 = !{!"acpi_device_status", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0}
!47 = !{!"acpi_device_flags", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 1, !3, i64 1, !3, i64 1, !3, i64 1, !3, i64 1}
!48 = !{!"acpi_device_pnp", !4, i64 0, !49, i64 8, !12, i64 16, !8, i64 24, !9, i64 32, !4, i64 48, !4, i64 88, !8, i64 112}
!49 = !{!"acpi_pnp_type", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0}
!50 = !{!"acpi_device_power", !3, i64 0, !51, i64 4, !4, i64 8}
!51 = !{!"acpi_device_power_flags", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0}
!52 = !{!"acpi_device_wakeup", !8, i64 0, !53, i64 8, !53, i64 16, !9, i64 24, !54, i64 40, !55, i64 48, !8, i64 136, !3, i64 144}
!53 = !{!"long long", !4, i64 0}
!54 = !{!"acpi_device_wakeup_flags", !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0}
!55 = !{!"acpi_device_wakeup_context", !56, i64 0, !8, i64 80}
!56 = !{!"work_struct", !11, i64 0, !9, i64 8, !8, i64 24, !16, i64 32}
!57 = !{!"acpi_device_perf", !3, i64 0, !58, i64 4, !3, i64 8, !8, i64 16}
!58 = !{!"acpi_device_perf_flags", !4, i64 0}
!59 = !{!"acpi_device_dir", !8, i64 0}
!60 = !{!"acpi_device_data", !8, i64 0, !8, i64 8, !8, i64 16, !9, i64 24}
!61 = !{!"device", !8, i64 0, !8, i64 8, !62, i64 16, !8, i64 280, !8, i64 288, !10, i64 296, !8, i64 456, !8, i64 464, !8, i64 472, !8, i64 480, !68, i64 488, !69, i64 528, !8, i64 1104, !8, i64 1112, !8, i64 1120, !9, i64 1128, !3, i64 1144, !8, i64 1152, !8, i64 1160, !53, i64 1168, !12, i64 1176, !8, i64 1184, !9, i64 1192, !8, i64 1208, !8, i64 1216, !74, i64 1224, !8, i64 1232, !8, i64 1240, !3, i64 1248, !3, i64 1252, !13, i64 1256, !9, i64 1328, !75, i64 1344, !8, i64 1376, !8, i64 1384, !8, i64 1392, !8, i64 1400, !8, i64 1408, !71, i64 1416, !71, i64 1416}
!62 = !{!"kobject", !8, i64 0, !9, i64 8, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !63, i64 56, !65, i64 64, !3, i64 256, !3, i64 256, !3, i64 256, !3, i64 256, !3, i64 256}
!63 = !{!"kref", !64, i64 0}
!64 = !{!"refcount_struct", !15, i64 0}
!65 = !{!"delayed_work", !56, i64 0, !66, i64 80, !8, i64 176, !3, i64 184}
!66 = !{!"timer_list", !67, i64 0, !12, i64 16, !8, i64 24, !12, i64 32, !3, i64 40, !16, i64 48}
!67 = !{!"hlist_node", !8, i64 0, !8, i64 8}
!68 = !{!"dev_links_info", !9, i64 0, !9, i64 16, !4, i64 32}
!69 = !{!"dev_pm_info", !70, i64 0, !3, i64 4, !3, i64 4, !71, i64 4, !71, i64 4, !71, i64 4, !71, i64 4, !71, i64 4, !71, i64 4, !71, i64 5, !13, i64 8, !9, i64 80, !72, i64 96, !8, i64 192, !71, i64 200, !71, i64 200, !71, i64 200, !66, i64 208, !12, i64 304, !56, i64 312, !73, i64 392, !8, i64 480, !15, i64 488, !15, i64 492, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !71, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 500, !4, i64 504, !4, i64 508, !3, i64 512, !3, i64 516, !12, i64 520, !12, i64 528, !12, i64 536, !12, i64 544, !8, i64 552, !8, i64 560, !8, i64 568}
!70 = !{!"pm_message", !3, i64 0}
!71 = !{!"_Bool", !4, i64 0}
!72 = !{!"completion", !3, i64 0, !73, i64 8}
!73 = !{!"__wait_queue_head", !13, i64 0, !9, i64 72}
!74 = !{!"dev_archdata", !8, i64 0}
!75 = !{!"klist_node", !8, i64 0, !9, i64 8, !63, i64 24}
!76 = !{i32 -2146233575, i32 -2146233536, i32 -2146233515, i32 -2146233478, i32 -2146233455, i32 -2146233446}
!77 = !{!66, !8, i64 24}
!78 = !{!66, !12, i64 32}
!79 = !{!80, !8, i64 0}
!80 = !{!"input_dev", !8, i64 0, !8, i64 8, !8, i64 16, !81, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184, !4, i64 200, !3, i64 208, !3, i64 212, !3, i64 216, !8, i64 224, !8, i64 232, !8, i64 240, !8, i64 248, !3, i64 256, !66, i64 264, !4, i64 360, !8, i64 368, !8, i64 376, !4, i64 384, !4, i64 480, !4, i64 488, !4, i64 496, !8, i64 504, !8, i64 512, !8, i64 520, !8, i64 528, !8, i64 536, !13, i64 544, !10, i64 616, !3, i64 776, !71, i64 780, !61, i64 784, !9, i64 2208, !9, i64 2224, !3, i64 2240, !3, i64 2244, !8, i64 2248, !71, i64 2256}
!81 = !{!"input_id", !17, i64 0, !17, i64 2, !17, i64 4, !17, i64 6}
!82 = !{!80, !17, i64 24}
!83 = !{!80, !17, i64 26}
!84 = !{!80, !8, i64 784}
!85 = !{i32 589045}
!86 = !{!80, !3, i64 216}
!87 = !{!80, !3, i64 212}
!88 = !{!80, !8, i64 224}
!89 = !{i32 590235}
!90 = !{!91, !8, i64 16}
!91 = !{!"sony_laptop_input_s", !15, i64 0, !8, i64 8, !8, i64 16, !92, i64 24, !13, i64 48, !66, i64 120}
!92 = !{!"kfifo", !4, i64 0, !4, i64 24}
!93 = !{!91, !8, i64 8}
!94 = !{i32 -2146238012, i32 -2146237973, i32 -2146237952, i32 -2146237915, i32 -2146237892, i32 -2146238022}
!95 = !{!96, !3, i64 0}
!96 = !{!"miscdevice", !3, i64 0, !8, i64 8, !8, i64 16, !9, i64 24, !8, i64 40, !8, i64 48, !8, i64 56, !8, i64 64, !17, i64 72}
!97 = !{!98, !12, i64 8}
!98 = !{!"sonypi_eventtypes", !4, i64 0, !12, i64 8, !8, i64 16}
!99 = !{!98, !4, i64 0}
!100 = !{!12, !12, i64 0}
!101 = !{!98, !8, i64 16}
!102 = !{!103, !4, i64 1}
!103 = !{!"sonypi_event", !4, i64 0, !4, i64 1}
!104 = !{!103, !4, i64 0}
!105 = !{!106, !53, i64 0}
!106 = !{!"acpi_buffer", !53, i64 0, !8, i64 8}
!107 = !{!106, !8, i64 8}
!108 = !{!109, !3, i64 0}
!109 = !{!"", !110, i64 0, !110, i64 68, !110, i64 136, !110, i64 204}
!110 = !{!"acpi_resource", !3, i64 0, !3, i64 4, !4, i64 8}
!111 = !{!109, !3, i64 4}
!112 = !{!109, !3, i64 68}
!113 = !{!109, !3, i64 72}
!114 = !{!109, !3, i64 136}
!115 = !{!109, !3, i64 140}
!116 = !{!109, !3, i64 204}
!117 = !{i32 -2146237260, i32 -2146237221, i32 -2146237200, i32 -2146237163, i32 -2146237140, i32 -2146237131, i32 -2146237087}
!118 = !{!71, !71, i64 0}
!119 = !{i8 0, i8 2}
!120 = !{!121, !8, i64 0}
!121 = !{!"sony_laptop_keypress", !8, i64 0, !3, i64 8}
!122 = !{!121, !3, i64 8}
!123 = !{!9, !8, i64 8}
!124 = !{!110, !3, i64 0}
!125 = !{!38, !4, i64 5}
!126 = !{!38, !4, i64 1}
!127 = !{!37, !4, i64 1}
!128 = !{!38, !4, i64 2}
!129 = !{!37, !4, i64 2}
!130 = !{!38, !4, i64 3}
!131 = !{!37, !4, i64 3}
!132 = !{!37, !4, i64 5}
!133 = !{!53, !53, i64 0}
!134 = !{!135, !3, i64 128}
!135 = !{!"file", !4, i64 0, !136, i64 16, !8, i64 32, !8, i64 40, !13, i64 48, !11, i64 120, !3, i64 128, !3, i64 132, !10, i64 136, !53, i64 296, !137, i64 304, !8, i64 400, !141, i64 408, !53, i64 440, !8, i64 448, !8, i64 456, !9, i64 464, !9, i64 480, !8, i64 496}
!136 = !{!"path", !8, i64 0, !8, i64 8}
!137 = !{!"fown_struct", !138, i64 0, !8, i64 72, !4, i64 80, !15, i64 84, !15, i64 88, !3, i64 92}
!138 = !{!"", !139, i64 0, !3, i64 8, !3, i64 12, !8, i64 16, !16, i64 24}
!139 = !{!"qrwlock", !15, i64 0, !140, i64 4}
!140 = !{!"qspinlock", !15, i64 0}
!141 = !{!"file_ra_state", !12, i64 0, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !53, i64 24}
!142 = !{i32 -2141724826}
!143 = !{i64 0, i64 8, !100, i64 8, i64 8, !100}
!144 = !{!145, !8, i64 0}
!145 = !{!"sony_backlight_props", !8, i64 0, !3, i64 8, !3, i64 12, !4, i64 16, !4, i64 17}
!146 = !{!147, !3, i64 0}
!147 = !{!"backlight_device", !148, i64 0, !10, i64 24, !10, i64 184, !8, i64 344, !149, i64 352, !9, i64 376, !61, i64 392, !4, i64 1816, !3, i64 1848}
!148 = !{!"backlight_properties", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !4, i64 16, !3, i64 20}
!149 = !{!"notifier_block", !8, i64 0, !8, i64 8, !3, i64 16}
!150 = !{!135, !8, i64 32}
!151 = !{!152, !8, i64 0}
!152 = !{!"poll_table_struct", !8, i64 0, !12, i64 8}
!153 = !{!17, !17, i64 0}
!154 = !{!155, !3, i64 0}
!155 = !{!"acpi_object_list", !3, i64 0, !8, i64 8}
!156 = !{!155, !8, i64 8}
!157 = !{!7, !4, i64 240}
!158 = !{!159, !8, i64 0}
!159 = !{!"sony_nc_value", !8, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !3, i64 32, !3, i64 36, !3, i64 40, !160, i64 48}
!160 = !{!"device_attribute", !161, i64 0, !8, i64 32, !8, i64 40}
!161 = !{!"attribute", !8, i64 0, !17, i64 8, !71, i64 10, !8, i64 16, !162, i64 24}
!162 = !{!"lock_class_key", !4, i64 0}
!163 = !{!159, !3, i64 40}
!164 = !{!159, !8, i64 8}
!165 = !{!159, !17, i64 56}
!166 = !{!159, !8, i64 16}
!167 = !{!161, !8, i64 16}
!168 = !{!169, !8, i64 32}
!169 = !{!"sony_nc_handles", !4, i64 0, !160, i64 32}
!170 = !{!169, !17, i64 40}
!171 = !{!169, !8, i64 64}
!172 = !{!145, !3, i64 12}
!173 = !{!145, !4, i64 17}
!174 = !{!145, !4, i64 16}
!175 = !{!148, !4, i64 16}
!176 = !{!148, !3, i64 4}
!177 = !{!178, !8, i64 16}
!178 = !{!"backlight_ops", !3, i64 0, !8, i64 8, !8, i64 16, !8, i64 24}
!179 = !{!180, !3, i64 48}
!180 = !{!"touchpad_control", !160, i64 0, !3, i64 48}
!181 = !{!180, !8, i64 0}
!182 = !{!180, !17, i64 8}
!183 = !{!180, !8, i64 32}
!184 = !{!180, !8, i64 40}
!185 = !{!186, !3, i64 96}
!186 = !{!"battery_care_control", !4, i64 0, !3, i64 96}
!187 = !{!160, !8, i64 0}
!188 = !{!160, !17, i64 8}
!189 = !{!160, !8, i64 32}
!190 = !{!160, !8, i64 40}
!191 = !{!192, !3, i64 144}
!192 = !{!"snc_lid_resume_control", !4, i64 0, !3, i64 144, !3, i64 148}
!193 = !{!192, !3, i64 148}
!194 = !{!195, !3, i64 0}
!195 = !{!"snc_thermal_ctrl", !3, i64 0, !3, i64 4, !160, i64 8, !160, i64 56}
!196 = !{!195, !8, i64 56}
!197 = !{!195, !17, i64 64}
!198 = !{!195, !8, i64 88}
!199 = !{!195, !8, i64 8}
!200 = !{!195, !17, i64 16}
!201 = !{!195, !8, i64 40}
!202 = !{!195, !8, i64 48}
!203 = !{!204, !3, i64 48}
!204 = !{!"snc_gfx_switch_control", !160, i64 0, !3, i64 48}
!205 = !{!204, !8, i64 0}
!206 = !{!204, !17, i64 8}
!207 = !{!204, !8, i64 32}
!208 = !{!209, !3, i64 8}
!209 = !{!"kbd_backlight", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !160, i64 24, !160, i64 72}
!210 = !{!209, !3, i64 12}
!211 = !{!209, !3, i64 0}
!212 = !{!209, !3, i64 4}
!213 = !{!209, !3, i64 16}
!214 = !{!209, !8, i64 24}
!215 = !{!209, !17, i64 32}
!216 = !{!209, !8, i64 56}
!217 = !{!209, !8, i64 64}
!218 = !{!209, !8, i64 72}
!219 = !{!209, !17, i64 80}
!220 = !{!209, !8, i64 104}
!221 = !{!209, !8, i64 112}
!222 = !{!195, !3, i64 4}
!223 = !{!145, !3, i64 8}
!224 = !{!61, !8, i64 480}
!225 = !{!159, !8, i64 24}
!226 = !{!159, !3, i64 32}
!227 = !{!159, !3, i64 36}
!228 = !{!229, !4, i64 0}
!229 = !{!"sony_nc_event", !4, i64 0, !4, i64 1}
!230 = !{!229, !4, i64 1}
!231 = !{!61, !8, i64 280}
!232 = !{!62, !8, i64 0}
