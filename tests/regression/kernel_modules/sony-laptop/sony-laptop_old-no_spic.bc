; ModuleID = 'tests/regression/kernel_modules/sony-laptop/sony-laptop_old-no_spic.bc'
source_filename = "drivers/platform/x86/sony-laptop.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.6 }
%union.anon.6 = type { i8* }
%struct.sony_pic_dev = type { %struct.acpi_device*, %struct.sony_pic_irq*, %struct.sony_pic_ioport*, %struct.list_head, %struct.list_head, %struct.mutex, %struct.sonypi_eventtypes*, i32 (i8, i8)*, i32, i16, i8, i8, i8 }
%struct.acpi_device = type { i32, i8*, %struct.acpi_device*, %struct.list_head, %struct.list_head, %struct.list_head, %struct.acpi_device_status, %struct.acpi_device_flags, %struct.acpi_device_pnp, %struct.acpi_device_power, %struct.acpi_device_wakeup, %struct.acpi_device_perf, %struct.acpi_device_dir, %struct.acpi_scan_handler*, %struct.acpi_driver*, i8*, %struct.device, i32, i8, %struct.list_head, %struct.mutex, [1 x i64], %struct.list_head, void (%struct.acpi_device*)* }
%struct.acpi_device_status = type { i32 }
%struct.acpi_device_flags = type { i32 }
%struct.acpi_device_pnp = type { [8 x i8], %struct.acpi_pnp_type, i64, i8*, %struct.list_head, [40 x i8], [20 x i8], %union.acpi_object*, i64 }
%struct.acpi_pnp_type = type { i32 }
%union.acpi_object = type { %struct.anon.52 }
%struct.anon.52 = type { i32, i32, i64, i32 }
%struct.acpi_device_power = type { i32, %struct.acpi_device_power_flags, [5 x %struct.acpi_device_power_state] }
%struct.acpi_device_power_flags = type { i32 }
%struct.acpi_device_power_state = type { %struct.anon.54, i32, i32, %struct.list_head }
%struct.anon.54 = type { i8, i8 }
%struct.acpi_device_wakeup = type { i8*, i64, i64, %struct.list_head, %struct.acpi_device_wakeup_flags, i32 }
%struct.acpi_device_wakeup_flags = type { i8 }
%struct.acpi_device_perf = type { i32, %struct.acpi_device_perf_flags, i32, %struct.acpi_device_perf_state* }
%struct.acpi_device_perf_flags = type { i8 }
%struct.acpi_device_perf_state = type { %struct.anon.55, i8, i8, i32 }
%struct.anon.55 = type { i8 }
%struct.acpi_device_dir = type { %struct.proc_dir_entry* }
%struct.proc_dir_entry = type opaque
%struct.acpi_scan_handler = type { %struct.acpi_device_id*, %struct.list_head, i32 (%struct.acpi_device*, %struct.acpi_device_id*)*, void (%struct.acpi_device*)*, %struct.acpi_hotplug_profile }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.acpi_hotplug_profile = type { %struct.kobject, i8, i32 }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i32 }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.acpi_driver = type { [80 x i8], [80 x i8], %struct.acpi_device_id*, i32, %struct.acpi_device_ops, %struct.device_driver, %struct.module* }
%struct.acpi_device_ops = type { i32 (%struct.acpi_device*)*, i32 (%struct.acpi_device*)*, void (%struct.acpi_device*, i32)* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.driver_private = type opaque
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, %struct.memcg_batch_info, i32, %struct.atomic_t, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.atomic64_t = type { i64 }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file = type { %union.anon.3, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%union.anon.3 = type { %struct.list_head }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.8, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.4, i8* }
%union.anon.4 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.7, i32 }
%union.anon.7 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%union.anon.8 = type { %struct.list_head }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.44, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.45, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.atomic_t, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.44 = type { i32 }
%union.anon.45 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.9 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.9 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.16, i32 }
%union.anon.16 = type { i8* }
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t, i32, i32, i8*, %struct.lockdep_map }
%union.arch_rwlock_t = type { i64 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.17, %union.anon.23, %union.anon.25, i64 }
%struct.anon.17 = type { %union.anon.18, %union.anon.19 }
%union.anon.18 = type { i64 }
%union.anon.19 = type { i64 }
%union.anon.23 = type { %struct.list_head }
%union.anon.25 = type { i64 }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %struct.atomic_t, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.12, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.13, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.14, %union.anon.15 }
%union.anon.12 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.13 = type { i64 }
%union.anon.14 = type { %struct.list_head }
%union.anon.15 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.28 }
%union.anon.28 = type { %struct.anon.29 }
%struct.anon.29 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.31, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.34 }
%union.anon.31 = type { %struct.anon.32 }
%struct.anon.32 = type { i64, i64 }
%union.anon.34 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.36 }
%union.anon.36 = type { %struct.anon.40, [80 x i8] }
%struct.anon.40 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.module_ref = type { i64, i64 }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.dma_attrs*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.dma_attrs = type { [1 x i64] }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.sony_pic_irq = type { %struct.acpi_resource_irq, %struct.list_head }
%struct.acpi_resource_irq = type { i8, i8, i8, i8, i8, i8, [1 x i8] }
%struct.sony_pic_ioport = type { %struct.acpi_resource_io, %struct.acpi_resource_io, %struct.list_head }
%struct.acpi_resource_io = type <{ i8, i8, i8, i16, i16 }>
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.sonypi_eventtypes = type { i8, i64, %struct.sonypi_event* }
%struct.sonypi_event = type { i8, i8 }
%struct.sony_backlight_props = type { %struct.backlight_device*, i32, i32, i8, i8 }
%struct.backlight_device = type { %struct.backlight_properties, %struct.mutex, %struct.mutex, %struct.backlight_ops*, %struct.notifier_block, %struct.device }
%struct.backlight_properties = type { i32, i32, i32, i32, i32, i32 }
%struct.backlight_ops = type { i32, i32 (%struct.backlight_device*)*, i32 (%struct.backlight_device*)*, i32 (%struct.backlight_device*, %struct.fb_info*)* }
%struct.fb_info = type opaque
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.pv_irq_ops = type { %struct.paravirt_callee_save, %struct.paravirt_callee_save, %struct.paravirt_callee_save, %struct.paravirt_callee_save, void ()*, void ()*, void ()* }
%struct.paravirt_callee_save = type { i8* }
%struct.pv_cpu_ops = type { i64 (i32)*, void (i32, i64)*, void ()*, i64 ()*, void (i64)*, i64 ()*, i64 ()*, void (i64)*, i64 ()*, void (i64)*, void ()*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (i8*, i32)*, i64 ()*, void (%struct.thread_struct*, i32)*, void (i32)*, void (%struct.desc_struct*, i32, i8*)*, void (%struct.desc_struct*, i32, i8*, i32)*, void (%struct.gate_struct64*, i32, %struct.gate_struct64*)*, void (%struct.desc_struct*, i32)*, void (%struct.desc_struct*, i32)*, void (%struct.tss_struct*, %struct.thread_struct*)*, void (i32)*, void ()*, void ()*, void (i32*, i32*, i32*, i32*)*, i64 (i32, i32*)*, i32 (i32, i32, i32)*, i64 ()*, i64 (i32)*, i64 (i32*)*, void ()*, void ()*, void ()*, void ()*, void ()*, void (%struct.task_struct*)*, void (%struct.task_struct*)* }
%struct.desc_ptr = type <{ i16, i64 }>
%struct.gate_struct64 = type { i16, i16, i16, i16, i32, i32 }
%struct.tss_struct = type { %struct.x86_hw_tss, [1025 x i64], [64 x i64], [56 x i8] }
%struct.x86_hw_tss = type <{ i32, i64, i64, i64, i64, [7 x i64], i32, i32, i16, i16, [24 x i8] }>
%struct.dmi_system_id = type { {}*, i8*, [4 x %struct.dmi_strmatch], i8* }
%struct.dmi_strmatch = type { i8, [79 x i8] }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, %struct.mfd_cell*, %struct.pdev_archdata }
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.mfd_cell = type opaque
%struct.pdev_archdata = type {}
%struct.sony_laptop_input_s = type { %struct.atomic_t, %struct.input_dev*, %struct.input_dev*, %struct.kfifo, %struct.spinlock, %struct.timer_list }
%struct.input_dev = type { i8*, i8*, i8*, %struct.input_id, [1 x i64], [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i32, i32, i32, i8*, i32 (%struct.input_dev*, %struct.input_keymap_entry*, i32*)*, i32 (%struct.input_dev*, %struct.input_keymap_entry*)*, %struct.ff_device*, i32, %struct.timer_list, [2 x i32], %struct.input_mt*, %struct.input_absinfo*, [12 x i64], [1 x i64], [1 x i64], [1 x i64], i32 (%struct.input_dev*)*, void (%struct.input_dev*)*, i32 (%struct.input_dev*, %struct.file*)*, i32 (%struct.input_dev*, i32, i32, i32)*, %struct.input_handle*, %struct.spinlock, %struct.mutex, i32, i8, %struct.device, %struct.list_head, %struct.list_head, i32, i32, %struct.input_value*, i8 }
%struct.input_id = type { i16, i16, i16, i16 }
%struct.input_keymap_entry = type { i8, i8, i16, i32, [32 x i8] }
%struct.ff_device = type { i32 (%struct.input_dev*, %struct.ff_effect*, %struct.ff_effect*)*, i32 (%struct.input_dev*, i32)*, i32 (%struct.input_dev*, i32, i32)*, void (%struct.input_dev*, i16)*, void (%struct.input_dev*, i16)*, void (%struct.ff_device*)*, i8*, [2 x i64], %struct.mutex, i32, %struct.ff_effect*, [0 x %struct.file*] }
%struct.ff_effect = type { i16, i16, i16, %struct.ff_trigger, %struct.ff_replay, %union.anon.57 }
%struct.ff_trigger = type { i16, i16 }
%struct.ff_replay = type { i16, i16 }
%union.anon.57 = type { %struct.ff_periodic_effect }
%struct.ff_periodic_effect = type { i16, i16, i16, i16, i16, %struct.ff_envelope, i32, i16* }
%struct.ff_envelope = type { i16, i16, i16, i16 }
%struct.input_mt = type opaque
%struct.input_absinfo = type { i32, i32, i32, i32, i32, i32 }
%struct.input_handle = type { i8*, i32, i8*, %struct.input_dev*, %struct.input_handler*, %struct.list_head, %struct.list_head }
%struct.input_handler = type { i8*, void (%struct.input_handle*, i32, i32, i32)*, void (%struct.input_handle*, %struct.input_value*, i32)*, i1 (%struct.input_handle*, i32, i32, i32)*, i1 (%struct.input_handler*, %struct.input_dev*)*, i32 (%struct.input_handler*, %struct.input_dev*, %struct.input_device_id*)*, void (%struct.input_handle*)*, void (%struct.input_handle*)*, i8, i32, i8*, %struct.input_device_id*, %struct.list_head, %struct.list_head }
%struct.input_device_id = type { i64, i16, i16, i16, i16, [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i64 }
%struct.input_value = type { i16, i16, i32 }
%struct.kfifo = type { %union.anon.58, [0 x i8] }
%union.anon.58 = type { %struct.__kfifo }
%struct.__kfifo = type { i32, i32, i32, i32, i8* }
%struct.sonypi_compat_s = type { %struct.fasync_struct*, %struct.kfifo, %struct.spinlock, %struct.__wait_queue_head, %struct.atomic_t }
%struct.miscdevice = type { i32, i8*, %struct.file_operations*, %struct.list_head, %struct.device*, %struct.device*, i8*, i16 }
%struct.acpi_buffer = type { i64, i8* }
%struct.platform_driver = type { i32 (%struct.platform_device*)*, i32 (%struct.platform_device*)*, void (%struct.platform_device*)*, i32 (%struct.platform_device*, i32)*, i32 (%struct.platform_device*)*, %struct.device_driver, %struct.platform_device_id* }
%struct.sony_nc_value = type { i8*, i8**, i8**, i32 (i32, i32)*, i32, i32, i32, %struct.device_attribute }
%struct.sony_nc_handles = type { [16 x i16], %struct.device_attribute }
%struct.touchpad_control = type { %struct.device_attribute, i32 }
%struct.battery_care_control = type { [2 x %struct.device_attribute], i32 }
%struct.snc_lid_resume_control = type { [3 x %struct.device_attribute], i32 }
%struct.snc_thermal_ctrl = type { i32, i32, %struct.device_attribute, %struct.device_attribute }
%struct.snc_gfx_switch_control = type { %struct.device_attribute, i32 }
%struct.rfkill = type opaque
%struct.rfkill_ops = type { void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)*, i32 (i8*, i1)* }
%struct.kbd_backlight = type { i32, i32, i32, i32, %struct.device_attribute, %struct.device_attribute }
%struct.sony_nc_event = type { i8, i8 }
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, %struct.memcg_cache_params*, i32, i32, [1024 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page*, [26 x i32] }
%struct.kmem_cache_order_objects = type { i64 }
%struct.memcg_cache_params = type { i8, %union.anon.26 }
%union.anon.26 = type { %struct.anon.27 }
%struct.anon.27 = type { %struct.mem_cgroup*, %struct.list_head, %struct.kmem_cache*, i8, %struct.atomic_t, %struct.work_struct }
%struct.kmem_cache_node = type opaque
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, [6 x i8], %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, i16, i8, i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, [3 x i8], i16, [2 x i8], %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], %struct.list_head, %struct.kset*, %struct.pci_vpd*, %union.anon.56, %struct.pci_ats*, i64, i64 }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.pci_ops = type { i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.pci_dynids }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)* }
%struct.pci_dynids = type { %struct.spinlock, %struct.list_head }
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.56 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_ats = type opaque
%struct.anon.63 = type { %struct.acpi_resource, %struct.acpi_resource, %struct.acpi_resource, %struct.acpi_resource }
%struct.acpi_resource = type { i32, i32, %union.acpi_resource_data }
%union.acpi_resource_data = type { %struct.acpi_resource_vendor_typed, [40 x i8] }
%struct.acpi_resource_vendor_typed = type { i16, i8, [16 x i8], [1 x i8] }
%struct.acpi_object_list = type { i32, %union.acpi_object* }
%struct.sony_laptop_keypress = type { %struct.input_dev*, i32 }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.mm_segment_t, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.map_segment = type opaque
%struct.mm_segment_t = type { i64 }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.59 }
%union.anon.59 = type { %struct.anon.60 }
%struct.anon.60 = type { i32*, i32, i32, i32, i64, i32* }
%struct.anon.47 = type { i32, i64 }
%struct.acpi_device_info = type { i32, i32, i32, i8, i8, i8, [4 x i8], [5 x i8], i32, i64, %struct.acpi_pnp_device_id, %struct.acpi_pnp_device_id, %struct.acpi_pnp_device_id, %struct.acpi_pnp_device_id_list }
%struct.acpi_pnp_device_id = type { i32, i8* }
%struct.acpi_pnp_device_id_list = type { i32, i32, [1 x %struct.acpi_pnp_device_id] }
%struct.anon.49 = type { i32, i32, i8* }

@__UNIQUE_ID_author91 = internal constant [35 x i8] c"author=Stelian Pop, Mattia Dongili\00", section ".modinfo", align 1
@__UNIQUE_ID_description92 = internal constant [65 x i8] c"description=Sony laptop extras driver (SPIC and SNC ACPI device)\00", section ".modinfo", align 1
@__UNIQUE_ID_license93 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__UNIQUE_ID_version94 = internal constant [12 x i8] c"version=0.6\00", section ".modinfo", align 1
@__param_str_debug = internal constant [6 x i8] c"debug\00", align 1
@param_ops_int = external global %struct.kernel_param_ops, align 8
@debug = internal global i32 0, align 4
@__param_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_debug, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 0, i16 -1, %union.anon.6 { i8* bitcast (i32* @debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_debugtype97 = internal constant [19 x i8] c"parmtype=debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_debug99 = internal constant [87 x i8] c"parm=debug:set this to 1 (and RTFM) if you want to help the development of this driver\00", section ".modinfo", align 1
@__param_str_no_spic = internal constant [8 x i8] c"no_spic\00", align 1
@no_spic = internal global i32 0, align 4
@__param_no_spic = internal constant %struct.kernel_param { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @__param_str_no_spic, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.6 { i8* bitcast (i32* @no_spic to i8*) } }, section "__param", align 8
@__UNIQUE_ID_no_spictype102 = internal constant [21 x i8] c"parmtype=no_spic:int\00", section ".modinfo", align 1
@__UNIQUE_ID_no_spic104 = internal constant [66 x i8] c"parm=no_spic:set this if you don't want to enable the SPIC device\00", section ".modinfo", align 1
@__param_str_compat = internal constant [7 x i8] c"compat\00", align 1
@compat = internal global i32 0, align 4
@__param_compat = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_compat, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.6 { i8* bitcast (i32* @compat to i8*) } }, section "__param", align 8
@__UNIQUE_ID_compattype107 = internal constant [20 x i8] c"parmtype=compat:int\00", section ".modinfo", align 1
@__UNIQUE_ID_compat109 = internal constant [71 x i8] c"parm=compat:set this if you want to enable backward compatibility mode\00", section ".modinfo", align 1
@__param_str_mask = internal constant [5 x i8] c"mask\00", align 1
@param_ops_ulong = external global %struct.kernel_param_ops, align 8
@mask = internal global i64 4294967295, align 8
@__param_mask = internal constant %struct.kernel_param { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @__param_str_mask, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_ulong, i16 420, i16 -1, %union.anon.6 { i8* bitcast (i64* @mask to i8*) } }, section "__param", align 8
@__UNIQUE_ID_masktype112 = internal constant [20 x i8] c"parmtype=mask:ulong\00", section ".modinfo", align 1
@__UNIQUE_ID_mask114 = internal constant [69 x i8] c"parm=mask:set this to the mask of event you want to enable (see doc)\00", section ".modinfo", align 1
@__param_str_camera = internal constant [7 x i8] c"camera\00", align 1
@camera = internal global i32 0, align 4
@__param_camera = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_camera, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.6 { i8* bitcast (i32* @camera to i8*) } }, section "__param", align 8
@__UNIQUE_ID_cameratype117 = internal constant [20 x i8] c"parmtype=camera:int\00", section ".modinfo", align 1
@__UNIQUE_ID_camera120 = internal constant [110 x i8] c"parm=camera:set this to 1 to enable Motion Eye camera controls (only use it if you have a C1VE or C1VN model)\00", section ".modinfo", align 1
@__param_str_minor = internal constant [6 x i8] c"minor\00", align 1
@minor = internal global i32 -1, align 4
@__param_minor = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_minor, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 0, i16 -1, %union.anon.6 { i8* bitcast (i32* @minor to i8*) } }, section "__param", align 8
@__UNIQUE_ID_minortype124 = internal constant [19 x i8] c"parmtype=minor:int\00", section ".modinfo", align 1
@__UNIQUE_ID_minor127 = internal constant [102 x i8] c"parm=minor:minor number of the misc device for the SPIC compatibility code, default is -1 (automatic)\00", section ".modinfo", align 1
@__param_str_kbd_backlight = internal constant [14 x i8] c"kbd_backlight\00", align 1
@kbd_backlight = internal global i32 1, align 4
@__param_kbd_backlight = internal constant %struct.kernel_param { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__param_str_kbd_backlight, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.6 { i8* bitcast (i32* @kbd_backlight to i8*) } }, section "__param", align 8
@__UNIQUE_ID_kbd_backlighttype131 = internal constant [27 x i8] c"parmtype=kbd_backlight:int\00", section ".modinfo", align 1
@__UNIQUE_ID_kbd_backlight134 = internal constant [92 x i8] c"parm=kbd_backlight:set this to 0 to disable keyboard backlight, 1 to enable it (default: 0)\00", section ".modinfo", align 1
@__param_str_kbd_backlight_timeout = internal constant [22 x i8] c"kbd_backlight_timeout\00", align 16
@kbd_backlight_timeout = internal global i32 0, align 4
@__param_kbd_backlight_timeout = internal constant %struct.kernel_param { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__param_str_kbd_backlight_timeout, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.6 { i8* bitcast (i32* @kbd_backlight_timeout to i8*) } }, section "__param", align 8
@__UNIQUE_ID_kbd_backlight_timeouttype137 = internal constant [35 x i8] c"parmtype=kbd_backlight_timeout:int\00", section ".modinfo", align 1
@__UNIQUE_ID_kbd_backlight_timeout141 = internal constant [153 x i8] c"parm=kbd_backlight_timeout:set this to 0 to set the default 10 seconds timeout, 1 for 30 seconds, 2 for 60 seconds and 3 to disable timeout (default: 0)\00", section ".modinfo", align 1
@spic_dev = internal global %struct.sony_pic_dev { %struct.acpi_device* null, %struct.sony_pic_irq* null, %struct.sony_pic_ioport* null, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 24) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 24) to %struct.list_head*) }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 40) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*), i64 40) to %struct.list_head*) }, %struct.mutex zeroinitializer, %struct.sonypi_eventtypes* null, i32 (i8, i8)* null, i32 0, i16 0, i8 0, i8 0, i8 0 }, align 8
@.str = private unnamed_addr constant [52 x i8] c"\014sony_laptop: command failed at %s : %s (line %d)\0A\00", align 1
@.str.1 = private unnamed_addr constant [35 x i8] c"drivers/platform/x86/sony-laptop.c\00", align 1
@__func__.sony_pic_camera_command = private unnamed_addr constant [24 x i8] c"sony_pic_camera_command\00", align 1
@.str.2 = private unnamed_addr constant [52 x i8] c"\013sony_laptop: sony_pic_camera_command invalid: %d\0A\00", align 1
@__crc_sony_pic_camera_command = extern_weak global i8*, align 8
@__kcrctab_sony_pic_camera_command = internal constant i64 ptrtoint (i8** @__crc_sony_pic_camera_command to i64), section "___kcrctab+sony_pic_camera_command", align 8
@__kstrtab_sony_pic_camera_command = internal constant [24 x i8] c"sony_pic_camera_command\00", section "__ksymtab_strings", align 1
@__ksymtab_sony_pic_camera_command = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, i8)* @sony_pic_camera_command to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_sony_pic_camera_command, i32 0, i32 0) }, section "___ksymtab+sony_pic_camera_command", align 8
@sony_bl_props = common global %struct.sony_backlight_props zeroinitializer, align 8
@smp_ops = external global %struct.smp_ops, align 8
@pv_irq_ops = external global %struct.pv_irq_ops, align 8
@.str.3 = private unnamed_addr constant [60 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/paravirt.h\00", align 1
@current_task = external global %struct.task_struct*, align 8
@sony_device_ids = internal constant [3 x %struct.acpi_device_id] [%struct.acpi_device_id { [9 x i8] c"SNY5001\00\00", i64 0 }, %struct.acpi_device_id { [9 x i8] c"SNY6001\00\00", i64 0 }, %struct.acpi_device_id zeroinitializer], align 16
@.str.5 = private unnamed_addr constant [43 x i8] c"\014sony_laptop: camera control not enabled\0A\00", align 1
@.str.6 = private unnamed_addr constant [42 x i8] c"\014sony_laptop: failed to power on camera\0A\00", align 1
@__func__.__sony_pic_camera_on = private unnamed_addr constant [21 x i8] c"__sony_pic_camera_on\00", align 1
@__func__.sony_pic_call2 = private unnamed_addr constant [15 x i8] c"sony_pic_call2\00", align 1
@.str.7 = private unnamed_addr constant [56 x i8] c"\014sony_laptop: sony_pic_call2(0x%.2x - 0x%.2x): 0x%.4x\0A\00", align 1
@pv_cpu_ops = external global %struct.pv_cpu_ops, align 8
@__func__.sony_pic_call1 = private unnamed_addr constant [15 x i8] c"sony_pic_call1\00", align 1
@.str.8 = private unnamed_addr constant [47 x i8] c"\014sony_laptop: sony_pic_call1(0x%.2x): 0x%.4x\0A\00", align 1
@__func__.__sony_pic_camera_off = private unnamed_addr constant [22 x i8] c"__sony_pic_camera_off\00", align 1
@__func__.sony_pic_call3 = private unnamed_addr constant [15 x i8] c"sony_pic_call3\00", align 1
@.str.9 = private unnamed_addr constant [65 x i8] c"\014sony_laptop: sony_pic_call3(0x%.2x - 0x%.2x - 0x%.2x): 0x%.4x\0A\00", align 1
@sony_pic_driver = internal global %struct.acpi_driver { [80 x i8] c"Sony Programmable IO Control Driver\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [80 x i8] c"sony-pic\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", %struct.acpi_device_id* getelementptr inbounds ([2 x %struct.acpi_device_id], [2 x %struct.acpi_device_id]* @sony_pic_device_ids, i32 0, i32 0), i32 0, %struct.acpi_device_ops { i32 (%struct.acpi_device*)* @sony_pic_add, i32 (%struct.acpi_device*)* @sony_pic_remove, void (%struct.acpi_device*, i32)* null }, %struct.device_driver { i8* null, %struct.bus_type* null, %struct.module* null, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* @sony_pic_pm, %struct.driver_private* null }, %struct.module* @__this_module }, align 8
@.str.10 = private unnamed_addr constant [47 x i8] c"\013sony_laptop: Unable to register SPIC driver\0A\00", align 1
@spic_drv_registered = internal global i32 0, align 4
@sony_nc_driver = internal global %struct.acpi_driver { [80 x i8] c"Sony Notebook Control Driver\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [80 x i8] c"sony-nc\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", %struct.acpi_device_id* getelementptr inbounds ([2 x %struct.acpi_device_id], [2 x %struct.acpi_device_id]* @sony_nc_device_ids, i32 0, i32 0), i32 0, %struct.acpi_device_ops { i32 (%struct.acpi_device*)* @sony_nc_add, i32 (%struct.acpi_device*)* @sony_nc_remove, void (%struct.acpi_device*, i32)* @sony_nc_notify }, %struct.device_driver { i8* null, %struct.bus_type* null, %struct.module* null, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* @sony_nc_pm, %struct.driver_private* null }, %struct.module* @__this_module }, align 8
@.str.11 = private unnamed_addr constant [46 x i8] c"\013sony_laptop: Unable to register SNC driver\0A\00", align 1
@.str.12 = private unnamed_addr constant [10 x i8] c"Sony Vaio\00", align 1
@sonypi_dmi_table = internal global <{ { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } }> <{ { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } { i32 (%struct.dmi_system_id*)* null, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12, i32 0, i32 0), [4 x %struct.dmi_strmatch] [%struct.dmi_strmatch { i8 4, [79 x i8] c"Sony Corporation\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch { i8 5, [79 x i8] c"PCG-\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch zeroinitializer, %struct.dmi_strmatch zeroinitializer], i8* null }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } { i32 (%struct.dmi_system_id*)* null, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12, i32 0, i32 0), [4 x %struct.dmi_strmatch] [%struct.dmi_strmatch { i8 4, [79 x i8] c"Sony Corporation\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch { i8 5, [79 x i8] c"VGN-\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, %struct.dmi_strmatch zeroinitializer, %struct.dmi_strmatch zeroinitializer], i8* null }, { i32 (%struct.dmi_system_id*)*, i8*, [4 x %struct.dmi_strmatch], i8* } zeroinitializer }>, section ".init.data", align 16
@sony_pic_device_ids = internal constant [2 x %struct.acpi_device_id] [%struct.acpi_device_id { [9 x i8] c"SNY6001\00\00", i64 0 }, %struct.acpi_device_id zeroinitializer], align 16
@sony_pic_pm = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* @sony_pic_suspend, i32 (%struct.device*)* @sony_pic_resume, i32 (%struct.device*)* @sony_pic_suspend, i32 (%struct.device*)* @sony_pic_resume, i32 (%struct.device*)* @sony_pic_suspend, i32 (%struct.device*)* @sony_pic_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null }, align 8
@__this_module = external global %struct.module, align 8
@.str.14 = private unnamed_addr constant [23 x i8] c"\016sony_laptop: %s v%s\0A\00", align 1
@.str.15 = private unnamed_addr constant [36 x i8] c"Sony Programmable IO Control Driver\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"0.6\00", align 1
@.str.17 = private unnamed_addr constant [12 x i8] c"sony/hotkey\00", align 1
@sony_pic_add.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.18 = private unnamed_addr constant [15 x i8] c"&spic_dev.lock\00", align 1
@.str.19 = private unnamed_addr constant [50 x i8] c"\013sony_laptop: Unable to read possible resources\0A\00", align 1
@.str.20 = private unnamed_addr constant [47 x i8] c"\013sony_laptop: Unable to create input devices\0A\00", align 1
@ioport_resource = external global %struct.resource, align 8
@.str.21 = private unnamed_addr constant [29 x i8] c"Sony Programmable I/O Device\00", align 1
@.str.22 = private unnamed_addr constant [52 x i8] c"\014sony_laptop: I/O port1: 0x%.4x (0x%.4x) + 0x%.2x\0A\00", align 1
@.str.23 = private unnamed_addr constant [52 x i8] c"\014sony_laptop: I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\0A\00", align 1
@.str.24 = private unnamed_addr constant [66 x i8] c"\014sony_laptop: Unable to get I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\0A\00", align 1
@.str.25 = private unnamed_addr constant [41 x i8] c"\013sony_laptop: Failed to request_region\0A\00", align 1
@.str.26 = private unnamed_addr constant [12 x i8] c"sony-laptop\00", align 1
@.str.27 = private unnamed_addr constant [66 x i8] c"\014sony_laptop: IRQ: %d - triggering: %d - polarity: %d - shr: %d\0A\00", align 1
@.str.28 = private unnamed_addr constant [38 x i8] c"\013sony_laptop: Failed to request_irq\0A\00", align 1
@.str.29 = private unnamed_addr constant [39 x i8] c"\013sony_laptop: Couldn't enable device\0A\00", align 1
@sony_pf_device = internal global %struct.platform_device* null, align 8
@spic_attribute_group = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([4 x %struct.attribute*], [4 x %struct.attribute*]* @spic_attributes, i32 0, i32 0) }, align 8
@type1_events = internal global [11 x %struct.sonypi_eventtypes] [%struct.sonypi_eventtypes { i8 0, i64 4294967295, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_releaseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 112, i64 1024, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_meyeev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 48, i64 128, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_lidev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 96, i64 2, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_captureev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 16, i64 1, %struct.sonypi_event* getelementptr inbounds ([14 x %struct.sonypi_event], [14 x %struct.sonypi_event]* @sonypi_joggerev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 32, i64 4, %struct.sonypi_event* getelementptr inbounds ([23 x %struct.sonypi_event], [23 x %struct.sonypi_event]* @sonypi_fnkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 48, i64 8, %struct.sonypi_event* getelementptr inbounds ([4 x %struct.sonypi_event], [4 x %struct.sonypi_event]* @sonypi_blueev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 64, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 48, i64 2048, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_memorystickev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 64, i64 4096, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_batteryev, i32 0, i32 0) }, %struct.sonypi_eventtypes zeroinitializer], align 16
@type2_events = internal global [15 x %struct.sonypi_eventtypes] [%struct.sonypi_eventtypes { i8 0, i64 4294967295, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_releaseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 56, i64 128, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_lidev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 17, i64 1, %struct.sonypi_event* getelementptr inbounds ([14 x %struct.sonypi_event], [14 x %struct.sonypi_event]* @sonypi_joggerev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 97, i64 2, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_captureev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 4, %struct.sonypi_event* getelementptr inbounds ([23 x %struct.sonypi_event], [23 x %struct.sonypi_event]* @sonypi_fnkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 8, %struct.sonypi_event* getelementptr inbounds ([4 x %struct.sonypi_event], [4 x %struct.sonypi_event]* @sonypi_blueev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 8, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 17, i64 32, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_backev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 64, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_helpev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 256, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_zoomev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 32, i64 512, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_thumbphraseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 2048, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_memorystickev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 65, i64 4096, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_batteryev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes zeroinitializer], align 16
@type3_events = internal global [12 x %struct.sonypi_eventtypes] [%struct.sonypi_eventtypes { i8 0, i64 4294967295, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_releaseev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 33, i64 4, %struct.sonypi_event* getelementptr inbounds ([23 x %struct.sonypi_event], [23 x %struct.sonypi_event]* @sonypi_fnkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 8192, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_wlessev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 2048, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_memorystickev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 65, i64 4096, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_batteryev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 49, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 16, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_pkeyev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 256, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_zoomev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 2, %struct.sonypi_event* getelementptr inbounds ([5 x %struct.sonypi_event], [5 x %struct.sonypi_event]* @sonypi_captureev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 16, %struct.sonypi_event* getelementptr inbounds ([3 x %struct.sonypi_event], [3 x %struct.sonypi_event]* @sonypi_volumeev, i32 0, i32 0) }, %struct.sonypi_eventtypes { i8 5, i64 16, %struct.sonypi_event* getelementptr inbounds ([2 x %struct.sonypi_event], [2 x %struct.sonypi_event]* @sonypi_brightnessev, i32 0, i32 0) }, %struct.sonypi_eventtypes zeroinitializer], align 16
@.str.30 = private unnamed_addr constant [38 x i8] c"\016sony_laptop: detected Type%d model\0A\00", align 1
@sonypi_releaseev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 0, i8 56 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_meyeev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 0, i8 52 }, %struct.sonypi_event { i8 1, i8 53 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_lidev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 81, i8 36 }, %struct.sonypi_event { i8 80, i8 37 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_captureev = internal global [5 x %struct.sonypi_event] [%struct.sonypi_event { i8 5, i8 9 }, %struct.sonypi_event { i8 7, i8 7 }, %struct.sonypi_event { i8 64, i8 7 }, %struct.sonypi_event { i8 1, i8 10 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_joggerev = internal global [14 x %struct.sonypi_event] [%struct.sonypi_event { i8 31, i8 2 }, %struct.sonypi_event { i8 1, i8 1 }, %struct.sonypi_event { i8 95, i8 4 }, %struct.sonypi_event { i8 65, i8 3 }, %struct.sonypi_event { i8 30, i8 43 }, %struct.sonypi_event { i8 2, i8 42 }, %struct.sonypi_event { i8 94, i8 45 }, %struct.sonypi_event { i8 66, i8 44 }, %struct.sonypi_event { i8 29, i8 47 }, %struct.sonypi_event { i8 3, i8 46 }, %struct.sonypi_event { i8 93, i8 49 }, %struct.sonypi_event { i8 67, i8 48 }, %struct.sonypi_event { i8 64, i8 5 }, %struct.sonypi_event zeroinitializer], align 16
@sonypi_fnkeyev = internal global [23 x %struct.sonypi_event] [%struct.sonypi_event { i8 16, i8 11 }, %struct.sonypi_event { i8 17, i8 12 }, %struct.sonypi_event { i8 18, i8 13 }, %struct.sonypi_event { i8 19, i8 14 }, %struct.sonypi_event { i8 20, i8 15 }, %struct.sonypi_event { i8 21, i8 16 }, %struct.sonypi_event { i8 22, i8 17 }, %struct.sonypi_event { i8 23, i8 18 }, %struct.sonypi_event { i8 24, i8 19 }, %struct.sonypi_event { i8 25, i8 20 }, %struct.sonypi_event { i8 26, i8 21 }, %struct.sonypi_event { i8 27, i8 22 }, %struct.sonypi_event { i8 28, i8 23 }, %struct.sonypi_event { i8 31, i8 59 }, %struct.sonypi_event { i8 33, i8 24 }, %struct.sonypi_event { i8 34, i8 25 }, %struct.sonypi_event { i8 49, i8 26 }, %struct.sonypi_event { i8 50, i8 27 }, %struct.sonypi_event { i8 51, i8 28 }, %struct.sonypi_event { i8 52, i8 29 }, %struct.sonypi_event { i8 53, i8 30 }, %struct.sonypi_event { i8 54, i8 41 }, %struct.sonypi_event zeroinitializer], align 16
@sonypi_blueev = internal global [4 x %struct.sonypi_event] [%struct.sonypi_event { i8 85, i8 31 }, %struct.sonypi_event { i8 89, i8 38 }, %struct.sonypi_event { i8 90, i8 39 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_pkeyev = internal global [5 x %struct.sonypi_event] [%struct.sonypi_event { i8 1, i8 32 }, %struct.sonypi_event { i8 2, i8 33 }, %struct.sonypi_event { i8 4, i8 34 }, %struct.sonypi_event { i8 32, i8 32 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_memorystickev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 83, i8 54 }, %struct.sonypi_event { i8 84, i8 55 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_batteryev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 32, i8 57 }, %struct.sonypi_event { i8 48, i8 58 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_backev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 32, i8 35 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_helpev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 59, i8 40 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_zoomev = internal global [5 x %struct.sonypi_event] [%struct.sonypi_event { i8 57, i8 50 }, %struct.sonypi_event { i8 16, i8 62 }, %struct.sonypi_event { i8 32, i8 63 }, %struct.sonypi_event { i8 4, i8 50 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_thumbphraseev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 58, i8 51 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_wlessev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 89, i8 0 }, %struct.sonypi_event { i8 90, i8 0 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_volumeev = internal global [3 x %struct.sonypi_event] [%struct.sonypi_event { i8 1, i8 69 }, %struct.sonypi_event { i8 2, i8 70 }, %struct.sonypi_event zeroinitializer], align 1
@sonypi_brightnessev = internal global [2 x %struct.sonypi_event] [%struct.sonypi_event { i8 -128, i8 71 }, %struct.sonypi_event zeroinitializer], align 1
@.str.31 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Evaluating _STA\0A\00", align 1
@.str.32 = private unnamed_addr constant [38 x i8] c"\014sony_laptop: Unable to read status\0A\00", align 1
@.str.33 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Device disabled\0A\00", align 1
@.str.34 = private unnamed_addr constant [31 x i8] c"\014sony_laptop: Device enabled\0A\00", align 1
@.str.35 = private unnamed_addr constant [30 x i8] c"\014sony_laptop: Evaluating %s\0A\00", align 1
@.str.36 = private unnamed_addr constant [5 x i8] c"_PRS\00", align 1
@.str.37 = private unnamed_addr constant [38 x i8] c"\014sony_laptop: Failure evaluating %s\0A\00", align 1
@.str.38 = private unnamed_addr constant [35 x i8] c"\014sony_laptop: Blank IRQ resource\0A\00", align 1
@.str.39 = private unnamed_addr constant [31 x i8] c"\014sony_laptop: Invalid IRQ %d\0A\00", align 1
@.str.40 = private unnamed_addr constant [34 x i8] c"\014sony_laptop: Blank IO resource\0A\00", align 1
@.str.41 = private unnamed_addr constant [39 x i8] c"\014sony_laptop: IO1 at 0x%.4x (0x%.2x)\0A\00", align 1
@.str.42 = private unnamed_addr constant [39 x i8] c"\014sony_laptop: IO2 at 0x%.4x (0x%.2x)\0A\00", align 1
@.str.43 = private unnamed_addr constant [56 x i8] c"\013sony_laptop: Unknown SPIC Type, more than 2 IO Ports\0A\00", align 1
@.str.44 = private unnamed_addr constant [56 x i8] c"\014sony_laptop: Resource %d isn't an IRQ nor an IO port\0A\00", align 1
@sony_laptop_input = internal global %struct.sony_laptop_input_s zeroinitializer, align 8
@sony_laptop_setup_input.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.45 = private unnamed_addr constant [39 x i8] c"&(&sony_laptop_input.fifo_lock)->rlock\00", align 1
@.str.46 = private unnamed_addr constant [35 x i8] c"\013sony_laptop: kfifo_alloc failed\0A\00", align 1
@sony_laptop_setup_input.__key.47 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.48 = private unnamed_addr constant [41 x i8] c"((&sony_laptop_input.release_key_timer))\00", align 1
@.str.49 = private unnamed_addr constant [15 x i8] c"Sony Vaio Keys\00", align 1
@sony_laptop_input_keycode_map = internal global [60 x i32] [i32 212, i32 0, i32 0, i32 0, i32 465, i32 466, i32 467, i32 468, i32 469, i32 470, i32 471, i32 472, i32 473, i32 474, i32 475, i32 476, i32 477, i32 466, i32 467, i32 480, i32 481, i32 482, i32 483, i32 484, i32 237, i32 148, i32 149, i32 202, i32 158, i32 237, i32 237, i32 138, i32 464, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 372, i32 289, i32 0, i32 0, i32 0, i32 0, i32 238, i32 238, i32 418, i32 419, i32 161, i32 183, i32 203, i32 184, i32 185, i32 115, i32 114, i32 226, i32 360], align 16
@.str.50 = private unnamed_addr constant [18 x i8] c"Sony Vaio Jogdial\00", align 1
@jiffies = external global i64, align 8
@sonypi_compat = internal global %struct.sonypi_compat_s zeroinitializer, align 8
@sonypi_compat_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.51 = private unnamed_addr constant [35 x i8] c"&(&sonypi_compat.fifo_lock)->rlock\00", align 1
@sonypi_compat_init.__key.52 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.53 = private unnamed_addr constant [30 x i8] c"&sonypi_compat.fifo_proc_list\00", align 1
@sonypi_misc_device = internal global %struct.miscdevice { i32 255, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.56, i32 0, i32 0), %struct.file_operations* @sonypi_misc_fops, %struct.list_head zeroinitializer, %struct.device* null, %struct.device* null, i8* null, i16 0 }, align 8
@.str.54 = private unnamed_addr constant [37 x i8] c"\013sony_laptop: misc_register failed\0A\00", align 1
@.str.55 = private unnamed_addr constant [45 x i8] c"\016sony_laptop: device allocated minor is %d\0A\00", align 1
@.str.56 = private unnamed_addr constant [7 x i8] c"sonypi\00", align 1
@sonypi_misc_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @noop_llseek, i64 (%struct.file*, i8*, i64, i64*)* @sonypi_misc_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @sonypi_misc_poll, i64 (%struct.file*, i32, i64)* @sonypi_misc_ioctl, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @sonypi_misc_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @sonypi_misc_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* @sonypi_misc_fasync, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@sony_nc_acpi_handle = internal global i8* null, align 8
@.str.57 = private unnamed_addr constant [5 x i8] c"GBRT\00", align 1
@.str.58 = private unnamed_addr constant [5 x i8] c"SBRT\00", align 1
@.str.59 = private unnamed_addr constant [60 x i8] c"\014sony_laptop: Invalid acpi_object: expected 0x%x got 0x%x\0A\00", align 1
@__call_snc_method.output = private unnamed_addr constant %struct.acpi_buffer { i64 -1, i8* null }, align 8
@.str.60 = private unnamed_addr constant [51 x i8] c"\014sony_laptop: __call_snc_method: [%s:0x%.8x%.8x]\0A\00", align 1
@.str.61 = private unnamed_addr constant [40 x i8] c"\014sony_laptop: __call_snc_method: [%s]\0A\00", align 1
@.str.62 = private unnamed_addr constant [40 x i8] c"\013sony_laptop: Failed to evaluate [%s]\0A\00", align 1
@.str.63 = private unnamed_addr constant [38 x i8] c"\014sony_laptop: No return object [%s]\0A\00", align 1
@.str.64 = private unnamed_addr constant [62 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/uaccess_64.h\00", align 1
@.str.65 = private unnamed_addr constant [27 x i8] c"Buffer overflow detected!\0A\00", align 1
@.str.66 = private unnamed_addr constant [62 x i8] c"\014sony_laptop: event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\0A\00", align 1
@.str.67 = private unnamed_addr constant [70 x i8] c"\014sony_laptop: unknown event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\0A\00", align 1
@.str.68 = private unnamed_addr constant [68 x i8] c"\014sony_laptop: sony_laptop_report_input_event, event not known: %d\0A\00", align 1
@sony_laptop_input_index = internal global [74 x i32] [i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 -1, i32 -1, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 -1, i32 -1, i32 -1, i32 -1, i32 47, i32 48, i32 49, i32 50, i32 51, i32 52, i32 53, i32 54, i32 55, i32 56, i32 57, i32 -1, i32 58, i32 59], align 16
@.str.69 = private unnamed_addr constant [41 x i8] c"\014sony_laptop: unknown input event %.2x\0A\00", align 1
@.str.70 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Evaluating _SRS\0A\00", align 1
@.str.71 = private unnamed_addr constant [38 x i8] c"\013sony_laptop: Error evaluating _SRS\0A\00", align 1
@sony_pf_users = internal global %struct.atomic_t zeroinitializer, align 4
@sony_pf_driver = internal global %struct.platform_driver { i32 (%struct.platform_device*)* null, i32 (%struct.platform_device*)* null, void (%struct.platform_device*)* null, i32 (%struct.platform_device*, i32)* null, i32 (%struct.platform_device*)* null, %struct.device_driver { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.26, i32 0, i32 0), %struct.bus_type* null, %struct.module* @__this_module, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.platform_device_id* null }, align 8
@spic_attributes = internal global [4 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @spic_attr_bluetoothpower, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @spic_attr_wwanpower, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @spic_attr_fanspeed, i32 0, i32 0), %struct.attribute* null], align 16
@spic_attr_bluetoothpower = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.72, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_pic_bluetoothpower_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_pic_bluetoothpower_store }, align 8
@spic_attr_wwanpower = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.74, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_pic_wwanpower_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_pic_wwanpower_store }, align 8
@spic_attr_fanspeed = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.75, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_pic_fanspeed_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_pic_fanspeed_store }, align 8
@.str.72 = private unnamed_addr constant [15 x i8] c"bluetoothpower\00", align 1
@.str.73 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.74 = private unnamed_addr constant [10 x i8] c"wwanpower\00", align 1
@.str.75 = private unnamed_addr constant [9 x i8] c"fanspeed\00", align 1
@.str.76 = private unnamed_addr constant [5 x i8] c"_DIS\00", align 1
@.str.77 = private unnamed_addr constant [40 x i8] c"\013sony_laptop: Couldn't disable device\0A\00", align 1
@.str.78 = private unnamed_addr constant [61 x i8] c"\014sony_laptop: Sony Programmable IO Control Driver removed.\0A\00", align 1
@sony_nc_device_ids = internal constant [2 x %struct.acpi_device_id] [%struct.acpi_device_id { [9 x i8] c"SNY5001\00\00", i64 0 }, %struct.acpi_device_id zeroinitializer], align 16
@sony_nc_pm = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* @sony_nc_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* @sony_nc_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* @sony_nc_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null }, align 8
@.str.79 = private unnamed_addr constant [29 x i8] c"Sony Notebook Control Driver\00", align 1
@sony_nc_acpi_device = internal global %struct.acpi_device* null, align 8
@.str.80 = private unnamed_addr constant [35 x i8] c"\014sony_laptop: Device not present\0A\00", align 1
@.str.81 = private unnamed_addr constant [46 x i8] c"\014sony_laptop: unable to walk acpi resources\0A\00", align 1
@.str.82 = private unnamed_addr constant [5 x i8] c"ECON\00", align 1
@.str.83 = private unnamed_addr constant [35 x i8] c"\014sony_laptop: ECON Method failed\0A\00", align 1
@.str.84 = private unnamed_addr constant [5 x i8] c"SN00\00", align 1
@.str.85 = private unnamed_addr constant [32 x i8] c"\014sony_laptop: Doing SNC setup\0A\00", align 1
@.str.86 = private unnamed_addr constant [76 x i8] c"\016sony_laptop: brightness ignored, must be controlled by ACPI video driver\0A\00", align 1
@sony_nc_values = internal global [13 x %struct.sony_nc_value] [%struct.sony_nc_value { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.147, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_brightness_def_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_brightness_def_set, i32 0, i32 0), i32 (i32, i32)* @brightness_default_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.147, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.148, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_fnkey_get, i32 0, i32 0), i8** null, i32 (i32, i32)* null, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.148, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.149, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_cdpower_get, i32 0, i32 0), i8** getelementptr inbounds ([3 x i8*], [3 x i8*]* @snc_cdpower_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.149, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.150, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_audiopower_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_audiopower_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.150, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.151, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_lanpower_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_lanpower_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.151, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.152, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_lidstate_get, i32 0, i32 0), i8** null, i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.152, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.153, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_indicatorlamp_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_indicatorlamp_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.153, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.154, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_gainbass_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_gainbass_set, i32 0, i32 0), i32 (i32, i32)* @boolean_validate, i32 0, i32 0, i32 0, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.154, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.155, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_PID_get, i32 0, i32 0), i8** null, i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.155, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.156, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CTR_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CTR_set, i32 0, i32 0), i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.156, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.157, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_PCR_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_PCR_set, i32 0, i32 0), i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.157, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.158, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CMI_get, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @snc_CMI_set, i32 0, i32 0), i32 (i32, i32)* null, i32 0, i32 0, i32 1, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.158, i32 0, i32 0), i16 0, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_sysfs_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_sysfs_store } }, %struct.sony_nc_value zeroinitializer], align 16
@.str.87 = private unnamed_addr constant [36 x i8] c"\014sony_laptop: Found %s getter: %s\0A\00", align 1
@.str.88 = private unnamed_addr constant [36 x i8] c"\014sony_laptop: Found %s setter: %s\0A\00", align 1
@.str.89 = private unnamed_addr constant [45 x i8] c"\014sony_laptop: method: name: %4.4s, args %X\0A\00", align 1
@handles = internal global %struct.sony_nc_handles* null, align 8
@.str.90 = private unnamed_addr constant [55 x i8] c"\014sony_laptop: caching handle 0x%.4x (offset: 0x%.2x)\0A\00", align 1
@sony_nc_handles_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.91 = private unnamed_addr constant [8 x i8] c"handles\00", align 1
@.str.92 = private unnamed_addr constant [8 x i8] c"0x%.4x \00", align 1
@.str.93 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.94 = private unnamed_addr constant [41 x i8] c"\014sony_laptop: setting up handle 0x%.4x\0A\00", align 1
@.str.95 = private unnamed_addr constant [63 x i8] c"\013sony_laptop: couldn't set up touchpad control function (%d)\0A\00", align 1
@.str.96 = private unnamed_addr constant [59 x i8] c"\013sony_laptop: couldn't set up battery care function (%d)\0A\00", align 1
@.str.97 = private unnamed_addr constant [57 x i8] c"\013sony_laptop: couldn't set up lid resume function (%d)\0A\00", align 1
@.str.98 = private unnamed_addr constant [62 x i8] c"\013sony_laptop: couldn't set up thermal profile function (%d)\0A\00", align 1
@.str.99 = private unnamed_addr constant [55 x i8] c"\013sony_laptop: couldn't set up GFX Switch status (%d)\0A\00", align 1
@.str.100 = private unnamed_addr constant [66 x i8] c"\013sony_laptop: couldn't set up high speed charging function (%d)\0A\00", align 1
@.str.101 = private unnamed_addr constant [52 x i8] c"\013sony_laptop: couldn't set up rfkill support (%d)\0A\00", align 1
@.str.102 = private unnamed_addr constant [65 x i8] c"\013sony_laptop: couldn't set up keyboard backlight function (%d)\0A\00", align 1
@.str.103 = private unnamed_addr constant [5 x i8] c"SN02\00", align 1
@.str.104 = private unnamed_addr constant [5 x i8] c"SN07\00", align 1
@.str.105 = private unnamed_addr constant [57 x i8] c"\014sony_laptop: called SN07 with 0x%.4x (result: 0x%.4x)\0A\00", align 1
@.str.106 = private unnamed_addr constant [53 x i8] c"\014sony_laptop: found handle 0x%.4x (offset: 0x%.2x)\0A\00", align 1
@.str.107 = private unnamed_addr constant [40 x i8] c"\014sony_laptop: handle 0x%.4x not found\0A\00", align 1
@tp_ctl = internal global %struct.touchpad_control* null, align 8
@sony_nc_touchpad_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.108 = private unnamed_addr constant [9 x i8] c"touchpad\00", align 1
@bcare_ctl = internal global %struct.battery_care_control* null, align 8
@sony_nc_battery_care_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.109 = private unnamed_addr constant [21 x i8] c"battery_care_limiter\00", align 1
@sony_nc_battery_care_setup.__key.110 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.111 = private unnamed_addr constant [20 x i8] c"battery_care_health\00", align 1
@lid_ctl = internal global %struct.snc_lid_resume_control* null, align 8
@sony_nc_lid_resume_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.112 = private unnamed_addr constant [14 x i8] c"lid_resume_S3\00", align 1
@sony_nc_lid_resume_setup.__key.113 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.114 = private unnamed_addr constant [14 x i8] c"lid_resume_S4\00", align 1
@sony_nc_lid_resume_setup.__key.115 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.116 = private unnamed_addr constant [14 x i8] c"lid_resume_S5\00", align 1
@th_handle = internal global %struct.snc_thermal_ctrl* null, align 8
@.str.117 = private unnamed_addr constant [54 x i8] c"\014sony_laptop: couldn't to read the thermal profiles\0A\00", align 1
@.str.118 = private unnamed_addr constant [60 x i8] c"\014sony_laptop: couldn't to read the current thermal profile\00", align 1
@sony_nc_thermal_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.119 = private unnamed_addr constant [17 x i8] c"thermal_profiles\00", align 1
@sony_nc_thermal_setup.__key.120 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.121 = private unnamed_addr constant [16 x i8] c"thermal_control\00", align 1
@.str.122 = private unnamed_addr constant [4 x i8] c"%s \00", align 1
@snc_thermal_profiles = internal constant [3 x i8*] [i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.123, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.124, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.125, i32 0, i32 0)], align 16
@.str.123 = private unnamed_addr constant [9 x i8] c"balanced\00", align 1
@.str.124 = private unnamed_addr constant [7 x i8] c"silent\00", align 1
@.str.125 = private unnamed_addr constant [12 x i8] c"performance\00", align 1
@.str.126 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@gfxs_ctl = internal global %struct.snc_gfx_switch_control* null, align 8
@sony_nc_gfx_switch_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.127 = private unnamed_addr constant [18 x i8] c"gfx_switch_status\00", align 1
@.str.128 = private unnamed_addr constant [6 x i8] c"speed\00", align 1
@.str.129 = private unnamed_addr constant [8 x i8] c"stamina\00", align 1
@.str.130 = private unnamed_addr constant [33 x i8] c"\014sony_laptop: GFX Status: 0x%x\0A\00", align 1
@.str.131 = private unnamed_addr constant [56 x i8] c"\016sony_laptop: No High Speed Charging capability found\0A\00", align 1
@hsc_handle = internal global %struct.device_attribute* null, align 8
@sony_nc_highspeed_charging_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.132 = private unnamed_addr constant [27 x i8] c"battery_highspeed_charging\00", align 1
@sony_rfkill_handle = internal global i32 0, align 4
@.str.133 = private unnamed_addr constant [5 x i8] c"SN06\00", align 1
@.str.134 = private unnamed_addr constant [44 x i8] c"\014sony_laptop: Radio devices, found 0x%.2x\0A\00", align 1
@sony_rfkill_devices = internal global [4 x %struct.rfkill*] zeroinitializer, align 16
@.str.135 = private unnamed_addr constant [10 x i8] c"sony-wifi\00", align 1
@.str.136 = private unnamed_addr constant [15 x i8] c"sony-bluetooth\00", align 1
@.str.137 = private unnamed_addr constant [10 x i8] c"sony-wwan\00", align 1
@.str.138 = private unnamed_addr constant [11 x i8] c"sony-wimax\00", align 1
@sony_rfkill_ops = internal constant %struct.rfkill_ops { void (%struct.rfkill*, i8*)* null, void (%struct.rfkill*, i8*)* null, i32 (i8*, i1)* @sony_nc_rfkill_set }, align 8
@sony_rfkill_address = internal global [4 x i32] [i32 768, i32 1280, i32 1792, i32 2304], align 16
@.str.139 = private unnamed_addr constant [44 x i8] c"\014sony_laptop: no backlight keyboard found\0A\00", align 1
@kbdbl_ctl = internal global %struct.kbd_backlight* null, align 8
@sony_nc_kbd_backlight_setup.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.140 = private unnamed_addr constant [14 x i8] c"kbd_backlight\00", align 1
@sony_nc_kbd_backlight_setup.__key.141 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.142 = private unnamed_addr constant [22 x i8] c"kbd_backlight_timeout\00", align 1
@sony_backlight_ng_ops = internal constant %struct.backlight_ops { i32 1, i32 (%struct.backlight_device*)* @sony_nc_update_status_ng, i32 (%struct.backlight_device*)* @sony_nc_get_brightness_ng, i32 (%struct.backlight_device*, %struct.fb_info*)* null }, align 8
@sony_backlight_ops = internal constant %struct.backlight_ops { i32 1, i32 (%struct.backlight_device*)* @sony_backlight_update_status, i32 (%struct.backlight_device*)* @sony_backlight_get_brightness, i32 (%struct.backlight_device*, %struct.fb_info*)* null }, align 8
@.str.143 = private unnamed_addr constant [5 x i8] c"sony\00", align 1
@.str.144 = private unnamed_addr constant [52 x i8] c"\014sony_laptop: unable to register backlight device\0A\00", align 1
@.str.145 = private unnamed_addr constant [37 x i8] c"\014sony_laptop: Brightness level: %d\0A\00", align 1
@.str.146 = private unnamed_addr constant [49 x i8] c"\014sony_laptop: Brightness levels: min=%d max=%d\0A\00", align 1
@.str.147 = private unnamed_addr constant [19 x i8] c"brightness_default\00", align 1
@snc_brightness_def_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.159, i32 0, i32 0), i8* null], align 16
@snc_brightness_def_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.160, i32 0, i32 0), i8* null], align 16
@.str.148 = private unnamed_addr constant [6 x i8] c"fnkey\00", align 1
@snc_fnkey_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.161, i32 0, i32 0), i8* null], align 16
@.str.149 = private unnamed_addr constant [8 x i8] c"cdpower\00", align 1
@snc_cdpower_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.162, i32 0, i32 0), i8* null], align 16
@snc_cdpower_set = internal global [3 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.163, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.164, i32 0, i32 0), i8* null], align 16
@.str.150 = private unnamed_addr constant [11 x i8] c"audiopower\00", align 1
@snc_audiopower_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.165, i32 0, i32 0), i8* null], align 16
@snc_audiopower_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.166, i32 0, i32 0), i8* null], align 16
@.str.151 = private unnamed_addr constant [9 x i8] c"lanpower\00", align 1
@snc_lanpower_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.167, i32 0, i32 0), i8* null], align 16
@snc_lanpower_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.168, i32 0, i32 0), i8* null], align 16
@.str.152 = private unnamed_addr constant [9 x i8] c"lidstate\00", align 1
@snc_lidstate_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* null], align 16
@.str.153 = private unnamed_addr constant [14 x i8] c"indicatorlamp\00", align 1
@snc_indicatorlamp_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@snc_indicatorlamp_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.154 = private unnamed_addr constant [9 x i8] c"gainbass\00", align 1
@snc_gainbass_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.172, i32 0, i32 0), i8* null], align 16
@snc_gainbass_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.173, i32 0, i32 0), i8* null], align 16
@.str.155 = private unnamed_addr constant [4 x i8] c"PID\00", align 1
@snc_PID_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.174, i32 0, i32 0), i8* null], align 16
@.str.156 = private unnamed_addr constant [4 x i8] c"CTR\00", align 1
@snc_CTR_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.175, i32 0, i32 0), i8* null], align 16
@snc_CTR_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.176, i32 0, i32 0), i8* null], align 16
@.str.157 = private unnamed_addr constant [4 x i8] c"PCR\00", align 1
@snc_PCR_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.177, i32 0, i32 0), i8* null], align 16
@snc_PCR_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.178, i32 0, i32 0), i8* null], align 16
@.str.158 = private unnamed_addr constant [4 x i8] c"CMI\00", align 1
@snc_CMI_get = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.179, i32 0, i32 0), i8* null], align 16
@snc_CMI_set = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.180, i32 0, i32 0), i8* null], align 16
@.str.159 = private unnamed_addr constant [5 x i8] c"GPBR\00", align 1
@.str.160 = private unnamed_addr constant [5 x i8] c"SPBR\00", align 1
@.str.161 = private unnamed_addr constant [5 x i8] c"GHKE\00", align 1
@.str.162 = private unnamed_addr constant [5 x i8] c"GCDP\00", align 1
@.str.163 = private unnamed_addr constant [5 x i8] c"SCDP\00", align 1
@.str.164 = private unnamed_addr constant [5 x i8] c"CDPW\00", align 1
@.str.165 = private unnamed_addr constant [5 x i8] c"GAZP\00", align 1
@.str.166 = private unnamed_addr constant [5 x i8] c"AZPW\00", align 1
@.str.167 = private unnamed_addr constant [5 x i8] c"GLNP\00", align 1
@.str.168 = private unnamed_addr constant [5 x i8] c"LNPW\00", align 1
@.str.169 = private unnamed_addr constant [5 x i8] c"GLID\00", align 1
@.str.170 = private unnamed_addr constant [5 x i8] c"GILS\00", align 1
@.str.171 = private unnamed_addr constant [5 x i8] c"SILS\00", align 1
@.str.172 = private unnamed_addr constant [5 x i8] c"GMGB\00", align 1
@.str.173 = private unnamed_addr constant [5 x i8] c"CMGB\00", align 1
@.str.174 = private unnamed_addr constant [5 x i8] c"GPID\00", align 1
@.str.175 = private unnamed_addr constant [5 x i8] c"GCTR\00", align 1
@.str.176 = private unnamed_addr constant [5 x i8] c"SCTR\00", align 1
@.str.177 = private unnamed_addr constant [5 x i8] c"GPCR\00", align 1
@.str.178 = private unnamed_addr constant [5 x i8] c"SPCR\00", align 1
@.str.179 = private unnamed_addr constant [5 x i8] c"GCMI\00", align 1
@.str.180 = private unnamed_addr constant [5 x i8] c"SCMI\00", align 1
@.str.181 = private unnamed_addr constant [5 x i8] c"SN01\00", align 1
@.str.182 = private unnamed_addr constant [5 x i8] c"SN03\00", align 1
@.str.183 = private unnamed_addr constant [54 x i8] c"\014sony_laptop: Sony Notebook Control Driver removed.\0A\00", align 1
@.str.184 = private unnamed_addr constant [46 x i8] c"\014sony_laptop: sony_nc_notify, event: 0x%.2x\0A\00", align 1
@.str.185 = private unnamed_addr constant [56 x i8] c"\013sony_laptop: Event 0x%x outside of capabilities list\0A\00", align 1
@.str.186 = private unnamed_addr constant [55 x i8] c"\014sony_laptop: GFX switch event received (reason: %s)\0A\00", align 1
@.str.187 = private unnamed_addr constant [14 x i8] c"switch change\00", align 1
@.str.188 = private unnamed_addr constant [14 x i8] c"output switch\00", align 1
@.str.189 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.190 = private unnamed_addr constant [51 x i8] c"\014sony_laptop: Unknown event 0x%x for handle 0x%x\0A\00", align 1
@.str.191 = private unnamed_addr constant [5 x i8] c"SN05\00", align 1
@.str.192 = private unnamed_addr constant [53 x i8] c"\014sony_laptop: Unable to decode event 0x%.2x 0x%.2x\0A\00", align 1
@sony_100_events = internal global [41 x %struct.sony_nc_event] [%struct.sony_nc_event { i8 -112, i8 32 }, %struct.sony_nc_event { i8 16, i8 56 }, %struct.sony_nc_event { i8 -111, i8 33 }, %struct.sony_nc_event { i8 17, i8 56 }, %struct.sony_nc_event { i8 -127, i8 12 }, %struct.sony_nc_event { i8 1, i8 59 }, %struct.sony_nc_event { i8 -126, i8 13 }, %struct.sony_nc_event { i8 2, i8 59 }, %struct.sony_nc_event { i8 -125, i8 14 }, %struct.sony_nc_event { i8 3, i8 59 }, %struct.sony_nc_event { i8 -124, i8 15 }, %struct.sony_nc_event { i8 4, i8 59 }, %struct.sony_nc_event { i8 -123, i8 16 }, %struct.sony_nc_event { i8 5, i8 59 }, %struct.sony_nc_event { i8 -122, i8 17 }, %struct.sony_nc_event { i8 6, i8 59 }, %struct.sony_nc_event { i8 -121, i8 18 }, %struct.sony_nc_event { i8 7, i8 59 }, %struct.sony_nc_event { i8 -120, i8 19 }, %struct.sony_nc_event { i8 8, i8 59 }, %struct.sony_nc_event { i8 -119, i8 20 }, %struct.sony_nc_event { i8 9, i8 59 }, %struct.sony_nc_event { i8 -118, i8 21 }, %struct.sony_nc_event { i8 10, i8 59 }, %struct.sony_nc_event { i8 -117, i8 22 }, %struct.sony_nc_event { i8 11, i8 59 }, %struct.sony_nc_event { i8 -116, i8 23 }, %struct.sony_nc_event { i8 12, i8 59 }, %struct.sony_nc_event { i8 -99, i8 50 }, %struct.sony_nc_event { i8 29, i8 56 }, %struct.sony_nc_event { i8 -97, i8 64 }, %struct.sony_nc_event { i8 31, i8 56 }, %struct.sony_nc_event { i8 -95, i8 72 }, %struct.sony_nc_event { i8 33, i8 56 }, %struct.sony_nc_event { i8 -92, i8 64 }, %struct.sony_nc_event { i8 36, i8 56 }, %struct.sony_nc_event { i8 -91, i8 73 }, %struct.sony_nc_event { i8 37, i8 56 }, %struct.sony_nc_event { i8 -90, i8 40 }, %struct.sony_nc_event { i8 38, i8 56 }, %struct.sony_nc_event zeroinitializer], align 16
@sony_127_events = internal global [15 x %struct.sony_nc_event] [%struct.sony_nc_event { i8 -127, i8 65 }, %struct.sony_nc_event { i8 1, i8 56 }, %struct.sony_nc_event { i8 -126, i8 32 }, %struct.sony_nc_event { i8 2, i8 56 }, %struct.sony_nc_event { i8 -125, i8 33 }, %struct.sony_nc_event { i8 3, i8 56 }, %struct.sony_nc_event { i8 -124, i8 34 }, %struct.sony_nc_event { i8 4, i8 56 }, %struct.sony_nc_event { i8 -123, i8 66 }, %struct.sony_nc_event { i8 5, i8 56 }, %struct.sony_nc_event { i8 -122, i8 67 }, %struct.sony_nc_event { i8 6, i8 56 }, %struct.sony_nc_event { i8 -121, i8 68 }, %struct.sony_nc_event { i8 7, i8 56 }, %struct.sony_nc_event zeroinitializer], align 16
@.str.193 = private unnamed_addr constant [61 x i8] c"\016sony_laptop: Unknown hotkey 0x%.2x/0x%.2x (handle 0x%.2x)\0A\00", align 1
@.str.194 = private unnamed_addr constant [23 x i8] c"\013sony_laptop: %s: %d\0A\00", align 1
@__func__.sony_nc_resume = private unnamed_addr constant [15 x i8] c"sony_nc_resume\00", align 1
@.str.195 = private unnamed_addr constant [36 x i8] c"\014sony_laptop: Resuming SNC device\0A\00", align 1
@llvm.used = appending global [30 x i8*] [i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__UNIQUE_ID_author91, i32 0, i32 0), i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__UNIQUE_ID_description92, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license93, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_version94, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_debug to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_debugtype97, i32 0, i32 0), i8* getelementptr inbounds ([87 x i8], [87 x i8]* @__UNIQUE_ID_debug99, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_no_spic to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_no_spictype102, i32 0, i32 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @__UNIQUE_ID_no_spic104, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_compat to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_compattype107, i32 0, i32 0), i8* getelementptr inbounds ([71 x i8], [71 x i8]* @__UNIQUE_ID_compat109, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_mask to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_masktype112, i32 0, i32 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @__UNIQUE_ID_mask114, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_camera to i8*), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__UNIQUE_ID_cameratype117, i32 0, i32 0), i8* getelementptr inbounds ([110 x i8], [110 x i8]* @__UNIQUE_ID_camera120, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_minor to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_minortype124, i32 0, i32 0), i8* getelementptr inbounds ([102 x i8], [102 x i8]* @__UNIQUE_ID_minor127, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_kbd_backlight to i8*), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__UNIQUE_ID_kbd_backlighttype131, i32 0, i32 0), i8* getelementptr inbounds ([92 x i8], [92 x i8]* @__UNIQUE_ID_kbd_backlight134, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_kbd_backlight_timeout to i8*), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__UNIQUE_ID_kbd_backlight_timeouttype137, i32 0, i32 0), i8* getelementptr inbounds ([153 x i8], [153 x i8]* @__UNIQUE_ID_kbd_backlight_timeout141, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_sony_pic_camera_command to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_sony_pic_camera_command to i8*)], section "llvm.metadata"

@__mod_acpi_device_table = alias %struct.acpi_device_id, getelementptr inbounds ([3 x %struct.acpi_device_id], [3 x %struct.acpi_device_id]* @sony_device_ids, i32 0, i32 0)
@cleanup_module = alias void (), void ()* @sony_laptop_exit

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @acpi_os_allocate(i64 %size) #0 {
entry:
  %call = call i64 @arch_local_save_flags()
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call9, 0
  %cond = select i1 %tobool, i32 32, i32 208
  %call.i = call i8* @__kmalloc(i64 %size, i32 %cond) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @acpi_os_acquire_object(%struct.kmem_cache* %cache) #0 {
entry:
  %call = call i64 @arch_local_save_flags()
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call9, 0
  %cond = select i1 %tobool, i32 32, i32 208
  call void @kmem_cache_zalloc(%struct.kmem_cache* %cache, i32 %cond)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @acpi_os_get_thread_id() #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @sony_pic_camera_command(i32 %command, i8 zeroext %value) #1 {
entry:
  %0 = load i32, i32* @camera, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %Pivot26 = icmp slt i32 %command, 10
  br i1 %Pivot26, label %NodeBlock9, label %NodeBlock23

NodeBlock23:                                      ; preds = %if.end
  %Pivot24 = icmp slt i32 %command, 14
  br i1 %Pivot24, label %NodeBlock15, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %command, 16
  br i1 %Pivot22, label %LeafBlock17, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %command, 16
  br i1 %SwitchLeaf20, label %sw.bb126, label %sw.default

LeafBlock17:                                      ; preds = %NodeBlock21
  %SwitchLeaf18 = icmp eq i32 %command, 14
  br i1 %SwitchLeaf18, label %sw.bb104, label %sw.default

NodeBlock15:                                      ; preds = %NodeBlock23
  %Pivot16 = icmp slt i32 %command, 12
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %command, 12
  br i1 %SwitchLeaf14, label %sw.bb82, label %sw.default

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %command, 10
  br i1 %SwitchLeaf12, label %sw.bb60, label %sw.default

NodeBlock9:                                       ; preds = %if.end
  %Pivot10 = icmp slt i32 %command, 6
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %command, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %command, 8
  br i1 %SwitchLeaf6, label %sw.bb38, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %command, 6
  br i1 %SwitchLeaf4, label %sw.bb16, label %sw.default

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %command, 4
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %command, 4
  br i1 %SwitchLeaf2, label %sw.bb5, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %command, 2
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %tobool1 = icmp ne i8 %value, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %sw.bb
  call void @__sony_pic_camera_on()
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb
  call void @__sony_pic_camera_off()
  br label %sw.epilog

sw.bb5:                                           ; preds = %LeafBlock1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.bb5
  %n.0 = phi i32 [ 10, %sw.bb5 ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %call7 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 0, i8 zeroext %value)
  %conv = zext i8 %call7 to i32
  %tobool8 = icmp ne i32 %conv, 0
  br i1 %tobool8, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool9 = icmp eq i32 %dec, 0
  %1 = load i32, i32* @debug, align 4
  %tobool11 = icmp ne i32 %1, 0
  %or.cond = and i1 %tobool9, %tobool11
  br i1 %or.cond, label %if.then12, label %sw.epilog

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool11.old = icmp ne i32 %.old, 0
  br i1 %tobool11.old, label %if.then12, label %sw.epilog

if.then12:                                        ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb16:                                          ; preds = %LeafBlock3
  br label %while.cond18

while.cond18:                                     ; preds = %while.body26, %sw.bb16
  %n17.0 = phi i32 [ 10, %sw.bb16 ], [ %dec19, %while.body26 ]
  %dec19 = add i32 %n17.0, -1
  %cond27 = icmp eq i32 %dec19, 0
  br i1 %cond27, label %do.body30, label %land.rhs21

land.rhs21:                                       ; preds = %while.cond18
  %call22 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 1, i8 zeroext %value)
  %conv23 = zext i8 %call22 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  br i1 %tobool24, label %while.body26, label %while.end27

while.body26:                                     ; preds = %land.rhs21
  call void @__const_udelay(i64 4295)
  br label %while.cond18

while.end27:                                      ; preds = %land.rhs21
  %tobool28 = icmp eq i32 %dec19, 0
  %2 = load i32, i32* @debug, align 4
  %tobool31 = icmp ne i32 %2, 0
  %or.cond29 = and i1 %tobool28, %tobool31
  br i1 %or.cond29, label %if.then32, label %sw.epilog

do.body30:                                        ; preds = %while.cond18
  %.old28 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool31.old = icmp ne i32 %.old28, 0
  br i1 %tobool31.old, label %if.then32, label %sw.epilog

if.then32:                                        ; preds = %do.body30, %while.end27
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb38:                                          ; preds = %LeafBlock5
  br label %while.cond40

while.cond40:                                     ; preds = %while.body48, %sw.bb38
  %n39.0 = phi i32 [ 10, %sw.bb38 ], [ %dec41, %while.body48 ]
  %dec41 = add i32 %n39.0, -1
  %cond30 = icmp eq i32 %dec41, 0
  br i1 %cond30, label %do.body52, label %land.rhs43

land.rhs43:                                       ; preds = %while.cond40
  %call44 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 2, i8 zeroext %value)
  %conv45 = zext i8 %call44 to i32
  %tobool46 = icmp ne i32 %conv45, 0
  br i1 %tobool46, label %while.body48, label %while.end49

while.body48:                                     ; preds = %land.rhs43
  call void @__const_udelay(i64 4295)
  br label %while.cond40

while.end49:                                      ; preds = %land.rhs43
  %tobool50 = icmp eq i32 %dec41, 0
  %3 = load i32, i32* @debug, align 4
  %tobool53 = icmp ne i32 %3, 0
  %or.cond32 = and i1 %tobool50, %tobool53
  br i1 %or.cond32, label %if.then54, label %sw.epilog

do.body52:                                        ; preds = %while.cond40
  %.old31 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool53.old = icmp ne i32 %.old31, 0
  br i1 %tobool53.old, label %if.then54, label %sw.epilog

if.then54:                                        ; preds = %do.body52, %while.end49
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb60:                                          ; preds = %LeafBlock11
  br label %while.cond62

while.cond62:                                     ; preds = %while.body70, %sw.bb60
  %n61.0 = phi i32 [ 10, %sw.bb60 ], [ %dec63, %while.body70 ]
  %dec63 = add i32 %n61.0, -1
  %cond33 = icmp eq i32 %dec63, 0
  br i1 %cond33, label %do.body74, label %land.rhs65

land.rhs65:                                       ; preds = %while.cond62
  %call66 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 3, i8 zeroext %value)
  %conv67 = zext i8 %call66 to i32
  %tobool68 = icmp ne i32 %conv67, 0
  br i1 %tobool68, label %while.body70, label %while.end71

while.body70:                                     ; preds = %land.rhs65
  call void @__const_udelay(i64 4295)
  br label %while.cond62

while.end71:                                      ; preds = %land.rhs65
  %tobool72 = icmp eq i32 %dec63, 0
  %4 = load i32, i32* @debug, align 4
  %tobool75 = icmp ne i32 %4, 0
  %or.cond35 = and i1 %tobool72, %tobool75
  br i1 %or.cond35, label %if.then76, label %sw.epilog

do.body74:                                        ; preds = %while.cond62
  %.old34 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool75.old = icmp ne i32 %.old34, 0
  br i1 %tobool75.old, label %if.then76, label %sw.epilog

if.then76:                                        ; preds = %do.body74, %while.end71
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb82:                                          ; preds = %LeafBlock13
  br label %while.cond84

while.cond84:                                     ; preds = %while.body92, %sw.bb82
  %n83.0 = phi i32 [ 10, %sw.bb82 ], [ %dec85, %while.body92 ]
  %dec85 = add i32 %n83.0, -1
  %cond36 = icmp eq i32 %dec85, 0
  br i1 %cond36, label %do.body96, label %land.rhs87

land.rhs87:                                       ; preds = %while.cond84
  %call88 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 4, i8 zeroext %value)
  %conv89 = zext i8 %call88 to i32
  %tobool90 = icmp ne i32 %conv89, 0
  br i1 %tobool90, label %while.body92, label %while.end93

while.body92:                                     ; preds = %land.rhs87
  call void @__const_udelay(i64 4295)
  br label %while.cond84

while.end93:                                      ; preds = %land.rhs87
  %tobool94 = icmp eq i32 %dec85, 0
  %5 = load i32, i32* @debug, align 4
  %tobool97 = icmp ne i32 %5, 0
  %or.cond38 = and i1 %tobool94, %tobool97
  br i1 %or.cond38, label %if.then98, label %sw.epilog

do.body96:                                        ; preds = %while.cond84
  %.old37 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool97.old = icmp ne i32 %.old37, 0
  br i1 %tobool97.old, label %if.then98, label %sw.epilog

if.then98:                                        ; preds = %do.body96, %while.end93
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb104:                                         ; preds = %LeafBlock17
  br label %while.cond106

while.cond106:                                    ; preds = %while.body114, %sw.bb104
  %n105.0 = phi i32 [ 10, %sw.bb104 ], [ %dec107, %while.body114 ]
  %dec107 = add i32 %n105.0, -1
  %cond39 = icmp eq i32 %dec107, 0
  br i1 %cond39, label %do.body118, label %land.rhs109

land.rhs109:                                      ; preds = %while.cond106
  %call110 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 5, i8 zeroext %value)
  %conv111 = zext i8 %call110 to i32
  %tobool112 = icmp ne i32 %conv111, 0
  br i1 %tobool112, label %while.body114, label %while.end115

while.body114:                                    ; preds = %land.rhs109
  call void @__const_udelay(i64 4295)
  br label %while.cond106

while.end115:                                     ; preds = %land.rhs109
  %tobool116 = icmp eq i32 %dec107, 0
  %6 = load i32, i32* @debug, align 4
  %tobool119 = icmp ne i32 %6, 0
  %or.cond41 = and i1 %tobool116, %tobool119
  br i1 %or.cond41, label %if.then120, label %sw.epilog

do.body118:                                       ; preds = %while.cond106
  %.old40 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool119.old = icmp ne i32 %.old40, 0
  br i1 %tobool119.old, label %if.then120, label %sw.epilog

if.then120:                                       ; preds = %do.body118, %while.end115
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.bb126:                                         ; preds = %LeafBlock19
  br label %while.cond128

while.cond128:                                    ; preds = %while.body136, %sw.bb126
  %n127.0 = phi i32 [ 10, %sw.bb126 ], [ %dec129, %while.body136 ]
  %dec129 = add i32 %n127.0, -1
  %cond42 = icmp eq i32 %dec129, 0
  br i1 %cond42, label %do.body140, label %land.rhs131

land.rhs131:                                      ; preds = %while.cond128
  %call132 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 6, i8 zeroext %value)
  %conv133 = zext i8 %call132 to i32
  %tobool134 = icmp ne i32 %conv133, 0
  br i1 %tobool134, label %while.body136, label %while.end137

while.body136:                                    ; preds = %land.rhs131
  call void @__const_udelay(i64 4295)
  br label %while.cond128

while.end137:                                     ; preds = %land.rhs131
  %tobool138 = icmp eq i32 %dec129, 0
  %7 = load i32, i32* @debug, align 4
  %tobool141 = icmp ne i32 %7, 0
  %or.cond44 = and i1 %tobool138, %tobool141
  br i1 %or.cond44, label %if.then142, label %sw.epilog

do.body140:                                       ; preds = %while.cond128
  %.old43 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool141.old = icmp ne i32 %.old43, 0
  br i1 %tobool141.old, label %if.then142, label %sw.epilog

if.then142:                                       ; preds = %do.body140, %while.end137
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock11, %LeafBlock13, %LeafBlock17, %LeafBlock19
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.then142, %do.body140, %while.end137, %if.then120, %do.body118, %while.end115, %if.then98, %do.body96, %while.end93, %if.then76, %do.body74, %while.end71, %if.then54, %do.body52, %while.end49, %if.then32, %do.body30, %while.end27, %if.then12, %do.body, %while.end, %if.else, %if.then2
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  br label %return

return:                                           ; preds = %sw.epilog, %entry
  %retval.0 = phi i32 [ 0, %sw.epilog ], [ -5, %entry ]
  ret i32 %retval.0
}

declare void @mutex_lock_nested(%struct.mutex*, i32) #2

; Function Attrs: nounwind uwtable
define internal void @__sony_pic_camera_on() #1 {
entry:
  %0 = load i32, i32* @camera, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %1 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !14
  %tobool1 = icmp ne i8 %1, 0
  br i1 %tobool1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc23, %if.end3
  %j.0 = phi i32 [ 5, %if.end3 ], [ %dec24, %for.inc23 ]
  %cmp = icmp sgt i32 %j.0, 0
  br i1 %cmp, label %for.body, label %for.end25

for.body:                                         ; preds = %for.cond
  br label %for.cond4

for.cond4:                                        ; preds = %for.body8, %for.body
  %x.0 = phi i32 [ 0, %for.body ], [ %inc, %for.body8 ]
  %cmp5 = icmp slt i32 %x.0, 100
  br i1 %cmp5, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond4
  %call6 = call zeroext i8 @sony_pic_call2(i8 zeroext -111, i8 zeroext 1)
  %conv = zext i8 %call6 to i32
  %tobool7 = icmp ne i32 %conv, 0
  br i1 %tobool7, label %for.body8, label %for.end

for.body8:                                        ; preds = %land.rhs
  call void @msleep(i32 10)
  %inc = add nsw i32 %x.0, 1
  br label %for.cond4

for.end:                                          ; preds = %land.rhs, %for.cond4
  call void @sony_pic_call1(i8 zeroext -109)
  br label %for.cond10

for.cond10:                                       ; preds = %if.end17, %for.end
  %i.0 = phi i32 [ 400, %for.end ], [ %dec, %if.end17 ]
  %cmp11 = icmp sgt i32 %i.0, 0
  br i1 %cmp11, label %for.body13, label %for.end19

for.body13:                                       ; preds = %for.cond10
  %call14 = call i32 @__sony_pic_camera_ready()
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %for.end19, label %if.end17

if.end17:                                         ; preds = %for.body13
  call void @msleep(i32 10)
  %dec = add nsw i32 %i.0, -1
  br label %for.cond10

for.end19:                                        ; preds = %for.body13, %for.cond10
  %tobool20 = icmp ne i32 %i.0, 0
  br i1 %tobool20, label %for.end25, label %for.inc23

for.inc23:                                        ; preds = %for.end19
  %dec24 = add nsw i32 %j.0, -1
  br label %for.cond

for.end25:                                        ; preds = %for.end19, %for.cond
  %cmp26 = icmp eq i32 %j.0, 0
  br i1 %cmp26, label %if.then28, label %if.end30

if.then28:                                        ; preds = %for.end25
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end30:                                         ; preds = %for.end25
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end30
  %n.0 = phi i32 [ 10, %if.end30 ], [ %dec31, %while.body ]
  %dec31 = add i32 %n.0, -1
  %cond = icmp eq i32 %dec31, 0
  br i1 %cond, label %do.body, label %land.rhs33

land.rhs33:                                       ; preds = %while.cond
  %call34 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 16, i8 zeroext 90)
  %conv35 = zext i8 %call34 to i32
  %tobool36 = icmp ne i32 %conv35, 0
  br i1 %tobool36, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs33
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs33
  %tobool38 = icmp eq i32 %dec31, 0
  %2 = load i32, i32* @debug, align 4
  %tobool40 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool38, %tobool40
  br i1 %or.cond, label %if.then41, label %if.end44

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool40.old = icmp ne i32 %.old, 0
  br i1 %tobool40.old, label %if.then41, label %if.end44

if.then41:                                        ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %if.end44

if.end44:                                         ; preds = %if.then41, %do.body, %while.end
  store i8 1, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !14
  br label %cleanup

cleanup:                                          ; preds = %if.end44, %if.then28, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__sony_pic_camera_off() #1 {
entry:
  %0 = load i32, i32* @camera, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %n.0 = phi i32 [ 10, %if.end ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %call2 = call zeroext i8 @sony_pic_call3(i8 zeroext -112, i8 zeroext 5, i8 zeroext 64)
  %conv = zext i8 %call2 to i32
  %tobool3 = icmp ne i32 %conv, 0
  br i1 %tobool3, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool4 = icmp eq i32 %dec, 0
  %1 = load i32, i32* @debug, align 4
  %tobool6 = icmp ne i32 %1, 0
  %or.cond = and i1 %tobool4, %tobool6
  br i1 %or.cond, label %if.then7, label %if.end10

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool6.old = icmp ne i32 %.old, 0
  br i1 %tobool6.old, label %if.then7, label %if.end10

if.then7:                                         ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %do.body, %while.end
  %2 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !14
  %tobool11 = icmp ne i8 %2, 0
  br i1 %tobool11, label %if.then12, label %return

if.then12:                                        ; preds = %if.end10
  %call13 = call zeroext i8 @sony_pic_call2(i8 zeroext -111, i8 zeroext 0)
  store i8 0, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 10), align 2, !tbaa !14
  br label %return

return:                                           ; preds = %if.then12, %if.end10, %if.then
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

; Function Attrs: nounwind uwtable
define internal zeroext i8 @sony_pic_call3(i8 zeroext %dev, i8 zeroext %fn, i8 zeroext %v) #1 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %n.0 = phi i32 [ 10000, %entry ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %0 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %0, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %1 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv = zext i16 %1 to i32
  %add = add nsw i32 %conv, 4
  %call = call zeroext i8 @inb_p(i32 %add)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp eq i32 %dec, 0
  %2 = load i32, i32* @debug, align 4
  %tobool4 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool3, %tobool4
  br i1 %or.cond, label %if.then5, label %if.end7

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool4.old = icmp ne i32 %.old, 0
  br i1 %tobool4.old, label %if.then5, label %if.end7

if.then5:                                         ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %do.body, %while.end
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io18 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 0
  %minimum9 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io18, i32 0, i32 3
  %4 = load i16, i16* %minimum9, align 1, !tbaa !24
  %conv10 = zext i16 %4 to i32
  %add11 = add nsw i32 %conv10, 4
  call void @outb(i8 zeroext %dev, i32 %add11)
  br label %while.cond13

while.cond13:                                     ; preds = %while.body26, %if.end7
  %n12.0 = phi i32 [ 10000, %if.end7 ], [ %dec14, %while.body26 ]
  %dec14 = add i32 %n12.0, -1
  %cond1 = icmp eq i32 %dec14, 0
  br i1 %cond1, label %do.body30, label %land.rhs16

land.rhs16:                                       ; preds = %while.cond13
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io117 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum18 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io117, i32 0, i32 3
  %6 = load i16, i16* %minimum18, align 1, !tbaa !24
  %conv19 = zext i16 %6 to i32
  %add20 = add nsw i32 %conv19, 4
  %call21 = call zeroext i8 @inb_p(i32 %add20)
  %conv22 = zext i8 %call21 to i32
  %and23 = and i32 %conv22, 2
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %while.body26, label %while.end27

while.body26:                                     ; preds = %land.rhs16
  call void @__const_udelay(i64 4295)
  br label %while.cond13

while.end27:                                      ; preds = %land.rhs16
  %tobool28 = icmp eq i32 %dec14, 0
  %7 = load i32, i32* @debug, align 4
  %tobool31 = icmp ne i32 %7, 0
  %or.cond3 = and i1 %tobool28, %tobool31
  br i1 %or.cond3, label %if.then32, label %if.end37

do.body30:                                        ; preds = %while.cond13
  %.old2 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool31.old = icmp ne i32 %.old2, 0
  br i1 %tobool31.old, label %if.then32, label %if.end37

if.then32:                                        ; preds = %do.body30, %while.end27
  call void (i8*, ...) @printk(i8* null)
  br label %if.end37

if.end37:                                         ; preds = %if.then32, %do.body30, %while.end27
  %8 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io138 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %8, i32 0, i32 0
  %minimum39 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io138, i32 0, i32 3
  %9 = load i16, i16* %minimum39, align 1, !tbaa !24
  %conv40 = zext i16 %9 to i32
  call void @outb(i8 zeroext %fn, i32 %conv40)
  br label %while.cond42

while.cond42:                                     ; preds = %while.body55, %if.end37
  %n41.0 = phi i32 [ 10000, %if.end37 ], [ %dec43, %while.body55 ]
  %dec43 = add i32 %n41.0, -1
  %cond4 = icmp eq i32 %dec43, 0
  br i1 %cond4, label %do.body59, label %land.rhs45

land.rhs45:                                       ; preds = %while.cond42
  %10 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io146 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %10, i32 0, i32 0
  %minimum47 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io146, i32 0, i32 3
  %11 = load i16, i16* %minimum47, align 1, !tbaa !24
  %conv48 = zext i16 %11 to i32
  %add49 = add nsw i32 %conv48, 4
  %call50 = call zeroext i8 @inb_p(i32 %add49)
  %conv51 = zext i8 %call50 to i32
  %and52 = and i32 %conv51, 2
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %while.body55, label %while.end56

while.body55:                                     ; preds = %land.rhs45
  call void @__const_udelay(i64 4295)
  br label %while.cond42

while.end56:                                      ; preds = %land.rhs45
  %tobool57 = icmp eq i32 %dec43, 0
  %12 = load i32, i32* @debug, align 4
  %tobool60 = icmp ne i32 %12, 0
  %or.cond6 = and i1 %tobool57, %tobool60
  br i1 %or.cond6, label %if.then61, label %if.end66

do.body59:                                        ; preds = %while.cond42
  %.old5 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool60.old = icmp ne i32 %.old5, 0
  br i1 %tobool60.old, label %if.then61, label %if.end66

if.then61:                                        ; preds = %do.body59, %while.end56
  call void (i8*, ...) @printk(i8* null)
  br label %if.end66

if.end66:                                         ; preds = %if.then61, %do.body59, %while.end56
  %13 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io167 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %13, i32 0, i32 0
  %minimum68 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io167, i32 0, i32 3
  %14 = load i16, i16* %minimum68, align 1, !tbaa !24
  %conv69 = zext i16 %14 to i32
  call void @outb(i8 zeroext %v, i32 %conv69)
  %15 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io170 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 0
  %minimum71 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io170, i32 0, i32 3
  %16 = load i16, i16* %minimum71, align 1, !tbaa !24
  %conv72 = zext i16 %16 to i32
  %call73 = call zeroext i8 @inb_p(i32 %conv72)
  %17 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool75 = icmp ne i32 %17, 0
  br i1 %tobool75, label %if.then76, label %do.end84

if.then76:                                        ; preds = %if.end66
  call void (i8*, ...) @printk(i8* null)
  br label %do.end84

do.end84:                                         ; preds = %if.then76, %if.end66
  ret i8 %call73
}

declare void @__const_udelay(i64) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

declare void @mutex_unlock(%struct.mutex*) #2

; Function Attrs: nounwind uwtable
declare i32 @sony_laptop_init() #4 section ".init.text"

; Function Attrs: nounwind uwtable
define internal void @sony_laptop_exit() #4 section ".exit.text" {
entry:
  call void @acpi_bus_unregister_driver(%struct.acpi_driver* @sony_nc_driver)
  %0 = load i32, i32* @spic_drv_registered, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @acpi_bus_unregister_driver(%struct.acpi_driver* @sony_pic_driver)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags() #0 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !27
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.3, i32 0, i32 0), i32 824, i64 12) #7, !srcloc !30
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 44, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1) #7, !srcloc !31
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags(i64 %flags) #0 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare i8* @__kmalloc(i64, i32) #2

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

; Function Attrs: inlinehint nounwind uwtable
define internal void @kmem_cache_zalloc(%struct.kmem_cache* %k, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmem_cache_alloc(%struct.kmem_cache* %k, i32 %or)
  ret void
}

declare i8* @kmem_cache_alloc(%struct.kmem_cache*, i32) #2

; Function Attrs: nounwind uwtable
define internal zeroext i8 @sony_pic_call2(i8 zeroext %dev, i8 zeroext %fn) #1 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %n.0 = phi i32 [ 10000, %entry ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %0 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %0, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %1 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv = zext i16 %1 to i32
  %add = add nsw i32 %conv, 4
  %call = call zeroext i8 @inb_p(i32 %add)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp eq i32 %dec, 0
  %2 = load i32, i32* @debug, align 4
  %tobool4 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool3, %tobool4
  br i1 %or.cond, label %if.then5, label %if.end7

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool4.old = icmp ne i32 %.old, 0
  br i1 %tobool4.old, label %if.then5, label %if.end7

if.then5:                                         ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %do.body, %while.end
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io18 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 0
  %minimum9 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io18, i32 0, i32 3
  %4 = load i16, i16* %minimum9, align 1, !tbaa !24
  %conv10 = zext i16 %4 to i32
  %add11 = add nsw i32 %conv10, 4
  call void @outb(i8 zeroext %dev, i32 %add11)
  br label %while.cond13

while.cond13:                                     ; preds = %while.body26, %if.end7
  %n12.0 = phi i32 [ 10000, %if.end7 ], [ %dec14, %while.body26 ]
  %dec14 = add i32 %n12.0, -1
  %cond1 = icmp eq i32 %dec14, 0
  br i1 %cond1, label %do.body30, label %land.rhs16

land.rhs16:                                       ; preds = %while.cond13
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io117 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum18 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io117, i32 0, i32 3
  %6 = load i16, i16* %minimum18, align 1, !tbaa !24
  %conv19 = zext i16 %6 to i32
  %add20 = add nsw i32 %conv19, 4
  %call21 = call zeroext i8 @inb_p(i32 %add20)
  %conv22 = zext i8 %call21 to i32
  %and23 = and i32 %conv22, 2
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %while.body26, label %while.end27

while.body26:                                     ; preds = %land.rhs16
  call void @__const_udelay(i64 4295)
  br label %while.cond13

while.end27:                                      ; preds = %land.rhs16
  %tobool28 = icmp eq i32 %dec14, 0
  %7 = load i32, i32* @debug, align 4
  %tobool31 = icmp ne i32 %7, 0
  %or.cond3 = and i1 %tobool28, %tobool31
  br i1 %or.cond3, label %if.then32, label %if.end37

do.body30:                                        ; preds = %while.cond13
  %.old2 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool31.old = icmp ne i32 %.old2, 0
  br i1 %tobool31.old, label %if.then32, label %if.end37

if.then32:                                        ; preds = %do.body30, %while.end27
  call void (i8*, ...) @printk(i8* null)
  br label %if.end37

if.end37:                                         ; preds = %if.then32, %do.body30, %while.end27
  %8 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io138 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %8, i32 0, i32 0
  %minimum39 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io138, i32 0, i32 3
  %9 = load i16, i16* %minimum39, align 1, !tbaa !24
  %conv40 = zext i16 %9 to i32
  call void @outb(i8 zeroext %fn, i32 %conv40)
  %10 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io141 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %10, i32 0, i32 0
  %minimum42 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io141, i32 0, i32 3
  %11 = load i16, i16* %minimum42, align 1, !tbaa !24
  %conv43 = zext i16 %11 to i32
  %call44 = call zeroext i8 @inb_p(i32 %conv43)
  %12 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool46 = icmp ne i32 %12, 0
  br i1 %tobool46, label %if.then47, label %do.end54

if.then47:                                        ; preds = %if.end37
  call void (i8*, ...) @printk(i8* null)
  br label %do.end54

do.end54:                                         ; preds = %if.then47, %if.end37
  ret i8 %call44
}

declare void @msleep(i32) #2

; Function Attrs: nounwind uwtable
define internal void @sony_pic_call1(i8 zeroext %dev) #1 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %n.0 = phi i32 [ 10000, %entry ], [ %dec, %while.body ]
  %dec = add i32 %n.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %do.body, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %0 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %0, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %1 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv = zext i16 %1 to i32
  %add = add nsw i32 %conv, 4
  %call = call zeroext i8 @inb_p(i32 %add)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp eq i32 %dec, 0
  %2 = load i32, i32* @debug, align 4
  %tobool4 = icmp ne i32 %2, 0
  %or.cond = and i1 %tobool3, %tobool4
  br i1 %or.cond, label %if.then5, label %if.end7

do.body:                                          ; preds = %while.cond
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool4.old = icmp ne i32 %.old, 0
  br i1 %tobool4.old, label %if.then5, label %if.end7

if.then5:                                         ; preds = %do.body, %while.end
  call void (i8*, ...) @printk(i8* null)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %do.body, %while.end
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io18 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 0
  %minimum9 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io18, i32 0, i32 3
  %4 = load i16, i16* %minimum9, align 1, !tbaa !24
  %conv10 = zext i16 %4 to i32
  %add11 = add nsw i32 %conv10, 4
  call void @outb(i8 zeroext %dev, i32 %add11)
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io112 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum13 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io112, i32 0, i32 3
  %6 = load i16, i16* %minimum13, align 1, !tbaa !24
  %conv14 = zext i16 %6 to i32
  %add15 = add nsw i32 %conv14, 4
  %call16 = call zeroext i8 @inb_p(i32 %add15)
  %7 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io117 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %7, i32 0, i32 0
  %minimum18 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io117, i32 0, i32 3
  %8 = load i16, i16* %minimum18, align 1, !tbaa !24
  %conv19 = zext i16 %8 to i32
  %call20 = call zeroext i8 @inb_p(i32 %conv19)
  %9 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool22 = icmp ne i32 %9, 0
  br i1 %tobool22, label %if.then23, label %do.end30

if.then23:                                        ; preds = %if.end7
  call void (i8*, ...) @printk(i8* null)
  br label %do.end30

do.end30:                                         ; preds = %if.then23, %if.end7
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @__sony_pic_camera_ready() #1 {
entry:
  %call = call zeroext i8 @sony_pic_call2(i8 zeroext -113, i8 zeroext 7)
  %conv = zext i8 %call to i32
  %cmp = icmp ne i32 %conv, 255
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %conv2 = zext i8 %call to i32
  %and = and i32 %conv2, 2
  %tobool = icmp ne i32 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %0 to i32
  ret i32 %land.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb_p(i32 %port) #0 {
entry:
  %call = call zeroext i8 @inb(i32 %port)
  call void @slow_down_io()
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #0 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #7, !srcloc !32
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #0 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #7, !srcloc !33
  ret i8 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @slow_down_io() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.pv_cpu_ops, %struct.pv_cpu_ops* @pv_cpu_ops, i32 0, i32 26), align 8, !tbaa !34
  call void %0()
  ret void
}

declare i32 @dmi_check_system(%struct.dmi_system_id*) #2

declare i32 @acpi_bus_register_driver(%struct.acpi_driver*) #2

declare void @acpi_bus_unregister_driver(%struct.acpi_driver*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_add(%struct.acpi_device* %device) #1 {
entry:
  call void (i8*, ...) @printk(i8* null)
  store %struct.acpi_device* %device, %struct.acpi_device** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 0), align 8, !tbaa !36
  %pnp = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 8
  %device_class = getelementptr inbounds %struct.acpi_device_pnp, %struct.acpi_device_pnp* %pnp, i32 0, i32 6
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %device_class, i32 0, i32 0
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.17, i32 0, i32 0))
  call void @sony_pic_detect_device_type(%struct.sony_pic_dev* @spic_dev)
  call void @__mutex_init(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.18, i32 0, i32 0), %struct.lock_class_key* @sony_pic_add.__key)
  %call2 = call i32 @sony_pic_possible_resources(%struct.acpi_device* %device)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %err_free_resources

if.end:                                           ; preds = %entry
  %call4 = call i32 @sony_laptop_setup_input(%struct.acpi_device* %device)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  call void (i8*, ...) @printk(i8* null)
  br label %err_free_resources

if.end8:                                          ; preds = %if.end
  %call9 = call i32 @sonypi_compat_init()
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %err_remove_input, label %if.end12

if.end12:                                         ; preds = %if.end8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end12
  %prev.sink = phi %struct.list_head** [ %prev, %for.inc ], [ getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4, i32 1), %if.end12 ]
  %0 = load %struct.list_head*, %struct.list_head** %prev.sink, align 8, !tbaa !37
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr90 = getelementptr inbounds i8, i8* %1, i64 -16
  %2 = bitcast i8* %add.ptr90 to %struct.sony_pic_ioport*
  %list = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 2
  %cmp = icmp ne %struct.list_head* %list, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4)
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %3 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv = zext i16 %3 to i64
  %io113 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %address_length = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io113, i32 0, i32 2
  %4 = load i8, i8* %address_length, align 2, !tbaa !38
  %conv14 = zext i8 %4 to i64
  %call15 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv, i64 %conv14, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.21, i32 0, i32 0), i32 0)
  %tobool16 = icmp ne %struct.resource* %call15, null
  br i1 %tobool16, label %do.body18, label %for.inc

do.body18:                                        ; preds = %for.body
  %5 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool19 = icmp ne i32 %5, 0
  br i1 %tobool19, label %if.then20, label %do.end32

if.then20:                                        ; preds = %do.body18
  call void (i8*, ...) @printk(i8* null)
  br label %do.end32

do.end32:                                         ; preds = %if.then20, %do.body18
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %minimum33 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %6 = load i16, i16* %minimum33, align 1, !tbaa !39
  %tobool34 = icmp ne i16 %6, 0
  br i1 %tobool34, label %if.then35, label %for.end.sink.split

if.then35:                                        ; preds = %do.end32
  %io236 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %minimum37 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io236, i32 0, i32 3
  %7 = load i16, i16* %minimum37, align 1, !tbaa !39
  %conv38 = zext i16 %7 to i64
  %io239 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 1
  %address_length40 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io239, i32 0, i32 2
  %8 = load i8, i8* %address_length40, align 1, !tbaa !40
  %conv41 = zext i8 %8 to i64
  %call42 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv38, i64 %conv41, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.21, i32 0, i32 0), i32 0)
  %tobool43 = icmp ne %struct.resource* %call42, null
  %9 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool46 = icmp ne i32 %9, 0
  br i1 %tobool43, label %do.body45, label %do.body61

do.body45:                                        ; preds = %if.then35
  br i1 %tobool46, label %if.then47, label %for.end.sink.split

if.then47:                                        ; preds = %do.body45
  call void (i8*, ...) @printk(i8* null)
  br label %for.end.sink.split

do.body61:                                        ; preds = %if.then35
  br i1 %tobool46, label %if.then63, label %do.end76

if.then63:                                        ; preds = %do.body61
  call void (i8*, ...) @printk(i8* null)
  br label %do.end76

do.end76:                                         ; preds = %if.then63, %do.body61
  %io177 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %minimum78 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io177, i32 0, i32 3
  %10 = load i16, i16* %minimum78, align 1, !tbaa !24
  %conv79 = zext i16 %10 to i64
  %io180 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %address_length81 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io180, i32 0, i32 2
  %11 = load i8, i8* %address_length81, align 2, !tbaa !38
  %conv82 = zext i8 %11 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv79, i64 %conv82)
  br label %for.inc

for.inc:                                          ; preds = %do.end76, %for.body
  %list88 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 2
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list88, i32 0, i32 1
  br label %for.cond

for.end.sink.split:                               ; preds = %if.then47, %do.body45, %do.end32
  store %struct.sony_pic_ioport* %2, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  br label %for.end

for.end:                                          ; preds = %for.end.sink.split, %for.cond
  %12 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %tobool91 = icmp ne %struct.sony_pic_ioport* %12, null
  br i1 %tobool91, label %if.end94, label %if.then92

if.then92:                                        ; preds = %for.end
  call void (i8*, ...) @printk(i8* null)
  br label %err_remove_compat

if.end94:                                         ; preds = %for.end
  br label %for.cond98

for.cond98:                                       ; preds = %for.inc126, %if.end94
  %prev129.sink = phi %struct.list_head** [ %prev129, %for.inc126 ], [ getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3, i32 1), %if.end94 ]
  %13 = load %struct.list_head*, %struct.list_head** %prev129.sink, align 8, !tbaa !37
  %14 = bitcast %struct.list_head* %13 to i8*
  %add.ptr131 = getelementptr inbounds i8, i8* %14, i64 -8
  %15 = bitcast i8* %add.ptr131 to %struct.sony_pic_irq*
  %list99 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %15, i32 0, i32 1
  %cmp100 = icmp ne %struct.list_head* %list99, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3)
  br i1 %cmp100, label %for.body102, label %for.end132

for.body102:                                      ; preds = %for.cond98
  %irq103 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %15, i32 0, i32 0
  %interrupts = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq103, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts, i64 0, i64 0
  %16 = load i8, i8* %arrayidx, align 2, !tbaa !41
  %conv104 = zext i8 %16 to i32
  %call105 = call i32 @request_irq(i32 %conv104, i32 (i32, i8*)* @sony_pic_irq, i64 0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.26, i32 0, i32 0), i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %for.inc126, label %do.body108

do.body108:                                       ; preds = %for.body102
  %17 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool109 = icmp ne i32 %17, 0
  br i1 %tobool109, label %if.then110, label %do.end124

if.then110:                                       ; preds = %do.body108
  call void (i8*, ...) @printk(i8* null)
  br label %do.end124

do.end124:                                        ; preds = %if.then110, %do.body108
  store %struct.sony_pic_irq* %15, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !42
  br label %for.end132

for.inc126:                                       ; preds = %for.body102
  %list128 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %15, i32 0, i32 1
  %prev129 = getelementptr inbounds %struct.list_head, %struct.list_head* %list128, i32 0, i32 1
  br label %for.cond98

for.end132:                                       ; preds = %do.end124, %for.cond98
  %18 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !42
  %tobool133 = icmp ne %struct.sony_pic_irq* %18, null
  br i1 %tobool133, label %if.end136, label %if.then134

if.then134:                                       ; preds = %for.end132
  call void (i8*, ...) @printk(i8* null)
  br label %err_release_region

if.end136:                                        ; preds = %for.end132
  %19 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %20 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !42
  %call137 = call i32 @sony_pic_enable(%struct.acpi_device* %device, %struct.sony_pic_ioport* %19, %struct.sony_pic_irq* %20)
  %tobool138 = icmp ne i32 %call137, 0
  br i1 %tobool138, label %if.then139, label %if.end141

if.then139:                                       ; preds = %if.end136
  call void (i8*, ...) @printk(i8* null)
  br label %err_free_irq

if.end141:                                        ; preds = %if.end136
  store i8 -1, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !43
  %call142 = call i32 @sony_pf_add()
  %tobool143 = icmp ne i32 %call142, 0
  br i1 %tobool143, label %err_disable_device, label %if.end145

if.end145:                                        ; preds = %if.end141
  %21 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %21, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call146 = call i32 @sysfs_create_group(%struct.kobject* %kobj, %struct.attribute_group* @spic_attribute_group)
  %tobool147 = icmp ne i32 %call146, 0
  br i1 %tobool147, label %err_remove_pf, label %cleanup

err_remove_pf:                                    ; preds = %if.end145
  call void @sony_pf_remove()
  br label %err_disable_device

err_disable_device:                               ; preds = %err_remove_pf, %if.end141
  %result.0 = phi i32 [ %call146, %err_remove_pf ], [ %call142, %if.end141 ]
  %call150 = call i32 @sony_pic_disable(%struct.acpi_device* %device)
  br label %err_free_irq

err_free_irq:                                     ; preds = %err_disable_device, %if.then139
  %result.1 = phi i32 [ %call137, %if.then139 ], [ %result.0, %err_disable_device ]
  %22 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !42
  %irq151 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %22, i32 0, i32 0
  %interrupts152 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq151, i32 0, i32 6
  %arrayidx153 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts152, i64 0, i64 0
  %23 = load i8, i8* %arrayidx153, align 2, !tbaa !41
  %conv154 = zext i8 %23 to i32
  call void @free_irq(i32 %conv154, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  br label %err_release_region

err_release_region:                               ; preds = %err_free_irq, %if.then134
  %result.2 = phi i32 [ %result.1, %err_free_irq ], [ -19, %if.then134 ]
  %24 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1155 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %24, i32 0, i32 0
  %minimum156 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1155, i32 0, i32 3
  %25 = load i16, i16* %minimum156, align 1, !tbaa !24
  %conv157 = zext i16 %25 to i64
  %26 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1158 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %26, i32 0, i32 0
  %address_length159 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1158, i32 0, i32 2
  %27 = load i8, i8* %address_length159, align 2, !tbaa !38
  %conv160 = zext i8 %27 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv157, i64 %conv160)
  %28 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io2161 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %28, i32 0, i32 1
  %minimum162 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2161, i32 0, i32 3
  %29 = load i16, i16* %minimum162, align 1, !tbaa !39
  %tobool163 = icmp ne i16 %29, 0
  br i1 %tobool163, label %if.then164, label %err_remove_compat

if.then164:                                       ; preds = %err_release_region
  %30 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io2165 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %30, i32 0, i32 1
  %minimum166 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2165, i32 0, i32 3
  %31 = load i16, i16* %minimum166, align 1, !tbaa !39
  %conv167 = zext i16 %31 to i64
  %32 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io2168 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %32, i32 0, i32 1
  %address_length169 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2168, i32 0, i32 2
  %33 = load i8, i8* %address_length169, align 1, !tbaa !40
  %conv170 = zext i8 %33 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv167, i64 %conv170)
  br label %err_remove_compat

err_remove_compat:                                ; preds = %if.then164, %err_release_region, %if.then92
  %result.3 = phi i32 [ -19, %if.then92 ], [ %result.2, %if.then164 ], [ %result.2, %err_release_region ]
  call void @sonypi_compat_exit()
  br label %err_remove_input

err_remove_input:                                 ; preds = %err_remove_compat, %if.end8
  %result.4 = phi i32 [ %result.3, %err_remove_compat ], [ %call4, %if.end8 ]
  call void @sony_laptop_remove_input()
  br label %err_free_resources

err_free_resources:                               ; preds = %err_remove_input, %if.then6, %if.then
  %result.5 = phi i32 [ %call2, %if.then ], [ %call4, %if.then6 ], [ %result.4, %err_remove_input ]
  %34 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4, i32 0), align 8, !tbaa !44
  %35 = bitcast %struct.list_head* %34 to i8*
  %add.ptr174 = getelementptr inbounds i8, i8* %35, i64 -16
  %36 = bitcast i8* %add.ptr174 to %struct.sony_pic_ioport*
  br label %for.cond179

for.cond179:                                      ; preds = %for.body183, %err_free_resources
  %.sink = phi %struct.sony_pic_ioport* [ %39, %for.body183 ], [ %36, %err_free_resources ]
  %io.1 = phi %struct.sony_pic_ioport* [ %36, %err_free_resources ], [ %39, %for.body183 ]
  %list187 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %.sink, i32 0, i32 2
  %next188 = getelementptr inbounds %struct.list_head, %struct.list_head* %list187, i32 0, i32 0
  %37 = load %struct.list_head*, %struct.list_head** %next188, align 8, !tbaa !45
  %38 = bitcast %struct.list_head* %37 to i8*
  %add.ptr190 = getelementptr inbounds i8, i8* %38, i64 -16
  %39 = bitcast i8* %add.ptr190 to %struct.sony_pic_ioport*
  %list180 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.1, i32 0, i32 2
  %cmp181 = icmp ne %struct.list_head* %list180, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4)
  br i1 %cmp181, label %for.body183, label %for.end191

for.body183:                                      ; preds = %for.cond179
  %list184 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.1, i32 0, i32 2
  call void @list_del(%struct.list_head* %list184)
  %40 = bitcast %struct.sony_pic_ioport* %io.1 to i8*
  call void @kfree(i8* %40)
  br label %for.cond179

for.end191:                                       ; preds = %for.cond179
  %41 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3, i32 0), align 8, !tbaa !44
  %42 = bitcast %struct.list_head* %41 to i8*
  %add.ptr194 = getelementptr inbounds i8, i8* %42, i64 -8
  %43 = bitcast i8* %add.ptr194 to %struct.sony_pic_irq*
  br label %for.cond200

for.cond200:                                      ; preds = %for.body204, %for.end191
  %.sink6 = phi %struct.sony_pic_irq* [ %46, %for.body204 ], [ %43, %for.end191 ]
  %irq.1 = phi %struct.sony_pic_irq* [ %43, %for.end191 ], [ %46, %for.body204 ]
  %list208 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %.sink6, i32 0, i32 1
  %next209 = getelementptr inbounds %struct.list_head, %struct.list_head* %list208, i32 0, i32 0
  %44 = load %struct.list_head*, %struct.list_head** %next209, align 8, !tbaa !46
  %45 = bitcast %struct.list_head* %44 to i8*
  %add.ptr211 = getelementptr inbounds i8, i8* %45, i64 -8
  %46 = bitcast i8* %add.ptr211 to %struct.sony_pic_irq*
  %list201 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.1, i32 0, i32 1
  %cmp202 = icmp ne %struct.list_head* %list201, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3)
  br i1 %cmp202, label %for.body204, label %for.end212

for.body204:                                      ; preds = %for.cond200
  %list205 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.1, i32 0, i32 1
  call void @list_del(%struct.list_head* %list205)
  %47 = bitcast %struct.sony_pic_irq* %irq.1 to i8*
  call void @kfree(i8* %47)
  br label %for.cond200

for.end212:                                       ; preds = %for.cond200
  store %struct.sony_pic_ioport* null, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  store %struct.sony_pic_irq* null, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !42
  br label %cleanup

cleanup:                                          ; preds = %for.end212, %if.end145
  %retval.0 = phi i32 [ %result.5, %for.end212 ], [ 0, %if.end145 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_remove(%struct.acpi_device* %device) #1 {
entry:
  %call = call i32 @sony_pic_disable(%struct.acpi_device* %device)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %0 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !42
  %irq2 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %0, i32 0, i32 0
  %interrupts = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq2, i32 0, i32 6
  %arrayidx = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts, i64 0, i64 0
  %1 = load i8, i8* %arrayidx, align 2, !tbaa !41
  %conv = zext i8 %1 to i32
  call void @free_irq(i32 %conv, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  %2 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %2, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %3 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv3 = zext i16 %3 to i64
  %4 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io14 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %4, i32 0, i32 0
  %address_length = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io14, i32 0, i32 2
  %5 = load i8, i8* %address_length, align 2, !tbaa !38
  %conv5 = zext i8 %5 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv3, i64 %conv5)
  %6 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %6, i32 0, i32 1
  %minimum6 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %7 = load i16, i16* %minimum6, align 1, !tbaa !39
  %tobool7 = icmp ne i16 %7, 0
  br i1 %tobool7, label %if.then8, label %if.end15

if.then8:                                         ; preds = %if.end
  %8 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io29 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %8, i32 0, i32 1
  %minimum10 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io29, i32 0, i32 3
  %9 = load i16, i16* %minimum10, align 1, !tbaa !39
  %conv11 = zext i16 %9 to i64
  %10 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %io212 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %10, i32 0, i32 1
  %address_length13 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io212, i32 0, i32 2
  %11 = load i8, i8* %address_length13, align 1, !tbaa !40
  %conv14 = zext i8 %11 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv11, i64 %conv14)
  br label %if.end15

if.end15:                                         ; preds = %if.then8, %if.end
  call void @sonypi_compat_exit()
  call void @sony_laptop_remove_input()
  %12 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %12, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj, %struct.attribute_group* @spic_attribute_group)
  call void @sony_pf_remove()
  %13 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4, i32 0), align 8, !tbaa !44
  %14 = bitcast %struct.list_head* %13 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %14, i64 -16
  %15 = bitcast i8* %add.ptr to %struct.sony_pic_ioport*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end15
  %.sink = phi %struct.sony_pic_ioport* [ %18, %for.body ], [ %15, %if.end15 ]
  %io.0 = phi %struct.sony_pic_ioport* [ %15, %if.end15 ], [ %18, %for.body ]
  %list23 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %.sink, i32 0, i32 2
  %next24 = getelementptr inbounds %struct.list_head, %struct.list_head* %list23, i32 0, i32 0
  %16 = load %struct.list_head*, %struct.list_head** %next24, align 8, !tbaa !45
  %17 = bitcast %struct.list_head* %16 to i8*
  %add.ptr26 = getelementptr inbounds i8, i8* %17, i64 -16
  %18 = bitcast i8* %add.ptr26 to %struct.sony_pic_ioport*
  %list19 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.0, i32 0, i32 2
  %cmp = icmp ne %struct.list_head* %list19, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 4)
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %list21 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %io.0, i32 0, i32 2
  call void @list_del(%struct.list_head* %list21)
  %19 = bitcast %struct.sony_pic_ioport* %io.0 to i8*
  call void @kfree(i8* %19)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %20 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3, i32 0), align 8, !tbaa !44
  %21 = bitcast %struct.list_head* %20 to i8*
  %add.ptr29 = getelementptr inbounds i8, i8* %21, i64 -8
  %22 = bitcast i8* %add.ptr29 to %struct.sony_pic_irq*
  br label %for.cond35

for.cond35:                                       ; preds = %for.body39, %for.end
  %.sink4 = phi %struct.sony_pic_irq* [ %25, %for.body39 ], [ %22, %for.end ]
  %irq.0 = phi %struct.sony_pic_irq* [ %22, %for.end ], [ %25, %for.body39 ]
  %list43 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %.sink4, i32 0, i32 1
  %next44 = getelementptr inbounds %struct.list_head, %struct.list_head* %list43, i32 0, i32 0
  %23 = load %struct.list_head*, %struct.list_head** %next44, align 8, !tbaa !46
  %24 = bitcast %struct.list_head* %23 to i8*
  %add.ptr46 = getelementptr inbounds i8, i8* %24, i64 -8
  %25 = bitcast i8* %add.ptr46 to %struct.sony_pic_irq*
  %list36 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.0, i32 0, i32 1
  %cmp37 = icmp ne %struct.list_head* %list36, getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 3)
  br i1 %cmp37, label %for.body39, label %for.end47

for.body39:                                       ; preds = %for.cond35
  %list40 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq.0, i32 0, i32 1
  call void @list_del(%struct.list_head* %list40)
  %26 = bitcast %struct.sony_pic_irq* %irq.0 to i8*
  call void @kfree(i8* %26)
  br label %for.cond35

for.end47:                                        ; preds = %for.cond35
  store %struct.sony_pic_ioport* null, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  store %struct.sony_pic_irq* null, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !42
  %27 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool48 = icmp ne i32 %27, 0
  br i1 %tobool48, label %if.then49, label %cleanup

if.then49:                                        ; preds = %for.end47
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then49, %for.end47, %if.then
  %retval.0 = phi i32 [ -6, %if.then ], [ 0, %if.then49 ], [ 0, %for.end47 ]
  ret i32 %retval.0
}

declare i8* @strcpy(i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @sony_pic_detect_device_type(%struct.sony_pic_dev* %dev) #1 {
entry:
  %call = call %struct.pci_dev* @pci_get_device(i32 32902, i32 28947, %struct.pci_dev* null)
  %tobool = icmp ne %struct.pci_dev* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %model = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 1, i32* %model, align 8, !tbaa !49
  br label %out

if.end:                                           ; preds = %entry
  %call1 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 9793, %struct.pci_dev* null)
  %tobool2 = icmp ne %struct.pci_dev* %call1, null
  br i1 %tobool2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %model4 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 2, i32* %model4, align 8, !tbaa !49
  br label %out

if.end7:                                          ; preds = %if.end
  %call8 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 10169, %struct.pci_dev* null)
  %tobool9 = icmp ne %struct.pci_dev* %call8, null
  br i1 %tobool9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end7
  %model11 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 4, i32* %model11, align 8, !tbaa !49
  %handle_irq = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 7
  store i32 (i8, i8)* @type3_handle_irq, i32 (i8, i8)** %handle_irq, align 8, !tbaa !50
  br label %out

if.end14:                                         ; preds = %if.end7
  %call15 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 10261, %struct.pci_dev* null)
  %tobool16 = icmp ne %struct.pci_dev* %call15, null
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.end14
  %model18 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  store i32 4, i32* %model18, align 8, !tbaa !49
  %handle_irq19 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 7
  store i32 (i8, i8)* @type3_handle_irq, i32 (i8, i8)** %handle_irq19, align 8, !tbaa !50
  br label %out

if.end22:                                         ; preds = %if.end14
  %call23 = call %struct.pci_dev* @pci_get_device(i32 32902, i32 10519, %struct.pci_dev* null)
  %tobool24 = icmp ne %struct.pci_dev* %call23, null
  %model26 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  br i1 %tobool24, label %if.then25, label %if.end30

if.then25:                                        ; preds = %if.end22
  store i32 4, i32* %model26, align 8, !tbaa !49
  %handle_irq27 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 7
  store i32 (i8, i8)* @type3_handle_irq, i32 (i8, i8)** %handle_irq27, align 8, !tbaa !50
  br label %out

if.end30:                                         ; preds = %if.end22
  store i32 2, i32* %model26, align 8, !tbaa !49
  br label %out

out:                                              ; preds = %if.end30, %if.then25, %if.then17, %if.then10, %if.then3, %if.then
  %.sink1 = phi i16 [ 18, %if.end30 ], [ 18, %if.then25 ], [ 18, %if.then17 ], [ 18, %if.then10 ], [ 18, %if.then3 ], [ 4, %if.then ]
  %.sink = phi %struct.sonypi_eventtypes* [ getelementptr inbounds ([15 x %struct.sonypi_eventtypes], [15 x %struct.sonypi_eventtypes]* @type2_events, i32 0, i32 0), %if.end30 ], [ getelementptr inbounds ([12 x %struct.sonypi_eventtypes], [12 x %struct.sonypi_eventtypes]* @type3_events, i32 0, i32 0), %if.then25 ], [ getelementptr inbounds ([12 x %struct.sonypi_eventtypes], [12 x %struct.sonypi_eventtypes]* @type3_events, i32 0, i32 0), %if.then17 ], [ getelementptr inbounds ([12 x %struct.sonypi_eventtypes], [12 x %struct.sonypi_eventtypes]* @type3_events, i32 0, i32 0), %if.then10 ], [ getelementptr inbounds ([15 x %struct.sonypi_eventtypes], [15 x %struct.sonypi_eventtypes]* @type2_events, i32 0, i32 0), %if.then3 ], [ getelementptr inbounds ([11 x %struct.sonypi_eventtypes], [11 x %struct.sonypi_eventtypes]* @type1_events, i32 0, i32 0), %if.then ]
  %pcidev.0 = phi %struct.pci_dev* [ %call, %if.then ], [ %call1, %if.then3 ], [ %call8, %if.then10 ], [ %call15, %if.then17 ], [ %call23, %if.then25 ], [ %call23, %if.end30 ]
  %evport_offset32 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 9
  store i16 %.sink1, i16* %evport_offset32, align 4, !tbaa !51
  %event_types33 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 6
  store %struct.sonypi_eventtypes* %.sink, %struct.sonypi_eventtypes** %event_types33, align 8, !tbaa !52
  %tobool34 = icmp ne %struct.pci_dev* %pcidev.0, null
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %out
  call void @pci_dev_put(%struct.pci_dev* %pcidev.0)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %out
  %model37 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %dev, i32 0, i32 8
  %0 = load i32, i32* %model37, align 8, !tbaa !49
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end36
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end36
  call void (i8*, ...) @printk(i8* null)
  ret void
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_possible_resources(%struct.acpi_device* %device) #1 {
entry:
  %tobool = icmp ne %struct.acpi_device* %device, null
  br i1 %tobool, label %do.body, label %cleanup

do.body:                                          ; preds = %entry
  %0 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %if.then2, label %do.end

if.then2:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then2, %do.body
  %call4 = call i32 @acpi_bus_get_status(%struct.acpi_device* %device)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %do.end
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end8:                                          ; preds = %do.end
  %status9 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 6
  %1 = bitcast %struct.acpi_device_status* %status9 to i32*
  %bf.load = load i32, i32* %1, align 8
  %bf.lshr = lshr i32 %bf.load, 1
  %bf.clear = and i32 %bf.lshr, 1
  %tobool10 = icmp ne i32 %bf.clear, 0
  %2 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool20 = icmp ne i32 %2, 0
  br i1 %tobool10, label %do.body19, label %do.body12

do.body12:                                        ; preds = %if.end8
  br i1 %tobool20, label %if.then14, label %do.body27

if.then14:                                        ; preds = %do.body12
  call void (i8*, ...) @printk(i8* null)
  br label %do.body27

do.body19:                                        ; preds = %if.end8
  br i1 %tobool20, label %if.then21, label %do.body27

if.then21:                                        ; preds = %do.body19
  call void (i8*, ...) @printk(i8* null)
  br label %do.body27

do.body27:                                        ; preds = %if.then21, %do.body19, %if.then14, %do.body12
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool28 = icmp ne i32 %3, 0
  br i1 %tobool28, label %if.then29, label %do.end33

if.then29:                                        ; preds = %do.body27
  call void (i8*, ...) @printk(i8* null)
  br label %do.end33

do.end33:                                         ; preds = %if.then29, %do.body27
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %4 = load i8*, i8** %handle, align 8, !tbaa !53
  %call34 = call i32 @acpi_walk_resources(i8* %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.36, i32 0, i32 0), i32 (%struct.acpi_resource*, i8*)* @sony_pic_read_possible_resource, i8* bitcast (%struct.sony_pic_dev* @spic_dev to i8*))
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.then36, label %cleanup

if.then36:                                        ; preds = %do.end33
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then36, %do.end33, %if.then6, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ %call4, %if.then6 ], [ -19, %if.then36 ], [ %call4, %do.end33 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_laptop_setup_input(%struct.acpi_device* %acpi_device) #1 {
entry:
  %call = call i32 @atomic_add_return(i32 1, %struct.atomic_t* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 0))
  %cmp = icmp sgt i32 %call, 1
  br i1 %cmp, label %cleanup, label %do.body

do.body:                                          ; preds = %entry
  %call1 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4))
  call void @__raw_spin_lock_init(%struct.raw_spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.45, i32 0, i32 0), %struct.lock_class_key* @sony_laptop_setup_input.__key)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  %call5 = call i32 @__kfifo_alloc(%struct.__kfifo* %kfifo, i32 128, i64 1, i32 208)
  %call6 = call i32 @__kfifo_int_must_check_helper(i32 %call5)
  %tobool = icmp ne i32 %call6, 0
  br i1 %tobool, label %if.then7, label %do.body11

if.then7:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %err_dec_users

do.body11:                                        ; preds = %do.body
  call void @init_timer_key(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5), i32 0, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.48, i32 0, i32 0), %struct.lock_class_key* @sony_laptop_setup_input.__key.47)
  store void (i64)* @do_sony_laptop_release_key, void (i64)** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5, i32 3), align 8, !tbaa !81
  store i64 0, i64* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5, i32 4), align 8, !tbaa !82
  %call16 = call %struct.input_dev* @input_allocate_device()
  %tobool17 = icmp ne %struct.input_dev* %call16, null
  br i1 %tobool17, label %if.end19, label %err_free_kfifo

if.end19:                                         ; preds = %do.body11
  %name = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 0
  store i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.49, i32 0, i32 0), i8** %name, align 8, !tbaa !83
  %id = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 3
  %bustype = getelementptr inbounds %struct.input_id, %struct.input_id* %id, i32 0, i32 0
  store i16 16, i16* %bustype, align 8, !tbaa !86
  %id20 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 3
  %vendor = getelementptr inbounds %struct.input_id, %struct.input_id* %id20, i32 0, i32 1
  store i16 4173, i16* %vendor, align 2, !tbaa !87
  %dev = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %acpi_device, i32 0, i32 16
  %dev21 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 39
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev21, i32 0, i32 0
  store %struct.device* %dev, %struct.device** %parent, align 8, !tbaa !88
  call void @input_set_capability(%struct.input_dev* %call16, i32 4, i32 4)
  %evbit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 5
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %evbit, i32 0, i32 0
  call void @__set_bit(i32 1, i64* %arraydecay)
  %keycodesize = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 16
  store i32 4, i32* %keycodesize, align 8, !tbaa !89
  %keycodemax = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 15
  store i32 60, i32* %keycodemax, align 4, !tbaa !90
  %keycode = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 17
  store i8* bitcast ([60 x i32]* @sony_laptop_input_keycode_map to i8*), i8** %keycode, align 8, !tbaa !91
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end19
  %i.0 = phi i32 [ 0, %if.end19 ], [ %inc, %for.body ]
  %conv = sext i32 %i.0 to i64
  %cmp22 = icmp ult i64 %conv, 60
  br i1 %cmp22, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [60 x i32], [60 x i32]* @sony_laptop_input_keycode_map, i64 0, i64 %idxprom
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %keybit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 6
  %arraydecay24 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit, i32 0, i32 0
  call void @__set_bit(i32 %1, i64* %arraydecay24)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %keybit25 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call16, i32 0, i32 6
  %arraydecay26 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit25, i32 0, i32 0
  call void @__clear_bit(i32 0, i64* %arraydecay26)
  %call27 = call i32 @input_register_device(%struct.input_dev* %call16)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %err_free_keydev, label %if.end30

if.end30:                                         ; preds = %for.end
  store %struct.input_dev* %call16, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !92
  %call31 = call %struct.input_dev* @input_allocate_device()
  %tobool32 = icmp ne %struct.input_dev* %call31, null
  br i1 %tobool32, label %if.end34, label %err_unregister_keydev

if.end34:                                         ; preds = %if.end30
  %name35 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call31, i32 0, i32 0
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.50, i32 0, i32 0), i8** %name35, align 8, !tbaa !83
  %id36 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call31, i32 0, i32 3
  %bustype37 = getelementptr inbounds %struct.input_id, %struct.input_id* %id36, i32 0, i32 0
  store i16 16, i16* %bustype37, align 8, !tbaa !86
  %id38 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call31, i32 0, i32 3
  %vendor39 = getelementptr inbounds %struct.input_id, %struct.input_id* %id38, i32 0, i32 1
  store i16 4173, i16* %vendor39, align 2, !tbaa !87
  %dev40 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %acpi_device, i32 0, i32 16
  %dev41 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call31, i32 0, i32 39
  %parent42 = getelementptr inbounds %struct.device, %struct.device* %dev41, i32 0, i32 0
  store %struct.device* %dev40, %struct.device** %parent42, align 8, !tbaa !88
  call void @input_set_capability(%struct.input_dev* %call31, i32 1, i32 274)
  call void @input_set_capability(%struct.input_dev* %call31, i32 2, i32 8)
  %call43 = call i32 @input_register_device(%struct.input_dev* %call31)
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %err_free_jogdev, label %if.end46

if.end46:                                         ; preds = %if.end34
  store %struct.input_dev* %call31, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !95
  br label %cleanup

err_free_jogdev:                                  ; preds = %if.end34
  call void @input_free_device(%struct.input_dev* %call31)
  br label %err_unregister_keydev

err_unregister_keydev:                            ; preds = %err_free_jogdev, %if.end30
  %error.0 = phi i32 [ %call43, %err_free_jogdev ], [ -12, %if.end30 ]
  call void @input_unregister_device(%struct.input_dev* %call16)
  br label %err_free_keydev

err_free_keydev:                                  ; preds = %err_unregister_keydev, %for.end
  %key_dev.0 = phi %struct.input_dev* [ null, %err_unregister_keydev ], [ %call16, %for.end ]
  %error.1 = phi i32 [ %error.0, %err_unregister_keydev ], [ %call27, %for.end ]
  call void @input_free_device(%struct.input_dev* %key_dev.0)
  br label %err_free_kfifo

err_free_kfifo:                                   ; preds = %err_free_keydev, %do.body11
  %error.2 = phi i32 [ %error.1, %err_free_keydev ], [ -12, %do.body11 ]
  %2 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo49 = bitcast %union.anon.58* %2 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo49)
  br label %err_dec_users

err_dec_users:                                    ; preds = %err_free_kfifo, %if.then7
  %error.3 = phi i32 [ %call6, %if.then7 ], [ %error.2, %err_free_kfifo ]
  call void @atomic_dec(%struct.atomic_t* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %err_dec_users, %if.end46, %entry
  %retval.0 = phi i32 [ %error.3, %err_dec_users ], [ 0, %if.end46 ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_compat_init() #1 {
entry:
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2))
  call void @__raw_spin_lock_init(%struct.raw_spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.51, i32 0, i32 0), %struct.lock_class_key* @sonypi_compat_init.__key)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  %call4 = call i32 @__kfifo_alloc(%struct.__kfifo* %kfifo, i32 128, i64 1, i32 208)
  %call5 = call i32 @__kfifo_int_must_check_helper(i32 %call4)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then, label %do.body7

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

do.body7:                                         ; preds = %entry
  call void @__init_waitqueue_head(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.53, i32 0, i32 0), %struct.lock_class_key* @sonypi_compat_init.__key.52)
  %1 = load i32, i32* @minor, align 4, !tbaa !12
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %if.then10, label %if.end11

if.then10:                                        ; preds = %do.body7
  %2 = load i32, i32* @minor, align 4, !tbaa !12
  store i32 %2, i32* getelementptr inbounds (%struct.miscdevice, %struct.miscdevice* @sonypi_misc_device, i32 0, i32 0), align 8, !tbaa !96
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %do.body7
  %call12 = call i32 @misc_register(%struct.miscdevice* @sonypi_misc_device)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  call void (i8*, ...) @printk(i8* null)
  %3 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo23 = bitcast %union.anon.58* %3 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo23)
  br label %cleanup

if.end16:                                         ; preds = %if.end11
  %4 = load i32, i32* @minor, align 4, !tbaa !12
  %cmp17 = icmp eq i32 %4, -1
  br i1 %cmp17, label %if.then18, label %cleanup

if.then18:                                        ; preds = %if.end16
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then18, %if.end16, %if.then14, %if.then
  %retval.0 = phi i32 [ %call5, %if.then ], [ %call12, %if.then14 ], [ 0, %if.then18 ], [ 0, %if.end16 ]
  ret i32 %retval.0
}

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #2

declare void @__release_region(%struct.resource*, i64, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #0 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_irq(i32 %irq, i8* %dev_id) #1 {
entry:
  %0 = bitcast i8* %dev_id to %struct.sony_pic_dev*
  %cur_ioport = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %1 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport, align 8, !tbaa !23
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %1, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %2 = load i16, i16* %minimum, align 1, !tbaa !24
  %conv = zext i16 %2 to i32
  %call = call zeroext i8 @inb_p(i32 %conv)
  %cur_ioport1 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %3 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport1, align 8, !tbaa !23
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 1
  %minimum2 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %4 = load i16, i16* %minimum2, align 1, !tbaa !39
  %tobool = icmp ne i16 %4, 0
  %cur_ioport3 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 2
  %5 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** %cur_ioport3, align 8, !tbaa !23
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %io24 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 1
  %minimum5 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io24, i32 0, i32 3
  %6 = load i16, i16* %minimum5, align 1, !tbaa !39
  %conv6 = zext i16 %6 to i32
  br label %if.end

if.else:                                          ; preds = %entry
  %io19 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %5, i32 0, i32 0
  %minimum10 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io19, i32 0, i32 3
  %7 = load i16, i16* %minimum10, align 1, !tbaa !24
  %conv11 = zext i16 %7 to i32
  %evport_offset = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 9
  %8 = load i16, i16* %evport_offset, align 4, !tbaa !51
  %conv12 = zext i16 %8 to i32
  %add = add nsw i32 %conv11, %conv12
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %add.sink = phi i32 [ %add, %if.else ], [ %conv6, %if.then ]
  %call13 = call zeroext i8 @inb_p(i32 %add.sink)
  %9 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool14 = icmp ne i32 %9, 0
  br i1 %tobool14, label %if.then15, label %do.end

if.then15:                                        ; preds = %if.end
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then15, %if.end
  %conv26 = zext i8 %call to i32
  %cmp = icmp eq i32 %conv26, 0
  %conv28 = zext i8 %call to i32
  %cmp29 = icmp eq i32 %conv28, 255
  %or.cond = or i1 %cmp, %cmp29
  br i1 %or.cond, label %cleanup, label %if.end32

if.end32:                                         ; preds = %do.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc87, %if.end32
  %i.0 = phi i32 [ 0, %if.end32 ], [ %inc88, %for.inc87 ]
  %event_types = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %10 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types, align 8, !tbaa !52
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %10, i64 %idxprom
  %mask = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx, i32 0, i32 1
  %11 = load i64, i64* %mask, align 8, !tbaa !98
  %tobool33 = icmp ne i64 %11, 0
  br i1 %tobool33, label %for.body, label %for.end89

for.body:                                         ; preds = %for.cond
  %conv34 = zext i8 %call13 to i32
  %event_types35 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %12 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types35, align 8, !tbaa !52
  %idxprom36 = sext i32 %i.0 to i64
  %arrayidx37 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %12, i64 %idxprom36
  %data = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx37, i32 0, i32 0
  %13 = load i8, i8* %data, align 8, !tbaa !100
  %conv38 = zext i8 %13 to i32
  %and = and i32 %conv34, %conv38
  %event_types39 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %14 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types39, align 8, !tbaa !52
  %idxprom40 = sext i32 %i.0 to i64
  %arrayidx41 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %14, i64 %idxprom40
  %data42 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx41, i32 0, i32 0
  %15 = load i8, i8* %data42, align 8, !tbaa !100
  %conv43 = zext i8 %15 to i32
  %cmp44 = icmp ne i32 %and, %conv43
  br i1 %cmp44, label %for.inc87, label %if.end47

if.end47:                                         ; preds = %for.body
  %16 = load i64, i64* @mask, align 8, !tbaa !101
  %event_types48 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %17 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types48, align 8, !tbaa !52
  %idxprom49 = sext i32 %i.0 to i64
  %arrayidx50 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %17, i64 %idxprom49
  %mask51 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx50, i32 0, i32 1
  %18 = load i64, i64* %mask51, align 8, !tbaa !98
  %and52 = and i64 %16, %18
  %tobool53 = icmp ne i64 %and52, 0
  br i1 %tobool53, label %if.end55, label %for.inc87

if.end55:                                         ; preds = %if.end47
  br label %for.cond56

for.cond56:                                       ; preds = %for.inc, %if.end55
  %j.0 = phi i32 [ 0, %if.end55 ], [ %inc, %for.inc ]
  %event_types57 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %19 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types57, align 8, !tbaa !52
  %idxprom58 = sext i32 %i.0 to i64
  %arrayidx59 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %19, i64 %idxprom58
  %events = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx59, i32 0, i32 2
  %20 = load %struct.sonypi_event*, %struct.sonypi_event** %events, align 8, !tbaa !102
  %idxprom60 = sext i32 %j.0 to i64
  %arrayidx61 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %20, i64 %idxprom60
  %event = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %arrayidx61, i32 0, i32 1
  %21 = load i8, i8* %event, align 1, !tbaa !103
  %tobool62 = icmp ne i8 %21, 0
  br i1 %tobool62, label %for.body63, label %for.inc87

for.body63:                                       ; preds = %for.cond56
  %conv64 = zext i8 %call to i32
  %event_types65 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %22 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types65, align 8, !tbaa !52
  %idxprom66 = sext i32 %i.0 to i64
  %arrayidx67 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %22, i64 %idxprom66
  %events68 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx67, i32 0, i32 2
  %23 = load %struct.sonypi_event*, %struct.sonypi_event** %events68, align 8, !tbaa !102
  %idxprom69 = sext i32 %j.0 to i64
  %arrayidx70 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %23, i64 %idxprom69
  %data71 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %arrayidx70, i32 0, i32 0
  %24 = load i8, i8* %data71, align 1, !tbaa !105
  %conv72 = zext i8 %24 to i32
  %cmp73 = icmp eq i32 %conv64, %conv72
  br i1 %cmp73, label %if.then75, label %for.inc

if.then75:                                        ; preds = %for.body63
  %event_types76 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 6
  %25 = load %struct.sonypi_eventtypes*, %struct.sonypi_eventtypes** %event_types76, align 8, !tbaa !52
  %idxprom77 = sext i32 %i.0 to i64
  %arrayidx78 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %25, i64 %idxprom77
  %events79 = getelementptr inbounds %struct.sonypi_eventtypes, %struct.sonypi_eventtypes* %arrayidx78, i32 0, i32 2
  %26 = load %struct.sonypi_event*, %struct.sonypi_event** %events79, align 8, !tbaa !102
  %idxprom80 = sext i32 %j.0 to i64
  %arrayidx81 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %26, i64 %idxprom80
  %event82 = getelementptr inbounds %struct.sonypi_event, %struct.sonypi_event* %arrayidx81, i32 0, i32 1
  %27 = load i8, i8* %event82, align 1, !tbaa !103
  %tobool83 = icmp ne i8 %27, 0
  br i1 %tobool83, label %found, label %cleanup

for.inc:                                          ; preds = %for.body63
  %inc = add nsw i32 %j.0, 1
  br label %for.cond56

for.inc87:                                        ; preds = %for.cond56, %if.end47, %for.body
  %inc88 = add nsw i32 %i.0, 1
  br label %for.cond

for.end89:                                        ; preds = %for.cond
  %handle_irq = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 7
  %28 = load i32 (i8, i8)*, i32 (i8, i8)** %handle_irq, align 8, !tbaa !50
  %tobool90 = icmp ne i32 (i8, i8)* %28, null
  br i1 %tobool90, label %land.lhs.true, label %do.body97

land.lhs.true:                                    ; preds = %for.end89
  %handle_irq91 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 7
  %29 = load i32 (i8, i8)*, i32 (i8, i8)** %handle_irq91, align 8, !tbaa !50
  %call92 = call i32 %29(i8 zeroext %call13, i8 zeroext %call)
  %cmp93 = icmp ne i32 %call92, 0
  %30 = load i32, i32* @debug, align 4
  %tobool98 = icmp ne i32 %30, 0
  %or.cond1 = and i1 %cmp93, %tobool98
  br i1 %or.cond1, label %if.then99, label %cleanup

do.body97:                                        ; preds = %for.end89
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool98.old = icmp ne i32 %.old, 0
  br i1 %tobool98.old, label %if.then99, label %cleanup

if.then99:                                        ; preds = %do.body97, %land.lhs.true
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

found:                                            ; preds = %if.then75
  call void @sony_laptop_report_input_event(i8 zeroext %27)
  %acpi_dev = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 0
  %31 = load %struct.acpi_device*, %struct.acpi_device** %acpi_dev, align 8, !tbaa !36
  %conv112 = zext i8 %27 to i32
  %call113 = call i32 @acpi_bus_generate_proc_event(%struct.acpi_device* %31, i8 zeroext 1, i32 %conv112)
  call void @sonypi_compat_report_event(i8 zeroext %27)
  br label %cleanup

cleanup:                                          ; preds = %found, %if.then99, %do.body97, %land.lhs.true, %if.then75, %do.end
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_enable(%struct.acpi_device* %device, %struct.sony_pic_ioport* %ioport, %struct.sony_pic_irq* %irq) #1 {
entry:
  %buffer = alloca %struct.acpi_buffer, align 8
  %0 = bitcast %struct.acpi_buffer* %buffer to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 16, i32 8, i1 false)
  %tobool = icmp ne %struct.sony_pic_ioport* %ioport, null
  %tobool1 = icmp ne %struct.sony_pic_irq* %irq, null
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call = call i8* @kzalloc(i64 273, i32 208)
  %1 = bitcast i8* %call to %struct.anon.63*
  %tobool2 = icmp ne %struct.anon.63* %1, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %length = getelementptr inbounds %struct.acpi_buffer, %struct.acpi_buffer* %buffer, i32 0, i32 0
  store i64 273, i64* %length, align 8, !tbaa !106
  %2 = bitcast %struct.anon.63* %1 to i8*
  %pointer = getelementptr inbounds %struct.acpi_buffer, %struct.acpi_buffer* %buffer, i32 0, i32 1
  store i8* %2, i8** %pointer, align 8, !tbaa !108
  %3 = load i32, i32* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 8), align 8, !tbaa !49
  %cmp = icmp eq i32 %3, 1
  %res1 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 0
  %type = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res1, i32 0, i32 0
  store i32 4, i32* %type, align 1, !tbaa !109
  %res16 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 0
  %length7 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res16, i32 0, i32 1
  store i32 68, i32* %length7, align 1, !tbaa !112
  %cmp8 = icmp uge i64 7, 64
  %res110 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 0
  %data = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res110, i32 0, i32 2
  %io = bitcast %union.acpi_resource_data* %data to %struct.acpi_resource_io*
  %4 = bitcast %struct.acpi_resource_io* %io to i8*
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %ioport, i32 0, i32 0
  %5 = bitcast %struct.acpi_resource_io* %io1 to i8*
  br i1 %cmp, label %if.then5, label %if.else60

if.then5:                                         ; preds = %if.end4
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then5
  %call11 = call i8* @__memcpy(i8* %4, i8* %5, i64 7)
  br label %if.end16

if.else:                                          ; preds = %if.then5
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 7, i32 1, i1 false)
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then9
  %res2 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 1
  %type17 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res2, i32 0, i32 0
  store i32 4, i32* %type17, align 1, !tbaa !113
  %res218 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 1
  %length19 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res218, i32 0, i32 1
  store i32 68, i32* %length19, align 1, !tbaa !114
  %cmp22 = icmp uge i64 7, 64
  %res224 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 1
  %data25 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res224, i32 0, i32 2
  %io26 = bitcast %union.acpi_resource_data* %data25 to %struct.acpi_resource_io*
  %6 = bitcast %struct.acpi_resource_io* %io26 to i8*
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %ioport, i32 0, i32 1
  %7 = bitcast %struct.acpi_resource_io* %io2 to i8*
  br i1 %cmp22, label %if.then23, label %if.else28

if.then23:                                        ; preds = %if.end16
  %call27 = call i8* @__memcpy(i8* %6, i8* %7, i64 7)
  br label %if.end33

if.else28:                                        ; preds = %if.end16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 7, i32 1, i1 false)
  br label %if.end33

if.end33:                                         ; preds = %if.else28, %if.then23
  %res3 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 2
  %type35 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res3, i32 0, i32 0
  store i32 0, i32* %type35, align 1, !tbaa !115
  %res336 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 2
  %length37 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res336, i32 0, i32 1
  store i32 68, i32* %length37, align 1, !tbaa !116
  %cmp40 = icmp uge i64 7, 64
  %res342 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 2
  %data43 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res342, i32 0, i32 2
  %irq44 = bitcast %union.acpi_resource_data* %data43 to %struct.acpi_resource_irq*
  %8 = bitcast %struct.acpi_resource_irq* %irq44 to i8*
  %irq45 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq, i32 0, i32 0
  %9 = bitcast %struct.acpi_resource_irq* %irq45 to i8*
  br i1 %cmp40, label %if.then41, label %if.else47

if.then41:                                        ; preds = %if.end33
  %call46 = call i8* @__memcpy(i8* %8, i8* %9, i64 7)
  br label %if.end52

if.else47:                                        ; preds = %if.end33
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 7, i32 1, i1 false)
  br label %if.end52

if.end52:                                         ; preds = %if.else47, %if.then41
  %res354 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 2
  %data55 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res354, i32 0, i32 2
  %irq56 = bitcast %union.acpi_resource_data* %data55 to %struct.acpi_resource_irq*
  %sharable = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq56, i32 0, i32 3
  store i8 1, i8* %sharable, align 1, !tbaa !41
  %res4 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 3
  %type57 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res4, i32 0, i32 0
  store i32 7, i32* %type57, align 1, !tbaa !117
  %res458 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 3
  br label %if.end109

if.else60:                                        ; preds = %if.end4
  br i1 %cmp8, label %if.then68, label %if.else74

if.then68:                                        ; preds = %if.else60
  %call73 = call i8* @__memcpy(i8* %4, i8* %5, i64 7)
  br label %if.end79

if.else74:                                        ; preds = %if.else60
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 7, i32 1, i1 false)
  br label %if.end79

if.end79:                                         ; preds = %if.else74, %if.then68
  %res281 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 1
  %type82 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res281, i32 0, i32 0
  store i32 0, i32* %type82, align 1, !tbaa !113
  %res283 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 1
  %length84 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res283, i32 0, i32 1
  store i32 68, i32* %length84, align 1, !tbaa !114
  %cmp87 = icmp uge i64 7, 64
  %res289 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 1
  %data90 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res289, i32 0, i32 2
  %irq91 = bitcast %union.acpi_resource_data* %data90 to %struct.acpi_resource_irq*
  %10 = bitcast %struct.acpi_resource_irq* %irq91 to i8*
  %irq92 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %irq, i32 0, i32 0
  %11 = bitcast %struct.acpi_resource_irq* %irq92 to i8*
  br i1 %cmp87, label %if.then88, label %if.else94

if.then88:                                        ; preds = %if.end79
  %call93 = call i8* @__memcpy(i8* %10, i8* %11, i64 7)
  br label %if.end99

if.else94:                                        ; preds = %if.end79
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 7, i32 1, i1 false)
  br label %if.end99

if.end99:                                         ; preds = %if.else94, %if.then88
  %res2101 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 1
  %data102 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res2101, i32 0, i32 2
  %irq103 = bitcast %union.acpi_resource_data* %data102 to %struct.acpi_resource_irq*
  %sharable104 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq103, i32 0, i32 3
  store i8 1, i8* %sharable104, align 1, !tbaa !41
  %res3105 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 2
  %type106 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res3105, i32 0, i32 0
  store i32 7, i32* %type106, align 1, !tbaa !115
  %res3107 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %1, i32 0, i32 2
  br label %if.end109

if.end109:                                        ; preds = %if.end99, %if.end52
  %res3107.sink = phi %struct.acpi_resource* [ %res3107, %if.end99 ], [ %res458, %if.end52 ]
  %length108 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %res3107.sink, i32 0, i32 1
  store i32 68, i32* %length108, align 1, !tbaa !12
  %12 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool110 = icmp ne i32 %12, 0
  br i1 %tobool110, label %if.then111, label %do.end

if.then111:                                       ; preds = %if.end109
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then111, %if.end109
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %13 = load i8*, i8** %handle, align 8, !tbaa !53
  %call114 = call i32 @acpi_set_current_resources(i8* %13, %struct.acpi_buffer* %buffer)
  %tobool115 = icmp ne i32 %call114, 0
  br i1 %tobool115, label %if.then116, label %if.end118

if.then116:                                       ; preds = %do.end
  call void (i8*, ...) @printk(i8* null)
  br label %end

if.end118:                                        ; preds = %do.end
  call void @sony_pic_call1(i8 zeroext -126)
  %call120 = call zeroext i8 @sony_pic_call2(i8 zeroext -127, i8 zeroext -1)
  %14 = load i32, i32* @compat, align 4, !tbaa !12
  %tobool121 = icmp ne i32 %14, 0
  %cond = select i1 %tobool121, i32 146, i32 130
  %conv = trunc i32 %cond to i8
  call void @sony_pic_call1(i8 zeroext %conv)
  br label %end

end:                                              ; preds = %if.end118, %if.then116
  %result.0 = phi i32 [ -19, %if.then116 ], [ 0, %if.end118 ]
  %15 = bitcast %struct.anon.63* %1 to i8*
  call void @kfree(i8* %15)
  br label %cleanup

cleanup:                                          ; preds = %end, %if.end, %entry
  %retval.0 = phi i32 [ %result.0, %end ], [ -22, %entry ], [ -12, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pf_add() #1 {
entry:
  %call = call i32 @atomic_add_return(i32 1, %struct.atomic_t* @sony_pf_users)
  %cmp = icmp sgt i32 %call, 1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @platform_driver_register(%struct.platform_driver* @sony_pf_driver)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %out, label %if.end3

if.end3:                                          ; preds = %if.end
  %call4 = call %struct.platform_device* @platform_device_alloc(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.26, i32 0, i32 0), i32 -1)
  store %struct.platform_device* %call4, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  %0 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  %tobool5 = icmp ne %struct.platform_device* %0, null
  br i1 %tobool5, label %if.end7, label %out_platform_registered

if.end7:                                          ; preds = %if.end3
  %1 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  %call8 = call i32 @platform_device_add(%struct.platform_device* %1)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %out_platform_alloced, label %cleanup

out_platform_alloced:                             ; preds = %if.end7
  %2 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  call void @platform_device_put(%struct.platform_device* %2)
  store %struct.platform_device* null, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  br label %out_platform_registered

out_platform_registered:                          ; preds = %out_platform_alloced, %if.end3
  %ret.0 = phi i32 [ %call8, %out_platform_alloced ], [ -12, %if.end3 ]
  call void @platform_driver_unregister(%struct.platform_driver* @sony_pf_driver)
  br label %out

out:                                              ; preds = %out_platform_registered, %if.end
  %ret.1 = phi i32 [ %ret.0, %out_platform_registered ], [ %call1, %if.end ]
  call void @atomic_dec(%struct.atomic_t* @sony_pf_users)
  br label %cleanup

cleanup:                                          ; preds = %out, %if.end7, %entry
  %retval.0 = phi i32 [ %ret.1, %out ], [ 0, %entry ], [ 0, %if.end7 ]
  ret i32 %retval.0
}

declare i32 @sysfs_create_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: nounwind uwtable
define internal void @sony_pf_remove() #1 {
entry:
  %call = call i32 @atomic_dec_and_test(%struct.atomic_t* @sony_pf_users)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %0 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  call void @platform_device_unregister(%struct.platform_device* %0)
  call void @platform_driver_unregister(%struct.platform_driver* @sony_pf_driver)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_disable(%struct.acpi_device* %device) #1 {
entry:
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %0 = load i8*, i8** %handle, align 8, !tbaa !53
  %call = call i32 @acpi_evaluate_object(i8* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.76, i32 0, i32 0), %struct.acpi_object_list* null, %struct.acpi_buffer* null)
  switch i32 %call, label %cleanup [
    i32 0, label %do.body
    i32 5, label %do.body
  ]

do.body:                                          ; preds = %entry, %entry
  %1 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then2, %do.body, %entry
  %retval.0 = phi i32 [ -6, %entry ], [ 0, %if.then2 ], [ 0, %do.body ]
  ret i32 %retval.0
}

declare void @free_irq(i32, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @sonypi_compat_exit() #1 {
entry:
  %call = call i32 @misc_deregister(%struct.miscdevice* @sonypi_misc_device)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_laptop_remove_input() #1 {
entry:
  %kp = alloca %struct.sony_laptop_keypress, align 8
  %0 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 16, i32 8, i1 false)
  %call = call i32 @atomic_dec_and_test(%struct.atomic_t* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 0))
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @del_timer_sync(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5))
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %1 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %2 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %2 to %struct.__kfifo*
  %conv = trunc i64 16 to i32
  %call2 = call i32 @__kfifo_out(%struct.__kfifo* %kfifo, i8* %1, i32 %conv)
  %call3 = call i32 @__kfifo_uint_must_check_helper(i32 %call2)
  %conv4 = zext i32 %call3 to i64
  %cmp = icmp eq i64 %conv4, 16
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %dev = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %3 = load %struct.input_dev*, %struct.input_dev** %dev, align 8, !tbaa !118
  %key = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %4 = load i32, i32* %key, align 8, !tbaa !120
  call void @input_report_key(%struct.input_dev* %3, i32 %4, i32 0)
  %dev6 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %5 = load %struct.input_dev*, %struct.input_dev** %dev6, align 8, !tbaa !118
  call void @input_sync(%struct.input_dev* %5)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %6 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !92
  call void @input_unregister_device(%struct.input_dev* %6)
  store %struct.input_dev* null, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !92
  %7 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !95
  %tobool7 = icmp ne %struct.input_dev* %7, null
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %while.end
  %8 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !95
  call void @input_unregister_device(%struct.input_dev* %8)
  store %struct.input_dev* null, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !95
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %while.end
  %9 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo12 = bitcast %union.anon.58* %9 to %struct.__kfifo*
  call void @__kfifo_free(%struct.__kfifo* %kfifo12)
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %entry
  ret void
}

declare void @list_del(%struct.list_head*) #2

declare void @kfree(i8*) #2

declare %struct.pci_dev* @pci_get_device(i32, i32, %struct.pci_dev*) #2

; Function Attrs: nounwind uwtable
define internal i32 @type3_handle_irq(i8 zeroext %data_mask, i8 zeroext %ev) #1 {
entry:
  %conv = zext i8 %data_mask to i32
  %cmp = icmp eq i32 %conv, 49
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %conv2 = zext i8 %ev to i32
  %cmp3 = icmp eq i32 %conv2, 92
  %conv5 = zext i8 %ev to i32
  %cmp6 = icmp eq i32 %conv5, 95
  %or.cond = or i1 %cmp3, %cmp6
  br i1 %or.cond, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  call void @sony_pic_call1(i8 zeroext -96)
  br label %return

if.else:                                          ; preds = %if.then
  %conv9 = zext i8 %ev to i32
  %cmp10 = icmp eq i32 %conv9, 97
  br i1 %cmp10, label %if.then12, label %return

if.then12:                                        ; preds = %if.else
  call void @sony_pic_call1(i8 zeroext -77)
  br label %return

return:                                           ; preds = %if.then12, %if.else, %if.then8, %entry
  %retval.0 = phi i32 [ 0, %if.else ], [ 0, %if.then12 ], [ 0, %if.then8 ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @pci_dev_put(%struct.pci_dev*) #2

declare i32 @acpi_bus_get_status(%struct.acpi_device*) #2

declare i32 @acpi_walk_resources(i8*, i8*, i32 (%struct.acpi_resource*, i8*)*, i8*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_read_possible_resource(%struct.acpi_resource* %resource, i8* %context) #1 {
entry:
  %0 = bitcast i8* %context to %struct.sony_pic_dev*
  %type = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %resource, i32 0, i32 0
  %1 = load i32, i32* %type, align 1, !tbaa !121
  %Pivot10 = icmp slt i32 %1, 3
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %1, 4
  br i1 %Pivot8, label %cleanup123, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %1, 7
  br i1 %Pivot6, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp ne i32 %1, 7
  %2 = load i32, i32* @debug, align 4
  %tobool115 = icmp ne i32 %2, 0
  %or.cond = and i1 %SwitchLeaf4, %tobool115
  br i1 %or.cond, label %if.then116, label %cleanup123

LeafBlock1:                                       ; preds = %NodeBlock5
  %SwitchLeaf2 = icmp eq i32 %1, 4
  br i1 %SwitchLeaf2, label %sw.bb43, label %do.body114

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %1, 2
  br i1 %Pivot, label %LeafBlock, label %sw.bb

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %1, 0
  br i1 %SwitchLeaf, label %sw.bb2, label %do.body114

sw.bb:                                            ; preds = %NodeBlock
  %call = call i8* @kzalloc(i64 32, i32 208)
  %3 = bitcast i8* %call to %struct.sony_pic_ioport*
  %tobool = icmp ne %struct.sony_pic_ioport* %3, null
  br i1 %tobool, label %if.end, label %cleanup123

if.end:                                           ; preds = %sw.bb
  %list = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %3, i32 0, i32 2
  %ioports = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 4
  call void @list_add(%struct.list_head* %list, %struct.list_head* %ioports)
  br label %cleanup123

sw.bb2:                                           ; preds = %LeafBlock
  %data = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %resource, i32 0, i32 2
  %irq = bitcast %union.acpi_resource_data* %data to %struct.acpi_resource_irq*
  %tobool3 = icmp ne %struct.acpi_resource_irq* %irq, null
  br i1 %tobool3, label %lor.lhs.false, label %do.body

lor.lhs.false:                                    ; preds = %sw.bb2
  %interrupt_count = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 5
  %4 = load i8, i8* %interrupt_count, align 1, !tbaa !122
  %tobool4 = icmp ne i8 %4, 0
  br i1 %tobool4, label %if.end10, label %do.body

do.body:                                          ; preds = %lor.lhs.false, %sw.bb2
  %5 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool6 = icmp ne i32 %5, 0
  br i1 %tobool6, label %if.then7, label %cleanup123

if.then7:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup123

if.end10:                                         ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %i.0 = phi i32 [ 0, %if.end10 ], [ %inc, %for.inc ]
  %interrupt_count11 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 5
  %6 = load i8, i8* %interrupt_count11, align 1, !tbaa !122
  %conv = zext i8 %6 to i32
  %cmp = icmp ult i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup123

for.body:                                         ; preds = %for.cond
  %interrupts = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 6
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts, i64 0, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !41
  %tobool13 = icmp ne i8 %7, 0
  br i1 %tobool13, label %if.end20, label %if.then14

if.then14:                                        ; preds = %for.body
  call void (i8*, ...) @printk(i8* null)
  br label %for.inc

if.end20:                                         ; preds = %for.body
  %call21 = call i8* @kzalloc(i64 24, i32 208)
  %8 = bitcast i8* %call21 to %struct.sony_pic_irq*
  %tobool22 = icmp ne %struct.sony_pic_irq* %8, null
  br i1 %tobool22, label %if.end24, label %cleanup123

if.end24:                                         ; preds = %if.end20
  %list25 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 1
  %interrupts26 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 3
  call void @list_add(%struct.list_head* %list25, %struct.list_head* %interrupts26)
  %triggering = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 1
  %9 = load i8, i8* %triggering, align 1, !tbaa !123
  %irq27 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 0
  %triggering28 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq27, i32 0, i32 1
  store i8 %9, i8* %triggering28, align 1, !tbaa !124
  %polarity = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 2
  %10 = load i8, i8* %polarity, align 1, !tbaa !125
  %irq29 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 0
  %polarity30 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq29, i32 0, i32 2
  store i8 %10, i8* %polarity30, align 2, !tbaa !126
  %sharable = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 3
  %11 = load i8, i8* %sharable, align 1, !tbaa !127
  %irq31 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 0
  %sharable32 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq31, i32 0, i32 3
  store i8 %11, i8* %sharable32, align 1, !tbaa !128
  %irq33 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 0
  %interrupt_count34 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq33, i32 0, i32 5
  store i8 1, i8* %interrupt_count34, align 1, !tbaa !129
  %interrupts35 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq, i32 0, i32 6
  %idxprom36 = zext i32 %i.0 to i64
  %arrayidx37 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts35, i64 0, i64 %idxprom36
  %12 = load i8, i8* %arrayidx37, align 1, !tbaa !41
  %irq38 = getelementptr inbounds %struct.sony_pic_irq, %struct.sony_pic_irq* %8, i32 0, i32 0
  %interrupts39 = getelementptr inbounds %struct.acpi_resource_irq, %struct.acpi_resource_irq* %irq38, i32 0, i32 6
  %arrayidx40 = getelementptr inbounds [1 x i8], [1 x i8]* %interrupts39, i64 0, i64 0
  store i8 %12, i8* %arrayidx40, align 2, !tbaa !41
  br label %for.inc

for.inc:                                          ; preds = %if.end24, %if.then14
  %inc = add i32 %i.0, 1
  br label %for.cond

sw.bb43:                                          ; preds = %LeafBlock1
  %data44 = getelementptr inbounds %struct.acpi_resource, %struct.acpi_resource* %resource, i32 0, i32 2
  %io45 = bitcast %union.acpi_resource_data* %data44 to %struct.acpi_resource_io*
  %ioports47 = getelementptr inbounds %struct.sony_pic_dev, %struct.sony_pic_dev* %0, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %ioports47, i32 0, i32 0
  %13 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !44
  %14 = bitcast %struct.list_head* %13 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %14, i64 -16
  %15 = bitcast i8* %add.ptr to %struct.sony_pic_ioport*
  %tobool48 = icmp ne %struct.acpi_resource_io* %io45, null
  br i1 %tobool48, label %if.end57, label %do.body50

do.body50:                                        ; preds = %sw.bb43
  %16 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool51 = icmp ne i32 %16, 0
  br i1 %tobool51, label %if.then52, label %cleanup123

if.then52:                                        ; preds = %do.body50
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup123

if.end57:                                         ; preds = %sw.bb43
  %io1 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 0
  %minimum = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io1, i32 0, i32 3
  %17 = load i16, i16* %minimum, align 1, !tbaa !24
  %tobool58 = icmp ne i16 %17, 0
  br i1 %tobool58, label %if.else80, label %if.then59

if.then59:                                        ; preds = %if.end57
  %cmp60 = icmp uge i64 7, 64
  %io163 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 0
  %18 = bitcast %struct.acpi_resource_io* %io163 to i8*
  %19 = bitcast %struct.acpi_resource_io* %io45 to i8*
  br i1 %cmp60, label %if.then62, label %if.else

if.then62:                                        ; preds = %if.then59
  %call64 = call i8* @__memcpy(i8* %18, i8* %19, i64 7)
  br label %do.body68

if.else:                                          ; preds = %if.then59
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 7, i32 1, i1 false)
  br label %do.body68

do.body68:                                        ; preds = %if.else, %if.then62
  %20 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool69 = icmp ne i32 %20, 0
  br i1 %tobool69, label %if.then70, label %cleanup123

if.then70:                                        ; preds = %do.body68
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup123

if.else80:                                        ; preds = %if.end57
  %io2 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 1
  %minimum81 = getelementptr inbounds %struct.acpi_resource_io, %struct.acpi_resource_io* %io2, i32 0, i32 3
  %21 = load i16, i16* %minimum81, align 1, !tbaa !39
  %tobool82 = icmp ne i16 %21, 0
  br i1 %tobool82, label %if.else108, label %if.then83

if.then83:                                        ; preds = %if.else80
  %cmp86 = icmp uge i64 7, 64
  %io289 = getelementptr inbounds %struct.sony_pic_ioport, %struct.sony_pic_ioport* %15, i32 0, i32 1
  %22 = bitcast %struct.acpi_resource_io* %io289 to i8*
  %23 = bitcast %struct.acpi_resource_io* %io45 to i8*
  br i1 %cmp86, label %if.then88, label %if.else91

if.then88:                                        ; preds = %if.then83
  %call90 = call i8* @__memcpy(i8* %22, i8* %23, i64 7)
  br label %do.body95

if.else91:                                        ; preds = %if.then83
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %22, i8* %23, i64 7, i32 1, i1 false)
  br label %do.body95

do.body95:                                        ; preds = %if.else91, %if.then88
  %24 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool96 = icmp ne i32 %24, 0
  br i1 %tobool96, label %if.then97, label %cleanup123

if.then97:                                        ; preds = %do.body95
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup123

if.else108:                                       ; preds = %if.else80
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup123

do.body114:                                       ; preds = %LeafBlock, %LeafBlock1
  %.old = load i32, i32* @debug, align 4, !tbaa !12
  %tobool115.old = icmp ne i32 %.old, 0
  br i1 %tobool115.old, label %if.then116, label %cleanup123

if.then116:                                       ; preds = %do.body114, %LeafBlock3
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup123

cleanup123:                                       ; preds = %if.then116, %do.body114, %if.else108, %if.then97, %do.body95, %if.then70, %do.body68, %if.then52, %do.body50, %if.end20, %for.cond, %if.then7, %do.body, %if.end, %sw.bb, %LeafBlock3, %NodeBlock7
  %retval.3 = phi i32 [ 0, %if.end ], [ 1, %sw.bb ], [ 0, %NodeBlock7 ], [ 0, %if.then7 ], [ 0, %do.body ], [ 1, %if.end20 ], [ 0, %for.cond ], [ 1, %if.else108 ], [ 0, %if.then52 ], [ 0, %do.body50 ], [ 0, %if.then97 ], [ 0, %do.body95 ], [ 0, %do.body68 ], [ 0, %if.then70 ], [ 0, %do.body114 ], [ 0, %if.then116 ], [ 0, %LeafBlock3 ]
  ret i32 %retval.3
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #0 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !44
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

declare i8* @__memcpy(i8*, i8*, i64) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #3

declare void @__list_add(%struct.list_head*, %struct.list_head*, %struct.list_head*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return(i32 %i, %struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !130
  %add = add nsw i32 %i, %0
  ret i32 %add
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kfifo_int_must_check_helper(i32 %val) #0 {
entry:
  ret i32 %val
}

declare i32 @__kfifo_alloc(%struct.__kfifo*, i32, i64, i32) #2

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal void @do_sony_laptop_release_key(i64 %unused) #1 {
entry:
  %kp = alloca %struct.sony_laptop_keypress, align 8
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4))
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %0 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %1 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %1 to %struct.__kfifo*
  %conv6 = trunc i64 16 to i32
  %call7 = call i32 @__kfifo_out(%struct.__kfifo* %kfifo, i8* %0, i32 %conv6)
  %call8 = call i32 @__kfifo_uint_must_check_helper(i32 %call7)
  %conv9 = zext i32 %call8 to i64
  %cmp10 = icmp eq i64 %conv9, 16
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %2 = load %struct.input_dev*, %struct.input_dev** %dev, align 8, !tbaa !118
  %key = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %3 = load i32, i32* %key, align 8, !tbaa !120
  call void @input_report_key(%struct.input_dev* %2, i32 %3, i32 0)
  %dev12 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %4 = load %struct.input_dev*, %struct.input_dev** %dev12, align 8, !tbaa !118
  call void @input_sync(%struct.input_dev* %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo14 = bitcast %union.anon.58* %5 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo14, i32 0, i32 0
  %6 = load i32, i32* %in, align 8, !tbaa !41
  %7 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo15 = bitcast %union.anon.58* %7 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo15, i32 0, i32 1
  %8 = load i32, i32* %out, align 4, !tbaa !41
  %sub = sub i32 %6, %8
  %cmp16 = icmp ne i32 %sub, 0
  br i1 %cmp16, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.end
  %9 = load volatile i64, i64* @jiffies, align 8, !tbaa !101
  %call19 = call i64 @msecs_to_jiffies(i32 10)
  %add = add i64 %9, %call19
  %call20 = call i32 @mod_timer(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5), i64 %add)
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %if.end
  call void @spin_unlock_irqrestore(%struct.spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4), i64 %call2)
  ret void
}

declare %struct.input_dev* @input_allocate_device() #2

declare void @input_set_capability(%struct.input_dev*, i32, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @__set_bit(i32 %nr, i64* %addr) #0 {
entry:
  call void asm sideeffect "bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !131
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__clear_bit(i32 %nr, i64* %addr) #0 {
entry:
  call void asm sideeffect "btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !132
  ret void
}

declare i32 @input_register_device(%struct.input_dev*) #2

declare void @input_free_device(%struct.input_dev*) #2

declare void @input_unregister_device(%struct.input_dev*) #2

declare void @__kfifo_free(%struct.__kfifo*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_dec(%struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !133
  ret void
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #2 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__kfifo_uint_must_check_helper(i32 %val) #0 {
entry:
  ret i32 %val
}

declare i32 @__kfifo_out(%struct.__kfifo*, i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_key(%struct.input_dev* %dev, i32 %code, i32 %value) #0 {
entry:
  %tobool = icmp ne i32 %value, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  call void @input_event(%struct.input_dev* %dev, i32 1, i32 %code, i32 %lnot.ext)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_sync(%struct.input_dev* %dev) #0 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 0, i32 0, i32 0)
  ret void
}

declare i32 @mod_timer(%struct.timer_list*, i64) #2

declare i64 @msecs_to_jiffies(i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @input_event(%struct.input_dev*, i32, i32, i32) #2

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #2 section ".spinlock.text"

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #2

declare i32 @misc_register(%struct.miscdevice*) #2

declare i64 @noop_llseek(%struct.file*, i64, i32) #2

; Function Attrs: nounwind uwtable
define internal i64 @sonypi_misc_read(%struct.file* %file, i8* %buf, i64 %count, i64* %pos) #1 {
entry:
  %c = alloca i8, align 1
  %__wait = alloca %struct.__wait_queue, align 8
  %coerce = alloca %struct.timespec, align 8
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo, i32 0, i32 0
  %1 = load i32, i32* %in, align 8, !tbaa !41
  %2 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo1 = bitcast %union.anon.58* %2 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo1, i32 0, i32 1
  %3 = load i32, i32* %out, align 4, !tbaa !41
  %sub = sub i32 %1, %3
  %cmp = icmp eq i32 %sub, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %4 = load i32, i32* %f_flags, align 8, !tbaa !134
  %and = and i32 %4, 2048
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %5 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo4 = bitcast %union.anon.58* %5 to %struct.__kfifo*
  %in5 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo4, i32 0, i32 0
  %6 = load i32, i32* %in5, align 8, !tbaa !41
  %7 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo6 = bitcast %union.anon.58* %7 to %struct.__kfifo*
  %out7 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo6, i32 0, i32 1
  %8 = load i32, i32* %out7, align 4, !tbaa !41
  %sub8 = sub i32 %6, %8
  %cmp9 = icmp ne i32 %sub8, 0
  br i1 %cmp9, label %if.end28, label %do.body

do.body:                                          ; preds = %if.end
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !140
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %9 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !142
  %10 = bitcast %struct.task_struct* %9 to i8*
  store i8* %10, i8** %private, align 8, !tbaa !143
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !144
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list11 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list11, %struct.list_head** %next, align 8, !tbaa !44
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list12 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list12, %struct.list_head** %prev, align 8, !tbaa !145
  br label %for.cond

for.cond:                                         ; preds = %if.then26, %do.body
  call void @prepare_to_wait(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), %struct.__wait_queue* %__wait, i32 1)
  %11 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo15 = bitcast %union.anon.58* %11 to %struct.__kfifo*
  %in16 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo15, i32 0, i32 0
  %12 = load i32, i32* %in16, align 8, !tbaa !41
  %13 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo17 = bitcast %union.anon.58* %13 to %struct.__kfifo*
  %out18 = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo17, i32 0, i32 1
  %14 = load i32, i32* %out18, align 4, !tbaa !41
  %sub19 = sub i32 %12, %14
  %cmp20 = icmp ne i32 %sub19, 0
  br i1 %cmp20, label %for.end, label %if.end22

if.end22:                                         ; preds = %for.cond
  %15 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !142
  %call24 = call i32 @signal_pending(%struct.task_struct* %15)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %for.end, label %if.then26

if.then26:                                        ; preds = %if.end22
  call void @schedule()
  br label %for.cond

for.end:                                          ; preds = %if.end22, %for.cond
  %__ret.0 = phi i32 [ 0, %for.cond ], [ -512, %if.end22 ]
  call void @finish_wait(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), %struct.__wait_queue* %__wait)
  br label %if.end28

if.end28:                                         ; preds = %for.end, %if.end
  %__ret.1 = phi i32 [ 0, %if.end ], [ %__ret.0, %for.end ]
  %conv = sext i32 %__ret.1 to i64
  %tobool30 = icmp ne i64 %conv, 0
  br i1 %tobool30, label %cleanup, label %if.end32

if.end32:                                         ; preds = %if.end28
  br label %while.cond

while.cond:                                       ; preds = %if.end60, %if.end32
  %ret.0 = phi i64 [ %conv, %if.end32 ], [ %inc, %if.end60 ]
  %buf.addr.0 = phi i8* [ %buf, %if.end32 ], [ %incdec.ptr, %if.end60 ]
  %cmp33 = icmp ult i64 %ret.0, %count
  br i1 %cmp33, label %do.body37, label %while.end

do.body37:                                        ; preds = %while.cond
  %call41 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2))
  %call42 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call41)
  %16 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo47 = bitcast %union.anon.58* %16 to %struct.__kfifo*
  %conv49 = trunc i64 1 to i32
  %call50 = call i32 @__kfifo_out(%struct.__kfifo* %kfifo47, i8* %c, i32 %conv49)
  %call51 = call i32 @__kfifo_uint_must_check_helper(i32 %call50)
  call void @spin_unlock_irqrestore(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2), i64 %call42)
  %call53 = call i32 @__kfifo_uint_must_check_helper(i32 %call51)
  %conv54 = zext i32 %call53 to i64
  %cmp55 = icmp eq i64 %conv54, 1
  br i1 %cmp55, label %while.body, label %while.end

while.body:                                       ; preds = %do.body37
  call void @might_fault()
  %17 = load i8, i8* %c, align 1, !tbaa !41
  %18 = zext i8 %17 to i32
  %incdec.ptr = getelementptr inbounds i8, i8* %buf.addr.0, i32 1
  %19 = call i32 asm sideeffect "call __put_user_1", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %18, i8* %buf.addr.0) #7, !srcloc !146
  %tobool58 = icmp ne i32 %19, 0
  br i1 %tobool58, label %cleanup, label %if.end60

if.end60:                                         ; preds = %while.body
  %inc = add nsw i64 %ret.0, 1
  br label %while.cond

while.end:                                        ; preds = %do.body37, %while.cond
  %cmp61 = icmp sgt i64 %ret.0, 0
  br i1 %cmp61, label %if.then63, label %cleanup

if.then63:                                        ; preds = %while.end
  %call64 = call %struct.inode* @file_inode(%struct.file* %file)
  %i_atime = getelementptr inbounds %struct.inode, %struct.inode* %call64, i32 0, i32 15
  %i_sb = getelementptr inbounds %struct.inode, %struct.inode* %call64, i32 0, i32 8
  %20 = load %struct.super_block*, %struct.super_block** %i_sb, align 8, !tbaa !147
  %call65 = call { i64, i64 } @current_fs_time(%struct.super_block* %20)
  %21 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = extractvalue { i64, i64 } %call65, 0
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = extractvalue { i64, i64 } %call65, 1
  store i64 %25, i64* %24, align 8
  %26 = bitcast %struct.timespec* %i_atime to i8*
  %27 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %26, i8* %27, i64 16, i32 8, i1 false), !tbaa.struct !155
  br label %cleanup

cleanup:                                          ; preds = %if.then63, %while.end, %while.body, %if.end28, %land.lhs.true
  %retval.0 = phi i64 [ -11, %land.lhs.true ], [ %conv, %if.end28 ], [ -14, %while.body ], [ %ret.0, %if.then63 ], [ %ret.0, %while.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #1 {
entry:
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), %struct.poll_table_struct* %wait)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo, i32 0, i32 0
  %1 = load i32, i32* %in, align 8, !tbaa !41
  %2 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo1 = bitcast %union.anon.58* %2 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo1, i32 0, i32 1
  %3 = load i32, i32* %out, align 4, !tbaa !41
  %sub = sub i32 %1, %3
  %tobool = icmp ne i32 %sub, 0
  %. = select i1 %tobool, i32 65, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i64 @sonypi_misc_ioctl(%struct.file* %fp, i32 %cmd, i64 %arg) #1 {
entry:
  %val8 = alloca i8, align 1
  %val16 = alloca i16, align 2
  %value = alloca i32, align 4
  %0 = inttoptr i64 %arg to i8*
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %Pivot34 = icmp slt i32 %cmd, -2147322365
  br i1 %Pivot34, label %NodeBlock13, label %NodeBlock31

NodeBlock31:                                      ; preds = %entry
  %Pivot32 = icmp slt i32 %cmd, 1073837568
  br i1 %Pivot32, label %NodeBlock19, label %NodeBlock29

NodeBlock29:                                      ; preds = %NodeBlock31
  %Pivot30 = icmp slt i32 %cmd, 1073837577
  br i1 %Pivot30, label %LeafBlock21, label %NodeBlock27

NodeBlock27:                                      ; preds = %NodeBlock29
  %Pivot28 = icmp slt i32 %cmd, 1073837579
  br i1 %Pivot28, label %LeafBlock23, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %cmd, 1073837579
  br i1 %SwitchLeaf26, label %sw.bb89, label %sw.epilog

LeafBlock23:                                      ; preds = %NodeBlock27
  %SwitchLeaf24 = icmp eq i32 %cmd, 1073837577
  br i1 %SwitchLeaf24, label %sw.bb75, label %sw.epilog

LeafBlock21:                                      ; preds = %NodeBlock29
  %SwitchLeaf22 = icmp eq i32 %cmd, 1073837568
  br i1 %SwitchLeaf22, label %sw.bb7, label %sw.epilog

NodeBlock19:                                      ; preds = %NodeBlock31
  %Pivot20 = icmp slt i32 %cmd, -2147322364
  br i1 %Pivot20, label %sw.bb31, label %NodeBlock17

NodeBlock17:                                      ; preds = %NodeBlock19
  %Pivot18 = icmp slt i32 %cmd, -2147322363
  br i1 %Pivot18, label %sw.bb40, label %LeafBlock15

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %cmd, -2147322363
  br i1 %SwitchLeaf16, label %sw.bb49, label %sw.epilog

NodeBlock13:                                      ; preds = %entry
  %Pivot14 = icmp slt i32 %cmd, -2147387894
  br i1 %Pivot14, label %NodeBlock3, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %cmd, -2147387892
  br i1 %Pivot12, label %LeafBlock5, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %cmd, -2147322366
  br i1 %Pivot10, label %LeafBlock7, label %sw.bb22

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %cmd, -2147387892
  br i1 %SwitchLeaf8, label %sw.bb99, label %sw.epilog

LeafBlock5:                                       ; preds = %NodeBlock11
  %SwitchLeaf6 = icmp eq i32 %cmd, -2147387894
  br i1 %SwitchLeaf6, label %sw.bb80, label %sw.epilog

NodeBlock3:                                       ; preds = %NodeBlock13
  %Pivot4 = icmp slt i32 %cmd, -2147387897
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cmd, -2147387896
  br i1 %Pivot, label %sw.bb58, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, -2147387896
  br i1 %SwitchLeaf2, label %sw.bb70, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cmd, -2147387904
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %1 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  %cmp = icmp eq %struct.backlight_device* %1, null
  br i1 %cmp, label %sw.epilog, label %if.end

if.end:                                           ; preds = %sw.bb
  %2 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call = call i32 @sony_nc_int_call(i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.57, i32 0, i32 0), i32* null, i32* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %sw.epilog, label %if.end2

if.end2:                                          ; preds = %if.end
  %3 = load i32, i32* %value, align 4, !tbaa !12
  %and = and i32 %3, 255
  %sub = sub nsw i32 %and, 1
  %shl = shl i32 %sub, 5
  %conv = trunc i32 %shl to i8
  store i8 %conv, i8* %val8, align 1, !tbaa !41
  call void @might_fault() #7
  %call.i15 = call i64 @_copy_to_user(i8* %0, i8* %val8, i32 1) #7
  %conv.i16 = trunc i64 %call.i15 to i32
  %tobool4 = icmp ne i32 %conv.i16, 0
  %. = select i1 %tobool4, i32 -14, i32 0
  br label %sw.epilog

sw.bb7:                                           ; preds = %LeafBlock21
  %4 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  %cmp8 = icmp eq %struct.backlight_device* %4, null
  br i1 %cmp8, label %sw.epilog, label %if.end11

if.end11:                                         ; preds = %sw.bb7
  %call12 = call i64 @copy_from_user(i8* %val8, i8* %0, i64 1)
  %tobool13 = icmp ne i64 %call12, 0
  br i1 %tobool13, label %sw.epilog, label %if.end15

if.end15:                                         ; preds = %if.end11
  %5 = load i8, i8* %val8, align 1, !tbaa !41
  %conv16 = zext i8 %5 to i32
  %shr = ashr i32 %conv16, 5
  %add = add nsw i32 %shr, 1
  store i32 %add, i32* %value, align 4, !tbaa !12
  %6 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call17 = call i32 @sony_nc_int_call(i8* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.58, i32 0, i32 0), i32* %value, i32* null)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %sw.epilog, label %if.end20

if.end20:                                         ; preds = %if.end15
  %7 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  %call21 = call i32 @sony_backlight_get_brightness(%struct.backlight_device* %7)
  %8 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  %props = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %8, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 0
  store i32 %call21, i32* %brightness, align 8, !tbaa !158
  br label %sw.epilog

sw.bb22:                                          ; preds = %NodeBlock9
  %call23 = call i32 @ec_read16(i8 zeroext -78, i16* %val16)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %sw.epilog, label %if.end26

if.end26:                                         ; preds = %sw.bb22
  %9 = bitcast i16* %val16 to i8*
  call void @might_fault() #7
  %call.i13 = call i64 @_copy_to_user(i8* %0, i8* %9, i32 2) #7
  %conv.i14 = trunc i64 %call.i13 to i32
  %tobool28 = icmp ne i32 %conv.i14, 0
  %.35 = select i1 %tobool28, i32 -14, i32 0
  br label %sw.epilog

sw.bb31:                                          ; preds = %NodeBlock19
  %call32 = call i32 @ec_read16(i8 zeroext -94, i16* %val16)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %sw.epilog, label %if.end35

if.end35:                                         ; preds = %sw.bb31
  %10 = bitcast i16* %val16 to i8*
  call void @might_fault() #7
  %call.i11 = call i64 @_copy_to_user(i8* %0, i8* %10, i32 2) #7
  %conv.i12 = trunc i64 %call.i11 to i32
  %tobool37 = icmp ne i32 %conv.i12, 0
  %.36 = select i1 %tobool37, i32 -14, i32 0
  br label %sw.epilog

sw.bb40:                                          ; preds = %NodeBlock17
  %call41 = call i32 @ec_read16(i8 zeroext -70, i16* %val16)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %sw.epilog, label %if.end44

if.end44:                                         ; preds = %sw.bb40
  %11 = bitcast i16* %val16 to i8*
  call void @might_fault() #7
  %call.i9 = call i64 @_copy_to_user(i8* %0, i8* %11, i32 2) #7
  %conv.i10 = trunc i64 %call.i9 to i32
  %tobool46 = icmp ne i32 %conv.i10, 0
  %.37 = select i1 %tobool46, i32 -14, i32 0
  br label %sw.epilog

sw.bb49:                                          ; preds = %LeafBlock15
  %call50 = call i32 @ec_read16(i8 zeroext -86, i16* %val16)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %sw.epilog, label %if.end53

if.end53:                                         ; preds = %sw.bb49
  %12 = bitcast i16* %val16 to i8*
  call void @might_fault() #7
  %call.i7 = call i64 @_copy_to_user(i8* %0, i8* %12, i32 2) #7
  %conv.i8 = trunc i64 %call.i7 to i32
  %tobool55 = icmp ne i32 %conv.i8, 0
  %.38 = select i1 %tobool55, i32 -14, i32 0
  br label %sw.epilog

sw.bb58:                                          ; preds = %NodeBlock
  %call59 = call i32 @ec_read(i8 zeroext -127, i8* %val8)
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %sw.epilog, label %if.end62

if.end62:                                         ; preds = %sw.bb58
  %13 = load i8, i8* %val8, align 1, !tbaa !41
  %conv63 = zext i8 %13 to i32
  %and64 = and i32 %conv63, 7
  %conv65 = trunc i32 %and64 to i8
  store i8 %conv65, i8* %val8, align 1, !tbaa !41
  call void @might_fault() #7
  %call.i5 = call i64 @_copy_to_user(i8* %0, i8* %val8, i32 1) #7
  %conv.i6 = trunc i64 %call.i5 to i32
  %tobool67 = icmp ne i32 %conv.i6, 0
  %.39 = select i1 %tobool67, i32 -14, i32 0
  br label %sw.epilog

sw.bb70:                                          ; preds = %LeafBlock1
  %14 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !43
  store i8 %14, i8* %val8, align 1, !tbaa !41
  call void @might_fault() #7
  %call.i3 = call i64 @_copy_to_user(i8* %0, i8* %val8, i32 1) #7
  %conv.i4 = trunc i64 %call.i3 to i32
  %tobool72 = icmp ne i32 %conv.i4, 0
  %.40 = select i1 %tobool72, i32 -14, i32 0
  br label %sw.epilog

sw.bb75:                                          ; preds = %LeafBlock23
  %call76 = call i64 @copy_from_user(i8* %val8, i8* %0, i64 1)
  %tobool77 = icmp ne i64 %call76, 0
  br i1 %tobool77, label %sw.epilog, label %if.end79

if.end79:                                         ; preds = %sw.bb75
  %15 = load i8, i8* %val8, align 1, !tbaa !41
  call void @__sony_pic_set_bluetoothpower(i8 zeroext %15)
  br label %sw.epilog

sw.bb80:                                          ; preds = %LeafBlock5
  %call81 = call i32 @sony_pic_get_fanspeed(i8* %val8)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %sw.epilog, label %if.end84

if.end84:                                         ; preds = %sw.bb80
  call void @might_fault() #7
  %call.i1 = call i64 @_copy_to_user(i8* %0, i8* %val8, i32 1) #7
  %conv.i2 = trunc i64 %call.i1 to i32
  %tobool86 = icmp ne i32 %conv.i2, 0
  %.41 = select i1 %tobool86, i32 -14, i32 0
  br label %sw.epilog

sw.bb89:                                          ; preds = %LeafBlock25
  %call90 = call i64 @copy_from_user(i8* %val8, i8* %0, i64 1)
  %tobool91 = icmp ne i64 %call90, 0
  br i1 %tobool91, label %sw.epilog, label %if.end93

if.end93:                                         ; preds = %sw.bb89
  %16 = load i8, i8* %val8, align 1, !tbaa !41
  %conv94 = zext i8 %16 to i64
  %call95 = call i32 @sony_pic_set_fanspeed(i64 %conv94)
  %tobool96 = icmp ne i32 %call95, 0
  %.42 = select i1 %tobool96, i32 -5, i32 0
  br label %sw.epilog

sw.bb99:                                          ; preds = %LeafBlock7
  %call100 = call i32 @ec_read(i8 zeroext -63, i8* %val8)
  %tobool101 = icmp ne i32 %call100, 0
  br i1 %tobool101, label %sw.epilog, label %if.end103

if.end103:                                        ; preds = %sw.bb99
  call void @might_fault() #7
  %call.i = call i64 @_copy_to_user(i8* %0, i8* %val8, i32 1) #7
  %conv.i = trunc i64 %call.i to i32
  %tobool105 = icmp ne i32 %conv.i, 0
  %.43 = select i1 %tobool105, i32 -14, i32 0
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end103, %sw.bb99, %if.end93, %sw.bb89, %if.end84, %sw.bb80, %if.end79, %sw.bb75, %sw.bb70, %if.end62, %sw.bb58, %if.end53, %sw.bb49, %if.end44, %sw.bb40, %if.end35, %sw.bb31, %if.end26, %sw.bb22, %if.end20, %if.end15, %if.end11, %sw.bb7, %if.end2, %if.end, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock5, %LeafBlock7, %LeafBlock15, %LeafBlock21, %LeafBlock23, %LeafBlock25
  %ret.10 = phi i32 [ %., %if.end2 ], [ %.39, %if.end62 ], [ %.40, %sw.bb70 ], [ %.41, %if.end84 ], [ %.43, %if.end103 ], [ %.35, %if.end26 ], [ %.36, %if.end35 ], [ %.37, %if.end44 ], [ %.38, %if.end53 ], [ 0, %if.end20 ], [ 0, %if.end79 ], [ %.42, %if.end93 ], [ -5, %sw.bb ], [ -5, %if.end ], [ -5, %sw.bb7 ], [ -14, %if.end11 ], [ -5, %if.end15 ], [ -5, %sw.bb22 ], [ -5, %sw.bb31 ], [ -5, %sw.bb40 ], [ -5, %sw.bb49 ], [ -5, %sw.bb58 ], [ -14, %sw.bb75 ], [ -5, %sw.bb80 ], [ -14, %sw.bb89 ], [ -5, %sw.bb99 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock5 ], [ -22, %LeafBlock7 ], [ -22, %LeafBlock15 ], [ -22, %LeafBlock21 ], [ -22, %LeafBlock23 ], [ -22, %LeafBlock25 ]
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  %conv108 = sext i32 %ret.10 to i64
  ret i64 %conv108
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_open(%struct.inode* %inode, %struct.file* %file) #1 {
entry:
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2))
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %call5 = call i32 @atomic_add_return(i32 1, %struct.atomic_t* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 4))
  %cmp6 = icmp eq i32 %call5, 1
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  %out = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo, i32 0, i32 1
  store i32 0, i32* %out, align 4, !tbaa !41
  %1 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo9 = bitcast %union.anon.58* %1 to %struct.__kfifo*
  %in = getelementptr inbounds %struct.__kfifo, %struct.__kfifo* %kfifo9, i32 0, i32 0
  store i32 0, i32* %in, align 8, !tbaa !41
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @spin_unlock_irqrestore(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2), i64 %call2)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_release(%struct.inode* %inode, %struct.file* %file) #1 {
entry:
  call void @atomic_dec(%struct.atomic_t* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 4))
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @sonypi_misc_fasync(i32 %fd, %struct.file* %filp, i32 %on) #1 {
entry:
  %call = call i32 @fasync_helper(i32 %fd, %struct.file* %filp, i32 %on, %struct.fasync_struct** getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 0))
  ret i32 %call
}

declare i32 @autoremove_wake_function(%struct.__wait_queue*, i32, i32, i8*) #2

declare void @prepare_to_wait(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #0 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

declare void @schedule() #2

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #2

declare void @might_fault() #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #0 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !162
  ret %struct.inode* %0
}

declare { i64, i64 } @current_fs_time(%struct.super_block*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #0 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #0 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #0 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #7, !srcloc !191
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #0 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !192
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !192
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_int_call(i8* %handle, i8* %name, i32* %value, i32* %result) #1 {
entry:
  %v = alloca i64, align 8
  %tobool = icmp ne i32* %value, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = load i32, i32* %value, align 4, !tbaa !12
  %conv = sext i32 %0 to i64
  store i64 %conv, i64* %v, align 8, !tbaa !194
  %call = call %union.acpi_object* @__call_snc_method(i8* %handle, i8* %name, i64* %v)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call %union.acpi_object* @__call_snc_method(i8* %handle, i8* %name, i64* null)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %object.0 = phi %union.acpi_object* [ %call, %if.then ], [ %call1, %if.else ]
  %tobool2 = icmp ne %union.acpi_object* %object.0, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %type = bitcast %union.acpi_object* %object.0 to i32*
  %1 = load i32, i32* %type, align 8, !tbaa !41
  %cmp = icmp ne i32 %1, 1
  br i1 %cmp, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end4
  call void (i8*, ...) @printk(i8* null)
  %2 = bitcast %union.acpi_object* %object.0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %tobool10 = icmp ne i32* %result, null
  br i1 %tobool10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.end9
  %integer = bitcast %union.acpi_object* %object.0 to %struct.anon.47*
  %value12 = getelementptr inbounds %struct.anon.47, %struct.anon.47* %integer, i32 0, i32 1
  %3 = load i64, i64* %value12, align 8, !tbaa !41
  %conv13 = trunc i64 %3 to i32
  store i32 %conv13, i32* %result, align 4, !tbaa !12
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.end9
  %4 = bitcast %union.acpi_object* %object.0 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.then6, %if.end
  %retval.0 = phi i32 [ -22, %if.then6 ], [ 0, %if.end14 ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #0 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.64, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.65, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_backlight_get_brightness(%struct.backlight_device* %bd) #1 {
entry:
  %value = alloca i32, align 4
  %0 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call = call i32 @sony_nc_int_call(i8* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.57, i32 0, i32 0), i32* null, i32* %value)
  %tobool = icmp ne i32 %call, 0
  %1 = load i32, i32* %value, align 4
  %sub = sub nsw i32 %1, 1
  %retval.0 = select i1 %tobool, i32 0, i32 %sub
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ec_read16(i8 zeroext %addr, i16* %value) #1 {
entry:
  %val_lb = alloca i8, align 1
  %val_hb = alloca i8, align 1
  %call = call i32 @ec_read(i8 zeroext %addr, i8* %val_lb)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i8 %addr to i32
  %add = add nsw i32 %conv, 1
  %conv1 = trunc i32 %add to i8
  %call2 = call i32 @ec_read(i8 zeroext %conv1, i8* %val_hb)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %0 = load i8, i8* %val_lb, align 1, !tbaa !41
  %conv6 = zext i8 %0 to i32
  %1 = load i8, i8* %val_hb, align 1, !tbaa !41
  %conv7 = zext i8 %1 to i32
  %shl = shl i32 %conv7, 8
  %or = or i32 %conv6, %shl
  %conv8 = trunc i32 %or to i16
  store i16 %conv8, i16* %value, align 2, !tbaa !195
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end5 ], [ -1, %entry ], [ -1, %if.end ]
  ret i32 %retval.0
}

declare i32 @ec_read(i8 zeroext, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @__sony_pic_set_bluetoothpower(i8 zeroext %state) #1 {
entry:
  %tobool = icmp ne i8 %state, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = trunc i32 %lnot.ext to i8
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !43
  %conv2 = zext i8 %0 to i32
  %conv3 = zext i8 %conv to i32
  %cmp = icmp eq i32 %conv2, %conv3
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = call zeroext i8 @sony_pic_call2(i8 zeroext -106, i8 zeroext %conv)
  call void @sony_pic_call1(i8 zeroext -126)
  store i8 %conv, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !43
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_get_fanspeed(i8* %value) #1 {
entry:
  %call = call i32 @ec_read(i8 zeroext -109, i8* %value)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_set_fanspeed(i64 %value) #1 {
entry:
  %conv = trunc i64 %value to i8
  %call = call i32 @ec_write(i8 zeroext -109, i8 zeroext %conv)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal %union.acpi_object* @__call_snc_method(i8* %handle, i8* %method, i64* %value) #1 {
entry:
  %output = alloca %struct.acpi_buffer, align 8
  %params = alloca %struct.acpi_object_list, align 8
  %in = alloca %union.acpi_object, align 8
  %0 = bitcast %struct.acpi_buffer* %output to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%struct.acpi_buffer* @__call_snc_method.output to i8*), i64 16, i32 8, i1 false)
  %tobool = icmp ne i64* %value, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %type = bitcast %union.acpi_object* %in to i32*
  store i32 1, i32* %type, align 8, !tbaa !41
  %1 = load i64, i64* %value, align 8, !tbaa !194
  %integer = bitcast %union.acpi_object* %in to %struct.anon.47*
  %value1 = getelementptr inbounds %struct.anon.47, %struct.anon.47* %integer, i32 0, i32 1
  store i64 %1, i64* %value1, align 8, !tbaa !41
  %count = getelementptr inbounds %struct.acpi_object_list, %struct.acpi_object_list* %params, i32 0, i32 0
  store i32 1, i32* %count, align 8, !tbaa !196
  %pointer = getelementptr inbounds %struct.acpi_object_list, %struct.acpi_object_list* %params, i32 0, i32 1
  store %union.acpi_object* %in, %union.acpi_object** %pointer, align 8, !tbaa !198
  %call = call i32 @acpi_evaluate_object(i8* %handle, i8* %method, %struct.acpi_object_list* %params, %struct.acpi_buffer* %output)
  %2 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool2 = icmp ne i32 %2, 0
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %if.then
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then3, %if.then
  br label %if.end14

if.else:                                          ; preds = %entry
  %call6 = call i32 @acpi_evaluate_object(i8* %handle, i8* %method, %struct.acpi_object_list* null, %struct.acpi_buffer* %output)
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool8 = icmp ne i32 %3, 0
  br i1 %tobool8, label %if.then9, label %if.end14

if.then9:                                         ; preds = %if.else
  call void (i8*, ...) @printk(i8* null)
  br label %if.end14

if.end14:                                         ; preds = %if.then9, %if.else, %do.end
  %status.0 = phi i32 [ %call, %do.end ], [ %call6, %if.then9 ], [ %call6, %if.else ]
  %tobool15 = icmp ne i32 %status.0, 0
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end18:                                         ; preds = %if.end14
  %pointer19 = getelementptr inbounds %struct.acpi_buffer, %struct.acpi_buffer* %output, i32 0, i32 1
  %4 = load i8*, i8** %pointer19, align 8, !tbaa !108
  %5 = bitcast i8* %4 to %union.acpi_object*
  %tobool20 = icmp eq %union.acpi_object* %5, null
  %6 = load i32, i32* @debug, align 4
  %tobool23 = icmp ne i32 %6, 0
  %or.cond = and i1 %tobool20, %tobool23
  br i1 %or.cond, label %if.then24, label %cleanup

if.then24:                                        ; preds = %if.end18
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then24, %if.end18, %if.then16
  %retval.0 = phi %union.acpi_object* [ null, %if.then16 ], [ %5, %if.then24 ], [ %5, %if.end18 ]
  ret %union.acpi_object* %retval.0
}

declare i32 @acpi_evaluate_object(i8*, i8*, %struct.acpi_object_list*, %struct.acpi_buffer*) #2

declare i64 @_copy_to_user(i8*, i8*, i32) #2

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #6

declare i64 @_copy_from_user(i8*, i8*, i32) #2

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #2

declare i32 @ec_write(i8 zeroext, i8 zeroext) #2

declare i32 @fasync_helper(i32, %struct.file*, i32, %struct.fasync_struct**) #2

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @sony_laptop_report_input_event(i8 zeroext %event) #1 {
entry:
  %kp = alloca %struct.sony_laptop_keypress, align 8
  %0 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 1), align 8, !tbaa !95
  %1 = load %struct.input_dev*, %struct.input_dev** getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 2), align 8, !tbaa !92
  %2 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 16, i32 8, i1 false)
  %conv = zext i8 %event to i32
  %cmp = icmp eq i32 %conv, 59
  %conv2 = zext i8 %event to i32
  %cmp3 = icmp eq i32 %conv2, 56
  %or.cond = or i1 %cmp, %cmp3
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv5 = zext i8 %event to i32
  %Pivot8 = icmp slt i32 %conv5, 3
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end
  %Pivot6 = icmp slt i32 %conv5, 4
  br i1 %Pivot6, label %sw.bb6, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %conv5, 5
  br i1 %Pivot4, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %conv5, 5
  br i1 %SwitchLeaf2, label %sw.bb7, label %sw.default

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %conv5, 2
  br i1 %Pivot, label %LeafBlock, label %sw.bb

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv5, 1
  br i1 %SwitchLeaf, label %sw.bb6, label %sw.default

sw.bb:                                            ; preds = %NodeBlock, %NodeBlock3
  call void @input_report_rel(%struct.input_dev* %0, i32 8, i32 1)
  call void @input_sync(%struct.input_dev* %0)
  br label %cleanup

sw.bb6:                                           ; preds = %LeafBlock, %NodeBlock5
  call void @input_report_rel(%struct.input_dev* %0, i32 8, i32 -1)
  call void @input_sync(%struct.input_dev* %0)
  br label %cleanup

sw.bb7:                                           ; preds = %LeafBlock1
  %key = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  store i32 274, i32* %key, align 8, !tbaa !120
  %dev = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  store %struct.input_dev* %0, %struct.input_dev** %dev, align 8, !tbaa !118
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %conv8 = zext i8 %event to i64
  %cmp9 = icmp uge i64 %conv8, 74
  br i1 %cmp9, label %do.body, label %if.end15

do.body:                                          ; preds = %sw.default
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then12, label %sw.epilog

if.then12:                                        ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

if.end15:                                         ; preds = %sw.default
  %idxprom = zext i8 %event to i64
  %arrayidx = getelementptr inbounds [74 x i32], [74 x i32]* @sony_laptop_input_index, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %cmp16 = icmp ne i32 %4, -1
  br i1 %cmp16, label %if.then18, label %sw.epilog

if.then18:                                        ; preds = %if.end15
  %idxprom19 = sext i32 %4 to i64
  %arrayidx20 = getelementptr inbounds [60 x i32], [60 x i32]* @sony_laptop_input_keycode_map, i64 0, i64 %idxprom19
  %5 = load i32, i32* %arrayidx20, align 4, !tbaa !12
  %key21 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  store i32 %5, i32* %key21, align 8, !tbaa !120
  %key22 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %6 = load i32, i32* %key22, align 8, !tbaa !120
  %cmp23 = icmp ne i32 %6, 240
  br i1 %cmp23, label %if.then25, label %sw.epilog

if.then25:                                        ; preds = %if.then18
  %dev26 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  store %struct.input_dev* %1, %struct.input_dev** %dev26, align 8, !tbaa !118
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then25, %if.then18, %if.end15, %if.then12, %do.body, %sw.bb7
  %scancode.0 = phi i32 [ -1, %sw.bb7 ], [ -1, %if.then12 ], [ -1, %do.body ], [ %4, %if.then18 ], [ %4, %if.then25 ], [ %4, %if.end15 ]
  %dev29 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %7 = load %struct.input_dev*, %struct.input_dev** %dev29, align 8, !tbaa !118
  %tobool30 = icmp ne %struct.input_dev* %7, null
  br i1 %tobool30, label %if.then31, label %do.body56

if.then31:                                        ; preds = %sw.epilog
  %cmp32 = icmp ne i32 %scancode.0, -1
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.then31
  %dev35 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %8 = load %struct.input_dev*, %struct.input_dev** %dev35, align 8, !tbaa !118
  call void @input_event(%struct.input_dev* %8, i32 4, i32 4, i32 %scancode.0)
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.then31
  %dev37 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %9 = load %struct.input_dev*, %struct.input_dev** %dev37, align 8, !tbaa !118
  %key38 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 1
  %10 = load i32, i32* %key38, align 8, !tbaa !120
  call void @input_report_key(%struct.input_dev* %9, i32 %10, i32 1)
  %dev39 = getelementptr inbounds %struct.sony_laptop_keypress, %struct.sony_laptop_keypress* %kp, i32 0, i32 0
  %11 = load %struct.input_dev*, %struct.input_dev** %dev39, align 8, !tbaa !118
  call void @input_sync(%struct.input_dev* %11)
  %call44 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4))
  %call45 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call44)
  %12 = bitcast %struct.sony_laptop_keypress* %kp to i8*
  %13 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 3), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %13 to %struct.__kfifo*
  %conv51 = trunc i64 16 to i32
  %call52 = call i32 @__kfifo_in(%struct.__kfifo* %kfifo, i8* %12, i32 %conv51)
  call void @spin_unlock_irqrestore(%struct.spinlock* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 4), i64 %call45)
  %14 = load volatile i64, i64* @jiffies, align 8, !tbaa !101
  %call54 = call i64 @msecs_to_jiffies(i32 10)
  %add = add i64 %14, %call54
  %call55 = call i32 @mod_timer(%struct.timer_list* getelementptr inbounds (%struct.sony_laptop_input_s, %struct.sony_laptop_input_s* @sony_laptop_input, i32 0, i32 5), i64 %add)
  br label %cleanup

do.body56:                                        ; preds = %sw.epilog
  %15 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool57 = icmp ne i32 %15, 0
  br i1 %tobool57, label %if.then58, label %cleanup

if.then58:                                        ; preds = %do.body56
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then58, %do.body56, %if.end36, %sw.bb6, %sw.bb, %entry
  ret void
}

declare i32 @acpi_bus_generate_proc_event(%struct.acpi_device*, i8 zeroext, i32) #2

; Function Attrs: nounwind uwtable
define internal void @sonypi_compat_report_event(i8 zeroext %event) #1 {
entry:
  %event.addr = alloca i8, align 1
  store i8 %event, i8* %event.addr, align 1, !tbaa !41
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2))
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %0 = getelementptr inbounds %struct.kfifo, %struct.kfifo* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 1), i32 0, i32 0
  %kfifo = bitcast %union.anon.58* %0 to %struct.__kfifo*
  %conv6 = trunc i64 1 to i32
  %call7 = call i32 @__kfifo_in(%struct.__kfifo* %kfifo, i8* %event.addr, i32 %conv6)
  call void @spin_unlock_irqrestore(%struct.spinlock* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 2), i64 %call2)
  call void @kill_fasync(%struct.fasync_struct** getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 0), i32 29, i32 131073)
  call void @__wake_up(%struct.__wait_queue_head* getelementptr inbounds (%struct.sonypi_compat_s, %struct.sonypi_compat_s* @sonypi_compat, i32 0, i32 3), i32 1, i32 1, i8* null)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_rel(%struct.input_dev* %dev, i32 %code, i32 %value) #0 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 2, i32 %code, i32 %value)
  ret void
}

declare i32 @__kfifo_in(%struct.__kfifo*, i8*, i32) #2

declare void @kill_fasync(%struct.fasync_struct**, i32, i32) #2

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #2

declare i32 @acpi_set_current_resources(i8*, %struct.acpi_buffer*) #2

declare i32 @platform_driver_register(%struct.platform_driver*) #2

declare %struct.platform_device* @platform_device_alloc(i8*, i32) #2

declare i32 @platform_device_add(%struct.platform_device*) #2

declare void @platform_device_put(%struct.platform_device*) #2

declare void @platform_driver_unregister(%struct.platform_driver*) #2

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_bluetoothpower_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 11), align 1, !tbaa !43
  %conv = zext i8 %0 to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_bluetoothpower_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i64, align 8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %0 = load i64, i64* %value, align 8, !tbaa !101
  %conv = trunc i64 %0 to i8
  call void @__sony_pic_set_bluetoothpower(i8 zeroext %conv)
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end2 ], [ -22, %entry ], [ -22, %if.end ]
  ret i64 %retval.0
}

declare i32 @snprintf(i8*, i64, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #0 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

declare i32 @kstrtoull(i8*, i32, i64*) #2

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_wwanpower_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 12), align 8, !tbaa !199
  %conv = zext i8 %0 to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_wwanpower_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i64, align 8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5), i32 0)
  %0 = load i64, i64* %value, align 8, !tbaa !101
  %conv = trunc i64 %0 to i8
  call void @__sony_pic_set_wwanpower(i8 zeroext %conv)
  call void @mutex_unlock(%struct.mutex* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 5))
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end2 ], [ -22, %entry ], [ -22, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @__sony_pic_set_wwanpower(i8 zeroext %state) #1 {
entry:
  %tobool = icmp ne i8 %state, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = trunc i32 %lnot.ext to i8
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 12), align 8, !tbaa !199
  %conv2 = zext i8 %0 to i32
  %conv3 = zext i8 %conv to i32
  %cmp = icmp eq i32 %conv2, %conv3
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = call zeroext i8 @sony_pic_call2(i8 zeroext -80, i8 zeroext %conv)
  call void @sony_pic_call1(i8 zeroext -126)
  store i8 %conv, i8* getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 12), align 8, !tbaa !199
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_fanspeed_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %value = alloca i8, align 1
  store i8 0, i8* %value, align 1, !tbaa !41
  %call = call i32 @sony_pic_get_fanspeed(i8* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = load i8, i8* %value, align 1, !tbaa !41
  %conv = zext i8 %0 to i32
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv2, %if.end ], [ -5, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_pic_fanspeed_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i64, align 8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %0 = load i64, i64* %value, align 8, !tbaa !101
  %call3 = call i32 @sony_pic_set_fanspeed(i64 %0)
  %tobool4 = icmp ne i32 %call3, 0
  %.count = select i1 %tobool4, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end2 ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test(%struct.atomic_t* %v) #0 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !200
  %0 = load i8, i8* %c, align 1, !tbaa !41
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare void @platform_device_unregister(%struct.platform_device*) #2

declare i32 @misc_deregister(%struct.miscdevice*) #2

declare i32 @del_timer_sync(%struct.timer_list*) #2

declare void @sysfs_remove_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_suspend(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -480
  %1 = bitcast i8* %add.ptr to %struct.acpi_device*
  %call = call i32 @sony_pic_disable(%struct.acpi_device* %1)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 -6, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_pic_resume(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -480
  %1 = bitcast i8* %add.ptr to %struct.acpi_device*
  %2 = load %struct.sony_pic_ioport*, %struct.sony_pic_ioport** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 2), align 8, !tbaa !23
  %3 = load %struct.sony_pic_irq*, %struct.sony_pic_irq** getelementptr inbounds (%struct.sony_pic_dev, %struct.sony_pic_dev* @spic_dev, i32 0, i32 1), align 8, !tbaa !42
  %call = call i32 @sony_pic_enable(%struct.acpi_device* %1, %struct.sony_pic_ioport* %2, %struct.sony_pic_irq* %3)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_add(%struct.acpi_device* %device) #1 {
entry:
  %handle = alloca i8*, align 8
  %arg = alloca i32, align 4
  call void (i8*, ...) @printk(i8* null)
  store %struct.acpi_device* %device, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !37
  %pnp = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 8
  %device_class = getelementptr inbounds %struct.acpi_device_pnp, %struct.acpi_device_pnp* %pnp, i32 0, i32 6
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %device_class, i32 0, i32 0
  %call1 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.17, i32 0, i32 0))
  %handle2 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 1
  %0 = load i8*, i8** %handle2, align 8, !tbaa !53
  store i8* %0, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call3 = call i32 @acpi_bus_get_status(%struct.acpi_device* %device)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %status4 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 6
  %1 = bitcast %struct.acpi_device_status* %status4 to i32*
  %bf.load = load i32, i32* %1, align 8
  %bf.clear = and i32 %bf.load, 1
  %tobool5 = icmp ne i32 %bf.clear, 0
  br i1 %tobool5, label %if.end9, label %do.body

do.body:                                          ; preds = %land.lhs.true
  %2 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool6 = icmp ne i32 %2, 0
  br i1 %tobool6, label %if.then7, label %outwalk

if.then7:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %outwalk

if.end9:                                          ; preds = %land.lhs.true, %entry
  %call10 = call i32 @sony_pf_add()
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %outpresent, label %if.end13

if.end13:                                         ; preds = %if.end9
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool14 = icmp ne i32 %3, 0
  br i1 %tobool14, label %if.then15, label %if.end21

if.then15:                                        ; preds = %if.end13
  %4 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call16 = call i32 @acpi_walk_namespace(i32 8, i8* %4, i32 1, i32 (i8*, i32, i8*, i8**)* @sony_walk_callback, i32 (i8*, i32, i8*, i8**)* null, i8* null, i8** null)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.then15
  call void (i8*, ...) @printk(i8* null)
  br label %outpresent

if.end21:                                         ; preds = %if.then15, %if.end13
  %call22 = call i32 @sony_laptop_setup_input(%struct.acpi_device* %device)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end21
  call void (i8*, ...) @printk(i8* null)
  br label %outplatform

if.end26:                                         ; preds = %if.end21
  %5 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call27 = call i32 @acpi_get_handle(i8* %5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.82, i32 0, i32 0), i8** %handle)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.end41, label %if.then29

if.then29:                                        ; preds = %if.end26
  store i32 1, i32* %arg, align 4, !tbaa !12
  %6 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call30 = call i32 @sony_nc_int_call(i8* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.82, i32 0, i32 0), i32* %arg, i32* null)
  %tobool31 = icmp ne i32 %call30, 0
  %7 = load i32, i32* @debug, align 4
  %tobool34 = icmp ne i32 %7, 0
  %or.cond = and i1 %tobool31, %tobool34
  br i1 %or.cond, label %if.then35, label %if.end40

if.then35:                                        ; preds = %if.then29
  call void (i8*, ...) @printk(i8* null)
  br label %if.end40

if.end40:                                         ; preds = %if.then35, %if.then29
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.end26
  %8 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call42 = call i32 @acpi_get_handle(i8* %8, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i8** %handle)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.end56, label %do.body45

do.body45:                                        ; preds = %if.end41
  %9 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool46 = icmp ne i32 %9, 0
  br i1 %tobool46, label %if.then47, label %do.end51

if.then47:                                        ; preds = %do.body45
  call void (i8*, ...) @printk(i8* null)
  br label %do.end51

do.end51:                                         ; preds = %if.then47, %do.body45
  %10 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  %call52 = call i32 @sony_nc_handles_setup(%struct.platform_device* %10)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.end56, label %if.then54

if.then54:                                        ; preds = %do.end51
  %11 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  call void @sony_nc_function_setup(%struct.acpi_device* %device, %struct.platform_device* %11)
  br label %if.end56

if.end56:                                         ; preds = %if.then54, %do.end51, %if.end41
  %call57 = call i32 @acpi_video_backlight_support()
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.then59, label %if.else

if.then59:                                        ; preds = %if.end56
  call void (i8*, ...) @printk(i8* null)
  br label %if.end61

if.else:                                          ; preds = %if.end56
  call void @sony_nc_backlight_setup()
  br label %if.end61

if.end61:                                         ; preds = %if.else, %if.then59
  br label %for.cond

for.cond:                                         ; preds = %for.inc132, %if.end61
  %item.0 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %if.end61 ], [ %incdec.ptr133, %for.inc132 ]
  %name = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %12 = load i8*, i8** %name, align 8, !tbaa !201
  %tobool62 = icmp ne i8* %12, null
  br i1 %tobool62, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %13 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool63 = icmp ne i32 %13, 0
  br i1 %tobool63, label %if.end67, label %land.lhs.true64

land.lhs.true64:                                  ; preds = %for.body
  %debug = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 6
  %14 = load i32, i32* %debug, align 8, !tbaa !206
  %tobool65 = icmp ne i32 %14, 0
  br i1 %tobool65, label %for.inc132, label %if.end67

if.end67:                                         ; preds = %land.lhs.true64, %for.body
  br label %for.cond68

for.cond68:                                       ; preds = %for.inc, %if.end67
  %acpiget = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %15 = load i8**, i8*** %acpiget, align 8, !tbaa !207
  %tobool69 = icmp ne i8** %15, null
  br i1 %tobool69, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond68
  %acpiget70 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %16 = load i8**, i8*** %acpiget70, align 8, !tbaa !207
  %17 = load i8*, i8** %16, align 8, !tbaa !37
  %tobool71 = icmp ne i8* %17, null
  br i1 %tobool71, label %for.body72, label %for.end

for.body72:                                       ; preds = %land.rhs
  %18 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %acpiget73 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %19 = load i8**, i8*** %acpiget73, align 8, !tbaa !207
  %20 = load i8*, i8** %19, align 8, !tbaa !37
  %call74 = call i32 @acpi_get_handle(i8* %18, i8* %20, i8** %handle)
  %tobool75 = icmp ne i32 %call74, 0
  br i1 %tobool75, label %for.inc, label %do.body77

do.body77:                                        ; preds = %for.body72
  %21 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool78 = icmp ne i32 %21, 0
  br i1 %tobool78, label %if.then79, label %do.end85

if.then79:                                        ; preds = %do.body77
  call void (i8*, ...) @printk(i8* null)
  br label %do.end85

do.end85:                                         ; preds = %if.then79, %do.body77
  %devattr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 1
  %22 = load i16, i16* %mode, align 8, !tbaa !208
  %conv = zext i16 %22 to i32
  %or = or i32 %conv, 292
  %conv86 = trunc i32 %or to i16
  store i16 %conv86, i16* %mode, align 8, !tbaa !208
  br label %for.end

for.inc:                                          ; preds = %for.body72
  %acpiget88 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 1
  %23 = load i8**, i8*** %acpiget88, align 8, !tbaa !207
  %incdec.ptr = getelementptr inbounds i8*, i8** %23, i32 1
  store i8** %incdec.ptr, i8*** %acpiget88, align 8, !tbaa !207
  br label %for.cond68

for.end:                                          ; preds = %do.end85, %land.rhs, %for.cond68
  br label %for.cond89

for.cond89:                                       ; preds = %for.inc116, %for.end
  %acpiset = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %24 = load i8**, i8*** %acpiset, align 8, !tbaa !209
  %tobool90 = icmp ne i8** %24, null
  br i1 %tobool90, label %land.rhs91, label %for.end119

land.rhs91:                                       ; preds = %for.cond89
  %acpiset92 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %25 = load i8**, i8*** %acpiset92, align 8, !tbaa !209
  %26 = load i8*, i8** %25, align 8, !tbaa !37
  %tobool93 = icmp ne i8* %26, null
  br i1 %tobool93, label %for.body95, label %for.end119

for.body95:                                       ; preds = %land.rhs91
  %27 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %acpiset96 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %28 = load i8**, i8*** %acpiset96, align 8, !tbaa !209
  %29 = load i8*, i8** %28, align 8, !tbaa !37
  %call97 = call i32 @acpi_get_handle(i8* %27, i8* %29, i8** %handle)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %for.inc116, label %do.body100

do.body100:                                       ; preds = %for.body95
  %30 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool101 = icmp ne i32 %30, 0
  br i1 %tobool101, label %if.then102, label %do.end108

if.then102:                                       ; preds = %do.body100
  call void (i8*, ...) @printk(i8* null)
  br label %do.end108

do.end108:                                        ; preds = %if.then102, %do.body100
  %devattr109 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %attr110 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr109, i32 0, i32 0
  %mode111 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr110, i32 0, i32 1
  %31 = load i16, i16* %mode111, align 8, !tbaa !208
  %conv112 = zext i16 %31 to i32
  %or113 = or i32 %conv112, 128
  %conv114 = trunc i32 %or113 to i16
  store i16 %conv114, i16* %mode111, align 8, !tbaa !208
  br label %for.end119

for.inc116:                                       ; preds = %for.body95
  %acpiset117 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %32 = load i8**, i8*** %acpiset117, align 8, !tbaa !209
  %incdec.ptr118 = getelementptr inbounds i8*, i8** %32, i32 1
  store i8** %incdec.ptr118, i8*** %acpiset117, align 8, !tbaa !209
  br label %for.cond89

for.end119:                                       ; preds = %do.end108, %land.rhs91, %for.cond89
  %devattr120 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %attr121 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr120, i32 0, i32 0
  %mode122 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr121, i32 0, i32 1
  %33 = load i16, i16* %mode122, align 8, !tbaa !208
  %conv123 = zext i16 %33 to i32
  %cmp = icmp ne i32 %conv123, 0
  br i1 %cmp, label %if.then125, label %for.inc132

if.then125:                                       ; preds = %for.end119
  %34 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %34, i32 0, i32 3
  %devattr126 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  %call127 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %devattr126)
  %tobool128 = icmp ne i32 %call127, 0
  br i1 %tobool128, label %out_sysfs, label %for.inc132

for.inc132:                                       ; preds = %if.then125, %for.end119, %land.lhs.true64
  %incdec.ptr133 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 1
  br label %for.cond

out_sysfs:                                        ; preds = %if.then125
  br label %for.cond135

for.cond135:                                      ; preds = %for.body138, %out_sysfs
  %item.1 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %out_sysfs ], [ %incdec.ptr142, %for.body138 ]
  %name136 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.1, i32 0, i32 0
  %35 = load i8*, i8** %name136, align 8, !tbaa !201
  %tobool137 = icmp ne i8* %35, null
  br i1 %tobool137, label %for.body138, label %for.end143

for.body138:                                      ; preds = %for.cond135
  %36 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  %dev139 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %36, i32 0, i32 3
  %devattr140 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.1, i32 0, i32 7
  call void @device_remove_file(%struct.device* %dev139, %struct.device_attribute* %devattr140)
  %incdec.ptr142 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.1, i32 1
  br label %for.cond135

for.end143:                                       ; preds = %for.cond135
  call void @sony_nc_backlight_cleanup()
  %37 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  call void @sony_nc_function_cleanup(%struct.platform_device* %37)
  %38 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  call void @sony_nc_handles_cleanup(%struct.platform_device* %38)
  br label %outplatform

outplatform:                                      ; preds = %for.end143, %if.then24
  %result.0 = phi i32 [ %call22, %if.then24 ], [ %call127, %for.end143 ]
  call void @sony_laptop_remove_input()
  br label %outpresent

outpresent:                                       ; preds = %outplatform, %if.then18, %if.end9
  %result.1 = phi i32 [ -19, %if.then18 ], [ %result.0, %outplatform ], [ %call10, %if.end9 ]
  call void @sony_pf_remove()
  br label %outwalk

outwalk:                                          ; preds = %outpresent, %if.then7, %do.body
  %result.2 = phi i32 [ %result.1, %outpresent ], [ -19, %if.then7 ], [ -19, %do.body ]
  call void @sony_nc_rfkill_cleanup()
  br label %cleanup

cleanup:                                          ; preds = %outwalk, %for.cond
  %retval.0 = phi i32 [ %result.2, %outwalk ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_remove(%struct.acpi_device* %device) #1 {
entry:
  call void @sony_nc_backlight_cleanup()
  store %struct.acpi_device* null, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !37
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %item.0 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %entry ], [ %incdec.ptr, %for.body ]
  %name = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !201
  %tobool = icmp ne i8* %0, null
  %1 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %1, i32 0, i32 3
  %devattr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 7
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %devattr)
  %incdec.ptr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @sony_nc_function_cleanup(%struct.platform_device* %1)
  %2 = load %struct.platform_device*, %struct.platform_device** @sony_pf_device, align 8, !tbaa !37
  call void @sony_nc_handles_cleanup(%struct.platform_device* %2)
  call void @sony_pf_remove()
  call void @sony_laptop_remove_input()
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then, label %do.end

if.then:                                          ; preds = %for.end
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %for.end
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_notify(%struct.acpi_device* %device, i32 %event) #1 {
entry:
  %result = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cmp = icmp uge i32 %event, 144
  br i1 %cmp, label %if.then1, label %if.else54

if.then1:                                         ; preds = %do.end
  store i32 0, i32* %result, align 4, !tbaa !12
  store i32 0, i32* %arg, align 4, !tbaa !12
  %sub = sub i32 %event, 144
  %conv = zext i32 %sub to i64
  %cmp2 = icmp uge i64 %conv, 16
  br i1 %cmp2, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.then1
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end6:                                          ; preds = %if.then1
  %1 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %1, i32 0, i32 0
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %2 = load i16, i16* %arrayidx, align 2, !tbaa !195
  %conv7 = zext i16 %2 to i32
  %Pivot20 = icmp slt i32 %conv7, 296
  br i1 %Pivot20, label %NodeBlock3, label %NodeBlock17

NodeBlock17:                                      ; preds = %if.end6
  %Pivot18 = icmp slt i32 %conv7, 326
  br i1 %Pivot18, label %NodeBlock9, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %conv7, 347
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %conv7, 347
  br i1 %SwitchLeaf14, label %sw.bb41, label %do.body43

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %conv7, 326
  br i1 %SwitchLeaf12, label %sw.bb20, label %do.body43

NodeBlock9:                                       ; preds = %NodeBlock17
  %Pivot10 = icmp slt i32 %conv7, 309
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv7, 309
  br i1 %SwitchLeaf8, label %sw.bb14, label %do.body43

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv7, 296
  br i1 %SwitchLeaf6, label %sw.bb20, label %do.body43

NodeBlock3:                                       ; preds = %if.end6
  %Pivot4 = icmp slt i32 %conv7, 292
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %conv7, 295
  br i1 %Pivot, label %LeafBlock1, label %sw.bb

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv7, 292
  br i1 %SwitchLeaf2, label %sw.bb14, label %do.body43

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %conv7, 256
  br i1 %SwitchLeaf, label %sw.bb, label %do.body43

sw.bb:                                            ; preds = %LeafBlock, %NodeBlock
  %call8 = call i32 @sony_nc_hotkeys_decode(i32 %conv7)
  %cmp9 = icmp ugt i32 %call8, 0
  br i1 %cmp9, label %if.then11, label %sw.epilog

if.then11:                                        ; preds = %sw.bb
  %conv12 = trunc i32 %call8 to i8
  call void @sony_laptop_report_input_event(i8 zeroext %conv12)
  br label %sw.epilog

sw.bb14:                                          ; preds = %LeafBlock1, %LeafBlock7
  %call15 = call i32 @sony_call_snc_handle(i32 %conv7, i32 256, i32* %result)
  %3 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %3, 3
  %cmp16 = icmp eq i32 %and, 1
  br i1 %cmp16, label %if.then18, label %sw.epilog

if.then18:                                        ; preds = %sw.bb14
  call void @sony_nc_rfkill_update()
  br label %sw.epilog

sw.bb20:                                          ; preds = %LeafBlock5, %LeafBlock11
  %call21 = call i32 @sony_call_snc_handle(i32 %conv7, i32 0, i32* %result)
  %4 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool23 = icmp ne i32 %4, 0
  br i1 %tobool23, label %if.then24, label %do.end39

if.then24:                                        ; preds = %sw.bb20
  %5 = load i32, i32* %result, align 4, !tbaa !12
  %cmp25 = icmp eq i32 %5, 1
  br i1 %cmp25, label %cond.end34, label %cond.false

cond.false:                                       ; preds = %if.then24
  %6 = load i32, i32* %result, align 4, !tbaa !12
  %cmp27 = icmp eq i32 %6, 2
  br i1 %cmp27, label %cond.end34, label %cond.false30

cond.false30:                                     ; preds = %cond.false
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false30, %cond.false, %if.then24
  call void (i8*, ...) @printk(i8* null)
  br label %do.end39

do.end39:                                         ; preds = %cond.end34, %sw.bb20
  %call40 = call i32 @__sony_nc_gfx_switch_status_get()
  br label %sw.epilog

sw.bb41:                                          ; preds = %LeafBlock13
  %call42 = call i32 @__sony_nc_gfx_switch_status_get()
  br label %sw.epilog

do.body43:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock5, %LeafBlock7, %LeafBlock11, %LeafBlock13
  %7 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool44 = icmp ne i32 %7, 0
  br i1 %tobool44, label %if.then45, label %sw.epilog

if.then45:                                        ; preds = %do.body43
  call void (i8*, ...) @printk(i8* null)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then45, %do.body43, %sw.bb41, %do.end39, %if.then18, %sw.bb14, %if.then11, %sw.bb
  %ev_type.0 = phi i8 [ 3, %do.end39 ], [ 3, %sw.bb41 ], [ 1, %sw.bb ], [ 1, %if.then11 ], [ 2, %if.then18 ], [ 2, %sw.bb14 ], [ 0, %if.then45 ], [ 0, %do.body43 ]
  %real_ev.1 = phi i32 [ %call40, %do.end39 ], [ %call42, %sw.bb41 ], [ %call8, %if.then11 ], [ %event, %sw.bb ], [ %and, %if.then18 ], [ %and, %sw.bb14 ], [ %event, %if.then45 ], [ %event, %do.body43 ]
  %shl = shl i32 1, %sub
  store i32 %shl, i32* %arg, align 4, !tbaa !12
  %8 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call50 = call i32 @sony_nc_int_call(i8* %8, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.191, i32 0, i32 0), i32* %arg, i32* %result)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %if.then4
  %ev_type.1 = phi i8 [ 0, %if.then4 ], [ %ev_type.0, %sw.epilog ]
  %real_ev.2 = phi i32 [ %event, %if.then4 ], [ %real_ev.1, %sw.epilog ]
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then4 ], [ 0, %sw.epilog ]
  %SwitchLeaf23 = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf23, label %if.end56, label %cleanup.cont63

if.else54:                                        ; preds = %do.end
  %conv55 = trunc i32 %event to i8
  call void @sony_laptop_report_input_event(i8 zeroext %conv55)
  br label %if.end56

if.end56:                                         ; preds = %if.else54, %cleanup
  %ev_type.2 = phi i8 [ 1, %if.else54 ], [ %ev_type.1, %cleanup ]
  %real_ev.3 = phi i32 [ %event, %if.else54 ], [ %real_ev.2, %cleanup ]
  %9 = load %struct.acpi_device*, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !37
  %call57 = call i32 @acpi_bus_generate_proc_event(%struct.acpi_device* %9, i8 zeroext %ev_type.2, i32 %real_ev.3)
  %10 = load %struct.acpi_device*, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !37
  %pnp = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %10, i32 0, i32 8
  %device_class = getelementptr inbounds %struct.acpi_device_pnp, %struct.acpi_device_pnp* %pnp, i32 0, i32 6
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %device_class, i32 0, i32 0
  %11 = load %struct.acpi_device*, %struct.acpi_device** @sony_nc_acpi_device, align 8, !tbaa !37
  %dev = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %11, i32 0, i32 16
  %call58 = call i8* @dev_name(%struct.device* %dev)
  %call59 = call i32 @acpi_bus_generate_netlink_event(i8* %arraydecay, i8* %call58, i8 zeroext %ev_type.2, i32 %real_ev.3)
  br label %cleanup.cont63

cleanup.cont63:                                   ; preds = %if.end56, %cleanup
  ret void
}

declare i32 @acpi_walk_namespace(i32, i8*, i32, i32 (i8*, i32, i8*, i8**)*, i32 (i8*, i32, i8*, i8**)*, i8*, i8**) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_walk_callback(i8* %handle, i32 %level, i8* %context, i8** %return_value) #1 {
entry:
  %info = alloca %struct.acpi_device_info*, align 8
  %call = call i32 @acpi_get_object_info(i8* %handle, %struct.acpi_device_info** %info)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  %0 = load %struct.acpi_device_info*, %struct.acpi_device_info** %info, align 8, !tbaa !37
  %1 = bitcast %struct.acpi_device_info* %0 to i8*
  call void @kfree(i8* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

declare i32 @acpi_get_handle(i8*, i8*, i8**) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_handles_setup(%struct.platform_device* %pd) #1 {
entry:
  %result = alloca i32, align 4
  %arg = alloca i32, align 4
  %call = call i8* @kzalloc(i64 80, i32 208)
  %0 = bitcast i8* %call to %struct.sony_nc_handles*
  store %struct.sony_nc_handles* %0, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %1 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %tobool = icmp ne %struct.sony_nc_handles* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 %i.0, 32
  store i32 %add, i32* %arg, align 4, !tbaa !12
  %2 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call2 = call i32 @sony_nc_int_call(i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i32* %arg, i32* %result)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %for.inc, label %do.body

do.body:                                          ; preds = %for.body
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool5 = icmp ne i32 %3, 0
  br i1 %tobool5, label %if.then6, label %do.end

if.then6:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then6, %do.body
  %4 = load i32, i32* %result, align 4, !tbaa !12
  %conv9 = trunc i32 %4 to i16
  %5 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %5, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  store i16 %conv9, i16* %arrayidx, align 2, !tbaa !195
  br label %for.inc

for.inc:                                          ; preds = %do.end, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool11 = icmp ne i32 %6, 0
  br i1 %tobool11, label %do.body13, label %cleanup

do.body13:                                        ; preds = %for.end
  %7 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %devattr = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %7, i32 0, i32 1
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_handles_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !210
  %8 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %devattr16 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %8, i32 0, i32 1
  %attr17 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr16, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr17, i32 0, i32 0
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.91, i32 0, i32 0), i8** %name, align 8, !tbaa !211
  %9 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %devattr18 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %9, i32 0, i32 1
  %attr19 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr18, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr19, i32 0, i32 1
  store i16 292, i16* %mode, align 8, !tbaa !213
  %10 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %devattr20 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %10, i32 0, i32 1
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %devattr20, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_handles_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !214
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %11 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %devattr21 = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %11, i32 0, i32 1
  %call22 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %devattr21)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.then24, label %cleanup

if.then24:                                        ; preds = %do.body13
  %12 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %13 = bitcast %struct.sony_nc_handles* %12 to i8*
  call void @kfree(i8* %13)
  store %struct.sony_nc_handles* null, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  br label %cleanup

cleanup:                                          ; preds = %if.then24, %do.body13, %for.end, %entry
  %retval.0 = phi i32 [ -1, %if.then24 ], [ -12, %entry ], [ 0, %do.body13 ], [ 0, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_function_setup(%struct.acpi_device* %device, %struct.platform_device* %pf_device) #1 {
entry:
  %result = alloca i32, align 4
  %bitmask = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %tobool = icmp ne %struct.sony_nc_handles* %0, null
  br i1 %tobool, label %if.end, label %cleanup65

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock71, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %LeafBlock71 ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %1, i32 0, i32 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %2 = load i16, i16* %arrayidx, align 2, !tbaa !195
  %conv2 = zext i16 %2 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br i1 %tobool3, label %do.body, label %LeafBlock71

do.body:                                          ; preds = %for.body
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool6 = icmp ne i32 %3, 0
  br i1 %tobool6, label %if.then7, label %NodeBlock68

if.then7:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %NodeBlock68

NodeBlock68:                                      ; preds = %if.then7, %do.body
  %Pivot69 = icmp slt i32 %conv2, 309
  br i1 %Pivot69, label %NodeBlock31, label %NodeBlock66

NodeBlock66:                                      ; preds = %NodeBlock68
  %Pivot67 = icmp slt i32 %conv2, 326
  br i1 %Pivot67, label %NodeBlock45, label %NodeBlock64

NodeBlock64:                                      ; preds = %NodeBlock66
  %Pivot65 = icmp slt i32 %conv2, 331
  br i1 %Pivot65, label %NodeBlock51, label %NodeBlock62

NodeBlock62:                                      ; preds = %NodeBlock64
  %Pivot63 = icmp slt i32 %conv2, 347
  br i1 %Pivot63, label %LeafBlock53, label %NodeBlock60

NodeBlock60:                                      ; preds = %NodeBlock62
  %Pivot61 = icmp slt i32 %conv2, 355
  br i1 %Pivot61, label %LeafBlock56, label %LeafBlock58

LeafBlock58:                                      ; preds = %NodeBlock60
  %SwitchLeaf59 = icmp eq i32 %conv2, 355
  br i1 %SwitchLeaf59, label %sw.bb54, label %LeafBlock71

LeafBlock56:                                      ; preds = %NodeBlock60
  %SwitchLeaf57 = icmp eq i32 %conv2, 347
  br i1 %SwitchLeaf57, label %sw.bb36, label %LeafBlock71

LeafBlock53:                                      ; preds = %NodeBlock62
  %.off54 = add i32 %conv2, -331
  %SwitchLeaf55 = icmp ule i32 %.off54, 1
  br i1 %SwitchLeaf55, label %sw.bb54, label %LeafBlock71

NodeBlock51:                                      ; preds = %NodeBlock64
  %Pivot52 = icmp slt i32 %conv2, 328
  br i1 %Pivot52, label %LeafBlock47, label %LeafBlock49

LeafBlock49:                                      ; preds = %NodeBlock51
  %SwitchLeaf50 = icmp eq i32 %conv2, 328
  br i1 %SwitchLeaf50, label %sw.bb12, label %LeafBlock71

LeafBlock47:                                      ; preds = %NodeBlock51
  %SwitchLeaf48 = icmp eq i32 %conv2, 326
  br i1 %SwitchLeaf48, label %sw.bb36, label %LeafBlock71

NodeBlock45:                                      ; preds = %NodeBlock66
  %Pivot46 = icmp slt i32 %conv2, 311
  br i1 %Pivot46, label %NodeBlock33, label %NodeBlock43

NodeBlock43:                                      ; preds = %NodeBlock45
  %Pivot44 = icmp slt i32 %conv2, 319
  br i1 %Pivot44, label %LeafBlock35, label %NodeBlock41

NodeBlock41:                                      ; preds = %NodeBlock43
  %Pivot42 = icmp slt i32 %conv2, 323
  br i1 %Pivot42, label %LeafBlock37, label %LeafBlock39

LeafBlock39:                                      ; preds = %NodeBlock41
  %SwitchLeaf40 = icmp eq i32 %conv2, 323
  br i1 %SwitchLeaf40, label %sw.bb54, label %LeafBlock71

LeafBlock37:                                      ; preds = %NodeBlock41
  %SwitchLeaf38 = icmp eq i32 %conv2, 319
  br i1 %SwitchLeaf38, label %sw.bb18, label %LeafBlock71

LeafBlock35:                                      ; preds = %NodeBlock43
  %SwitchLeaf36 = icmp eq i32 %conv2, 311
  br i1 %SwitchLeaf36, label %sw.bb54, label %LeafBlock71

NodeBlock33:                                      ; preds = %NodeBlock45
  %Pivot34 = icmp slt i32 %conv2, 310
  br i1 %Pivot34, label %sw.bb48, label %sw.bb18

NodeBlock31:                                      ; preds = %NodeBlock68
  %Pivot32 = icmp slt i32 %conv2, 290
  br i1 %Pivot32, label %NodeBlock13, label %NodeBlock29

NodeBlock29:                                      ; preds = %NodeBlock31
  %Pivot30 = icmp slt i32 %conv2, 295
  br i1 %Pivot30, label %NodeBlock19, label %NodeBlock27

NodeBlock27:                                      ; preds = %NodeBlock29
  %Pivot28 = icmp slt i32 %conv2, 296
  br i1 %Pivot28, label %sw.bb, label %NodeBlock25

NodeBlock25:                                      ; preds = %NodeBlock27
  %Pivot26 = icmp slt i32 %conv2, 305
  br i1 %Pivot26, label %LeafBlock21, label %LeafBlock23

LeafBlock23:                                      ; preds = %NodeBlock25
  %SwitchLeaf24 = icmp eq i32 %conv2, 305
  br i1 %SwitchLeaf24, label %sw.bb42, label %LeafBlock71

LeafBlock21:                                      ; preds = %NodeBlock25
  %SwitchLeaf22 = icmp eq i32 %conv2, 296
  br i1 %SwitchLeaf22, label %sw.bb36, label %LeafBlock71

NodeBlock19:                                      ; preds = %NodeBlock29
  %Pivot20 = icmp slt i32 %conv2, 292
  br i1 %Pivot20, label %LeafBlock15, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %conv2, 292
  br i1 %SwitchLeaf18, label %sw.bb48, label %LeafBlock71

LeafBlock15:                                      ; preds = %NodeBlock19
  %SwitchLeaf16 = icmp eq i32 %conv2, 290
  br i1 %SwitchLeaf16, label %sw.bb30, label %LeafBlock71

NodeBlock13:                                      ; preds = %NodeBlock31
  %Pivot14 = icmp slt i32 %conv2, 261
  br i1 %Pivot14, label %NodeBlock, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %conv2, 277
  br i1 %Pivot12, label %LeafBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %conv2, 281
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv2, 281
  br i1 %SwitchLeaf8, label %sw.bb24, label %LeafBlock71

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv2, 277
  br i1 %SwitchLeaf6, label %sw.bb18, label %LeafBlock71

LeafBlock3:                                       ; preds = %NodeBlock11
  %SwitchLeaf4 = icmp eq i32 %conv2, 261
  br i1 %SwitchLeaf4, label %sw.bb12, label %LeafBlock71

NodeBlock:                                        ; preds = %NodeBlock13
  %Pivot = icmp slt i32 %conv2, 258
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv2, 258
  br i1 %SwitchLeaf2, label %sw.bb10, label %LeafBlock71

LeafBlock:                                        ; preds = %NodeBlock
  %.off = add i32 %conv2, -256
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %LeafBlock71

sw.bb:                                            ; preds = %LeafBlock, %NodeBlock27
  %call9 = call i32 @sony_call_snc_handle(i32 %conv2, i32 0, i32* %result)
  br label %LeafBlock71

sw.bb10:                                          ; preds = %LeafBlock1
  %call11 = call i32 @sony_call_snc_handle(i32 %conv2, i32 256, i32* %result)
  br label %LeafBlock71

sw.bb12:                                          ; preds = %LeafBlock3, %LeafBlock49
  %call13 = call i32 @sony_nc_touchpad_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call13, i32* %result, align 4, !tbaa !12
  %4 = load i32, i32* %result, align 4, !tbaa !12
  %tobool14 = icmp ne i32 %4, 0
  br i1 %tobool14, label %if.then15, label %LeafBlock71

if.then15:                                        ; preds = %sw.bb12
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock71

sw.bb18:                                          ; preds = %LeafBlock5, %NodeBlock33, %LeafBlock37
  %call19 = call i32 @sony_nc_battery_care_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call19, i32* %result, align 4, !tbaa !12
  %5 = load i32, i32* %result, align 4, !tbaa !12
  %tobool20 = icmp ne i32 %5, 0
  br i1 %tobool20, label %if.then21, label %LeafBlock71

if.then21:                                        ; preds = %sw.bb18
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock71

sw.bb24:                                          ; preds = %LeafBlock7
  %call25 = call i32 @sony_nc_lid_resume_setup(%struct.platform_device* %pf_device)
  store i32 %call25, i32* %result, align 4, !tbaa !12
  %6 = load i32, i32* %result, align 4, !tbaa !12
  %tobool26 = icmp ne i32 %6, 0
  br i1 %tobool26, label %if.then27, label %LeafBlock71

if.then27:                                        ; preds = %sw.bb24
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock71

sw.bb30:                                          ; preds = %LeafBlock15
  %call31 = call i32 @sony_nc_thermal_setup(%struct.platform_device* %pf_device)
  store i32 %call31, i32* %result, align 4, !tbaa !12
  %7 = load i32, i32* %result, align 4, !tbaa !12
  %tobool32 = icmp ne i32 %7, 0
  br i1 %tobool32, label %if.then33, label %LeafBlock71

if.then33:                                        ; preds = %sw.bb30
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock71

sw.bb36:                                          ; preds = %LeafBlock21, %LeafBlock47, %LeafBlock56
  %call37 = call i32 @sony_nc_gfx_switch_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call37, i32* %result, align 4, !tbaa !12
  %8 = load i32, i32* %result, align 4, !tbaa !12
  %tobool38 = icmp ne i32 %8, 0
  br i1 %tobool38, label %if.then39, label %LeafBlock71

if.then39:                                        ; preds = %sw.bb36
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock71

sw.bb42:                                          ; preds = %LeafBlock23
  %call43 = call i32 @sony_nc_highspeed_charging_setup(%struct.platform_device* %pf_device)
  store i32 %call43, i32* %result, align 4, !tbaa !12
  %9 = load i32, i32* %result, align 4, !tbaa !12
  %tobool44 = icmp ne i32 %9, 0
  br i1 %tobool44, label %if.then45, label %LeafBlock71

if.then45:                                        ; preds = %sw.bb42
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock71

sw.bb48:                                          ; preds = %LeafBlock17, %NodeBlock33
  %call49 = call i32 @sony_nc_rfkill_setup(%struct.acpi_device* %device, i32 %conv2)
  store i32 %call49, i32* %result, align 4, !tbaa !12
  %10 = load i32, i32* %result, align 4, !tbaa !12
  %tobool50 = icmp ne i32 %10, 0
  br i1 %tobool50, label %if.then51, label %LeafBlock71

if.then51:                                        ; preds = %sw.bb48
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock71

sw.bb54:                                          ; preds = %LeafBlock35, %LeafBlock39, %LeafBlock53, %LeafBlock58
  %call55 = call i32 @sony_nc_kbd_backlight_setup(%struct.platform_device* %pf_device, i32 %conv2)
  store i32 %call55, i32* %result, align 4, !tbaa !12
  %11 = load i32, i32* %result, align 4, !tbaa !12
  %tobool56 = icmp ne i32 %11, 0
  br i1 %tobool56, label %if.then57, label %LeafBlock71

if.then57:                                        ; preds = %sw.bb54
  call void (i8*, ...) @printk(i8* null)
  br label %LeafBlock71

LeafBlock71:                                      ; preds = %if.then57, %sw.bb54, %if.then51, %sw.bb48, %if.then45, %sw.bb42, %if.then39, %sw.bb36, %if.then33, %sw.bb30, %if.then27, %sw.bb24, %if.then21, %sw.bb18, %if.then15, %sw.bb12, %sw.bb10, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock7, %LeafBlock15, %LeafBlock17, %LeafBlock21, %LeafBlock23, %LeafBlock35, %LeafBlock37, %LeafBlock39, %LeafBlock47, %LeafBlock49, %LeafBlock53, %LeafBlock56, %LeafBlock58, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 16, i32* %arg, align 4, !tbaa !12
  %12 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call60 = call i32 @sony_nc_int_call(i8* %12, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i32* %arg, i32* %bitmask)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %cleanup65, label %if.then62

if.then62:                                        ; preds = %for.end
  %13 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call63 = call i32 @sony_nc_int_call(i8* %13, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.103, i32 0, i32 0), i32* %bitmask, i32* %result)
  br label %cleanup65

cleanup65:                                        ; preds = %if.then62, %for.end, %entry
  ret void
}

declare i32 @acpi_video_backlight_support() #2

; Function Attrs: nounwind uwtable
define internal void @sony_nc_backlight_setup() #1 {
entry:
  %unused = alloca i8*, align 8
  %props = alloca %struct.backlight_properties, align 4
  %call = call i32 @sony_find_snc_handle(i32 303)
  %cmp = icmp sge i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 256, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !215
  call void @sony_nc_backlight_ng_read_limits(i32 303, %struct.sony_backlight_props* @sony_bl_props)
  %0 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !216
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !217
  %conv1 = zext i8 %1 to i32
  %sub = sub nsw i32 %conv, %conv1
  br label %if.end41

if.else:                                          ; preds = %entry
  %call2 = call i32 @sony_find_snc_handle(i32 311)
  %cmp3 = icmp sge i32 %call2, 0
  br i1 %cmp3, label %if.then5, label %if.else9

if.then5:                                         ; preds = %if.else
  store i32 256, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !215
  call void @sony_nc_backlight_ng_read_limits(i32 311, %struct.sony_backlight_props* @sony_bl_props)
  %2 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !216
  %conv6 = zext i8 %2 to i32
  %3 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !217
  %conv7 = zext i8 %3 to i32
  %sub8 = sub nsw i32 %conv6, %conv7
  br label %if.end41

if.else9:                                         ; preds = %if.else
  %call10 = call i32 @sony_find_snc_handle(i32 323)
  %cmp11 = icmp sge i32 %call10, 0
  br i1 %cmp11, label %if.then13, label %if.else17

if.then13:                                        ; preds = %if.else9
  store i32 12288, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !215
  call void @sony_nc_backlight_ng_read_limits(i32 323, %struct.sony_backlight_props* @sony_bl_props)
  %4 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !216
  %conv14 = zext i8 %4 to i32
  %5 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !217
  %conv15 = zext i8 %5 to i32
  %sub16 = sub nsw i32 %conv14, %conv15
  br label %if.end41

if.else17:                                        ; preds = %if.else9
  %call18 = call i32 @sony_find_snc_handle(i32 331)
  %cmp19 = icmp sge i32 %call18, 0
  br i1 %cmp19, label %if.then21, label %if.else25

if.then21:                                        ; preds = %if.else17
  store i32 12288, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !215
  call void @sony_nc_backlight_ng_read_limits(i32 331, %struct.sony_backlight_props* @sony_bl_props)
  %6 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !216
  %conv22 = zext i8 %6 to i32
  %7 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !217
  %conv23 = zext i8 %7 to i32
  %sub24 = sub nsw i32 %conv22, %conv23
  br label %if.end41

if.else25:                                        ; preds = %if.else17
  %call26 = call i32 @sony_find_snc_handle(i32 332)
  %cmp27 = icmp sge i32 %call26, 0
  br i1 %cmp27, label %if.then29, label %if.else33

if.then29:                                        ; preds = %if.else25
  store i32 12288, i32* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 2), align 4, !tbaa !215
  call void @sony_nc_backlight_ng_read_limits(i32 332, %struct.sony_backlight_props* @sony_bl_props)
  %8 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 4), align 1, !tbaa !216
  %conv30 = zext i8 %8 to i32
  %9 = load i8, i8* getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 3), align 8, !tbaa !217
  %conv31 = zext i8 %9 to i32
  %sub32 = sub nsw i32 %conv30, %conv31
  br label %if.end41

if.else33:                                        ; preds = %if.else25
  %10 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call34 = call i32 @acpi_get_handle(i8* %10, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.57, i32 0, i32 0), i8** %unused)
  %tobool = icmp ne i32 %call34, 0
  br i1 %tobool, label %cleanup, label %if.end41

if.end41:                                         ; preds = %if.else33, %if.then29, %if.then21, %if.then13, %if.then5, %if.then
  %ops.4 = phi %struct.backlight_ops* [ @sony_backlight_ng_ops, %if.then ], [ @sony_backlight_ng_ops, %if.then5 ], [ @sony_backlight_ng_ops, %if.then13 ], [ @sony_backlight_ng_ops, %if.then21 ], [ @sony_backlight_ng_ops, %if.then29 ], [ @sony_backlight_ops, %if.else33 ]
  %max_brightness.4 = phi i32 [ %sub, %if.then ], [ %sub8, %if.then5 ], [ %sub16, %if.then13 ], [ %sub24, %if.then21 ], [ %sub32, %if.then29 ], [ 7, %if.else33 ]
  %11 = bitcast %struct.backlight_properties* %props to i8*
  call void @llvm.memset.p0i8.i64(i8* %11, i8 0, i64 24, i32 4, i1 false)
  %type = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 4
  store i32 2, i32* %type, align 4, !tbaa !218
  %max_brightness42 = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 1
  store i32 %max_brightness.4, i32* %max_brightness42, align 4, !tbaa !219
  %call43 = call %struct.backlight_device* @backlight_device_register(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.143, i32 0, i32 0), %struct.device* null, i8* bitcast (%struct.sony_backlight_props* @sony_bl_props to i8*), %struct.backlight_ops* %ops.4, %struct.backlight_properties* %props)
  store %struct.backlight_device* %call43, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  %12 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  %13 = bitcast %struct.backlight_device* %12 to i8*
  %call44 = call i64 @IS_ERR(i8* %13)
  %tobool45 = icmp ne i64 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.else48

if.then46:                                        ; preds = %if.end41
  call void (i8*, ...) @printk(i8* null)
  store %struct.backlight_device* null, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  br label %cleanup

if.else48:                                        ; preds = %if.end41
  %get_brightness = getelementptr inbounds %struct.backlight_ops, %struct.backlight_ops* %ops.4, i32 0, i32 2
  %14 = load i32 (%struct.backlight_device*)*, i32 (%struct.backlight_device*)** %get_brightness, align 8, !tbaa !220
  %15 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  %call49 = call i32 %14(%struct.backlight_device* %15)
  %16 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  %props50 = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %16, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props50, i32 0, i32 0
  store i32 %call49, i32* %brightness, align 8, !tbaa !158
  br label %cleanup

cleanup:                                          ; preds = %if.else48, %if.then46, %if.else33
  ret void
}

declare i32 @device_create_file(%struct.device*, %struct.device_attribute*) #2

declare void @device_remove_file(%struct.device*, %struct.device_attribute*) #2

; Function Attrs: nounwind uwtable
define internal void @sony_nc_backlight_cleanup() #1 {
entry:
  %0 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  %tobool = icmp ne %struct.backlight_device* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.backlight_device*, %struct.backlight_device** getelementptr inbounds (%struct.sony_backlight_props, %struct.sony_backlight_props* @sony_bl_props, i32 0, i32 0), align 8, !tbaa !156
  call void @backlight_device_unregister(%struct.backlight_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_function_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %result = alloca i32, align 4
  %bitmask = alloca i32, align 4
  %0 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call = call i32 @sony_nc_int_call(i8* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.181, i32 0, i32 0), i32* null, i32* %bitmask)
  %1 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call1 = call i32 @sony_nc_int_call(i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.182, i32 0, i32 0), i32* %bitmask, i32* %result)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %2, i32 0, i32 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %3 = load i16, i16* %arrayidx, align 2, !tbaa !195
  %conv3 = zext i16 %3 to i32
  %tobool = icmp ne i32 %conv3, 0
  br i1 %tobool, label %NodeBlock57, label %for.inc

NodeBlock57:                                      ; preds = %for.body
  %Pivot58 = icmp slt i32 %conv3, 310
  br i1 %Pivot58, label %NodeBlock23, label %NodeBlock55

NodeBlock55:                                      ; preds = %NodeBlock57
  %Pivot56 = icmp slt i32 %conv3, 326
  br i1 %Pivot56, label %NodeBlock35, label %NodeBlock53

NodeBlock53:                                      ; preds = %NodeBlock55
  %Pivot54 = icmp slt i32 %conv3, 331
  br i1 %Pivot54, label %NodeBlock41, label %NodeBlock51

NodeBlock51:                                      ; preds = %NodeBlock53
  %Pivot52 = icmp slt i32 %conv3, 347
  br i1 %Pivot52, label %LeafBlock43, label %NodeBlock49

NodeBlock49:                                      ; preds = %NodeBlock51
  %Pivot50 = icmp slt i32 %conv3, 355
  br i1 %Pivot50, label %LeafBlock45, label %LeafBlock47

LeafBlock47:                                      ; preds = %NodeBlock49
  %SwitchLeaf48 = icmp eq i32 %conv3, 355
  br i1 %SwitchLeaf48, label %sw.bb10, label %for.inc

LeafBlock45:                                      ; preds = %NodeBlock49
  %SwitchLeaf46 = icmp eq i32 %conv3, 347
  br i1 %SwitchLeaf46, label %sw.bb7, label %for.inc

LeafBlock43:                                      ; preds = %NodeBlock51
  %.off = add i32 %conv3, -331
  %SwitchLeaf44 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf44, label %sw.bb10, label %for.inc

NodeBlock41:                                      ; preds = %NodeBlock53
  %Pivot42 = icmp slt i32 %conv3, 328
  br i1 %Pivot42, label %LeafBlock37, label %LeafBlock39

LeafBlock39:                                      ; preds = %NodeBlock41
  %SwitchLeaf40 = icmp eq i32 %conv3, 328
  br i1 %SwitchLeaf40, label %sw.bb, label %for.inc

LeafBlock37:                                      ; preds = %NodeBlock41
  %SwitchLeaf38 = icmp eq i32 %conv3, 326
  br i1 %SwitchLeaf38, label %sw.bb7, label %for.inc

NodeBlock35:                                      ; preds = %NodeBlock55
  %Pivot36 = icmp slt i32 %conv3, 319
  br i1 %Pivot36, label %NodeBlock27, label %NodeBlock33

NodeBlock33:                                      ; preds = %NodeBlock35
  %Pivot34 = icmp slt i32 %conv3, 323
  br i1 %Pivot34, label %LeafBlock29, label %LeafBlock31

LeafBlock31:                                      ; preds = %NodeBlock33
  %SwitchLeaf32 = icmp eq i32 %conv3, 323
  br i1 %SwitchLeaf32, label %sw.bb10, label %for.inc

LeafBlock29:                                      ; preds = %NodeBlock33
  %SwitchLeaf30 = icmp eq i32 %conv3, 319
  br i1 %SwitchLeaf30, label %sw.bb4, label %for.inc

NodeBlock27:                                      ; preds = %NodeBlock35
  %Pivot28 = icmp slt i32 %conv3, 311
  br i1 %Pivot28, label %sw.bb4, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %conv3, 311
  br i1 %SwitchLeaf26, label %sw.bb10, label %for.inc

NodeBlock23:                                      ; preds = %NodeBlock57
  %Pivot24 = icmp slt i32 %conv3, 292
  br i1 %Pivot24, label %NodeBlock9, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %conv3, 305
  br i1 %Pivot22, label %NodeBlock15, label %NodeBlock19

NodeBlock19:                                      ; preds = %NodeBlock21
  %Pivot20 = icmp slt i32 %conv3, 309
  br i1 %Pivot20, label %LeafBlock17, label %sw.bb9

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %conv3, 305
  br i1 %SwitchLeaf18, label %sw.bb8, label %for.inc

NodeBlock15:                                      ; preds = %NodeBlock21
  %Pivot16 = icmp slt i32 %conv3, 296
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %conv3, 296
  br i1 %SwitchLeaf14, label %sw.bb7, label %for.inc

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %conv3, 292
  br i1 %SwitchLeaf12, label %sw.bb9, label %for.inc

NodeBlock9:                                       ; preds = %NodeBlock23
  %Pivot10 = icmp slt i32 %conv3, 281
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %conv3, 290
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %conv3, 290
  br i1 %SwitchLeaf6, label %sw.bb6, label %for.inc

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %conv3, 281
  br i1 %SwitchLeaf4, label %sw.bb5, label %for.inc

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %conv3, 277
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv3, 277
  br i1 %SwitchLeaf2, label %sw.bb4, label %for.inc

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv3, 261
  br i1 %SwitchLeaf, label %sw.bb, label %for.inc

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock39
  call void @sony_nc_touchpad_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb4:                                           ; preds = %LeafBlock1, %NodeBlock27, %LeafBlock29
  call void @sony_nc_battery_care_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb5:                                           ; preds = %LeafBlock3
  call void @sony_nc_lid_resume_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb6:                                           ; preds = %LeafBlock5
  call void @sony_nc_thermal_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb7:                                           ; preds = %LeafBlock13, %LeafBlock37, %LeafBlock45
  call void @sony_nc_gfx_switch_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb8:                                           ; preds = %LeafBlock17
  call void @sony_nc_highspeed_charging_cleanup(%struct.platform_device* %pd)
  br label %for.inc

sw.bb9:                                           ; preds = %LeafBlock11, %NodeBlock19
  call void @sony_nc_rfkill_cleanup()
  br label %for.inc

sw.bb10:                                          ; preds = %LeafBlock25, %LeafBlock31, %LeafBlock43, %LeafBlock47
  call void @sony_nc_kbd_backlight_cleanup(%struct.platform_device* %pd)
  br label %for.inc

for.inc:                                          ; preds = %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock11, %LeafBlock13, %LeafBlock17, %LeafBlock25, %LeafBlock29, %LeafBlock31, %LeafBlock37, %LeafBlock39, %LeafBlock43, %LeafBlock45, %LeafBlock47, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @sony_nc_handles_cleanup(%struct.platform_device* %pd)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_handles_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %tobool = icmp ne %struct.sony_nc_handles* %0, null
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %1 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %2 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %devattr = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %2, i32 0, i32 1
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %devattr)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %3 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %4 = bitcast %struct.sony_nc_handles* %3 to i8*
  call void @kfree(i8* %4)
  store %struct.sony_nc_handles* null, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_rfkill_cleanup() #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom
  %0 = load %struct.rfkill*, %struct.rfkill** %arrayidx, align 8, !tbaa !37
  %tobool = icmp ne %struct.rfkill* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %idxprom1 = sext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom1
  %1 = load %struct.rfkill*, %struct.rfkill** %arrayidx2, align 8, !tbaa !37
  call void @rfkill_unregister(%struct.rfkill* %1)
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom3
  %2 = load %struct.rfkill*, %struct.rfkill** %arrayidx4, align 8, !tbaa !37
  call void @rfkill_destroy(%struct.rfkill* %2)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare i32 @acpi_get_object_info(i8*, %struct.acpi_device_info**) #2

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_handles_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %len.0 = phi i64 [ 0, %entry ], [ %add, %for.body ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %len.0
  %sub = sub i64 4096, %len.0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %0, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %1 = load i16, i16* %arrayidx, align 2, !tbaa !195
  %conv2 = zext i16 %1 to i32
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr, i64 %sub, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.92, i32 0, i32 0), i32 %conv2)
  %conv3 = sext i32 %call to i64
  %add = add nsw i64 %len.0, %conv3
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call6 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr, i64 %sub, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.93, i32 0, i32 0))
  %conv7 = sext i32 %call6 to i64
  %add8 = add nsw i64 %len.0, %conv7
  ret i64 %add8
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_call_snc_handle(i32 %handle, i32 %argument, i32* %result) #1 {
entry:
  %arg = alloca i32, align 4
  %call = call i32 @sony_find_snc_handle(i32 %handle)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %or = or i32 %call, %argument
  store i32 %or, i32* %arg, align 4, !tbaa !12
  %0 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call1 = call i32 @sony_nc_int_call(i8* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i32 0, i32 0), i32* %arg, i32* %result)
  %1 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then2, label %cleanup

if.then2:                                         ; preds = %if.end
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then2, %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ %call1, %if.then2 ], [ %call1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_touchpad_setup(%struct.platform_device* %pd, i32 %handle) #1 {
entry:
  %call = call i8* @kzalloc(i64 56, i32 208)
  %0 = bitcast i8* %call to %struct.touchpad_control*
  store %struct.touchpad_control* %0, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %1 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %tobool = icmp ne %struct.touchpad_control* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %handle1 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %2, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !222
  %3 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %attr = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %3, i32 0, i32 0
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_touchpad_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !210
  %4 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %attr3 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %4, i32 0, i32 0
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.108, i32 0, i32 0), i8** %name, align 8, !tbaa !224
  %5 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %attr5 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %5, i32 0, i32 0
  %attr6 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr5, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr6, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !225
  %6 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %attr7 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %6, i32 0, i32 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr7, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_touchpad_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !226
  %7 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %attr8 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %7, i32 0, i32 0
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr8, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_touchpad_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !227
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %8 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %attr9 = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %8, i32 0, i32 0
  %call10 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %attr9)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %cleanup

if.then12:                                        ; preds = %if.end
  %9 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %10 = bitcast %struct.touchpad_control* %9 to i8*
  call void @kfree(i8* %10)
  store %struct.touchpad_control* null, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  br label %cleanup

cleanup:                                          ; preds = %if.then12, %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %call10, %if.then12 ], [ %call10, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_battery_care_setup(%struct.platform_device* %pd, i32 %handle) #1 {
entry:
  %call = call i8* @kzalloc(i64 104, i32 208)
  %0 = bitcast i8* %call to %struct.battery_care_control*
  store %struct.battery_care_control* %0, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %1 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %tobool = icmp ne %struct.battery_care_control* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %handle1 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %2, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !228
  %3 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %3, i32 0, i32 0
  %arrayidx = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs, i64 0, i64 0
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_battery_care_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !210
  %4 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs2 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %4, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs2, i64 0, i64 0
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  store i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.109, i32 0, i32 0), i8** %name, align 8, !tbaa !230
  %5 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs5 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %5, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs5, i64 0, i64 0
  %attr7 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx6, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr7, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !231
  %6 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs8 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %6, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs8, i64 0, i64 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx9, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_battery_care_limit_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !232
  %7 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs10 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %7, i32 0, i32 0
  %arrayidx11 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs10, i64 0, i64 0
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx11, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_battery_care_limit_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !233
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %8 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs12 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %8, i32 0, i32 0
  %arrayidx13 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs12, i64 0, i64 0
  %call14 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %arrayidx13)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %outkzalloc, label %if.end17

if.end17:                                         ; preds = %if.end
  %cmp = icmp eq i32 %handle, 277
  br i1 %cmp, label %cleanup, label %do.body20

do.body20:                                        ; preds = %if.end17
  %9 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs21 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %9, i32 0, i32 0
  %arrayidx22 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs21, i64 0, i64 1
  %attr23 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx22, i32 0, i32 0
  %key24 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr23, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_battery_care_setup.__key.110, %struct.lock_class_key** %key24, align 8, !tbaa !210
  %10 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs27 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %10, i32 0, i32 0
  %arrayidx28 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs27, i64 0, i64 1
  %attr29 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx28, i32 0, i32 0
  %name30 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr29, i32 0, i32 0
  store i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.111, i32 0, i32 0), i8** %name30, align 8, !tbaa !230
  %11 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs31 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %11, i32 0, i32 0
  %arrayidx32 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs31, i64 0, i64 1
  %attr33 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx32, i32 0, i32 0
  %mode34 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr33, i32 0, i32 1
  store i16 292, i16* %mode34, align 8, !tbaa !231
  %12 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs35 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %12, i32 0, i32 0
  %arrayidx36 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs35, i64 0, i64 1
  %show37 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx36, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_battery_care_health_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show37, align 8, !tbaa !232
  %dev38 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %13 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs39 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %13, i32 0, i32 0
  %arrayidx40 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs39, i64 0, i64 1
  %call41 = call i32 @device_create_file(%struct.device* %dev38, %struct.device_attribute* %arrayidx40)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %outlimiter, label %cleanup

outlimiter:                                       ; preds = %do.body20
  %dev45 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %14 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs46 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %14, i32 0, i32 0
  %arrayidx47 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs46, i64 0, i64 0
  call void @device_remove_file(%struct.device* %dev45, %struct.device_attribute* %arrayidx47)
  br label %outkzalloc

outkzalloc:                                       ; preds = %outlimiter, %if.end
  %ret.0 = phi i32 [ %call41, %outlimiter ], [ %call14, %if.end ]
  %15 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %16 = bitcast %struct.battery_care_control* %15 to i8*
  call void @kfree(i8* %16)
  store %struct.battery_care_control* null, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  br label %cleanup

cleanup:                                          ; preds = %outkzalloc, %do.body20, %if.end17, %entry
  %retval.0 = phi i32 [ %ret.0, %outkzalloc ], [ -12, %entry ], [ 0, %if.end17 ], [ 0, %do.body20 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_lid_resume_setup(%struct.platform_device* %pd) #1 {
entry:
  %result = alloca i32, align 4
  %call = call i32 @sony_call_snc_handle(i32 281, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i8* @kzalloc(i64 152, i32 208)
  %0 = bitcast i8* %call1 to %struct.snc_lid_resume_control*
  store %struct.snc_lid_resume_control* %0, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %1 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %tobool2 = icmp ne %struct.snc_lid_resume_control* %1, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %2 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %2, 7
  %3 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %status = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %3, i32 0, i32 1
  store i32 %and, i32* %status, align 8, !tbaa !234
  %4 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %4, i32 0, i32 0
  %arrayidx = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs, i64 0, i64 0
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_lid_resume_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !210
  %5 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs5 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %5, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs5, i64 0, i64 0
  %attr7 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx6, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr7, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.112, i32 0, i32 0), i8** %name, align 8, !tbaa !230
  %6 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs8 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %6, i32 0, i32 0
  %arrayidx9 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs8, i64 0, i64 0
  %attr10 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx9, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr10, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !231
  %7 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs11 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %7, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs11, i64 0, i64 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx12, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_lid_resume_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !232
  %8 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs13 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %8, i32 0, i32 0
  %arrayidx14 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs13, i64 0, i64 0
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx14, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_lid_resume_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !233
  %9 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs16 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %9, i32 0, i32 0
  %arrayidx17 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs16, i64 0, i64 1
  %attr18 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx17, i32 0, i32 0
  %key19 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr18, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_lid_resume_setup.__key.113, %struct.lock_class_key** %key19, align 8, !tbaa !210
  %10 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs22 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %10, i32 0, i32 0
  %arrayidx23 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs22, i64 0, i64 1
  %attr24 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx23, i32 0, i32 0
  %name25 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr24, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.114, i32 0, i32 0), i8** %name25, align 8, !tbaa !230
  %11 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs26 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %11, i32 0, i32 0
  %arrayidx27 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs26, i64 0, i64 1
  %attr28 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx27, i32 0, i32 0
  %mode29 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr28, i32 0, i32 1
  store i16 420, i16* %mode29, align 8, !tbaa !231
  %12 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs30 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %12, i32 0, i32 0
  %arrayidx31 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs30, i64 0, i64 1
  %show32 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx31, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_lid_resume_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show32, align 8, !tbaa !232
  %13 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs33 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %13, i32 0, i32 0
  %arrayidx34 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs33, i64 0, i64 1
  %store35 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx34, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_lid_resume_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store35, align 8, !tbaa !233
  %14 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs37 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %14, i32 0, i32 0
  %arrayidx38 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs37, i64 0, i64 2
  %attr39 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx38, i32 0, i32 0
  %key40 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr39, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_lid_resume_setup.__key.115, %struct.lock_class_key** %key40, align 8, !tbaa !210
  %15 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs43 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %15, i32 0, i32 0
  %arrayidx44 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs43, i64 0, i64 2
  %attr45 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx44, i32 0, i32 0
  %name46 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr45, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.116, i32 0, i32 0), i8** %name46, align 8, !tbaa !230
  %16 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs47 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %16, i32 0, i32 0
  %arrayidx48 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs47, i64 0, i64 2
  %attr49 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx48, i32 0, i32 0
  %mode50 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr49, i32 0, i32 1
  store i16 420, i16* %mode50, align 8, !tbaa !231
  %17 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs51 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %17, i32 0, i32 0
  %arrayidx52 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs51, i64 0, i64 2
  %show53 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx52, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_lid_resume_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show53, align 8, !tbaa !232
  %18 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs54 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %18, i32 0, i32 0
  %arrayidx55 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs54, i64 0, i64 2
  %store56 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %arrayidx55, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_lid_resume_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store56, align 8, !tbaa !233
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %i.0 = phi i32 [ 0, %if.end4 ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %19 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs57 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %19, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx58 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs57, i64 0, i64 %idxprom
  %call59 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %arrayidx58)
  store i32 %call59, i32* %result, align 4, !tbaa !12
  %20 = load i32, i32* %result, align 4, !tbaa !12
  %tobool60 = icmp ne i32 %20, 0
  br i1 %tobool60, label %liderror, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

liderror:                                         ; preds = %for.body
  br label %for.cond63

for.cond63:                                       ; preds = %for.body65, %liderror
  %i.1.sink = phi i32 [ %dec71, %for.body65 ], [ %i.0, %liderror ]
  %dec71 = add nsw i32 %i.1.sink, -1
  %cmp64 = icmp sge i32 %dec71, 0
  br i1 %cmp64, label %for.body65, label %for.end72

for.body65:                                       ; preds = %for.cond63
  %dev66 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %21 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs67 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %21, i32 0, i32 0
  %idxprom68 = sext i32 %dec71 to i64
  %arrayidx69 = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs67, i64 0, i64 %idxprom68
  call void @device_remove_file(%struct.device* %dev66, %struct.device_attribute* %arrayidx69)
  br label %for.cond63

for.end72:                                        ; preds = %for.cond63
  %22 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %23 = bitcast %struct.snc_lid_resume_control* %22 to i8*
  call void @kfree(i8* %23)
  store %struct.snc_lid_resume_control* null, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %24 = load i32, i32* %result, align 4, !tbaa !12
  br label %cleanup

cleanup:                                          ; preds = %for.end72, %for.cond, %if.end, %entry
  %retval.0 = phi i32 [ %24, %for.end72 ], [ -5, %entry ], [ -12, %if.end ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_thermal_setup(%struct.platform_device* %pd) #1 {
entry:
  %call = call i8* @kzalloc(i64 104, i32 208)
  %0 = bitcast i8* %call to %struct.snc_thermal_ctrl*
  store %struct.snc_thermal_ctrl* %0, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %1 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %tobool = icmp ne %struct.snc_thermal_ctrl* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %profiles = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %2, i32 0, i32 1
  %call1 = call i32 @sony_call_snc_handle(i32 290, i32 0, i32* %profiles)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  call void (i8*, ...) @printk(i8* null)
  br label %outkzalloc

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @sony_nc_thermal_mode_get()
  %cmp = icmp slt i32 %call6, 0
  br i1 %cmp, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end5
  call void (i8*, ...) @printk(i8* null)
  br label %outkzalloc

if.end9:                                          ; preds = %if.end5
  %3 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %3, i32 0, i32 0
  store i32 %call6, i32* %mode, align 8, !tbaa !236
  %4 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %profiles_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %4, i32 0, i32 3
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_thermal_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !210
  %5 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %profiles_attr10 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %5, i32 0, i32 3
  %attr11 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr10, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr11, i32 0, i32 0
  store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.119, i32 0, i32 0), i8** %name, align 8, !tbaa !238
  %6 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %profiles_attr12 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %6, i32 0, i32 3
  %attr13 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr12, i32 0, i32 0
  %mode14 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr13, i32 0, i32 1
  store i16 292, i16* %mode14, align 8, !tbaa !239
  %7 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %profiles_attr15 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %7, i32 0, i32 3
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %profiles_attr15, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_thermal_profiles_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !240
  %8 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %8, i32 0, i32 2
  %attr17 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr, i32 0, i32 0
  %key18 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr17, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_thermal_setup.__key.120, %struct.lock_class_key** %key18, align 8, !tbaa !210
  %9 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode_attr21 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %9, i32 0, i32 2
  %attr22 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr21, i32 0, i32 0
  %name23 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr22, i32 0, i32 0
  store i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.121, i32 0, i32 0), i8** %name23, align 8, !tbaa !241
  %10 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode_attr24 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %10, i32 0, i32 2
  %attr25 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr24, i32 0, i32 0
  %mode26 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr25, i32 0, i32 1
  store i16 420, i16* %mode26, align 8, !tbaa !242
  %11 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode_attr27 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %11, i32 0, i32 2
  %show28 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr27, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_thermal_mode_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show28, align 8, !tbaa !243
  %12 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode_attr29 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %12, i32 0, i32 2
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr29, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_thermal_mode_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !244
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %13 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %profiles_attr30 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %13, i32 0, i32 3
  %call31 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %profiles_attr30)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %outkzalloc, label %if.end34

if.end34:                                         ; preds = %if.end9
  %dev35 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %14 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode_attr36 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %14, i32 0, i32 2
  %call37 = call i32 @device_create_file(%struct.device* %dev35, %struct.device_attribute* %mode_attr36)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %outprofiles, label %cleanup

outprofiles:                                      ; preds = %if.end34
  %dev41 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %15 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %profiles_attr42 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %15, i32 0, i32 3
  call void @device_remove_file(%struct.device* %dev41, %struct.device_attribute* %profiles_attr42)
  br label %outkzalloc

outkzalloc:                                       ; preds = %outprofiles, %if.end9, %if.then7, %if.then3
  %ret.0 = phi i32 [ %call1, %if.then3 ], [ %call6, %if.then7 ], [ %call37, %outprofiles ], [ %call31, %if.end9 ]
  %16 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %17 = bitcast %struct.snc_thermal_ctrl* %16 to i8*
  call void @kfree(i8* %17)
  store %struct.snc_thermal_ctrl* null, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  br label %cleanup

cleanup:                                          ; preds = %outkzalloc, %if.end34, %entry
  %retval.0 = phi i32 [ %ret.0, %outkzalloc ], [ -12, %entry ], [ 0, %if.end34 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_gfx_switch_setup(%struct.platform_device* %pd, i32 %handle) #1 {
entry:
  %call = call i8* @kzalloc(i64 56, i32 208)
  %0 = bitcast i8* %call to %struct.snc_gfx_switch_control*
  store %struct.snc_gfx_switch_control* %0, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %1 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %tobool = icmp ne %struct.snc_gfx_switch_control* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %handle1 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %2, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !245
  %3 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %attr = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %3, i32 0, i32 0
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_gfx_switch_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !210
  %4 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %attr3 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %4, i32 0, i32 0
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr3, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.127, i32 0, i32 0), i8** %name, align 8, !tbaa !247
  %5 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %attr5 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %5, i32 0, i32 0
  %attr6 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr5, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr6, i32 0, i32 1
  store i16 292, i16* %mode, align 8, !tbaa !248
  %6 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %attr7 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %6, i32 0, i32 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr7, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_gfx_switch_status_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !249
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %7 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %attr8 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %7, i32 0, i32 0
  %call9 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %attr8)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %gfxerror, label %cleanup

gfxerror:                                         ; preds = %if.end
  %8 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %9 = bitcast %struct.snc_gfx_switch_control* %8 to i8*
  call void @kfree(i8* %9)
  store %struct.snc_gfx_switch_control* null, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  br label %cleanup

cleanup:                                          ; preds = %gfxerror, %if.end, %entry
  %retval.0 = phi i32 [ %call9, %gfxerror ], [ -12, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_highspeed_charging_setup(%struct.platform_device* %pd) #1 {
entry:
  %result = alloca i32, align 4
  %call = call i32 @sony_call_snc_handle(i32 305, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %0, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %call3 = call i8* @kzalloc(i64 48, i32 208)
  %1 = bitcast i8* %call3 to %struct.device_attribute*
  store %struct.device_attribute* %1, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %2 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %tobool4 = icmp ne %struct.device_attribute* %2, null
  br i1 %tobool4, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %3 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %3, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_highspeed_charging_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !210
  %4 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %attr7 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %4, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr7, i32 0, i32 0
  store i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.132, i32 0, i32 0), i8** %name, align 8, !tbaa !230
  %5 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %attr8 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %5, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr8, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !231
  %6 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %6, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_highspeed_charging_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !232
  %7 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %7, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_highspeed_charging_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !233
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %8 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %call9 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %8)
  store i32 %call9, i32* %result, align 4, !tbaa !12
  %9 = load i32, i32* %result, align 4, !tbaa !12
  %tobool10 = icmp ne i32 %9, 0
  br i1 %tobool10, label %if.then11, label %cleanup

if.then11:                                        ; preds = %do.body
  %10 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %11 = bitcast %struct.device_attribute* %10 to i8*
  call void @kfree(i8* %11)
  store %struct.device_attribute* null, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %12 = load i32, i32* %result, align 4, !tbaa !12
  br label %cleanup

cleanup:                                          ; preds = %if.then11, %do.body, %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %12, %if.then11 ], [ -12, %if.end ], [ 0, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_rfkill_setup(%struct.acpi_device* %device, i32 %handle) #1 {
entry:
  %offset = alloca i64, align 8
  %buffer = alloca [32 x i8], align 16
  %0 = bitcast [32 x i8]* %buffer to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 32, i32 16, i1 false)
  %call = call i32 @sony_find_snc_handle(i32 %handle)
  %conv = sext i32 %call to i64
  store i64 %conv, i64* %offset, align 8, !tbaa !194
  store i32 %handle, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %1 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i32 0, i32 0
  %call1 = call i32 @sony_nc_buffer_call(i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.133, i32 0, i32 0), i64* %offset, i8* %arraydecay, i64 32)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv3 = sext i32 %i.0 to i64
  %cmp4 = icmp ult i64 %conv3, 32
  br i1 %cmp4, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !41
  %conv6 = zext i8 %2 to i32
  %cmp7 = icmp eq i32 %conv6, 255
  br i1 %cmp7, label %cleanup, label %do.body

do.body:                                          ; preds = %for.body
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %idxprom17 = sext i32 %i.0 to i64
  %arrayidx18 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom17
  %4 = load i8, i8* %arrayidx18, align 1, !tbaa !41
  %conv19 = zext i8 %4 to i32
  %cmp20 = icmp ne i32 %conv19, 0
  %5 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 0), align 16
  %tobool22 = icmp ne %struct.rfkill* %5, null
  %or.cond = or i1 %cmp20, %tobool22
  br i1 %or.cond, label %if.end25, label %if.then23

if.then23:                                        ; preds = %do.end
  call void @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 0)
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %do.end
  %idxprom26 = sext i32 %i.0 to i64
  %arrayidx27 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom26
  %6 = load i8, i8* %arrayidx27, align 1, !tbaa !41
  %conv28 = zext i8 %6 to i32
  %cmp29 = icmp ne i32 %conv28, 16
  %7 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 1), align 8
  %tobool32 = icmp ne %struct.rfkill* %7, null
  %or.cond1 = or i1 %cmp29, %tobool32
  br i1 %or.cond1, label %if.end35, label %if.then33

if.then33:                                        ; preds = %if.end25
  call void @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 1)
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.end25
  %idxprom36 = sext i32 %i.0 to i64
  %arrayidx37 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom36
  %8 = load i8, i8* %arrayidx37, align 1, !tbaa !41
  %conv38 = zext i8 %8 to i32
  %and = and i32 240, %conv38
  %cmp39 = icmp eq i32 %and, 32
  br i1 %cmp39, label %land.lhs.true47, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end35
  %idxprom41 = sext i32 %i.0 to i64
  %arrayidx42 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom41
  %9 = load i8, i8* %arrayidx42, align 1, !tbaa !41
  %conv43 = zext i8 %9 to i32
  %and44 = and i32 240, %conv43
  %cmp45 = icmp ne i32 %and44, 80
  %10 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 2), align 16
  %tobool48 = icmp ne %struct.rfkill* %10, null
  %or.cond2 = or i1 %cmp45, %tobool48
  br i1 %or.cond2, label %if.end51, label %if.then49

land.lhs.true47:                                  ; preds = %if.end35
  %.old = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 2), align 16, !tbaa !37
  %tobool48.old = icmp ne %struct.rfkill* %.old, null
  br i1 %tobool48.old, label %if.end51, label %if.then49

if.then49:                                        ; preds = %land.lhs.true47, %lor.lhs.false
  call void @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 2)
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %land.lhs.true47, %lor.lhs.false
  %idxprom52 = sext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom52
  %11 = load i8, i8* %arrayidx53, align 1, !tbaa !41
  %conv54 = zext i8 %11 to i32
  %cmp55 = icmp ne i32 %conv54, 48
  %12 = load %struct.rfkill*, %struct.rfkill** getelementptr inbounds ([4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 3), align 8
  %tobool58 = icmp ne %struct.rfkill* %12, null
  %or.cond4 = or i1 %cmp55, %tobool58
  br i1 %or.cond4, label %for.inc, label %if.then59

if.then59:                                        ; preds = %if.end51
  call void @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 3)
  br label %for.inc

for.inc:                                          ; preds = %if.then59, %if.end51
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond, %entry
  %retval.0 = phi i32 [ %call1, %entry ], [ 0, %for.cond ], [ 0, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_kbd_backlight_setup(%struct.platform_device* %pd, i32 %handle) #1 {
entry:
  %result = alloca i32, align 4
  %cmp = icmp eq i32 %handle, 311
  %cond = select i1 %cmp, i32 2816, i32 256
  %call = call i32 @sony_call_snc_handle(i32 %handle, i32 %cond, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq i32 %handle, 311
  br i1 %cmp1, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end
  %0 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %0, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %lor.lhs.false, label %do.body

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end
  %1 = load i32, i32* %result, align 4, !tbaa !12
  %and3 = and i32 %1, 1
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.end10, label %do.body

do.body:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %2 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool6 = icmp ne i32 %2, 0
  br i1 %tobool6, label %if.then7, label %cleanup

if.then7:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end10:                                         ; preds = %lor.lhs.false
  %call11 = call i8* @kzalloc(i64 112, i32 208)
  %3 = bitcast i8* %call11 to %struct.kbd_backlight*
  store %struct.kbd_backlight* %3, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %4 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %tobool12 = icmp ne %struct.kbd_backlight* %4, null
  br i1 %tobool12, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end10
  %5 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %handle15 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %5, i32 0, i32 0
  store i32 %handle, i32* %handle15, align 8, !tbaa !250
  %cmp16 = icmp eq i32 %handle, 311
  %6 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %6, i32 0, i32 1
  %.sink = select i1 %cmp16, i32 3072, i32 16384
  store i32 %.sink, i32* %base, align 4, !tbaa !252
  %7 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %7, i32 0, i32 4
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_kbd_backlight_setup.__key, %struct.lock_class_key** %key, align 8, !tbaa !210
  %8 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode_attr23 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %8, i32 0, i32 4
  %attr24 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr23, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr24, i32 0, i32 0
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.140, i32 0, i32 0), i8** %name, align 8, !tbaa !253
  %9 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode_attr25 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %9, i32 0, i32 4
  %attr26 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr25, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr26, i32 0, i32 1
  store i16 420, i16* %mode, align 8, !tbaa !254
  %10 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode_attr27 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %10, i32 0, i32 4
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr27, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_kbd_backlight_mode_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !255
  %11 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode_attr28 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %11, i32 0, i32 4
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %mode_attr28, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_kbd_backlight_mode_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !256
  %12 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %12, i32 0, i32 5
  %attr30 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr, i32 0, i32 0
  %key31 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr30, i32 0, i32 3
  store %struct.lock_class_key* @sony_nc_kbd_backlight_setup.__key.141, %struct.lock_class_key** %key31, align 8, !tbaa !210
  %13 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout_attr34 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %13, i32 0, i32 5
  %attr35 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr34, i32 0, i32 0
  %name36 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr35, i32 0, i32 0
  store i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.142, i32 0, i32 0), i8** %name36, align 8, !tbaa !257
  %14 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout_attr37 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %14, i32 0, i32 5
  %attr38 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr37, i32 0, i32 0
  %mode39 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr38, i32 0, i32 1
  store i16 420, i16* %mode39, align 8, !tbaa !258
  %15 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout_attr40 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %15, i32 0, i32 5
  %show41 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr40, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* @sony_nc_kbd_backlight_timeout_show, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show41, align 8, !tbaa !259
  %16 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout_attr42 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %16, i32 0, i32 5
  %store43 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %timeout_attr42, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @sony_nc_kbd_backlight_timeout_store, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store43, align 8, !tbaa !260
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %17 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode_attr44 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %17, i32 0, i32 4
  %call45 = call i32 @device_create_file(%struct.device* %dev, %struct.device_attribute* %mode_attr44)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %outkzalloc, label %if.end48

if.end48:                                         ; preds = %if.end14
  %dev49 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %18 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout_attr50 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %18, i32 0, i32 5
  %call51 = call i32 @device_create_file(%struct.device* %dev49, %struct.device_attribute* %timeout_attr50)
  %tobool52 = icmp ne i32 %call51, 0
  br i1 %tobool52, label %outmode, label %if.end54

if.end54:                                         ; preds = %if.end48
  %19 = load i32, i32* @kbd_backlight, align 4, !tbaa !12
  %conv = trunc i32 %19 to i8
  %call55 = call i64 @__sony_nc_kbd_backlight_mode_set(i8 zeroext %conv)
  %20 = load i32, i32* @kbd_backlight_timeout, align 4, !tbaa !12
  %conv56 = trunc i32 %20 to i8
  %call57 = call i32 @__sony_nc_kbd_backlight_timeout_set(i8 zeroext %conv56)
  br label %cleanup

outmode:                                          ; preds = %if.end48
  %dev58 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %21 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode_attr59 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %21, i32 0, i32 4
  call void @device_remove_file(%struct.device* %dev58, %struct.device_attribute* %mode_attr59)
  br label %outkzalloc

outkzalloc:                                       ; preds = %outmode, %if.end14
  %ret.0 = phi i32 [ %call51, %outmode ], [ %call45, %if.end14 ]
  %22 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %23 = bitcast %struct.kbd_backlight* %22 to i8*
  call void @kfree(i8* %23)
  store %struct.kbd_backlight* null, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  br label %cleanup

cleanup:                                          ; preds = %outkzalloc, %if.end54, %if.end10, %if.then7, %do.body, %entry
  %retval.0 = phi i32 [ %ret.0, %outkzalloc ], [ 0, %if.end54 ], [ %call, %entry ], [ 0, %if.then7 ], [ 0, %do.body ], [ -12, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_find_snc_handle(i32 %handle) #1 {
entry:
  %0 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %tobool = icmp ne %struct.sony_nc_handles* %0, null
  %tobool1 = icmp ne i32 %handle, 0
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %for.body, label %do.body9

for.body:                                         ; preds = %for.cond
  %1 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %1, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %2 = load i16, i16* %arrayidx, align 2, !tbaa !195
  %conv = zext i16 %2 to i32
  %cmp2 = icmp eq i32 %conv, %handle
  br i1 %cmp2, label %do.body, label %for.inc

do.body:                                          ; preds = %for.body
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool5 = icmp ne i32 %3, 0
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

do.body9:                                         ; preds = %for.cond
  %4 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool10 = icmp ne i32 %4, 0
  br i1 %tobool10, label %if.then11, label %cleanup

if.then11:                                        ; preds = %do.body9
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then11, %do.body9, %if.then6, %do.body, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ %i.0, %if.then6 ], [ %i.0, %do.body ], [ -22, %if.then11 ], [ -22, %do.body9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_touchpad_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %result = alloca i32, align 4
  %0 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %0, i32 0, i32 1
  %1 = load i32, i32* %handle, align 8, !tbaa !222
  %call = call i32 @sony_call_snc_handle(i32 %1, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %2, 1
  %tobool1 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot.ext = zext i1 %lnot to i32
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %lnot.ext)
  %conv = sext i32 %call2 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -22, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_touchpad_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %0 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %0, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %1 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %1, i32 0, i32 1
  %2 = load i32, i32* %handle, align 8, !tbaa !222
  %3 = load i64, i64* %value, align 8, !tbaa !101
  %tobool4 = icmp ne i64 %3, 0
  %lnot = xor i1 %tobool4, true
  %lnot.ext = zext i1 %lnot to i32
  %shl = shl i32 %lnot.ext, 16
  %or = or i32 %shl, 256
  %call5 = call i32 @sony_call_snc_handle(i32 %2, i32 %or, i32* %result)
  %tobool6 = icmp ne i32 %call5, 0
  %.count = select i1 %tobool6, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end3 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_battery_care_limit_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %result = alloca i32, align 4
  %0 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %0, i32 0, i32 1
  %1 = load i32, i32* %handle, align 8, !tbaa !228
  %call = call i32 @sony_call_snc_handle(i32 %1, i32 0, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %2, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %cond.true, label %NodeBlock3

cond.true:                                        ; preds = %if.end
  %3 = load i32, i32* %result, align 4, !tbaa !12
  %and2 = and i32 %3, 48
  %shr = lshr i32 %and2, 4
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %cond.true, %if.end
  %cond = phi i32 [ %shr, %cond.true ], [ 0, %if.end ]
  %Pivot4 = icmp slt i32 %cond, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cond, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cond, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cond, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1, %NodeBlock
  %status.0 = phi i32 [ 0, %sw.default ], [ 80, %LeafBlock ], [ 50, %NodeBlock ], [ 100, %LeafBlock1 ]
  %call5 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %status.0)
  %conv = sext i32 %call5 to i64
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %entry
  %retval.0 = phi i64 [ %conv, %sw.epilog ], [ -5, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_battery_care_limit_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %0 = load i64, i64* %value, align 8, !tbaa !101
  %cmp3 = icmp ugt i64 %0, 0
  br i1 %cmp3, label %if.then4, label %if.end21

if.then4:                                         ; preds = %if.end2
  %1 = load i64, i64* %value, align 8, !tbaa !101
  %cmp5 = icmp ule i64 %1, 50
  br i1 %cmp5, label %if.end15, label %if.else

if.else:                                          ; preds = %if.then4
  %2 = load i64, i64* %value, align 8, !tbaa !101
  %cmp7 = icmp ule i64 %2, 80
  br i1 %cmp7, label %if.end15, label %if.else9

if.else9:                                         ; preds = %if.else
  %3 = load i64, i64* %value, align 8, !tbaa !101
  %cmp10 = icmp ule i64 %3, 100
  br i1 %cmp10, label %if.end15, label %cleanup

if.end15:                                         ; preds = %if.else9, %if.else, %if.then4
  %cmd.1 = phi i32 [ 32, %if.then4 ], [ 16, %if.else ], [ 48, %if.else9 ]
  %4 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %4, i32 0, i32 1
  %5 = load i32, i32* %handle, align 8, !tbaa !228
  %cmp16 = icmp ne i32 %5, 319
  %shl = shl i32 %cmd.1, 2
  %or = or i32 %cmd.1, %shl
  %cmd.2 = select i1 %cmp16, i32 %or, i32 %cmd.1
  %or19 = or i32 %cmd.2, 1
  %shl20 = shl i32 %or19, 16
  br label %if.end21

if.end21:                                         ; preds = %if.end15, %if.end2
  %cmd.3 = phi i32 [ %shl20, %if.end15 ], [ 0, %if.end2 ]
  %6 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %handle22 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %6, i32 0, i32 1
  %7 = load i32, i32* %handle22, align 8, !tbaa !228
  %or23 = or i32 %cmd.3, 256
  %call24 = call i32 @sony_call_snc_handle(i32 %7, i32 %or23, i32* %result)
  %tobool25 = icmp ne i32 %call24, 0
  %.count = select i1 %tobool25, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %if.else9, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ -22, %if.else9 ], [ %.count, %if.end21 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_battery_care_health_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %health = alloca i32, align 4
  %0 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %0, i32 0, i32 1
  %1 = load i32, i32* %handle, align 8, !tbaa !228
  %call = call i32 @sony_call_snc_handle(i32 %1, i32 512, i32* %health)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %health, align 4, !tbaa !12
  %and = and i32 %2, 255
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_lid_resume_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %attr1 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr1, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !230
  %call = call i32 @strcmp(i8* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.112, i32 0, i32 0))
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.end15, label %if.else

if.else:                                          ; preds = %entry
  %attr2 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name3 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr2, i32 0, i32 0
  %1 = load i8*, i8** %name3, align 8, !tbaa !230
  %call4 = call i32 @strcmp(i8* %1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.114, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %if.end15, label %if.else7

if.else7:                                         ; preds = %if.else
  %attr8 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name9 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr8, i32 0, i32 0
  %2 = load i8*, i8** %name9, align 8, !tbaa !230
  %call10 = call i32 @strcmp(i8* %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.116, i32 0, i32 0))
  %cmp11 = icmp eq i32 %call10, 0
  br i1 %cmp11, label %if.end15, label %cleanup

if.end15:                                         ; preds = %if.else7, %if.else, %entry
  %pos.1 = phi i32 [ 2, %entry ], [ 1, %if.else ], [ 0, %if.else7 ]
  %3 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %status = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %3, i32 0, i32 1
  %4 = load i32, i32* %status, align 8, !tbaa !234
  %shr = lshr i32 %4, %pos.1
  %and = and i32 %shr, 1
  %call16 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call16 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.else7
  %retval.0 = phi i64 [ %conv, %if.end15 ], [ -22, %if.else7 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_lid_resume_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %0 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %0, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %attr4 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name = getelementptr inbounds %struct.attribute, %struct.attribute* %attr4, i32 0, i32 0
  %1 = load i8*, i8** %name, align 8, !tbaa !230
  %call5 = call i32 @strcmp(i8* %1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.112, i32 0, i32 0))
  %cmp6 = icmp eq i32 %call5, 0
  br i1 %cmp6, label %if.end22, label %if.else

if.else:                                          ; preds = %if.end3
  %attr8 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name9 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr8, i32 0, i32 0
  %2 = load i8*, i8** %name9, align 8, !tbaa !230
  %call10 = call i32 @strcmp(i8* %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.114, i32 0, i32 0))
  %cmp11 = icmp eq i32 %call10, 0
  br i1 %cmp11, label %if.end22, label %if.else13

if.else13:                                        ; preds = %if.else
  %attr14 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %attr, i32 0, i32 0
  %name15 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr14, i32 0, i32 0
  %3 = load i8*, i8** %name15, align 8, !tbaa !230
  %call16 = call i32 @strcmp(i8* %3, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.116, i32 0, i32 0))
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.end22, label %cleanup

if.end22:                                         ; preds = %if.else13, %if.else, %if.end3
  %pos.1 = phi i32 [ 2, %if.end3 ], [ 1, %if.else ], [ 0, %if.else13 ]
  %4 = load i64, i64* %value, align 8, !tbaa !101
  %tobool23 = icmp ne i64 %4, 0
  %5 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %status = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %5, i32 0, i32 1
  %6 = load i32, i32* %status, align 8, !tbaa !234
  %shl = shl i32 1, %pos.1
  br i1 %tobool23, label %if.then24, label %if.else25

if.then24:                                        ; preds = %if.end22
  %or = or i32 %6, %shl
  %conv = zext i32 %or to i64
  store i64 %conv, i64* %value, align 8, !tbaa !101
  br label %if.end29

if.else25:                                        ; preds = %if.end22
  %neg = xor i32 %shl, -1
  %and = and i32 %6, %neg
  %conv28 = zext i32 %and to i64
  store i64 %conv28, i64* %value, align 8, !tbaa !101
  br label %if.end29

if.end29:                                         ; preds = %if.else25, %if.then24
  %7 = load i64, i64* %value, align 8, !tbaa !101
  %shl30 = shl i64 %7, 16
  %or31 = or i64 %shl30, 256
  %conv32 = trunc i64 %or31 to i32
  %call33 = call i32 @sony_call_snc_handle(i32 281, i32 %conv32, i32* %result)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %cleanup, label %if.end36

if.end36:                                         ; preds = %if.end29
  %8 = load i64, i64* %value, align 8, !tbaa !101
  %conv37 = trunc i64 %8 to i32
  %9 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %status38 = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %9, i32 0, i32 1
  store i32 %conv37, i32* %status38, align 8, !tbaa !234
  br label %cleanup

cleanup:                                          ; preds = %if.end36, %if.end29, %if.else13, %if.end, %entry
  %retval.0 = phi i64 [ %count, %if.end36 ], [ -22, %entry ], [ -22, %if.end ], [ -22, %if.else13 ], [ -5, %if.end29 ]
  ret i64 %retval.0
}

declare i32 @strcmp(i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_thermal_mode_get() #1 {
entry:
  %result = alloca i32, align 4
  %call = call i32 @sony_call_snc_handle(i32 290, i32 256, i32* %result)
  %tobool = icmp ne i32 %call, 0
  %0 = load i32, i32* %result, align 4
  %and = and i32 %0, 255
  %retval.0 = select i1 %tobool, i32 -5, i32 %and
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_thermal_profiles_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %cnt.0 = phi i16 [ 0, %entry ], [ %inc, %for.inc ]
  %idx.0 = phi i64 [ 0, %entry ], [ %idx.1, %for.inc ]
  %conv = sext i16 %cnt.0 to i32
  %cmp = icmp slt i32 %conv, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %tobool = icmp ne i16 %cnt.0, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %for.body
  %0 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %profiles = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %0, i32 0, i32 1
  %1 = load i32, i32* %profiles, align 4, !tbaa !261
  %conv2 = sext i16 %cnt.0 to i32
  %and = and i32 %1, %conv2
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then, label %for.inc

if.then:                                          ; preds = %lor.lhs.false, %for.body
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 %idx.0
  %sub = sub i64 4096, %idx.0
  %idxprom = sext i16 %cnt.0 to i64
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @snc_thermal_profiles, i64 0, i64 %idxprom
  %2 = load i8*, i8** %arrayidx, align 8, !tbaa !37
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr, i64 %sub, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.122, i32 0, i32 0), i8* %2)
  %conv4 = sext i32 %call to i64
  %add = add i64 %idx.0, %conv4
  br label %for.inc

for.inc:                                          ; preds = %if.then, %lor.lhs.false
  %idx.1 = phi i64 [ %add, %if.then ], [ %idx.0, %lor.lhs.false ]
  %inc = add i16 %cnt.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %add.ptr5 = getelementptr inbounds i8, i8* %buffer, i64 %idx.0
  %sub6 = sub i64 4096, %idx.0
  %call7 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %add.ptr5, i64 %sub6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.93, i32 0, i32 0))
  %conv8 = sext i32 %call7 to i64
  %add9 = add i64 %idx.0, %conv8
  ret i64 %add9
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_thermal_mode_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %call = call i32 @sony_nc_thermal_mode_get()
  %cmp = icmp slt i32 %call, 0
  %conv = sext i32 %call to i64
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @snc_thermal_profiles, i64 0, i64 %conv
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !37
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i32 0, i32 0), i8* %0)
  %conv2 = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv2, %if.end ], [ %conv, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_thermal_mode_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %cmp = icmp eq i64 %count, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %sub = sub i64 %count, 1
  %arrayidx = getelementptr inbounds i8, i8* %buffer, i64 %sub
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !41
  %conv = sext i8 %0 to i32
  %cmp1 = icmp eq i32 %conv, 10
  %dec = add i64 %count, -1
  %dec.count = select i1 %cmp1, i64 %dec, i64 %count
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %cmd.0 = phi i16 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv5 = zext i16 %cmd.0 to i32
  %cmp6 = icmp slt i32 %conv5, 3
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i16 %cmd.0 to i64
  %arrayidx8 = getelementptr inbounds [3 x i8*], [3 x i8*]* @snc_thermal_profiles, i64 0, i64 %idxprom
  %1 = load i8*, i8** %arrayidx8, align 8, !tbaa !37
  %call = call i32 @strncmp(i8* %buffer, i8* %1, i64 %dec.count)
  %cmp9 = icmp eq i32 %call, 0
  br i1 %cmp9, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add i16 %cmd.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %call13 = call i32 @sony_nc_thermal_mode_set(i16 zeroext %cmd.0)
  %tobool = icmp ne i32 %call13, 0
  %.count = select i1 %tobool, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ %.count, %for.end ]
  ret i64 %retval.0
}

declare i32 @strncmp(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_thermal_mode_set(i16 zeroext %mode) #1 {
entry:
  %result = alloca i32, align 4
  %conv = zext i16 %mode to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %0 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %profiles = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %0, i32 0, i32 1
  %1 = load i32, i32* %profiles, align 4, !tbaa !261
  %conv1 = zext i16 %mode to i32
  %and = and i32 %1, %conv1
  %tobool2 = icmp eq i32 %and, 0
  %conv3 = zext i16 %mode to i32
  %cmp = icmp sge i32 %conv3, 3
  %or.cond = or i1 %tobool2, %cmp
  br i1 %or.cond, label %cleanup, label %if.end

lor.lhs.false:                                    ; preds = %entry
  %.old = zext i16 %mode to i32
  %cmp.old = icmp sge i32 %.old, 3
  br i1 %cmp.old, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %conv5 = zext i16 %mode to i32
  %shl = shl i32 %conv5, 16
  %or = or i32 %shl, 512
  %call = call i32 @sony_call_snc_handle(i32 290, i32 %or, i32* %result)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end
  %conv9 = zext i16 %mode to i32
  %2 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode10 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %2, i32 0, i32 0
  store i32 %conv9, i32* %mode10, align 8, !tbaa !236
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end, %lor.lhs.false, %land.lhs.true
  %retval.0 = phi i32 [ 0, %if.end8 ], [ -22, %land.lhs.true ], [ -22, %lor.lhs.false ], [ -5, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_gfx_switch_status_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %call = call i32 @__sony_nc_gfx_switch_status_get()
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %tobool = icmp ne i32 %call, 0
  %cond = select i1 %tobool, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.128, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.129, i32 0, i32 0)
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i32 0, i32 0), i8* %cond)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %call1.sink = phi i32 [ %call1, %if.end ], [ %call, %entry ]
  %conv2 = sext i32 %call1.sink to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i32 @__sony_nc_gfx_switch_status_get() #1 {
entry:
  %result = alloca i32, align 4
  %0 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %0, i32 0, i32 1
  %1 = load i32, i32* %handle, align 8, !tbaa !245
  %2 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %handle1 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %2, i32 0, i32 1
  %3 = load i32, i32* %handle1, align 8, !tbaa !245
  %cmp = icmp eq i32 %3, 347
  %cond = select i1 %cmp, i32 0, i32 256
  %call = call i32 @sony_call_snc_handle(i32 %1, i32 %cond, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %4 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %handle2 = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %4, i32 0, i32 1
  %5 = load i32, i32* %handle2, align 8, !tbaa !245
  %Pivot6 = icmp slt i32 %5, 326
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %5, 347
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %5, 347
  br i1 %SwitchLeaf4, label %sw.bb5, label %cleanup

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %5, 326
  br i1 %SwitchLeaf2, label %sw.bb, label %cleanup

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %5, 296
  br i1 %SwitchLeaf, label %do.body, label %cleanup

sw.bb:                                            ; preds = %LeafBlock1
  %6 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %6, 1
  %tobool3 = icmp ne i32 %and, 0
  %cond4 = select i1 %tobool3, i32 0, i32 1
  br label %cleanup

sw.bb5:                                           ; preds = %LeafBlock3
  %7 = load i32, i32* %result, align 4, !tbaa !12
  %and6 = and i32 %7, 1
  %tobool7 = icmp ne i32 %and6, 0
  %cond8 = select i1 %tobool7, i32 1, i32 0
  br label %cleanup

do.body:                                          ; preds = %LeafBlock
  %8 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool10 = icmp ne i32 %8, 0
  br i1 %tobool10, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %9 = load i32, i32* %result, align 4, !tbaa !12
  %and14 = and i32 %9, 128
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %cleanup, label %cond.false

cond.false:                                       ; preds = %do.end
  %10 = load i32, i32* %result, align 4, !tbaa !12
  %and16 = and i32 %10, 2
  %tobool17 = icmp ne i32 %and16, 0
  %cond18 = select i1 %tobool17, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %cond.false, %do.end, %sw.bb5, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %entry
  %retval.0 = phi i32 [ %cond4, %sw.bb ], [ %cond8, %sw.bb5 ], [ -5, %entry ], [ %cond18, %cond.false ], [ 2, %do.end ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock3 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_highspeed_charging_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %result = alloca i32, align 4
  %call = call i32 @sony_call_snc_handle(i32 305, i32 256, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %0, 1
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %and)
  %conv = sext i32 %call1 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -5, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_highspeed_charging_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %result = alloca i32, align 4
  %value = alloca i64, align 8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  %0 = load i64, i64* %value, align 8
  %cmp1 = icmp ugt i64 %0, 1
  %or.cond = or i1 %tobool, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %1 = load i64, i64* %value, align 8, !tbaa !101
  %shl = shl i64 %1, 16
  %or = or i64 %shl, 512
  %conv = trunc i64 %or to i32
  %call4 = call i32 @sony_call_snc_handle(i32 305, i32 %conv, i32* %result)
  %tobool5 = icmp ne i32 %call4, 0
  %.count = select i1 %tobool5, i64 -5, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %.count, %if.end3 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_buffer_call(i8* %handle, i8* %name, i64* %value, i8* %buffer, i64 %buflen) #1 {
entry:
  %call = call %union.acpi_object* @__call_snc_method(i8* %handle, i8* %name, i64* %value)
  %tobool = icmp ne %union.acpi_object* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %type = bitcast %union.acpi_object* %call to i32*
  %0 = load i32, i32* %type, align 8, !tbaa !41
  %cmp = icmp eq i32 %0, 3
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %buffer2 = bitcast %union.acpi_object* %call to %struct.anon.49*
  %length = getelementptr inbounds %struct.anon.49, %struct.anon.49* %buffer2, i32 0, i32 1
  %1 = load i32, i32* %length, align 4, !tbaa !41
  %conv = zext i32 %1 to i64
  %cmp3 = icmp ugt i64 %buflen, %conv
  br i1 %cmp3, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then1
  %buffer5 = bitcast %union.acpi_object* %call to %struct.anon.49*
  %length6 = getelementptr inbounds %struct.anon.49, %struct.anon.49* %buffer5, i32 0, i32 1
  %2 = load i32, i32* %length6, align 4, !tbaa !41
  %conv7 = zext i32 %2 to i64
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.then1
  %cond = phi i64 [ %conv7, %cond.true ], [ %buflen, %if.then1 ]
  %buffer8 = bitcast %union.acpi_object* %call to %struct.anon.49*
  %pointer = getelementptr inbounds %struct.anon.49, %struct.anon.49* %buffer8, i32 0, i32 2
  %3 = load i8*, i8** %pointer, align 8, !tbaa !41
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %buffer, i8* %3, i64 %cond, i32 1, i1 false)
  br label %if.end27

if.else:                                          ; preds = %if.end
  %type9 = bitcast %union.acpi_object* %call to i32*
  %4 = load i32, i32* %type9, align 8, !tbaa !41
  %cmp10 = icmp eq i32 %4, 1
  br i1 %cmp10, label %if.then12, label %if.else23

if.then12:                                        ; preds = %if.else
  %cmp13 = icmp ugt i64 %buflen, 8
  %.buflen = select i1 %cmp13, i64 8, i64 %buflen
  %integer = bitcast %union.acpi_object* %call to %struct.anon.47*
  %value21 = getelementptr inbounds %struct.anon.47, %struct.anon.47* %integer, i32 0, i32 1
  %5 = bitcast i64* %value21 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %buffer, i8* %5, i64 %.buflen, i32 1, i1 false)
  br label %if.end27

if.else23:                                        ; preds = %if.else
  call void (i8*, ...) @printk(i8* null)
  br label %if.end27

if.end27:                                         ; preds = %if.else23, %if.then12, %cond.end
  %ret.1 = phi i32 [ 0, %cond.end ], [ 0, %if.then12 ], [ -22, %if.else23 ]
  %6 = bitcast %union.acpi_object* %call to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %if.end27, %entry
  %retval.0 = phi i32 [ %ret.1, %if.end27 ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_setup_rfkill(%struct.acpi_device* %device, i32 %nc_type) #1 {
entry:
  %result = alloca i32, align 4
  %Pivot6 = icmp slt i32 %nc_type, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %nc_type, 3
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %nc_type, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %cleanup

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %nc_type, 1
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %nc_type, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3
  %type.0 = phi i32 [ 1, %LeafBlock ], [ 2, %NodeBlock ], [ 5, %NodeBlock3 ], [ 4, %LeafBlock1 ]
  %name.0 = phi i8* [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.135, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([15 x i8], [15 x i8]* @.str.136, i32 0, i32 0), %NodeBlock ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.137, i32 0, i32 0), %NodeBlock3 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.138, i32 0, i32 0), %LeafBlock1 ]
  %dev = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %device, i32 0, i32 16
  %conv = zext i32 %nc_type to i64
  %0 = inttoptr i64 %conv to i8*
  %call = call %struct.rfkill* @rfkill_alloc(i8* %name.0, %struct.device* %dev, i32 %type.0, %struct.rfkill_ops* @sony_rfkill_ops, i8* %0)
  %tobool = icmp ne %struct.rfkill* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %sw.epilog
  %1 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %call4 = call i32 @sony_call_snc_handle(i32 %1, i32 512, i32* %result)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  call void @rfkill_destroy(%struct.rfkill* %call)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %2 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %2, 1
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %frombool = zext i1 %lnot to i8
  %3 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %idxprom = zext i32 %nc_type to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @sony_rfkill_address, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %call9 = call i32 @sony_call_snc_handle(i32 %3, i32 %4, i32* %result)
  %cmp10 = icmp slt i32 %call9, 0
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end7
  call void @rfkill_destroy(%struct.rfkill* %call)
  br label %cleanup

if.end13:                                         ; preds = %if.end7
  %5 = load i32, i32* %result, align 4, !tbaa !12
  %and14 = and i32 %5, 2
  %tobool15 = icmp ne i32 %and14, 0
  %lnot16 = xor i1 %tobool15, true
  %frombool17 = zext i1 %lnot16 to i8
  %tobool18 = trunc i8 %frombool17 to i1
  call void @rfkill_init_sw_state(%struct.rfkill* %call, i1 zeroext %tobool18)
  %tobool19 = trunc i8 %frombool to i1
  %call20 = call zeroext i1 @rfkill_set_hw_state(%struct.rfkill* %call, i1 zeroext %tobool19)
  %call21 = call i32 @rfkill_register(%struct.rfkill* %call)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end13
  call void @rfkill_destroy(%struct.rfkill* %call)
  br label %cleanup

if.end24:                                         ; preds = %if.end13
  %idxprom25 = zext i32 %nc_type to i64
  %arrayidx26 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom25
  store %struct.rfkill* %call, %struct.rfkill** %arrayidx26, align 8, !tbaa !37
  br label %cleanup

cleanup:                                          ; preds = %if.end24, %if.then23, %if.then12, %if.then6, %sw.epilog, %LeafBlock, %LeafBlock1
  ret void
}

declare %struct.rfkill* @rfkill_alloc(i8*, %struct.device*, i32, %struct.rfkill_ops*, i8*) #2

declare void @rfkill_destroy(%struct.rfkill*) #2

declare void @rfkill_init_sw_state(%struct.rfkill*, i1 zeroext) #2

declare zeroext i1 @rfkill_set_hw_state(%struct.rfkill*, i1 zeroext) #2

declare i32 @rfkill_register(%struct.rfkill*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_rfkill_set(i8* %data, i1 zeroext %blocked) #1 {
entry:
  %result = alloca i32, align 4
  %frombool = zext i1 %blocked to i8
  %0 = ptrtoint i8* %data to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @sony_rfkill_address, i64 0, i64 %0
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %add = add nsw i32 %1, 256
  %tobool = trunc i8 %frombool to i1
  %or = or i32 %add, 458752
  %add.or = select i1 %tobool, i32 %add, i32 %or
  %2 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %call = call i32 @sony_call_snc_handle(i32 %2, i32 %add.or, i32* %result)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_mode_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %0, i32 0, i32 2
  %1 = load i32, i32* %mode, align 8, !tbaa !262
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %1)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_mode_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i64, align 8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %0 = load i64, i64* %value, align 8, !tbaa !101
  %conv = trunc i64 %0 to i8
  %call3 = call i64 @__sony_nc_kbd_backlight_mode_set(i8 zeroext %conv)
  %conv4 = trunc i64 %call3 to i32
  %cmp5 = icmp slt i32 %conv4, 0
  %conv8 = sext i32 %conv4 to i64
  %conv8.count = select i1 %cmp5, i64 %conv8, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %conv8.count, %if.end2 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_timeout_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %0, i32 0, i32 3
  %1 = load i32, i32* %timeout, align 4, !tbaa !263
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %1)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_kbd_backlight_timeout_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i64, align 8
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %buffer, i32 10, i64* %value)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %0 = load i64, i64* %value, align 8, !tbaa !101
  %conv = trunc i64 %0 to i8
  %call3 = call i32 @__sony_nc_kbd_backlight_timeout_set(i8 zeroext %conv)
  %cmp4 = icmp slt i32 %call3, 0
  %conv7 = sext i32 %call3 to i64
  %conv7.count = select i1 %cmp4, i64 %conv7, i64 %count
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -22, %if.end ], [ %conv7.count, %if.end2 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @__sony_nc_kbd_backlight_mode_set(i8 zeroext %value) #1 {
entry:
  %result = alloca i32, align 4
  %conv = zext i8 %value to i32
  %cmp = icmp sgt i32 %conv, 1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %0, i32 0, i32 0
  %1 = load i32, i32* %handle, align 8, !tbaa !250
  %conv2 = zext i8 %value to i32
  %shl = shl i32 %conv2, 16
  %2 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %2, i32 0, i32 1
  %3 = load i32, i32* %base, align 4, !tbaa !252
  %or = or i32 %shl, %3
  %call = call i32 @sony_call_snc_handle(i32 %1, i32 %or, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %4 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %handle5 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %4, i32 0, i32 0
  %5 = load i32, i32* %handle5, align 8, !tbaa !250
  %conv6 = zext i8 %value to i32
  %shl7 = shl i32 %conv6, 16
  %6 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %base8 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %6, i32 0, i32 1
  %7 = load i32, i32* %base8, align 4, !tbaa !252
  %add = add i32 %7, 256
  %or9 = or i32 %shl7, %add
  %call10 = call i32 @sony_call_snc_handle(i32 %5, i32 %or9, i32* %result)
  %conv11 = zext i8 %value to i32
  %8 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %8, i32 0, i32 2
  store i32 %conv11, i32* %mode, align 8, !tbaa !262
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i64 [ 0, %if.end4 ], [ -22, %entry ], [ -5, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @__sony_nc_kbd_backlight_timeout_set(i8 zeroext %value) #1 {
entry:
  %result = alloca i32, align 4
  %conv = zext i8 %value to i32
  %cmp = icmp sgt i32 %conv, 3
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %0, i32 0, i32 0
  %1 = load i32, i32* %handle, align 8, !tbaa !250
  %conv2 = zext i8 %value to i32
  %shl = shl i32 %conv2, 16
  %2 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %2, i32 0, i32 1
  %3 = load i32, i32* %base, align 4, !tbaa !252
  %add = add i32 %3, 512
  %or = or i32 %shl, %add
  %call = call i32 @sony_call_snc_handle(i32 %1, i32 %or, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %conv5 = zext i8 %value to i32
  %4 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %4, i32 0, i32 3
  store i32 %conv5, i32* %timeout, align 4, !tbaa !263
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -22, %entry ], [ -5, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_backlight_ng_read_limits(i32 %handle, %struct.sony_backlight_props* %props) #1 {
entry:
  %offset = alloca i64, align 8
  %buffer = alloca [32 x i8], align 16
  %0 = bitcast [32 x i8]* %buffer to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 32, i32 16, i1 false)
  %handle1 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 1
  store i32 %handle, i32* %handle1, align 8, !tbaa !264
  %offset2 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 3
  store i8 0, i8* %offset2, align 8, !tbaa !217
  %maxlvl = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 4
  store i8 -1, i8* %maxlvl, align 1, !tbaa !216
  %call = call i32 @sony_find_snc_handle(i32 %handle)
  %conv = sext i32 %call to i64
  store i64 %conv, i64* %offset, align 8, !tbaa !194
  %1 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i32 0, i32 0
  %call3 = call i32 @sony_nc_buffer_call(i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.133, i32 0, i32 0), i64* %offset, i8* %arraydecay, i64 32)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %cleanup, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %handle, 323
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %handle, 331
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %.off = add i32 %handle, -331
  %SwitchLeaf6 = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf6, label %sw.epilog, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %handle, 323
  br i1 %SwitchLeaf4, label %sw.epilog, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %handle, 311
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %handle, 311
  br i1 %SwitchLeaf2, label %sw.epilog, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %handle, 303
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %lvl_table_len.0 = phi i32 [ 0, %NewDefault ], [ 9, %LeafBlock1 ], [ 9, %LeafBlock ], [ 16, %LeafBlock5 ], [ 16, %LeafBlock3 ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %min.0 = phi i8 [ -1, %sw.epilog ], [ %min.1, %for.inc ]
  %i.0 = phi i32 [ 0, %sw.epilog ], [ %inc, %for.inc ]
  %max.0 = phi i8 [ 0, %sw.epilog ], [ %max.1, %for.inc ]
  %cmp6 = icmp slt i32 %i.0, %lvl_table_len.0
  %conv8 = sext i32 %i.0 to i64
  %cmp9 = icmp ult i64 %conv8, 32
  %2 = select i1 %cmp6, i1 %cmp9, i1 false
  br i1 %2, label %do.body, label %for.end

do.body:                                          ; preds = %for.cond
  %3 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %idxprom15 = sext i32 %i.0 to i64
  %arrayidx16 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom15
  %4 = load i8, i8* %arrayidx16, align 1, !tbaa !41
  %tobool17 = icmp ne i8 %4, 0
  br i1 %tobool17, label %if.end19, label %for.end

if.end19:                                         ; preds = %do.end
  %idxprom20 = sext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom20
  %5 = load i8, i8* %arrayidx21, align 1, !tbaa !41
  %conv22 = zext i8 %5 to i32
  %conv23 = zext i8 %max.0 to i32
  %cmp24 = icmp sgt i32 %conv22, %conv23
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end19
  %idxprom27 = sext i32 %i.0 to i64
  %arrayidx28 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom27
  %6 = load i8, i8* %arrayidx28, align 1, !tbaa !41
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end19
  %max.1 = phi i8 [ %6, %if.then26 ], [ %max.0, %if.end19 ]
  %idxprom30 = sext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom30
  %7 = load i8, i8* %arrayidx31, align 1, !tbaa !41
  %conv32 = zext i8 %7 to i32
  %conv33 = zext i8 %min.0 to i32
  %cmp34 = icmp slt i32 %conv32, %conv33
  br i1 %cmp34, label %if.then36, label %for.inc

if.then36:                                        ; preds = %if.end29
  %idxprom37 = sext i32 %i.0 to i64
  %arrayidx38 = getelementptr inbounds [32 x i8], [32 x i8]* %buffer, i64 0, i64 %idxprom37
  %8 = load i8, i8* %arrayidx38, align 1, !tbaa !41
  br label %for.inc

for.inc:                                          ; preds = %if.then36, %if.end29
  %min.1 = phi i8 [ %8, %if.then36 ], [ %min.0, %if.end29 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %do.end, %for.cond
  %offset40 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 3
  store i8 %min.0, i8* %offset40, align 8, !tbaa !217
  %maxlvl41 = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %props, i32 0, i32 4
  store i8 %max.0, i8* %maxlvl41, align 1, !tbaa !216
  %9 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool43 = icmp ne i32 %9, 0
  br i1 %tobool43, label %if.then44, label %cleanup

if.then44:                                        ; preds = %for.end
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then44, %for.end, %entry
  ret void
}

declare %struct.backlight_device* @backlight_device_register(i8*, %struct.device*, i8*, %struct.backlight_ops*, %struct.backlight_properties*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_update_status_ng(%struct.backlight_device* %bd) #1 {
entry:
  %result = alloca i32, align 4
  %call = call i8* @bl_get_data(%struct.backlight_device* %bd)
  %0 = bitcast i8* %call to %struct.sony_backlight_props*
  %props = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %bd, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 0
  %1 = load i32, i32* %brightness, align 8, !tbaa !158
  %offset = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %0, i32 0, i32 3
  %2 = load i8, i8* %offset, align 8, !tbaa !217
  %conv = zext i8 %2 to i32
  %add = add nsw i32 %1, %conv
  %handle = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %0, i32 0, i32 1
  %3 = load i32, i32* %handle, align 8, !tbaa !264
  %cmd_base = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %0, i32 0, i32 2
  %4 = load i32, i32* %cmd_base, align 4, !tbaa !215
  %shl = shl i32 %add, 16
  %or = or i32 %4, %shl
  %call1 = call i32 @sony_call_snc_handle(i32 %3, i32 %or, i32* %result)
  %tobool = icmp ne i32 %call1, 0
  %.add = select i1 %tobool, i32 -5, i32 %add
  ret i32 %.add
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_get_brightness_ng(%struct.backlight_device* %bd) #1 {
entry:
  %result = alloca i32, align 4
  %call = call i8* @bl_get_data(%struct.backlight_device* %bd)
  %0 = bitcast i8* %call to %struct.sony_backlight_props*
  %handle = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %0, i32 0, i32 1
  %1 = load i32, i32* %handle, align 8, !tbaa !264
  %cmd_base = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %0, i32 0, i32 2
  %2 = load i32, i32* %cmd_base, align 4, !tbaa !215
  %add = add nsw i32 %2, 256
  %call1 = call i32 @sony_call_snc_handle(i32 %1, i32 %add, i32* %result)
  %3 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %3, 255
  %offset = getelementptr inbounds %struct.sony_backlight_props, %struct.sony_backlight_props* %0, i32 0, i32 3
  %4 = load i8, i8* %offset, align 8, !tbaa !217
  %conv = zext i8 %4 to i32
  %sub = sub nsw i32 %and, %conv
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @bl_get_data(%struct.backlight_device* %bl_dev) #0 {
entry:
  %dev = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %bl_dev, i32 0, i32 5
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare i8* @dev_get_drvdata(%struct.device*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_backlight_update_status(%struct.backlight_device* %bd) #1 {
entry:
  %arg = alloca i32, align 4
  %props = getelementptr inbounds %struct.backlight_device, %struct.backlight_device* %bd, i32 0, i32 0
  %brightness = getelementptr inbounds %struct.backlight_properties, %struct.backlight_properties* %props, i32 0, i32 0
  %0 = load i32, i32* %brightness, align 8, !tbaa !158
  %add = add nsw i32 %0, 1
  store i32 %add, i32* %arg, align 4, !tbaa !12
  %1 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call = call i32 @sony_nc_int_call(i8* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.58, i32 0, i32 0), i32* %arg, i32* null)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @brightness_default_validate(i32 %direction, i32 %value) #1 {
entry:
  %Pivot = icmp slt i32 %direction, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %direction, 1
  %sub = sub nsw i32 %value, 1
  %sub. = select i1 %SwitchLeaf2, i32 %sub, i32 -22
  ret i32 %sub.

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %direction, 0
  br i1 %SwitchLeaf, label %sw.bb1, label %return

sw.bb1:                                           ; preds = %LeafBlock
  %cmp = icmp sge i32 %value, 0
  %cmp2 = icmp slt i32 %value, 8
  %or.cond = and i1 %cmp, %cmp2
  %add = add nsw i32 %value, 1
  %add. = select i1 %or.cond, i32 %add, i32 -22
  br label %return

return:                                           ; preds = %sw.bb1, %LeafBlock
  %retval.0 = phi i32 [ -22, %LeafBlock ], [ %add., %sw.bb1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_sysfs_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer) #1 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.sony_nc_value*
  %acpiget = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %1, i32 0, i32 1
  %2 = load i8**, i8*** %acpiget, align 8, !tbaa !207
  %3 = load i8*, i8** %2, align 8, !tbaa !37
  %tobool = icmp ne i8* %3, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %4 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %acpiget1 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %1, i32 0, i32 1
  %5 = load i8**, i8*** %acpiget1, align 8, !tbaa !207
  %6 = load i8*, i8** %5, align 8, !tbaa !37
  %call = call i32 @sony_nc_int_call(i8* %4, i8* %6, i32* null, i32* %value)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %validate = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %1, i32 0, i32 3
  %7 = load i32 (i32, i32)*, i32 (i32, i32)** %validate, align 8, !tbaa !265
  %tobool4 = icmp ne i32 (i32, i32)* %7, null
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end3
  %validate6 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %1, i32 0, i32 3
  %8 = load i32 (i32, i32)*, i32 (i32, i32)** %validate6, align 8, !tbaa !265
  %9 = load i32, i32* %value, align 4, !tbaa !12
  %call7 = call i32 %8(i32 1, i32 %9)
  store i32 %call7, i32* %value, align 4, !tbaa !12
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end3
  %10 = load i32, i32* %value, align 4, !tbaa !12
  %call9 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buffer, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i32 0, i32 0), i32 %10)
  %conv = sext i32 %call9 to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end8 ], [ -5, %entry ], [ -5, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @sony_nc_sysfs_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buffer, i64 %count) #1 {
entry:
  %value = alloca i32, align 4
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.sony_nc_value*
  %acpiset = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %1, i32 0, i32 2
  %2 = load i8**, i8*** %acpiset, align 8, !tbaa !209
  %tobool = icmp ne i8** %2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %cmp = icmp ugt i64 %count, 31
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %call = call i32 @kstrtoint(i8* %buffer, i32 10, i32* %value)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end2
  %validate = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %1, i32 0, i32 3
  %3 = load i32 (i32, i32)*, i32 (i32, i32)** %validate, align 8, !tbaa !265
  %tobool6 = icmp ne i32 (i32, i32)* %3, null
  br i1 %tobool6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end5
  %validate8 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %1, i32 0, i32 3
  %4 = load i32 (i32, i32)*, i32 (i32, i32)** %validate8, align 8, !tbaa !265
  %5 = load i32, i32* %value, align 4, !tbaa !12
  %call9 = call i32 %4(i32 0, i32 %5)
  store i32 %call9, i32* %value, align 4, !tbaa !12
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end5
  %6 = load i32, i32* %value, align 4, !tbaa !12
  %cmp11 = icmp slt i32 %6, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  %7 = load i32, i32* %value, align 4, !tbaa !12
  %conv = sext i32 %7 to i64
  br label %cleanup

if.end13:                                         ; preds = %if.end10
  %8 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %acpiset14 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %1, i32 0, i32 2
  %9 = load i8**, i8*** %acpiset14, align 8, !tbaa !209
  %10 = load i8*, i8** %9, align 8, !tbaa !37
  %call15 = call i32 @sony_nc_int_call(i8* %8, i8* %10, i32* %value, i32* null)
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end13
  %11 = load i32, i32* %value, align 4, !tbaa !12
  %value20 = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %1, i32 0, i32 4
  store i32 %11, i32* %value20, align 8, !tbaa !266
  %valid = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %1, i32 0, i32 5
  store i32 1, i32* %valid, align 4, !tbaa !267
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.end13, %if.then12, %if.end2, %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.then12 ], [ %count, %if.end19 ], [ -5, %entry ], [ -22, %if.end ], [ -22, %if.end2 ], [ -5, %if.end13 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @boolean_validate(i32 %direction, i32 %value) #1 {
entry:
  %cmp = icmp ne i32 %direction, 0
  %switch = icmp ult i32 %value, 2
  %or.cond = or i1 %cmp, %switch
  %retval.0 = select i1 %or.cond, i32 %value, i32 -22
  ret i32 %retval.0
}

declare i32 @kstrtoint(i8*, i32, i32*) #2

declare void @backlight_device_unregister(%struct.backlight_device*) #2

; Function Attrs: nounwind uwtable
define internal void @sony_nc_touchpad_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %tobool = icmp ne %struct.touchpad_control* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %attr = getelementptr inbounds %struct.touchpad_control, %struct.touchpad_control* %1, i32 0, i32 0
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %attr)
  %2 = load %struct.touchpad_control*, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  %3 = bitcast %struct.touchpad_control* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.touchpad_control* null, %struct.touchpad_control** @tp_ctl, align 8, !tbaa !37
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_battery_care_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %tobool = icmp ne %struct.battery_care_control* %0, null
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %1, i32 0, i32 0
  %arrayidx = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs, i64 0, i64 0
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %arrayidx)
  %2 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %2, i32 0, i32 1
  %3 = load i32, i32* %handle, align 8, !tbaa !228
  %cmp = icmp ne i32 %3, 277
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %dev2 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %4 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %attrs3 = getelementptr inbounds %struct.battery_care_control, %struct.battery_care_control* %4, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [2 x %struct.device_attribute], [2 x %struct.device_attribute]* %attrs3, i64 0, i64 1
  call void @device_remove_file(%struct.device* %dev2, %struct.device_attribute* %arrayidx4)
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %5 = load %struct.battery_care_control*, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  %6 = bitcast %struct.battery_care_control* %5 to i8*
  call void @kfree(i8* %6)
  store %struct.battery_care_control* null, %struct.battery_care_control** @bcare_ctl, align 8, !tbaa !37
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_lid_resume_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %tobool = icmp ne %struct.snc_lid_resume_control* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %attrs = getelementptr inbounds %struct.snc_lid_resume_control, %struct.snc_lid_resume_control* %1, i32 0, i32 0
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.device_attribute], [3 x %struct.device_attribute]* %attrs, i64 0, i64 %idxprom
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %arrayidx)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %2 = load %struct.snc_lid_resume_control*, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  %3 = bitcast %struct.snc_lid_resume_control* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.snc_lid_resume_control* null, %struct.snc_lid_resume_control** @lid_ctl, align 8, !tbaa !37
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_thermal_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %tobool = icmp ne %struct.snc_thermal_ctrl* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %profiles_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %1, i32 0, i32 3
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %profiles_attr)
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %2 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode_attr = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %2, i32 0, i32 2
  call void @device_remove_file(%struct.device* %dev1, %struct.device_attribute* %mode_attr)
  %3 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %4 = bitcast %struct.snc_thermal_ctrl* %3 to i8*
  call void @kfree(i8* %4)
  store %struct.snc_thermal_ctrl* null, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_gfx_switch_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %tobool = icmp ne %struct.snc_gfx_switch_control* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %attr = getelementptr inbounds %struct.snc_gfx_switch_control, %struct.snc_gfx_switch_control* %1, i32 0, i32 0
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %attr)
  %2 = load %struct.snc_gfx_switch_control*, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  %3 = bitcast %struct.snc_gfx_switch_control* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.snc_gfx_switch_control* null, %struct.snc_gfx_switch_control** @gfxs_ctl, align 8, !tbaa !37
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_highspeed_charging_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %0 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %tobool = icmp ne %struct.device_attribute* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %1)
  %2 = load %struct.device_attribute*, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  %3 = bitcast %struct.device_attribute* %2 to i8*
  call void @kfree(i8* %3)
  store %struct.device_attribute* null, %struct.device_attribute** @hsc_handle, align 8, !tbaa !37
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_kbd_backlight_cleanup(%struct.platform_device* %pd) #1 {
entry:
  %result = alloca i32, align 4
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %tobool = icmp ne %struct.kbd_backlight* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %1 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %1, i32 0, i32 4
  call void @device_remove_file(%struct.device* %dev, %struct.device_attribute* %mode_attr)
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pd, i32 0, i32 3
  %2 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout_attr = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %2, i32 0, i32 5
  call void @device_remove_file(%struct.device* %dev1, %struct.device_attribute* %timeout_attr)
  %3 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %3, i32 0, i32 0
  %4 = load i32, i32* %handle, align 8, !tbaa !250
  %5 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %5, i32 0, i32 1
  %6 = load i32, i32* %base, align 4, !tbaa !252
  %or = or i32 %6, 65536
  %call = call i32 @sony_call_snc_handle(i32 %4, i32 %or, i32* %result)
  %7 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %handle2 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %7, i32 0, i32 0
  %8 = load i32, i32* %handle2, align 8, !tbaa !250
  %9 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %base3 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %9, i32 0, i32 1
  %10 = load i32, i32* %base3, align 4, !tbaa !252
  %add = add i32 %10, 512
  %call4 = call i32 @sony_call_snc_handle(i32 %8, i32 %add, i32* %result)
  %11 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %12 = bitcast %struct.kbd_backlight* %11 to i8*
  call void @kfree(i8* %12)
  store %struct.kbd_backlight* null, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @rfkill_unregister(%struct.rfkill*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_hotkeys_decode(i32 %handle) #1 {
entry:
  %result = alloca i32, align 4
  store i32 0, i32* %result, align 4, !tbaa !12
  %call = call i32 @sony_call_snc_handle(i32 %handle, i32 512, i32* %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %do.body, label %if.end4

do.body:                                          ; preds = %entry
  %0 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %do.body
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end4:                                          ; preds = %entry
  %1 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %1, 255
  store i32 %and, i32* %result, align 4, !tbaa !12
  %cmp = icmp eq i32 %handle, 256
  %. = select i1 %cmp, %struct.sony_nc_event* getelementptr inbounds ([41 x %struct.sony_nc_event], [41 x %struct.sony_nc_event]* @sony_100_events, i32 0, i32 0), %struct.sony_nc_event* getelementptr inbounds ([15 x %struct.sony_nc_event], [15 x %struct.sony_nc_event]* @sony_127_events, i32 0, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %key_event.1 = phi %struct.sony_nc_event* [ %., %if.end4 ], [ %incdec.ptr, %for.inc ]
  %data = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 0
  %2 = load i8, i8* %data, align 1, !tbaa !268
  %tobool7 = icmp ne i8 %2, 0
  br i1 %tobool7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %data8 = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 0
  %3 = load i8, i8* %data8, align 1, !tbaa !268
  %conv = zext i8 %3 to i32
  %4 = load i32, i32* %result, align 4, !tbaa !12
  %cmp9 = icmp eq i32 %conv, %4
  br i1 %cmp9, label %if.then11, label %for.inc

if.then11:                                        ; preds = %for.body
  %event12 = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 1
  %5 = load i8, i8* %event12, align 1, !tbaa !270
  %conv13 = zext i8 %5 to i32
  br label %for.end

for.inc:                                          ; preds = %for.body
  %incdec.ptr = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 1
  br label %for.cond

for.end:                                          ; preds = %if.then11, %for.cond
  %ret.0 = phi i32 [ %conv13, %if.then11 ], [ -22, %for.cond ]
  %data15 = getelementptr inbounds %struct.sony_nc_event, %struct.sony_nc_event* %key_event.1, i32 0, i32 0
  %6 = load i8, i8* %data15, align 1, !tbaa !268
  %tobool16 = icmp ne i8 %6, 0
  br i1 %tobool16, label %cleanup, label %if.then17

if.then17:                                        ; preds = %for.end
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then17, %for.end, %if.then2, %do.body
  %retval.0 = phi i32 [ -22, %if.then2 ], [ -22, %do.body ], [ %ret.0, %if.then17 ], [ %ret.0, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_rfkill_update() #1 {
entry:
  %result = alloca i32, align 4
  %0 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %call = call i32 @sony_call_snc_handle(i32 %0, i32 512, i32* %result)
  %1 = load i32, i32* %result, align 4, !tbaa !12
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %LeafBlock ]
  %cmp = icmp ult i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @sony_rfkill_address, i64 0, i64 %idxprom
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %idxprom1 = zext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom1
  %3 = load %struct.rfkill*, %struct.rfkill** %arrayidx2, align 8, !tbaa !37
  %tobool3 = icmp ne %struct.rfkill* %3, null
  br i1 %tobool3, label %if.end, label %LeafBlock

if.end:                                           ; preds = %for.body
  %tobool4 = trunc i8 %frombool to i1
  br i1 %tobool4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end
  %idxprom6 = zext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom6
  %4 = load %struct.rfkill*, %struct.rfkill** %arrayidx7, align 8, !tbaa !37
  %call8 = call zeroext i1 @rfkill_set_hw_state(%struct.rfkill* %4, i1 zeroext true)
  br label %LeafBlock

if.end11:                                         ; preds = %if.end
  %5 = load i32, i32* @sony_rfkill_handle, align 4, !tbaa !12
  %call12 = call i32 @sony_call_snc_handle(i32 %5, i32 %2, i32* %result)
  %idxprom13 = zext i32 %i.0 to i64
  %arrayidx14 = getelementptr inbounds [4 x %struct.rfkill*], [4 x %struct.rfkill*]* @sony_rfkill_devices, i64 0, i64 %idxprom13
  %6 = load %struct.rfkill*, %struct.rfkill** %arrayidx14, align 8, !tbaa !37
  %7 = load i32, i32* %result, align 4, !tbaa !12
  %and15 = and i32 %7, 2
  %tobool16 = icmp ne i32 %and15, 0
  %lnot17 = xor i1 %tobool16, true
  call void @rfkill_set_states(%struct.rfkill* %6, i1 zeroext %lnot17, i1 zeroext false)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end11, %if.then5, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare i32 @acpi_bus_generate_netlink_event(i8*, i8*, i8 zeroext, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name(%struct.device* %dev) #0 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !271
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !271
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

declare void @rfkill_set_states(%struct.rfkill*, i1 zeroext, i1 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name(%struct.kobject* %kobj) #0 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !272
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @sony_nc_resume(%struct.device* %dev) #1 {
entry:
  %handle = alloca i8*, align 8
  %arg = alloca i32, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %item.0 = phi %struct.sony_nc_value* [ getelementptr inbounds ([13 x %struct.sony_nc_value], [13 x %struct.sony_nc_value]* @sony_nc_values, i32 0, i32 0), %entry ], [ %incdec.ptr, %for.inc ]
  %name = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !201
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %valid = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 5
  %1 = load i32, i32* %valid, align 4, !tbaa !267
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.end, label %NodeBlock

if.end:                                           ; preds = %for.body
  %2 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %acpiset = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 2
  %3 = load i8**, i8*** %acpiset, align 8, !tbaa !209
  %4 = load i8*, i8** %3, align 8, !tbaa !37
  %value = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 0, i32 4
  %call = call i32 @sony_nc_int_call(i8* %2, i8* %4, i32* %value, i32* null)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then2, label %NodeBlock

if.then2:                                         ; preds = %if.end
  call void (i8*, ...) @printk(i8* null)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.then2, %if.end, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then2 ], [ 4, %for.body ], [ 0, %if.end ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 4
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  %or.cond = and i1 %Pivot, %SwitchLeaf
  br i1 %or.cond, label %for.end, label %for.inc

for.inc:                                          ; preds = %NodeBlock
  %incdec.ptr = getelementptr inbounds %struct.sony_nc_value, %struct.sony_nc_value* %item.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %NodeBlock, %for.cond
  %5 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call5 = call i32 @acpi_get_handle(i8* %5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.82, i32 0, i32 0), i8** %handle)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end16, label %if.then7

if.then7:                                         ; preds = %for.end
  store i32 1, i32* %arg, align 4, !tbaa !12
  %6 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call8 = call i32 @sony_nc_int_call(i8* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.82, i32 0, i32 0), i32* %arg, i32* null)
  %tobool9 = icmp ne i32 %call8, 0
  %7 = load i32, i32* @debug, align 4
  %tobool11 = icmp ne i32 %7, 0
  %or.cond1 = and i1 %tobool9, %tobool11
  br i1 %or.cond1, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.then7
  call void (i8*, ...) @printk(i8* null)
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.then7
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %for.end
  %8 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call17 = call i32 @acpi_get_handle(i8* %8, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i8** %handle)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end16
  call void @sony_nc_function_resume()
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %if.end16
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_function_resume() #1 {
entry:
  %result = alloca i32, align 4
  %bitmask = alloca i32, align 4
  %arg = alloca i32, align 4
  %0 = load i32, i32* @debug, align 4, !tbaa !12
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @printk(i8* null)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock37, %do.end
  %i.0 = phi i32 [ 0, %do.end ], [ %inc, %LeafBlock37 ]
  %conv = zext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.sony_nc_handles*, %struct.sony_nc_handles** @handles, align 8, !tbaa !37
  %cap = getelementptr inbounds %struct.sony_nc_handles, %struct.sony_nc_handles* %1, i32 0, i32 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %cap, i64 0, i64 %idxprom
  %2 = load i16, i16* %arrayidx, align 2, !tbaa !195
  %conv2 = zext i16 %2 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br i1 %tobool3, label %NodeBlock34, label %LeafBlock37

NodeBlock34:                                      ; preds = %for.body
  %Pivot35 = icmp slt i32 %conv2, 309
  br i1 %Pivot35, label %NodeBlock13, label %NodeBlock32

NodeBlock32:                                      ; preds = %NodeBlock34
  %Pivot33 = icmp slt i32 %conv2, 323
  br i1 %Pivot33, label %NodeBlock19, label %NodeBlock30

NodeBlock30:                                      ; preds = %NodeBlock32
  %Pivot31 = icmp slt i32 %conv2, 331
  br i1 %Pivot31, label %LeafBlock21, label %NodeBlock28

NodeBlock28:                                      ; preds = %NodeBlock30
  %Pivot29 = icmp slt i32 %conv2, 355
  br i1 %Pivot29, label %LeafBlock23, label %LeafBlock26

LeafBlock26:                                      ; preds = %NodeBlock28
  %SwitchLeaf27 = icmp eq i32 %conv2, 355
  br i1 %SwitchLeaf27, label %sw.bb11, label %LeafBlock37

LeafBlock23:                                      ; preds = %NodeBlock28
  %.off24 = add i32 %conv2, -331
  %SwitchLeaf25 = icmp ule i32 %.off24, 1
  br i1 %SwitchLeaf25, label %sw.bb11, label %LeafBlock37

LeafBlock21:                                      ; preds = %NodeBlock30
  %SwitchLeaf22 = icmp eq i32 %conv2, 323
  br i1 %SwitchLeaf22, label %sw.bb11, label %LeafBlock37

NodeBlock19:                                      ; preds = %NodeBlock32
  %Pivot20 = icmp slt i32 %conv2, 311
  br i1 %Pivot20, label %LeafBlock15, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %conv2, 311
  br i1 %SwitchLeaf18, label %sw.bb11, label %LeafBlock37

LeafBlock15:                                      ; preds = %NodeBlock19
  %SwitchLeaf16 = icmp eq i32 %conv2, 309
  br i1 %SwitchLeaf16, label %sw.bb10, label %LeafBlock37

NodeBlock13:                                      ; preds = %NodeBlock34
  %Pivot14 = icmp slt i32 %conv2, 290
  br i1 %Pivot14, label %NodeBlock, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %conv2, 292
  br i1 %Pivot12, label %LeafBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %conv2, 295
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv2, 295
  br i1 %SwitchLeaf8, label %sw.bb, label %LeafBlock37

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv2, 292
  br i1 %SwitchLeaf6, label %sw.bb10, label %LeafBlock37

LeafBlock3:                                       ; preds = %NodeBlock11
  %SwitchLeaf4 = icmp eq i32 %conv2, 290
  br i1 %SwitchLeaf4, label %sw.bb9, label %LeafBlock37

NodeBlock:                                        ; preds = %NodeBlock13
  %Pivot = icmp slt i32 %conv2, 258
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv2, 258
  br i1 %SwitchLeaf2, label %sw.bb7, label %LeafBlock37

LeafBlock:                                        ; preds = %NodeBlock
  %.off = add i32 %conv2, -256
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %LeafBlock37

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock7
  %call6 = call i32 @sony_call_snc_handle(i32 %conv2, i32 0, i32* %result)
  br label %LeafBlock37

sw.bb7:                                           ; preds = %LeafBlock1
  %call8 = call i32 @sony_call_snc_handle(i32 %conv2, i32 256, i32* %result)
  br label %LeafBlock37

sw.bb9:                                           ; preds = %LeafBlock3
  call void @sony_nc_thermal_resume()
  br label %LeafBlock37

sw.bb10:                                          ; preds = %LeafBlock5, %LeafBlock15
  call void @sony_nc_rfkill_update()
  br label %LeafBlock37

sw.bb11:                                          ; preds = %LeafBlock17, %LeafBlock21, %LeafBlock23, %LeafBlock26
  call void @sony_nc_kbd_backlight_resume()
  br label %LeafBlock37

LeafBlock37:                                      ; preds = %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb7, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock7, %LeafBlock15, %LeafBlock17, %LeafBlock21, %LeafBlock23, %LeafBlock26, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 16, i32* %arg, align 4, !tbaa !12
  %3 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call12 = call i32 @sony_nc_int_call(i8* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i32* %arg, i32* %bitmask)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end16, label %if.then14

if.then14:                                        ; preds = %for.end
  %4 = load i8*, i8** @sony_nc_acpi_handle, align 8, !tbaa !37
  %call15 = call i32 @sony_nc_int_call(i8* %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.103, i32 0, i32 0), i32* %bitmask, i32* %result)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_thermal_resume() #1 {
entry:
  %call = call i32 @sony_nc_thermal_mode_get()
  %0 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %0, i32 0, i32 0
  %1 = load i32, i32* %mode, align 8, !tbaa !236
  %cmp = icmp ne i32 %call, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.snc_thermal_ctrl*, %struct.snc_thermal_ctrl** @th_handle, align 8, !tbaa !37
  %mode1 = getelementptr inbounds %struct.snc_thermal_ctrl, %struct.snc_thermal_ctrl* %2, i32 0, i32 0
  %3 = load i32, i32* %mode1, align 8, !tbaa !236
  %conv = trunc i32 %3 to i16
  %call2 = call i32 @sony_nc_thermal_mode_set(i16 zeroext %conv)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sony_nc_kbd_backlight_resume() #1 {
entry:
  %ignore = alloca i32, align 4
  store i32 0, i32* %ignore, align 4, !tbaa !12
  %0 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %tobool = icmp ne %struct.kbd_backlight* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %mode = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %1, i32 0, i32 2
  %2 = load i32, i32* %mode, align 8, !tbaa !262
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %3 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %handle = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %3, i32 0, i32 0
  %4 = load i32, i32* %handle, align 8, !tbaa !250
  %5 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %base = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %5, i32 0, i32 1
  %6 = load i32, i32* %base, align 4, !tbaa !252
  %call = call i32 @sony_call_snc_handle(i32 %4, i32 %6, i32* %ignore)
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %7 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %7, i32 0, i32 3
  %8 = load i32, i32* %timeout, align 4, !tbaa !263
  %cmp3 = icmp ne i32 %8, 0
  br i1 %cmp3, label %if.then4, label %cleanup

if.then4:                                         ; preds = %if.end2
  %9 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %handle5 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %9, i32 0, i32 0
  %10 = load i32, i32* %handle5, align 8, !tbaa !250
  %11 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %base6 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %11, i32 0, i32 1
  %12 = load i32, i32* %base6, align 4, !tbaa !252
  %add = add i32 %12, 512
  %13 = load %struct.kbd_backlight*, %struct.kbd_backlight** @kbdbl_ctl, align 8, !tbaa !37
  %timeout7 = getelementptr inbounds %struct.kbd_backlight, %struct.kbd_backlight* %13, i32 0, i32 3
  %14 = load i32, i32* %timeout7, align 4, !tbaa !263
  %shl = shl i32 %14, 16
  %or = or i32 %add, %shl
  %call8 = call i32 @sony_call_snc_handle(i32 %10, i32 %or, i32* %ignore)
  br label %cleanup

cleanup:                                          ; preds = %if.then4, %if.end2, %entry
  ret void
}

declare void @printk(i8*, ...) #2

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !13, i64 0}
!13 = !{!"int", !5, i64 0}
!14 = !{!15, !5, i64 246}
!15 = !{!"sony_pic_dev", !4, i64 0, !4, i64 8, !4, i64 16, !16, i64 24, !16, i64 40, !17, i64 56, !4, i64 224, !4, i64 232, !13, i64 240, !22, i64 244, !5, i64 246, !5, i64 247, !5, i64 248}
!16 = !{!"list_head", !4, i64 0, !4, i64 8}
!17 = !{!"mutex", !18, i64 0, !19, i64 8, !16, i64 80, !4, i64 96, !4, i64 104, !4, i64 112, !20, i64 120}
!18 = !{!"", !13, i64 0}
!19 = !{!"spinlock", !5, i64 0}
!20 = !{!"lockdep_map", !4, i64 0, !5, i64 8, !4, i64 24, !13, i64 32, !21, i64 40}
!21 = !{!"long", !5, i64 0}
!22 = !{!"short", !5, i64 0}
!23 = !{!15, !4, i64 16}
!24 = !{!25, !22, i64 3}
!25 = !{!"sony_pic_ioport", !26, i64 0, !26, i64 7, !16, i64 16}
!26 = !{!"acpi_resource_io", !5, i64 0, !5, i64 1, !5, i64 2, !22, i64 3, !22, i64 5}
!27 = !{!28, !4, i64 0}
!28 = !{!"pv_irq_ops", !29, i64 0, !29, i64 8, !29, i64 16, !29, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!29 = !{!"paravirt_callee_save", !4, i64 0}
!30 = !{i32 -2146180388, i32 -2146180363, i32 -2146180093, i32 -2146180296, i32 -2146180265, i32 -2146180235}
!31 = !{i32 -2146180808, i32 -2146178830, i32 -2146178808, i32 -2146178795, i32 -2146178472, i32 -2146178405, i32 -2146178703, i32 -2146178676, i32 -2146178648, i32 -2146178618}
!32 = !{i32 -2145463055}
!33 = !{i32 -2145462853}
!34 = !{!35, !4, i64 208}
!35 = !{!"pv_cpu_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184, !4, i64 192, !4, i64 200, !4, i64 208, !4, i64 216, !4, i64 224, !4, i64 232, !4, i64 240, !4, i64 248, !4, i64 256, !4, i64 264, !4, i64 272, !4, i64 280, !4, i64 288, !4, i64 296, !4, i64 304, !4, i64 312}
!36 = !{!15, !4, i64 0}
!37 = !{!4, !4, i64 0}
!38 = !{!25, !5, i64 2}
!39 = !{!25, !22, i64 10}
!40 = !{!25, !5, i64 9}
!41 = !{!5, !5, i64 0}
!42 = !{!15, !4, i64 8}
!43 = !{!15, !5, i64 247}
!44 = !{!16, !4, i64 0}
!45 = !{!25, !4, i64 16}
!46 = !{!47, !4, i64 8}
!47 = !{!"sony_pic_irq", !48, i64 0, !16, i64 8}
!48 = !{!"acpi_resource_irq", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6}
!49 = !{!15, !13, i64 240}
!50 = !{!15, !4, i64 232}
!51 = !{!15, !22, i64 244}
!52 = !{!15, !4, i64 224}
!53 = !{!54, !4, i64 8}
!54 = !{!"acpi_device", !13, i64 0, !4, i64 8, !4, i64 16, !16, i64 24, !16, i64 40, !16, i64 56, !55, i64 72, !56, i64 76, !57, i64 80, !59, i64 208, !61, i64 376, !64, i64 424, !66, i64 448, !4, i64 456, !4, i64 464, !4, i64 472, !67, i64 480, !5, i64 1616, !5, i64 1620, !16, i64 1624, !17, i64 1640, !5, i64 1808, !16, i64 1816, !4, i64 1832}
!55 = !{!"acpi_device_status", !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0}
!56 = !{!"acpi_device_flags", !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 1}
!57 = !{!"acpi_device_pnp", !5, i64 0, !58, i64 8, !21, i64 16, !4, i64 24, !16, i64 32, !5, i64 48, !5, i64 88, !4, i64 112, !21, i64 120}
!58 = !{!"acpi_pnp_type", !13, i64 0, !13, i64 0, !13, i64 0}
!59 = !{!"acpi_device_power", !13, i64 0, !60, i64 4, !5, i64 8}
!60 = !{!"acpi_device_power_flags", !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0, !13, i64 0}
!61 = !{!"acpi_device_wakeup", !4, i64 0, !62, i64 8, !62, i64 16, !16, i64 24, !63, i64 40, !13, i64 44}
!62 = !{!"long long", !5, i64 0}
!63 = !{!"acpi_device_wakeup_flags", !5, i64 0, !5, i64 0, !5, i64 0}
!64 = !{!"acpi_device_perf", !13, i64 0, !65, i64 4, !13, i64 8, !4, i64 16}
!65 = !{!"acpi_device_perf_flags", !5, i64 0}
!66 = !{!"acpi_device_dir", !4, i64 0}
!67 = !{!"device", !4, i64 0, !4, i64 8, !68, i64 16, !4, i64 80, !4, i64 88, !17, i64 96, !4, i64 264, !4, i64 272, !4, i64 280, !70, i64 288, !4, i64 880, !13, i64 888, !4, i64 896, !62, i64 904, !4, i64 912, !16, i64 920, !4, i64 936, !78, i64 944, !4, i64 960, !79, i64 968, !13, i64 976, !13, i64 980, !19, i64 984, !16, i64 1056, !80, i64 1072, !4, i64 1104, !4, i64 1112, !4, i64 1120, !4, i64 1128}
!68 = !{!"kobject", !4, i64 0, !16, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !69, i64 56, !13, i64 60, !13, i64 60, !13, i64 60, !13, i64 60, !13, i64 60}
!69 = !{!"kref", !18, i64 0}
!70 = !{!"dev_pm_info", !71, i64 0, !13, i64 4, !13, i64 4, !72, i64 4, !72, i64 4, !72, i64 4, !72, i64 4, !19, i64 8, !16, i64 80, !73, i64 96, !4, i64 192, !72, i64 200, !72, i64 200, !75, i64 208, !21, i64 336, !76, i64 344, !74, i64 424, !18, i64 512, !18, i64 516, !13, i64 520, !13, i64 520, !13, i64 520, !13, i64 520, !13, i64 520, !13, i64 520, !13, i64 521, !13, i64 521, !13, i64 521, !13, i64 521, !13, i64 521, !5, i64 524, !5, i64 528, !13, i64 532, !13, i64 536, !21, i64 544, !21, i64 552, !21, i64 560, !21, i64 568, !4, i64 576, !4, i64 584}
!71 = !{!"pm_message", !13, i64 0}
!72 = !{!"_Bool", !5, i64 0}
!73 = !{!"completion", !13, i64 0, !74, i64 8}
!74 = !{!"__wait_queue_head", !19, i64 0, !16, i64 72}
!75 = !{!"timer_list", !16, i64 0, !21, i64 16, !4, i64 24, !4, i64 32, !21, i64 40, !13, i64 48, !13, i64 52, !4, i64 56, !5, i64 64, !20, i64 80}
!76 = !{!"work_struct", !77, i64 0, !16, i64 8, !4, i64 24, !20, i64 32}
!77 = !{!"", !21, i64 0}
!78 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!79 = !{!"acpi_dev_node", !4, i64 0}
!80 = !{!"klist_node", !4, i64 0, !16, i64 8, !69, i64 24}
!81 = !{!75, !4, i64 32}
!82 = !{!75, !21, i64 40}
!83 = !{!84, !4, i64 0}
!84 = !{!"input_dev", !4, i64 0, !4, i64 8, !4, i64 16, !85, i64 24, !5, i64 32, !5, i64 40, !5, i64 48, !5, i64 144, !5, i64 152, !5, i64 160, !5, i64 168, !5, i64 176, !5, i64 184, !5, i64 200, !13, i64 208, !13, i64 212, !13, i64 216, !4, i64 224, !4, i64 232, !4, i64 240, !4, i64 248, !13, i64 256, !75, i64 264, !5, i64 392, !4, i64 400, !4, i64 408, !5, i64 416, !5, i64 512, !5, i64 520, !5, i64 528, !4, i64 536, !4, i64 544, !4, i64 552, !4, i64 560, !4, i64 568, !19, i64 576, !17, i64 648, !13, i64 816, !72, i64 820, !67, i64 824, !16, i64 1960, !16, i64 1976, !13, i64 1992, !13, i64 1996, !4, i64 2000, !72, i64 2008}
!85 = !{!"input_id", !22, i64 0, !22, i64 2, !22, i64 4, !22, i64 6}
!86 = !{!84, !22, i64 24}
!87 = !{!84, !22, i64 26}
!88 = !{!84, !4, i64 824}
!89 = !{!84, !13, i64 216}
!90 = !{!84, !13, i64 212}
!91 = !{!84, !4, i64 224}
!92 = !{!93, !4, i64 16}
!93 = !{!"sony_laptop_input_s", !18, i64 0, !4, i64 8, !4, i64 16, !94, i64 24, !19, i64 48, !75, i64 120}
!94 = !{!"kfifo", !5, i64 0, !5, i64 24}
!95 = !{!93, !4, i64 8}
!96 = !{!97, !13, i64 0}
!97 = !{!"miscdevice", !13, i64 0, !4, i64 8, !4, i64 16, !16, i64 24, !4, i64 40, !4, i64 48, !4, i64 56, !22, i64 64}
!98 = !{!99, !21, i64 8}
!99 = !{!"sonypi_eventtypes", !5, i64 0, !21, i64 8, !4, i64 16}
!100 = !{!99, !5, i64 0}
!101 = !{!21, !21, i64 0}
!102 = !{!99, !4, i64 16}
!103 = !{!104, !5, i64 1}
!104 = !{!"sonypi_event", !5, i64 0, !5, i64 1}
!105 = !{!104, !5, i64 0}
!106 = !{!107, !62, i64 0}
!107 = !{!"acpi_buffer", !62, i64 0, !4, i64 8}
!108 = !{!107, !4, i64 8}
!109 = !{!110, !13, i64 0}
!110 = !{!"", !111, i64 0, !111, i64 68, !111, i64 136, !111, i64 204}
!111 = !{!"acpi_resource", !13, i64 0, !13, i64 4, !5, i64 8}
!112 = !{!110, !13, i64 4}
!113 = !{!110, !13, i64 68}
!114 = !{!110, !13, i64 72}
!115 = !{!110, !13, i64 136}
!116 = !{!110, !13, i64 140}
!117 = !{!110, !13, i64 204}
!118 = !{!119, !4, i64 0}
!119 = !{!"sony_laptop_keypress", !4, i64 0, !13, i64 8}
!120 = !{!119, !13, i64 8}
!121 = !{!111, !13, i64 0}
!122 = !{!48, !5, i64 5}
!123 = !{!48, !5, i64 1}
!124 = !{!47, !5, i64 1}
!125 = !{!48, !5, i64 2}
!126 = !{!47, !5, i64 2}
!127 = !{!48, !5, i64 3}
!128 = !{!47, !5, i64 3}
!129 = !{!47, !5, i64 5}
!130 = !{i32 -2146106807, i32 -2146106768, i32 -2146106747, i32 -2146106710, i32 -2146106687, i32 -2146106678}
!131 = !{i32 427566}
!132 = !{i32 428746}
!133 = !{i32 -2146109230, i32 -2146109191, i32 -2146109170, i32 -2146109133, i32 -2146109110, i32 -2146109240}
!134 = !{!135, !13, i64 136}
!135 = !{!"file", !5, i64 0, !136, i64 16, !4, i64 32, !4, i64 40, !19, i64 48, !13, i64 120, !77, i64 128, !13, i64 136, !13, i64 140, !62, i64 144, !137, i64 152, !4, i64 248, !139, i64 256, !62, i64 288, !4, i64 296, !4, i64 304, !16, i64 312, !16, i64 328, !4, i64 344, !21, i64 352}
!136 = !{!"path", !4, i64 0, !4, i64 8}
!137 = !{!"fown_struct", !138, i64 0, !4, i64 72, !5, i64 80, !13, i64 84, !13, i64 88, !13, i64 92}
!138 = !{!"", !5, i64 0, !13, i64 8, !13, i64 12, !4, i64 16, !20, i64 24}
!139 = !{!"file_ra_state", !21, i64 0, !13, i64 8, !13, i64 12, !13, i64 16, !13, i64 20, !62, i64 24}
!140 = !{!141, !13, i64 0}
!141 = !{!"__wait_queue", !13, i64 0, !4, i64 8, !4, i64 16, !16, i64 24}
!142 = !{i32 -2146649451}
!143 = !{!141, !4, i64 8}
!144 = !{!141, !4, i64 16}
!145 = !{!16, !4, i64 8}
!146 = !{i32 -2143016959}
!147 = !{!148, !4, i64 40}
!148 = !{!"inode", !22, i64 0, !22, i64 2, !13, i64 4, !13, i64 8, !13, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !21, i64 64, !5, i64 72, !13, i64 76, !62, i64 80, !149, i64 88, !149, i64 104, !149, i64 120, !19, i64 136, !22, i64 208, !13, i64 212, !21, i64 216, !21, i64 224, !17, i64 232, !21, i64 400, !150, i64 408, !16, i64 424, !16, i64 440, !16, i64 456, !5, i64 472, !62, i64 488, !18, i64 496, !18, i64 500, !18, i64 504, !4, i64 512, !4, i64 520, !151, i64 528, !5, i64 960, !16, i64 976, !5, i64 992, !13, i64 1000, !13, i64 1004, !154, i64 1008, !18, i64 1016, !4, i64 1024}
!149 = !{!"timespec", !21, i64 0, !21, i64 8}
!150 = !{!"hlist_node", !4, i64 0, !4, i64 8}
!151 = !{!"address_space", !4, i64 0, !152, i64 8, !19, i64 24, !13, i64 96, !153, i64 104, !16, i64 112, !17, i64 128, !21, i64 296, !21, i64 304, !4, i64 312, !21, i64 320, !4, i64 328, !19, i64 336, !16, i64 408, !4, i64 424}
!152 = !{!"radix_tree_root", !13, i64 0, !13, i64 4, !4, i64 8}
!153 = !{!"rb_root", !4, i64 0}
!154 = !{!"hlist_head", !4, i64 0}
!155 = !{i64 0, i64 8, !101, i64 8, i64 8, !101}
!156 = !{!157, !4, i64 0}
!157 = !{!"sony_backlight_props", !4, i64 0, !13, i64 8, !13, i64 12, !5, i64 16, !5, i64 17}
!158 = !{!159, !13, i64 0}
!159 = !{!"backlight_device", !160, i64 0, !17, i64 24, !17, i64 192, !4, i64 360, !161, i64 368, !67, i64 392}
!160 = !{!"backlight_properties", !13, i64 0, !13, i64 4, !13, i64 8, !13, i64 12, !5, i64 16, !13, i64 20}
!161 = !{!"notifier_block", !4, i64 0, !4, i64 8, !13, i64 16}
!162 = !{!135, !4, i64 32}
!163 = !{!164, !4, i64 8}
!164 = !{!"task_struct", !21, i64 0, !4, i64 8, !18, i64 16, !13, i64 20, !13, i64 24, !165, i64 32, !13, i64 40, !13, i64 44, !13, i64 48, !13, i64 52, !13, i64 56, !13, i64 60, !4, i64 64, !166, i64 72, !171, i64 448, !4, i64 520, !154, i64 528, !5, i64 536, !13, i64 540, !13, i64 544, !13, i64 548, !172, i64 552, !173, i64 1064, !16, i64 1096, !174, i64 1112, !4, i64 1152, !4, i64 1160, !13, i64 1168, !13, i64 1172, !13, i64 1176, !13, i64 1180, !13, i64 1184, !13, i64 1188, !13, i64 1192, !13, i64 1196, !13, i64 1196, !13, i64 1196, !13, i64 1196, !13, i64 1196, !13, i64 1196, !13, i64 1200, !13, i64 1204, !21, i64 1208, !4, i64 1216, !4, i64 1224, !16, i64 1232, !16, i64 1248, !4, i64 1264, !16, i64 1272, !16, i64 1288, !5, i64 1304, !16, i64 1376, !4, i64 1392, !4, i64 1400, !4, i64 1408, !21, i64 1416, !21, i64 1424, !21, i64 1432, !21, i64 1440, !21, i64 1448, !175, i64 1456, !21, i64 1472, !21, i64 1480, !149, i64 1488, !149, i64 1504, !21, i64 1520, !21, i64 1528, !176, i64 1536, !5, i64 1560, !4, i64 1608, !4, i64 1616, !5, i64 1624, !13, i64 1640, !13, i64 1644, !177, i64 1648, !21, i64 1656, !178, i64 1664, !4, i64 1848, !4, i64 1856, !4, i64 1864, !4, i64 1872, !4, i64 1880, !180, i64 1888, !180, i64 1896, !180, i64 1904, !181, i64 1912, !21, i64 1936, !21, i64 1944, !4, i64 1952, !4, i64 1960, !4, i64 1968, !4, i64 1976, !4, i64 1984, !13, i64 1992, !13, i64 1996, !182, i64 2000, !13, i64 2016, !13, i64 2020, !19, i64 2024, !183, i64 2096, !185, i64 2168, !4, i64 2184, !4, i64 2192, !13, i64 2200, !21, i64 2208, !21, i64 2216, !13, i64 2224, !13, i64 2228, !13, i64 2232, !13, i64 2236, !21, i64 2240, !21, i64 2248, !13, i64 2256, !13, i64 2260, !13, i64 2264, !13, i64 2268, !62, i64 2272, !13, i64 2280, !13, i64 2284, !5, i64 2288, !13, i64 4976, !4, i64 4984, !4, i64 4992, !4, i64 5000, !4, i64 5008, !4, i64 5016, !4, i64 5024, !21, i64 5032, !4, i64 5040, !186, i64 5048, !62, i64 5104, !62, i64 5112, !21, i64 5120, !180, i64 5128, !187, i64 5256, !13, i64 5260, !13, i64 5264, !4, i64 5272, !16, i64 5280, !4, i64 5296, !4, i64 5304, !16, i64 5312, !4, i64 5328, !5, i64 5336, !17, i64 5352, !16, i64 5520, !4, i64 5536, !22, i64 5544, !22, i64 5546, !13, i64 5548, !13, i64 5552, !13, i64 5556, !62, i64 5560, !188, i64 5568, !188, i64 5584, !4, i64 5600, !189, i64 5608, !4, i64 5624, !13, i64 5632, !13, i64 5636, !13, i64 5640, !21, i64 5648, !13, i64 5656, !5, i64 5664, !21, i64 9504, !21, i64 9512, !13, i64 9520, !4, i64 9528, !62, i64 9536, !18, i64 9544, !18, i64 9548, !21, i64 9552, !21, i64 9560, !190, i64 9568, !13, i64 9600, !18, i64 9604, !4, i64 9608, !13, i64 9616, !13, i64 9620}
!165 = !{!"llist_node", !4, i64 0}
!166 = !{!"sched_entity", !167, i64 0, !168, i64 16, !16, i64 40, !13, i64 56, !62, i64 64, !62, i64 72, !62, i64 80, !62, i64 88, !62, i64 96, !169, i64 104, !4, i64 320, !4, i64 328, !4, i64 336, !170, i64 344}
!167 = !{!"load_weight", !21, i64 0, !21, i64 8}
!168 = !{!"rb_node", !21, i64 0, !4, i64 8, !4, i64 16}
!169 = !{!"sched_statistics", !62, i64 0, !62, i64 8, !62, i64 16, !62, i64 24, !62, i64 32, !62, i64 40, !62, i64 48, !62, i64 56, !62, i64 64, !62, i64 72, !62, i64 80, !62, i64 88, !62, i64 96, !62, i64 104, !62, i64 112, !62, i64 120, !62, i64 128, !62, i64 136, !62, i64 144, !62, i64 152, !62, i64 160, !62, i64 168, !62, i64 176, !62, i64 184, !62, i64 192, !62, i64 200, !62, i64 208}
!170 = !{!"sched_avg", !13, i64 0, !13, i64 4, !62, i64 8, !62, i64 16, !21, i64 24}
!171 = !{!"sched_rt_entity", !16, i64 0, !21, i64 16, !21, i64 24, !13, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64}
!172 = !{!"cpumask", !5, i64 0}
!173 = !{!"sched_info", !21, i64 0, !62, i64 8, !62, i64 16, !62, i64 24}
!174 = !{!"plist_node", !13, i64 0, !16, i64 8, !16, i64 24}
!175 = !{!"cputime", !21, i64 0, !21, i64 8}
!176 = !{!"task_cputime", !21, i64 0, !21, i64 8, !62, i64 16}
!177 = !{!"sysv_sem", !4, i64 0}
!178 = !{!"thread_struct", !5, i64 0, !21, i64 24, !21, i64 32, !21, i64 40, !22, i64 48, !22, i64 50, !22, i64 52, !22, i64 54, !21, i64 56, !21, i64 64, !5, i64 72, !21, i64 104, !21, i64 112, !21, i64 120, !21, i64 128, !21, i64 136, !179, i64 144, !4, i64 160, !21, i64 168, !13, i64 176}
!179 = !{!"fpu", !13, i64 0, !13, i64 4, !4, i64 8}
!180 = !{!"", !5, i64 0}
!181 = !{!"sigpending", !16, i64 0, !180, i64 16}
!182 = !{!"seccomp", !13, i64 0, !4, i64 8}
!183 = !{!"raw_spinlock", !184, i64 0, !13, i64 4, !13, i64 8, !4, i64 16, !20, i64 24}
!184 = !{!"arch_spinlock", !5, i64 0}
!185 = !{!"plist_head", !16, i64 0}
!186 = !{!"task_io_accounting", !62, i64 0, !62, i64 8, !62, i64 16, !62, i64 24, !62, i64 32, !62, i64 40, !62, i64 48}
!187 = !{!"seqcount", !13, i64 0}
!188 = !{!"callback_head", !4, i64 0, !4, i64 8}
!189 = !{!"page_frag", !4, i64 0, !13, i64 8, !13, i64 12}
!190 = !{!"memcg_batch_info", !13, i64 0, !4, i64 8, !21, i64 16, !21, i64 24}
!191 = !{i32 434035, i32 434046}
!192 = !{!193, !4, i64 0}
!193 = !{!"poll_table_struct", !4, i64 0, !21, i64 8}
!194 = !{!62, !62, i64 0}
!195 = !{!22, !22, i64 0}
!196 = !{!197, !13, i64 0}
!197 = !{!"acpi_object_list", !13, i64 0, !4, i64 8}
!198 = !{!197, !4, i64 8}
!199 = !{!15, !5, i64 248}
!200 = !{i32 -2146109018, i32 -2146108979, i32 -2146108958, i32 -2146108921, i32 -2146108898, i32 -2146109028}
!201 = !{!202, !4, i64 0}
!202 = !{!"sony_nc_value", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !13, i64 32, !13, i64 36, !13, i64 40, !203, i64 48}
!203 = !{!"device_attribute", !204, i64 0, !4, i64 32, !4, i64 40}
!204 = !{!"attribute", !4, i64 0, !22, i64 8, !72, i64 10, !4, i64 16, !205, i64 24}
!205 = !{!"lock_class_key", !5, i64 0}
!206 = !{!202, !13, i64 40}
!207 = !{!202, !4, i64 8}
!208 = !{!202, !22, i64 56}
!209 = !{!202, !4, i64 16}
!210 = !{!204, !4, i64 16}
!211 = !{!212, !4, i64 32}
!212 = !{!"sony_nc_handles", !5, i64 0, !203, i64 32}
!213 = !{!212, !22, i64 40}
!214 = !{!212, !4, i64 64}
!215 = !{!157, !13, i64 12}
!216 = !{!157, !5, i64 17}
!217 = !{!157, !5, i64 16}
!218 = !{!160, !5, i64 16}
!219 = !{!160, !13, i64 4}
!220 = !{!221, !4, i64 16}
!221 = !{!"backlight_ops", !13, i64 0, !4, i64 8, !4, i64 16, !4, i64 24}
!222 = !{!223, !13, i64 48}
!223 = !{!"touchpad_control", !203, i64 0, !13, i64 48}
!224 = !{!223, !4, i64 0}
!225 = !{!223, !22, i64 8}
!226 = !{!223, !4, i64 32}
!227 = !{!223, !4, i64 40}
!228 = !{!229, !13, i64 96}
!229 = !{!"battery_care_control", !5, i64 0, !13, i64 96}
!230 = !{!203, !4, i64 0}
!231 = !{!203, !22, i64 8}
!232 = !{!203, !4, i64 32}
!233 = !{!203, !4, i64 40}
!234 = !{!235, !13, i64 144}
!235 = !{!"snc_lid_resume_control", !5, i64 0, !13, i64 144}
!236 = !{!237, !13, i64 0}
!237 = !{!"snc_thermal_ctrl", !13, i64 0, !13, i64 4, !203, i64 8, !203, i64 56}
!238 = !{!237, !4, i64 56}
!239 = !{!237, !22, i64 64}
!240 = !{!237, !4, i64 88}
!241 = !{!237, !4, i64 8}
!242 = !{!237, !22, i64 16}
!243 = !{!237, !4, i64 40}
!244 = !{!237, !4, i64 48}
!245 = !{!246, !13, i64 48}
!246 = !{!"snc_gfx_switch_control", !203, i64 0, !13, i64 48}
!247 = !{!246, !4, i64 0}
!248 = !{!246, !22, i64 8}
!249 = !{!246, !4, i64 32}
!250 = !{!251, !13, i64 0}
!251 = !{!"kbd_backlight", !13, i64 0, !13, i64 4, !13, i64 8, !13, i64 12, !203, i64 16, !203, i64 64}
!252 = !{!251, !13, i64 4}
!253 = !{!251, !4, i64 16}
!254 = !{!251, !22, i64 24}
!255 = !{!251, !4, i64 48}
!256 = !{!251, !4, i64 56}
!257 = !{!251, !4, i64 64}
!258 = !{!251, !22, i64 72}
!259 = !{!251, !4, i64 96}
!260 = !{!251, !4, i64 104}
!261 = !{!237, !13, i64 4}
!262 = !{!251, !13, i64 8}
!263 = !{!251, !13, i64 12}
!264 = !{!157, !13, i64 8}
!265 = !{!202, !4, i64 24}
!266 = !{!202, !13, i64 32}
!267 = !{!202, !13, i64 36}
!268 = !{!269, !5, i64 0}
!269 = !{!"sony_nc_event", !5, i64 0, !5, i64 1}
!270 = !{!269, !5, i64 1}
!271 = !{!67, !4, i64 80}
!272 = !{!68, !4, i64 0}
