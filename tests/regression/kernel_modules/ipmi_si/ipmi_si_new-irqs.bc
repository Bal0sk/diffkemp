; ModuleID = 'tests/regression/kernel_modules/ipmi_si/ipmi_si_new.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %union.anon.3, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.0, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %union.anon.3, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %struct.qspinlock, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.3, %union.anon.3, %union.anon.0, %union.anon.3, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.atomic_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %union.anon.3, %struct.list_head, %struct.raw_spinlock, %struct.qspinlock, %struct.task_struct*, %struct.lockdep_map }
%struct.task_struct = type { %union.anon.3, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %union.anon.0, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.atomic_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %union.anon.3*, %struct.atomic_t, %struct.atomic_t, %union.anon.3, %union.anon.3, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %union.anon.3, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %union.anon.3, i64, %struct.timerqueue_node, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.mm_rss_stat = type { [4 x %union.anon.3] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.12 }
%union.anon.12 = type { %struct.anon.16, [80 x i8] }
%struct.anon.16 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.22, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.22 = type { %struct.anon.23 }
%struct.anon.23 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %union.anon.3, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.timespec }
%struct.timespec = type { i64, i64 }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %union.anon.3* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %union.anon.3, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.0 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.atomic_t, %struct.atomic_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.2, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.bdi_writeback = type opaque
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type opaque
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.3 = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.atomic_t, %struct.atomic_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.3, i64, %struct.atomic_t, %struct.atomic_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.3, i64, i64, i64, %union.anon.3, %struct.key*, %struct.key*, %struct.hlist_node, %struct.atomic_t, %union.anon.3 }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.atomic_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %union.anon.3*, %union.anon.3*, %union.anon.3, %struct.page*, %struct.mem_cgroup*, %struct.page*, %union.anon.3*, %struct.spinlock*, %struct.page* }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.qspinlock }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %union.anon.3, %struct.spinlock, %struct.qspinlock, %struct.list_head, i8*, %struct.lockdep_map }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.qspinlock, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.51 = type { i8* }
%struct.kparam_string = type { i32, i8* }
%struct.kparam_array = type { i32, i32, i32*, %struct.kernel_param_ops*, i8* }
%struct.hotmod_vals = type { i8*, i32 }
%struct.atomic_notifier_head = type { %struct.spinlock, %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.platform_driver = type { i32 (%struct.platform_device*)*, i32 (%struct.platform_device*)*, void (%struct.platform_device*)*, i32 (%struct.platform_device*, i32)*, i32 (%struct.platform_device*)*, %struct.device_driver, %struct.platform_device_id*, i8 }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, i8*, %struct.mfd_cell*, %struct.mod_arch_specific }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %union.anon.51, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.atomic_t, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type { %struct.list_head, i8*, %struct.irq_domain_ops*, i8*, i32, %struct.fwnode_handle*, i32, %struct.irq_domain_chip_generic*, %struct.irq_domain*, i64, i32, i32, %struct.radix_tree_root, [0 x i32] }
%struct.irq_domain_ops = type { i32 (%struct.irq_domain*, %struct.device_node*, i32)*, i32 (%struct.irq_domain*, %struct.irq_fwspec*, i32)*, i32 (%struct.irq_domain*, i32, i64)*, void (%struct.irq_domain*, i32)*, i32 (%struct.irq_domain*, %struct.device_node*, i32*, i32, i64*, i32*)*, i32 (%struct.irq_domain*, i32, i32, i8*)*, void (%struct.irq_domain*, i32, i32)*, void (%struct.irq_domain*, %struct.irq_data*)*, void (%struct.irq_domain*, %struct.irq_data*)*, i32 (%struct.irq_domain*, %struct.irq_fwspec*, i64*, i32*)* }
%struct.irq_fwspec = type { %struct.fwnode_handle*, i32, [16 x i32] }
%struct.irq_data = type { i32, i32, i64, %struct.irq_common_data*, %struct.irq_chip*, %struct.irq_domain*, %struct.irq_data*, i8* }
%struct.irq_common_data = type { i32, i32, i8*, %struct.msi_desc*, %struct.cpumask* }
%struct.msi_desc = type opaque
%struct.irq_chip = type { %struct.device*, i8*, i32 (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, i32 (%struct.irq_data*, %struct.cpumask*, i1)*, i32 (%struct.irq_data*)*, i32 (%struct.irq_data*, i32)*, i32 (%struct.irq_data*, i32)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*, %struct.seq_file*)*, i32 (%struct.irq_data*)*, void (%struct.irq_data*)*, void (%struct.irq_data*, %struct.msi_msg*)*, void (%struct.irq_data*, %struct.msi_msg*)*, i32 (%struct.irq_data*, i32, i8*)*, i32 (%struct.irq_data*, i32, i1)*, i32 (%struct.irq_data*, i8*)*, void (%struct.irq_data*, i32)*, void (%struct.irq_data*, %struct.cpumask*)*, i64 }
%struct.msi_msg = type opaque
%struct.irq_domain_chip_generic = type { i32, i32, i32, i32, i32, [0 x %struct.irq_chip_generic*] }
%struct.irq_chip_generic = type { %struct.raw_spinlock, i8*, i32 (i8*)*, void (i32, i8*)*, void (%struct.irq_chip_generic*)*, void (%struct.irq_chip_generic*)*, i32, i32, i32, i32, i32, i32, i32, i32, i8*, i64, i64, %struct.irq_domain*, %struct.list_head, [0 x %struct.irq_chip_type] }
%struct.irq_chip_type = type { %struct.irq_chip, %struct.task_io_accounting, void (%struct.irq_desc*)*, i32, i32, i32* }
%struct.irq_desc = type { %struct.irq_common_data, %struct.irq_data, i32*, {}*, %struct.irqaction*, i32, i32, i32, i32, i32, i64, i32, %struct.atomic_t, i32, %struct.raw_spinlock, %struct.cpumask*, %struct.cpumask*, %struct.cpumask*, %struct.irq_affinity_notify*, %struct.cpumask*, i64, %struct.atomic_t, %struct.__wait_queue_head, i32, i32, i32, i32, %struct.proc_dir_entry*, %struct.callback_head, %struct.kobject, i32, %struct.module*, i8*, [3392 x i8] }
%struct.irqaction = type { i32 (i32, i8*)*, i8*, i8*, %struct.irqaction*, i32 (i32, i8*)*, %struct.task_struct*, %struct.irqaction*, i32, i32, i64, i64, i8*, %struct.proc_dir_entry*, [4000 x i8] }
%struct.irq_affinity_notify = type { i32, %struct.kref, %struct.work_struct, void (%struct.irq_affinity_notify*, %struct.cpumask*)*, void (%struct.kref*)* }
%struct.proc_dir_entry = type opaque
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.fwnode_handle, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.kobject, i64, i8* }
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32, %struct.bin_attribute }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.resource = type { i64, i64, i8*, i64, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.mfd_cell = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.ipmi_smi_handlers = type { %struct.module*, i32 (i8*, %struct.ipmi_smi*)*, i32 (i8*, %struct.ipmi_smi_info*)*, void (i8*, %struct.ipmi_smi_msg*)*, void (i8*)*, void (i8*, i1)*, void (i8*)*, void (i8*, i1)*, void (i8*)*, void (i8*, i1)*, i32 (i8*)*, void (i8*)* }
%struct.ipmi_smi = type opaque
%struct.ipmi_smi_info = type { i32, %struct.device*, %union.ipmi_smi_info_union }
%union.ipmi_smi_info_union = type { %union.anon.51 }
%struct.ipmi_smi_msg = type { %struct.list_head, i64, i8*, i32, [272 x i8], i32, [272 x i8], void (%struct.ipmi_smi_msg*)* }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.__wait_queue_head }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i16, i8, i8, i8, i8, i8, i8, i16, [4 x i8], i64*, %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, [3 x i8], i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, i32, i8, i16, %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], i8, i8, [6 x i8], %struct.attribute_group**, %struct.pci_vpd*, %union.anon.72, i16, i8, i8, %struct.atomic_t, i64, i64, i8* }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, %struct.msi_controller*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.pci_ops = type { i32 (%struct.pci_bus*)*, void (%struct.pci_bus*)*, i8* (%struct.pci_bus*, i32, i32)*, i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.msi_controller = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.72 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*, i1)*, void (%struct.pci_dev*)* }
%struct.si_sm_handlers = type { i8*, i32 (%struct.si_sm_data*, %struct.si_sm_io*)*, i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*)*, void (%struct.si_sm_data*)*, i32 ()* }
%struct.si_sm_data = type { i32, %struct.si_sm_io*, [272 x i8], i32, i32, i32, [272 x i8], i32, i32, i32, i64, i64, i64 }
%struct.si_sm_io = type { i8 (%struct.si_sm_io*, i32)*, void (%struct.si_sm_io*, i32, i8)*, i8*, i32, i32, i32, i32, i64 }
%struct.si_sm_handlers.178 = type { i8*, i32 (%struct.si_sm_data.179*, %struct.si_sm_io*)*, i32 (%struct.si_sm_data.179*, i8*, i32)*, i32 (%struct.si_sm_data.179*, i8*, i32)*, i32 (%struct.si_sm_data.179*, i64)*, i32 (%struct.si_sm_data.179*)*, void (%struct.si_sm_data.179*)*, i32 ()* }
%struct.si_sm_data.179 = type { i32, %struct.si_sm_io*, [80 x i8], i32, i32, i32, [80 x i8], i32, i32, i32, i64 }
%struct.si_sm_handlers.268 = type { i8*, i32 (%struct.si_sm_data.269*, %struct.si_sm_io*)*, i32 (%struct.si_sm_data.269*, i8*, i32)*, i32 (%struct.si_sm_data.269*, i8*, i32)*, i32 (%struct.si_sm_data.269*, i64)*, i32 (%struct.si_sm_data.269*)*, void (%struct.si_sm_data.269*)*, i32 ()* }
%struct.si_sm_data.269 = type { i32, i8, %struct.si_sm_io*, [274 x i8], i32, [274 x i8], i32, i32, i64, i32, i32, i32, i32, i64, i32 }
%struct.smi_info = type { i32, %struct.ipmi_smi*, %struct.si_sm_data*, %struct.si_sm_handlers*, i32, %struct.spinlock, %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg*, i32, %struct.si_sm_io, i32 (%struct.smi_info*)*, void (%struct.smi_info*)*, i32 (%struct.smi_info*)*, void (%struct.smi_info*)*, i32, i32, void (%struct.smi_info*)*, i8*, i32 (%struct.smi_info*)*, i8, i8, %struct.atomic_t, i8, i32, i32, i32, %struct.timer_list, i8, i64, %struct.atomic_t, i8, i8, i8, i8, i8, %struct.ipmi_device_id, %struct.device*, %struct.platform_device*, i8, i8, [11 x %struct.atomic_t], %struct.task_struct*, %struct.list_head, %union.ipmi_smi_info_union }
%struct.ipmi_device_id = type { i8, i8, i8, i8, i8, i8, i32, i32, [4 x i8], i8 }
%union.anon.71 = type { %struct.list_head* }
%struct._ddebug = type { i8*, i8*, i8*, i8*, i32 }
%struct.acpi_device = type { i32, i8*, %struct.fwnode_handle, %struct.acpi_device*, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.atomic_t, %struct.atomic_t, %struct.acpi_device_pnp, %struct.acpi_device_power, %struct.acpi_device_wakeup, %struct.acpi_device_perf, %struct.acpi_device_dir, %struct.acpi_device_data, %struct.acpi_scan_handler*, %struct.acpi_hotplug_context*, %struct.acpi_driver*, %struct.acpi_gpio_mapping*, i8*, %struct.device, i32, i32, %struct.list_head, %struct.mutex, void (%struct.acpi_device*)* }
%struct.acpi_device_pnp = type { [8 x i8], %struct.atomic_t, i64, i8*, %struct.list_head, [40 x i8], [20 x i8], %union.acpi_object* }
%union.acpi_object = type { %struct.anon.67 }
%struct.anon.67 = type { i32, i32, i64, i32 }
%struct.acpi_device_power = type { i32, %struct.atomic_t, [5 x %struct.acpi_device_power_state] }
%struct.acpi_device_power_state = type { %struct.lockdep_subclass_key, i32, i32, %struct.list_head }
%struct.acpi_device_wakeup = type { i8*, i64, i64, %struct.list_head, %struct.lockdep_subclass_key, %struct.acpi_device_wakeup_context, %struct.wakeup_source*, i32 }
%struct.acpi_device_wakeup_context = type { %struct.work_struct, %struct.device* }
%struct.acpi_device_perf = type { i32, %struct.lockdep_subclass_key, i32, %struct.acpi_device_perf_state* }
%struct.acpi_device_perf_state = type { %struct.lockdep_subclass_key, i8, i8, i32 }
%struct.acpi_device_dir = type { %struct.proc_dir_entry* }
%struct.acpi_device_data = type { %union.acpi_object*, %union.acpi_object*, %union.acpi_object*, %struct.list_head }
%struct.acpi_scan_handler = type { %struct.acpi_device_id*, %struct.list_head, i1 (i8*, %struct.acpi_device_id**)*, i32 (%struct.acpi_device*, %struct.acpi_device_id*)*, void (%struct.acpi_device*)*, void (%struct.device*)*, void (%struct.device*)*, %struct.acpi_hotplug_profile }
%struct.acpi_hotplug_profile = type { %struct.kobject, i32 (%struct.acpi_device*)*, void (%struct.acpi_device*)*, i8 }
%struct.acpi_hotplug_context = type { %struct.acpi_device*, i32 (%struct.acpi_device*, i32)*, void (%struct.acpi_device*, i32)*, void (%struct.acpi_device*)* }
%struct.acpi_driver = type { [80 x i8], [80 x i8], %struct.acpi_device_id*, i32, %struct.acpi_device_ops, %struct.device_driver, %struct.module* }
%struct.acpi_device_ops = type { i32 (%struct.acpi_device*)*, i32 (%struct.acpi_device*)*, void (%struct.acpi_device*, i32)* }
%struct.acpi_gpio_mapping = type { i8*, %struct.acpi_gpio_params*, i32 }
%struct.acpi_gpio_params = type { i32, i32, i8 }
%struct.acpi_object_list = type { i32, %union.acpi_object* }
%struct.dmi_ipmi_data = type { i8, i8, i64, i8, i8, i8 }
%struct.dmi_device = type { %struct.list_head, i32, i8*, i8* }
%struct.dmi_header = type { i8, i8, i16 }
%struct.SPMITable = type { [4 x i8], i32, i8, i8, [6 x i8], [8 x i8], [4 x i8], [4 x i8], [4 x i8], i8, i8, i16, i8, i8, i16, i32, %struct.acpi_generic_address, [4 x i8], [1 x i8] }
%struct.acpi_generic_address = type <{ i8, i8, i8, i8, i64 }>
%struct.acpi_table_header = type { [4 x i8], i32, i8, i8, [6 x i8], [8 x i8], i32, [4 x i8], i32 }

@llvm.used = appending global [59 x i8*] [i8* bitcast (%struct.kernel_param* @__param_hotmod to i8*), i8* getelementptr inbounds ([111 x i8], [111 x i8]* @__UNIQUE_ID_hotmod12, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_tryacpi to i8*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__UNIQUE_ID_tryacpitype13, i32 0, i32 0), i8* getelementptr inbounds ([102 x i8], [102 x i8]* @__UNIQUE_ID_tryacpi14, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_trydmi to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_trydmitype15, i32 0, i32 0), i8* getelementptr inbounds ([100 x i8], [100 x i8]* @__UNIQUE_ID_trydmi16, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_tryplatform to i8*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__UNIQUE_ID_tryplatformtype17, i32 0, i32 0), i8* getelementptr inbounds ([139 x i8], [139 x i8]* @__UNIQUE_ID_tryplatform18, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_trypci to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_trypcitype19, i32 0, i32 0), i8* getelementptr inbounds ([100 x i8], [100 x i8]* @__UNIQUE_ID_trypci20, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_string* } }* @__param_type to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_typetype21, i32 0, i32 0), i8* getelementptr inbounds ([207 x i8], [207 x i8]* @__UNIQUE_ID_type22, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_addrs to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_addrstype23, i32 0, i32 0), i8* getelementptr inbounds ([175 x i8], [175 x i8]* @__UNIQUE_ID_addrs24, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_ports to i8*), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__UNIQUE_ID_portstype25, i32 0, i32 0), i8* getelementptr inbounds ([170 x i8], [170 x i8]* @__UNIQUE_ID_ports26, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_irqs to i8*), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__UNIQUE_ID_irqstype27, i32 0, i32 0), i8* getelementptr inbounds ([173 x i8], [173 x i8]* @__UNIQUE_ID_irqs28, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_regspacings to i8*), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__UNIQUE_ID_regspacingstype29, i32 0, i32 0), i8* getelementptr inbounds ([235 x i8], [235 x i8]* @__UNIQUE_ID_regspacings30, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_regsizes to i8*), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_regsizestype31, i32 0, i32 0), i8* getelementptr inbounds ([232 x i8], [232 x i8]* @__UNIQUE_ID_regsizes32, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_regshifts to i8*), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__UNIQUE_ID_regshiftstype33, i32 0, i32 0), i8* getelementptr inbounds ([197 x i8], [197 x i8]* @__UNIQUE_ID_regshifts34, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_slave_addrs to i8*), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__UNIQUE_ID_slave_addrstype35, i32 0, i32 0), i8* getelementptr inbounds ([179 x i8], [179 x i8]* @__UNIQUE_ID_slave_addrs36, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_force_kipmid to i8*), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__UNIQUE_ID_force_kipmidtype37, i32 0, i32 0), i8* getelementptr inbounds ([166 x i8], [166 x i8]* @__UNIQUE_ID_force_kipmid38, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_unload_when_empty to i8*), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__UNIQUE_ID_unload_when_emptytype39, i32 0, i32 0), i8* getelementptr inbounds ([157 x i8], [157 x i8]* @__UNIQUE_ID_unload_when_empty40, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_kipmid_max_busy_us to i8*), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @__UNIQUE_ID_kipmid_max_busy_ustype41, i32 0, i32 0), i8* getelementptr inbounds ([186 x i8], [186 x i8]* @__UNIQUE_ID_kipmid_max_busy_us42, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license43, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @__UNIQUE_ID_author44, i32 0, i32 0), i8* getelementptr inbounds ([86 x i8], [86 x i8]* @__UNIQUE_ID_description45, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_kcs_debug to i8*), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__UNIQUE_ID_kcs_debugtype8, i32 0, i32 0), i8* getelementptr inbounds ([61 x i8], [61 x i8]* @__UNIQUE_ID_kcs_debug9, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_smic_debug to i8*), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__UNIQUE_ID_smic_debugtype8, i32 0, i32 0), i8* getelementptr inbounds ([62 x i8], [62 x i8]* @__UNIQUE_ID_smic_debug9, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_bt_debug to i8*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__UNIQUE_ID_bt_debugtype8, i32 0, i32 0), i8* getelementptr inbounds ([60 x i8], [60 x i8]* @__UNIQUE_ID_bt_debug9, i32 0, i32 0)], section "llvm.metadata"
@__param_hotmod = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_hotmod, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @__param_ops_hotmod, i16 128, i8 -1, i8 0, %union.anon.51 zeroinitializer }, section "__param", align 8
@__UNIQUE_ID_hotmod12 = internal constant [111 x i8] c"parm=hotmod:Add and remove interfaces.  See Documentation/IPMI.txt in the kernel sources for the gory details.\00", section ".modinfo", align 1
@__param_tryacpi = internal constant %struct.kernel_param { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @__param_str_tryacpi, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 0, i8 -1, i8 0, %union.anon.51 { i8* @si_tryacpi } }, section "__param", align 8
@__UNIQUE_ID_tryacpitype13 = internal constant [22 x i8] c"parmtype=tryacpi:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_tryacpi14 = internal constant [102 x i8] c"parm=tryacpi:Setting this to zero will disable the default scan of the interfaces identified via ACPI\00", section ".modinfo", align 1
@__param_trydmi = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_trydmi, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 0, i8 -1, i8 0, %union.anon.51 { i8* @si_trydmi } }, section "__param", align 8
@__UNIQUE_ID_trydmitype15 = internal constant [21 x i8] c"parmtype=trydmi:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_trydmi16 = internal constant [100 x i8] c"parm=trydmi:Setting this to zero will disable the default scan of the interfaces identified via DMI\00", section ".modinfo", align 1
@__param_tryplatform = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_tryplatform, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 0, i8 -1, i8 0, %union.anon.51 { i8* @si_tryplatform } }, section "__param", align 8
@__UNIQUE_ID_tryplatformtype17 = internal constant [26 x i8] c"parmtype=tryplatform:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_tryplatform18 = internal constant [139 x i8] c"parm=tryplatform:Setting this to zero will disable the default scan of the interfaces identified via platform interfaces like openfirmware\00", section ".modinfo", align 1
@__param_trypci = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_trypci, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 0, i8 -1, i8 0, %union.anon.51 { i8* @si_trypci } }, section "__param", align 8
@__UNIQUE_ID_trypcitype19 = internal constant [21 x i8] c"parmtype=trypci:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_trypci20 = internal constant [100 x i8] c"parm=trypci:Setting this to zero will disable the default scan of the interfaces identified via pci\00", section ".modinfo", align 1
@__param_type = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_string* } } { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_string, i16 0, i8 -1, i8 0, { %struct.kparam_string* } { %struct.kparam_string* @__param_string_type } }, section "__param", align 8
@__UNIQUE_ID_typetype21 = internal constant [21 x i8] c"parmtype=type:string\00", section ".modinfo", align 1
@__UNIQUE_ID_type22 = internal constant [207 x i8] c"parm=type:Defines the type of each interface, each interface separated by commas.  The types are 'kcs', 'smic', and 'bt'.  For example si_type=kcs,bt will set the first interface to kcs and the second to bt\00", section ".modinfo", align 1
@__param_addrs = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_addrs, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 0, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_addrs } }, section "__param", align 8
@__UNIQUE_ID_addrstype23 = internal constant [30 x i8] c"parmtype=addrs:array of ulong\00", section ".modinfo", align 1
@__UNIQUE_ID_addrs24 = internal constant [175 x i8] c"parm=addrs:Sets the memory address of each interface, the addresses separated by commas.  Only use if an interface is in memory.  Otherwise, set it to zero or leave it blank.\00", section ".modinfo", align 1
@__param_ports = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_ports, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 0, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_ports } }, section "__param", align 8
@__UNIQUE_ID_portstype25 = internal constant [29 x i8] c"parmtype=ports:array of uint\00", section ".modinfo", align 1
@__UNIQUE_ID_ports26 = internal constant [170 x i8] c"parm=ports:Sets the port address of each interface, the addresses separated by commas.  Only use if an interface is a port.  Otherwise, set it to zero or leave it blank.\00", section ".modinfo", align 1
@__param_irqs = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @__param_str_irqs, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 0, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_irqs } }, section "__param", align 8
@__UNIQUE_ID_irqstype27 = internal constant [27 x i8] c"parmtype=irqs:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_irqs28 = internal constant [173 x i8] c"parm=irqs:Sets the interrupt of each interface, the addresses separated by commas.  Only use if an interface has an interrupt.  Otherwise, set it to zero or leave it blank.\00", section ".modinfo", align 1
@__param_regspacings = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_regspacings, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 0, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_regspacings } }, section "__param", align 8
@__UNIQUE_ID_regspacingstype29 = internal constant [34 x i8] c"parmtype=regspacings:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_regspacings30 = internal constant [235 x i8] c"parm=regspacings:The number of bytes between the start address and each successive register used by the interface.  For instance, if the start address is 0xca2 and the spacing is 2, then the second address is at 0xca4.  Defaults to 1.\00", section ".modinfo", align 1
@__param_regsizes = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_regsizes, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 0, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_regsizes } }, section "__param", align 8
@__UNIQUE_ID_regsizestype31 = internal constant [31 x i8] c"parmtype=regsizes:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_regsizes32 = internal constant [232 x i8] c"parm=regsizes:The size of the specific IPMI register in bytes. This should generally be 1, 2, 4, or 8 for an 8-bit, 16-bit, 32-bit, or 64-bit register.  Use this if you the 8-bit IPMI register has to be read from a larger register.\00", section ".modinfo", align 1
@__param_regshifts = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_regshifts, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 0, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_regshifts } }, section "__param", align 8
@__UNIQUE_ID_regshiftstype33 = internal constant [32 x i8] c"parmtype=regshifts:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_regshifts34 = internal constant [197 x i8] c"parm=regshifts:The amount to shift the data read from the. IPMI register, in bits.  For instance, if the data is read from a 32-bit word and the IPMI data is in bit 8-15, then the shift would be 8\00", section ".modinfo", align 1
@__param_slave_addrs = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_slave_addrs, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 0, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_slave_addrs } }, section "__param", align 8
@__UNIQUE_ID_slave_addrstype35 = internal constant [34 x i8] c"parmtype=slave_addrs:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_slave_addrs36 = internal constant [179 x i8] c"parm=slave_addrs:Set the default IPMB slave address for the controller.  Normally this is 0x20, but can be overridden by this parm.  This is an array indexed by interface number.\00", section ".modinfo", align 1
@__param_force_kipmid = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__param_str_force_kipmid, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 0, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_force_kipmid } }, section "__param", align 8
@__UNIQUE_ID_force_kipmidtype37 = internal constant [35 x i8] c"parmtype=force_kipmid:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_force_kipmid38 = internal constant [166 x i8] c"parm=force_kipmid:Force the kipmi daemon to be enabled (1) or disabled(0).  Normally the IPMI driver auto-detects this, but the value may be overridden by this parm.\00", section ".modinfo", align 1
@__param_unload_when_empty = internal constant %struct.kernel_param { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__param_str_unload_when_empty, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 0, i8 -1, i8 0, %union.anon.51 { i8* @unload_when_empty } }, section "__param", align 8
@__UNIQUE_ID_unload_when_emptytype39 = internal constant [32 x i8] c"parmtype=unload_when_empty:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_unload_when_empty40 = internal constant [157 x i8] c"parm=unload_when_empty:Unload the module if no interfaces are specified or found, default is 1.  Setting to 0 is useful for hot add of devices using hotmod.\00", section ".modinfo", align 1
@__param_kipmid_max_busy_us = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__param_str_kipmid_max_busy_us, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 420, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_kipmid_max_busy_us } }, section "__param", align 8
@__UNIQUE_ID_kipmid_max_busy_ustype41 = internal constant [42 x i8] c"parmtype=kipmid_max_busy_us:array of uint\00", section ".modinfo", align 1
@__UNIQUE_ID_kipmid_max_busy_us42 = internal constant [186 x i8] c"parm=kipmid_max_busy_us:Max time (in microseconds) to busy-wait for IPMI data before sleeping. 0 (default) means to wait forever. Set to 100-500 if kipmid is using up a lot of CPU time.\00", section ".modinfo", align 1
@__UNIQUE_ID_license43 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__UNIQUE_ID_author44 = internal constant [42 x i8] c"author=Corey Minyard <minyard@mvista.com>\00", section ".modinfo", align 1
@__UNIQUE_ID_description45 = internal constant [86 x i8] c"description=Interface to the IPMI driver for the KCS, SMIC, and BT system interfaces.\00", section ".modinfo", align 1
@__param_str_kipmid_max_busy_us = internal constant [19 x i8] c"kipmid_max_busy_us\00", align 16
@__this_module = external global %struct.module, align 64
@param_array_ops = external constant %struct.kernel_param_ops, align 8
@__param_arr_kipmid_max_busy_us = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_max_busy_us, %struct.kernel_param_ops* @param_ops_uint, i8* bitcast ([4 x i32]* @kipmid_max_busy_us to i8*) }, align 8
@num_max_busy_us = internal global i32 0, align 4
@param_ops_uint = external constant %struct.kernel_param_ops, align 8
@kipmid_max_busy_us = internal global [4 x i32] zeroinitializer, align 16
@__param_str_unload_when_empty = internal constant [18 x i8] c"unload_when_empty\00", align 16
@param_ops_bool = external constant %struct.kernel_param_ops, align 8
@unload_when_empty = internal global i8 1, align 1
@__param_str_force_kipmid = internal constant [13 x i8] c"force_kipmid\00", align 1
@__param_arr_force_kipmid = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_force_kipmid, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @force_kipmid to i8*) }, align 8
@num_force_kipmid = internal global i32 0, align 4
@param_ops_int = external constant %struct.kernel_param_ops, align 8
@force_kipmid = internal global [4 x i32] zeroinitializer, align 16
@__param_str_slave_addrs = internal constant [12 x i8] c"slave_addrs\00", align 1
@__param_arr_slave_addrs = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_slave_addrs, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @slave_addrs to i8*) }, align 8
@num_slave_addrs = internal global i32 0, align 4
@slave_addrs = internal global [4 x i32] zeroinitializer, align 16
@__param_str_regshifts = internal constant [10 x i8] c"regshifts\00", align 1
@__param_arr_regshifts = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_regshifts, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @regshifts to i8*) }, align 8
@num_regshifts = internal global i32 0, align 4
@regshifts = internal global [4 x i32] zeroinitializer, align 16
@__param_str_regsizes = internal constant [9 x i8] c"regsizes\00", align 1
@__param_arr_regsizes = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_regsizes, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @regsizes to i8*) }, align 8
@num_regsizes = internal global i32 0, align 4
@regsizes = internal global [4 x i32] zeroinitializer, align 16
@__param_str_regspacings = internal constant [12 x i8] c"regspacings\00", align 1
@__param_arr_regspacings = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_regspacings, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @regspacings to i8*) }, align 8
@num_regspacings = internal global i32 0, align 4
@regspacings = internal global [4 x i32] zeroinitializer, align 16
@__param_str_irqs = internal constant [5 x i8] c"irqs\00", align 1
@__param_arr_irqs = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_irqs, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @irqs to i8*) }, align 8
@num_irqs = internal global i32 0, align 4
@irqs = internal global [4 x i32] zeroinitializer, align 16
@__param_str_ports = internal constant [6 x i8] c"ports\00", align 1
@__param_arr_ports = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_ports, %struct.kernel_param_ops* @param_ops_uint, i8* bitcast ([4 x i32]* @ports to i8*) }, align 8
@num_ports = internal global i32 0, align 4
@ports = internal global [4 x i32] zeroinitializer, align 16
@__param_str_addrs = internal constant [6 x i8] c"addrs\00", align 1
@__param_arr_addrs = internal constant %struct.kparam_array { i32 4, i32 8, i32* @num_addrs, %struct.kernel_param_ops* @param_ops_ulong, i8* bitcast ([4 x i64]* @addrs to i8*) }, align 8
@num_addrs = internal global i32 0, align 4
@param_ops_ulong = external constant %struct.kernel_param_ops, align 8
@addrs = internal global [4 x i64] zeroinitializer, align 16
@param_ops_string = external constant %struct.kernel_param_ops, align 8
@__param_string_type = internal constant %struct.kparam_string { i32 30, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @si_type_str, i32 0, i32 0) }, align 8
@si_type_str = internal global [30 x i8] zeroinitializer, align 16
@__param_str_trypci = internal constant [7 x i8] c"trypci\00", align 1
@si_trypci = internal global i8 1, align 1
@__param_str_tryplatform = internal constant [12 x i8] c"tryplatform\00", align 1
@si_tryplatform = internal global i8 1, align 1
@__param_str_trydmi = internal constant [7 x i8] c"trydmi\00", align 1
@si_trydmi = internal global i8 1, align 1
@__param_str_tryacpi = internal constant [8 x i8] c"tryacpi\00", align 1
@si_tryacpi = internal global i8 1, align 1
@__param_str_hotmod = internal constant [7 x i8] c"hotmod\00", align 1
@__param_ops_hotmod = internal constant %struct.kernel_param_ops { i32 0, i32 (i8*, %struct.kernel_param*)* @hotmod_handler, i32 (i8*, %struct.kernel_param*)* null, void (i8*)* null }, align 8
@_ctype = external constant [0 x i8], align 1
@hotmod_ops = internal constant [3 x %struct.hotmod_vals] [%struct.hotmod_vals { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i32 0 }, %struct.hotmod_vals { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13, i32 0, i32 0), i32 1 }, %struct.hotmod_vals zeroinitializer], align 16
@.str = private unnamed_addr constant [10 x i8] c"operation\00", align 1
@hotmod_si = internal constant [4 x %struct.hotmod_vals] [%struct.hotmod_vals { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 0 }, %struct.hotmod_vals { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.15, i32 0, i32 0), i32 1 }, %struct.hotmod_vals { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i32 2 }, %struct.hotmod_vals zeroinitializer], align 16
@.str.1 = private unnamed_addr constant [15 x i8] c"interface type\00", align 1
@hotmod_as = internal constant [3 x %struct.hotmod_vals] [%struct.hotmod_vals { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 1 }, %struct.hotmod_vals { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 0 }, %struct.hotmod_vals zeroinitializer], align 16
@.str.2 = private unnamed_addr constant [14 x i8] c"address space\00", align 1
@.str.3 = private unnamed_addr constant [40 x i8] c"\014ipmi_si: Invalid hotmod address '%s'\0A\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"rsp\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"rsi\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"rsh\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"irq\00", align 1
@.str.8 = private unnamed_addr constant [5 x i8] c"ipmb\00", align 1
@.str.9 = private unnamed_addr constant [39 x i8] c"\014ipmi_si: Invalid hotmod option '%s'\0A\00", align 1
@smi_infos_lock = internal global %struct.mutex { %union.anon.3 zeroinitializer, %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.97, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.qspinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @smi_infos_lock to i8*), i64 88) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @smi_infos_lock to i8*), i64 88) to %struct.list_head*) }, i8* bitcast (%struct.mutex* @smi_infos_lock to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.98, i32 0, i32 0), i32 0, i64 0 } }, align 8
@smi_infos = internal global %struct.list_head { %struct.list_head* @smi_infos, %struct.list_head* @smi_infos }, align 8
@.str.97 = private unnamed_addr constant [25 x i8] c"smi_infos_lock.wait_lock\00", align 1
@.str.98 = private unnamed_addr constant [15 x i8] c"smi_infos_lock\00", align 1
@.str.96 = private unnamed_addr constant [50 x i8] c"\013ipmi_si: Unable to unregister device: errno=%d\0A\00", align 1
@jiffies = external global i64, align 8
@xaction_notifier_list = internal global %struct.atomic_notifier_head { %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.30, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.notifier_block* null }, align 8
@.str.30 = private unnamed_addr constant [27 x i8] c"xaction_notifier_list.lock\00", align 1
@.str.26 = private unnamed_addr constant [29 x i8] c"Error clearing flags: %2.2x\0A\00", align 1
@.str.27 = private unnamed_addr constant [28 x i8] c"Couldn't get irq info: %x.\0A\00", align 1
@.str.28 = private unnamed_addr constant [43 x i8] c"Maybe ok, but ipmi might run very slowly.\0A\00", align 1
@.str.29 = private unnamed_addr constant [41 x i8] c"Could not set the global enables: 0x%x.\0A\00", align 1
@si_to_str = internal constant [3 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0)], align 16
@addr_space_to_str = internal constant [2 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0)], align 16
@.str.33 = private unnamed_addr constant [97 x i8] c"\016ipmi_si: Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\0A\00", align 1
@.str.34 = private unnamed_addr constant [11 x i8] c"ipmi_si.%d\00", align 1
@.str.23 = private unnamed_addr constant [8 x i8] c"ipmi_si\00", align 1
@.str.35 = private unnamed_addr constant [47 x i8] c"\013ipmi_si: Unable to allocate platform device\0A\00", align 1
@ipmi_driver = internal global %struct.platform_driver { i32 (%struct.platform_device*)* @ipmi_probe, i32 (%struct.platform_device*)* @ipmi_remove, void (%struct.platform_device*)* null, i32 (%struct.platform_device*, i32)* null, i32 (%struct.platform_device*)* null, %struct.device_driver { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), %struct.bus_type* null, %struct.module* null, i8* null, i8 0, i32 0, %struct.of_device_id* getelementptr inbounds ([4 x %struct.of_device_id], [4 x %struct.of_device_id]* @of_ipmi_match, i32 0, i32 0), %struct.acpi_device_id* getelementptr inbounds ([2 x %struct.acpi_device_id], [2 x %struct.acpi_device_id]* @acpi_ipmi_match, i32 0, i32 0), i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.platform_device_id* null, i8 0 }, align 8
@.str.36 = private unnamed_addr constant [52 x i8] c"\013ipmi_si: Could not allocate state machine memory\0A\00", align 1
@.str.37 = private unnamed_addr constant [28 x i8] c"Could not set up I/O space\0A\00", align 1
@.str.38 = private unnamed_addr constant [28 x i8] c"Interface detection failed\0A\00", align 1
@.str.39 = private unnamed_addr constant [45 x i8] c"There appears to be no BMC at this location\0A\00", align 1
@smi_num = internal global i32 0, align 4
@.str.40 = private unnamed_addr constant [48 x i8] c"Unable to register system interface device: %d\0A\00", align 1
@handlers = internal constant %struct.ipmi_smi_handlers { %struct.module* @__this_module, i32 (i8*, %struct.ipmi_smi*)* @smi_start_processing, i32 (i8*, %struct.ipmi_smi_info*)* @get_smi_info, void (i8*, %struct.ipmi_smi_msg*)* @sender, void (i8*)* @request_events, void (i8*, i1)* @set_need_watch, void (i8*)* @flush_messages, void (i8*, i1)* @set_run_to_completion, void (i8*)* @poll, void (i8*, i1)* @set_maintenance_mode, i32 (i8*)* null, void (i8*)* null }, align 8
@.str.41 = private unnamed_addr constant [37 x i8] c"Unable to register device: error %d\0A\00", align 1
@.str.42 = private constant [5 x i8] c"type\00", align 1
@smi_type_proc_ops = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @smi_type_proc_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @single_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.43 = private unnamed_addr constant [33 x i8] c"Unable to create proc entry: %d\0A\00", align 1
@.str.44 = private unnamed_addr constant [9 x i8] c"si_stats\00", align 1
@smi_si_stats_proc_ops = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @smi_si_stats_proc_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @single_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.45 = private unnamed_addr constant [7 x i8] c"params\00", align 1
@smi_params_proc_ops = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @smi_params_proc_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @single_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.46 = private unnamed_addr constant [31 x i8] c"IPMI %s interface initialized\0A\00", align 1
@.str.47 = private unnamed_addr constant [33 x i8] c"drivers/char/ipmi/ipmi_si_intf.c\00", align 1
@.str.95 = private unnamed_addr constant [49 x i8] c"%s,%s,0x%lx,rsp=%d,rsi=%d,rsh=%d,irq=%d,ipmb=%d\0A\00", align 1
@.str.83 = private unnamed_addr constant [27 x i8] c"interrupts_enabled:    %d\0A\00", align 1
@.str.84 = private unnamed_addr constant [27 x i8] c"short_timeouts:        %u\0A\00", align 1
@.str.85 = private unnamed_addr constant [27 x i8] c"long_timeouts:         %u\0A\00", align 1
@.str.86 = private unnamed_addr constant [27 x i8] c"idles:                 %u\0A\00", align 1
@.str.87 = private unnamed_addr constant [27 x i8] c"interrupts:            %u\0A\00", align 1
@.str.88 = private unnamed_addr constant [27 x i8] c"attentions:            %u\0A\00", align 1
@.str.89 = private unnamed_addr constant [27 x i8] c"flag_fetches:          %u\0A\00", align 1
@.str.90 = private unnamed_addr constant [27 x i8] c"hosed_count:           %u\0A\00", align 1
@.str.91 = private unnamed_addr constant [27 x i8] c"complete_transactions: %u\0A\00", align 1
@.str.92 = private unnamed_addr constant [27 x i8] c"events:                %u\0A\00", align 1
@.str.93 = private unnamed_addr constant [27 x i8] c"watchdog_pretimeouts:  %u\0A\00", align 1
@.str.94 = private unnamed_addr constant [27 x i8] c"incoming_messages:     %u\0A\00", align 1
@.str.82 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.79 = private unnamed_addr constant [23 x i8] c"((&new_smi->si_timer))\00", align 1
@smi_start_processing.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.80 = private unnamed_addr constant [8 x i8] c"kipmi%d\00", align 1
@.str.81 = private unnamed_addr constant [90 x i8] c"Could not start kernel thread due to error %ld, only using timers to drive the interface\0A\00", align 1
@current_task = external global %struct.task_struct*, align 8
@.str.75 = private unnamed_addr constant [101 x i8] c"\014ipmi_si: Error getting response from get global enables command, the event buffer is not enabled.\0A\00", align 1
@.str.76 = private unnamed_addr constant [92 x i8] c"\014ipmi_si: Invalid return from get global enables command, cannot enable the event buffer.\0A\00", align 1
@.str.77 = private unnamed_addr constant [102 x i8] c"\014ipmi_si: Error getting response from set global, enables command, the event buffer is not enabled.\0A\00", align 1
@.str.78 = private unnamed_addr constant [90 x i8] c"\014ipmi_si: Invalid return from get global, enables command, not enable the event buffer.\0A\00", align 1
@.str.73 = private unnamed_addr constant [38 x i8] c"Cannot check setting the rcv irq: %d\0A\00", align 1
@.str.74 = private unnamed_addr constant [97 x i8] c"The BMC does not support setting the recv irq bit, compensating, but the BMC needs to be fixed.\0A\00", align 1
@.str.71 = private unnamed_addr constant [60 x i8] c"Error getting response from set global enables command: %d\0A\00", align 1
@.str.72 = private unnamed_addr constant [59 x i8] c"Invalid return from set global enables command: %ld %x %x\0A\00", align 1
@.str.69 = private unnamed_addr constant [60 x i8] c"Error getting response from get global enables command: %d\0A\00", align 1
@.str.70 = private unnamed_addr constant [62 x i8] c"Invalid return from get global enables command: %ld %x %x %x\0A\00", align 1
@.str.67 = private unnamed_addr constant [39 x i8] c"Cannot check clearing the rcv irq: %d\0A\00", align 1
@.str.68 = private unnamed_addr constant [98 x i8] c"The BMC does not support clearing the recv irq bit, compensating, but the BMC needs to be fixed.\0A\00", align 1
@dell_poweredge_bt_xaction_notifier = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @dell_poweredge_bt_xaction_handler, %struct.notifier_block* null, i32 0 }, align 8
@of_ipmi_match = internal constant [4 x %struct.of_device_id] [%struct.of_device_id { [32 x i8] zeroinitializer, [32 x i8] c"ipmi\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [128 x i8] c"ipmi-kcs\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i8* null }, %struct.of_device_id { [32 x i8] zeroinitializer, [32 x i8] c"ipmi\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [128 x i8] c"ipmi-smic\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i8* inttoptr (i64 1 to i8*) }, %struct.of_device_id { [32 x i8] zeroinitializer, [32 x i8] c"ipmi\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [128 x i8] c"ipmi-bt\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i8* inttoptr (i64 2 to i8*) }, %struct.of_device_id zeroinitializer], align 16
@acpi_ipmi_match = internal constant [2 x %struct.acpi_device_id] [%struct.acpi_device_id { [9 x i8] c"IPI0001\00\00", i64 0, i32 0, i32 0 }, %struct.acpi_device_id zeroinitializer], align 16
@.str.58 = private unnamed_addr constant [27 x i8] c"ipmi_si: probing via ACPI\0A\00", align 1
@.str.59 = private unnamed_addr constant [5 x i8] c"_IFT\00", align 1
@.str.60 = private unnamed_addr constant [41 x i8] c"Could not find ACPI IPMI interface type\0A\00", align 1
@.str.61 = private unnamed_addr constant [24 x i8] c"unknown IPMI type %lld\0A\00", align 1
@.str.62 = private unnamed_addr constant [26 x i8] c"no I/O or memory address\0A\00", align 1
@.str.63 = private unnamed_addr constant [5 x i8] c"_GPE\00", align 1
@.str.64 = private unnamed_addr constant [34 x i8] c"%pR regsize %d spacing %d irq %d\0A\00", align 1
@.str.65 = private unnamed_addr constant [48 x i8] c"%s unable to claim ACPI GPE %d, running polled\0A\00", align 1
@.str.66 = private unnamed_addr constant [19 x i8] c"Using ACPI GPE %d\0A\00", align 1
@.str.48 = private unnamed_addr constant [25 x i8] c"probing via device tree\0A\00", align 1
@.str.49 = private unnamed_addr constant [34 x i8] c"ipmi_si: invalid address from OF\0A\00", align 1
@.str.50 = private unnamed_addr constant [9 x i8] c"reg-size\00", align 1
@.str.51 = private unnamed_addr constant [34 x i8] c"ipmi_si: invalid regsize from OF\0A\00", align 1
@.str.52 = private unnamed_addr constant [12 x i8] c"reg-spacing\00", align 1
@.str.53 = private unnamed_addr constant [37 x i8] c"ipmi_si: invalid regspacing from OF\0A\00", align 1
@.str.54 = private unnamed_addr constant [10 x i8] c"reg-shift\00", align 1
@.str.55 = private unnamed_addr constant [35 x i8] c"ipmi_si: invalid regshift from OF\0A\00", align 1
@.str.56 = private unnamed_addr constant [40 x i8] c"could not allocate memory for OF probe\0A\00", align 1
@of_ipmi_probe.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.of_ipmi_probe, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.47, i32 0, i32 0), i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.57, i32 0, i32 0), i8 103, i8 10, i8 0, i8 0 }, section "__verbose", align 8
@.str.57 = private unnamed_addr constant [41 x i8] c"addr 0x%lx regsize %d spacing %d irq %d\0A\00", align 1
@__func__.of_ipmi_probe = private unnamed_addr constant [14 x i8] c"of_ipmi_probe\00", align 1
@.str.18 = private unnamed_addr constant [4 x i8] c"i/o\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"mem\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"kcs\00", align 1
@.str.15 = private unnamed_addr constant [5 x i8] c"smic\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"bt\00", align 1
@.str.31 = private unnamed_addr constant [53 x i8] c"\016ipmi_si: %s-specified %s state machine: duplicate\0A\00", align 1
@.str.32 = private unnamed_addr constant [49 x i8] c"\016ipmi_si: Adding %s-specified %s state machine\0A\00", align 1
@.str.24 = private unnamed_addr constant [49 x i8] c"%s unable to claim interrupt %d, running polled\0A\00", align 1
@.str.25 = private unnamed_addr constant [14 x i8] c"Using irq %d\0A\00", align 1
@.str.22 = private unnamed_addr constant [27 x i8] c"Invalid register size: %d\0A\00", align 1
@ioport_resource = external global %struct.resource, align 8
@iomem_resource = external global %struct.resource, align 8
@.str.21 = private unnamed_addr constant [25 x i8] c"&(&info->si_lock)->rlock\00", align 1
@smi_info_alloc.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.19 = private unnamed_addr constant [37 x i8] c"\014ipmi_si: No option given for '%s'\0A\00", align 1
@.str.20 = private unnamed_addr constant [38 x i8] c"\014ipmi_si: Bad option given for '%s'\0A\00", align 1
@.str.10 = private unnamed_addr constant [32 x i8] c"\014ipmi_si: No hotmod %s given.\0A\00", align 1
@.str.11 = private unnamed_addr constant [35 x i8] c"\014ipmi_si: Invalid hotmod %s '%s'\0A\00", align 1
@.str.12 = private unnamed_addr constant [4 x i8] c"add\00", align 1
@.str.13 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@ipmi_pci_devices = internal constant [3 x %struct.pci_device_id] [%struct.pci_device_id { i32 4156, i32 4634, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 -1, i32 -1, i32 -1, i32 -1, i32 788224, i32 -256, i64 0 }, %struct.pci_device_id zeroinitializer], align 16
@initialized = internal global i32 0, align 4
@.str.99 = private unnamed_addr constant [42 x i8] c"\013ipmi_si: Unable to register driver: %d\0A\00", align 1
@si_type = internal global [4 x i8*] zeroinitializer, align 16
@.str.100 = private unnamed_addr constant [33 x i8] c"\016IPMI System Interface driver.\0A\00", align 1
@ipmi_pci_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([3 x %struct.pci_device_id], [3 x %struct.pci_device_id]* @ipmi_pci_devices, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @ipmi_pci_probe, void (%struct.pci_dev*)* @ipmi_pci_remove, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, %struct.pci_error_handlers* null, %struct.device_driver zeroinitializer, %struct.__wait_queue_head zeroinitializer }, align 8
@.str.101 = private unnamed_addr constant [46 x i8] c"\013ipmi_si: Unable to register PCI driver: %d\0A\00", align 1
@pci_registered = internal global i8 0, align 1
@.str.102 = private unnamed_addr constant [51 x i8] c"\014ipmi_si: Unable to find any System Interface(s)\0A\00", align 1
@acpi_disabled = external global i32, align 4
@acpi_failure = internal global i32 0, align 4
@.str.115 = private unnamed_addr constant [5 x i8] c"SPMI\00", align 1
@.str.116 = private unnamed_addr constant [31 x i8] c"\016ipmi_si: Bad SPMI legacy %d\0A\00", align 1
@.str.117 = private unnamed_addr constant [43 x i8] c"\013ipmi_si: Could not allocate SI data (3)\0A\00", align 1
@.str.118 = private unnamed_addr constant [29 x i8] c"\016ipmi_si: probing via SPMI\0A\00", align 1
@.str.119 = private unnamed_addr constant [41 x i8] c"\016ipmi_si: Unknown ACPI/SPMI SI type %d\0A\00", align 1
@.str.120 = private unnamed_addr constant [42 x i8] c"\014ipmi_si: Unknown ACPI I/O Address type\0A\00", align 1
@.str.114 = private unnamed_addr constant [3 x i8] c"io\00", align 1
@.str.121 = private unnamed_addr constant [55 x i8] c"\016ipmi_si: SPMI: %s %#lx regsize %d spacing %d irq %d\0A\00", align 1
@.str.110 = private unnamed_addr constant [39 x i8] c"\013ipmi_si: Could not allocate SI data\0A\00", align 1
@.str.111 = private unnamed_addr constant [31 x i8] c"\016ipmi_si: probing via SMBIOS\0A\00", align 1
@.str.112 = private unnamed_addr constant [48 x i8] c"\014ipmi_si: Unknown SMBIOS I/O Address type: %d\0A\00", align 1
@.str.113 = private unnamed_addr constant [57 x i8] c"\016ipmi_si: SMBIOS: %s %#lx regsize %d spacing %d irq %d\0A\00", align 1
@.str.106 = private unnamed_addr constant [16 x i8] c"probing via PCI\00", align 1
@.str.107 = private unnamed_addr constant [23 x i8] c"Unknown IPMI type: %d\0A\00", align 1
@.str.108 = private unnamed_addr constant [28 x i8] c"couldn't enable PCI device\0A\00", align 1
@.str.109 = private unnamed_addr constant [27 x i8] c"Could not setup I/O space\0A\00", align 1
@.str.103 = private unnamed_addr constant [42 x i8] c"\016ipmi_si: probing via hardcoded address\0A\00", align 1
@.str.104 = private unnamed_addr constant [71 x i8] c"\014ipmi_si: Interface type specified for interface %d, was invalid: %s\0A\00", align 1
@.str.105 = private unnamed_addr constant [105 x i8] c"\014ipmi_si: Interface type specified for interface %d, but port and address were not set or set to zero.\0A\00", align 1
@kcs_smi_handlers = constant %struct.si_sm_handlers { i8* null, i32 (%struct.si_sm_data*, %struct.si_sm_io*)* @init_kcs_data, i32 (%struct.si_sm_data*, i8*, i32)* @start_kcs_transaction, i32 (%struct.si_sm_data*, i8*, i32)* @get_kcs_result, i32 (%struct.si_sm_data*, i64)* @kcs_event, i32 (%struct.si_sm_data*)* @kcs_detect, void (%struct.si_sm_data*)* @kcs_cleanup, i32 ()* @kcs_size }, align 8
@kcs_debug = internal global i32 0, align 4
@.str.3.3 = private unnamed_addr constant [23 x i8] c"\017KCS: State = %d, %x\0A\00", align 1
@.str.4.4 = private unnamed_addr constant [32 x i8] c"State machine not idle at start\00", align 1
@.str.5.5 = private unnamed_addr constant [34 x i8] c"Not in write state at write start\00", align 1
@.str.6.6 = private unnamed_addr constant [29 x i8] c"Not in write state for write\00", align 1
@.str.7.7 = private unnamed_addr constant [33 x i8] c"Not in write state for write end\00", align 1
@.str.8.8 = private unnamed_addr constant [34 x i8] c"Not in read or idle in read state\00", align 1
@.str.9.9 = private unnamed_addr constant [29 x i8] c"Not in read state for error2\00", align 1
@.str.10.10 = private unnamed_addr constant [29 x i8] c"Not in idle state for error3\00", align 1
@.str.13.11 = private unnamed_addr constant [22 x i8] c"OBF not ready in time\00", align 1
@.str.12.12 = private unnamed_addr constant [30 x i8] c"\017ipmi_kcs_sm: kcs hosed: %s\0A\00", align 1
@.str.11.13 = private unnamed_addr constant [22 x i8] c"IBF not ready in time\00", align 1
@.str.122 = private unnamed_addr constant [26 x i8] c"\017start_kcs_transaction -\00", align 1
@__param_kcs_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_kcs_debug, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @kcs_debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_kcs_debugtype8 = internal constant [23 x i8] c"parmtype=kcs_debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_kcs_debug9 = internal constant [61 x i8] c"parm=kcs_debug:debug bitmask, 1=enable, 2=messages, 4=states\00", section ".modinfo", align 1
@__param_str_kcs_debug = internal constant [10 x i8] c"kcs_debug\00", align 1
@smic_smi_handlers = constant %struct.si_sm_handlers.178 { i8* null, i32 (%struct.si_sm_data.179*, %struct.si_sm_io*)* @init_smic_data, i32 (%struct.si_sm_data.179*, i8*, i32)* @start_smic_transaction, i32 (%struct.si_sm_data.179*, i8*, i32)* @smic_get_result, i32 (%struct.si_sm_data.179*, i64)* @smic_event, i32 (%struct.si_sm_data.179*)* @smic_detect, void (%struct.si_sm_data.179*)* @smic_cleanup, i32 ()* @smic_size }, align 8
@smic_debug = internal global i32 1, align 4
@.str.4.128 = private unnamed_addr constant [53 x i8] c"\017smic_event - smic->smic_timeout = %ld, time = %ld\0A\00", align 1
@.str.5.129 = private unnamed_addr constant [16 x i8] c"smic timed out.\00", align 1
@.str.6.131 = private unnamed_addr constant [60 x i8] c"\017smic_event - state = %d, flags = 0x%02x, status = 0x%02x\0A\00", align 1
@.str.7.132 = private unnamed_addr constant [48 x i8] c"state = SMIC_OP_OK, status != SMIC_SC_SMS_READY\00", align 1
@.str.8.134 = private unnamed_addr constant [57 x i8] c"state = SMIC_WRITE_START, status != SMIC_SC_SMS_WR_START\00", align 1
@.str.9.135 = private unnamed_addr constant [55 x i8] c"state = SMIC_WRITE_NEXT, status != SMIC_SC_SMS_WR_NEXT\00", align 1
@.str.10.136 = private unnamed_addr constant [53 x i8] c"state = SMIC_WRITE_END, status != SMIC_SC_SMS_WR_END\00", align 1
@.str.11.137 = private unnamed_addr constant [31 x i8] c"\017SMIC_WRITE_END: data = %02x\0A\00", align 1
@.str.12.138 = private unnamed_addr constant [40 x i8] c"state = SMIC_WRITE_END, data != SUCCESS\00", align 1
@.str.13.139 = private unnamed_addr constant [56 x i8] c"state = SMIC_READ_START, status != SMIC_SC_SMS_RD_START\00", align 1
@.str.14.141 = private unnamed_addr constant [60 x i8] c"state = SMIC_READ_NEXT, status != SMIC_SC_SMS_RD_(NEXT|END)\00", align 1
@.str.15.142 = private unnamed_addr constant [51 x i8] c"state = SMIC_READ_END, status != SMIC_SC_SMS_READY\00", align 1
@.str.16.143 = private unnamed_addr constant [30 x i8] c"\017SMIC_READ_END: data = %02x\0A\00", align 1
@.str.17.144 = private unnamed_addr constant [39 x i8] c"state = SMIC_READ_END, data != SUCCESS\00", align 1
@.str.18.145 = private unnamed_addr constant [20 x i8] c"\017smic->state = %d\0A\00", align 1
@.str.19.146 = private unnamed_addr constant [16 x i8] c"state = UNKNOWN\00", align 1
@.str.20.147 = private unnamed_addr constant [33 x i8] c"\014ipmi_smic_drv: smic hosed: %s\0A\00", align 1
@.str.3.148 = private unnamed_addr constant [20 x i8] c"\017smic_get result -\00", align 1
@.str.151 = private unnamed_addr constant [27 x i8] c"\017start_smic_transaction -\00", align 1
@__param_smic_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__param_str_smic_debug, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @smic_debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_smic_debugtype8 = internal constant [24 x i8] c"parmtype=smic_debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_smic_debug9 = internal constant [62 x i8] c"parm=smic_debug:debug bitmask, 1=enable, 2=messages, 4=states\00", section ".modinfo", align 1
@__param_str_smic_debug = internal constant [11 x i8] c"smic_debug\00", align 1
@bt_smi_handlers = constant %struct.si_sm_handlers.268 { i8* null, i32 (%struct.si_sm_data.269*, %struct.si_sm_io*)* @bt_init_data, i32 (%struct.si_sm_data.269*, i8*, i32)* @bt_start_transaction, i32 (%struct.si_sm_data.269*, i8*, i32)* @bt_get_result, i32 (%struct.si_sm_data.269*, i64)* @bt_event, i32 (%struct.si_sm_data.269*)* @bt_detect, void (%struct.si_sm_data.269*)* @bt_cleanup, i32 ()* @bt_size }, align 8
@bt_debug = internal global i32 0, align 4
@.str.48.155 = private unnamed_addr constant [26 x i8] c"\014IPMI BT: flag reset %s\0A\00", align 1
@status2txt.buf = internal global [40 x i8] zeroinitializer, align 16
@.str.23.156 = private unnamed_addr constant [3 x i8] c"[ \00", align 1
@.str.24.157 = private unnamed_addr constant [8 x i8] c"B_BUSY \00", align 1
@.str.25.158 = private unnamed_addr constant [8 x i8] c"H_BUSY \00", align 1
@.str.26.159 = private unnamed_addr constant [6 x i8] c"OEM0 \00", align 1
@.str.27.160 = private unnamed_addr constant [5 x i8] c"SMS \00", align 1
@.str.28.161 = private unnamed_addr constant [5 x i8] c"B2H \00", align 1
@.str.29.162 = private unnamed_addr constant [5 x i8] c"H2B \00", align 1
@.str.30.163 = private unnamed_addr constant [2 x i8] c"]\00", align 1
@bt_event.last_printed = internal global i32 11, align 4
@.str.5.164 = private unnamed_addr constant [27 x i8] c"\014BT: %s %s TO=%ld - %ld \0A\00", align 1
@bt_event.GetBT_CAP = private unnamed_addr constant [2 x i8] c"\186", align 1
@.str.6.165 = private unnamed_addr constant [33 x i8] c"\014IPMI BT: using default values\0A\00", align 1
@.str.7.166 = private unnamed_addr constant [40 x i8] c"\014IPMI BT: req2rsp=%ld secs retries=%d\0A\00", align 1
@.str.41.167 = private unnamed_addr constant [26 x i8] c"\014BT: bad raw rsp len=%d\0A\00", align 1
@.str.42.168 = private unnamed_addr constant [30 x i8] c"\014BT: got %d bytes seq=0x%02X\00", align 1
@.str.43.169 = private unnamed_addr constant [8 x i8] c"\01c %02x\00", align 1
@.str.45.170 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.46.171 = private unnamed_addr constant [5 x i8] c" ...\00", align 1
@.str.44.172 = private unnamed_addr constant [6 x i8] c"\01c%s\0A\00", align 1
@.str.47.173 = private unnamed_addr constant [73 x i8] c"\014IPMI BT: bad packet: want 0x(%02X, %02X, %02X) got (%02X, %02X, %02X)\0A\00", align 1
@.str.40.174 = private unnamed_addr constant [32 x i8] c"\014BT: write %d bytes seq=0x%02X\00", align 1
@.str.2.175 = private unnamed_addr constant [6 x i8] c" %02x\00", align 1
@.str.3.176 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.33.177 = private unnamed_addr constant [8 x i8] c"timeout\00", align 1
@.str.34.178 = private unnamed_addr constant [15 x i8] c"internal error\00", align 1
@.str.35.179 = private unnamed_addr constant [24 x i8] c"\014IPMI BT: %s in %s %s \00", align 1
@.str.36.180 = private unnamed_addr constant [17 x i8] c"%d retries left\0A\00", align 1
@.str.37.181 = private unnamed_addr constant [45 x i8] c"\014failed %d retries, sending error response\0A\00", align 1
@.str.38.182 = private unnamed_addr constant [35 x i8] c"\013IPMI BT: stuck, try power cycle\0A\00", align 1
@.str.39.183 = private unnamed_addr constant [33 x i8] c"\014IPMI: BT reset (takes 5 secs)\0A\00", align 1
@.str.31.184 = private unnamed_addr constant [31 x i8] c"\014IPMI BT: stale response %s; \00", align 1
@.str.32.185 = private unnamed_addr constant [18 x i8] c"drained %d bytes\0A\00", align 1
@.str.16.186 = private unnamed_addr constant [7 x i8] c"RESET2\00", align 1
@.str.17.187 = private unnamed_addr constant [7 x i8] c"RESET3\00", align 1
@.str.13.188 = private unnamed_addr constant [10 x i8] c"CLEAR_B2H\00", align 1
@.str.14.189 = private unnamed_addr constant [9 x i8] c"RD_BYTES\00", align 1
@.str.11.190 = private unnamed_addr constant [11 x i8] c"WR_CONSUME\00", align 1
@.str.12.191 = private unnamed_addr constant [8 x i8] c"RD_WAIT\00", align 1
@.str.9.192 = private unnamed_addr constant [8 x i8] c"XACTION\00", align 1
@.str.10.193 = private unnamed_addr constant [9 x i8] c"WR_BYTES\00", align 1
@.str.22.194 = private unnamed_addr constant [10 x i8] c"BAD STATE\00", align 1
@.str.8.195 = private unnamed_addr constant [5 x i8] c"IDLE\00", align 1
@.str.15.196 = private unnamed_addr constant [7 x i8] c"RESET1\00", align 1
@.str.18.197 = private unnamed_addr constant [8 x i8] c"RESTART\00", align 1
@.str.19.198 = private unnamed_addr constant [10 x i8] c"LONG_BUSY\00", align 1
@.str.20.199 = private unnamed_addr constant [10 x i8] c"CAP_BEGIN\00", align 1
@.str.21.200 = private unnamed_addr constant [8 x i8] c"CAP_END\00", align 1
@.str.4.201 = private unnamed_addr constant [23 x i8] c"\014BT: result %d bytes:\00", align 1
@.str.202 = private unnamed_addr constant [37 x i8] c"\014BT: +++++++++++++++++ New command\0A\00", align 1
@.str.1.203 = private unnamed_addr constant [31 x i8] c"\014BT: NetFn/LUN CMD [%d data]:\00", align 1
@__param_bt_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_bt_debug, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @bt_debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_bt_debugtype8 = internal constant [22 x i8] c"parmtype=bt_debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_bt_debug9 = internal constant [60 x i8] c"parm=bt_debug:debug bitmask, 1=enable, 2=messages, 4=states\00", section ".modinfo", align 1
@__param_str_bt_debug = internal constant [9 x i8] c"bt_debug\00", align 1

@__mod_pci__ipmi_pci_devices_device_table = alias [3 x %struct.pci_device_id], [3 x %struct.pci_device_id]* @ipmi_pci_devices
@__mod_of__of_ipmi_match_device_table = alias [4 x %struct.of_device_id], [4 x %struct.of_device_id]* @of_ipmi_match
@__mod_acpi__acpi_ipmi_match_device_table = alias [2 x %struct.acpi_device_id], [2 x %struct.acpi_device_id]* @acpi_ipmi_match
@init_module = alias i32 (), i32 ()* @init_ipmi_si
@cleanup_module = alias void (), void ()* @cleanup_ipmi_si

; Function Attrs: nounwind uwtable
define internal i32 @hotmod_handler(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %curr = alloca i8*, align 8
  %n = alloca i8*, align 8
  %addr_space = alloca i32, align 4
  %regspacing = alloca i32, align 4
  %regsize = alloca i32, align 4
  %regshift = alloca i32, align 4
  %irq = alloca i32, align 4
  %ipmb = alloca i32, align 4
  %ival = alloca i32, align 4
  %call = call noalias i8* @kstrdup(i8* %val, i32 20971712)
  %0 = bitcast i8** %curr to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i8** %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i32* %addr_space to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #7
  %3 = bitcast i32* %regspacing to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #7
  %4 = bitcast i32* %regsize to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #7
  %5 = bitcast i32* %regshift to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #7
  %6 = bitcast i32* %irq to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #7
  %7 = bitcast i32* %ipmb to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #7
  %8 = bitcast i32* %ival to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #7
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i64 @strlen(i8* %call)
  %conv = trunc i64 %call1 to i32
  %sub = sub nsw i32 %conv, 1
  store i32 %sub, i32* %ival, align 4, !tbaa !2
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %9 = load i32, i32* %ival, align 4, !tbaa !2
  %cmp = icmp sge i32 %9, 0
  br i1 %cmp, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %while.cond
  %10 = load i32, i32* %ival, align 4, !tbaa !2
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds i8, i8* %call, i64 %idxprom
  %11 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv3 = zext i8 %11 to i32
  %idxprom4 = sext i32 %conv3 to i64
  %arrayidx5 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom4
  %12 = load i8, i8* %arrayidx5, align 1, !tbaa !6
  %conv6 = zext i8 %12 to i32
  %and = and i32 %conv6, 32
  %cmp7 = icmp ne i32 %and, 0
  br i1 %cmp7, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %13 = load i32, i32* %ival, align 4, !tbaa !2
  %idxprom9 = sext i32 %13 to i64
  %arrayidx10 = getelementptr inbounds i8, i8* %call, i64 %idxprom9
  store i8 0, i8* %arrayidx10, align 1, !tbaa !6
  %14 = load i32, i32* %ival, align 4, !tbaa !2
  %dec = add nsw i32 %14, -1
  store i32 %dec, i32* %ival, align 4, !tbaa !2
  br label %while.cond

while.end:                                        ; preds = %land.rhs, %while.cond
  store i8* %call, i8** %curr, align 8, !tbaa !7
  br label %for.cond

for.cond:                                         ; preds = %for.inc186, %while.end
  %15 = load i8*, i8** %curr, align 8, !tbaa !7
  %tobool11 = icmp ne i8* %15, null
  br i1 %tobool11, label %for.body, label %out

for.body:                                         ; preds = %for.cond
  store i32 1, i32* %regspacing, align 4, !tbaa !2
  store i32 1, i32* %regsize, align 4, !tbaa !2
  store i32 0, i32* %regshift, align 4, !tbaa !2
  store i32 0, i32* %irq, align 4, !tbaa !2
  store i32 0, i32* %ipmb, align 4, !tbaa !2
  %16 = load i8*, i8** %curr, align 8, !tbaa !7
  %call12 = call i8* @strchr(i8* %16, i32 58)
  %tobool13 = icmp ne i8* %call12, null
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.body
  store i8 0, i8* %call12, align 1, !tbaa !6
  %incdec.ptr = getelementptr inbounds i8, i8* %call12, i32 1
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %for.body
  %next.0 = phi i8* [ %incdec.ptr, %if.then14 ], [ %call12, %for.body ]
  %call16 = call i32 @parse_str(%struct.hotmod_vals* getelementptr inbounds ([3 x %struct.hotmod_vals], [3 x %struct.hotmod_vals]* @hotmod_ops, i32 0, i32 0), i32* %ival, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str, i32 0, i32 0), i8** %curr)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %out, label %if.end19

if.end19:                                         ; preds = %if.end15
  %17 = load i32, i32* %ival, align 4, !tbaa !2
  %call20 = call i32 @parse_str(%struct.hotmod_vals* getelementptr inbounds ([4 x %struct.hotmod_vals], [4 x %struct.hotmod_vals]* @hotmod_si, i32 0, i32 0), i32* %ival, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.1, i32 0, i32 0), i8** %curr)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %out, label %if.end23

if.end23:                                         ; preds = %if.end19
  %18 = load i32, i32* %ival, align 4, !tbaa !2
  %call24 = call i32 @parse_str(%struct.hotmod_vals* getelementptr inbounds ([3 x %struct.hotmod_vals], [3 x %struct.hotmod_vals]* @hotmod_as, i32 0, i32 0), i32* %addr_space, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.2, i32 0, i32 0), i8** %curr)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %out, label %if.end27

if.end27:                                         ; preds = %if.end23
  %19 = load i8*, i8** %curr, align 8, !tbaa !7
  %call28 = call i8* @strchr(i8* %19, i32 44)
  %tobool29 = icmp ne i8* %call28, null
  br i1 %tobool29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end27
  store i8 0, i8* %call28, align 1, !tbaa !6
  %incdec.ptr31 = getelementptr inbounds i8, i8* %call28, i32 1
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.end27
  %s.0 = phi i8* [ %incdec.ptr31, %if.then30 ], [ %call28, %if.end27 ]
  %20 = load i8*, i8** %curr, align 8, !tbaa !7
  %call33 = call i64 @simple_strtoul(i8* %20, i8** %n, i32 0)
  %21 = load i8*, i8** %n, align 8, !tbaa !7
  %22 = load i8, i8* %21, align 1, !tbaa !6
  %conv34 = sext i8 %22 to i32
  %cmp35 = icmp ne i32 %conv34, 0
  br i1 %cmp35, label %if.then40, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end32
  %23 = load i8*, i8** %curr, align 8, !tbaa !7
  %24 = load i8, i8* %23, align 1, !tbaa !6
  %conv37 = sext i8 %24 to i32
  %cmp38 = icmp eq i32 %conv37, 0
  br i1 %cmp38, label %if.then40, label %if.end42

if.then40:                                        ; preds = %lor.lhs.false, %if.end32
  %25 = load i8*, i8** %curr, align 8, !tbaa !7
  %call41 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.3, i32 0, i32 0), i8* %25)
  br label %out

if.end42:                                         ; preds = %lor.lhs.false
  br label %while.cond43

while.cond43:                                     ; preds = %while.cond43.backedge, %if.end42
  %s.1 = phi i8* [ %s.0, %if.end42 ], [ %s.2, %while.cond43.backedge ]
  %tobool44 = icmp ne i8* %s.1, null
  br i1 %tobool44, label %while.body45, label %while.end101

while.body45:                                     ; preds = %while.cond43
  store i8* %s.1, i8** %curr, align 8, !tbaa !7
  %26 = load i8*, i8** %curr, align 8, !tbaa !7
  %call46 = call i8* @strchr(i8* %26, i32 44)
  %tobool47 = icmp ne i8* %call46, null
  br i1 %tobool47, label %if.then48, label %if.end50

if.then48:                                        ; preds = %while.body45
  store i8 0, i8* %call46, align 1, !tbaa !6
  %incdec.ptr49 = getelementptr inbounds i8, i8* %call46, i32 1
  br label %if.end50

if.end50:                                         ; preds = %if.then48, %while.body45
  %s.2 = phi i8* [ %incdec.ptr49, %if.then48 ], [ %call46, %while.body45 ]
  %27 = load i8*, i8** %curr, align 8, !tbaa !7
  %call51 = call i8* @strchr(i8* %27, i32 61)
  %tobool52 = icmp ne i8* %call51, null
  br i1 %tobool52, label %if.then53, label %if.end55

if.then53:                                        ; preds = %if.end50
  store i8 0, i8* %call51, align 1, !tbaa !6
  %incdec.ptr54 = getelementptr inbounds i8, i8* %call51, i32 1
  br label %if.end55

if.end55:                                         ; preds = %if.then53, %if.end50
  %o.0 = phi i8* [ %incdec.ptr54, %if.then53 ], [ %call51, %if.end50 ]
  %28 = load i8*, i8** %curr, align 8, !tbaa !7
  %call56 = call i32 @check_hotmod_int_op(i8* %28, i8* %o.0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i32* %regspacing)
  %cmp57 = icmp slt i32 %call56, 0
  br i1 %cmp57, label %out, label %if.else

if.else:                                          ; preds = %if.end55
  %tobool60 = icmp ne i32 %call56, 0
  br i1 %tobool60, label %while.cond43.backedge, label %if.end63

while.cond43.backedge:                            ; preds = %if.else95, %if.else86, %if.else77, %if.else68, %if.else
  br label %while.cond43

if.end63:                                         ; preds = %if.else
  %29 = load i8*, i8** %curr, align 8, !tbaa !7
  %call64 = call i32 @check_hotmod_int_op(i8* %29, i8* %o.0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i32* %regsize)
  %cmp65 = icmp slt i32 %call64, 0
  br i1 %cmp65, label %out, label %if.else68

if.else68:                                        ; preds = %if.end63
  %tobool69 = icmp ne i32 %call64, 0
  br i1 %tobool69, label %while.cond43.backedge, label %if.end72

if.end72:                                         ; preds = %if.else68
  %30 = load i8*, i8** %curr, align 8, !tbaa !7
  %call73 = call i32 @check_hotmod_int_op(i8* %30, i8* %o.0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i32* %regshift)
  %cmp74 = icmp slt i32 %call73, 0
  br i1 %cmp74, label %out, label %if.else77

if.else77:                                        ; preds = %if.end72
  %tobool78 = icmp ne i32 %call73, 0
  br i1 %tobool78, label %while.cond43.backedge, label %if.end81

if.end81:                                         ; preds = %if.else77
  %31 = load i8*, i8** %curr, align 8, !tbaa !7
  %call82 = call i32 @check_hotmod_int_op(i8* %31, i8* %o.0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0), i32* %irq)
  %cmp83 = icmp slt i32 %call82, 0
  br i1 %cmp83, label %out, label %if.else86

if.else86:                                        ; preds = %if.end81
  %tobool87 = icmp ne i32 %call82, 0
  br i1 %tobool87, label %while.cond43.backedge, label %if.end90

if.end90:                                         ; preds = %if.else86
  %32 = load i8*, i8** %curr, align 8, !tbaa !7
  %call91 = call i32 @check_hotmod_int_op(i8* %32, i8* %o.0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.8, i32 0, i32 0), i32* %ipmb)
  %cmp92 = icmp slt i32 %call91, 0
  br i1 %cmp92, label %out, label %if.else95

if.else95:                                        ; preds = %if.end90
  %tobool96 = icmp ne i32 %call91, 0
  br i1 %tobool96, label %while.cond43.backedge, label %if.end99

if.end99:                                         ; preds = %if.else95
  %33 = load i8*, i8** %curr, align 8, !tbaa !7
  %call100 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.9, i32 0, i32 0), i8* %33)
  br label %out

while.end101:                                     ; preds = %while.cond43
  %cmp102 = icmp eq i32 %17, 0
  br i1 %cmp102, label %if.then104, label %if.else153

if.then104:                                       ; preds = %while.end101
  %call105 = call %struct.smi_info* @smi_info_alloc()
  %tobool106 = icmp ne %struct.smi_info* %call105, null
  br i1 %tobool106, label %if.end108, label %out

if.end108:                                        ; preds = %if.then104
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 15
  store i32 1, i32* %addr_source, align 4, !tbaa !9
  %si_type109 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 4
  store i32 %18, i32* %si_type109, align 8, !tbaa !21
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  store i64 %call33, i64* %addr_data, align 8, !tbaa !22
  %34 = load i32, i32* %addr_space, align 4, !tbaa !2
  %io110 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 9
  %addr_type = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io110, i32 0, i32 6
  store i32 %34, i32* %addr_type, align 4, !tbaa !23
  %35 = load i32, i32* %addr_space, align 4, !tbaa !2
  %cmp111 = icmp eq i32 %35, 1
  %io_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 10
  %port_setup.sink = select i1 %cmp111, i32 (%struct.smi_info*)* @mem_setup, i32 (%struct.smi_info*)* @port_setup
  store i32 (%struct.smi_info*)* %port_setup.sink, i32 (%struct.smi_info*)** %io_setup, align 8, !tbaa !24
  %io117 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 9
  %addr118 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io117, i32 0, i32 2
  store i8* null, i8** %addr118, align 8, !tbaa !25
  %36 = load i32, i32* %regspacing, align 4, !tbaa !2
  %io119 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 9
  %regspacing120 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io119, i32 0, i32 3
  store i32 %36, i32* %regspacing120, align 8, !tbaa !26
  %io121 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 9
  %regspacing122 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io121, i32 0, i32 3
  %37 = load i32, i32* %regspacing122, align 8, !tbaa !26
  %tobool123 = icmp ne i32 %37, 0
  br i1 %tobool123, label %if.end127, label %if.then124

if.then124:                                       ; preds = %if.end108
  %io125 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 9
  %regspacing126 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io125, i32 0, i32 3
  store i32 1, i32* %regspacing126, align 8, !tbaa !26
  br label %if.end127

if.end127:                                        ; preds = %if.then124, %if.end108
  %38 = load i32, i32* %regsize, align 4, !tbaa !2
  %io128 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 9
  %regsize129 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io128, i32 0, i32 4
  store i32 %38, i32* %regsize129, align 4, !tbaa !27
  %io130 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 9
  %regsize131 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io130, i32 0, i32 4
  %39 = load i32, i32* %regsize131, align 4, !tbaa !27
  %tobool132 = icmp ne i32 %39, 0
  br i1 %tobool132, label %if.end136, label %if.then133

if.then133:                                       ; preds = %if.end127
  %io134 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 9
  %regsize135 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io134, i32 0, i32 4
  store i32 1, i32* %regsize135, align 4, !tbaa !27
  br label %if.end136

if.end136:                                        ; preds = %if.then133, %if.end127
  %40 = load i32, i32* %regshift, align 4, !tbaa !2
  %io137 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 9
  %regshift138 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io137, i32 0, i32 5
  store i32 %40, i32* %regshift138, align 8, !tbaa !28
  %41 = load i32, i32* %irq, align 4, !tbaa !2
  %irq139 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 25
  store i32 %41, i32* %irq139, align 4, !tbaa !29
  %irq140 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 25
  %42 = load i32, i32* %irq140, align 4, !tbaa !29
  %tobool141 = icmp ne i32 %42, 0
  br i1 %tobool141, label %if.then142, label %if.end143

if.then142:                                       ; preds = %if.end136
  %irq_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 12
  store i32 (%struct.smi_info*)* @std_irq_setup, i32 (%struct.smi_info*)** %irq_setup, align 8, !tbaa !30
  br label %if.end143

if.end143:                                        ; preds = %if.then142, %if.end136
  %43 = load i32, i32* %ipmb, align 4, !tbaa !2
  %conv144 = trunc i32 %43 to i8
  %slave_addr = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call105, i32 0, i32 39
  store i8 %conv144, i8* %slave_addr, align 1, !tbaa !31
  %call145 = call i32 @add_smi(%struct.smi_info* %call105)
  %tobool146 = icmp ne i32 %call145, 0
  br i1 %tobool146, label %if.then147, label %if.end148

if.then147:                                       ; preds = %if.end143
  %44 = bitcast %struct.smi_info* %call105 to i8*
  call void @kfree(i8* %44)
  br label %out

if.end148:                                        ; preds = %if.end143
  %call149 = call i32 @try_smi_init(%struct.smi_info* %call105)
  %tobool150 = icmp ne i32 %call149, 0
  br i1 %tobool150, label %if.then151, label %for.inc186

if.then151:                                       ; preds = %if.end148
  call void @cleanup_one_si(%struct.smi_info* %call105)
  br label %out

if.else153:                                       ; preds = %while.end101
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  %45 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.list_head, %struct.list_head* @smi_infos, i32 0, i32 0), align 8, !tbaa !32
  %46 = bitcast %struct.list_head* %45 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %46, i64 -496
  %47 = bitcast i8* %add.ptr to %struct.smi_info*
  br label %for.cond158

for.cond158:                                      ; preds = %for.inc, %if.else153
  %.sink = phi %struct.smi_info* [ %50, %for.inc ], [ %47, %if.else153 ]
  %e.0 = phi %struct.smi_info* [ %47, %if.else153 ], [ %50, %for.inc ]
  %link181 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %.sink, i32 0, i32 42
  %next182 = getelementptr inbounds %struct.list_head, %struct.list_head* %link181, i32 0, i32 0
  %48 = load %struct.list_head*, %struct.list_head** %next182, align 8, !tbaa !33
  %49 = bitcast %struct.list_head* %48 to i8*
  %add.ptr184 = getelementptr inbounds i8, i8* %49, i64 -496
  %50 = bitcast i8* %add.ptr184 to %struct.smi_info*
  %link159 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %e.0, i32 0, i32 42
  %cmp160 = icmp ne %struct.list_head* %link159, @smi_infos
  br i1 %cmp160, label %for.body162, label %for.end

for.body162:                                      ; preds = %for.cond158
  %io163 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %e.0, i32 0, i32 9
  %addr_type164 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io163, i32 0, i32 6
  %51 = load i32, i32* %addr_type164, align 4, !tbaa !23
  %52 = load i32, i32* %addr_space, align 4, !tbaa !2
  %cmp165 = icmp ne i32 %51, %52
  br i1 %cmp165, label %for.inc, label %if.end168

if.end168:                                        ; preds = %for.body162
  %si_type169 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %e.0, i32 0, i32 4
  %53 = load i32, i32* %si_type169, align 8, !tbaa !21
  %cmp170 = icmp ne i32 %53, %18
  br i1 %cmp170, label %for.inc, label %if.end173

if.end173:                                        ; preds = %if.end168
  %io174 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %e.0, i32 0, i32 9
  %addr_data175 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io174, i32 0, i32 7
  %54 = load i64, i64* %addr_data175, align 8, !tbaa !22
  %cmp176 = icmp eq i64 %54, %call33
  br i1 %cmp176, label %if.then178, label %for.inc

if.then178:                                       ; preds = %if.end173
  call void @cleanup_one_si(%struct.smi_info* %e.0)
  br label %for.inc

for.inc:                                          ; preds = %if.then178, %if.end173, %if.end168, %for.body162
  br label %for.cond158

for.end:                                          ; preds = %for.cond158
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  br label %for.inc186

for.inc186:                                       ; preds = %for.end, %if.end148
  store i8* %next.0, i8** %curr, align 8, !tbaa !7
  br label %for.cond

out:                                              ; preds = %if.then151, %if.then147, %if.then104, %if.end99, %if.end90, %if.end81, %if.end72, %if.end63, %if.end55, %if.then40, %if.end23, %if.end19, %if.end15, %for.cond
  %rv.0 = phi i32 [ -22, %if.end99 ], [ %call145, %if.then147 ], [ %call149, %if.then151 ], [ %call56, %if.end55 ], [ %call64, %if.end63 ], [ %call73, %if.end72 ], [ %call82, %if.end81 ], [ %call91, %if.end90 ], [ -12, %if.then104 ], [ %conv, %for.cond ], [ %conv, %if.end23 ], [ %conv, %if.end19 ], [ %conv, %if.end15 ], [ %conv, %if.then40 ]
  call void @kfree(i8* %call)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %rv.0, %out ], [ -12, %entry ]
  %55 = bitcast i32* %ival to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %55) #7
  %56 = bitcast i32* %ipmb to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %56) #7
  %57 = bitcast i32* %irq to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %57) #7
  %58 = bitcast i32* %regshift to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %58) #7
  %59 = bitcast i32* %regsize to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %59) #7
  %60 = bitcast i32* %regspacing to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %60) #7
  %61 = bitcast i32* %addr_space to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %61) #7
  %62 = bitcast i8** %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %62) #7
  %63 = bitcast i8** %curr to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %63) #7
  ret i32 %retval.0
}

declare noalias i8* @kstrdup(i8*, i32) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

declare i64 @strlen(i8*) #1

declare i8* @strchr(i8*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @parse_str(%struct.hotmod_vals* %v, i32* %val, i8* %name, i8** %curr) #0 {
entry:
  %0 = load i8*, i8** %curr, align 8, !tbaa !7
  %call = call i8* @strchr(i8* %0, i32 44)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.10, i32 0, i32 0), i8* %name)
  br label %cleanup

if.end:                                           ; preds = %entry
  store i8 0, i8* %call, align 1, !tbaa !6
  %incdec.ptr = getelementptr inbounds i8, i8* %call, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %v, i64 %idxprom
  %name2 = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %name2, align 8, !tbaa !34
  %tobool3 = icmp ne i8* %1, null
  %2 = load i8*, i8** %curr, align 8, !tbaa !7
  br i1 %tobool3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %v, i64 %idxprom4
  %name6 = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %arrayidx5, i32 0, i32 0
  %3 = load i8*, i8** %name6, align 8, !tbaa !34
  %call7 = call i32 @strcmp(i8* %2, i8* %3)
  %cmp = icmp eq i32 %call7, 0
  br i1 %cmp, label %if.then8, label %for.inc

if.then8:                                         ; preds = %for.body
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %v, i64 %idxprom9
  %val11 = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %arrayidx10, i32 0, i32 1
  %4 = load i32, i32* %val11, align 8, !tbaa !36
  store i32 %4, i32* %val, align 4, !tbaa !2
  store i8* %incdec.ptr, i8** %curr, align 8, !tbaa !7
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call13 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.11, i32 0, i32 0), i8* %name, i8* %2)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then8, %if.then
  %retval.0 = phi i32 [ 0, %if.then8 ], [ -22, %for.end ], [ -22, %if.then ]
  ret i32 %retval.0
}

declare i64 @simple_strtoul(i8*, i8**, i32) #1

declare i32 @printk(i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @check_hotmod_int_op(i8* %curr, i8* %option, i8* %name, i32* %val) #0 {
entry:
  %n = alloca i8*, align 8
  %0 = bitcast i8** %n to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %call = call i32 @strcmp(i8* %curr, i8* %name)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %tobool = icmp ne i8* %option, null
  br i1 %tobool, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.19, i32 0, i32 0), i8* %curr)
  br label %cleanup

if.end:                                           ; preds = %if.then
  %call3 = call i64 @simple_strtoul(i8* %option, i8** %n, i32 0)
  %conv = trunc i64 %call3 to i32
  store i32 %conv, i32* %val, align 4, !tbaa !2
  %1 = load i8*, i8** %n, align 8, !tbaa !7
  %2 = load i8, i8* %1, align 1, !tbaa !6
  %conv4 = sext i8 %2 to i32
  %cmp5 = icmp ne i32 %conv4, 0
  br i1 %cmp5, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load i8, i8* %option, align 1, !tbaa !6
  %conv7 = sext i8 %3 to i32
  %cmp8 = icmp eq i32 %conv7, 0
  br i1 %cmp8, label %if.then10, label %cleanup

if.then10:                                        ; preds = %lor.lhs.false, %if.end
  %call11 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.20, i32 0, i32 0), i8* %curr)
  br label %cleanup

cleanup:                                          ; preds = %if.then10, %lor.lhs.false, %if.then1, %entry
  %retval.0 = phi i32 [ -22, %if.then10 ], [ -22, %if.then1 ], [ 1, %lor.lhs.false ], [ 0, %entry ]
  %4 = bitcast i8** %n to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.smi_info* @smi_info_alloc() #0 {
entry:
  %call = call i8* @kzalloc(i64 520, i32 20971712)
  %0 = bitcast i8* %call to %struct.smi_info*
  %tobool = icmp ne %struct.smi_info* %0, null
  br i1 %tobool, label %do.body, label %if.end

do.body:                                          ; preds = %entry
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %call1 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %si_lock)
  %si_lock3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock3, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.21, i32 0, i32 0), %struct.lock_class_key* @smi_info_alloc.__key)
  br label %if.end

if.end:                                           ; preds = %do.body, %entry
  ret %struct.smi_info* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @mem_setup(%struct.smi_info* %info) #0 {
entry:
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !22
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %io_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 11
  store void (%struct.smi_info*)* @mem_cleanup, void (%struct.smi_info*)** %io_cleanup, align 8, !tbaa !37
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 4
  %1 = load i32, i32* %regsize, align 4, !tbaa !27
  %Pivot10 = icmp slt i32 %1, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %if.end
  %Pivot8 = icmp slt i32 %1, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %1, 8
  br i1 %SwitchLeaf6, label %sw.epilog, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %1, 4
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %1, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %1, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %1, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 36
  %2 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  %io19 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize20 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io19, i32 0, i32 4
  %3 = load i32, i32* %regsize20, align 4, !tbaa !27
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %2, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.22, i32 0, i32 0), i32 %3)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %mem_inq.sink = phi i8 (%struct.si_sm_io*, i32)* [ @intf_mem_inw, %LeafBlock1 ], [ @intf_mem_inl, %LeafBlock3 ], [ @mem_inq, %LeafBlock5 ], [ @intf_mem_inb, %LeafBlock ]
  %mem_outq.sink = phi void (%struct.si_sm_io*, i32, i8)* [ @intf_mem_outw, %LeafBlock1 ], [ @intf_mem_outl, %LeafBlock3 ], [ @mem_outq, %LeafBlock5 ], [ @intf_mem_outb, %LeafBlock ]
  %io15 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %inputb16 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io15, i32 0, i32 0
  store i8 (%struct.si_sm_io*, i32)* %mem_inq.sink, i8 (%struct.si_sm_io*, i32)** %inputb16, align 8, !tbaa !39
  %io17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %outputb18 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io17, i32 0, i32 1
  store void (%struct.si_sm_io*, i32, i8)* %mem_outq.sink, void (%struct.si_sm_io*, i32, i8)** %outputb18, align 8, !tbaa !40
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %idx.0 = phi i32 [ 0, %sw.epilog ], [ %inc, %for.inc ]
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 14
  %4 = load i32, i32* %io_size, align 8, !tbaa !41
  %cmp = icmp ult i32 %idx.0, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %io21 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io21, i32 0, i32 3
  %5 = load i32, i32* %regspacing, align 8, !tbaa !26
  %mul = mul nsw i32 %idx.0, %5
  %conv = sext i32 %mul to i64
  %add = add i64 %0, %conv
  %io22 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize23 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io22, i32 0, i32 4
  %6 = load i32, i32* %regsize23, align 4, !tbaa !27
  %conv24 = sext i32 %6 to i64
  %call = call %struct.resource* @__request_region(%struct.resource* @iomem_resource, i64 %add, i64 %conv24, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i32 0)
  %cmp25 = icmp eq %struct.resource* %call, null
  br i1 %cmp25, label %if.then27, label %for.inc

if.then27:                                        ; preds = %for.body
  call void @mem_region_cleanup(%struct.smi_info* %info, i32 %idx.0)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %io_size29 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 14
  %7 = load i32, i32* %io_size29, align 8, !tbaa !41
  %io30 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regspacing31 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io30, i32 0, i32 3
  %8 = load i32, i32* %regspacing31, align 8, !tbaa !26
  %mul32 = mul i32 %7, %8
  %io33 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regspacing34 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io33, i32 0, i32 3
  %9 = load i32, i32* %regspacing34, align 8, !tbaa !26
  %io35 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize36 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io35, i32 0, i32 4
  %10 = load i32, i32* %regsize36, align 4, !tbaa !27
  %sub = sub nsw i32 %9, %10
  %sub37 = sub i32 %mul32, %sub
  %conv38 = sext i32 %sub37 to i64
  %call39 = call i8* @ioremap(i64 %0, i64 %conv38)
  %io40 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %addr41 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io40, i32 0, i32 2
  store i8* %call39, i8** %addr41, align 8, !tbaa !25
  %io42 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %addr43 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io42, i32 0, i32 2
  %11 = load i8*, i8** %addr43, align 8, !tbaa !25
  %cmp44 = icmp eq i8* %11, null
  br i1 %cmp44, label %if.then46, label %cleanup

if.then46:                                        ; preds = %for.end
  %io_size47 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 14
  %12 = load i32, i32* %io_size47, align 8, !tbaa !41
  call void @mem_region_cleanup(%struct.smi_info* %info, i32 %12)
  br label %cleanup

cleanup:                                          ; preds = %if.then46, %for.end, %if.then27, %sw.default, %entry
  %retval.0 = phi i32 [ -5, %if.then27 ], [ -5, %if.then46 ], [ -22, %sw.default ], [ -19, %entry ], [ 0, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @port_setup(%struct.smi_info* %info) #0 {
entry:
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !22
  %conv = trunc i64 %0 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %io_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 11
  store void (%struct.smi_info*)* @port_cleanup, void (%struct.smi_info*)** %io_cleanup, align 8, !tbaa !37
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 4
  %1 = load i32, i32* %regsize, align 4, !tbaa !27
  %Pivot6 = icmp slt i32 %1, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %1, 4
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %1, 4
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %1, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %1, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 36
  %2 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  %io14 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize15 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io14, i32 0, i32 4
  %3 = load i32, i32* %regsize15, align 4, !tbaa !27
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %2, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.22, i32 0, i32 0), i32 %3)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %port_inl.sink = phi i8 (%struct.si_sm_io*, i32)* [ @port_inw, %LeafBlock1 ], [ @port_inl, %LeafBlock3 ], [ @port_inb, %LeafBlock ]
  %port_outl.sink = phi void (%struct.si_sm_io*, i32, i8)* [ @port_outw, %LeafBlock1 ], [ @port_outl, %LeafBlock3 ], [ @port_outb, %LeafBlock ]
  %io10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %inputb11 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io10, i32 0, i32 0
  store i8 (%struct.si_sm_io*, i32)* %port_inl.sink, i8 (%struct.si_sm_io*, i32)** %inputb11, align 8, !tbaa !39
  %io12 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %outputb13 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io12, i32 0, i32 1
  store void (%struct.si_sm_io*, i32, i8)* %port_outl.sink, void (%struct.si_sm_io*, i32, i8)** %outputb13, align 8, !tbaa !40
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %idx.0 = phi i32 [ 0, %sw.epilog ], [ %inc, %for.inc ]
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 14
  %4 = load i32, i32* %io_size, align 8, !tbaa !41
  %cmp = icmp ult i32 %idx.0, %4
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %io17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io17, i32 0, i32 3
  %5 = load i32, i32* %regspacing, align 8, !tbaa !26
  %mul = mul nsw i32 %idx.0, %5
  %add = add i32 %conv, %mul
  %conv18 = zext i32 %add to i64
  %io19 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize20 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io19, i32 0, i32 4
  %6 = load i32, i32* %regsize20, align 4, !tbaa !27
  %conv21 = sext i32 %6 to i64
  %call = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv18, i64 %conv21, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i32 0)
  %cmp22 = icmp eq %struct.resource* %call, null
  br i1 %cmp22, label %if.then24, label %for.inc

if.then24:                                        ; preds = %for.body
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then24
  %idx.1 = phi i32 [ %idx.0, %if.then24 ], [ %dec, %while.body ]
  %dec = add nsw i32 %idx.1, -1
  %tobool25 = icmp ne i32 %idx.1, 0
  br i1 %tobool25, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %io26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regspacing27 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io26, i32 0, i32 3
  %7 = load i32, i32* %regspacing27, align 8, !tbaa !26
  %mul28 = mul nsw i32 %dec, %7
  %add29 = add i32 %conv, %mul28
  %conv30 = zext i32 %add29 to i64
  %io31 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize32 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io31, i32 0, i32 4
  %8 = load i32, i32* %regsize32, align 4, !tbaa !27
  %conv33 = sext i32 %8 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv30, i64 %conv33)
  br label %while.cond

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

cleanup:                                          ; preds = %while.cond, %for.cond, %sw.default, %entry
  %retval.0 = phi i32 [ -22, %sw.default ], [ -19, %entry ], [ -5, %while.cond ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @std_irq_setup(%struct.smi_info* %info) #0 {
entry:
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %0 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 4
  %1 = load i32, i32* %si_type, align 8, !tbaa !21
  %cmp = icmp eq i32 %1, 2
  %irq2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %2 = load i32, i32* %irq2, align 4, !tbaa !29
  %3 = bitcast %struct.smi_info* %info to i8*
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %call = call i32 @request_irq(i32 %2, i32 (i32, i8*)* @si_bt_irq_handler, i64 128, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i8* %3)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.end9, label %if.then4

if.then4:                                         ; preds = %if.then1
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 1
  %4 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !40
  %io5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  call void %4(%struct.si_sm_io* %io5, i32 2, i8 zeroext 1)
  br label %if.end9

if.else:                                          ; preds = %if.end
  %call8 = call i32 @request_irq(i32 %2, i32 (i32, i8*)* @si_irq_handler, i64 128, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i8* %3)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then4, %if.then1
  %rv.0 = phi i32 [ %call8, %if.else ], [ %call, %if.then4 ], [ %call, %if.then1 ]
  %tobool10 = icmp ne i32 %rv.0, 0
  br i1 %tobool10, label %if.then11, label %if.else14

if.then11:                                        ; preds = %if.end9
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 36
  %5 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  %irq12 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %6 = load i32, i32* %irq12, align 4, !tbaa !29
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %5, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i32 %6)
  %irq13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  store i32 0, i32* %irq13, align 4, !tbaa !29
  br label %cleanup

if.else14:                                        ; preds = %if.end9
  %irq_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 13
  store void (%struct.smi_info*)* @std_irq_cleanup, void (%struct.smi_info*)** %irq_cleanup, align 8, !tbaa !42
  %dev15 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 36
  %7 = load %struct.device*, %struct.device** %dev15, align 8, !tbaa !38
  %irq16 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %8 = load i32, i32* %irq16, align 4, !tbaa !29
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %7, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.25, i32 0, i32 0), i32 %8)
  br label %cleanup

cleanup:                                          ; preds = %if.else14, %if.then11, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %rv.0, %if.else14 ], [ %rv.0, %if.then11 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @add_smi(%struct.smi_info* %new_smi) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  %call = call i32 @is_new_interface(%struct.smi_info* %new_smi)
  %tobool = icmp ne i32 %call, 0
  %addr_source3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 15
  %0 = load i32, i32* %addr_source3, align 4, !tbaa !9
  %call4 = call i8* @ipmi_addr_src_to_str(i32 %0)
  %si_type5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 4
  %1 = load i32, i32* %si_type5, align 8, !tbaa !21
  %idxprom6 = zext i32 %1 to i64
  %arrayidx7 = getelementptr inbounds [3 x i8*], [3 x i8*]* @si_to_str, i64 0, i64 %idxprom6
  %2 = load i8*, i8** %arrayidx7, align 8, !tbaa !7
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.31, i32 0, i32 0), i8* %call4, i8* %2)
  br label %out_err

if.end:                                           ; preds = %entry
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.32, i32 0, i32 0), i8* %call4, i8* %2)
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  store %struct.ipmi_smi* null, %struct.ipmi_smi** %intf, align 8, !tbaa !43
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  store %struct.si_sm_data* null, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  store %struct.si_sm_handlers* null, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %link = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 42
  call void @list_add_tail(%struct.list_head* %link, %struct.list_head* @smi_infos)
  br label %out_err

out_err:                                          ; preds = %if.end, %if.then
  %rv.0 = phi i32 [ 0, %if.end ], [ -16, %if.then ]
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  ret i32 %rv.0
}

declare void @kfree(i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @try_smi_init(%struct.smi_info* %new_smi) #0 {
entry:
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 15
  %0 = load i32, i32* %addr_source, align 4, !tbaa !9
  %call = call i8* @ipmi_addr_src_to_str(i32 %0)
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 4
  %1 = load i32, i32* %si_type, align 8, !tbaa !21
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @si_to_str, i64 0, i64 %idxprom
  %2 = load i8*, i8** %arrayidx, align 8, !tbaa !7
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 9
  %addr_type = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 6
  %3 = load i32, i32* %addr_type, align 4, !tbaa !23
  %idxprom1 = sext i32 %3 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8*], [2 x i8*]* @addr_space_to_str, i64 0, i64 %idxprom1
  %4 = load i8*, i8** %arrayidx2, align 8, !tbaa !7
  %io3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io3, i32 0, i32 7
  %5 = load i64, i64* %addr_data, align 8, !tbaa !22
  %slave_addr = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 39
  %6 = load i8, i8* %slave_addr, align 1, !tbaa !31
  %conv = zext i8 %6 to i32
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 25
  %7 = load i32, i32* %irq, align 4, !tbaa !29
  %call4 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([97 x i8], [97 x i8]* @.str.33, i32 0, i32 0), i8* %call, i8* %2, i8* %4, i64 %5, i32 %conv, i32 %7)
  %si_type5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 4
  %8 = load i32, i32* %si_type5, align 8, !tbaa !21
  %Pivot4 = icmp slt i32 %8, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %8, 2
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %8, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %out_err

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %8, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %out_err

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %NodeBlock
  %bt_smi_handlers.sink = phi %struct.si_sm_handlers* [ bitcast (%struct.si_sm_handlers.178* @smic_smi_handlers to %struct.si_sm_handlers*), %NodeBlock ], [ bitcast (%struct.si_sm_handlers.268* @bt_smi_handlers to %struct.si_sm_handlers*), %LeafBlock1 ], [ @kcs_smi_handlers, %LeafBlock ]
  %handlers9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  store %struct.si_sm_handlers* %bt_smi_handlers.sink, %struct.si_sm_handlers** %handlers9, align 8, !tbaa !45
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %9 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  %tobool = icmp ne %struct.device* %9, null
  br i1 %tobool, label %if.end22, label %if.then

if.then:                                          ; preds = %sw.epilog
  %call10 = call noalias i8* (i32, i8*, ...) @kasprintf(i32 20971712, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34, i32 0, i32 0), i32 0)
  %intf_num = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 0
  %10 = load i32, i32* %intf_num, align 8, !tbaa !46
  %call11 = call %struct.platform_device* @platform_device_alloc(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i32 %10)
  %pdev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 37
  store %struct.platform_device* %call11, %struct.platform_device** %pdev, align 8, !tbaa !47
  %pdev12 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 37
  %11 = load %struct.platform_device*, %struct.platform_device** %pdev12, align 8, !tbaa !47
  %tobool13 = icmp ne %struct.platform_device* %11, null
  br i1 %tobool13, label %if.end, label %if.then14

if.then14:                                        ; preds = %if.then
  %call15 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.35, i32 0, i32 0))
  br label %out_err

if.end:                                           ; preds = %if.then
  %pdev16 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 37
  %12 = load %struct.platform_device*, %struct.platform_device** %pdev16, align 8, !tbaa !47
  %dev17 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %12, i32 0, i32 3
  %dev18 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  store %struct.device* %dev17, %struct.device** %dev18, align 8, !tbaa !38
  %dev19 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %13 = load %struct.device*, %struct.device** %dev19, align 8, !tbaa !38
  %driver = getelementptr inbounds %struct.device, %struct.device* %13, i32 0, i32 7
  store %struct.device_driver* getelementptr inbounds (%struct.platform_driver, %struct.platform_driver* @ipmi_driver, i32 0, i32 5), %struct.device_driver** %driver, align 8, !tbaa !48
  %dev20 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %14 = load %struct.device*, %struct.device** %dev20, align 8, !tbaa !38
  %init_name21 = getelementptr inbounds %struct.device, %struct.device* %14, i32 0, i32 3
  store i8* %call10, i8** %init_name21, align 8, !tbaa !66
  br label %if.end22

if.end22:                                         ; preds = %if.end, %sw.epilog
  %init_name.0 = phi i8* [ null, %sw.epilog ], [ %call10, %if.end ]
  %handlers23 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  %15 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers23, align 8, !tbaa !45
  %size = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %15, i32 0, i32 7
  %16 = load i32 ()*, i32 ()** %size, align 8, !tbaa !67
  %call24 = call i32 %16()
  %conv25 = sext i32 %call24 to i64
  %call26 = call i8* @kmalloc(i64 %conv25, i32 20971712)
  %17 = bitcast i8* %call26 to %struct.si_sm_data*
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  store %struct.si_sm_data* %17, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %si_sm27 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %18 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm27, align 8, !tbaa !44
  %tobool28 = icmp ne %struct.si_sm_data* %18, null
  br i1 %tobool28, label %if.end31, label %if.then29

if.then29:                                        ; preds = %if.end22
  %call30 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.36, i32 0, i32 0))
  br label %out_err

if.end31:                                         ; preds = %if.end22
  %handlers32 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  %19 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers32, align 8, !tbaa !45
  %init_data = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %19, i32 0, i32 1
  %20 = load i32 (%struct.si_sm_data*, %struct.si_sm_io*)*, i32 (%struct.si_sm_data*, %struct.si_sm_io*)** %init_data, align 8, !tbaa !69
  %si_sm33 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %21 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm33, align 8, !tbaa !44
  %io34 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 9
  %call35 = call i32 %20(%struct.si_sm_data* %21, %struct.si_sm_io* %io34)
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 14
  store i32 %call35, i32* %io_size, align 8, !tbaa !41
  %io_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 10
  %22 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %io_setup, align 8, !tbaa !24
  %call36 = call i32 %22(%struct.smi_info* %new_smi)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.then38, label %if.end40

if.then38:                                        ; preds = %if.end31
  %dev39 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %23 = load %struct.device*, %struct.device** %dev39, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %23, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.37, i32 0, i32 0))
  br label %out_err

if.end40:                                         ; preds = %if.end31
  %handlers41 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  %24 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers41, align 8, !tbaa !45
  %detect = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %24, i32 0, i32 5
  %25 = load i32 (%struct.si_sm_data*)*, i32 (%struct.si_sm_data*)** %detect, align 8, !tbaa !70
  %si_sm42 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %26 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm42, align 8, !tbaa !44
  %call43 = call i32 %25(%struct.si_sm_data* %26)
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %if.then45, label %if.end51

if.then45:                                        ; preds = %if.end40
  %addr_source46 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 15
  %27 = load i32, i32* %addr_source46, align 4, !tbaa !9
  %tobool47 = icmp ne i32 %27, 0
  br i1 %tobool47, label %if.then48, label %out_err

if.then48:                                        ; preds = %if.then45
  %dev49 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %28 = load %struct.device*, %struct.device** %dev49, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %28, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.38, i32 0, i32 0))
  br label %out_err

if.end51:                                         ; preds = %if.end40
  %call52 = call i32 @try_get_dev_id(%struct.smi_info* %new_smi)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.then54, label %if.end60

if.then54:                                        ; preds = %if.end51
  %addr_source55 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 15
  %29 = load i32, i32* %addr_source55, align 4, !tbaa !9
  %tobool56 = icmp ne i32 %29, 0
  br i1 %tobool56, label %if.then57, label %out_err

if.then57:                                        ; preds = %if.then54
  %dev58 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %30 = load %struct.device*, %struct.device** %dev58, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %30, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.39, i32 0, i32 0))
  br label %out_err

if.end60:                                         ; preds = %if.end51
  call void @setup_oem_data_handler(%struct.smi_info* %new_smi)
  call void @setup_xaction_handlers(%struct.smi_info* %new_smi)
  call void @check_for_broken_irqs(%struct.smi_info* %new_smi)
  %waiting_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 6
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %waiting_msg, align 8, !tbaa !71
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 7
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %req_events = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 21
  call void @atomic_set(%struct.atomic_t* %req_events, i32 0)
  %run_to_completion = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 22
  store i8 0, i8* %run_to_completion, align 8, !tbaa !73
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end60
  %i.0 = phi i32 [ 0, %if.end60 ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 40
  %idxprom62 = sext i32 %i.0 to i64
  %arrayidx63 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats, i64 0, i64 %idxprom62
  call void @atomic_set(%struct.atomic_t* %arrayidx63, i32 0)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 30
  store i8 1, i8* %interrupt_disabled, align 4, !tbaa !74
  %need_watch = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 29
  call void @atomic_set(%struct.atomic_t* %need_watch, i32 0)
  %31 = load i32, i32* @smi_num, align 4, !tbaa !2
  %intf_num64 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 0
  store i32 %31, i32* %intf_num64, align 8, !tbaa !46
  %32 = load i32, i32* @smi_num, align 4, !tbaa !2
  %inc65 = add nsw i32 %32, 1
  store i32 %inc65, i32* @smi_num, align 4, !tbaa !2
  %call66 = call i32 @try_enable_event_buffer(%struct.smi_info* %new_smi)
  %cmp67 = icmp eq i32 %call66, 0
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %for.end
  %has_event_buffer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 20
  store i8 1, i8* %has_event_buffer, align 1, !tbaa !75
  br label %if.end70

if.end70:                                         ; preds = %if.then69, %for.end
  call void @start_clear_flags(%struct.smi_info* %new_smi, i1 zeroext false)
  %irq71 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 25
  %33 = load i32, i32* %irq71, align 4, !tbaa !29
  %tobool72 = icmp ne i32 %33, 0
  br i1 %tobool72, label %if.then73, label %if.end76

if.then73:                                        ; preds = %if.end70
  %interrupt_disabled74 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 30
  store i8 0, i8* %interrupt_disabled74, align 4, !tbaa !74
  %req_events75 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 21
  call void @atomic_set(%struct.atomic_t* %req_events75, i32 1)
  br label %if.end76

if.end76:                                         ; preds = %if.then73, %if.end70
  %pdev77 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 37
  %34 = load %struct.platform_device*, %struct.platform_device** %pdev77, align 8, !tbaa !47
  %tobool78 = icmp ne %struct.platform_device* %34, null
  br i1 %tobool78, label %if.then79, label %if.end86

if.then79:                                        ; preds = %if.end76
  %pdev80 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 37
  %35 = load %struct.platform_device*, %struct.platform_device** %pdev80, align 8, !tbaa !47
  %call81 = call i32 @platform_device_add(%struct.platform_device* %35)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %if.then83, label %if.end85

if.then83:                                        ; preds = %if.then79
  %dev84 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %36 = load %struct.device*, %struct.device** %dev84, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %36, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.40, i32 0, i32 0), i32 %call81)
  br label %out_err

if.end85:                                         ; preds = %if.then79
  %dev_registered = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 38
  store i8 1, i8* %dev_registered, align 8, !tbaa !76
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %if.end76
  %37 = bitcast %struct.smi_info* %new_smi to i8*
  %device_id = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 35
  %dev87 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %38 = load %struct.device*, %struct.device** %dev87, align 8, !tbaa !38
  %slave_addr88 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 39
  %39 = load i8, i8* %slave_addr88, align 1, !tbaa !31
  %call89 = call i32 @ipmi_register_smi(%struct.ipmi_smi_handlers* @handlers, i8* %37, %struct.ipmi_device_id* %device_id, %struct.device* %38, i8 zeroext %39)
  %tobool90 = icmp ne i32 %call89, 0
  br i1 %tobool90, label %if.then91, label %if.end93

if.then91:                                        ; preds = %if.end86
  %dev92 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %40 = load %struct.device*, %struct.device** %dev92, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %40, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.41, i32 0, i32 0), i32 %call89)
  br label %out_err_stop_timer

if.end93:                                         ; preds = %if.end86
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  %41 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !43
  %42 = bitcast %struct.smi_info* %new_smi to i8*
  %call94 = call i32 @ipmi_smi_add_proc_entry(%struct.ipmi_smi* %41, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i32 0, i32 0), %struct.file_operations* @smi_type_proc_ops, i8* %42)
  %tobool95 = icmp ne i32 %call94, 0
  br i1 %tobool95, label %if.then96, label %if.end98

if.then96:                                        ; preds = %if.end93
  %dev97 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %43 = load %struct.device*, %struct.device** %dev97, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %43, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.43, i32 0, i32 0), i32 %call94)
  br label %out_err_stop_timer

if.end98:                                         ; preds = %if.end93
  %intf99 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  %44 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf99, align 8, !tbaa !43
  %45 = bitcast %struct.smi_info* %new_smi to i8*
  %call100 = call i32 @ipmi_smi_add_proc_entry(%struct.ipmi_smi* %44, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.44, i32 0, i32 0), %struct.file_operations* @smi_si_stats_proc_ops, i8* %45)
  %tobool101 = icmp ne i32 %call100, 0
  br i1 %tobool101, label %if.then102, label %if.end104

if.then102:                                       ; preds = %if.end98
  %dev103 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %46 = load %struct.device*, %struct.device** %dev103, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %46, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.43, i32 0, i32 0), i32 %call100)
  br label %out_err_stop_timer

if.end104:                                        ; preds = %if.end98
  %intf105 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  %47 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf105, align 8, !tbaa !43
  %48 = bitcast %struct.smi_info* %new_smi to i8*
  %call106 = call i32 @ipmi_smi_add_proc_entry(%struct.ipmi_smi* %47, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), %struct.file_operations* @smi_params_proc_ops, i8* %48)
  %tobool107 = icmp ne i32 %call106, 0
  %dev109 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %49 = load %struct.device*, %struct.device** %dev109, align 8, !tbaa !38
  br i1 %tobool107, label %if.then108, label %if.end110

if.then108:                                       ; preds = %if.end104
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %49, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.43, i32 0, i32 0), i32 %call106)
  br label %out_err_stop_timer

if.end110:                                        ; preds = %if.end104
  %si_type112 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 4
  %50 = load i32, i32* %si_type112, align 8, !tbaa !21
  %idxprom113 = zext i32 %50 to i64
  %arrayidx114 = getelementptr inbounds [3 x i8*], [3 x i8*]* @si_to_str, i64 0, i64 %idxprom113
  %51 = load i8*, i8** %arrayidx114, align 8, !tbaa !7
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %49, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.46, i32 0, i32 0), i8* %51)
  %dev115 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %52 = load %struct.device*, %struct.device** %dev115, align 8, !tbaa !38
  %init_name116 = getelementptr inbounds %struct.device, %struct.device* %52, i32 0, i32 3
  %53 = load i8*, i8** %init_name116, align 8, !tbaa !66
  %cmp117 = icmp ne i8* %53, null
  %lnot = xor i1 %cmp117, true
  %lnot119 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot119 to i32
  %tobool120 = icmp ne i32 %lnot.ext, 0
  %lnot121 = xor i1 %tobool120, true
  %lnot123 = xor i1 %lnot121, true
  %lnot.ext124 = zext i1 %lnot123 to i32
  %conv125 = sext i32 %lnot.ext124 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv125, i64 0)
  %tobool126 = icmp ne i64 %expval, 0
  br i1 %tobool126, label %if.then127, label %if.end128

if.then127:                                       ; preds = %if.end110
  call void @warn_slowpath_null(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.47, i32 0, i32 0), i32 3667)
  br label %if.end128

if.end128:                                        ; preds = %if.then127, %if.end110
  %tobool129 = icmp ne i32 %lnot.ext, 0
  %lnot130 = xor i1 %tobool129, true
  %lnot132 = xor i1 %lnot130, true
  %lnot.ext133 = zext i1 %lnot132 to i32
  %conv134 = sext i32 %lnot.ext133 to i64
  %expval135 = call i64 @llvm.expect.i64(i64 %conv134, i64 0)
  call void @kfree(i8* %init_name.0)
  br label %cleanup185

out_err_stop_timer:                               ; preds = %if.then108, %if.then102, %if.then96, %if.then91
  %rv.0 = phi i32 [ %call89, %if.then91 ], [ %call94, %if.then96 ], [ %call100, %if.then102 ], [ %call106, %if.then108 ]
  call void @wait_for_timer_and_thread(%struct.smi_info* %new_smi)
  br label %out_err

out_err:                                          ; preds = %out_err_stop_timer, %if.then83, %if.then57, %if.then54, %if.then48, %if.then45, %if.then38, %if.then29, %if.then14, %LeafBlock, %LeafBlock1
  %init_name.1 = phi i8* [ %init_name.0, %if.then38 ], [ %init_name.0, %if.then83 ], [ %init_name.0, %out_err_stop_timer ], [ %init_name.0, %if.then29 ], [ %call10, %if.then14 ], [ null, %LeafBlock ], [ null, %LeafBlock1 ], [ %init_name.0, %if.then48 ], [ %init_name.0, %if.then45 ], [ %init_name.0, %if.then57 ], [ %init_name.0, %if.then54 ]
  %rv.1 = phi i32 [ %call36, %if.then38 ], [ %call81, %if.then83 ], [ %rv.0, %out_err_stop_timer ], [ -12, %if.then29 ], [ 0, %if.then14 ], [ -5, %LeafBlock ], [ -5, %LeafBlock1 ], [ -19, %if.then48 ], [ -19, %if.then45 ], [ %call52, %if.then57 ], [ %call52, %if.then54 ]
  %interrupt_disabled136 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 30
  store i8 1, i8* %interrupt_disabled136, align 4, !tbaa !74
  %intf137 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  %54 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf137, align 8, !tbaa !43
  %tobool138 = icmp ne %struct.ipmi_smi* %54, null
  br i1 %tobool138, label %if.then139, label %if.end144

if.then139:                                       ; preds = %out_err
  %intf141 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  %55 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf141, align 8, !tbaa !43
  %intf142 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  store %struct.ipmi_smi* null, %struct.ipmi_smi** %intf142, align 8, !tbaa !43
  %call143 = call i32 @ipmi_unregister_smi(%struct.ipmi_smi* %55)
  br label %if.end144

if.end144:                                        ; preds = %if.then139, %out_err
  %irq_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 13
  %56 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %irq_cleanup, align 8, !tbaa !42
  %tobool145 = icmp ne void (%struct.smi_info*)* %56, null
  br i1 %tobool145, label %if.then146, label %if.end149

if.then146:                                       ; preds = %if.end144
  %irq_cleanup147 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 13
  %57 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %irq_cleanup147, align 8, !tbaa !42
  call void %57(%struct.smi_info* %new_smi)
  %irq_cleanup148 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 13
  store void (%struct.smi_info*)* null, void (%struct.smi_info*)** %irq_cleanup148, align 8, !tbaa !42
  br label %if.end149

if.end149:                                        ; preds = %if.then146, %if.end144
  call void @synchronize_sched()
  %si_sm150 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %58 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm150, align 8, !tbaa !44
  %tobool151 = icmp ne %struct.si_sm_data* %58, null
  br i1 %tobool151, label %if.then152, label %if.end161

if.then152:                                       ; preds = %if.end149
  %handlers153 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  %59 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers153, align 8, !tbaa !45
  %tobool154 = icmp ne %struct.si_sm_handlers* %59, null
  br i1 %tobool154, label %if.then155, label %if.end158

if.then155:                                       ; preds = %if.then152
  %handlers156 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  %60 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers156, align 8, !tbaa !45
  %cleanup = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %60, i32 0, i32 6
  %61 = load void (%struct.si_sm_data*)*, void (%struct.si_sm_data*)** %cleanup, align 8, !tbaa !77
  %si_sm157 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %62 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm157, align 8, !tbaa !44
  call void %61(%struct.si_sm_data* %62)
  br label %if.end158

if.end158:                                        ; preds = %if.then155, %if.then152
  %si_sm159 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %63 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm159, align 8, !tbaa !44
  %64 = bitcast %struct.si_sm_data* %63 to i8*
  call void @kfree(i8* %64)
  %si_sm160 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  store %struct.si_sm_data* null, %struct.si_sm_data** %si_sm160, align 8, !tbaa !44
  br label %if.end161

if.end161:                                        ; preds = %if.end158, %if.end149
  %addr_source_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 16
  %65 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %addr_source_cleanup, align 8, !tbaa !78
  %tobool162 = icmp ne void (%struct.smi_info*)* %65, null
  br i1 %tobool162, label %if.then163, label %if.end166

if.then163:                                       ; preds = %if.end161
  %addr_source_cleanup164 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 16
  %66 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %addr_source_cleanup164, align 8, !tbaa !78
  call void %66(%struct.smi_info* %new_smi)
  %addr_source_cleanup165 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 16
  store void (%struct.smi_info*)* null, void (%struct.smi_info*)** %addr_source_cleanup165, align 8, !tbaa !78
  br label %if.end166

if.end166:                                        ; preds = %if.then163, %if.end161
  %io_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 11
  %67 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %io_cleanup, align 8, !tbaa !37
  %tobool167 = icmp ne void (%struct.smi_info*)* %67, null
  br i1 %tobool167, label %if.then168, label %if.end171

if.then168:                                       ; preds = %if.end166
  %io_cleanup169 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 11
  %68 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %io_cleanup169, align 8, !tbaa !37
  call void %68(%struct.smi_info* %new_smi)
  %io_cleanup170 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 11
  store void (%struct.smi_info*)* null, void (%struct.smi_info*)** %io_cleanup170, align 8, !tbaa !37
  br label %if.end171

if.end171:                                        ; preds = %if.then168, %if.end166
  %dev_registered172 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 38
  %69 = load i8, i8* %dev_registered172, align 8, !tbaa !76, !range !79
  %tobool173 = trunc i8 %69 to i1
  %pdev175 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 37
  %70 = load %struct.platform_device*, %struct.platform_device** %pdev175, align 8, !tbaa !47
  br i1 %tobool173, label %if.then174, label %if.else

if.then174:                                       ; preds = %if.end171
  call void @platform_device_unregister(%struct.platform_device* %70)
  %dev_registered176 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 38
  store i8 0, i8* %dev_registered176, align 8, !tbaa !76
  br label %if.end184.sink.split

if.else:                                          ; preds = %if.end171
  %tobool179 = icmp ne %struct.platform_device* %70, null
  br i1 %tobool179, label %if.then180, label %if.end184

if.then180:                                       ; preds = %if.else
  %pdev181 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 37
  %71 = load %struct.platform_device*, %struct.platform_device** %pdev181, align 8, !tbaa !47
  call void @platform_device_put(%struct.platform_device* %71)
  br label %if.end184.sink.split

if.end184.sink.split:                             ; preds = %if.then180, %if.then174
  %pdev182 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 37
  store %struct.platform_device* null, %struct.platform_device** %pdev182, align 8, !tbaa !47
  br label %if.end184

if.end184:                                        ; preds = %if.end184.sink.split, %if.else
  call void @kfree(i8* %init_name.1)
  br label %cleanup185

cleanup185:                                       ; preds = %if.end184, %if.end128
  %retval.0 = phi i32 [ %rv.1, %if.end184 ], [ 0, %if.end128 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @cleanup_one_si(%struct.smi_info* %to_clean) #0 {
entry:
  %tobool = icmp ne %struct.smi_info* %to_clean, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 1
  %0 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !43
  %tobool1 = icmp ne %struct.ipmi_smi* %0, null
  br i1 %tobool1, label %if.then2, label %if.end10

if.then2:                                         ; preds = %if.end
  %intf4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 1
  %1 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf4, align 8, !tbaa !43
  %intf5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 1
  store %struct.ipmi_smi* null, %struct.ipmi_smi** %intf5, align 8, !tbaa !43
  %call = call i32 @ipmi_unregister_smi(%struct.ipmi_smi* %1)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.then2
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.96, i32 0, i32 0), i32 %call)
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.then2, %if.end
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 36
  %2 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  %tobool11 = icmp ne %struct.device* %2, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %dev13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 36
  %3 = load %struct.device*, %struct.device** %dev13, align 8, !tbaa !38
  call void @dev_set_drvdata(%struct.device* %3, i8* null)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %link = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 42
  call void @list_del(%struct.list_head* %link)
  %irq_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 13
  %4 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %irq_cleanup, align 8, !tbaa !42
  %tobool15 = icmp ne void (%struct.smi_info*)* %4, null
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  %irq_cleanup17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 13
  %5 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %irq_cleanup17, align 8, !tbaa !42
  call void %5(%struct.smi_info* %to_clean)
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end14
  call void @wait_for_timer_and_thread(%struct.smi_info* %to_clean)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end18
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 7
  %6 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %tobool19 = icmp ne %struct.ipmi_smi_msg* %6, null
  br i1 %tobool19, label %while.body, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 8
  %7 = load i32, i32* %si_state, align 8, !tbaa !80
  %cmp = icmp ne i32 %7, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %lor.rhs, %while.cond
  %8 = bitcast %struct.smi_info* %to_clean to i8*
  call void @poll(i8* %8)
  %call20 = call i64 @schedule_timeout_uninterruptible(i64 1)
  br label %while.cond

while.end:                                        ; preds = %lor.rhs
  %call21 = call zeroext i1 @disable_si_irq(%struct.smi_info* %to_clean, i1 zeroext false)
  br label %while.cond22

while.cond22:                                     ; preds = %while.body29, %while.end
  %curr_msg23 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 7
  %9 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg23, align 8, !tbaa !72
  %tobool24 = icmp ne %struct.ipmi_smi_msg* %9, null
  br i1 %tobool24, label %while.body29, label %lor.rhs25

lor.rhs25:                                        ; preds = %while.cond22
  %si_state26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 8
  %10 = load i32, i32* %si_state26, align 8, !tbaa !80
  %cmp27 = icmp ne i32 %10, 0
  br i1 %cmp27, label %while.body29, label %while.end31

while.body29:                                     ; preds = %lor.rhs25, %while.cond22
  %11 = bitcast %struct.smi_info* %to_clean to i8*
  call void @poll(i8* %11)
  %call30 = call i64 @schedule_timeout_uninterruptible(i64 1)
  br label %while.cond22

while.end31:                                      ; preds = %lor.rhs25
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 3
  %12 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %tobool32 = icmp ne %struct.si_sm_handlers* %12, null
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %while.end31
  %handlers34 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 3
  %13 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers34, align 8, !tbaa !45
  %cleanup = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %13, i32 0, i32 6
  %14 = load void (%struct.si_sm_data*)*, void (%struct.si_sm_data*)** %cleanup, align 8, !tbaa !77
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 2
  %15 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  call void %14(%struct.si_sm_data* %15)
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %while.end31
  %si_sm36 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 2
  %16 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm36, align 8, !tbaa !44
  %17 = bitcast %struct.si_sm_data* %16 to i8*
  call void @kfree(i8* %17)
  %addr_source_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 16
  %18 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %addr_source_cleanup, align 8, !tbaa !78
  %tobool37 = icmp ne void (%struct.smi_info*)* %18, null
  br i1 %tobool37, label %if.then38, label %if.end40

if.then38:                                        ; preds = %if.end35
  %addr_source_cleanup39 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 16
  %19 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %addr_source_cleanup39, align 8, !tbaa !78
  call void %19(%struct.smi_info* %to_clean)
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %if.end35
  %io_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 11
  %20 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %io_cleanup, align 8, !tbaa !37
  %tobool41 = icmp ne void (%struct.smi_info*)* %20, null
  br i1 %tobool41, label %if.then42, label %if.end44

if.then42:                                        ; preds = %if.end40
  %io_cleanup43 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 11
  %21 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %io_cleanup43, align 8, !tbaa !37
  call void %21(%struct.smi_info* %to_clean)
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %if.end40
  %dev_registered = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 38
  %22 = load i8, i8* %dev_registered, align 8, !tbaa !76, !range !79
  %tobool45 = trunc i8 %22 to i1
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.end44
  %pdev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 37
  %23 = load %struct.platform_device*, %struct.platform_device** %pdev, align 8, !tbaa !47
  call void @platform_device_unregister(%struct.platform_device* %23)
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %if.end44
  %24 = bitcast %struct.smi_info* %to_clean to i8*
  call void @kfree(i8* %24)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end47, %entry
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end47 ], [ 1, %entry ]
  ret void
}

declare void @mutex_lock_nested(%struct.mutex*, i32) #1

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

declare i32 @ipmi_unregister_smi(%struct.ipmi_smi*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !81
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del(%struct.list_head* %entry1) #3 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !32
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !82
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @wait_for_timer_and_thread(%struct.smi_info* %smi_info) #3 {
entry:
  %thread = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 41
  %0 = load %struct.task_struct*, %struct.task_struct** %thread, align 8, !tbaa !83
  %cmp = icmp ne %struct.task_struct* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %thread1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 41
  %1 = load %struct.task_struct*, %struct.task_struct** %thread1, align 8, !tbaa !83
  %call = call i32 @kthread_stop(%struct.task_struct* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %timer_running = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 27
  %2 = load i8, i8* %timer_running, align 8, !tbaa !84, !range !79
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %si_timer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 26
  %call3 = call i32 @del_timer_sync(%struct.timer_list* %si_timer)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @poll(i8* %send_info) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %run_to_completion1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 22
  %1 = load i8, i8* %run_to_completion1, align 8, !tbaa !73, !range !79
  %tobool = trunc i8 %1 to i1
  %frombool = zext i1 %tobool to i8
  call void @__const_udelay(i64 42950)
  %tobool2 = trunc i8 %frombool to i1
  br i1 %tobool2, label %if.end, label %do.body3

do.body3:                                         ; preds = %entry
  %2 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #7
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %si_lock)
  %call4 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  br label %if.end

if.end:                                           ; preds = %do.body3, %entry
  %flags.0 = phi i64 [ 0, %entry ], [ %call4, %do.body3 ]
  %call7 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 10)
  %tobool8 = trunc i8 %frombool to i1
  br i1 %tobool8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end
  %si_lock10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock10, i64 %flags.0)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end
  ret void
}

declare i64 @schedule_timeout_uninterruptible(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @disable_si_irq(%struct.smi_info* %smi_info, i1 zeroext %start_timer) #3 {
entry:
  %frombool = zext i1 %start_timer to i8
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 25
  %0 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %entry
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  %1 = load i8, i8* %interrupt_disabled, align 4, !tbaa !74, !range !79
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %return, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %interrupt_disabled2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  store i8 1, i8* %interrupt_disabled2, align 4, !tbaa !74
  %tobool3 = trunc i8 %frombool to i1
  call void @start_check_enables(%struct.smi_info* %smi_info, i1 zeroext %tobool3)
  br label %return

return:                                           ; preds = %if.then, %land.lhs.true, %entry
  %retval.0 = phi i1 [ true, %if.then ], [ false, %land.lhs.true ], [ false, %entry ]
  ret i1 %retval.0
}

declare void @platform_device_unregister(%struct.platform_device*) #1

; Function Attrs: nounwind uwtable
define internal void @start_check_enables(%struct.smi_info* %smi_info, i1 zeroext %start_timer) #0 {
entry:
  %msg = alloca [2 x i8], align 1
  %frombool = zext i1 %start_timer to i8
  %0 = bitcast [2 x i8]* %msg to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %0) #7
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 1
  store i8 47, i8* %arrayidx1, align 1, !tbaa !6
  %tobool = trunc i8 %frombool to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i32 0, i32 0
  call void @start_new_msg(%struct.smi_info* %smi_info, i8* %arraydecay, i32 2)
  br label %if.end

if.else:                                          ; preds = %entry
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %1 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %1, i32 0, i32 2
  %2 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !85
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %3 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %arraydecay2 = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i32 0, i32 0
  %call = call i32 %2(%struct.si_sm_data* %3, i8* %arraydecay2, i32 2)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 5, i32* %si_state, align 8, !tbaa !80
  %4 = bitcast [2 x i8]* %msg to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %4) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @start_new_msg(%struct.smi_info* %smi_info, i8* %msg, i32 %size) #0 {
entry:
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !86
  %add = add i64 %0, 2
  call void @smi_mod_timer(%struct.smi_info* %smi_info, i64 %add)
  %thread = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 41
  %1 = load %struct.task_struct*, %struct.task_struct** %thread, align 8, !tbaa !83
  %tobool = icmp ne %struct.task_struct* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %thread1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 41
  %2 = load %struct.task_struct*, %struct.task_struct** %thread1, align 8, !tbaa !83
  %call = call i32 @wake_up_process(%struct.task_struct* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %3 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %3, i32 0, i32 2
  %4 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !85
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %5 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %call2 = call i32 %4(%struct.si_sm_data* %5, i8* %msg, i32 %size)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @smi_mod_timer(%struct.smi_info* %smi_info, i64 %new_val) #0 {
entry:
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !86
  %last_timeout_jiffies = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 28
  store i64 %0, i64* %last_timeout_jiffies, align 8, !tbaa !87
  %si_timer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 26
  %call = call i32 @mod_timer(%struct.timer_list* %si_timer, i64 %new_val)
  %timer_running = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 27
  store i8 1, i8* %timer_running, align 8, !tbaa !84
  ret void
}

declare i32 @wake_up_process(%struct.task_struct*) #1

declare i32 @mod_timer(%struct.timer_list*, i64) #1

declare void @__const_udelay(i64) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #4 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal i32 @smi_event_handler(%struct.smi_info* %smi_info, i32 %time) #0 {
entry:
  %msg = alloca [2 x i8], align 1
  br label %restart

restart:                                          ; preds = %restart.backedge, %entry
  %time.addr.0 = phi i32 [ %time, %entry ], [ 0, %restart.backedge ]
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %0 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %event = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %0, i32 0, i32 4
  %1 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event, align 8, !tbaa !88
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %2 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %conv = sext i32 %time.addr.0 to i64
  %call = call i32 %1(%struct.si_sm_data* %2, i64 %conv)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %restart
  %si_sm_result.0 = phi i32 [ %call, %restart ], [ %call5, %while.body ]
  switch i32 %si_sm_result.0, label %if.end17 [
    i32 0, label %while.body
    i32 3, label %if.then
    i32 5, label %if.then10
  ]

while.body:                                       ; preds = %while.cond
  %handlers2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %3 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers2, align 8, !tbaa !45
  %event3 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %3, i32 0, i32 4
  %4 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event3, align 8, !tbaa !88
  %si_sm4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %5 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm4, align 8, !tbaa !44
  %call5 = call i32 %4(%struct.si_sm_data* %5, i64 0)
  br label %while.cond

if.then:                                          ; preds = %while.cond
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 40
  %arrayidx = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats, i64 0, i64 7
  call void @atomic_inc(%struct.atomic_t* %arrayidx)
  call void @handle_transaction_done(%struct.smi_info* %smi_info)
  br label %restart.backedge

restart.backedge:                                 ; preds = %if.end69, %if.then62, %if.then42, %cleanup, %if.then15, %if.then10, %if.then
  br label %restart

if.then10:                                        ; preds = %while.cond
  %stats11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 40
  %arrayidx12 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats11, i64 0, i64 6
  call void @atomic_inc(%struct.atomic_t* %arrayidx12)
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state, align 8, !tbaa !80
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %6 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %cmp13 = icmp ne %struct.ipmi_smi_msg* %6, null
  br i1 %cmp13, label %if.then15, label %restart.backedge

if.then15:                                        ; preds = %if.then10
  call void @return_hosed_msg(%struct.smi_info* %smi_info, i32 255)
  br label %restart.backedge

if.end17:                                         ; preds = %while.cond
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 1
  %7 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !43
  %tobool = icmp ne %struct.ipmi_smi* %7, null
  %lnot = xor i1 %tobool, true
  %lnot18 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot18 to i32
  %conv19 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv19, i64 1)
  %tobool20 = icmp ne i64 %expval, 0
  br i1 %tobool20, label %land.lhs.true, label %if.end39

land.lhs.true:                                    ; preds = %if.end17
  %cmp21 = icmp eq i32 %si_sm_result.0, 6
  br i1 %cmp21, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %got_attn = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 34
  %8 = load i8, i8* %got_attn, align 8, !tbaa !89, !range !79
  %tobool23 = trunc i8 %8 to i1
  br i1 %tobool23, label %if.then25, label %if.end39

if.then25:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %9 = bitcast [2 x i8]* %msg to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %9) #7
  %si_state26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %10 = load i32, i32* %si_state26, align 8, !tbaa !80
  %cmp27 = icmp ne i32 %10, 0
  %got_attn30 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 34
  br i1 %cmp27, label %if.then29, label %if.else31

if.then29:                                        ; preds = %if.then25
  store i8 1, i8* %got_attn30, align 8, !tbaa !89
  br label %cleanup

if.else31:                                        ; preds = %if.then25
  store i8 0, i8* %got_attn30, align 8, !tbaa !89
  %stats33 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 40
  %arrayidx34 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats33, i64 0, i64 4
  call void @atomic_inc(%struct.atomic_t* %arrayidx34)
  %arrayidx35 = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx35, align 1, !tbaa !6
  %arrayidx36 = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 1
  store i8 49, i8* %arrayidx36, align 1, !tbaa !6
  %arraydecay = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i32 0, i32 0
  call void @start_new_msg(%struct.smi_info* %smi_info, i8* %arraydecay, i32 2)
  %si_state37 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 1, i32* %si_state37, align 8, !tbaa !80
  br label %cleanup

cleanup:                                          ; preds = %if.else31, %if.then29
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.then29 ], [ 2, %if.else31 ]
  %11 = bitcast [2 x i8]* %msg to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %11) #7
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf, label %restart.backedge, label %if.end39

if.end39:                                         ; preds = %cleanup, %lor.lhs.false, %if.end17
  %cmp40 = icmp eq i32 %si_sm_result.0, 4
  br i1 %cmp40, label %if.then42, label %if.end50

if.then42:                                        ; preds = %if.end39
  %stats43 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 40
  %arrayidx44 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats43, i64 0, i64 2
  call void @atomic_inc(%struct.atomic_t* %arrayidx44)
  %call45 = call i32 @start_next_msg(%struct.smi_info* %smi_info)
  %cmp46 = icmp ne i32 %call45, 4
  br i1 %cmp46, label %restart.backedge, label %if.end50

if.end50:                                         ; preds = %if.then42, %if.end39
  %si_sm_result.1 = phi i32 [ %si_sm_result.0, %if.end39 ], [ %call45, %if.then42 ]
  %cond = icmp eq i32 %si_sm_result.1, 4
  br i1 %cond, label %land.lhs.true53, label %out

land.lhs.true53:                                  ; preds = %if.end50
  %req_events = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 21
  %call54 = call i32 @atomic_read(%struct.atomic_t* %req_events)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.then56, label %if.end71

if.then56:                                        ; preds = %land.lhs.true53
  %req_events57 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 21
  call void @atomic_set(%struct.atomic_t* %req_events57, i32 0)
  %supports_event_msg_buff = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 31
  %12 = load i8, i8* %supports_event_msg_buff, align 1, !tbaa !90, !range !79
  %tobool58 = trunc i8 %12 to i1
  br i1 %tobool58, label %if.then62, label %lor.lhs.false60

lor.lhs.false60:                                  ; preds = %if.then56
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 25
  %13 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool61 = icmp ne i32 %13, 0
  br i1 %tobool61, label %if.then62, label %if.else63

if.then62:                                        ; preds = %lor.lhs.false60, %if.then56
  call void @start_check_enables(%struct.smi_info* %smi_info, i1 zeroext true)
  br label %restart.backedge

if.else63:                                        ; preds = %lor.lhs.false60
  %call64 = call %struct.ipmi_smi_msg* @alloc_msg_handle_irq(%struct.smi_info* %smi_info)
  %curr_msg65 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* %call64, %struct.ipmi_smi_msg** %curr_msg65, align 8, !tbaa !72
  %curr_msg66 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %14 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg66, align 8, !tbaa !72
  %tobool67 = icmp ne %struct.ipmi_smi_msg* %14, null
  br i1 %tobool67, label %if.end69, label %out

if.end69:                                         ; preds = %if.else63
  call void @start_getting_events(%struct.smi_info* %smi_info)
  br label %restart.backedge

if.end71:                                         ; preds = %land.lhs.true53
  %cmp72 = icmp eq i32 %si_sm_result.1, 4
  br i1 %cmp72, label %land.lhs.true74, label %out

land.lhs.true74:                                  ; preds = %if.end71
  %timer_running = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 27
  %15 = load i8, i8* %timer_running, align 8, !tbaa !84, !range !79
  %tobool75 = trunc i8 %15 to i1
  br i1 %tobool75, label %if.then77, label %out

if.then77:                                        ; preds = %land.lhs.true74
  %si_timer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 26
  %call78 = call i32 @del_timer(%struct.timer_list* %si_timer)
  %tobool79 = icmp ne i32 %call78, 0
  br i1 %tobool79, label %if.then80, label %out

if.then80:                                        ; preds = %if.then77
  %timer_running81 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 27
  store i8 0, i8* %timer_running81, align 8, !tbaa !84
  br label %out

out:                                              ; preds = %if.then80, %if.then77, %land.lhs.true74, %if.end71, %if.else63, %if.end50
  ret i32 %si_sm_result.1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #4 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

; Function Attrs: alwaysinline nounwind uwtable
define internal void @atomic_inc(%struct.atomic_t* %v) #4 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !91
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @handle_transaction_done(%struct.smi_info* %smi_info) #0 {
entry:
  %msg6 = alloca [4 x i8], align 1
  %msg24 = alloca [3 x i8], align 1
  %msg91 = alloca [4 x i8], align 1
  %irq_on = alloca i8, align 1
  %msg151 = alloca [4 x i8], align 1
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %0 = load i32, i32* %si_state, align 8, !tbaa !80
  %Pivot12 = icmp slt i32 %0, 3
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %0, 5
  br i1 %Pivot10, label %NodeBlock3, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %0, 6
  br i1 %Pivot8, label %sw.bb90, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %0, 6
  br i1 %SwitchLeaf6, label %sw.bb150, label %sw.epilog

NodeBlock3:                                       ; preds = %NodeBlock9
  %Pivot4 = icmp slt i32 %0, 4
  br i1 %Pivot4, label %sw.bb23, label %sw.bb63

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %0, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %0, 2
  br i1 %Pivot, label %sw.bb5, label %sw.bb39

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %0, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %1 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %tobool = icmp ne %struct.ipmi_smi_msg* %1, null
  br i1 %tobool, label %if.end, label %sw.epilog

if.end:                                           ; preds = %sw.bb
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %2 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %get_result = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %2, i32 0, i32 3
  %3 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result, align 8, !tbaa !92
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %4 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %curr_msg1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %5 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg1, align 8, !tbaa !72
  %rsp = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %5, i32 0, i32 6
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %rsp, i32 0, i32 0
  %call = call i32 %3(%struct.si_sm_data* %4, i8* %arraydecay, i32 272)
  %curr_msg2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %6 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg2, align 8, !tbaa !72
  %rsp_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %6, i32 0, i32 5
  store i32 %call, i32* %rsp_size, align 4, !tbaa !93
  %curr_msg3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %7 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg3, align 8, !tbaa !72
  %curr_msg4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg4, align 8, !tbaa !72
  call void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %7)
  br label %sw.epilog

sw.bb5:                                           ; preds = %NodeBlock
  %8 = bitcast [4 x i8]* %msg6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #7
  %handlers7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %9 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers7, align 8, !tbaa !45
  %get_result8 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %9, i32 0, i32 3
  %10 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result8, align 8, !tbaa !92
  %si_sm9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %11 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm9, align 8, !tbaa !44
  %arraydecay10 = getelementptr inbounds [4 x i8], [4 x i8]* %msg6, i32 0, i32 0
  %call11 = call i32 %10(%struct.si_sm_data* %11, i8* %arraydecay10, i32 4)
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %msg6, i64 0, i64 2
  %12 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv = zext i8 %12 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then13, label %if.else

if.then13:                                        ; preds = %sw.bb5
  %si_state14 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state14, align 8, !tbaa !80
  br label %if.end22

if.else:                                          ; preds = %sw.bb5
  %cmp15 = icmp ult i32 %call11, 4
  br i1 %cmp15, label %if.then17, label %if.else19

if.then17:                                        ; preds = %if.else
  %si_state18 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state18, align 8, !tbaa !80
  br label %if.end22

if.else19:                                        ; preds = %if.else
  %arrayidx20 = getelementptr inbounds [4 x i8], [4 x i8]* %msg6, i64 0, i64 3
  %13 = load i8, i8* %arrayidx20, align 1, !tbaa !6
  %msg_flags = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  store i8 %13, i8* %msg_flags, align 8, !tbaa !95
  call void @handle_flags(%struct.smi_info* %smi_info)
  br label %if.end22

if.end22:                                         ; preds = %if.else19, %if.then17, %if.then13
  %14 = bitcast [4 x i8]* %msg6 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #7
  br label %sw.epilog

sw.bb23:                                          ; preds = %NodeBlock3
  %15 = bitcast [3 x i8]* %msg24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 3, i8* %15) #7
  %handlers25 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %16 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers25, align 8, !tbaa !45
  %get_result26 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %16, i32 0, i32 3
  %17 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result26, align 8, !tbaa !92
  %si_sm27 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %18 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm27, align 8, !tbaa !44
  %arraydecay28 = getelementptr inbounds [3 x i8], [3 x i8]* %msg24, i32 0, i32 0
  %call29 = call i32 %17(%struct.si_sm_data* %18, i8* %arraydecay28, i32 3)
  %arrayidx30 = getelementptr inbounds [3 x i8], [3 x i8]* %msg24, i64 0, i64 2
  %19 = load i8, i8* %arrayidx30, align 1, !tbaa !6
  %conv31 = zext i8 %19 to i32
  %cmp32 = icmp ne i32 %conv31, 0
  br i1 %cmp32, label %if.then34, label %if.end37

if.then34:                                        ; preds = %sw.bb23
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %20 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  %arrayidx35 = getelementptr inbounds [3 x i8], [3 x i8]* %msg24, i64 0, i64 2
  %21 = load i8, i8* %arrayidx35, align 1, !tbaa !6
  %conv36 = zext i8 %21 to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %20, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.26, i32 0, i32 0), i32 %conv36)
  br label %if.end37

if.end37:                                         ; preds = %if.then34, %sw.bb23
  %si_state38 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state38, align 8, !tbaa !80
  %22 = bitcast [3 x i8]* %msg24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 3, i8* %22) #7
  br label %sw.epilog

sw.bb39:                                          ; preds = %NodeBlock
  %handlers40 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %23 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers40, align 8, !tbaa !45
  %get_result41 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %23, i32 0, i32 3
  %24 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result41, align 8, !tbaa !92
  %si_sm42 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %25 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm42, align 8, !tbaa !44
  %curr_msg43 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %26 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg43, align 8, !tbaa !72
  %rsp44 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %26, i32 0, i32 6
  %arraydecay45 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp44, i32 0, i32 0
  %call46 = call i32 %24(%struct.si_sm_data* %25, i8* %arraydecay45, i32 272)
  %curr_msg47 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %27 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg47, align 8, !tbaa !72
  %rsp_size48 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %27, i32 0, i32 5
  store i32 %call46, i32* %rsp_size48, align 4, !tbaa !93
  %curr_msg49 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %28 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg49, align 8, !tbaa !72
  %curr_msg50 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg50, align 8, !tbaa !72
  %rsp51 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %28, i32 0, i32 6
  %arrayidx52 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp51, i64 0, i64 2
  %29 = load i8, i8* %arrayidx52, align 2, !tbaa !6
  %conv53 = zext i8 %29 to i32
  %cmp54 = icmp ne i32 %conv53, 0
  br i1 %cmp54, label %if.then56, label %if.else60

if.then56:                                        ; preds = %sw.bb39
  %done = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %28, i32 0, i32 7
  %30 = load void (%struct.ipmi_smi_msg*)*, void (%struct.ipmi_smi_msg*)** %done, align 8, !tbaa !96
  call void %30(%struct.ipmi_smi_msg* %28)
  %msg_flags57 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  %31 = load i8, i8* %msg_flags57, align 8, !tbaa !95
  %conv58 = zext i8 %31 to i32
  %and = and i32 %conv58, -3
  %conv59 = trunc i32 %and to i8
  store i8 %conv59, i8* %msg_flags57, align 8, !tbaa !95
  call void @handle_flags(%struct.smi_info* %smi_info)
  br label %sw.epilog

if.else60:                                        ; preds = %sw.bb39
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 40
  %arrayidx61 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats, i64 0, i64 8
  call void @atomic_inc(%struct.atomic_t* %arrayidx61)
  call void @handle_flags(%struct.smi_info* %smi_info)
  call void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %28)
  br label %sw.epilog

sw.bb63:                                          ; preds = %NodeBlock3
  %handlers64 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %32 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers64, align 8, !tbaa !45
  %get_result65 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %32, i32 0, i32 3
  %33 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result65, align 8, !tbaa !92
  %si_sm66 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %34 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm66, align 8, !tbaa !44
  %curr_msg67 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %35 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg67, align 8, !tbaa !72
  %rsp68 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %35, i32 0, i32 6
  %arraydecay69 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp68, i32 0, i32 0
  %call70 = call i32 %33(%struct.si_sm_data* %34, i8* %arraydecay69, i32 272)
  %curr_msg71 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %36 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg71, align 8, !tbaa !72
  %rsp_size72 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %36, i32 0, i32 5
  store i32 %call70, i32* %rsp_size72, align 4, !tbaa !93
  %curr_msg73 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %37 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg73, align 8, !tbaa !72
  %curr_msg74 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg74, align 8, !tbaa !72
  %rsp75 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %37, i32 0, i32 6
  %arrayidx76 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp75, i64 0, i64 2
  %38 = load i8, i8* %arrayidx76, align 2, !tbaa !6
  %conv77 = zext i8 %38 to i32
  %cmp78 = icmp ne i32 %conv77, 0
  br i1 %cmp78, label %if.then80, label %if.else86

if.then80:                                        ; preds = %sw.bb63
  %done81 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %37, i32 0, i32 7
  %39 = load void (%struct.ipmi_smi_msg*)*, void (%struct.ipmi_smi_msg*)** %done81, align 8, !tbaa !96
  call void %39(%struct.ipmi_smi_msg* %37)
  %msg_flags82 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  %40 = load i8, i8* %msg_flags82, align 8, !tbaa !95
  %conv83 = zext i8 %40 to i32
  %and84 = and i32 %conv83, -2
  %conv85 = trunc i32 %and84 to i8
  store i8 %conv85, i8* %msg_flags82, align 8, !tbaa !95
  call void @handle_flags(%struct.smi_info* %smi_info)
  br label %sw.epilog

if.else86:                                        ; preds = %sw.bb63
  %stats87 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 40
  %arrayidx88 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats87, i64 0, i64 10
  call void @atomic_inc(%struct.atomic_t* %arrayidx88)
  call void @handle_flags(%struct.smi_info* %smi_info)
  call void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %37)
  br label %sw.epilog

sw.bb90:                                          ; preds = %NodeBlock7
  %41 = bitcast [4 x i8]* %msg91 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %41) #7
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %irq_on) #7
  %handlers92 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %42 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers92, align 8, !tbaa !45
  %get_result93 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %42, i32 0, i32 3
  %43 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result93, align 8, !tbaa !92
  %si_sm94 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %44 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm94, align 8, !tbaa !44
  %arraydecay95 = getelementptr inbounds [4 x i8], [4 x i8]* %msg91, i32 0, i32 0
  %call96 = call i32 %43(%struct.si_sm_data* %44, i8* %arraydecay95, i32 4)
  %arrayidx97 = getelementptr inbounds [4 x i8], [4 x i8]* %msg91, i64 0, i64 2
  %45 = load i8, i8* %arrayidx97, align 1, !tbaa !6
  %conv98 = zext i8 %45 to i32
  %cmp99 = icmp ne i32 %conv98, 0
  br i1 %cmp99, label %if.then101, label %if.end107

if.then101:                                       ; preds = %sw.bb90
  %dev102 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %46 = load %struct.device*, %struct.device** %dev102, align 8, !tbaa !38
  %arrayidx103 = getelementptr inbounds [4 x i8], [4 x i8]* %msg91, i64 0, i64 2
  %47 = load i8, i8* %arrayidx103, align 1, !tbaa !6
  %conv104 = zext i8 %47 to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %46, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.27, i32 0, i32 0), i32 %conv104)
  %dev105 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %48 = load %struct.device*, %struct.device** %dev105, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %48, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.28, i32 0, i32 0))
  %si_state106 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state106, align 8, !tbaa !80
  br label %cleanup

if.end107:                                        ; preds = %sw.bb90
  %call108 = call zeroext i8 @current_global_enables(%struct.smi_info* %smi_info, i8* %irq_on)
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 4
  %49 = load i32, i32* %si_type, align 8, !tbaa !21
  %cmp109 = icmp eq i32 %49, 2
  br i1 %cmp109, label %if.then111, label %if.end113

if.then111:                                       ; preds = %if.end107
  %50 = load i8, i8* %irq_on, align 1, !tbaa !97, !range !79
  %tobool112 = trunc i8 %50 to i1
  call void @check_bt_irq(%struct.smi_info* %smi_info, i1 zeroext %tobool112)
  br label %if.end113

if.end113:                                        ; preds = %if.then111, %if.end107
  %conv114 = zext i8 %call108 to i32
  %arrayidx115 = getelementptr inbounds [4 x i8], [4 x i8]* %msg91, i64 0, i64 3
  %51 = load i8, i8* %arrayidx115, align 1, !tbaa !6
  %conv116 = zext i8 %51 to i32
  %and117 = and i32 %conv116, 7
  %cmp118 = icmp ne i32 %conv114, %and117
  br i1 %cmp118, label %if.then120, label %if.else134

if.then120:                                       ; preds = %if.end113
  %arrayidx121 = getelementptr inbounds [4 x i8], [4 x i8]* %msg91, i64 0, i64 0
  store i8 24, i8* %arrayidx121, align 1, !tbaa !6
  %arrayidx122 = getelementptr inbounds [4 x i8], [4 x i8]* %msg91, i64 0, i64 1
  store i8 46, i8* %arrayidx122, align 1, !tbaa !6
  %conv123 = zext i8 %call108 to i32
  %arrayidx124 = getelementptr inbounds [4 x i8], [4 x i8]* %msg91, i64 0, i64 3
  %52 = load i8, i8* %arrayidx124, align 1, !tbaa !6
  %conv125 = zext i8 %52 to i32
  %and126 = and i32 %conv125, -8
  %or = or i32 %conv123, %and126
  %conv127 = trunc i32 %or to i8
  %arrayidx128 = getelementptr inbounds [4 x i8], [4 x i8]* %msg91, i64 0, i64 2
  store i8 %conv127, i8* %arrayidx128, align 1, !tbaa !6
  %handlers129 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %53 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers129, align 8, !tbaa !45
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %53, i32 0, i32 2
  %54 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !85
  %si_sm130 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %55 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm130, align 8, !tbaa !44
  %arraydecay131 = getelementptr inbounds [4 x i8], [4 x i8]* %msg91, i32 0, i32 0
  %call132 = call i32 %54(%struct.si_sm_data* %55, i8* %arraydecay131, i32 3)
  %si_state133 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 6, i32* %si_state133, align 8, !tbaa !80
  br label %cleanup

if.else134:                                       ; preds = %if.end113
  %supports_event_msg_buff = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 31
  %56 = load i8, i8* %supports_event_msg_buff, align 1, !tbaa !90, !range !79
  %tobool135 = trunc i8 %56 to i1
  br i1 %tobool135, label %if.then136, label %if.else144

if.then136:                                       ; preds = %if.else134
  %call137 = call %struct.ipmi_smi_msg* @ipmi_alloc_smi_msg()
  %curr_msg138 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* %call137, %struct.ipmi_smi_msg** %curr_msg138, align 8, !tbaa !72
  %curr_msg139 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %57 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg139, align 8, !tbaa !72
  %tobool140 = icmp ne %struct.ipmi_smi_msg* %57, null
  br i1 %tobool140, label %if.end143, label %if.then141

if.then141:                                       ; preds = %if.then136
  %si_state142 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state142, align 8, !tbaa !80
  br label %cleanup

if.end143:                                        ; preds = %if.then136
  call void @start_getting_events(%struct.smi_info* %smi_info)
  br label %cleanup

if.else144:                                       ; preds = %if.else134
  %si_state145 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state145, align 8, !tbaa !80
  br label %cleanup

cleanup:                                          ; preds = %if.else144, %if.end143, %if.then141, %if.then120, %if.then101
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %irq_on) #7
  %58 = bitcast [4 x i8]* %msg91 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %58) #7
  br label %sw.epilog

sw.bb150:                                         ; preds = %LeafBlock5
  %59 = bitcast [4 x i8]* %msg151 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %59) #7
  %handlers152 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %60 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers152, align 8, !tbaa !45
  %get_result153 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %60, i32 0, i32 3
  %61 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result153, align 8, !tbaa !92
  %si_sm154 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %62 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm154, align 8, !tbaa !44
  %arraydecay155 = getelementptr inbounds [4 x i8], [4 x i8]* %msg151, i32 0, i32 0
  %call156 = call i32 %61(%struct.si_sm_data* %62, i8* %arraydecay155, i32 4)
  %arrayidx157 = getelementptr inbounds [4 x i8], [4 x i8]* %msg151, i64 0, i64 2
  %63 = load i8, i8* %arrayidx157, align 1, !tbaa !6
  %conv158 = zext i8 %63 to i32
  %cmp159 = icmp ne i32 %conv158, 0
  br i1 %cmp159, label %if.then161, label %if.end165

if.then161:                                       ; preds = %sw.bb150
  %dev162 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %64 = load %struct.device*, %struct.device** %dev162, align 8, !tbaa !38
  %arrayidx163 = getelementptr inbounds [4 x i8], [4 x i8]* %msg151, i64 0, i64 2
  %65 = load i8, i8* %arrayidx163, align 1, !tbaa !6
  %conv164 = zext i8 %65 to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %64, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.29, i32 0, i32 0), i32 %conv164)
  br label %if.end165

if.end165:                                        ; preds = %if.then161, %sw.bb150
  %supports_event_msg_buff166 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 31
  %66 = load i8, i8* %supports_event_msg_buff166, align 1, !tbaa !90, !range !79
  %tobool167 = trunc i8 %66 to i1
  br i1 %tobool167, label %if.then168, label %if.else176

if.then168:                                       ; preds = %if.end165
  %call169 = call %struct.ipmi_smi_msg* @ipmi_alloc_smi_msg()
  %curr_msg170 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* %call169, %struct.ipmi_smi_msg** %curr_msg170, align 8, !tbaa !72
  %curr_msg171 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %67 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg171, align 8, !tbaa !72
  %tobool172 = icmp ne %struct.ipmi_smi_msg* %67, null
  br i1 %tobool172, label %if.end175, label %if.then173

if.then173:                                       ; preds = %if.then168
  %si_state174 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state174, align 8, !tbaa !80
  br label %cleanup179

if.end175:                                        ; preds = %if.then168
  call void @start_getting_events(%struct.smi_info* %smi_info)
  br label %cleanup179

if.else176:                                       ; preds = %if.end165
  %si_state177 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state177, align 8, !tbaa !80
  br label %cleanup179

cleanup179:                                       ; preds = %if.else176, %if.end175, %if.then173
  %68 = bitcast [4 x i8]* %msg151 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %68) #7
  br label %sw.epilog

sw.epilog:                                        ; preds = %cleanup179, %cleanup, %if.else86, %if.then80, %if.else60, %if.then56, %if.end37, %if.end22, %if.end, %sw.bb, %LeafBlock, %LeafBlock5
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @return_hosed_msg(%struct.smi_info* %smi_info, i32 %cCode) #0 {
entry:
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %0 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %cmp = icmp slt i32 %cCode, 0
  %cmp1 = icmp sgt i32 %cCode, 255
  %or.cond = or i1 %cmp, %cmp1
  %cCode.addr.0 = select i1 %or.cond, i32 255, i32 %cCode
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 4
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %data, i64 0, i64 0
  %1 = load i8, i8* %arrayidx, align 4, !tbaa !6
  %conv = zext i8 %1 to i32
  %or = or i32 %conv, 4
  %conv2 = trunc i32 %or to i8
  %rsp = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx3 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp, i64 0, i64 0
  store i8 %conv2, i8* %arrayidx3, align 8, !tbaa !6
  %data4 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 4
  %arrayidx5 = getelementptr inbounds [272 x i8], [272 x i8]* %data4, i64 0, i64 1
  %2 = load i8, i8* %arrayidx5, align 1, !tbaa !6
  %rsp6 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx7 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp6, i64 0, i64 1
  store i8 %2, i8* %arrayidx7, align 1, !tbaa !6
  %conv8 = trunc i32 %cCode.addr.0 to i8
  %rsp9 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx10 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp9, i64 0, i64 2
  store i8 %conv8, i8* %arrayidx10, align 2, !tbaa !6
  %rsp_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 5
  store i32 3, i32* %rsp_size, align 4, !tbaa !93
  %curr_msg11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg11, align 8, !tbaa !72
  call void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %0)
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

; Function Attrs: nounwind uwtable
define internal i32 @start_next_msg(%struct.smi_info* %smi_info) #0 {
entry:
  %waiting_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 6
  %0 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %waiting_msg, align 8, !tbaa !71
  %tobool = icmp ne %struct.ipmi_smi_msg* %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  br label %UnifiedReturnBlock

if.else:                                          ; preds = %entry
  %waiting_msg1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 6
  %1 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %waiting_msg1, align 8, !tbaa !71
  %curr_msg2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* %1, %struct.ipmi_smi_msg** %curr_msg2, align 8, !tbaa !72
  %waiting_msg3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 6
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %waiting_msg3, align 8, !tbaa !71
  %2 = bitcast %struct.smi_info* %smi_info to i8*
  %call = call i32 @atomic_notifier_call_chain(%struct.atomic_notifier_head* @xaction_notifier_list, i64 0, i8* %2)
  %and = and i32 %call, 32768
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %NodeBlock, label %if.end

if.end:                                           ; preds = %if.else
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %3 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %3, i32 0, i32 2
  %4 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !85
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %5 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %curr_msg6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %6 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg6, align 8, !tbaa !72
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %6, i32 0, i32 4
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %data, i32 0, i32 0
  %curr_msg7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %7 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg7, align 8, !tbaa !72
  %data_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %7, i32 0, i32 3
  %8 = load i32, i32* %data_size, align 8, !tbaa !98
  %call8 = call i32 %4(%struct.si_sm_data* %5, i8* %arraydecay, i32 %8)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %NodeBlock

if.then10:                                        ; preds = %if.end
  call void @return_hosed_msg(%struct.smi_info* %smi_info, i32 %call8)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.then10, %if.end, %if.else
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %NodeBlock, %if.then
  %UnifiedRetVal = phi i32 [ 4, %if.then ], [ 0, %NodeBlock ]
  ret i32 %UnifiedRetVal
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @atomic_read(%struct.atomic_t* %v) #4 {
entry:
  %__u = alloca %struct.atomic_t, align 4
  %0 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %1 = bitcast i32* %counter to i8*
  %__c = bitcast %struct.atomic_t* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 4)
  %__val = bitcast %struct.atomic_t* %__u to i32*
  %2 = load i32, i32* %__val, align 4, !tbaa !6
  %3 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #7
  ret i32 %2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @atomic_set(%struct.atomic_t* %v, i32 %i) #4 {
entry:
  %__u = alloca %struct.atomic_t, align 4
  %0 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %__val = bitcast %struct.atomic_t* %__u to i32*
  store i32 %i, i32* %__val, align 4, !tbaa !6
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %1 = bitcast i32* %counter to i8*
  %__c = bitcast %struct.atomic_t* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 4)
  %__val1 = bitcast %struct.atomic_t* %__u to i32*
  %2 = load i32, i32* %__val1, align 4, !tbaa !6
  %3 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.ipmi_smi_msg* @alloc_msg_handle_irq(%struct.smi_info* %smi_info) #0 {
entry:
  %call = call %struct.ipmi_smi_msg* @ipmi_alloc_smi_msg()
  %tobool = icmp ne %struct.ipmi_smi_msg* %call, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call zeroext i1 @disable_si_irq(%struct.smi_info* %smi_info, i1 zeroext true)
  br i1 %call1, label %if.end6, label %if.then2

if.then2:                                         ; preds = %if.then
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state, align 8, !tbaa !80
  br label %if.end6

if.else:                                          ; preds = %entry
  %call3 = call zeroext i1 @enable_si_irq(%struct.smi_info* %smi_info)
  br i1 %call3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.else
  call void @ipmi_free_smi_msg(%struct.ipmi_smi_msg* %call)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.else, %if.then2, %if.then
  %msg.1 = phi %struct.ipmi_smi_msg* [ %call, %if.then2 ], [ %call, %if.then ], [ null, %if.then4 ], [ %call, %if.else ]
  ret %struct.ipmi_smi_msg* %msg.1
}

; Function Attrs: nounwind uwtable
define internal void @start_getting_events(%struct.smi_info* %smi_info) #0 {
entry:
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %0 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 4
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %data, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 4, !tbaa !6
  %curr_msg1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %1 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg1, align 8, !tbaa !72
  %data2 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %1, i32 0, i32 4
  %arrayidx3 = getelementptr inbounds [272 x i8], [272 x i8]* %data2, i64 0, i64 1
  store i8 53, i8* %arrayidx3, align 1, !tbaa !6
  %curr_msg4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %2 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg4, align 8, !tbaa !72
  %data_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %2, i32 0, i32 3
  store i32 2, i32* %data_size, align 8, !tbaa !98
  %curr_msg5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %3 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg5, align 8, !tbaa !72
  %data6 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %3, i32 0, i32 4
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %data6, i32 0, i32 0
  %curr_msg7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %4 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg7, align 8, !tbaa !72
  %data_size8 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %4, i32 0, i32 3
  %5 = load i32, i32* %data_size8, align 8, !tbaa !98
  call void @start_new_msg(%struct.smi_info* %smi_info, i8* %arraydecay, i32 %5)
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 2, i32* %si_state, align 8, !tbaa !80
  ret void
}

declare i32 @del_timer(%struct.timer_list*) #1

declare %struct.ipmi_smi_msg* @ipmi_alloc_smi_msg() #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @enable_si_irq(%struct.smi_info* %smi_info) #3 {
entry:
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 25
  %0 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %entry
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  %1 = load i8, i8* %interrupt_disabled, align 4, !tbaa !74, !range !79
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %if.then, label %return

if.then:                                          ; preds = %land.lhs.true
  %interrupt_disabled2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  store i8 0, i8* %interrupt_disabled2, align 4, !tbaa !74
  call void @start_check_enables(%struct.smi_info* %smi_info, i1 zeroext true)
  br label %return

return:                                           ; preds = %if.then, %land.lhs.true, %entry
  %retval.0 = phi i1 [ true, %if.then ], [ false, %land.lhs.true ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @ipmi_free_smi_msg(%struct.ipmi_smi_msg* %msg) #3 {
entry:
  %done = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %msg, i32 0, i32 7
  %0 = load void (%struct.ipmi_smi_msg*)*, void (%struct.ipmi_smi_msg*)** %done, align 8, !tbaa !96
  call void %0(%struct.ipmi_smi_msg* %msg)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size(i8* %p, i8* %res, i32 %size) #4 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !6
  store volatile i8 %0, i8* %p, align 1, !tbaa !6
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !99
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !99
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !2
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !2
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !101
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !101
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !102
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !103
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__read_once_size(i8* %p, i8* %res, i32 %size) #4 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load volatile i8, i8* %p, align 1, !tbaa !6
  store i8 %0, i8* %res, align 1, !tbaa !6
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %p to i16*
  %2 = load volatile i16, i16* %1, align 2, !tbaa !99
  %3 = bitcast i8* %res to i16*
  store i16 %2, i16* %3, align 2, !tbaa !99
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %p to i32*
  %5 = load volatile i32, i32* %4, align 4, !tbaa !2
  %6 = bitcast i8* %res to i32*
  store i32 %5, i32* %6, align 4, !tbaa !2
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %p to i64*
  %8 = load volatile i64, i64* %7, align 8, !tbaa !101
  %9 = bitcast i8* %res to i64*
  store i64 %8, i64* %9, align 8, !tbaa !101
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !104
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %res, i8* %p, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !105
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

declare i32 @atomic_notifier_call_chain(%struct.atomic_notifier_head*, i64, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %msg) #0 {
entry:
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 1
  %0 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !43
  %tobool = icmp ne %struct.ipmi_smi* %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %intf1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 1
  %1 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf1, align 8, !tbaa !43
  call void @ipmi_smi_msg_received(%struct.ipmi_smi* %1, %struct.ipmi_smi_msg* %msg)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @ipmi_free_smi_msg(%struct.ipmi_smi_msg* %msg)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare void @ipmi_smi_msg_received(%struct.ipmi_smi*, %struct.ipmi_smi_msg*) #1

; Function Attrs: nounwind uwtable
define internal void @handle_flags(%struct.smi_info* %smi_info) #0 {
entry:
  br label %retry

retry:                                            ; preds = %if.then39, %entry
  %msg_flags = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  %0 = load i8, i8* %msg_flags, align 8, !tbaa !95
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %retry
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 40
  %arrayidx = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats, i64 0, i64 9
  call void @atomic_inc(%struct.atomic_t* %arrayidx)
  call void @start_clear_flags(%struct.smi_info* %smi_info, i1 zeroext true)
  %msg_flags1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  %1 = load i8, i8* %msg_flags1, align 8, !tbaa !95
  %conv2 = zext i8 %1 to i32
  %and3 = and i32 %conv2, -9
  %conv4 = trunc i32 %and3 to i8
  store i8 %conv4, i8* %msg_flags1, align 8, !tbaa !95
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 1
  %2 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !43
  %tobool5 = icmp ne %struct.ipmi_smi* %2, null
  br i1 %tobool5, label %if.then6, label %if.end45

if.then6:                                         ; preds = %if.then
  %intf7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 1
  %3 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf7, align 8, !tbaa !43
  call void @ipmi_smi_watchdog_pretimeout(%struct.ipmi_smi* %3)
  br label %if.end45

if.else:                                          ; preds = %retry
  %msg_flags8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  %4 = load i8, i8* %msg_flags8, align 8, !tbaa !95
  %conv9 = zext i8 %4 to i32
  %and10 = and i32 %conv9, 1
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else17

if.then12:                                        ; preds = %if.else
  %call = call %struct.ipmi_smi_msg* @alloc_msg_handle_irq(%struct.smi_info* %smi_info)
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* %call, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %curr_msg13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %5 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg13, align 8, !tbaa !72
  %tobool14 = icmp ne %struct.ipmi_smi_msg* %5, null
  br i1 %tobool14, label %if.end16, label %if.end45

if.end16:                                         ; preds = %if.then12
  call void @start_getting_msg_queue(%struct.smi_info* %smi_info)
  br label %if.end45

if.else17:                                        ; preds = %if.else
  %msg_flags18 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  %6 = load i8, i8* %msg_flags18, align 8, !tbaa !95
  %conv19 = zext i8 %6 to i32
  %and20 = and i32 %conv19, 2
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.then22, label %if.else29

if.then22:                                        ; preds = %if.else17
  %call23 = call %struct.ipmi_smi_msg* @alloc_msg_handle_irq(%struct.smi_info* %smi_info)
  %curr_msg24 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* %call23, %struct.ipmi_smi_msg** %curr_msg24, align 8, !tbaa !72
  %curr_msg25 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %7 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg25, align 8, !tbaa !72
  %tobool26 = icmp ne %struct.ipmi_smi_msg* %7, null
  br i1 %tobool26, label %if.end28, label %if.end45

if.end28:                                         ; preds = %if.then22
  call void @start_getting_events(%struct.smi_info* %smi_info)
  br label %if.end45

if.else29:                                        ; preds = %if.else17
  %msg_flags30 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  %8 = load i8, i8* %msg_flags30, align 8, !tbaa !95
  %conv31 = zext i8 %8 to i32
  %and32 = and i32 %conv31, 224
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %land.lhs.true, label %if.else41

land.lhs.true:                                    ; preds = %if.else29
  %oem_data_avail_handler = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 18
  %9 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %oem_data_avail_handler, align 8, !tbaa !106
  %tobool34 = icmp ne i32 (%struct.smi_info*)* %9, null
  br i1 %tobool34, label %if.then35, label %if.else41

if.then35:                                        ; preds = %land.lhs.true
  %oem_data_avail_handler36 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 18
  %10 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %oem_data_avail_handler36, align 8, !tbaa !106
  %call37 = call i32 %10(%struct.smi_info* %smi_info)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then39, label %if.end45

if.then39:                                        ; preds = %if.then35
  br label %retry

if.else41:                                        ; preds = %land.lhs.true, %if.else29
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 0, i32* %si_state, align 8, !tbaa !80
  br label %if.end45

if.end45:                                         ; preds = %if.else41, %if.then35, %if.end28, %if.then22, %if.end16, %if.then12, %if.then6, %if.then
  ret void
}

declare void @dev_warn(%struct.device*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal zeroext i8 @current_global_enables(%struct.smi_info* %smi_info, i8* %irq_on) #0 {
entry:
  %supports_event_msg_buff = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 31
  %0 = load i8, i8* %supports_event_msg_buff, align 1, !tbaa !90, !range !79
  %tobool = trunc i8 %0 to i1
  %conv = zext i8 0 to i32
  %or = or i32 %conv, 4
  %conv1 = trunc i32 %or to i8
  %enables.0 = select i1 %tobool, i8 %conv1, i8 0
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 25
  %1 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool2 = icmp ne i32 %1, 0
  br i1 %tobool2, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  %2 = load i8, i8* %interrupt_disabled, align 4, !tbaa !74, !range !79
  %tobool3 = trunc i8 %2 to i1
  br i1 %tobool3, label %lor.lhs.false, label %land.lhs.true6

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %cannot_disable_irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 32
  %3 = load i8, i8* %cannot_disable_irq, align 2, !tbaa !107, !range !79
  %tobool4 = trunc i8 %3 to i1
  br i1 %tobool4, label %land.lhs.true6, label %if.end12

land.lhs.true6:                                   ; preds = %lor.lhs.false, %land.lhs.true
  %irq_enable_broken = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 33
  %4 = load i8, i8* %irq_enable_broken, align 1, !tbaa !108, !range !79
  %tobool7 = trunc i8 %4 to i1
  br i1 %tobool7, label %if.end12, label %if.then8

if.then8:                                         ; preds = %land.lhs.true6
  %conv9 = zext i8 %enables.0 to i32
  %or10 = or i32 %conv9, 1
  %conv11 = trunc i32 %or10 to i8
  br label %if.end12

if.end12:                                         ; preds = %if.then8, %land.lhs.true6, %lor.lhs.false
  %enables.1 = phi i8 [ %enables.0, %land.lhs.true6 ], [ %conv11, %if.then8 ], [ %enables.0, %lor.lhs.false ]
  %supports_event_msg_buff13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 31
  %5 = load i8, i8* %supports_event_msg_buff13, align 1, !tbaa !90, !range !79
  %tobool14 = trunc i8 %5 to i1
  br i1 %tobool14, label %land.lhs.true16, label %if.end29

land.lhs.true16:                                  ; preds = %if.end12
  %irq17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 25
  %6 = load i32, i32* %irq17, align 4, !tbaa !29
  %tobool18 = icmp ne i32 %6, 0
  br i1 %tobool18, label %land.lhs.true19, label %if.end29

land.lhs.true19:                                  ; preds = %land.lhs.true16
  %interrupt_disabled20 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  %7 = load i8, i8* %interrupt_disabled20, align 4, !tbaa !74, !range !79
  %tobool21 = trunc i8 %7 to i1
  br i1 %tobool21, label %if.end29, label %land.lhs.true22

land.lhs.true22:                                  ; preds = %land.lhs.true19
  %irq_enable_broken23 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 33
  %8 = load i8, i8* %irq_enable_broken23, align 1, !tbaa !108, !range !79
  %tobool24 = trunc i8 %8 to i1
  br i1 %tobool24, label %if.end29, label %if.then25

if.then25:                                        ; preds = %land.lhs.true22
  %conv26 = zext i8 %enables.1 to i32
  %or27 = or i32 %conv26, 2
  %conv28 = trunc i32 %or27 to i8
  br label %if.end29

if.end29:                                         ; preds = %if.then25, %land.lhs.true22, %land.lhs.true19, %land.lhs.true16, %if.end12
  %enables.2 = phi i8 [ %enables.1, %land.lhs.true19 ], [ %enables.1, %land.lhs.true22 ], [ %conv28, %if.then25 ], [ %enables.1, %land.lhs.true16 ], [ %enables.1, %if.end12 ]
  %conv30 = zext i8 %enables.2 to i32
  %and = and i32 %conv30, 3
  %tobool31 = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool31 to i8
  store i8 %frombool, i8* %irq_on, align 1, !tbaa !97
  ret i8 %enables.2
}

; Function Attrs: nounwind uwtable
define internal void @check_bt_irq(%struct.smi_info* %smi_info, i1 zeroext %irq_on) #0 {
entry:
  %frombool = zext i1 %irq_on to i8
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 0
  %0 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !39
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  %call = call zeroext i8 %0(%struct.si_sm_io* %io1, i32 2)
  %conv = zext i8 %call to i32
  %and = and i32 %conv, 1
  %conv2 = trunc i32 %and to i8
  %tobool = icmp ne i8 %conv2, 0
  %conv3 = zext i1 %tobool to i32
  %tobool4 = trunc i8 %frombool to i1
  %conv5 = zext i1 %tobool4 to i32
  %cmp = icmp eq i32 %conv3, %conv5
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %tobool7 = trunc i8 %frombool to i1
  %io9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io9, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !40
  %io10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end
  call void %1(%struct.si_sm_io* %io10, i32 2, i8 zeroext 1)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end
  call void %1(%struct.si_sm_io* %io10, i32 2, i8 zeroext 0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.else, %if.then8, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %entry ], [ 0, %if.else ], [ 0, %if.then8 ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @start_clear_flags(%struct.smi_info* %smi_info, i1 zeroext %start_timer) #0 {
entry:
  %msg = alloca [3 x i8], align 1
  %frombool = zext i1 %start_timer to i8
  %0 = bitcast [3 x i8]* %msg to i8*
  call void @llvm.lifetime.start.p0i8(i64 3, i8* %0) #7
  %arrayidx = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 1
  store i8 48, i8* %arrayidx1, align 1, !tbaa !6
  %arrayidx2 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 2
  store i8 8, i8* %arrayidx2, align 1, !tbaa !6
  %tobool = trunc i8 %frombool to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i32 0, i32 0
  call void @start_new_msg(%struct.smi_info* %smi_info, i8* %arraydecay, i32 3)
  br label %if.end

if.else:                                          ; preds = %entry
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %1 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %1, i32 0, i32 2
  %2 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !85
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %3 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %arraydecay3 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i32 0, i32 0
  %call = call i32 %2(%struct.si_sm_data* %3, i8* %arraydecay3, i32 3)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 3, i32* %si_state, align 8, !tbaa !80
  %4 = bitcast [3 x i8]* %msg to i8*
  call void @llvm.lifetime.end.p0i8(i64 3, i8* %4) #7
  ret void
}

declare void @ipmi_smi_watchdog_pretimeout(%struct.ipmi_smi*) #1

; Function Attrs: nounwind uwtable
define internal void @start_getting_msg_queue(%struct.smi_info* %smi_info) #0 {
entry:
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %0 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 4
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %data, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 4, !tbaa !6
  %curr_msg1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %1 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg1, align 8, !tbaa !72
  %data2 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %1, i32 0, i32 4
  %arrayidx3 = getelementptr inbounds [272 x i8], [272 x i8]* %data2, i64 0, i64 1
  store i8 51, i8* %arrayidx3, align 1, !tbaa !6
  %curr_msg4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %2 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg4, align 8, !tbaa !72
  %data_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %2, i32 0, i32 3
  store i32 2, i32* %data_size, align 8, !tbaa !98
  %curr_msg5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %3 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg5, align 8, !tbaa !72
  %data6 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %3, i32 0, i32 4
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %data6, i32 0, i32 0
  %curr_msg7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %4 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg7, align 8, !tbaa !72
  %data_size8 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %4, i32 0, i32 3
  %5 = load i32, i32* %data_size8, align 8, !tbaa !98
  call void @start_new_msg(%struct.smi_info* %smi_info, i8* %arraydecay, i32 %5)
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store i32 4, i32* %si_state, align 8, !tbaa !80
  ret void
}

declare i32 @kthread_stop(%struct.task_struct*) #1

declare i32 @del_timer_sync(%struct.timer_list*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #3 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !82
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !32
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_del_entry_valid(%struct.list_head*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  %__u = alloca %union.anon.71, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !82
  %0 = bitcast %union.anon.71* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %__val = bitcast %union.anon.71* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !6
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.71* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val3 = bitcast %union.anon.71* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val3, align 8, !tbaa !6
  %3 = bitcast %union.anon.71* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  ret void
}

declare i8* @ipmi_addr_src_to_str(i32) #1

declare noalias i8* @kasprintf(i32, i8*, ...) #1

declare %struct.platform_device* @platform_device_alloc(i8*, i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #4 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare void @dev_err(%struct.device*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @try_get_dev_id(%struct.smi_info* %smi_info) #0 {
entry:
  %msg = alloca [2 x i8], align 1
  %0 = bitcast [2 x i8]* %msg to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %0) #7
  %call = call i8* @kmalloc(i64 272, i32 20971712)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 1
  store i8 1, i8* %arrayidx1, align 1, !tbaa !6
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %1 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %1, i32 0, i32 2
  %2 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !85
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %3 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %arraydecay = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i32 0, i32 0
  %call2 = call i32 %2(%struct.si_sm_data* %3, i8* %arraydecay, i32 2)
  %call3 = call i32 @wait_for_msg_done(%struct.smi_info* %smi_info)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %out, label %if.end6

if.end6:                                          ; preds = %if.end
  %handlers7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %4 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers7, align 8, !tbaa !45
  %get_result = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %4, i32 0, i32 3
  %5 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result, align 8, !tbaa !92
  %si_sm8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %6 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm8, align 8, !tbaa !44
  %call9 = call i32 %5(%struct.si_sm_data* %6, i8* %call, i32 272)
  %conv = sext i32 %call9 to i64
  %conv10 = trunc i64 %conv to i32
  %device_id = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 35
  %call11 = call i32 @ipmi_demangle_device_id(i8* %call, i32 %conv10, %struct.ipmi_device_id* %device_id)
  br label %out

out:                                              ; preds = %if.end6, %if.end
  %rv.0 = phi i32 [ %call11, %if.end6 ], [ %call3, %if.end ]
  call void @kfree(i8* %call)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %rv.0, %out ], [ -12, %entry ]
  %7 = bitcast [2 x i8]* %msg to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %7) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @setup_oem_data_handler(%struct.smi_info* %smi_info) #0 {
entry:
  call void @setup_dell_poweredge_oem_data_handler(%struct.smi_info* %smi_info)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @setup_xaction_handlers(%struct.smi_info* %smi_info) #0 {
entry:
  call void @setup_dell_poweredge_bt_xaction_handler(%struct.smi_info* %smi_info)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @check_for_broken_irqs(%struct.smi_info* %smi_info) #0 {
entry:
  call void @check_clr_rcv_irq(%struct.smi_info* %smi_info)
  call void @check_set_rcv_irq(%struct.smi_info* %smi_info)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @try_enable_event_buffer(%struct.smi_info* %smi_info) #0 {
entry:
  %msg = alloca [3 x i8], align 1
  %0 = bitcast [3 x i8]* %msg to i8*
  call void @llvm.lifetime.start.p0i8(i64 3, i8* %0) #7
  %call = call i8* @kmalloc(i64 272, i32 20971712)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 1
  store i8 47, i8* %arrayidx1, align 1, !tbaa !6
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %1 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %1, i32 0, i32 2
  %2 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !85
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %3 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %arraydecay = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i32 0, i32 0
  %call2 = call i32 %2(%struct.si_sm_data* %3, i8* %arraydecay, i32 2)
  %call3 = call i32 @wait_for_msg_done(%struct.smi_info* %smi_info)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([101 x i8], [101 x i8]* @.str.75, i32 0, i32 0))
  br label %out

if.end7:                                          ; preds = %if.end
  %handlers8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %4 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers8, align 8, !tbaa !45
  %get_result = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %4, i32 0, i32 3
  %5 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result, align 8, !tbaa !92
  %si_sm9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %6 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm9, align 8, !tbaa !44
  %call10 = call i32 %5(%struct.si_sm_data* %6, i8* %call, i32 272)
  %conv = sext i32 %call10 to i64
  %cmp = icmp ult i64 %conv, 4
  br i1 %cmp, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %arrayidx12 = getelementptr inbounds i8, i8* %call, i64 0
  %7 = load i8, i8* %arrayidx12, align 1, !tbaa !6
  %conv13 = zext i8 %7 to i32
  %cmp14 = icmp ne i32 %conv13, 28
  br i1 %cmp14, label %if.then26, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %lor.lhs.false
  %arrayidx17 = getelementptr inbounds i8, i8* %call, i64 1
  %8 = load i8, i8* %arrayidx17, align 1, !tbaa !6
  %conv18 = zext i8 %8 to i32
  %cmp19 = icmp ne i32 %conv18, 47
  br i1 %cmp19, label %if.then26, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %lor.lhs.false16
  %arrayidx22 = getelementptr inbounds i8, i8* %call, i64 2
  %9 = load i8, i8* %arrayidx22, align 1, !tbaa !6
  %conv23 = zext i8 %9 to i32
  %cmp24 = icmp ne i32 %conv23, 0
  br i1 %cmp24, label %if.then26, label %if.end28

if.then26:                                        ; preds = %lor.lhs.false21, %lor.lhs.false16, %lor.lhs.false, %if.end7
  %call27 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([92 x i8], [92 x i8]* @.str.76, i32 0, i32 0))
  br label %out

if.end28:                                         ; preds = %lor.lhs.false21
  %arrayidx29 = getelementptr inbounds i8, i8* %call, i64 3
  %10 = load i8, i8* %arrayidx29, align 1, !tbaa !6
  %conv30 = zext i8 %10 to i32
  %and = and i32 %conv30, 4
  %tobool31 = icmp ne i32 %and, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end28
  %supports_event_msg_buff = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 31
  store i8 1, i8* %supports_event_msg_buff, align 1, !tbaa !90
  br label %out

if.end33:                                         ; preds = %if.end28
  %arrayidx34 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx34, align 1, !tbaa !6
  %arrayidx35 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 1
  store i8 46, i8* %arrayidx35, align 1, !tbaa !6
  %arrayidx36 = getelementptr inbounds i8, i8* %call, i64 3
  %11 = load i8, i8* %arrayidx36, align 1, !tbaa !6
  %conv37 = zext i8 %11 to i32
  %or = or i32 %conv37, 4
  %conv38 = trunc i32 %or to i8
  %arrayidx39 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 2
  store i8 %conv38, i8* %arrayidx39, align 1, !tbaa !6
  %handlers40 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %12 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers40, align 8, !tbaa !45
  %start_transaction41 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %12, i32 0, i32 2
  %13 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction41, align 8, !tbaa !85
  %si_sm42 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %14 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm42, align 8, !tbaa !44
  %arraydecay43 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i32 0, i32 0
  %call44 = call i32 %13(%struct.si_sm_data* %14, i8* %arraydecay43, i32 3)
  %call45 = call i32 @wait_for_msg_done(%struct.smi_info* %smi_info)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.then47, label %if.end49

if.then47:                                        ; preds = %if.end33
  %call48 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([102 x i8], [102 x i8]* @.str.77, i32 0, i32 0))
  br label %out

if.end49:                                         ; preds = %if.end33
  %handlers50 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %15 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers50, align 8, !tbaa !45
  %get_result51 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %15, i32 0, i32 3
  %16 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result51, align 8, !tbaa !92
  %si_sm52 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %17 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm52, align 8, !tbaa !44
  %call53 = call i32 %16(%struct.si_sm_data* %17, i8* %call, i32 272)
  %conv54 = sext i32 %call53 to i64
  %cmp55 = icmp ult i64 %conv54, 3
  br i1 %cmp55, label %if.then67, label %lor.lhs.false57

lor.lhs.false57:                                  ; preds = %if.end49
  %arrayidx58 = getelementptr inbounds i8, i8* %call, i64 0
  %18 = load i8, i8* %arrayidx58, align 1, !tbaa !6
  %conv59 = zext i8 %18 to i32
  %cmp60 = icmp ne i32 %conv59, 28
  br i1 %cmp60, label %if.then67, label %lor.lhs.false62

lor.lhs.false62:                                  ; preds = %lor.lhs.false57
  %arrayidx63 = getelementptr inbounds i8, i8* %call, i64 1
  %19 = load i8, i8* %arrayidx63, align 1, !tbaa !6
  %conv64 = zext i8 %19 to i32
  %cmp65 = icmp ne i32 %conv64, 46
  br i1 %cmp65, label %if.then67, label %if.end69

if.then67:                                        ; preds = %lor.lhs.false62, %lor.lhs.false57, %if.end49
  %call68 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([90 x i8], [90 x i8]* @.str.78, i32 0, i32 0))
  br label %out

if.end69:                                         ; preds = %lor.lhs.false62
  %arrayidx70 = getelementptr inbounds i8, i8* %call, i64 2
  %20 = load i8, i8* %arrayidx70, align 1, !tbaa !6
  %conv71 = zext i8 %20 to i32
  %cmp72 = icmp ne i32 %conv71, 0
  br i1 %cmp72, label %out, label %if.else

if.else:                                          ; preds = %if.end69
  %supports_event_msg_buff75 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 31
  store i8 1, i8* %supports_event_msg_buff75, align 1, !tbaa !90
  br label %out

out:                                              ; preds = %if.else, %if.end69, %if.then67, %if.then47, %if.then32, %if.then26, %if.then5
  %rv.1 = phi i32 [ %call3, %if.then5 ], [ -22, %if.then26 ], [ %call3, %if.then32 ], [ %call45, %if.then47 ], [ -22, %if.then67 ], [ %call45, %if.else ], [ -2, %if.end69 ]
  call void @kfree(i8* %call)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %rv.1, %out ], [ -12, %entry ]
  %21 = bitcast [3 x i8]* %msg to i8*
  call void @llvm.lifetime.end.p0i8(i64 3, i8* %21) #7
  ret i32 %retval.0
}

declare i32 @platform_device_add(%struct.platform_device*) #1

declare i32 @ipmi_register_smi(%struct.ipmi_smi_handlers*, i8*, %struct.ipmi_device_id*, %struct.device*, i8 zeroext) #1

declare i32 @ipmi_smi_add_proc_entry(%struct.ipmi_smi*, i8*, %struct.file_operations*, i8*) #1

declare void @_dev_info(%struct.device*, i8*, ...) #1

declare void @warn_slowpath_null(i8*, i32) #1

declare void @synchronize_sched() #1

declare void @platform_device_put(%struct.platform_device*) #1

declare i64 @seq_lseek(%struct.file*, i64, i32) #1

declare i64 @seq_read(%struct.file*, i8*, i64, i64*) #1

; Function Attrs: nounwind uwtable
define internal i32 @smi_params_proc_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %call1 = call i32 @single_open(%struct.file* %file, i32 (%struct.seq_file*, i8*)* @smi_params_proc_show, i8* %call)
  ret i32 %call1
}

declare i32 @single_release(%struct.inode*, %struct.file*) #1

declare i8* @PDE_DATA(%struct.inode*) #1

; Function Attrs: nounwind uwtable
define internal i32 @smi_params_proc_show(%struct.seq_file* %m, i8* %v) #0 {
entry:
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 12
  %0 = load i8*, i8** %private, align 8, !tbaa !109
  %1 = bitcast i8* %0 to %struct.smi_info*
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 4
  %2 = load i32, i32* %si_type, align 8, !tbaa !21
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @si_to_str, i64 0, i64 %idxprom
  %3 = load i8*, i8** %arrayidx, align 8, !tbaa !7
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 9
  %addr_type = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 6
  %4 = load i32, i32* %addr_type, align 4, !tbaa !23
  %idxprom1 = sext i32 %4 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8*], [2 x i8*]* @addr_space_to_str, i64 0, i64 %idxprom1
  %5 = load i8*, i8** %arrayidx2, align 8, !tbaa !7
  %io3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io3, i32 0, i32 7
  %6 = load i64, i64* %addr_data, align 8, !tbaa !22
  %io4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 9
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io4, i32 0, i32 3
  %7 = load i32, i32* %regspacing, align 8, !tbaa !26
  %io5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 9
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io5, i32 0, i32 4
  %8 = load i32, i32* %regsize, align 4, !tbaa !27
  %io6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 9
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io6, i32 0, i32 5
  %9 = load i32, i32* %regshift, align 8, !tbaa !28
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 25
  %10 = load i32, i32* %irq, align 4, !tbaa !29
  %slave_addr = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 39
  %11 = load i8, i8* %slave_addr, align 1, !tbaa !31
  %conv = zext i8 %11 to i32
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.95, i32 0, i32 0), i8* %3, i8* %5, i64 %6, i32 %7, i32 %8, i32 %9, i32 %10, i32 %conv)
  ret i32 0
}

declare i32 @single_open(%struct.file*, i32 (%struct.seq_file*, i8*)*, i8*) #1

declare void @seq_printf(%struct.seq_file*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @smi_si_stats_proc_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %call1 = call i32 @single_open(%struct.file* %file, i32 (%struct.seq_file*, i8*)* @smi_si_stats_proc_show, i8* %call)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @smi_si_stats_proc_show(%struct.seq_file* %m, i8* %v) #0 {
entry:
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 12
  %0 = load i8*, i8** %private, align 8, !tbaa !109
  %1 = bitcast i8* %0 to %struct.smi_info*
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 25
  %2 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 30
  %3 = load i8, i8* %interrupt_disabled, align 4, !tbaa !74, !range !79
  %tobool1 = trunc i8 %3 to i1
  %lnot = xor i1 %tobool1, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.83, i32 0, i32 0), i32 %land.ext)
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats, i64 0, i64 0
  %call = call i32 @atomic_read(%struct.atomic_t* %arrayidx)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.84, i32 0, i32 0), i32 %call)
  %stats2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx3 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats2, i64 0, i64 1
  %call4 = call i32 @atomic_read(%struct.atomic_t* %arrayidx3)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.85, i32 0, i32 0), i32 %call4)
  %stats5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx6 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats5, i64 0, i64 2
  %call7 = call i32 @atomic_read(%struct.atomic_t* %arrayidx6)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.86, i32 0, i32 0), i32 %call7)
  %stats8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx9 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats8, i64 0, i64 3
  %call10 = call i32 @atomic_read(%struct.atomic_t* %arrayidx9)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.87, i32 0, i32 0), i32 %call10)
  %stats11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx12 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats11, i64 0, i64 4
  %call13 = call i32 @atomic_read(%struct.atomic_t* %arrayidx12)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.88, i32 0, i32 0), i32 %call13)
  %stats14 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx15 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats14, i64 0, i64 5
  %call16 = call i32 @atomic_read(%struct.atomic_t* %arrayidx15)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.89, i32 0, i32 0), i32 %call16)
  %stats17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx18 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats17, i64 0, i64 6
  %call19 = call i32 @atomic_read(%struct.atomic_t* %arrayidx18)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.90, i32 0, i32 0), i32 %call19)
  %stats20 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx21 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats20, i64 0, i64 7
  %call22 = call i32 @atomic_read(%struct.atomic_t* %arrayidx21)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.91, i32 0, i32 0), i32 %call22)
  %stats23 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx24 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats23, i64 0, i64 8
  %call25 = call i32 @atomic_read(%struct.atomic_t* %arrayidx24)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.92, i32 0, i32 0), i32 %call25)
  %stats26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx27 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats26, i64 0, i64 9
  %call28 = call i32 @atomic_read(%struct.atomic_t* %arrayidx27)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.93, i32 0, i32 0), i32 %call28)
  %stats29 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 40
  %arrayidx30 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats29, i64 0, i64 10
  %call31 = call i32 @atomic_read(%struct.atomic_t* %arrayidx30)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.94, i32 0, i32 0), i32 %call31)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @smi_type_proc_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %call1 = call i32 @single_open(%struct.file* %file, i32 (%struct.seq_file*, i8*)* @smi_type_proc_show, i8* %call)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @smi_type_proc_show(%struct.seq_file* %m, i8* %v) #0 {
entry:
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 12
  %0 = load i8*, i8** %private, align 8, !tbaa !109
  %1 = bitcast i8* %0 to %struct.smi_info*
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 4
  %2 = load i32, i32* %si_type, align 8, !tbaa !21
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @si_to_str, i64 0, i64 %idxprom
  %3 = load i8*, i8** %arrayidx, align 8, !tbaa !7
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.82, i32 0, i32 0), i8* %3)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @smi_start_processing(i8* %send_info, %struct.ipmi_smi* %intf) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %intf1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 1
  store %struct.ipmi_smi* %intf, %struct.ipmi_smi** %intf1, align 8, !tbaa !43
  %si_timer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 26
  call void @init_timer_key(%struct.timer_list* %si_timer, i32 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.79, i32 0, i32 0), %struct.lock_class_key* @smi_start_processing.__key)
  %si_timer3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 26
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %si_timer3, i32 0, i32 2
  store void (i64)* @smi_timeout, void (i64)** %function, align 8, !tbaa !111
  %1 = ptrtoint %struct.smi_info* %0 to i64
  %si_timer4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 26
  %data = getelementptr inbounds %struct.timer_list, %struct.timer_list* %si_timer4, i32 0, i32 3
  store i64 %1, i64* %data, align 8, !tbaa !112
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !86
  %add = add i64 %2, 2
  call void @smi_mod_timer(%struct.smi_info* %0, i64 %add)
  %irq_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 12
  %3 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %irq_setup, align 8, !tbaa !30
  %tobool = icmp ne i32 (%struct.smi_info*)* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %irq_setup7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 12
  %4 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %irq_setup7, align 8, !tbaa !30
  %call = call i32 %4(%struct.smi_info* %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %intf_num = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 0
  %5 = load i32, i32* %intf_num, align 8, !tbaa !46
  %6 = load i32, i32* @num_force_kipmid, align 4, !tbaa !2
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end
  %intf_num9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 0
  %7 = load i32, i32* %intf_num9, align 8, !tbaa !46
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @force_kipmid, i64 0, i64 %idxprom
  %8 = load i32, i32* %arrayidx, align 4, !tbaa !2
  br label %if.end14

if.else:                                          ; preds = %if.end
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 4
  %9 = load i32, i32* %si_type, align 8, !tbaa !21
  %cmp10 = icmp ne i32 %9, 2
  br i1 %cmp10, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %if.else
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 25
  %10 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool11 = icmp ne i32 %10, 0
  %. = select i1 %tobool11, i32 0, i32 1
  br label %if.end14

if.end14:                                         ; preds = %land.lhs.true, %if.else, %if.then8
  %enable.1 = phi i32 [ %8, %if.then8 ], [ 0, %if.else ], [ %., %land.lhs.true ]
  %tobool15 = icmp ne i32 %enable.1, 0
  br i1 %tobool15, label %if.then16, label %if.end30

if.then16:                                        ; preds = %if.end14
  %11 = bitcast %struct.smi_info* %0 to i8*
  %intf_num17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 0
  %12 = load i32, i32* %intf_num17, align 8, !tbaa !46
  %call18 = call %struct.task_struct* (i32 (i8*)*, i8*, i32, i8*, ...) @kthread_create_on_node(i32 (i8*)* @ipmi_thread, i8* %11, i32 -1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.80, i32 0, i32 0), i32 %12)
  %13 = bitcast %struct.task_struct* %call18 to i8*
  %call19 = call zeroext i1 @IS_ERR(i8* %13)
  br i1 %call19, label %if.end22, label %if.then20

if.then20:                                        ; preds = %if.then16
  %call21 = call i32 @wake_up_process(%struct.task_struct* %call18)
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.then16
  %thread = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 41
  store %struct.task_struct* %call18, %struct.task_struct** %thread, align 8, !tbaa !83
  %thread23 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 41
  %14 = load %struct.task_struct*, %struct.task_struct** %thread23, align 8, !tbaa !83
  %15 = bitcast %struct.task_struct* %14 to i8*
  %call24 = call zeroext i1 @IS_ERR(i8* %15)
  br i1 %call24, label %if.then25, label %if.end30

if.then25:                                        ; preds = %if.end22
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 36
  %16 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  %thread26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 41
  %17 = load %struct.task_struct*, %struct.task_struct** %thread26, align 8, !tbaa !83
  %18 = bitcast %struct.task_struct* %17 to i8*
  %call27 = call i64 @PTR_ERR(i8* %18)
  call void (%struct.device*, i8*, ...) @dev_notice(%struct.device* %16, i8* getelementptr inbounds ([90 x i8], [90 x i8]* @.str.81, i32 0, i32 0), i64 %call27)
  %thread28 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 41
  store %struct.task_struct* null, %struct.task_struct** %thread28, align 8, !tbaa !83
  br label %if.end30

if.end30:                                         ; preds = %if.then25, %if.end22, %if.end14
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_smi_info(i8* %send_info, %struct.ipmi_smi_info* %data) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 15
  %1 = load i32, i32* %addr_source, align 4, !tbaa !9
  %addr_src = getelementptr inbounds %struct.ipmi_smi_info, %struct.ipmi_smi_info* %data, i32 0, i32 0
  store i32 %1, i32* %addr_src, align 8, !tbaa !113
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 36
  %2 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  %dev1 = getelementptr inbounds %struct.ipmi_smi_info, %struct.ipmi_smi_info* %data, i32 0, i32 1
  store %struct.device* %2, %struct.device** %dev1, align 8, !tbaa !115
  %addr_info = getelementptr inbounds %struct.ipmi_smi_info, %struct.ipmi_smi_info* %data, i32 0, i32 2
  %addr_info2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 43
  %3 = bitcast %union.ipmi_smi_info_union* %addr_info to i8*
  %4 = bitcast %union.ipmi_smi_info_union* %addr_info2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 8, i32 8, i1 false), !tbaa.struct !116
  %dev3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 36
  %5 = load %struct.device*, %struct.device** %dev3, align 8, !tbaa !38
  %call = call %struct.device* @get_device(%struct.device* %5)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @sender(i8* %send_info, %struct.ipmi_smi_msg* %msg) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %run_to_completion = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 22
  %1 = load i8, i8* %run_to_completion, align 8, !tbaa !73, !range !79
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %do.body1

if.then:                                          ; preds = %entry
  %waiting_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 6
  store %struct.ipmi_smi_msg* %msg, %struct.ipmi_smi_msg** %waiting_msg, align 8, !tbaa !71
  br label %cleanup.cont

do.body1:                                         ; preds = %entry
  %2 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #7
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %si_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %waiting_msg6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 6
  %6 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %waiting_msg6, align 8, !tbaa !71
  %tobool7 = icmp ne %struct.ipmi_smi_msg* %6, null
  %lnot = xor i1 %tobool7, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv9 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %do.body12, label %do.end20

do.body12:                                        ; preds = %do.body1
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.47, i32 0, i32 0), i32 1005, i64 12) #7, !srcloc !117
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %do.body12
  br label %do.body13

do.end20:                                         ; preds = %do.body1
  %waiting_msg21 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 6
  store %struct.ipmi_smi_msg* %msg, %struct.ipmi_smi_msg** %waiting_msg21, align 8, !tbaa !71
  call void @check_start_timer_thread(%struct.smi_info* %0)
  %si_lock22 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock22, i64 %call2)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end20, %if.then
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then ], [ 0, %do.end20 ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @request_events(i8* %send_info) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %has_event_buffer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 20
  %1 = load i8, i8* %has_event_buffer, align 1, !tbaa !75, !range !79
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %req_events = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 21
  call void @atomic_set(%struct.atomic_t* %req_events, i32 1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_need_watch(i8* %send_info, i1 zeroext %enable) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %frombool = zext i1 %enable to i8
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %need_watch = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 29
  %tobool = trunc i8 %frombool to i1
  %conv = zext i1 %tobool to i32
  call void @atomic_set(%struct.atomic_t* %need_watch, i32 %conv)
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv2 = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %si_lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  call void @check_start_timer_thread(%struct.smi_info* %0)
  %si_lock6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock6, i64 %call3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @flush_messages(i8* %send_info) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %.sink = phi i32 [ 250, %while.body ], [ 0, %entry ]
  %call1 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 %.sink)
  %cmp = icmp ne i32 %call1, 4
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @__const_udelay(i64 1073750)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_run_to_completion(i8* %send_info, i1 zeroext %i_run_to_completion) #0 {
entry:
  %frombool = zext i1 %i_run_to_completion to i8
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %tobool = trunc i8 %frombool to i1
  %run_to_completion = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 22
  %frombool1 = zext i1 %tobool to i8
  store i8 %frombool1, i8* %run_to_completion, align 8, !tbaa !73
  %tobool2 = trunc i8 %frombool to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = bitcast %struct.smi_info* %0 to i8*
  call void @flush_messages(i8* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_maintenance_mode(i8* %send_info, i1 zeroext %enable) #0 {
entry:
  %frombool = zext i1 %enable to i8
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %tobool = trunc i8 %frombool to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %req_events = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 21
  call void @atomic_set(%struct.atomic_t* %req_events, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @check_start_timer_thread(%struct.smi_info* %smi_info) #0 {
entry:
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %0 = load i32, i32* %si_state, align 8, !tbaa !80
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %entry
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %1 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %cmp1 = icmp eq %struct.ipmi_smi_msg* %1, null
  br i1 %cmp1, label %if.then, label %if.end6

if.then:                                          ; preds = %land.lhs.true
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !86
  %add = add i64 %2, 2
  call void @smi_mod_timer(%struct.smi_info* %smi_info, i64 %add)
  %thread = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 41
  %3 = load %struct.task_struct*, %struct.task_struct** %thread, align 8, !tbaa !83
  %tobool = icmp ne %struct.task_struct* %3, null
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %thread3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 41
  %4 = load %struct.task_struct*, %struct.task_struct** %thread3, align 8, !tbaa !83
  %call = call i32 @wake_up_process(%struct.task_struct* %4)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %call4 = call i32 @start_next_msg(%struct.smi_info* %smi_info)
  %call5 = call i32 @smi_event_handler(%struct.smi_info* %smi_info, i32 0)
  br label %if.end6

if.end6:                                          ; preds = %if.end, %land.lhs.true, %entry
  ret void
}

declare %struct.device* @get_device(%struct.device*) #1

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #1

; Function Attrs: nounwind uwtable
define internal void @smi_timeout(i64 %data) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = inttoptr i64 %data to %struct.smi_info*
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %si_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %5 = load volatile i64, i64* @jiffies, align 8, !tbaa !86
  %last_timeout_jiffies = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 28
  %6 = load i64, i64* %last_timeout_jiffies, align 8, !tbaa !87
  %sub = sub nsw i64 %5, %6
  %mul = mul nsw i64 %sub, 4000
  %conv5 = trunc i64 %mul to i32
  %call6 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 %conv5)
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 25
  %7 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 30
  %8 = load i8, i8* %interrupt_disabled, align 4, !tbaa !74, !range !79
  %tobool7 = trunc i8 %8 to i1
  br i1 %tobool7, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %9 = load volatile i64, i64* @jiffies, align 8, !tbaa !86
  %add = add i64 %9, 2
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 40
  %arrayidx = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats, i64 0, i64 1
  call void @atomic_inc(%struct.atomic_t* %arrayidx)
  br label %do_mod_timer

if.end:                                           ; preds = %land.lhs.true, %entry
  %cmp8 = icmp eq i32 %call6, 1
  %stats11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 40
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end
  %arrayidx12 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats11, i64 0, i64 0
  call void @atomic_inc(%struct.atomic_t* %arrayidx12)
  br label %if.end17

if.else:                                          ; preds = %if.end
  %arrayidx15 = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats11, i64 0, i64 1
  call void @atomic_inc(%struct.atomic_t* %arrayidx15)
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then10
  %.sink1 = phi i64 [ 2, %if.else ], [ 1, %if.then10 ]
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !86
  %add16 = add i64 %10, %.sink1
  br label %do_mod_timer

do_mod_timer:                                     ; preds = %if.end17, %if.then
  %timeout.1 = phi i64 [ %add16, %if.end17 ], [ %add, %if.then ]
  %cmp18 = icmp ne i32 %call6, 4
  br i1 %cmp18, label %if.then20, label %if.else21

if.then20:                                        ; preds = %do_mod_timer
  call void @smi_mod_timer(%struct.smi_info* %0, i64 %timeout.1)
  br label %if.end22

if.else21:                                        ; preds = %do_mod_timer
  %timer_running = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 27
  store i8 0, i8* %timer_running, align 8, !tbaa !84
  br label %if.end22

if.end22:                                         ; preds = %if.else21, %if.then20
  %si_lock23 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock23, i64 %call2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_thread(i8* %data) #0 {
entry:
  %busy_until = alloca %struct.timespec, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i8* %data to %struct.smi_info*
  %1 = bitcast %struct.timespec* %busy_until to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #7
  call void @ipmi_si_set_not_busy(%struct.timespec* %busy_until)
  %call = call %struct.task_struct* @get_current()
  call void @set_user_nice(%struct.task_struct* %call, i64 19)
  br label %while.cond

while.cond:                                       ; preds = %if.end40, %entry
  %call1 = call zeroext i1 @kthread_should_stop()
  %lnot = xor i1 %call1, true
  br i1 %lnot, label %do.body2, label %while.end

do.body2:                                         ; preds = %while.cond
  %2 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #7
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %call3 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %si_lock)
  %call4 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call3)
  %call7 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 0)
  %cmp8 = icmp ne i32 %call7, 4
  br i1 %cmp8, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %do.body2
  %timer_running = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 27
  %6 = load i8, i8* %timer_running, align 8, !tbaa !84, !range !79
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %7 = load volatile i64, i64* @jiffies, align 8, !tbaa !86
  %add = add i64 %7, 2
  call void @smi_mod_timer(%struct.smi_info* %0, i64 %add)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %do.body2
  %si_lock10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock10, i64 %call4)
  %call11 = call i32 @ipmi_thread_busy_wait(i32 %call7, %struct.smi_info* %0, %struct.timespec* %busy_until)
  switch i32 %call7, label %if.else36 [
    i32 0, label %if.end40
    i32 1, label %land.lhs.true17
    i32 4, label %if.then23
  ]

land.lhs.true17:                                  ; preds = %if.end
  %tobool18 = icmp ne i32 %call11, 0
  br i1 %tobool18, label %if.then19, label %if.else20

if.then19:                                        ; preds = %land.lhs.true17
  call void @schedule()
  br label %if.end40

if.else20:                                        ; preds = %land.lhs.true17
  %cmp21 = icmp eq i32 %call7, 4
  br i1 %cmp21, label %if.then23, label %if.else36

if.then23:                                        ; preds = %if.else20, %if.end
  %need_watch = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 29
  %call24 = call i32 @atomic_read(%struct.atomic_t* %need_watch)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.then26, label %__here

if.then26:                                        ; preds = %if.then23
  %call27 = call i64 @schedule_timeout_interruptible(i64 100)
  br label %if.end40

__here:                                           ; preds = %if.then23
  %call31 = call %struct.task_struct* @get_current()
  %task_state_change = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call31, i32 0, i32 208
  store i64 ptrtoint (i8* blockaddress(@ipmi_thread, %__here) to i64), i64* %task_state_change, align 32, !tbaa !118
  %call32 = call %struct.task_struct* @get_current()
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call32, i32 0, i32 1
  store volatile i64 1, i64* %state, align 8, !tbaa !156
  call void @schedule()
  br label %if.end40

if.else36:                                        ; preds = %if.else20, %if.end
  %call37 = call i64 @schedule_timeout_interruptible(i64 1)
  br label %if.end40

if.end40:                                         ; preds = %if.else36, %__here, %if.then26, %if.then19, %if.end
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %8 = bitcast %struct.timespec* %busy_until to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %8) #7
  ret i32 0
}

declare %struct.task_struct* @kthread_create_on_node(i32 (i8*)*, i8*, i32, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare void @dev_notice(%struct.device*, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @ipmi_si_set_not_busy(%struct.timespec* %ts) #3 {
entry:
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %ts, i32 0, i32 1
  store i64 -1, i64* %tv_nsec, align 8, !tbaa !157
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #4 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !159
  ret %struct.task_struct* %0
}

declare void @set_user_nice(%struct.task_struct*, i64) #1

declare zeroext i1 @kthread_should_stop() #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ipmi_thread_busy_wait(i32 %smi_result, %struct.smi_info* %smi_info, %struct.timespec* %busy_until) #3 {
entry:
  %now = alloca %struct.timespec, align 8
  %intf_num = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 0
  %0 = load i32, i32* %intf_num, align 8, !tbaa !46
  %1 = load i32, i32* @num_max_busy_us, align 4, !tbaa !2
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %intf_num1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 0
  %2 = load i32, i32* %intf_num1, align 8, !tbaa !46
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @kipmid_max_busy_us, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !2
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %max_busy_us.0 = phi i32 [ %3, %if.then ], [ 0, %entry ]
  %cmp2 = icmp eq i32 %max_busy_us.0, 0
  %cmp3 = icmp ne i32 %smi_result, 1
  %or.cond = or i1 %cmp2, %cmp3
  br i1 %or.cond, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  call void @ipmi_si_set_not_busy(%struct.timespec* %busy_until)
  br label %cleanup17

if.else:                                          ; preds = %if.end
  %call = call i32 @ipmi_si_is_busy(%struct.timespec* %busy_until)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else6, label %if.then5

if.then5:                                         ; preds = %if.else
  call void @getnstimeofday64(%struct.timespec* %busy_until)
  %conv = zext i32 %max_busy_us.0 to i64
  %mul = mul nsw i64 %conv, 1000
  call void @timespec_add_ns(%struct.timespec* %busy_until, i64 %mul)
  br label %cleanup17

if.else6:                                         ; preds = %if.else
  %4 = bitcast %struct.timespec* %now to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %4) #7
  call void @getnstimeofday64(%struct.timespec* %now)
  %call7 = call i32 @timespec_compare(%struct.timespec* %now, %struct.timespec* %busy_until)
  %cmp8 = icmp sgt i32 %call7, 0
  %lnot = xor i1 %cmp8, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %cleanup

if.then13:                                        ; preds = %if.else6
  call void @ipmi_si_set_not_busy(%struct.timespec* %busy_until)
  br label %cleanup

cleanup:                                          ; preds = %if.then13, %if.else6
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then13 ], [ 0, %if.else6 ]
  %5 = bitcast %struct.timespec* %now to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %5) #7
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  %. = select i1 %SwitchLeaf, i32 1, i32 0
  br label %UnifiedReturnBlock

cleanup17:                                        ; preds = %if.then5, %if.then4
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %cleanup17, %cleanup
  %UnifiedRetVal = phi i32 [ %., %cleanup ], [ 1, %cleanup17 ]
  ret i32 %UnifiedRetVal
}

declare void @schedule() #1

declare i64 @schedule_timeout_interruptible(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ipmi_si_is_busy(%struct.timespec* %ts) #3 {
entry:
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %ts, i32 0, i32 1
  %0 = load i64, i64* %tv_nsec, align 8, !tbaa !157
  %cmp = icmp ne i64 %0, -1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare void @getnstimeofday64(%struct.timespec*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @timespec_add_ns(%struct.timespec* %a, i64 %ns) #4 {
entry:
  %ns.addr = alloca i64, align 8
  store i64 %ns, i64* %ns.addr, align 8, !tbaa !101
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %a, i32 0, i32 1
  %0 = load i64, i64* %tv_nsec, align 8, !tbaa !157
  %1 = load i64, i64* %ns.addr, align 8, !tbaa !101
  %add = add i64 %0, %1
  %call = call i32 @__iter_div_u64_rem(i64 %add, i32 1000000000, i64* %ns.addr)
  %conv = zext i32 %call to i64
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %a, i32 0, i32 0
  %2 = load i64, i64* %tv_sec, align 8, !tbaa !160
  %add1 = add nsw i64 %2, %conv
  store i64 %add1, i64* %tv_sec, align 8, !tbaa !160
  %3 = load i64, i64* %ns.addr, align 8, !tbaa !101
  %tv_nsec2 = getelementptr inbounds %struct.timespec, %struct.timespec* %a, i32 0, i32 1
  store i64 %3, i64* %tv_nsec2, align 8, !tbaa !157
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @timespec_compare(%struct.timespec* %lhs, %struct.timespec* %rhs) #3 {
entry:
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %lhs, i32 0, i32 0
  %0 = load i64, i64* %tv_sec, align 8, !tbaa !160
  %tv_sec1 = getelementptr inbounds %struct.timespec, %struct.timespec* %rhs, i32 0, i32 0
  %1 = load i64, i64* %tv_sec1, align 8, !tbaa !160
  %cmp = icmp slt i64 %0, %1
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tv_sec2 = getelementptr inbounds %struct.timespec, %struct.timespec* %lhs, i32 0, i32 0
  %2 = load i64, i64* %tv_sec2, align 8, !tbaa !160
  %tv_sec3 = getelementptr inbounds %struct.timespec, %struct.timespec* %rhs, i32 0, i32 0
  %3 = load i64, i64* %tv_sec3, align 8, !tbaa !160
  %cmp4 = icmp sgt i64 %2, %3
  br i1 %cmp4, label %return, label %if.end6

if.end6:                                          ; preds = %if.end
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %lhs, i32 0, i32 1
  %4 = load i64, i64* %tv_nsec, align 8, !tbaa !157
  %tv_nsec7 = getelementptr inbounds %struct.timespec, %struct.timespec* %rhs, i32 0, i32 1
  %5 = load i64, i64* %tv_nsec7, align 8, !tbaa !157
  %sub = sub nsw i64 %4, %5
  %conv = trunc i64 %sub to i32
  br label %return

return:                                           ; preds = %if.end6, %if.end, %entry
  %retval.0 = phi i32 [ %conv, %if.end6 ], [ -1, %entry ], [ 1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @__iter_div_u64_rem(i64 %dividend, i32 %divisor, i64* %remainder) #4 {
entry:
  %dividend.addr = alloca i64, align 8
  store i64 %dividend, i64* %dividend.addr, align 8, !tbaa !101
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %ret.0 = phi i32 [ 0, %entry ], [ %inc, %while.body ]
  %0 = load i64, i64* %dividend.addr, align 8, !tbaa !101
  %conv = zext i32 %divisor to i64
  %cmp = icmp uge i64 %0, %conv
  %1 = load i64, i64* %dividend.addr, align 8, !tbaa !101
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void asm "", "=*rm,0,~{dirflag},~{fpsr},~{flags}"(i64* %dividend.addr, i64 %1) #7, !srcloc !161
  %conv2 = zext i32 %divisor to i64
  %2 = load i64, i64* %dividend.addr, align 8, !tbaa !101
  %sub = sub i64 %2, %conv2
  store i64 %sub, i64* %dividend.addr, align 8, !tbaa !101
  %inc = add i32 %ret.0, 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store i64 %1, i64* %remainder, align 8, !tbaa !101
  ret i32 %ret.0
}

; Function Attrs: nounwind uwtable
define internal i32 @wait_for_msg_done(%struct.smi_info* %smi_info) #0 {
entry:
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %0 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %event = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %0, i32 0, i32 4
  %1 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event, align 8, !tbaa !88
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %2 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %call = call i32 %1(%struct.si_sm_data* %2, i64 0)
  br label %for.cond

for.cond:                                         ; preds = %if.end16, %entry
  %smi_result.0 = phi i32 [ %call, %entry ], [ %smi_result.1, %if.end16 ]
  switch i32 %smi_result.0, label %if.end20 [
    i32 1, label %if.then
    i32 2, label %if.then
    i32 0, label %if.then10
    i32 5, label %cleanup
  ]

if.then:                                          ; preds = %for.cond, %for.cond
  %call2 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %handlers3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %3 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers3, align 8, !tbaa !45
  %event4 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %3, i32 0, i32 4
  %4 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event4, align 8, !tbaa !88
  %si_sm5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %5 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm5, align 8, !tbaa !44
  %call6 = call i32 @jiffies_to_usecs(i64 1)
  %conv = zext i32 %call6 to i64
  %call7 = call i32 %4(%struct.si_sm_data* %5, i64 %conv)
  br label %if.end16

if.then10:                                        ; preds = %for.cond
  %handlers11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %6 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers11, align 8, !tbaa !45
  %event12 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %6, i32 0, i32 4
  %7 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event12, align 8, !tbaa !88
  %si_sm13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %8 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm13, align 8, !tbaa !44
  %call14 = call i32 %7(%struct.si_sm_data* %8, i64 0)
  br label %if.end16

if.end16:                                         ; preds = %if.then10, %if.then
  %smi_result.1 = phi i32 [ %call7, %if.then ], [ %call14, %if.then10 ]
  br label %for.cond

if.end20:                                         ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %for.cond
  %retval.0 = phi i32 [ 0, %if.end20 ], [ -19, %for.cond ]
  ret i32 %retval.0
}

declare i32 @jiffies_to_usecs(i64) #1

; Function Attrs: nounwind uwtable
define internal void @check_clr_rcv_irq(%struct.smi_info* %smi_info) #0 {
entry:
  %enables = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %enables) #7
  store i8 0, i8* %enables, align 1, !tbaa !6
  %call = call i32 @get_global_enables(%struct.smi_info* %smi_info, i8* %enables)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %0 = load i8, i8* %enables, align 1, !tbaa !6
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 1
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %if.then
  %1 = load i8, i8* %enables, align 1, !tbaa !6
  %conv3 = zext i8 %1 to i32
  %and4 = and i32 %conv3, -2
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, i8* %enables, align 1, !tbaa !6
  %2 = load i8, i8* %enables, align 1, !tbaa !6
  %call6 = call i32 @set_global_enables(%struct.smi_info* %smi_info, i8 zeroext %2)
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %rv.0 = phi i32 [ %call, %entry ], [ %call6, %if.end ]
  %cmp8 = icmp slt i32 %rv.0, 0
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %3 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %3, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.67, i32 0, i32 0), i32 %rv.0)
  br label %cleanup

if.end11:                                         ; preds = %if.end7
  %tobool12 = icmp ne i32 %rv.0, 0
  br i1 %tobool12, label %if.then13, label %cleanup

if.then13:                                        ; preds = %if.end11
  %dev14 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %4 = load %struct.device*, %struct.device** %dev14, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %4, i8* getelementptr inbounds ([98 x i8], [98 x i8]* @.str.68, i32 0, i32 0))
  %cannot_disable_irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 32
  store i8 1, i8* %cannot_disable_irq, align 2, !tbaa !107
  br label %cleanup

cleanup:                                          ; preds = %if.then13, %if.end11, %if.then10, %if.then
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then10 ], [ 1, %if.then ], [ 0, %if.then13 ], [ 0, %if.end11 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %enables) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @check_set_rcv_irq(%struct.smi_info* %smi_info) #0 {
entry:
  %enables = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %enables) #7
  store i8 0, i8* %enables, align 1, !tbaa !6
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 25
  %0 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call = call i32 @get_global_enables(%struct.smi_info* %smi_info, i8* %enables)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.end5, label %if.then2

if.then2:                                         ; preds = %if.end
  %1 = load i8, i8* %enables, align 1, !tbaa !6
  %conv = zext i8 %1 to i32
  %or = or i32 %conv, 1
  %conv3 = trunc i32 %or to i8
  store i8 %conv3, i8* %enables, align 1, !tbaa !6
  %2 = load i8, i8* %enables, align 1, !tbaa !6
  %call4 = call i32 @set_global_enables(%struct.smi_info* %smi_info, i8 zeroext %2)
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.end
  %rv.0 = phi i32 [ %call, %if.end ], [ %call4, %if.then2 ]
  %cmp = icmp slt i32 %rv.0, 0
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end5
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %3 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %3, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.73, i32 0, i32 0), i32 %rv.0)
  br label %cleanup

if.end8:                                          ; preds = %if.end5
  %tobool9 = icmp ne i32 %rv.0, 0
  br i1 %tobool9, label %if.then10, label %cleanup

if.then10:                                        ; preds = %if.end8
  %dev11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %4 = load %struct.device*, %struct.device** %dev11, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %4, i8* getelementptr inbounds ([97 x i8], [97 x i8]* @.str.74, i32 0, i32 0))
  %cannot_disable_irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 32
  store i8 1, i8* %cannot_disable_irq, align 2, !tbaa !107
  %irq_enable_broken = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 33
  store i8 1, i8* %irq_enable_broken, align 1, !tbaa !108
  br label %cleanup

cleanup:                                          ; preds = %if.then10, %if.end8, %if.then7, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then7 ], [ 1, %entry ], [ 0, %if.then10 ], [ 0, %if.end8 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %enables) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @get_global_enables(%struct.smi_info* %smi_info, i8* %enables) #0 {
entry:
  %msg = alloca [3 x i8], align 1
  %0 = bitcast [3 x i8]* %msg to i8*
  call void @llvm.lifetime.start.p0i8(i64 3, i8* %0) #7
  %call = call i8* @kmalloc(i64 272, i32 20971712)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 1
  store i8 47, i8* %arrayidx1, align 1, !tbaa !6
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %1 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %1, i32 0, i32 2
  %2 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !85
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %3 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %arraydecay = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i32 0, i32 0
  %call2 = call i32 %2(%struct.si_sm_data* %3, i8* %arraydecay, i32 2)
  %call3 = call i32 @wait_for_msg_done(%struct.smi_info* %smi_info)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %4 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %4, i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.69, i32 0, i32 0), i32 %call3)
  br label %out

if.end6:                                          ; preds = %if.end
  %handlers7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %5 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers7, align 8, !tbaa !45
  %get_result = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %5, i32 0, i32 3
  %6 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result, align 8, !tbaa !92
  %si_sm8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %7 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm8, align 8, !tbaa !44
  %call9 = call i32 %6(%struct.si_sm_data* %7, i8* %call, i32 272)
  %conv = sext i32 %call9 to i64
  %cmp = icmp ult i64 %conv, 4
  br i1 %cmp, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end6
  %arrayidx11 = getelementptr inbounds i8, i8* %call, i64 0
  %8 = load i8, i8* %arrayidx11, align 1, !tbaa !6
  %conv12 = zext i8 %8 to i32
  %cmp13 = icmp ne i32 %conv12, 28
  br i1 %cmp13, label %if.then25, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %lor.lhs.false
  %arrayidx16 = getelementptr inbounds i8, i8* %call, i64 1
  %9 = load i8, i8* %arrayidx16, align 1, !tbaa !6
  %conv17 = zext i8 %9 to i32
  %cmp18 = icmp ne i32 %conv17, 47
  br i1 %cmp18, label %if.then25, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false15
  %arrayidx21 = getelementptr inbounds i8, i8* %call, i64 2
  %10 = load i8, i8* %arrayidx21, align 1, !tbaa !6
  %conv22 = zext i8 %10 to i32
  %cmp23 = icmp ne i32 %conv22, 0
  br i1 %cmp23, label %if.then25, label %if.else

if.then25:                                        ; preds = %lor.lhs.false20, %lor.lhs.false15, %lor.lhs.false, %if.end6
  %dev26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %11 = load %struct.device*, %struct.device** %dev26, align 8, !tbaa !38
  %arrayidx27 = getelementptr inbounds i8, i8* %call, i64 0
  %12 = load i8, i8* %arrayidx27, align 1, !tbaa !6
  %conv28 = zext i8 %12 to i32
  %arrayidx29 = getelementptr inbounds i8, i8* %call, i64 1
  %13 = load i8, i8* %arrayidx29, align 1, !tbaa !6
  %conv30 = zext i8 %13 to i32
  %arrayidx31 = getelementptr inbounds i8, i8* %call, i64 2
  %14 = load i8, i8* %arrayidx31, align 1, !tbaa !6
  %conv32 = zext i8 %14 to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %11, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.70, i32 0, i32 0), i64 %conv, i32 %conv28, i32 %conv30, i32 %conv32)
  br label %out

if.else:                                          ; preds = %lor.lhs.false20
  %arrayidx33 = getelementptr inbounds i8, i8* %call, i64 3
  %15 = load i8, i8* %arrayidx33, align 1, !tbaa !6
  store i8 %15, i8* %enables, align 1, !tbaa !6
  br label %out

out:                                              ; preds = %if.else, %if.then25, %if.then5
  %rv.0 = phi i32 [ %call3, %if.then5 ], [ -22, %if.then25 ], [ %call3, %if.else ]
  call void @kfree(i8* %call)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %rv.0, %out ], [ -12, %entry ]
  %16 = bitcast [3 x i8]* %msg to i8*
  call void @llvm.lifetime.end.p0i8(i64 3, i8* %16) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @set_global_enables(%struct.smi_info* %smi_info, i8 zeroext %enables) #0 {
entry:
  %msg = alloca [3 x i8], align 1
  %0 = bitcast [3 x i8]* %msg to i8*
  call void @llvm.lifetime.start.p0i8(i64 3, i8* %0) #7
  %call = call i8* @kmalloc(i64 272, i32 20971712)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 1
  store i8 46, i8* %arrayidx1, align 1, !tbaa !6
  %arrayidx2 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 2
  store i8 %enables, i8* %arrayidx2, align 1, !tbaa !6
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %1 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %1, i32 0, i32 2
  %2 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !85
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %3 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !44
  %arraydecay = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i32 0, i32 0
  %call3 = call i32 %2(%struct.si_sm_data* %3, i8* %arraydecay, i32 3)
  %call4 = call i32 @wait_for_msg_done(%struct.smi_info* %smi_info)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %4 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %4, i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.71, i32 0, i32 0), i32 %call4)
  br label %out

if.end7:                                          ; preds = %if.end
  %handlers8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %5 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers8, align 8, !tbaa !45
  %get_result = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %5, i32 0, i32 3
  %6 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result, align 8, !tbaa !92
  %si_sm9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %7 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm9, align 8, !tbaa !44
  %call10 = call i32 %6(%struct.si_sm_data* %7, i8* %call, i32 272)
  %conv = sext i32 %call10 to i64
  %cmp = icmp ult i64 %conv, 3
  br i1 %cmp, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %arrayidx12 = getelementptr inbounds i8, i8* %call, i64 0
  %8 = load i8, i8* %arrayidx12, align 1, !tbaa !6
  %conv13 = zext i8 %8 to i32
  %cmp14 = icmp ne i32 %conv13, 28
  br i1 %cmp14, label %if.then21, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %lor.lhs.false
  %arrayidx17 = getelementptr inbounds i8, i8* %call, i64 1
  %9 = load i8, i8* %arrayidx17, align 1, !tbaa !6
  %conv18 = zext i8 %9 to i32
  %cmp19 = icmp ne i32 %conv18, 46
  br i1 %cmp19, label %if.then21, label %if.end27

if.then21:                                        ; preds = %lor.lhs.false16, %lor.lhs.false, %if.end7
  %dev22 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %10 = load %struct.device*, %struct.device** %dev22, align 8, !tbaa !38
  %arrayidx23 = getelementptr inbounds i8, i8* %call, i64 0
  %11 = load i8, i8* %arrayidx23, align 1, !tbaa !6
  %conv24 = zext i8 %11 to i32
  %arrayidx25 = getelementptr inbounds i8, i8* %call, i64 1
  %12 = load i8, i8* %arrayidx25, align 1, !tbaa !6
  %conv26 = zext i8 %12 to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %10, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.72, i32 0, i32 0), i64 %conv, i32 %conv24, i32 %conv26)
  br label %out

if.end27:                                         ; preds = %lor.lhs.false16
  %arrayidx28 = getelementptr inbounds i8, i8* %call, i64 2
  %13 = load i8, i8* %arrayidx28, align 1, !tbaa !6
  %conv29 = zext i8 %13 to i32
  %cmp30 = icmp ne i32 %conv29, 0
  %.call4 = select i1 %cmp30, i32 1, i32 %call4
  br label %out

out:                                              ; preds = %if.end27, %if.then21, %if.then6
  %rv.1 = phi i32 [ %call4, %if.then6 ], [ -22, %if.then21 ], [ %.call4, %if.end27 ]
  call void @kfree(i8* %call)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %rv.1, %out ], [ -12, %entry ]
  %14 = bitcast [3 x i8]* %msg to i8*
  call void @llvm.lifetime.end.p0i8(i64 3, i8* %14) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @setup_dell_poweredge_bt_xaction_handler(%struct.smi_info* %smi_info) #0 {
entry:
  %device_id = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 35
  %manufacturer_id = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 6
  %0 = load i32, i32* %manufacturer_id, align 4, !tbaa !162
  %cmp = icmp eq i32 %0, 674
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 4
  %1 = load i32, i32* %si_type, align 8, !tbaa !21
  %cmp1 = icmp eq i32 %1, 2
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @register_xaction_notifier(%struct.notifier_block* @dell_poweredge_bt_xaction_notifier)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @register_xaction_notifier(%struct.notifier_block* %nb) #0 {
entry:
  %call = call i32 @atomic_notifier_chain_register(%struct.atomic_notifier_head* @xaction_notifier_list, %struct.notifier_block* %nb)
  ret void
}

declare i32 @atomic_notifier_chain_register(%struct.atomic_notifier_head*, %struct.notifier_block*) #1

; Function Attrs: nounwind uwtable
define internal i32 @dell_poweredge_bt_xaction_handler(%struct.notifier_block* %self, i64 %unused, i8* %in) #0 {
entry:
  %0 = bitcast i8* %in to %struct.smi_info*
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 7
  %1 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %data1 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %1, i32 0, i32 4
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %data1, i32 0, i32 0
  %curr_msg2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 7
  %2 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg2, align 8, !tbaa !72
  %data_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %2, i32 0, i32 3
  %3 = load i32, i32* %data_size, align 8, !tbaa !98
  %cmp = icmp uge i32 %3, 8
  br i1 %cmp, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %entry
  %arrayidx = getelementptr inbounds i8, i8* %arraydecay, i64 0
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv = zext i8 %4 to i32
  %shr = ashr i32 %conv, 2
  %cmp3 = icmp eq i32 %shr, 10
  br i1 %cmp3, label %land.lhs.true5, label %cleanup

land.lhs.true5:                                   ; preds = %land.lhs.true
  %arrayidx6 = getelementptr inbounds i8, i8* %arraydecay, i64 1
  %5 = load i8, i8* %arrayidx6, align 1, !tbaa !6
  %conv7 = zext i8 %5 to i32
  %cmp8 = icmp eq i32 %conv7, 35
  br i1 %cmp8, label %land.lhs.true10, label %cleanup

land.lhs.true10:                                  ; preds = %land.lhs.true5
  %arrayidx11 = getelementptr inbounds i8, i8* %arraydecay, i64 7
  %6 = load i8, i8* %arrayidx11, align 1, !tbaa !6
  %conv12 = zext i8 %6 to i32
  %cmp13 = icmp eq i32 %conv12, 58
  br i1 %cmp13, label %if.then, label %cleanup

if.then:                                          ; preds = %land.lhs.true10
  call void @return_hosed_msg_badsize(%struct.smi_info* %0)
  br label %cleanup

cleanup:                                          ; preds = %if.then, %land.lhs.true10, %land.lhs.true5, %land.lhs.true, %entry
  %retval.0 = phi i32 [ 32769, %if.then ], [ 0, %land.lhs.true10 ], [ 0, %land.lhs.true5 ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @return_hosed_msg_badsize(%struct.smi_info* %smi_info) #0 {
entry:
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %0 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !72
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 4
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %data, i64 0, i64 0
  %1 = load i8, i8* %arrayidx, align 4, !tbaa !6
  %conv = zext i8 %1 to i32
  %or = or i32 %conv, 4
  %conv1 = trunc i32 %or to i8
  %rsp = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx2 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp, i64 0, i64 0
  store i8 %conv1, i8* %arrayidx2, align 8, !tbaa !6
  %data3 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 4
  %arrayidx4 = getelementptr inbounds [272 x i8], [272 x i8]* %data3, i64 0, i64 1
  %2 = load i8, i8* %arrayidx4, align 1, !tbaa !6
  %rsp5 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx6 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp5, i64 0, i64 1
  store i8 %2, i8* %arrayidx6, align 1, !tbaa !6
  %rsp7 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx8 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp7, i64 0, i64 2
  store i8 -54, i8* %arrayidx8, align 2, !tbaa !6
  %rsp_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 5
  store i32 3, i32* %rsp_size, align 4, !tbaa !93
  %curr_msg9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg9, align 8, !tbaa !72
  call void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @setup_dell_poweredge_oem_data_handler(%struct.smi_info* %smi_info) #0 {
entry:
  %device_id = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 35
  %manufacturer_id = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 6
  %0 = load i32, i32* %manufacturer_id, align 4, !tbaa !162
  %cmp = icmp eq i32 %0, 674
  br i1 %cmp, label %if.then, label %if.end29

if.then:                                          ; preds = %entry
  %device_id1 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 0
  %1 = load i8, i8* %device_id1, align 4, !tbaa !163
  %conv = zext i8 %1 to i32
  %cmp2 = icmp eq i32 %conv, 32
  br i1 %cmp2, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %device_revision = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 1
  %2 = load i8, i8* %device_revision, align 1, !tbaa !164
  %conv4 = zext i8 %2 to i32
  %cmp5 = icmp eq i32 %conv4, 128
  br i1 %cmp5, label %land.lhs.true7, label %if.else

land.lhs.true7:                                   ; preds = %land.lhs.true
  %ipmi_version = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 4
  %3 = load i8, i8* %ipmi_version, align 4, !tbaa !165
  %conv8 = zext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 81
  br i1 %cmp9, label %if.then11, label %if.else

if.then11:                                        ; preds = %land.lhs.true7
  %oem_data_avail_handler = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 18
  store i32 (%struct.smi_info*)* @oem_data_avail_to_receive_msg_avail, i32 (%struct.smi_info*)** %oem_data_avail_handler, align 8, !tbaa !106
  br label %if.end29

if.else:                                          ; preds = %land.lhs.true7, %land.lhs.true, %if.then
  %ipmi_version12 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 4
  %4 = load i8, i8* %ipmi_version12, align 4, !tbaa !165
  %conv13 = zext i8 %4 to i32
  %and = and i32 %conv13, 15
  %cmp14 = icmp slt i32 %and, 1
  br i1 %cmp14, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %ipmi_version16 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 4
  %5 = load i8, i8* %ipmi_version16, align 4, !tbaa !165
  %conv17 = zext i8 %5 to i32
  %and18 = and i32 %conv17, 15
  %cmp19 = icmp eq i32 %and18, 1
  br i1 %cmp19, label %land.lhs.true21, label %if.end29

land.lhs.true21:                                  ; preds = %lor.lhs.false
  %ipmi_version22 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 4
  %6 = load i8, i8* %ipmi_version22, align 4, !tbaa !165
  %conv23 = zext i8 %6 to i32
  %shr = ashr i32 %conv23, 4
  %cmp24 = icmp slt i32 %shr, 5
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %land.lhs.true21, %if.else
  %oem_data_avail_handler27 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 18
  store i32 (%struct.smi_info*)* @oem_data_avail_to_receive_msg_avail, i32 (%struct.smi_info*)** %oem_data_avail_handler27, align 8, !tbaa !106
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %land.lhs.true21, %lor.lhs.false, %if.then11, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @oem_data_avail_to_receive_msg_avail(%struct.smi_info* %smi_info) #0 {
entry:
  %msg_flags = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  %0 = load i8, i8* %msg_flags, align 8, !tbaa !95
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, -225
  %or = or i32 %and, 1
  %conv1 = trunc i32 %or to i8
  %msg_flags2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  store i8 %conv1, i8* %msg_flags2, align 8, !tbaa !95
  ret i32 1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ipmi_demangle_device_id(i8* %data, i32 %data_len, %struct.ipmi_device_id* %id) #3 {
entry:
  %cmp = icmp ult i32 %data_len, 9
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 0
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv = zext i8 %0 to i32
  %cmp1 = icmp ne i32 %conv, 28
  br i1 %cmp1, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %arrayidx3 = getelementptr inbounds i8, i8* %data, i64 1
  %1 = load i8, i8* %arrayidx3, align 1, !tbaa !6
  %conv4 = zext i8 %1 to i32
  %cmp5 = icmp ne i32 %conv4, 1
  br i1 %cmp5, label %return, label %if.end8

if.end8:                                          ; preds = %lor.lhs.false
  %arrayidx9 = getelementptr inbounds i8, i8* %data, i64 2
  %2 = load i8, i8* %arrayidx9, align 1, !tbaa !6
  %conv10 = zext i8 %2 to i32
  %cmp11 = icmp ne i32 %conv10, 0
  br i1 %cmp11, label %return, label %if.end14

if.end14:                                         ; preds = %if.end8
  %add.ptr = getelementptr inbounds i8, i8* %data, i64 3
  %sub = sub i32 %data_len, 3
  %arrayidx15 = getelementptr inbounds i8, i8* %add.ptr, i64 0
  %3 = load i8, i8* %arrayidx15, align 1, !tbaa !6
  %device_id = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 0
  store i8 %3, i8* %device_id, align 4, !tbaa !163
  %arrayidx16 = getelementptr inbounds i8, i8* %add.ptr, i64 1
  %4 = load i8, i8* %arrayidx16, align 1, !tbaa !6
  %device_revision = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 1
  store i8 %4, i8* %device_revision, align 1, !tbaa !164
  %arrayidx17 = getelementptr inbounds i8, i8* %add.ptr, i64 2
  %5 = load i8, i8* %arrayidx17, align 1, !tbaa !6
  %firmware_revision_1 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 2
  store i8 %5, i8* %firmware_revision_1, align 2, !tbaa !166
  %arrayidx18 = getelementptr inbounds i8, i8* %add.ptr, i64 3
  %6 = load i8, i8* %arrayidx18, align 1, !tbaa !6
  %firmware_revision_2 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 3
  store i8 %6, i8* %firmware_revision_2, align 1, !tbaa !167
  %arrayidx19 = getelementptr inbounds i8, i8* %add.ptr, i64 4
  %7 = load i8, i8* %arrayidx19, align 1, !tbaa !6
  %ipmi_version = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 4
  store i8 %7, i8* %ipmi_version, align 4, !tbaa !165
  %arrayidx20 = getelementptr inbounds i8, i8* %add.ptr, i64 5
  %8 = load i8, i8* %arrayidx20, align 1, !tbaa !6
  %additional_device_support = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 5
  store i8 %8, i8* %additional_device_support, align 1, !tbaa !168
  %cmp21 = icmp uge i32 %sub, 11
  br i1 %cmp21, label %if.then23, label %if.else

if.then23:                                        ; preds = %if.end14
  %arrayidx24 = getelementptr inbounds i8, i8* %add.ptr, i64 6
  %9 = load i8, i8* %arrayidx24, align 1, !tbaa !6
  %conv25 = zext i8 %9 to i32
  %arrayidx26 = getelementptr inbounds i8, i8* %add.ptr, i64 7
  %10 = load i8, i8* %arrayidx26, align 1, !tbaa !6
  %conv27 = zext i8 %10 to i32
  %shl = shl i32 %conv27, 8
  %or = or i32 %conv25, %shl
  %arrayidx28 = getelementptr inbounds i8, i8* %add.ptr, i64 8
  %11 = load i8, i8* %arrayidx28, align 1, !tbaa !6
  %conv29 = zext i8 %11 to i32
  %shl30 = shl i32 %conv29, 16
  %or31 = or i32 %or, %shl30
  %manufacturer_id = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 6
  store i32 %or31, i32* %manufacturer_id, align 4, !tbaa !162
  %arrayidx32 = getelementptr inbounds i8, i8* %add.ptr, i64 9
  %12 = load i8, i8* %arrayidx32, align 1, !tbaa !6
  %conv33 = zext i8 %12 to i32
  %arrayidx34 = getelementptr inbounds i8, i8* %add.ptr, i64 10
  %13 = load i8, i8* %arrayidx34, align 1, !tbaa !6
  %conv35 = zext i8 %13 to i32
  %shl36 = shl i32 %conv35, 8
  %or37 = or i32 %conv33, %shl36
  br label %if.end40

if.else:                                          ; preds = %if.end14
  %manufacturer_id38 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 6
  store i32 0, i32* %manufacturer_id38, align 4, !tbaa !162
  br label %if.end40

if.end40:                                         ; preds = %if.else, %if.then23
  %.sink = phi i32 [ 0, %if.else ], [ %or37, %if.then23 ]
  %product_id39 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 7
  store i32 %.sink, i32* %product_id39, align 4, !tbaa !169
  %cmp41 = icmp uge i32 %sub, 15
  br i1 %cmp41, label %if.then43, label %if.else45

if.then43:                                        ; preds = %if.end40
  %aux_firmware_revision = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 8
  %arraydecay = getelementptr inbounds [4 x i8], [4 x i8]* %aux_firmware_revision, i32 0, i32 0
  %add.ptr44 = getelementptr inbounds i8, i8* %add.ptr, i64 11
  %call = call i8* @__memcpy(i8* %arraydecay, i8* %add.ptr44, i64 4)
  %aux_firmware_revision_set = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 9
  %bf.load = load i8, i8* %aux_firmware_revision_set, align 4
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %aux_firmware_revision_set, align 4
  br label %return

if.else45:                                        ; preds = %if.end40
  %aux_firmware_revision_set46 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 9
  %bf.load47 = load i8, i8* %aux_firmware_revision_set46, align 4
  %bf.clear48 = and i8 %bf.load47, -2
  store i8 %bf.clear48, i8* %aux_firmware_revision_set46, align 4
  br label %return

return:                                           ; preds = %if.else45, %if.then43, %if.end8, %lor.lhs.false, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -22, %if.end8 ], [ 0, %if.else45 ], [ 0, %if.then43 ]
  ret i32 %retval.0
}

declare i8* @__memcpy(i8*, i8*, i64) #1

declare noalias i8* @__kmalloc(i64, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_probe(%struct.platform_device* %dev) #0 {
entry:
  %call = call i32 @of_ipmi_probe(%struct.platform_device* %dev)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @acpi_ipmi_probe(%struct.platform_device* %dev)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_remove(%struct.platform_device* %dev) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  %call = call i8* @dev_get_drvdata(%struct.device* %dev1)
  %0 = bitcast i8* %call to %struct.smi_info*
  call void @cleanup_one_si(%struct.smi_info* %0)
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !81
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @of_ipmi_probe(%struct.platform_device* %dev) #0 {
entry:
  %resource = alloca %struct.resource, align 8
  %proplen = alloca i32, align 4
  %0 = bitcast %struct.resource* %resource to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #7
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  %of_node = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 26
  %1 = load %struct.device_node*, %struct.device_node** %of_node, align 8, !tbaa !170
  %2 = bitcast i32* %proplen to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #7
  %dev2 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev2, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.48, i32 0, i32 0))
  %dev3 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  %call = call %struct.of_device_id* @of_match_device(%struct.of_device_id* getelementptr inbounds ([4 x %struct.of_device_id], [4 x %struct.of_device_id]* @of_ipmi_match, i32 0, i32 0), %struct.device* %dev3)
  %tobool = icmp ne %struct.of_device_id* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call4 = call zeroext i1 @of_device_is_available(%struct.device_node* %1)
  br i1 %call4, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @of_address_to_resource(%struct.device_node* %1, i32 0, %struct.resource* %resource)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end6
  %dev10 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev10, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.49, i32 0, i32 0))
  br label %cleanup

if.end11:                                         ; preds = %if.end6
  %call12 = call i8* @of_get_property(%struct.device_node* %1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.50, i32 0, i32 0), i32* %proplen)
  %3 = bitcast i8* %call12 to i32*
  %tobool13 = icmp ne i32* %3, null
  %4 = load i32, i32* %proplen, align 4
  %cmp = icmp ne i32 %4, 4
  %or.cond = and i1 %tobool13, %cmp
  br i1 %or.cond, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  %dev15 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev15, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.51, i32 0, i32 0))
  br label %cleanup

if.end16:                                         ; preds = %if.end11
  %call17 = call i8* @of_get_property(%struct.device_node* %1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.52, i32 0, i32 0), i32* %proplen)
  %5 = bitcast i8* %call17 to i32*
  %tobool18 = icmp ne i32* %5, null
  %6 = load i32, i32* %proplen, align 4
  %cmp20 = icmp ne i32 %6, 4
  %or.cond1 = and i1 %tobool18, %cmp20
  br i1 %or.cond1, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end16
  %dev22 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev22, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.53, i32 0, i32 0))
  br label %cleanup

if.end23:                                         ; preds = %if.end16
  %call24 = call i8* @of_get_property(%struct.device_node* %1, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.54, i32 0, i32 0), i32* %proplen)
  %7 = bitcast i8* %call24 to i32*
  %tobool25 = icmp ne i32* %7, null
  %8 = load i32, i32* %proplen, align 4
  %cmp27 = icmp ne i32 %8, 4
  %or.cond2 = and i1 %tobool25, %cmp27
  br i1 %or.cond2, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end23
  %dev29 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev29, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.55, i32 0, i32 0))
  br label %cleanup

if.end30:                                         ; preds = %if.end23
  %call31 = call %struct.smi_info* @smi_info_alloc()
  %tobool32 = icmp ne %struct.smi_info* %call31, null
  br i1 %tobool32, label %if.end35, label %if.then33

if.then33:                                        ; preds = %if.end30
  %dev34 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev34, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.56, i32 0, i32 0))
  br label %cleanup

if.end35:                                         ; preds = %if.end30
  %data = getelementptr inbounds %struct.of_device_id, %struct.of_device_id* %call, i32 0, i32 3
  %9 = load i8*, i8** %data, align 8, !tbaa !173
  %10 = ptrtoint i8* %9 to i32
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 4
  store i32 %10, i32* %si_type, align 8, !tbaa !21
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 15
  store i32 7, i32* %addr_source, align 4, !tbaa !9
  %irq_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 12
  store i32 (%struct.smi_info*)* @std_irq_setup, i32 (%struct.smi_info*)** %irq_setup, align 8, !tbaa !30
  %flags = getelementptr inbounds %struct.resource, %struct.resource* %resource, i32 0, i32 3
  %11 = load i64, i64* %flags, align 8, !tbaa !175
  %and = and i64 %11, 256
  %tobool36 = icmp ne i64 %and, 0
  %io_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 10
  %mem_setup.sink = select i1 %tobool36, i32 (%struct.smi_info*)* @port_setup, i32 (%struct.smi_info*)* @mem_setup
  %.sink = select i1 %tobool36, i32 0, i32 1
  store i32 (%struct.smi_info*)* %mem_setup.sink, i32 (%struct.smi_info*)** %io_setup, align 8, !tbaa !24
  %io39 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 9
  %addr_type40 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io39, i32 0, i32 6
  store i32 %.sink, i32* %addr_type40, align 4, !tbaa !23
  %start = getelementptr inbounds %struct.resource, %struct.resource* %resource, i32 0, i32 0
  %12 = load i64, i64* %start, align 8, !tbaa !177
  %io42 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io42, i32 0, i32 7
  store i64 %12, i64* %addr_data, align 8, !tbaa !22
  %tobool43 = icmp ne i32* %3, null
  br i1 %tobool43, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end35
  %call44 = call i32 @__be32_to_cpup(i32* %3)
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end35
  %cond = phi i32 [ %call44, %cond.true ], [ 1, %if.end35 ]
  %io45 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 9
  %regsize46 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io45, i32 0, i32 4
  store i32 %cond, i32* %regsize46, align 4, !tbaa !27
  %tobool47 = icmp ne i32* %5, null
  br i1 %tobool47, label %cond.true48, label %cond.end51

cond.true48:                                      ; preds = %cond.end
  %call49 = call i32 @__be32_to_cpup(i32* %5)
  br label %cond.end51

cond.end51:                                       ; preds = %cond.true48, %cond.end
  %cond52 = phi i32 [ %call49, %cond.true48 ], [ 1, %cond.end ]
  %io53 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 9
  %regspacing54 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io53, i32 0, i32 3
  store i32 %cond52, i32* %regspacing54, align 8, !tbaa !26
  %tobool55 = icmp ne i32* %7, null
  br i1 %tobool55, label %cond.true56, label %cond.end59

cond.true56:                                      ; preds = %cond.end51
  %call57 = call i32 @__be32_to_cpup(i32* %7)
  br label %cond.end59

cond.end59:                                       ; preds = %cond.true56, %cond.end51
  %cond60 = phi i32 [ %call57, %cond.true56 ], [ 0, %cond.end51 ]
  %io61 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 9
  %regshift62 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io61, i32 0, i32 5
  store i32 %cond60, i32* %regshift62, align 8, !tbaa !28
  %dev63 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  %of_node64 = getelementptr inbounds %struct.device, %struct.device* %dev63, i32 0, i32 26
  %13 = load %struct.device_node*, %struct.device_node** %of_node64, align 8, !tbaa !170
  %call65 = call i32 @irq_of_parse_and_map(%struct.device_node* %13, i32 0)
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 25
  store i32 %call65, i32* %irq, align 4, !tbaa !29
  %dev66 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  %dev67 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 36
  store %struct.device* %dev66, %struct.device** %dev67, align 8, !tbaa !38
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @of_ipmi_probe.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and69 = and i32 %bf.clear, 1
  %tobool70 = icmp ne i32 %and69, 0
  %lnot = xor i1 %tobool70, true
  %lnot71 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot71 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool72 = icmp ne i64 %expval, 0
  br i1 %tobool72, label %if.then73, label %do.end84

if.then73:                                        ; preds = %cond.end59
  %dev74 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  %io75 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 9
  %addr_data76 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io75, i32 0, i32 7
  %14 = load i64, i64* %addr_data76, align 8, !tbaa !22
  %io77 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 9
  %regsize78 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io77, i32 0, i32 4
  %15 = load i32, i32* %regsize78, align 4, !tbaa !27
  %io79 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 9
  %regspacing80 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io79, i32 0, i32 3
  %16 = load i32, i32* %regspacing80, align 8, !tbaa !26
  %irq81 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call31, i32 0, i32 25
  %17 = load i32, i32* %irq81, align 4, !tbaa !29
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @of_ipmi_probe.descriptor to %struct._ddebug*), %struct.device* %dev74, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.57, i32 0, i32 0), i64 %14, i32 %15, i32 %16, i32 %17)
  br label %do.end84

do.end84:                                         ; preds = %if.then73, %cond.end59
  %dev85 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  %18 = bitcast %struct.smi_info* %call31 to i8*
  call void @dev_set_drvdata(%struct.device* %dev85, i8* %18)
  %call86 = call i32 @add_smi(%struct.smi_info* %call31)
  %tobool87 = icmp ne i32 %call86, 0
  br i1 %tobool87, label %if.then88, label %cleanup

if.then88:                                        ; preds = %do.end84
  %19 = bitcast %struct.smi_info* %call31 to i8*
  call void @kfree(i8* %19)
  br label %cleanup

cleanup:                                          ; preds = %if.then88, %do.end84, %if.then33, %if.then28, %if.then21, %if.then14, %if.then9, %if.end, %entry
  %retval.0 = phi i32 [ %call7, %if.then9 ], [ -22, %if.then14 ], [ -22, %if.then21 ], [ -22, %if.then28 ], [ %call86, %if.then88 ], [ -12, %if.then33 ], [ -19, %entry ], [ -22, %if.end ], [ 0, %do.end84 ]
  %20 = bitcast i32* %proplen to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %20) #7
  %21 = bitcast %struct.resource* %resource to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %21) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @acpi_ipmi_probe(%struct.platform_device* %dev) #0 {
entry:
  %tmp = alloca i64, align 8
  %0 = bitcast i64* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = load i8, i8* @si_tryacpi, align 1, !tbaa !97, !range !79
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  %fwnode = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 27
  %2 = load %struct.fwnode_handle*, %struct.fwnode_handle** %fwnode, align 8, !tbaa !178
  %call = call %struct.acpi_device* @to_acpi_device_node(%struct.fwnode_handle* %2)
  %call2 = call i8* @acpi_device_handle(%struct.acpi_device* %call)
  %tobool3 = icmp ne i8* %call2, null
  br i1 %tobool3, label %if.end5, label %cleanup

if.end5:                                          ; preds = %if.end
  %call6 = call %struct.smi_info* @smi_info_alloc()
  %tobool7 = icmp ne %struct.smi_info* %call6, null
  br i1 %tobool7, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end5
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 15
  store i32 4, i32* %addr_source, align 4, !tbaa !9
  %dev10 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev10, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.58, i32 0, i32 0))
  %addr_info = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 43
  %acpi_info = bitcast %union.ipmi_smi_info_union* %addr_info to %union.anon.51*
  %acpi_handle = getelementptr inbounds %union.anon.51, %union.anon.51* %acpi_info, i32 0, i32 0
  store i8* %call2, i8** %acpi_handle, align 8, !tbaa !6
  %call11 = call i32 @acpi_evaluate_integer(i8* %call2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.59, i32 0, i32 0), %struct.acpi_object_list* null, i64* %tmp)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end9
  %dev14 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev14, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.60, i32 0, i32 0))
  br label %err_free

if.end15:                                         ; preds = %if.end9
  %3 = load i64, i64* %tmp, align 8, !tbaa !101
  %Pivot6 = icmp slt i64 %3, 3
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.end15
  %Pivot4 = icmp slt i64 %3, 4
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i64 %3, 4
  br i1 %SwitchLeaf2, label %err_free, label %sw.default

NodeBlock:                                        ; preds = %if.end15
  %Pivot = icmp slt i64 %3, 2
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i64 %3, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %dev21 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  %4 = load i64, i64* %tmp, align 8, !tbaa !101
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev21, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.61, i32 0, i32 0), i64 %4)
  br label %err_free

sw.epilog:                                        ; preds = %LeafBlock, %NodeBlock, %NodeBlock3
  %.sink = phi i32 [ 1, %NodeBlock ], [ 2, %NodeBlock3 ], [ 0, %LeafBlock ]
  %si_type19 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 4
  store i32 %.sink, i32* %si_type19, align 8, !tbaa !21
  %call22 = call %struct.resource* @platform_get_resource(%struct.platform_device* %dev, i32 256, i32 0)
  %tobool23 = icmp ne %struct.resource* %call22, null
  br i1 %tobool23, label %if.end32.sink.split, label %if.else

if.else:                                          ; preds = %sw.epilog
  %call25 = call %struct.resource* @platform_get_resource(%struct.platform_device* %dev, i32 512, i32 0)
  %tobool26 = icmp ne %struct.resource* %call25, null
  br i1 %tobool26, label %if.end32.sink.split, label %if.end32

if.end32.sink.split:                              ; preds = %if.else, %sw.epilog
  %mem_setup.sink = phi i32 (%struct.smi_info*)* [ @mem_setup, %if.else ], [ @port_setup, %sw.epilog ]
  %.sink7 = phi i32 [ 1, %if.else ], [ 0, %sw.epilog ]
  %res.0.ph = phi %struct.resource* [ %call25, %if.else ], [ %call22, %sw.epilog ]
  %io_setup28 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 10
  store i32 (%struct.smi_info*)* %mem_setup.sink, i32 (%struct.smi_info*)** %io_setup28, align 8, !tbaa !24
  %io29 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %addr_type30 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io29, i32 0, i32 6
  store i32 %.sink7, i32* %addr_type30, align 4, !tbaa !23
  br label %if.end32

if.end32:                                         ; preds = %if.end32.sink.split, %if.else
  %res.0 = phi %struct.resource* [ %call25, %if.else ], [ %res.0.ph, %if.end32.sink.split ]
  %tobool33 = icmp ne %struct.resource* %res.0, null
  br i1 %tobool33, label %if.end36, label %if.then34

if.then34:                                        ; preds = %if.end32
  %dev35 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev35, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.62, i32 0, i32 0))
  br label %err_free

if.end36:                                         ; preds = %if.end32
  %start = getelementptr inbounds %struct.resource, %struct.resource* %res.0, i32 0, i32 0
  %5 = load i64, i64* %start, align 8, !tbaa !177
  %io37 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io37, i32 0, i32 7
  store i64 %5, i64* %addr_data, align 8, !tbaa !22
  %io38 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io38, i32 0, i32 3
  store i32 1, i32* %regspacing, align 8, !tbaa !26
  %io39 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %addr_type40 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io39, i32 0, i32 6
  %6 = load i32, i32* %addr_type40, align 4, !tbaa !23
  %cmp = icmp eq i32 %6, 0
  %7 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 256, i32 512
  %call41 = call %struct.resource* @platform_get_resource(%struct.platform_device* %dev, i32 %cond, i32 1)
  %tobool42 = icmp ne %struct.resource* %call41, null
  br i1 %tobool42, label %if.then43, label %if.end55

if.then43:                                        ; preds = %if.end36
  %start44 = getelementptr inbounds %struct.resource, %struct.resource* %call41, i32 0, i32 0
  %8 = load i64, i64* %start44, align 8, !tbaa !177
  %io45 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %addr_data46 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io45, i32 0, i32 7
  %9 = load i64, i64* %addr_data46, align 8, !tbaa !22
  %cmp47 = icmp ugt i64 %8, %9
  br i1 %cmp47, label %if.then48, label %if.end55

if.then48:                                        ; preds = %if.then43
  %start49 = getelementptr inbounds %struct.resource, %struct.resource* %call41, i32 0, i32 0
  %10 = load i64, i64* %start49, align 8, !tbaa !177
  %io50 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %addr_data51 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io50, i32 0, i32 7
  %11 = load i64, i64* %addr_data51, align 8, !tbaa !22
  %sub = sub i64 %10, %11
  %conv = trunc i64 %sub to i32
  %io52 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %regspacing53 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io52, i32 0, i32 3
  store i32 %conv, i32* %regspacing53, align 8, !tbaa !26
  br label %if.end55

if.end55:                                         ; preds = %if.then48, %if.then43, %if.end36
  %io56 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io56, i32 0, i32 4
  store i32 1, i32* %regsize, align 4, !tbaa !27
  %io57 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io57, i32 0, i32 5
  store i32 0, i32* %regshift, align 8, !tbaa !28
  %call58 = call i32 @acpi_evaluate_integer(i8* %call2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.63, i32 0, i32 0), %struct.acpi_object_list* null, i64* %tmp)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.else62, label %if.then60

if.then60:                                        ; preds = %if.end55
  %12 = load i64, i64* %tmp, align 8, !tbaa !101
  %conv61 = trunc i64 %12 to i32
  br label %if.end71.sink.split

if.else62:                                        ; preds = %if.end55
  %call64 = call i32 @platform_get_irq(%struct.platform_device* %dev, i32 0)
  %cmp65 = icmp sgt i32 %call64, 0
  br i1 %cmp65, label %if.end71.sink.split, label %if.end71

if.end71.sink.split:                              ; preds = %if.else62, %if.then60
  %call64.sink = phi i32 [ %conv61, %if.then60 ], [ %call64, %if.else62 ]
  %std_irq_setup.sink = phi i32 (%struct.smi_info*)* [ @acpi_gpe_irq_setup, %if.then60 ], [ @std_irq_setup, %if.else62 ]
  %irq68 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 25
  store i32 %call64.sink, i32* %irq68, align 4, !tbaa !29
  %irq_setup69 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 12
  store i32 (%struct.smi_info*)* %std_irq_setup.sink, i32 (%struct.smi_info*)** %irq_setup69, align 8, !tbaa !30
  br label %if.end71

if.end71:                                         ; preds = %if.end71.sink.split, %if.else62
  %dev72 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %dev, i32 0, i32 3
  %dev73 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 36
  store %struct.device* %dev72, %struct.device** %dev73, align 8, !tbaa !38
  %13 = bitcast %struct.smi_info* %call6 to i8*
  call void @platform_set_drvdata(%struct.platform_device* %dev, i8* %13)
  %dev74 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 36
  %14 = load %struct.device*, %struct.device** %dev74, align 8, !tbaa !38
  %io75 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %regsize76 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io75, i32 0, i32 4
  %15 = load i32, i32* %regsize76, align 4, !tbaa !27
  %io77 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 9
  %regspacing78 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io77, i32 0, i32 3
  %16 = load i32, i32* %regspacing78, align 8, !tbaa !26
  %irq79 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call6, i32 0, i32 25
  %17 = load i32, i32* %irq79, align 4, !tbaa !29
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %14, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.64, i32 0, i32 0), %struct.resource* %res.0, i32 %15, i32 %16, i32 %17)
  %call80 = call i32 @add_smi(%struct.smi_info* %call6)
  %tobool81 = icmp ne i32 %call80, 0
  br i1 %tobool81, label %if.then82, label %cleanup

if.then82:                                        ; preds = %if.end71
  %18 = bitcast %struct.smi_info* %call6 to i8*
  call void @kfree(i8* %18)
  br label %cleanup

err_free:                                         ; preds = %if.then34, %sw.default, %LeafBlock1, %if.then13
  %rv.0 = phi i32 [ -22, %if.then13 ], [ -22, %if.then34 ], [ -22, %sw.default ], [ -19, %LeafBlock1 ]
  %19 = bitcast %struct.smi_info* %call6 to i8*
  call void @kfree(i8* %19)
  br label %cleanup

cleanup:                                          ; preds = %err_free, %if.then82, %if.end71, %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ %rv.0, %err_free ], [ 0, %entry ], [ -19, %if.end ], [ -12, %if.end5 ], [ %call80, %if.then82 ], [ %call80, %if.end71 ]
  %20 = bitcast i64* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #7
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.acpi_device* @to_acpi_device_node(%struct.fwnode_handle* %fwnode) #3 {
entry:
  %call = call zeroext i1 @is_acpi_device_node(%struct.fwnode_handle* %fwnode)
  %0 = bitcast %struct.fwnode_handle* %fwnode to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.acpi_device*
  %cond = select i1 %call, %struct.acpi_device* %1, %struct.acpi_device* null
  ret %struct.acpi_device* %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @acpi_device_handle(%struct.acpi_device* %adev) #3 {
entry:
  %tobool = icmp ne %struct.acpi_device* %adev, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %handle = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %adev, i32 0, i32 1
  %0 = load i8*, i8** %handle, align 8, !tbaa !179
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i8* [ %0, %cond.true ], [ null, %entry ]
  ret i8* %cond
}

declare i32 @acpi_evaluate_integer(i8*, i8*, %struct.acpi_object_list*, i64*) #1

declare %struct.resource* @platform_get_resource(%struct.platform_device*, i32, i32) #1

declare i32 @platform_get_irq(%struct.platform_device*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @acpi_gpe_irq_setup(%struct.smi_info* %info) #0 {
entry:
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %0 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %irq1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %1 = load i32, i32* %irq1, align 4, !tbaa !29
  %2 = bitcast %struct.smi_info* %info to i8*
  %call = call i32 @acpi_install_gpe_handler()
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 36
  %3 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  %irq3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %4 = load i32, i32* %irq3, align 4, !tbaa !29
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %3, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.65, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i32 %4)
  %irq4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  store i32 0, i32* %irq4, align 4, !tbaa !29
  br label %cleanup

if.else:                                          ; preds = %if.end
  %irq_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 13
  store void (%struct.smi_info*)* @acpi_gpe_irq_cleanup, void (%struct.smi_info*)** %irq_cleanup, align 8, !tbaa !42
  %dev5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 36
  %5 = load %struct.device*, %struct.device** %dev5, align 8, !tbaa !38
  %irq6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %6 = load i32, i32* %irq6, align 4, !tbaa !29
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %5, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.66, i32 0, i32 0), i32 %6)
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then2, %entry
  %retval.0 = phi i32 [ -22, %if.then2 ], [ 0, %if.else ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @platform_set_drvdata(%struct.platform_device* %pdev, i8* %data) #3 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_acpi_gpe(i8* %gpe_device, i32 %gpe_number, i8* %context) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i8* %context to %struct.smi_info*
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %si_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 40
  %arrayidx = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats, i64 0, i64 3
  call void @atomic_inc(%struct.atomic_t* %arrayidx)
  %call5 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 0)
  %si_lock6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock6, i64 %call2)
  ret i32 1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @acpi_install_gpe_handler() #3 {
entry:
  ret i32 28
}

; Function Attrs: nounwind uwtable
define internal void @acpi_gpe_irq_cleanup(%struct.smi_info* %info) #0 {
entry:
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %0 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %irq1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %1 = load i32, i32* %irq1, align 4, !tbaa !29
  call void @acpi_remove_gpe_handler()
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @acpi_remove_gpe_handler() #3 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @is_acpi_device_node(%struct.fwnode_handle* %fwnode) #3 {
entry:
  %0 = bitcast %struct.fwnode_handle* %fwnode to i8*
  %call = call zeroext i1 @IS_ERR_OR_NULL(i8* %0)
  br i1 %call, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %type = getelementptr inbounds %struct.fwnode_handle, %struct.fwnode_handle* %fwnode, i32 0, i32 0
  %1 = load i32, i32* %type, align 8, !tbaa !195
  %cmp = icmp eq i32 %1, 2
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  ret i1 %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR_OR_NULL(i8* %ptr) #3 {
entry:
  %tobool = icmp ne i8* %ptr, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot5 = xor i1 %cmp, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool11 = icmp ne i64 %expval10, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool11, %lor.rhs ]
  ret i1 %3
}

declare %struct.of_device_id* @of_match_device(%struct.of_device_id*, %struct.device*) #1

declare zeroext i1 @of_device_is_available(%struct.device_node*) #1

declare i32 @of_address_to_resource(%struct.device_node*, i32, %struct.resource*) #1

declare i8* @of_get_property(%struct.device_node*, i8*, i32*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @__be32_to_cpup(i32* %p) #4 {
entry:
  %call = call i32 @__swab32p(i32* %p)
  ret i32 %call
}

declare i32 @irq_of_parse_and_map(%struct.device_node*, i32) #1

declare void @__dynamic_dev_dbg(%struct._ddebug*, %struct.device*, i8*, ...) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @__swab32p(i32* %p) #4 {
entry:
  %0 = load i32, i32* %p, align 4, !tbaa !2
  %call = call i32 @__fswab32(i32 %0) #5
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32(i32 %val) #6 {
entry:
  %call = call i32 @__arch_swab32(i32 %val) #5
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32(i32 %val) #6 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #5, !srcloc !196
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @is_new_interface(%struct.smi_info* %info) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @smi_infos, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !7
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr19 = getelementptr inbounds i8, i8* %1, i64 -496
  %2 = bitcast i8* %add.ptr19 to %struct.smi_info*
  %link = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 42
  %cmp = icmp ne %struct.list_head* %link, @smi_infos
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 9
  %addr_type = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 6
  %3 = load i32, i32* %addr_type, align 4, !tbaa !23
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %addr_type2 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 6
  %4 = load i32, i32* %addr_type2, align 4, !tbaa !23
  %cmp3 = icmp ne i32 %3, %4
  br i1 %cmp3, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %io4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io4, i32 0, i32 7
  %5 = load i64, i64* %addr_data, align 8, !tbaa !22
  %io5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %addr_data6 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io5, i32 0, i32 7
  %6 = load i64, i64* %addr_data6, align 8, !tbaa !22
  %cmp7 = icmp eq i64 %5, %6
  br i1 %cmp7, label %if.then8, label %for.inc

if.then8:                                         ; preds = %if.end
  %slave_addr = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 39
  %7 = load i8, i8* %slave_addr, align 1, !tbaa !31
  %conv = zext i8 %7 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %if.then8
  %slave_addr9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 39
  %8 = load i8, i8* %slave_addr9, align 1, !tbaa !31
  %tobool10 = icmp ne i8 %8, 0
  br i1 %tobool10, label %cleanup, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %slave_addr12 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 39
  %9 = load i8, i8* %slave_addr12, align 1, !tbaa !31
  %slave_addr13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 39
  store i8 %9, i8* %slave_addr13, align 1, !tbaa !31
  br label %cleanup

for.inc:                                          ; preds = %if.end, %for.body
  %link17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 42
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %link17, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %if.then11, %land.lhs.true, %if.then8, %for.cond
  %retval.0 = phi i32 [ 0, %if.then11 ], [ 0, %land.lhs.true ], [ 0, %if.then8 ], [ 1, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !82
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  %__u = alloca %union.anon.71, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !82
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !32
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !82
  %0 = bitcast %union.anon.71* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %__val = bitcast %union.anon.71* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !6
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.71* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val5 = bitcast %union.anon.71* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val5, align 8, !tbaa !6
  %3 = bitcast %union.anon.71* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_add_valid(%struct.list_head*, %struct.list_head*, %struct.list_head*) #1

; Function Attrs: nounwind uwtable
define internal i32 @si_bt_irq_handler(i32 %irq, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.smi_info*
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 9
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !40
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 9
  call void %1(%struct.si_sm_io* %io1, i32 2, i8 zeroext 3)
  %call = call i32 @si_irq_handler(i32 %irq, i8* %data)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #3 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @si_irq_handler(i32 %irq, i8* %data) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i8* %data to %struct.smi_info*
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %si_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 40
  %arrayidx = getelementptr inbounds [11 x %struct.atomic_t], [11 x %struct.atomic_t]* %stats, i64 0, i64 3
  call void @atomic_inc(%struct.atomic_t* %arrayidx)
  %call5 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 0)
  %si_lock6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock6, i64 %call2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @std_irq_cleanup(%struct.smi_info* %info) #0 {
entry:
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 4
  %0 = load i32, i32* %si_type, align 8, !tbaa !21
  %cmp = icmp eq i32 %0, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !40
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  call void %1(%struct.si_sm_io* %io1, i32 2, i8 zeroext 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 25
  %2 = load i32, i32* %irq, align 4, !tbaa !29
  %3 = bitcast %struct.smi_info* %info to i8*
  call void @free_irq(i32 %2, i8* %3)
  ret void
}

declare void @free_irq(i32, i8*) #1

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @port_cleanup(%struct.smi_info* %info) #0 {
entry:
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !22
  %conv = trunc i64 %0 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %idx.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 14
  %1 = load i32, i32* %io_size, align 8, !tbaa !41
  %cmp = icmp ult i32 %idx.0, %1
  br i1 %cmp, label %for.body, label %if.end

for.body:                                         ; preds = %for.cond
  %io2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io2, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !26
  %mul = mul nsw i32 %idx.0, %2
  %add = add i32 %conv, %mul
  %conv3 = zext i32 %add to i64
  %io4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io4, i32 0, i32 4
  %3 = load i32, i32* %regsize, align 4, !tbaa !27
  %conv5 = sext i32 %3 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv3, i64 %conv5)
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @port_inw(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !197
  %conv = trunc i64 %0 to i32
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %1
  %add = add i32 %conv, %mul
  %call = call zeroext i16 @inw(i32 %add)
  %conv1 = zext i16 %call to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %2 = load i32, i32* %regshift, align 8, !tbaa !199
  %shr = ashr i32 %conv1, %2
  %and = and i32 %shr, 255
  %conv2 = trunc i32 %and to i8
  ret i8 %conv2
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @port_inl(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !197
  %conv = trunc i64 %0 to i32
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %1
  %add = add i32 %conv, %mul
  %call = call i32 @inl(i32 %add)
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %2 = load i32, i32* %regshift, align 8, !tbaa !199
  %shr = lshr i32 %call, %2
  %and = and i32 %shr, 255
  %conv1 = trunc i32 %and to i8
  ret i8 %conv1
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @port_inb(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !197
  %conv = trunc i64 %0 to i32
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %1
  %add = add i32 %conv, %mul
  %call = call zeroext i8 @inb(i32 %add)
  ret i8 %call
}

; Function Attrs: nounwind uwtable
define internal void @port_outw(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !197
  %conv = trunc i64 %0 to i32
  %conv1 = zext i8 %b to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %1 = load i32, i32* %regshift, align 8, !tbaa !199
  %shl = shl i32 %conv1, %1
  %conv2 = trunc i32 %shl to i16
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %2
  %add = add i32 %conv, %mul
  call void @outw(i16 zeroext %conv2, i32 %add)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @port_outl(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !197
  %conv = trunc i64 %0 to i32
  %conv1 = zext i8 %b to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %1 = load i32, i32* %regshift, align 8, !tbaa !199
  %shl = shl i32 %conv1, %1
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %2
  %add = add i32 %conv, %mul
  call void @outl(i32 %shl, i32 %add)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @port_outb(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !197
  %conv = trunc i64 %0 to i32
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %1
  %add = add i32 %conv, %mul
  call void @outb(i8 zeroext %b, i32 %add)
  ret void
}

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #1

declare void @__release_region(%struct.resource*, i64, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #3 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #7, !srcloc !200
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outl(i32 %value, i32 %port) #3 {
entry:
  call void asm sideeffect "outl $0, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %value, i32 %port) #7, !srcloc !201
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outw(i16 zeroext %value, i32 %port) #3 {
entry:
  call void asm sideeffect "outw ${0:w}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i16 %value, i32 %port) #7, !srcloc !202
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #3 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #7, !srcloc !203
  ret i8 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @inl(i32 %port) #3 {
entry:
  %0 = call i32 asm sideeffect "inl ${1:w}, $0", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #7, !srcloc !204
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @inw(i32 %port) #3 {
entry:
  %0 = call i16 asm sideeffect "inw ${1:w}, ${0:w}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #7, !srcloc !205
  ret i16 %0
}

; Function Attrs: nounwind uwtable
define internal void @mem_cleanup(%struct.smi_info* %info) #0 {
entry:
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !25
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %addr2 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 2
  %1 = load i8*, i8** %addr2, align 8, !tbaa !25
  call void @iounmap(i8* %1)
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 14
  %2 = load i32, i32* %io_size, align 8, !tbaa !41
  call void @mem_region_cleanup(%struct.smi_info* %info, i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @intf_mem_inw(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !206
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call zeroext i16 @readw(i8* %add.ptr)
  %conv = zext i16 %call to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %2 = load i32, i32* %regshift, align 8, !tbaa !199
  %shr = ashr i32 %conv, %2
  %and = and i32 %shr, 255
  %conv1 = trunc i32 %and to i8
  ret i8 %conv1
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @intf_mem_inl(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !206
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i32 @readl(i8* %add.ptr)
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %2 = load i32, i32* %regshift, align 8, !tbaa !199
  %shr = lshr i32 %call, %2
  %and = and i32 %shr, 255
  %conv = trunc i32 %and to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @mem_inq(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !206
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i64 @readq(i8* %add.ptr)
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %2 = load i32, i32* %regshift, align 8, !tbaa !199
  %sh_prom = zext i32 %2 to i64
  %shr = lshr i64 %call, %sh_prom
  %and = and i64 %shr, 255
  %conv = trunc i64 %and to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @intf_mem_inb(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !206
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call zeroext i8 @readb(i8* %add.ptr)
  ret i8 %call
}

; Function Attrs: nounwind uwtable
define internal void @intf_mem_outw(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %conv = zext i8 %b to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %0 = load i32, i32* %regshift, align 8, !tbaa !199
  %shl = shl i32 %conv, %0
  %conv1 = trunc i32 %shl to i8
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %1 = load i8*, i8** %addr, align 8, !tbaa !206
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %2
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %1, i64 %idx.ext
  call void @writeb(i8 zeroext %conv1, i8* %add.ptr)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @intf_mem_outl(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %conv = zext i8 %b to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %0 = load i32, i32* %regshift, align 8, !tbaa !199
  %shl = shl i32 %conv, %0
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %1 = load i8*, i8** %addr, align 8, !tbaa !206
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %2
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %1, i64 %idx.ext
  call void @writel(i32 %shl, i8* %add.ptr)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mem_outq(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %conv = zext i8 %b to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %0 = load i32, i32* %regshift, align 8, !tbaa !199
  %shl = shl i32 %conv, %0
  %conv1 = sext i32 %shl to i64
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %1 = load i8*, i8** %addr, align 8, !tbaa !206
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %2
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %1, i64 %idx.ext
  call void @writeq(i64 %conv1, i8* %add.ptr)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @intf_mem_outb(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !206
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !198
  %mul = mul i32 %offset, %1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  call void @writeb(i8 zeroext %b, i8* %add.ptr)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mem_region_cleanup(%struct.smi_info* %info, i32 %num) #0 {
entry:
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !22
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %idx.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %idx.0, %num
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !26
  %mul = mul nsw i32 %idx.0, %1
  %conv = sext i32 %mul to i64
  %add = add i64 %0, %conv
  %io2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io2, i32 0, i32 4
  %2 = load i32, i32* %regsize, align 4, !tbaa !27
  %conv3 = sext i32 %2 to i64
  call void @__release_region(%struct.resource* @iomem_resource, i64 %add, i64 %conv3)
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ioremap(i64 %offset, i64 %size) #3 {
entry:
  %call = call i8* @ioremap_nocache(i64 %offset, i64 %size)
  ret i8* %call
}

declare i8* @ioremap_nocache(i64, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @writeb(i8 zeroext %val, i8* %addr) #3 {
entry:
  call void asm sideeffect "movb $0,$1", "q,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i8 %val, i8* %addr) #7, !srcloc !207
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @writeq(i64 %val, i8* %addr) #3 {
entry:
  %0 = bitcast i8* %addr to i64*
  call void asm sideeffect "movq $0,$1", "r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %val, i64* %0) #7, !srcloc !208
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @writel(i32 %val, i8* %addr) #3 {
entry:
  %0 = bitcast i8* %addr to i32*
  call void asm sideeffect "movl $0,$1", "r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 %val, i32* %0) #7, !srcloc !209
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @readb(i8* %addr) #3 {
entry:
  %0 = call i8 asm sideeffect "movb $1,$0", "=q,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i8* %addr) #7, !srcloc !210
  ret i8 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @readq(i8* %addr) #3 {
entry:
  %0 = bitcast i8* %addr to i64*
  %1 = call i64 asm sideeffect "movq $1,$0", "=r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %0) #7, !srcloc !211
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @readl(i8* %addr) #3 {
entry:
  %0 = bitcast i8* %addr to i32*
  %1 = call i32 asm sideeffect "movl $1,$0", "=r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %0) #7, !srcloc !212
  ret i32 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @readw(i8* %addr) #3 {
entry:
  %0 = bitcast i8* %addr to i16*
  %1 = call i16 asm sideeffect "movw $1,$0", "=r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i16* %0) #7, !srcloc !213
  ret i16 %1
}

declare void @iounmap(i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #1

declare i32 @strcmp(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @init_ipmi_si() #0 {
entry:
  %0 = load i32, i32* @initialized, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  store i32 1, i32* @initialized, align 4, !tbaa !2
  %1 = load i8, i8* @si_tryplatform, align 1, !tbaa !97, !range !79
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %call = call i32 @__platform_driver_register(%struct.platform_driver* @ipmi_driver, %struct.module* @__this_module)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.then2
  %call5 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.99, i32 0, i32 0), i32 %call)
  br label %cleanup

if.end7:                                          ; preds = %if.then2, %if.end
  %2 = load i8, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @si_type_str, i32 0, i32 0), align 1, !tbaa !6
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then9, label %if.end19

if.then9:                                         ; preds = %if.end7
  br label %for.cond

for.cond:                                         ; preds = %if.then17, %if.then9
  %str.0 = phi i8* [ getelementptr inbounds ([30 x i8], [30 x i8]* @si_type_str, i32 0, i32 0), %if.then9 ], [ %incdec.ptr, %if.then17 ]
  %i.0 = phi i32 [ 0, %if.then9 ], [ %inc, %if.then17 ]
  %cmp10 = icmp slt i32 %i.0, 4
  br i1 %cmp10, label %land.rhs, label %if.end19

land.rhs:                                         ; preds = %for.cond
  %3 = load i8, i8* %str.0, align 1, !tbaa !6
  %conv12 = sext i8 %3 to i32
  %cmp13 = icmp ne i32 %conv12, 0
  br i1 %cmp13, label %for.body, label %if.end19

for.body:                                         ; preds = %land.rhs
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i8*], [4 x i8*]* @si_type, i64 0, i64 %idxprom
  store i8* %str.0, i8** %arrayidx, align 8, !tbaa !7
  %call15 = call i8* @strchr(i8* %str.0, i32 44)
  %tobool16 = icmp ne i8* %call15, null
  br i1 %tobool16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %for.body
  store i8 0, i8* %call15, align 1, !tbaa !6
  %incdec.ptr = getelementptr inbounds i8, i8* %call15, i32 1
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end19:                                         ; preds = %for.body, %land.rhs, %for.cond, %if.end7
  %call20 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.100, i32 0, i32 0))
  %call21 = call i32 @hardcode_find_bmc()
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.end24, label %cleanup

if.end24:                                         ; preds = %if.end19
  %4 = load i8, i8* @si_trypci, align 1, !tbaa !97, !range !79
  %tobool25 = trunc i8 %4 to i1
  br i1 %tobool25, label %if.then26, label %if.end33

if.then26:                                        ; preds = %if.end24
  %call27 = call i32 @__pci_register_driver(%struct.pci_driver* @ipmi_pci_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0))
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.then29, label %if.else31

if.then29:                                        ; preds = %if.then26
  %call30 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.101, i32 0, i32 0), i32 %call27)
  br label %if.end33

if.else31:                                        ; preds = %if.then26
  store i8 1, i8* @pci_registered, align 1, !tbaa !97
  br label %if.end33

if.end33:                                         ; preds = %if.else31, %if.then29, %if.end24
  %5 = load i8, i8* @si_trydmi, align 1, !tbaa !97, !range !79
  %tobool34 = trunc i8 %5 to i1
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end33
  call void @dmi_find_bmc()
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.end33
  %6 = load i8, i8* @si_tryacpi, align 1, !tbaa !97, !range !79
  %tobool37 = trunc i8 %6 to i1
  br i1 %tobool37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end36
  call void @spmi_find_bmc()
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.end36
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc55, %if.end39
  %next.sink = phi %struct.list_head** [ %next, %for.inc55 ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @smi_infos, i32 0, i32 0), %if.end39 ]
  %type.0 = phi i32 [ 0, %if.end39 ], [ %type.2, %for.inc55 ]
  %7 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !7
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr59 = getelementptr inbounds i8, i8* %8, i64 -496
  %9 = bitcast i8* %add.ptr59 to %struct.smi_info*
  %link = getelementptr inbounds %struct.smi_info, %struct.smi_info* %9, i32 0, i32 42
  %cmp41 = icmp ne %struct.list_head* %link, @smi_infos
  br i1 %cmp41, label %for.body43, label %for.end60

for.body43:                                       ; preds = %for.cond40
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %9, i32 0, i32 25
  %10 = load i32, i32* %irq, align 4, !tbaa !29
  %tobool44 = icmp ne i32 %10, 0
  br i1 %tobool44, label %land.lhs.true, label %for.inc55

land.lhs.true:                                    ; preds = %for.body43
  %tobool45 = icmp ne i32 %type.0, 0
  br i1 %tobool45, label %lor.lhs.false, label %if.then48

lor.lhs.false:                                    ; preds = %land.lhs.true
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %9, i32 0, i32 15
  %11 = load i32, i32* %addr_source, align 4, !tbaa !9
  %cmp46 = icmp eq i32 %11, %type.0
  br i1 %cmp46, label %if.then48, label %for.inc55

if.then48:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %call49 = call i32 @try_smi_init(%struct.smi_info* %9)
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %for.inc55, label %if.then51

if.then51:                                        ; preds = %if.then48
  %addr_source52 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %9, i32 0, i32 15
  %12 = load i32, i32* %addr_source52, align 4, !tbaa !9
  br label %for.inc55

for.inc55:                                        ; preds = %if.then51, %if.then48, %lor.lhs.false, %for.body43
  %type.2 = phi i32 [ %type.0, %lor.lhs.false ], [ %type.0, %for.body43 ], [ %type.0, %if.then48 ], [ %12, %if.then51 ]
  %link57 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %9, i32 0, i32 42
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %link57, i32 0, i32 0
  br label %for.cond40

for.end60:                                        ; preds = %for.cond40
  %tobool61 = icmp ne i32 %type.0, 0
  br i1 %tobool61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %for.end60
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  br label %cleanup

if.end63:                                         ; preds = %for.end60
  br label %for.cond67

for.cond67:                                       ; preds = %for.inc87, %if.end63
  %next90.sink = phi %struct.list_head** [ %next90, %for.inc87 ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @smi_infos, i32 0, i32 0), %if.end63 ]
  %type.3 = phi i32 [ %type.0, %if.end63 ], [ %type.5, %for.inc87 ]
  %13 = load %struct.list_head*, %struct.list_head** %next90.sink, align 8, !tbaa !7
  %14 = bitcast %struct.list_head* %13 to i8*
  %add.ptr92 = getelementptr inbounds i8, i8* %14, i64 -496
  %15 = bitcast i8* %add.ptr92 to %struct.smi_info*
  %link68 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %15, i32 0, i32 42
  %cmp69 = icmp ne %struct.list_head* %link68, @smi_infos
  br i1 %cmp69, label %for.body71, label %for.end93

for.body71:                                       ; preds = %for.cond67
  %irq72 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %15, i32 0, i32 25
  %16 = load i32, i32* %irq72, align 4, !tbaa !29
  %tobool73 = icmp ne i32 %16, 0
  br i1 %tobool73, label %for.inc87, label %land.lhs.true74

land.lhs.true74:                                  ; preds = %for.body71
  %tobool75 = icmp ne i32 %type.3, 0
  br i1 %tobool75, label %lor.lhs.false76, label %if.then80

lor.lhs.false76:                                  ; preds = %land.lhs.true74
  %addr_source77 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %15, i32 0, i32 15
  %17 = load i32, i32* %addr_source77, align 4, !tbaa !9
  %cmp78 = icmp eq i32 %17, %type.3
  br i1 %cmp78, label %if.then80, label %for.inc87

if.then80:                                        ; preds = %lor.lhs.false76, %land.lhs.true74
  %call81 = call i32 @try_smi_init(%struct.smi_info* %15)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %for.inc87, label %if.then83

if.then83:                                        ; preds = %if.then80
  %addr_source84 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %15, i32 0, i32 15
  %18 = load i32, i32* %addr_source84, align 4, !tbaa !9
  br label %for.inc87

for.inc87:                                        ; preds = %if.then83, %if.then80, %lor.lhs.false76, %for.body71
  %type.5 = phi i32 [ %type.3, %for.body71 ], [ %type.3, %lor.lhs.false76 ], [ %type.3, %if.then80 ], [ %18, %if.then83 ]
  %link89 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %15, i32 0, i32 42
  %next90 = getelementptr inbounds %struct.list_head, %struct.list_head* %link89, i32 0, i32 0
  br label %for.cond67

for.end93:                                        ; preds = %for.cond67
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  %tobool94 = icmp ne i32 %type.3, 0
  br i1 %tobool94, label %cleanup, label %if.end96

if.end96:                                         ; preds = %for.end93
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  %19 = load i8, i8* @unload_when_empty, align 1, !tbaa !97, !range !79
  %tobool97 = trunc i8 %19 to i1
  br i1 %tobool97, label %land.lhs.true99, label %if.else104

land.lhs.true99:                                  ; preds = %if.end96
  %call100 = call i32 @list_empty(%struct.list_head* @smi_infos)
  %tobool101 = icmp ne i32 %call100, 0
  br i1 %tobool101, label %if.then102, label %if.else104

if.then102:                                       ; preds = %land.lhs.true99
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  call void @cleanup_ipmi_si()
  %call103 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.102, i32 0, i32 0))
  br label %cleanup

if.else104:                                       ; preds = %land.lhs.true99, %if.end96
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  br label %cleanup

cleanup:                                          ; preds = %if.else104, %if.then102, %for.end93, %if.then62, %if.end19, %if.then4, %entry
  %retval.0 = phi i32 [ %call, %if.then4 ], [ 0, %if.then62 ], [ -19, %if.then102 ], [ 0, %if.else104 ], [ 0, %entry ], [ 0, %if.end19 ], [ 0, %for.end93 ]
  ret i32 %retval.0
}

declare i32 @__platform_driver_register(%struct.platform_driver*, %struct.module*) #1

; Function Attrs: nounwind uwtable
define internal i32 @hardcode_find_bmc() #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  br label %if.end

if.end:                                           ; preds = %for.cond
  %call = call %struct.smi_info* @smi_info_alloc()
  br label %if.end79

if.end79:                                         ; preds = %if.end
  %idxprom83 = sext i32 %i.0 to i64
  %arrayidx84 = getelementptr inbounds [4 x i32], [4 x i32]* @irqs, i64 0, i64 %idxprom83
  %0 = load i32, i32* %arrayidx84, align 4, !tbaa !2
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 25
  store i32 %0, i32* %irq, align 4, !tbaa !29
  br label %for.inc

for.inc:                                          ; preds = %if.end79
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; No predecessors!
  ret i32 0
}

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @dmi_find_bmc() #0 {
entry:
  %data = alloca %struct.dmi_ipmi_data, align 8
  %0 = bitcast %struct.dmi_ipmi_data* %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #7
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %dev.0 = phi %struct.dmi_device* [ null, %entry ], [ %call, %if.end ]
  %call = call %struct.dmi_device* @dmi_find_device(i32 -1, i8* null, %struct.dmi_device* %dev.0)
  %tobool = icmp ne %struct.dmi_device* %call, null
  %1 = bitcast %struct.dmi_ipmi_data* %data to i8*
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call1 = call i8* @__memset(i8* %1, i32 0, i64 24)
  %device_data = getelementptr inbounds %struct.dmi_device, %struct.dmi_device* %call, i32 0, i32 3
  %2 = load i8*, i8** %device_data, align 8, !tbaa !214
  %3 = bitcast i8* %2 to %struct.dmi_header*
  %call2 = call i32 @decode_dmi(%struct.dmi_header* %3, %struct.dmi_ipmi_data* %data)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  call void @try_init_dmi(%struct.dmi_ipmi_data* %data)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %1) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @spmi_find_bmc() #0 {
entry:
  %spmi = alloca %struct.SPMITable*, align 8
  %0 = bitcast %struct.SPMITable** %spmi to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = load i32, i32* @acpi_disabled, align 4, !tbaa !2
  %tobool = icmp ne i32 %1, 0
  %2 = load i32, i32* @acpi_failure, align 4
  %tobool1 = icmp ne i32 %2, 0
  %or.cond = or i1 %tobool, %tobool1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end5, %if.end3
  %i.0 = phi i32 [ 0, %if.end3 ], [ %inc, %if.end5 ]
  %add = add nsw i32 %i.0, 1
  %3 = bitcast %struct.SPMITable** %spmi to %struct.acpi_table_header**
  %call = call i32 @acpi_get_table(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.115, i32 0, i32 0), i32 %add, %struct.acpi_table_header** %3)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %for.cond
  %4 = load %struct.SPMITable*, %struct.SPMITable** %spmi, align 8, !tbaa !7
  call void @try_init_spmi(%struct.SPMITable* %4)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %entry
  %5 = bitcast %struct.SPMITable** %spmi to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #3 {
entry:
  %__u = alloca %union.anon.71, align 8
  %0 = bitcast %union.anon.71* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.71* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.71* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val, align 8, !tbaa !6
  %3 = bitcast %union.anon.71* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %cmp = icmp eq %struct.list_head* %2, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @cleanup_ipmi_si() #0 {
entry:
  %0 = load i32, i32* @initialized, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %1 = load i8, i8* @pci_registered, align 1, !tbaa !97, !range !79
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void @pci_unregister_driver(%struct.pci_driver* @ipmi_pci_driver)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  call void @platform_driver_unregister(%struct.platform_driver* @ipmi_driver)
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  %2 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.list_head, %struct.list_head* @smi_infos, i32 0, i32 0), align 8, !tbaa !32
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -496
  %4 = bitcast i8* %add.ptr to %struct.smi_info*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end3
  %.sink = phi %struct.smi_info* [ %7, %for.body ], [ %4, %if.end3 ]
  %e.0 = phi %struct.smi_info* [ %4, %if.end3 ], [ %7, %for.body ]
  %link9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %.sink, i32 0, i32 42
  %next10 = getelementptr inbounds %struct.list_head, %struct.list_head* %link9, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next10, align 8, !tbaa !33
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr12 = getelementptr inbounds i8, i8* %6, i64 -496
  %7 = bitcast i8* %add.ptr12 to %struct.smi_info*
  %link7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %e.0, i32 0, i32 42
  %cmp = icmp ne %struct.list_head* %link7, @smi_infos
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @cleanup_one_si(%struct.smi_info* %e.0)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %entry
  %cleanup.dest.slot.0 = phi i32 [ 0, %for.end ], [ 1, %entry ]
  ret void
}

declare void @pci_unregister_driver(%struct.pci_driver*) #1

declare void @platform_driver_unregister(%struct.platform_driver*) #1

declare i32 @acpi_get_table(i8*, i32, %struct.acpi_table_header**) #1

; Function Attrs: nounwind uwtable
define internal void @try_init_spmi(%struct.SPMITable* %spmi) #0 {
entry:
  %IPMIlegacy = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 10
  %0 = load i8, i8* %IPMIlegacy, align 1, !tbaa !216
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %IPMIlegacy2 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 10
  %1 = load i8, i8* %IPMIlegacy2, align 1, !tbaa !216
  %conv3 = zext i8 %1 to i32
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.116, i32 0, i32 0), i32 %conv3)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call4 = call %struct.smi_info* @smi_info_alloc()
  %tobool = icmp ne %struct.smi_info* %call4, null
  br i1 %tobool, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.117, i32 0, i32 0))
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 15
  store i32 3, i32* %addr_source, align 4, !tbaa !9
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.118, i32 0, i32 0))
  %InterfaceType = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 9
  %2 = load i8, i8* %InterfaceType, align 4, !tbaa !219
  %conv9 = zext i8 %2 to i32
  %Pivot6 = icmp slt i32 %conv9, 3
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.end7
  %Pivot4 = icmp slt i32 %conv9, 4
  br i1 %Pivot4, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %conv9, 4
  br i1 %SwitchLeaf2, label %sw.bb14, label %sw.default

NodeBlock:                                        ; preds = %if.end7
  %Pivot = icmp slt i32 %conv9, 2
  br i1 %Pivot, label %LeafBlock, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv9, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.bb14:                                          ; preds = %LeafBlock1
  %3 = bitcast %struct.smi_info* %call4 to i8*
  call void @kfree(i8* %3)
  br label %cleanup

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %InterfaceType15 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 9
  %4 = load i8, i8* %InterfaceType15, align 4, !tbaa !219
  %conv16 = zext i8 %4 to i32
  %call17 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.119, i32 0, i32 0), i32 %conv16)
  %5 = bitcast %struct.smi_info* %call4 to i8*
  call void @kfree(i8* %5)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %NodeBlock, %NodeBlock3
  %.sink = phi i32 [ 1, %NodeBlock ], [ 2, %NodeBlock3 ], [ 0, %LeafBlock ]
  %si_type13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 4
  store i32 %.sink, i32* %si_type13, align 8, !tbaa !21
  %InterruptType = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 12
  %6 = load i8, i8* %InterruptType, align 4, !tbaa !220
  %conv18 = zext i8 %6 to i32
  %and = and i32 %conv18, 1
  %tobool19 = icmp ne i32 %and, 0
  br i1 %tobool19, label %if.then20, label %if.else

if.then20:                                        ; preds = %sw.epilog
  %GPE = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 13
  %7 = load i8, i8* %GPE, align 1, !tbaa !221
  %conv21 = zext i8 %7 to i32
  br label %if.end33

if.else:                                          ; preds = %sw.epilog
  %InterruptType22 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 12
  %8 = load i8, i8* %InterruptType22, align 4, !tbaa !220
  %conv23 = zext i8 %8 to i32
  %and24 = and i32 %conv23, 2
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then26, label %if.end33

if.then26:                                        ; preds = %if.else
  %GlobalSystemInterrupt = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 15
  %9 = load i32, i32* %GlobalSystemInterrupt, align 4, !tbaa !222
  br label %if.end33

if.end33:                                         ; preds = %if.then26, %if.else, %if.then20
  %.sink8.sink = phi i32 [ %conv21, %if.then20 ], [ %9, %if.then26 ], [ 0, %if.else ]
  %.sink7.sink = phi i32 (%struct.smi_info*)* [ @acpi_gpe_irq_setup, %if.then20 ], [ @std_irq_setup, %if.then26 ], [ null, %if.else ]
  %irq30 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 25
  store i32 %.sink8.sink, i32* %irq30, align 4, !tbaa !29
  %irq_setup31 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 12
  store i32 (%struct.smi_info*)* %.sink7.sink, i32 (%struct.smi_info*)** %irq_setup31, align 8, !tbaa !30
  %addr = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %bit_width = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr, i32 0, i32 1
  %10 = load i8, i8* %bit_width, align 1, !tbaa !223
  %tobool34 = icmp ne i8 %10, 0
  br i1 %tobool34, label %if.then35, label %if.end42

if.then35:                                        ; preds = %if.end33
  %addr36 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %bit_width37 = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr36, i32 0, i32 1
  %11 = load i8, i8* %bit_width37, align 1, !tbaa !223
  %conv38 = zext i8 %11 to i32
  %div = sdiv i32 %conv38, 8
  br label %if.end42

if.end42:                                         ; preds = %if.then35, %if.end33
  %.sink9 = phi i32 [ %div, %if.then35 ], [ 1, %if.end33 ]
  %io40 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 9
  %regspacing41 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io40, i32 0, i32 3
  store i32 %.sink9, i32* %regspacing41, align 8, !tbaa !26
  %io43 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 9
  %regspacing44 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io43, i32 0, i32 3
  %12 = load i32, i32* %regspacing44, align 8, !tbaa !26
  %io45 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 9
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io45, i32 0, i32 4
  store i32 %12, i32* %regsize, align 4, !tbaa !27
  %addr46 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %bit_offset = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr46, i32 0, i32 2
  %13 = load i8, i8* %bit_offset, align 2, !tbaa !224
  %conv47 = zext i8 %13 to i32
  %io48 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 9
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io48, i32 0, i32 5
  store i32 %conv47, i32* %regshift, align 8, !tbaa !28
  %addr49 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %space_id = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr49, i32 0, i32 0
  %14 = load i8, i8* %space_id, align 4, !tbaa !225
  %conv50 = zext i8 %14 to i32
  %cmp51 = icmp eq i32 %conv50, 0
  br i1 %cmp51, label %if.end68, label %if.else55

if.else55:                                        ; preds = %if.end42
  %addr56 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %space_id57 = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr56, i32 0, i32 0
  %15 = load i8, i8* %space_id57, align 4, !tbaa !225
  %conv58 = zext i8 %15 to i32
  %cmp59 = icmp eq i32 %conv58, 1
  br i1 %cmp59, label %if.end68, label %if.else65

if.else65:                                        ; preds = %if.else55
  %16 = bitcast %struct.smi_info* %call4 to i8*
  call void @kfree(i8* %16)
  %call66 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.120, i32 0, i32 0))
  br label %cleanup

if.end68:                                         ; preds = %if.else55, %if.end42
  %port_setup.sink = phi i32 (%struct.smi_info*)* [ @port_setup, %if.else55 ], [ @mem_setup, %if.end42 ]
  %.sink10 = phi i32 [ 0, %if.else55 ], [ 1, %if.end42 ]
  %io_setup62 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 10
  store i32 (%struct.smi_info*)* %port_setup.sink, i32 (%struct.smi_info*)** %io_setup62, align 8, !tbaa !24
  %io63 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 9
  %addr_type64 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io63, i32 0, i32 6
  store i32 %.sink10, i32* %addr_type64, align 4, !tbaa !23
  %addr69 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %address = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr69, i32 0, i32 4
  %17 = load i64, i64* %address, align 4, !tbaa !226
  %io70 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io70, i32 0, i32 7
  store i64 %17, i64* %addr_data, align 8, !tbaa !22
  %io71 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 9
  %addr_type72 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io71, i32 0, i32 6
  %18 = load i32, i32* %addr_type72, align 4, !tbaa !23
  %cmp73 = icmp eq i32 %18, 0
  %19 = zext i1 %cmp73 to i64
  %cond = select i1 %cmp73, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.114, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0)
  %io75 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 9
  %addr_data76 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io75, i32 0, i32 7
  %20 = load i64, i64* %addr_data76, align 8, !tbaa !22
  %io77 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 9
  %regsize78 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io77, i32 0, i32 4
  %21 = load i32, i32* %regsize78, align 4, !tbaa !27
  %io79 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 9
  %regspacing80 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io79, i32 0, i32 3
  %22 = load i32, i32* %regspacing80, align 8, !tbaa !26
  %irq81 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call4, i32 0, i32 25
  %23 = load i32, i32* %irq81, align 4, !tbaa !29
  %call82 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.121, i32 0, i32 0), i8* %cond, i64 %20, i32 %21, i32 %22, i32 %23)
  %call83 = call i32 @add_smi(%struct.smi_info* %call4)
  %tobool84 = icmp ne i32 %call83, 0
  br i1 %tobool84, label %if.then85, label %cleanup

if.then85:                                        ; preds = %if.end68
  %24 = bitcast %struct.smi_info* %call4 to i8*
  call void @kfree(i8* %24)
  br label %cleanup

cleanup:                                          ; preds = %if.then85, %if.end68, %if.else65, %sw.default, %sw.bb14, %if.then5, %if.then
  %retval.0 = phi i32 [ -19, %if.then ], [ -5, %if.else65 ], [ -5, %sw.default ], [ -5, %sw.bb14 ], [ -12, %if.then5 ], [ %call83, %if.then85 ], [ %call83, %if.end68 ]
  ret void
}

declare %struct.dmi_device* @dmi_find_device(i32, i8*, %struct.dmi_device*) #1

declare i8* @__memset(i8*, i32, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @decode_dmi(%struct.dmi_header* %dm, %struct.dmi_ipmi_data* %dmi) #0 {
entry:
  %base_addr = alloca i64, align 8
  %0 = bitcast %struct.dmi_header* %dm to i8*
  %1 = bitcast i64* %base_addr to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %length = getelementptr inbounds %struct.dmi_header, %struct.dmi_header* %dm, i32 0, i32 1
  %2 = load i8, i8* %length, align 1, !tbaa !227
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 4
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %type = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 0
  store i8 %3, i8* %type, align 8, !tbaa !229
  %4 = bitcast i64* %base_addr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 8
  %call = call i8* @__memcpy(i8* %4, i8* %add.ptr, i64 8)
  %conv = zext i8 %2 to i32
  %cmp = icmp sge i32 %conv, 17
  %5 = load i64, i64* %base_addr, align 8, !tbaa !86
  br i1 %cmp, label %if.then, label %if.else21

if.then:                                          ; preds = %entry
  %and = and i64 %5, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %6 = load i64, i64* %base_addr, align 8, !tbaa !86
  %and3 = and i64 %6, 65534
  store i64 %and3, i64* %base_addr, align 8, !tbaa !86
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %.sink = phi i8 [ 0, %if.then2 ], [ 1, %if.then ]
  %addr_space4 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 1
  store i8 %.sink, i8* %addr_space4, align 1, !tbaa !231
  %7 = load i64, i64* %base_addr, align 8, !tbaa !86
  %arrayidx5 = getelementptr inbounds i8, i8* %0, i64 16
  %8 = load i8, i8* %arrayidx5, align 1, !tbaa !6
  %conv6 = zext i8 %8 to i32
  %and7 = and i32 %conv6, 16
  %shr = ashr i32 %and7, 4
  %conv8 = sext i32 %shr to i64
  %or = or i64 %7, %conv8
  %base_addr9 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 2
  store i64 %or, i64* %base_addr9, align 8, !tbaa !232
  %arrayidx10 = getelementptr inbounds i8, i8* %0, i64 17
  %9 = load i8, i8* %arrayidx10, align 1, !tbaa !6
  %irq = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 3
  store i8 %9, i8* %irq, align 8, !tbaa !233
  %arrayidx11 = getelementptr inbounds i8, i8* %0, i64 16
  %10 = load i8, i8* %arrayidx11, align 1, !tbaa !6
  %conv12 = zext i8 %10 to i32
  %and13 = and i32 %conv12, 192
  %shr14 = ashr i32 %and13, 6
  %conv15 = trunc i32 %shr14 to i8
  %conv16 = zext i8 %conv15 to i32
  %Pivot4 = icmp slt i32 %conv16, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %conv16, 2
  br i1 %Pivot, label %if.end26, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv16, 2
  br i1 %SwitchLeaf2, label %if.end26, label %cleanup

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %conv16, 0
  br i1 %SwitchLeaf, label %if.end26, label %cleanup

if.else21:                                        ; preds = %entry
  %and22 = and i64 %5, 65534
  %base_addr23 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 2
  store i64 %and22, i64* %base_addr23, align 8, !tbaa !232
  %addr_space24 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 1
  store i8 0, i8* %addr_space24, align 1, !tbaa !231
  br label %if.end26

if.end26:                                         ; preds = %if.else21, %LeafBlock, %LeafBlock1, %NodeBlock
  %.sink6 = phi i8 [ 1, %if.else21 ], [ 4, %NodeBlock ], [ 16, %LeafBlock1 ], [ 1, %LeafBlock ]
  %offset25 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 4
  store i8 %.sink6, i8* %offset25, align 1, !tbaa !234
  %arrayidx27 = getelementptr inbounds i8, i8* %0, i64 6
  %11 = load i8, i8* %arrayidx27, align 1, !tbaa !6
  %slave_addr = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 5
  store i8 %11, i8* %slave_addr, align 2, !tbaa !235
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ 0, %if.end26 ], [ -5, %LeafBlock ], [ -5, %LeafBlock1 ]
  %12 = bitcast i64* %base_addr to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @try_init_dmi(%struct.dmi_ipmi_data* %ipmi_data) #0 {
entry:
  %call = call %struct.smi_info* @smi_info_alloc()
  %tobool = icmp ne %struct.smi_info* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.110, i32 0, i32 0))
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 15
  store i32 5, i32* %addr_source, align 4, !tbaa !9
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.111, i32 0, i32 0))
  %type = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 0
  %0 = load i8, i8* %type, align 8, !tbaa !229
  %conv = zext i8 %0 to i32
  %Pivot4 = icmp slt i32 %conv, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %conv, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %1 = bitcast %struct.smi_info* %call to i8*
  call void @kfree(i8* %1)
  br label %cleanup.cont

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %NodeBlock
  %.sink = phi i32 [ 1, %NodeBlock ], [ 2, %LeafBlock1 ], [ 0, %LeafBlock ]
  %si_type6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 4
  store i32 %.sink, i32* %si_type6, align 8, !tbaa !21
  %addr_space = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 1
  %2 = load i8, i8* %addr_space, align 1, !tbaa !231
  %conv7 = zext i8 %2 to i32
  %Pivot11 = icmp slt i32 %conv7, 1
  br i1 %Pivot11, label %LeafBlock6, label %LeafBlock8

LeafBlock8:                                       ; preds = %sw.epilog
  %SwitchLeaf9 = icmp eq i32 %conv7, 1
  br i1 %SwitchLeaf9, label %sw.epilog17, label %sw.default13

LeafBlock6:                                       ; preds = %sw.epilog
  %SwitchLeaf7 = icmp eq i32 %conv7, 0
  br i1 %SwitchLeaf7, label %sw.epilog17, label %sw.default13

sw.default13:                                     ; preds = %LeafBlock6, %LeafBlock8
  %3 = bitcast %struct.smi_info* %call to i8*
  call void @kfree(i8* %3)
  %addr_space14 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 1
  %4 = load i8, i8* %addr_space14, align 1, !tbaa !231
  %conv15 = zext i8 %4 to i32
  %call16 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.112, i32 0, i32 0), i32 %conv15)
  br label %cleanup.cont

sw.epilog17:                                      ; preds = %LeafBlock6, %LeafBlock8
  %port_setup.sink = phi i32 (%struct.smi_info*)* [ @port_setup, %LeafBlock6 ], [ @mem_setup, %LeafBlock8 ]
  %.sink12 = phi i32 [ 0, %LeafBlock6 ], [ 1, %LeafBlock8 ]
  %io_setup10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 10
  store i32 (%struct.smi_info*)* %port_setup.sink, i32 (%struct.smi_info*)** %io_setup10, align 8, !tbaa !24
  %io11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %addr_type12 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io11, i32 0, i32 6
  store i32 %.sink12, i32* %addr_type12, align 4, !tbaa !23
  %base_addr = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 2
  %5 = load i64, i64* %base_addr, align 8, !tbaa !232
  %io18 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io18, i32 0, i32 7
  store i64 %5, i64* %addr_data, align 8, !tbaa !22
  %offset = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 4
  %6 = load i8, i8* %offset, align 1, !tbaa !234
  %conv19 = zext i8 %6 to i32
  %io20 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io20, i32 0, i32 3
  store i32 %conv19, i32* %regspacing, align 8, !tbaa !26
  %io21 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regspacing22 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io21, i32 0, i32 3
  %7 = load i32, i32* %regspacing22, align 8, !tbaa !26
  %tobool23 = icmp ne i32 %7, 0
  br i1 %tobool23, label %if.end27, label %if.then24

if.then24:                                        ; preds = %sw.epilog17
  %io25 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regspacing26 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io25, i32 0, i32 3
  store i32 1, i32* %regspacing26, align 8, !tbaa !26
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %sw.epilog17
  %io28 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io28, i32 0, i32 4
  store i32 1, i32* %regsize, align 4, !tbaa !27
  %io29 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io29, i32 0, i32 5
  store i32 0, i32* %regshift, align 8, !tbaa !28
  %slave_addr = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 5
  %8 = load i8, i8* %slave_addr, align 2, !tbaa !235
  %slave_addr30 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 39
  store i8 %8, i8* %slave_addr30, align 1, !tbaa !31
  %irq = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 3
  %9 = load i8, i8* %irq, align 8, !tbaa !233
  %conv31 = zext i8 %9 to i32
  %irq32 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 25
  store i32 %conv31, i32* %irq32, align 4, !tbaa !29
  %irq33 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 25
  %10 = load i32, i32* %irq33, align 4, !tbaa !29
  %tobool34 = icmp ne i32 %10, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end27
  %irq_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 12
  store i32 (%struct.smi_info*)* @std_irq_setup, i32 (%struct.smi_info*)** %irq_setup, align 8, !tbaa !30
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.end27
  %io37 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %addr_type38 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io37, i32 0, i32 6
  %11 = load i32, i32* %addr_type38, align 4, !tbaa !23
  %cmp = icmp eq i32 %11, 0
  %12 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.114, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0)
  %io40 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %addr_data41 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io40, i32 0, i32 7
  %13 = load i64, i64* %addr_data41, align 8, !tbaa !22
  %io42 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regsize43 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io42, i32 0, i32 4
  %14 = load i32, i32* %regsize43, align 4, !tbaa !27
  %io44 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regspacing45 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io44, i32 0, i32 3
  %15 = load i32, i32* %regspacing45, align 8, !tbaa !26
  %irq46 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 25
  %16 = load i32, i32* %irq46, align 4, !tbaa !29
  %call47 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.113, i32 0, i32 0), i8* %cond, i64 %13, i32 %14, i32 %15, i32 %16)
  %call48 = call i32 @add_smi(%struct.smi_info* %call)
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.then50, label %cleanup.cont

if.then50:                                        ; preds = %if.end36
  %17 = bitcast %struct.smi_info* %call to i8*
  call void @kfree(i8* %17)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then50, %if.end36, %sw.default13, %sw.default, %if.then
  %cleanup.dest.slot.0 = phi i32 [ 1, %sw.default13 ], [ 1, %sw.default ], [ 1, %if.then ], [ 0, %if.then50 ], [ 0, %if.end36 ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_pci_probe(%struct.pci_dev* %pdev, %struct.pci_device_id* %ent) #0 {
entry:
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 11
  %0 = load i32, i32* %class, align 4, !tbaa !236
  %and = and i32 %0, 255
  %call = call %struct.smi_info* @smi_info_alloc()
  %tobool = icmp ne %struct.smi_info* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 15
  store i32 6, i32* %addr_source, align 4, !tbaa !9
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.106, i32 0, i32 0))
  %Pivot4 = icmp slt i32 %and, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %and, 2
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %and, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %1 = bitcast %struct.smi_info* %call to i8*
  call void @kfree(i8* %1)
  %dev5 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev5, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.107, i32 0, i32 0), i32 %and)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %NodeBlock
  %.sink = phi i32 [ 0, %NodeBlock ], [ 2, %LeafBlock1 ], [ 1, %LeafBlock ]
  %si_type4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 4
  store i32 %.sink, i32* %si_type4, align 8, !tbaa !21
  %call6 = call i32 @pci_enable_device(%struct.pci_dev* %pdev)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %sw.epilog
  %dev9 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev9, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.108, i32 0, i32 0))
  %2 = bitcast %struct.smi_info* %call to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end10:                                         ; preds = %sw.epilog
  %addr_source_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 16
  store void (%struct.smi_info*)* @ipmi_pci_cleanup, void (%struct.smi_info*)** %addr_source_cleanup, align 8, !tbaa !78
  %3 = bitcast %struct.pci_dev* %pdev to i8*
  %addr_source_data = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 17
  store i8* %3, i8** %addr_source_data, align 8, !tbaa !239
  %resource = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 38
  %arrayidx = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource, i64 0, i64 0
  %flags = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx, i32 0, i32 3
  %4 = load i64, i64* %flags, align 8, !tbaa !175
  %and11 = and i64 %4, 256
  %tobool12 = icmp ne i64 %and11, 0
  %io_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 10
  %mem_setup.sink = select i1 %tobool12, i32 (%struct.smi_info*)* @port_setup, i32 (%struct.smi_info*)* @mem_setup
  %.sink5 = select i1 %tobool12, i32 0, i32 1
  store i32 (%struct.smi_info*)* %mem_setup.sink, i32 (%struct.smi_info*)** %io_setup, align 8, !tbaa !24
  %io15 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %addr_type16 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io15, i32 0, i32 6
  store i32 %.sink5, i32* %addr_type16, align 4, !tbaa !23
  %resource18 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 38
  %arrayidx19 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource18, i64 0, i64 0
  %start = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx19, i32 0, i32 0
  %5 = load i64, i64* %start, align 8, !tbaa !177
  %io20 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io20, i32 0, i32 7
  store i64 %5, i64* %addr_data, align 8, !tbaa !22
  %call21 = call i32 @ipmi_pci_probe_regspacing(%struct.smi_info* %call)
  %io22 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io22, i32 0, i32 3
  store i32 %call21, i32* %regspacing, align 8, !tbaa !26
  %io23 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io23, i32 0, i32 4
  store i32 1, i32* %regsize, align 4, !tbaa !27
  %io24 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io24, i32 0, i32 5
  store i32 0, i32* %regshift, align 8, !tbaa !28
  %irq = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 37
  %6 = load i32, i32* %irq, align 4, !tbaa !240
  %irq25 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 25
  store i32 %6, i32* %irq25, align 4, !tbaa !29
  %irq26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 25
  %7 = load i32, i32* %irq26, align 4, !tbaa !29
  %tobool27 = icmp ne i32 %7, 0
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end10
  %irq_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 12
  store i32 (%struct.smi_info*)* @std_irq_setup, i32 (%struct.smi_info*)** %irq_setup, align 8, !tbaa !30
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end10
  %dev30 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %dev31 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 36
  store %struct.device* %dev30, %struct.device** %dev31, align 8, !tbaa !38
  %8 = bitcast %struct.smi_info* %call to i8*
  call void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %8)
  %dev32 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %resource33 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 38
  %arrayidx34 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource33, i64 0, i64 0
  %io35 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regsize36 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io35, i32 0, i32 4
  %9 = load i32, i32* %regsize36, align 4, !tbaa !27
  %io37 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 9
  %regspacing38 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io37, i32 0, i32 3
  %10 = load i32, i32* %regspacing38, align 8, !tbaa !26
  %irq39 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %call, i32 0, i32 25
  %11 = load i32, i32* %irq39, align 4, !tbaa !29
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev32, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.64, i32 0, i32 0), %struct.resource* %arrayidx34, i32 %9, i32 %10, i32 %11)
  %call40 = call i32 @add_smi(%struct.smi_info* %call)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.then42, label %cleanup

if.then42:                                        ; preds = %if.end29
  %12 = bitcast %struct.smi_info* %call to i8*
  call void @kfree(i8* %12)
  call void @pci_disable_device(%struct.pci_dev* %pdev)
  br label %cleanup

cleanup:                                          ; preds = %if.then42, %if.end29, %if.then8, %sw.default, %entry
  %retval.0 = phi i32 [ %call6, %if.then8 ], [ -12, %sw.default ], [ -12, %entry ], [ %call40, %if.then42 ], [ %call40, %if.end29 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @ipmi_pci_remove(%struct.pci_dev* %pdev) #0 {
entry:
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %pdev)
  %0 = bitcast i8* %call to %struct.smi_info*
  call void @cleanup_one_si(%struct.smi_info* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_get_drvdata(%struct.pci_dev* %pdev) #3 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare i32 @pci_enable_device(%struct.pci_dev*) #1

; Function Attrs: nounwind uwtable
define internal void @ipmi_pci_cleanup(%struct.smi_info* %info) #0 {
entry:
  %addr_source_data = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 17
  %0 = load i8*, i8** %addr_source_data, align 8, !tbaa !239
  %1 = bitcast i8* %0 to %struct.pci_dev*
  call void @pci_disable_device(%struct.pci_dev* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_pci_probe_regspacing(%struct.smi_info* %info) #0 {
entry:
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 4
  %0 = load i32, i32* %si_type, align 8, !tbaa !21
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end15

if.then:                                          ; preds = %entry
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 4
  store i32 1, i32* %regsize, align 4, !tbaa !27
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 5
  store i32 0, i32* %regshift, align 8, !tbaa !28
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 14
  store i32 2, i32* %io_size, align 8, !tbaa !41
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 3
  store %struct.si_sm_handlers* @kcs_smi_handlers, %struct.si_sm_handlers** %handlers, align 8, !tbaa !45
  br label %for.cond

for.cond:                                         ; preds = %if.end13, %if.then
  %regspacing.0 = phi i32 [ 1, %if.then ], [ %mul, %if.end13 ]
  %cmp2 = icmp sle i32 %regspacing.0, 16
  br i1 %cmp2, label %for.body, label %LeafBlock

for.body:                                         ; preds = %for.cond
  %io3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %regspacing4 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io3, i32 0, i32 3
  store i32 %regspacing.0, i32* %regspacing4, align 8, !tbaa !26
  %io_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %1 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %io_setup, align 8, !tbaa !24
  %call = call i32 %1(%struct.smi_info* %info)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then5, label %if.end

if.then5:                                         ; preds = %for.body
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 36
  %2 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !38
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %2, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.109, i32 0, i32 0))
  br label %LeafBlock

if.end:                                           ; preds = %for.body
  %io6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io6, i32 0, i32 1
  %3 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !40
  %io7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  call void %3(%struct.si_sm_io* %io7, i32 1, i8 zeroext 16)
  %io8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io8, i32 0, i32 0
  %4 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !39
  %io9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 9
  %call10 = call zeroext i8 %4(%struct.si_sm_io* %io9, i32 1)
  %io_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 11
  %5 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %io_cleanup, align 8, !tbaa !37
  call void %5(%struct.smi_info* %info)
  %tobool11 = icmp ne i8 %call10, 0
  br i1 %tobool11, label %LeafBlock, label %if.end13

if.end13:                                         ; preds = %if.end
  %mul = mul nsw i32 %regspacing.0, 4
  br label %for.cond

LeafBlock:                                        ; preds = %if.end, %if.then5, %for.cond
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then5 ], [ 1, %if.end ], [ 0, %for.cond ]
  %retval.0 = phi i32 [ 1, %if.then5 ], [ %regspacing.0, %if.end ], [ undef, %for.cond ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 1
  br i1 %SwitchLeaf, label %return, label %if.end15

if.end15:                                         ; preds = %LeafBlock, %entry
  br label %return

return:                                           ; preds = %if.end15, %LeafBlock
  %retval.1 = phi i32 [ %retval.0, %LeafBlock ], [ 1, %if.end15 ]
  ret i32 %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %data) #3 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

declare void @pci_disable_device(%struct.pci_dev*) #1

; Function Attrs: nounwind uwtable
define internal i32 @init_kcs_data(%struct.si_sm_data* %kcs, %struct.si_sm_io* %io) #0 {
entry:
  %state = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 0, i32* %state, align 8, !tbaa !241
  %io1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  store %struct.si_sm_io* %io, %struct.si_sm_io** %io1, align 8, !tbaa !243
  %write_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !244
  %write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  store i32 0, i32* %write_count, align 4, !tbaa !245
  %orig_write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 5
  store i32 0, i32* %orig_write_count, align 8, !tbaa !246
  %read_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !247
  %error_retries = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 9
  store i32 0, i32* %error_retries, align 4, !tbaa !248
  %truncated = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 8
  store i32 0, i32* %truncated, align 8, !tbaa !249
  %ibf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  store i64 5000000, i64* %ibf_timeout, align 8, !tbaa !250
  %obf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  store i64 5000000, i64* %obf_timeout, align 8, !tbaa !251
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @start_kcs_transaction(%struct.si_sm_data* %kcs, i8* %data, i32 %size) #0 {
entry:
  %cmp = icmp ult i32 %size, 2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp ugt i32 %size, 272
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %state = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  %0 = load i32, i32* %state, align 8, !tbaa !241
  %cmp4 = icmp ne i32 %0, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.end3
  %state5 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  %1 = load i32, i32* %state5, align 8, !tbaa !241
  %cmp6 = icmp ne i32 %1, 10
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %land.lhs.true, %if.end3
  %2 = load i32, i32* @kcs_debug, align 4, !tbaa !2
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end8
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.122, i32 0, i32 0))
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then9
  %i.0 = phi i32 [ 0, %if.then9 ], [ %inc, %for.body ]
  %cmp10 = icmp ult i32 %i.0, %size
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv = zext i8 %3 to i32
  %call11 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2.175, i32 0, i32 0), i32 %conv)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3.176, i32 0, i32 0))
  br label %if.end13

if.end13:                                         ; preds = %for.end, %if.end8
  %error_retries = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 9
  store i32 0, i32* %error_retries, align 4, !tbaa !248
  %write_data = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 2
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %write_data, i32 0, i32 0
  %conv14 = zext i32 %size to i64
  %call15 = call i8* @__memcpy(i8* %arraydecay, i8* %data, i64 %conv14)
  %write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  store i32 %size, i32* %write_count, align 4, !tbaa !245
  %orig_write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 5
  store i32 %size, i32* %orig_write_count, align 8, !tbaa !246
  %write_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !244
  %read_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !247
  %state16 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 1, i32* %state16, align 8, !tbaa !241
  %ibf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  store i64 5000000, i64* %ibf_timeout, align 8, !tbaa !250
  %obf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  store i64 5000000, i64* %obf_timeout, align 8, !tbaa !251
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %land.lhs.true, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end13 ], [ 199, %entry ], [ 200, %if.end ], [ 213, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_kcs_result(%struct.si_sm_data* %kcs, i8* %data, i32 %length) #0 {
entry:
  %read_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %0 = load i32, i32* %read_pos, align 4, !tbaa !247
  %cmp = icmp ult i32 %length, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %read_pos1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  store i32 %length, i32* %read_pos1, align 4, !tbaa !247
  %truncated = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 8
  store i32 1, i32* %truncated, align 8, !tbaa !249
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %read_data = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 6
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %read_data, i32 0, i32 0
  %read_pos2 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %1 = load i32, i32* %read_pos2, align 4, !tbaa !247
  %conv = sext i32 %1 to i64
  %call = call i8* @__memcpy(i8* %data, i8* %arraydecay, i64 %conv)
  %cmp3 = icmp uge i32 %length, 3
  br i1 %cmp3, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %if.end
  %read_pos5 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %2 = load i32, i32* %read_pos5, align 4, !tbaa !247
  %cmp6 = icmp slt i32 %2, 3
  br i1 %cmp6, label %if.then8, label %if.end10

if.then8:                                         ; preds = %land.lhs.true
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 2
  store i8 -1, i8* %arrayidx, align 1, !tbaa !6
  %read_pos9 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  store i32 3, i32* %read_pos9, align 4, !tbaa !247
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %land.lhs.true, %if.end
  %truncated11 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 8
  %3 = load i32, i32* %truncated11, align 8, !tbaa !249
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end10
  %arrayidx13 = getelementptr inbounds i8, i8* %data, i64 2
  store i8 -58, i8* %arrayidx13, align 1, !tbaa !6
  %truncated14 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 8
  store i32 0, i32* %truncated14, align 8, !tbaa !249
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end10
  %read_pos16 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %4 = load i32, i32* %read_pos16, align 4, !tbaa !247
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @kcs_event(%struct.si_sm_data* %kcs, i64 %time) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy85 = alloca i64, align 8
  %__dummy286 = alloca i64, align 8
  %call = call zeroext i8 @read_status(%struct.si_sm_data* %kcs)
  %0 = load i32, i32* @kcs_debug, align 4, !tbaa !2
  %and = and i32 %0, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %state1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  %1 = load i32, i32* %state1, align 8, !tbaa !241
  %conv = zext i8 %call to i32
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3.3, i32 0, i32 0), i32 %1, i32 %conv)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call3 = call i32 @check_ibf(%struct.si_sm_data* %kcs, i8 zeroext %call, i64 %time)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.end
  %conv7 = zext i8 %call to i32
  %shr = ashr i32 %conv7, 6
  %and8 = and i32 %shr, 3
  %conv9 = trunc i32 %and8 to i8
  %state10 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  %2 = load i32, i32* %state10, align 8, !tbaa !241
  %Pivot20 = icmp slt i32 %2, 5
  br i1 %Pivot20, label %NodeBlock5, label %NodeBlock17

NodeBlock17:                                      ; preds = %if.end6
  %Pivot18 = icmp slt i32 %2, 8
  br i1 %Pivot18, label %NodeBlock9, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %2, 9
  br i1 %Pivot16, label %sw.bb100, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %2, 10
  br i1 %Pivot14, label %sw.bb111, label %sw.epilog

NodeBlock9:                                       ; preds = %NodeBlock17
  %Pivot10 = icmp slt i32 %2, 6
  br i1 %Pivot10, label %sw.bb55, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %2, 7
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  br i1 %Pivot8, label %sw.bb75, label %sw.bb98

NodeBlock5:                                       ; preds = %if.end6
  %Pivot6 = icmp slt i32 %2, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %2, 3
  br i1 %Pivot4, label %sw.bb21, label %NodeBlock1

NodeBlock1:                                       ; preds = %NodeBlock3
  %Pivot2 = icmp slt i32 %2, 4
  %conv36 = zext i8 %conv9 to i32
  %cmp37 = icmp ne i32 %conv36, 2
  br i1 %Pivot2, label %sw.bb35, label %sw.bb48

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %2, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb15

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %2, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  %conv11 = zext i8 %call to i32
  %and12 = and i32 %conv11, 4
  %tobool13 = icmp ne i32 %and12, 0
  %. = select i1 %tobool13, i32 6, i32 4
  br label %cleanup

sw.bb15:                                          ; preds = %NodeBlock
  %conv16 = zext i8 %conv9 to i32
  %cmp = icmp ne i32 %conv16, 0
  br i1 %cmp, label %if.then18, label %if.end19

if.then18:                                        ; preds = %sw.bb15
  call void @start_error_recovery(%struct.si_sm_data* %kcs, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.4.4, i32 0, i32 0))
  br label %sw.epilog

if.end19:                                         ; preds = %sw.bb15
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  call void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext 97)
  %state20 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 2, i32* %state20, align 8, !tbaa !241
  br label %sw.epilog

sw.bb21:                                          ; preds = %NodeBlock3
  %conv22 = zext i8 %conv9 to i32
  %cmp23 = icmp ne i32 %conv22, 2
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %sw.bb21
  call void @start_error_recovery(%struct.si_sm_data* %kcs, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.5.5, i32 0, i32 0))
  br label %sw.epilog

if.end26:                                         ; preds = %sw.bb21
  %call27 = call zeroext i8 @read_data(%struct.si_sm_data* %kcs)
  %write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  %3 = load i32, i32* %write_count, align 4, !tbaa !245
  %cmp28 = icmp eq i32 %3, 1
  br i1 %cmp28, label %if.then30, label %if.else32

if.then30:                                        ; preds = %if.end26
  call void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext 98)
  br label %if.end34

if.else32:                                        ; preds = %if.end26
  call void @write_next_byte(%struct.si_sm_data* %kcs)
  br label %if.end34

if.end34:                                         ; preds = %if.else32, %if.then30
  %.sink = phi i32 [ 3, %if.else32 ], [ 4, %if.then30 ]
  %state33 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 %.sink, i32* %state33, align 8, !tbaa !241
  br label %sw.epilog

sw.bb35:                                          ; preds = %NodeBlock1
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %sw.bb35
  call void @start_error_recovery(%struct.si_sm_data* %kcs, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.6.6, i32 0, i32 0))
  br label %sw.epilog

if.end40:                                         ; preds = %sw.bb35
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  %write_count41 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  %4 = load i32, i32* %write_count41, align 4, !tbaa !245
  %cmp42 = icmp eq i32 %4, 1
  br i1 %cmp42, label %if.then44, label %if.else46

if.then44:                                        ; preds = %if.end40
  call void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext 98)
  %state45 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 4, i32* %state45, align 8, !tbaa !241
  br label %sw.epilog

if.else46:                                        ; preds = %if.end40
  call void @write_next_byte(%struct.si_sm_data* %kcs)
  br label %sw.epilog

sw.bb48:                                          ; preds = %NodeBlock1
  br i1 %cmp37, label %if.then52, label %if.end53

if.then52:                                        ; preds = %sw.bb48
  call void @start_error_recovery(%struct.si_sm_data* %kcs, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.7.7, i32 0, i32 0))
  br label %sw.epilog

if.end53:                                         ; preds = %sw.bb48
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  call void @write_next_byte(%struct.si_sm_data* %kcs)
  %state54 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 5, i32* %state54, align 8, !tbaa !241
  br label %sw.epilog

sw.bb55:                                          ; preds = %NodeBlock9
  %conv56 = zext i8 %conv9 to i32
  %cmp57 = icmp ne i32 %conv56, 1
  %conv59 = zext i8 %conv9 to i32
  %cmp60 = icmp ne i32 %conv59, 0
  %or.cond = and i1 %cmp57, %cmp60
  br i1 %or.cond, label %if.then62, label %if.end63

if.then62:                                        ; preds = %sw.bb55
  call void @start_error_recovery(%struct.si_sm_data* %kcs, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.8.8, i32 0, i32 0))
  br label %sw.epilog

if.end63:                                         ; preds = %sw.bb55
  %conv64 = zext i8 %conv9 to i32
  %cmp65 = icmp eq i32 %conv64, 1
  br i1 %cmp65, label %if.then67, label %if.else72

if.then67:                                        ; preds = %if.end63
  %call68 = call i32 @check_obf(%struct.si_sm_data* %kcs, i8 zeroext %call, i64 %time)
  %tobool69 = icmp ne i32 %call68, 0
  br i1 %tobool69, label %if.end71, label %cleanup

if.end71:                                         ; preds = %if.then67
  call void @read_next_byte(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.else72:                                        ; preds = %if.end63
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  %orig_write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 5
  store i32 0, i32* %orig_write_count, align 8, !tbaa !246
  %state73 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 0, i32* %state73, align 8, !tbaa !241
  br label %cleanup

sw.bb75:                                          ; preds = %NodeBlock7
  %call76 = call zeroext i8 @read_status(%struct.si_sm_data* %kcs)
  %conv77 = zext i8 %call76 to i32
  %and78 = and i32 %conv77, 1
  %tobool79 = icmp ne i32 %and78, 0
  br i1 %tobool79, label %if.then80, label %if.end96

if.then80:                                        ; preds = %sw.bb75
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %6 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #7
  %cmp81 = icmp eq i64* %__dummy, %__dummy2
  %conv82 = zext i1 %cmp81 to i32
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %8 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #7
  %tobool83 = icmp ne i32 1, 0
  br i1 %tobool83, label %land.lhs.true84, label %if.end96

land.lhs.true84:                                  ; preds = %if.then80
  %9 = bitcast i64* %__dummy85 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #7
  %10 = bitcast i64* %__dummy286 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #7
  %cmp87 = icmp eq i64* %__dummy85, %__dummy286
  %conv88 = zext i1 %cmp87 to i32
  %11 = bitcast i64* %__dummy286 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #7
  %12 = bitcast i64* %__dummy85 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #7
  %13 = load volatile i64, i64* @jiffies, align 8, !tbaa !86
  %error0_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 12
  %14 = load i64, i64* %error0_timeout, align 8, !tbaa !252
  %sub = sub i64 %13, %14
  %cmp92 = icmp slt i64 %sub, 0
  br i1 %cmp92, label %cleanup, label %if.end96

if.end96:                                         ; preds = %land.lhs.true84, %if.then80, %sw.bb75
  call void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext 96)
  %state97 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 7, i32* %state97, align 8, !tbaa !241
  br label %sw.epilog

sw.bb98:                                          ; preds = %NodeBlock7
  call void @write_data(%struct.si_sm_data* %kcs, i8 zeroext 0)
  %state99 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 8, i32* %state99, align 8, !tbaa !241
  br label %sw.epilog

sw.bb100:                                         ; preds = %NodeBlock15
  %conv101 = zext i8 %conv9 to i32
  %cmp102 = icmp ne i32 %conv101, 1
  br i1 %cmp102, label %if.then104, label %if.end105

if.then104:                                       ; preds = %sw.bb100
  call void @start_error_recovery(%struct.si_sm_data* %kcs, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.9.9, i32 0, i32 0))
  br label %sw.epilog

if.end105:                                        ; preds = %sw.bb100
  %call106 = call i32 @check_obf(%struct.si_sm_data* %kcs, i8 zeroext %call, i64 %time)
  %tobool107 = icmp ne i32 %call106, 0
  br i1 %tobool107, label %if.end109, label %cleanup

if.end109:                                        ; preds = %if.end105
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  call void @write_data(%struct.si_sm_data* %kcs, i8 zeroext 104)
  %state110 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 9, i32* %state110, align 8, !tbaa !241
  br label %sw.epilog

sw.bb111:                                         ; preds = %NodeBlock13
  %conv112 = zext i8 %conv9 to i32
  %cmp113 = icmp ne i32 %conv112, 0
  br i1 %cmp113, label %if.then115, label %if.end116

if.then115:                                       ; preds = %sw.bb111
  call void @start_error_recovery(%struct.si_sm_data* %kcs, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.10.10, i32 0, i32 0))
  br label %sw.epilog

if.end116:                                        ; preds = %sw.bb111
  %call117 = call i32 @check_obf(%struct.si_sm_data* %kcs, i8 zeroext %call, i64 %time)
  %tobool118 = icmp ne i32 %call117, 0
  br i1 %tobool118, label %if.end120, label %cleanup

if.end120:                                        ; preds = %if.end116
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  %orig_write_count121 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 5
  %15 = load i32, i32* %orig_write_count121, align 8, !tbaa !246
  %tobool122 = icmp ne i32 %15, 0
  br i1 %tobool122, label %if.then123, label %if.else124

if.then123:                                       ; preds = %if.end120
  call void @restart_kcs_transaction(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.else124:                                       ; preds = %if.end120
  %state125 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 0, i32* %state125, align 8, !tbaa !241
  br label %cleanup

sw.epilog:                                        ; preds = %if.then123, %if.then115, %if.end109, %if.then104, %sw.bb98, %if.end96, %if.end71, %if.then62, %if.end53, %if.then52, %if.else46, %if.then44, %if.then39, %if.end34, %if.then25, %if.end19, %if.then18, %LeafBlock, %NodeBlock13
  %state127 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  %16 = load i32, i32* %state127, align 8, !tbaa !241
  %cmp128 = icmp eq i32 %16, 10
  br i1 %cmp128, label %if.then130, label %cleanup

if.then130:                                       ; preds = %sw.epilog
  %io = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %17 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !243
  %call131 = call i32 @init_kcs_data(%struct.si_sm_data* %kcs, %struct.si_sm_io* %17)
  br label %cleanup

cleanup:                                          ; preds = %if.then130, %sw.epilog, %if.else124, %if.end116, %if.end105, %land.lhs.true84, %if.else72, %if.then67, %sw.bb, %if.end
  %retval.0 = phi i32 [ 5, %if.then130 ], [ 3, %if.else72 ], [ 3, %if.else124 ], [ 1, %if.end ], [ %., %sw.bb ], [ 1, %if.then67 ], [ 2, %land.lhs.true84 ], [ 1, %if.end105 ], [ 1, %if.end116 ], [ 0, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @kcs_detect(%struct.si_sm_data* %kcs) #0 {
entry:
  %call = call zeroext i8 @read_status(%struct.si_sm_data* %kcs)
  %conv = zext i8 %call to i32
  %cmp = icmp eq i32 %conv, 255
  %. = select i1 %cmp, i32 1, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal void @kcs_cleanup(%struct.si_sm_data* %kcs) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @kcs_size() #0 {
entry:
  ret i32 608
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @read_status(%struct.si_sm_data* %kcs) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !243
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !253
  %io1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !243
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 1)
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @check_ibf(%struct.si_sm_data* %kcs, i8 zeroext %status, i64 %time) #3 {
entry:
  %conv = zext i8 %status to i32
  %and = and i32 %conv, 2
  %tobool = icmp ne i32 %and, 0
  %ibf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  br i1 %tobool, label %if.then, label %return.sink.split

if.then:                                          ; preds = %entry
  %0 = load i64, i64* %ibf_timeout, align 8, !tbaa !250
  %sub = sub nsw i64 %0, %time
  store i64 %sub, i64* %ibf_timeout, align 8, !tbaa !250
  %ibf_timeout1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  %1 = load i64, i64* %ibf_timeout1, align 8, !tbaa !250
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %if.then3, label %return

if.then3:                                         ; preds = %if.then
  call void @start_error_recovery(%struct.si_sm_data* %kcs, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.11.13, i32 0, i32 0))
  %ibf_timeout4 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  br label %return.sink.split

return.sink.split:                                ; preds = %if.then3, %entry
  %ibf_timeout.sink = phi i64* [ %ibf_timeout4, %if.then3 ], [ %ibf_timeout, %entry ]
  store i64 5000000, i64* %ibf_timeout.sink, align 8, !tbaa !250
  br label %return

return:                                           ; preds = %return.sink.split, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 1, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %status) #0 {
entry:
  %conv = zext i8 %status to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call zeroext i8 @read_data(%struct.si_sm_data* %kcs)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @start_error_recovery(%struct.si_sm_data* %kcs, i8* %reason) #3 {
entry:
  %error_retries = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 9
  %0 = load i32, i32* %error_retries, align 4, !tbaa !248
  %inc = add i32 %0, 1
  store i32 %inc, i32* %error_retries, align 4, !tbaa !248
  %error_retries1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 9
  %1 = load i32, i32* %error_retries1, align 4, !tbaa !248
  %cmp = icmp ugt i32 %1, 10
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @kcs_debug, align 4, !tbaa !2
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.then
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.12.12, i32 0, i32 0), i8* %reason)
  br label %if.end4

if.else:                                          ; preds = %entry
  %3 = load volatile i64, i64* @jiffies, align 8, !tbaa !86
  %add = add i64 %3, 500
  %error0_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 12
  store i64 %add, i64* %error0_timeout, align 8, !tbaa !252
  br label %if.end4

if.end4:                                          ; preds = %if.else, %if.then2, %if.then
  %.sink = phi i32 [ 6, %if.else ], [ 10, %if.then2 ], [ 10, %if.then ]
  %state3 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 %.sink, i32* %state3, align 8, !tbaa !241
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext %data) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !243
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !254
  %io1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !243
  call void %1(%struct.si_sm_io* %2, i32 1, i8 zeroext %data)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @read_data(%struct.si_sm_data* %kcs) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !243
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !253
  %io1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !243
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 0)
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_next_byte(%struct.si_sm_data* %kcs) #3 {
entry:
  %write_data = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 2
  %write_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 3
  %0 = load i32, i32* %write_pos, align 8, !tbaa !244
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %write_data, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !6
  call void @write_data(%struct.si_sm_data* %kcs, i8 zeroext %1)
  %write_pos1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 3
  %2 = load i32, i32* %write_pos1, align 8, !tbaa !244
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %write_pos1, align 8, !tbaa !244
  %write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  %3 = load i32, i32* %write_count, align 4, !tbaa !245
  %dec = add nsw i32 %3, -1
  store i32 %dec, i32* %write_count, align 4, !tbaa !245
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @check_obf(%struct.si_sm_data* %kcs, i8 zeroext %status, i64 %time) #3 {
entry:
  %conv = zext i8 %status to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  %obf_timeout6 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  br i1 %tobool, label %if.end5, label %if.then

if.then:                                          ; preds = %entry
  %0 = load i64, i64* %obf_timeout6, align 8, !tbaa !251
  %sub = sub nsw i64 %0, %time
  store i64 %sub, i64* %obf_timeout6, align 8, !tbaa !251
  %obf_timeout1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  %1 = load i64, i64* %obf_timeout1, align 8, !tbaa !251
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %if.then3, label %return

if.then3:                                         ; preds = %if.then
  %obf_timeout4 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  store i64 5000000, i64* %obf_timeout4, align 8, !tbaa !251
  call void @start_error_recovery(%struct.si_sm_data* %kcs, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13.11, i32 0, i32 0))
  br label %return

if.end5:                                          ; preds = %entry
  store i64 5000000, i64* %obf_timeout6, align 8, !tbaa !251
  br label %return

return:                                           ; preds = %if.end5, %if.then3, %if.then
  %retval.0 = phi i32 [ 1, %if.end5 ], [ 1, %if.then3 ], [ 0, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @read_next_byte(%struct.si_sm_data* %kcs) #3 {
entry:
  %read_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %0 = load i32, i32* %read_pos, align 4, !tbaa !247
  %cmp = icmp sge i32 %0, 272
  %call = call zeroext i8 @read_data(%struct.si_sm_data* %kcs)
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %truncated = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 8
  store i32 1, i32* %truncated, align 8, !tbaa !249
  br label %if.end

if.else:                                          ; preds = %entry
  %read_data = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 6
  %read_pos2 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %1 = load i32, i32* %read_pos2, align 4, !tbaa !247
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %read_data, i64 0, i64 %idxprom
  store i8 %call, i8* %arrayidx, align 1, !tbaa !6
  %read_pos3 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %2 = load i32, i32* %read_pos3, align 4, !tbaa !247
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %read_pos3, align 4, !tbaa !247
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @write_data(%struct.si_sm_data* %kcs, i8 zeroext 104)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_data(%struct.si_sm_data* %kcs, i8 zeroext %data) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !243
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !254
  %io1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !243
  call void %1(%struct.si_sm_io* %2, i32 0, i8 zeroext %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @restart_kcs_transaction(%struct.si_sm_data* %kcs) #0 {
entry:
  %orig_write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 5
  %0 = load i32, i32* %orig_write_count, align 8, !tbaa !246
  %write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  store i32 %0, i32* %write_count, align 4, !tbaa !245
  %write_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !244
  %read_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !247
  %state = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 2, i32* %state, align 8, !tbaa !241
  %ibf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  store i64 5000000, i64* %ibf_timeout, align 8, !tbaa !250
  %obf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  store i64 5000000, i64* %obf_timeout, align 8, !tbaa !251
  call void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext 97)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @init_smic_data(%struct.si_sm_data.179* %smic, %struct.si_sm_io* %io) #0 {
entry:
  %state = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 0, i32* %state, align 8, !tbaa !255
  %io1 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  store %struct.si_sm_io* %io, %struct.si_sm_io** %io1, align 8, !tbaa !257
  %write_pos = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !258
  %write_count = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 4
  store i32 0, i32* %write_count, align 4, !tbaa !259
  %orig_write_count = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 5
  store i32 0, i32* %orig_write_count, align 8, !tbaa !260
  %read_pos = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !261
  %error_retries = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 9
  store i32 0, i32* %error_retries, align 4, !tbaa !262
  %truncated = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 8
  store i32 0, i32* %truncated, align 8, !tbaa !263
  %smic_timeout = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 10
  store i64 2000000, i64* %smic_timeout, align 8, !tbaa !264
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @start_smic_transaction(%struct.si_sm_data.179* %smic, i8* %data, i32 %size) #0 {
entry:
  %cmp = icmp ult i32 %size, 2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp ugt i32 %size, 80
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %state = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  %0 = load i32, i32* %state, align 8, !tbaa !255
  %cmp4 = icmp ne i32 %0, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.end3
  %state5 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  %1 = load i32, i32* %state5, align 8, !tbaa !255
  %cmp6 = icmp ne i32 %1, 10
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %land.lhs.true, %if.end3
  %2 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end8
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.151, i32 0, i32 0))
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then9
  %i.0 = phi i32 [ 0, %if.then9 ], [ %inc, %for.body ]
  %cmp10 = icmp ult i32 %i.0, %size
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv = zext i8 %3 to i32
  %call11 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2.175, i32 0, i32 0), i32 %conv)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3.176, i32 0, i32 0))
  br label %if.end13

if.end13:                                         ; preds = %for.end, %if.end8
  %error_retries = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 9
  store i32 0, i32* %error_retries, align 4, !tbaa !262
  %write_data = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 2
  %arraydecay = getelementptr inbounds [80 x i8], [80 x i8]* %write_data, i32 0, i32 0
  %conv14 = zext i32 %size to i64
  %call15 = call i8* @__memcpy(i8* %arraydecay, i8* %data, i64 %conv14)
  %write_count = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 4
  store i32 %size, i32* %write_count, align 4, !tbaa !259
  %orig_write_count = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 5
  store i32 %size, i32* %orig_write_count, align 8, !tbaa !260
  %write_pos = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !258
  %read_pos = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !261
  %state16 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 1, i32* %state16, align 8, !tbaa !255
  %smic_timeout = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 10
  store i64 2000000, i64* %smic_timeout, align 8, !tbaa !264
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %land.lhs.true, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end13 ], [ 199, %entry ], [ 200, %if.end ], [ 213, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @smic_get_result(%struct.si_sm_data.179* %smic, i8* %data, i32 %length) #0 {
entry:
  %0 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.3.148, i32 0, i32 0))
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %read_pos = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  %1 = load i32, i32* %read_pos, align 4, !tbaa !261
  %cmp = icmp slt i32 %i.0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %read_data = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 6
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [80 x i8], [80 x i8]* %read_data, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv = zext i8 %2 to i32
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2.175, i32 0, i32 0), i32 %conv)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3.176, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  %read_pos3 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  %3 = load i32, i32* %read_pos3, align 4, !tbaa !261
  %cmp4 = icmp ult i32 %length, %3
  br i1 %cmp4, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %read_pos7 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  store i32 %length, i32* %read_pos7, align 4, !tbaa !261
  %truncated = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 8
  store i32 1, i32* %truncated, align 8, !tbaa !263
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %read_data9 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 6
  %arraydecay = getelementptr inbounds [80 x i8], [80 x i8]* %read_data9, i32 0, i32 0
  %read_pos10 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  %4 = load i32, i32* %read_pos10, align 4, !tbaa !261
  %conv11 = sext i32 %4 to i64
  %call12 = call i8* @__memcpy(i8* %data, i8* %arraydecay, i64 %conv11)
  %cmp13 = icmp uge i32 %length, 3
  br i1 %cmp13, label %land.lhs.true, label %if.end21

land.lhs.true:                                    ; preds = %if.end8
  %read_pos15 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  %5 = load i32, i32* %read_pos15, align 4, !tbaa !261
  %cmp16 = icmp slt i32 %5, 3
  br i1 %cmp16, label %if.then18, label %if.end21

if.then18:                                        ; preds = %land.lhs.true
  %arrayidx19 = getelementptr inbounds i8, i8* %data, i64 2
  store i8 -1, i8* %arrayidx19, align 1, !tbaa !6
  %read_pos20 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  store i32 3, i32* %read_pos20, align 4, !tbaa !261
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %land.lhs.true, %if.end8
  %truncated22 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 8
  %6 = load i32, i32* %truncated22, align 8, !tbaa !263
  %tobool23 = icmp ne i32 %6, 0
  br i1 %tobool23, label %if.then24, label %if.end27

if.then24:                                        ; preds = %if.end21
  %arrayidx25 = getelementptr inbounds i8, i8* %data, i64 2
  store i8 -58, i8* %arrayidx25, align 1, !tbaa !6
  %truncated26 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 8
  store i32 0, i32* %truncated26, align 8, !tbaa !263
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %if.end21
  %read_pos28 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  %7 = load i32, i32* %read_pos28, align 4, !tbaa !261
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @smic_event(%struct.si_sm_data.179* %smic, i64 %time) #0 {
entry:
  %state = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  %0 = load i32, i32* %state, align 8, !tbaa !255
  %cmp = icmp eq i32 %0, 10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %io = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %1 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !257
  %call = call i32 @init_smic_data(%struct.si_sm_data.179* %smic, %struct.si_sm_io* %1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %state1 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  %2 = load i32, i32* %state1, align 8, !tbaa !255
  %cmp2 = icmp ne i32 %2, 0
  br i1 %cmp2, label %if.then3, label %if.end15

if.then3:                                         ; preds = %if.end
  %3 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and = and i32 %3, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.then3
  %smic_timeout = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 10
  %4 = load i64, i64* %smic_timeout, align 8, !tbaa !264
  %call5 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.4.128, i32 0, i32 0), i64 %4, i64 %time)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.then3
  %cmp7 = icmp slt i64 %time, 2000000
  br i1 %cmp7, label %if.then8, label %if.end15

if.then8:                                         ; preds = %if.end6
  %smic_timeout9 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 10
  %5 = load i64, i64* %smic_timeout9, align 8, !tbaa !264
  %sub = sub nsw i64 %5, %time
  store i64 %sub, i64* %smic_timeout9, align 8, !tbaa !264
  %smic_timeout10 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 10
  %6 = load i64, i64* %smic_timeout10, align 8, !tbaa !264
  %cmp11 = icmp slt i64 %6, 0
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.then8
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.5.129, i32 0, i32 0))
  br label %cleanup

if.end15:                                         ; preds = %if.then8, %if.end6, %if.end
  %call16 = call zeroext i8 @read_smic_flags(%struct.si_sm_data.179* %smic)
  %conv = zext i8 %call16 to i32
  %and17 = and i32 %conv, 1
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end15
  %call21 = call zeroext i8 @read_smic_status(%struct.si_sm_data.179* %smic)
  %7 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and22 = and i32 %7, 4
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end29

if.then24:                                        ; preds = %if.end20
  %state25 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  %8 = load i32, i32* %state25, align 8, !tbaa !255
  %conv26 = zext i8 %call16 to i32
  %conv27 = zext i8 %call21 to i32
  %call28 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.6.131, i32 0, i32 0), i32 %8, i32 %conv26, i32 %conv27)
  br label %if.end29

if.end29:                                         ; preds = %if.then24, %if.end20
  %state30 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  %9 = load i32, i32* %state30, align 8, !tbaa !255
  %Pivot20 = icmp slt i32 %9, 5
  br i1 %Pivot20, label %NodeBlock5, label %NodeBlock17

NodeBlock17:                                      ; preds = %if.end29
  %Pivot18 = icmp slt i32 %9, 8
  br i1 %Pivot18, label %NodeBlock9, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %9, 9
  br i1 %Pivot16, label %sw.bb141, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %9, 10
  br i1 %Pivot14, label %sw.bb159, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %9, 10
  br i1 %SwitchLeaf12, label %sw.bb178, label %sw.default181

NodeBlock9:                                       ; preds = %NodeBlock17
  %Pivot10 = icmp slt i32 %9, 6
  br i1 %Pivot10, label %sw.bb94, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %9, 7
  br i1 %Pivot8, label %sw.bb114, label %sw.bb125

NodeBlock5:                                       ; preds = %if.end29
  %Pivot6 = icmp slt i32 %9, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %9, 3
  br i1 %Pivot4, label %sw.bb40, label %NodeBlock1

NodeBlock1:                                       ; preds = %NodeBlock3
  %Pivot2 = icmp slt i32 %9, 4
  %conv51 = zext i8 %call21 to i32
  br i1 %Pivot2, label %sw.bb50, label %sw.bb71

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %9, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb36

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %9, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default181

sw.bb:                                            ; preds = %LeafBlock
  %conv31 = zext i8 %call16 to i32
  %and32 = and i32 %conv31, 4
  %tobool33 = icmp ne i32 %and32, 0
  %. = select i1 %tobool33, i32 6, i32 4
  br label %cleanup

sw.bb36:                                          ; preds = %NodeBlock
  call void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext 64)
  %conv37 = zext i8 %call16 to i32
  %or = or i32 %conv37, 1
  %conv38 = trunc i32 %or to i8
  call void @write_smic_flags(%struct.si_sm_data.179* %smic, i8 zeroext %conv38)
  %state39 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 2, i32* %state39, align 8, !tbaa !255
  br label %sw.epilog188

sw.bb40:                                          ; preds = %NodeBlock3
  %conv41 = zext i8 %call21 to i32
  %cmp42 = icmp ne i32 %conv41, 192
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %sw.bb40
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.7.132, i32 0, i32 0))
  br label %cleanup

if.end45:                                         ; preds = %sw.bb40
  call void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext 65)
  call void @write_next_byte.133(%struct.si_sm_data.179* %smic)
  %conv46 = zext i8 %call16 to i32
  %or47 = or i32 %conv46, 1
  %conv48 = trunc i32 %or47 to i8
  call void @write_smic_flags(%struct.si_sm_data.179* %smic, i8 zeroext %conv48)
  %state49 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 3, i32* %state49, align 8, !tbaa !255
  br label %sw.epilog188

sw.bb50:                                          ; preds = %NodeBlock1
  %cmp52 = icmp ne i32 %conv51, 193
  br i1 %cmp52, label %if.then54, label %if.end55

if.then54:                                        ; preds = %sw.bb50
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.8.134, i32 0, i32 0))
  br label %cleanup

if.end55:                                         ; preds = %sw.bb50
  %conv56 = zext i8 %call16 to i32
  %and57 = and i32 %conv56, 64
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.then59, label %cleanup

if.then59:                                        ; preds = %if.end55
  %write_count = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 4
  %10 = load i32, i32* %write_count, align 4, !tbaa !259
  %cmp60 = icmp eq i32 %10, 1
  br i1 %cmp60, label %if.then62, label %if.else

if.then62:                                        ; preds = %if.then59
  call void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext 67)
  br label %if.end65

if.else:                                          ; preds = %if.then59
  call void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext 66)
  br label %if.end65

if.end65:                                         ; preds = %if.else, %if.then62
  %.sink = phi i32 [ 4, %if.else ], [ 5, %if.then62 ]
  %state64 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 %.sink, i32* %state64, align 8, !tbaa !255
  call void @write_next_byte.133(%struct.si_sm_data.179* %smic)
  %conv66 = zext i8 %call16 to i32
  %or67 = or i32 %conv66, 1
  %conv68 = trunc i32 %or67 to i8
  call void @write_smic_flags(%struct.si_sm_data.179* %smic, i8 zeroext %conv68)
  br label %sw.epilog188

sw.bb71:                                          ; preds = %NodeBlock1
  %cmp73 = icmp ne i32 %conv51, 194
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %sw.bb71
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.9.135, i32 0, i32 0))
  br label %cleanup

if.end76:                                         ; preds = %sw.bb71
  %conv77 = zext i8 %call16 to i32
  %and78 = and i32 %conv77, 64
  %tobool79 = icmp ne i32 %and78, 0
  br i1 %tobool79, label %if.then80, label %cleanup

if.then80:                                        ; preds = %if.end76
  %write_count81 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 4
  %11 = load i32, i32* %write_count81, align 4, !tbaa !259
  %cmp82 = icmp eq i32 %11, 1
  br i1 %cmp82, label %if.then84, label %if.else86

if.then84:                                        ; preds = %if.then80
  call void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext 67)
  br label %if.end88

if.else86:                                        ; preds = %if.then80
  call void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext 66)
  br label %if.end88

if.end88:                                         ; preds = %if.else86, %if.then84
  %.sink28 = phi i32 [ 4, %if.else86 ], [ 5, %if.then84 ]
  %state87 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 %.sink28, i32* %state87, align 8, !tbaa !255
  call void @write_next_byte.133(%struct.si_sm_data.179* %smic)
  %conv89 = zext i8 %call16 to i32
  %or90 = or i32 %conv89, 1
  %conv91 = trunc i32 %or90 to i8
  call void @write_smic_flags(%struct.si_sm_data.179* %smic, i8 zeroext %conv91)
  br label %sw.epilog188

sw.bb94:                                          ; preds = %NodeBlock9
  %conv95 = zext i8 %call21 to i32
  %cmp96 = icmp ne i32 %conv95, 195
  br i1 %cmp96, label %if.then98, label %if.end99

if.then98:                                        ; preds = %sw.bb94
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.10.136, i32 0, i32 0))
  br label %cleanup

if.end99:                                         ; preds = %sw.bb94
  %call100 = call zeroext i8 @read_smic_data(%struct.si_sm_data.179* %smic)
  %conv101 = zext i8 %call100 to i32
  %cmp102 = icmp ne i32 %conv101, 0
  br i1 %cmp102, label %if.then104, label %if.else111

if.then104:                                       ; preds = %if.end99
  %12 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and105 = and i32 %12, 1
  %tobool106 = icmp ne i32 %and105, 0
  br i1 %tobool106, label %if.then107, label %if.end110

if.then107:                                       ; preds = %if.then104
  %conv108 = zext i8 %call100 to i32
  %call109 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.11.137, i32 0, i32 0), i32 %conv108)
  br label %if.end110

if.end110:                                        ; preds = %if.then107, %if.then104
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.12.138, i32 0, i32 0))
  br label %cleanup

if.else111:                                       ; preds = %if.end99
  %state112 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 6, i32* %state112, align 8, !tbaa !255
  br label %sw.epilog188

sw.bb114:                                         ; preds = %NodeBlock7
  %conv115 = zext i8 %call16 to i32
  %and116 = and i32 %conv115, 128
  %tobool117 = icmp ne i32 %and116, 0
  br i1 %tobool117, label %if.then118, label %cleanup

if.then118:                                       ; preds = %sw.bb114
  call void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext 68)
  %conv119 = zext i8 %call16 to i32
  %or120 = or i32 %conv119, 1
  %conv121 = trunc i32 %or120 to i8
  call void @write_smic_flags(%struct.si_sm_data.179* %smic, i8 zeroext %conv121)
  %state122 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 7, i32* %state122, align 8, !tbaa !255
  br label %sw.epilog188

sw.bb125:                                         ; preds = %NodeBlock7
  %conv126 = zext i8 %call21 to i32
  %cmp127 = icmp ne i32 %conv126, 196
  br i1 %cmp127, label %if.then129, label %if.end130

if.then129:                                       ; preds = %sw.bb125
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.13.139, i32 0, i32 0))
  br label %cleanup

if.end130:                                        ; preds = %sw.bb125
  %conv131 = zext i8 %call16 to i32
  %and132 = and i32 %conv131, 128
  %tobool133 = icmp ne i32 %and132, 0
  br i1 %tobool133, label %if.then134, label %cleanup

if.then134:                                       ; preds = %if.end130
  call void @read_next_byte.140(%struct.si_sm_data.179* %smic)
  call void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext 69)
  %conv135 = zext i8 %call16 to i32
  %or136 = or i32 %conv135, 1
  %conv137 = trunc i32 %or136 to i8
  call void @write_smic_flags(%struct.si_sm_data.179* %smic, i8 zeroext %conv137)
  %state138 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 8, i32* %state138, align 8, !tbaa !255
  br label %sw.epilog188

sw.bb141:                                         ; preds = %NodeBlock15
  %conv142 = zext i8 %call21 to i32
  %Pivot27 = icmp slt i32 %conv142, 198
  br i1 %Pivot27, label %LeafBlock22, label %LeafBlock24

LeafBlock24:                                      ; preds = %sw.bb141
  %SwitchLeaf25 = icmp eq i32 %conv142, 198
  br i1 %SwitchLeaf25, label %sw.bb143, label %sw.default

LeafBlock22:                                      ; preds = %sw.bb141
  %SwitchLeaf23 = icmp eq i32 %conv142, 197
  br i1 %SwitchLeaf23, label %sw.bb148, label %sw.default

sw.bb143:                                         ; preds = %LeafBlock24
  call void @read_next_byte.140(%struct.si_sm_data.179* %smic)
  call void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext 70)
  %conv144 = zext i8 %call16 to i32
  %or145 = or i32 %conv144, 1
  %conv146 = trunc i32 %or145 to i8
  call void @write_smic_flags(%struct.si_sm_data.179* %smic, i8 zeroext %conv146)
  %state147 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 9, i32* %state147, align 8, !tbaa !255
  br label %sw.epilog188

sw.bb148:                                         ; preds = %LeafBlock22
  %conv149 = zext i8 %call16 to i32
  %and150 = and i32 %conv149, 128
  %tobool151 = icmp ne i32 %and150, 0
  br i1 %tobool151, label %if.then152, label %cleanup

if.then152:                                       ; preds = %sw.bb148
  call void @read_next_byte.140(%struct.si_sm_data.179* %smic)
  call void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext 69)
  %conv153 = zext i8 %call16 to i32
  %or154 = or i32 %conv153, 1
  %conv155 = trunc i32 %or154 to i8
  call void @write_smic_flags(%struct.si_sm_data.179* %smic, i8 zeroext %conv155)
  %state156 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 8, i32* %state156, align 8, !tbaa !255
  br label %sw.epilog188

sw.default:                                       ; preds = %LeafBlock22, %LeafBlock24
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.14.141, i32 0, i32 0))
  br label %cleanup

sw.bb159:                                         ; preds = %NodeBlock13
  %conv160 = zext i8 %call21 to i32
  %cmp161 = icmp ne i32 %conv160, 192
  br i1 %cmp161, label %if.then163, label %if.end164

if.then163:                                       ; preds = %sw.bb159
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.15.142, i32 0, i32 0))
  br label %cleanup

if.end164:                                        ; preds = %sw.bb159
  %call165 = call zeroext i8 @read_smic_data(%struct.si_sm_data.179* %smic)
  %conv166 = zext i8 %call165 to i32
  %cmp167 = icmp ne i32 %conv166, 0
  br i1 %cmp167, label %if.then169, label %if.else176

if.then169:                                       ; preds = %if.end164
  %13 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and170 = and i32 %13, 1
  %tobool171 = icmp ne i32 %and170, 0
  br i1 %tobool171, label %if.then172, label %if.end175

if.then172:                                       ; preds = %if.then169
  %conv173 = zext i8 %call165 to i32
  %call174 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.16.143, i32 0, i32 0), i32 %conv173)
  br label %if.end175

if.end175:                                        ; preds = %if.then172, %if.then169
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.17.144, i32 0, i32 0))
  br label %cleanup

if.else176:                                       ; preds = %if.end164
  %state177 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 0, i32* %state177, align 8, !tbaa !255
  br label %cleanup

sw.bb178:                                         ; preds = %LeafBlock11
  %io179 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %14 = load %struct.si_sm_io*, %struct.si_sm_io** %io179, align 8, !tbaa !257
  %call180 = call i32 @init_smic_data(%struct.si_sm_data.179* %smic, %struct.si_sm_io* %14)
  br label %cleanup

sw.default181:                                    ; preds = %LeafBlock, %LeafBlock11
  %15 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and182 = and i32 %15, 1
  %tobool183 = icmp ne i32 %and182, 0
  br i1 %tobool183, label %if.then184, label %sw.epilog188

if.then184:                                       ; preds = %sw.default181
  %state185 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  %16 = load i32, i32* %state185, align 8, !tbaa !255
  %call186 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.18.145, i32 0, i32 0), i32 %16)
  call void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.19.146, i32 0, i32 0))
  br label %cleanup

sw.epilog188:                                     ; preds = %sw.default181, %if.then152, %sw.bb143, %if.then134, %if.then118, %if.else111, %if.end88, %if.end65, %if.end45, %sw.bb36
  %smic_timeout189 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 10
  store i64 2000000, i64* %smic_timeout189, align 8, !tbaa !264
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog188, %if.then184, %sw.bb178, %if.else176, %if.end175, %if.then163, %sw.default, %sw.bb148, %if.end130, %if.then129, %sw.bb114, %if.end110, %if.then98, %if.end76, %if.then75, %if.end55, %if.then54, %if.then44, %sw.bb, %if.end15, %if.then12, %if.then
  %retval.0 = phi i32 [ 5, %if.then ], [ 1, %if.then12 ], [ 1, %if.then184 ], [ 0, %sw.epilog188 ], [ 1, %if.then44 ], [ 1, %if.then54 ], [ 1, %if.then75 ], [ 1, %if.then98 ], [ 1, %if.end110 ], [ 1, %if.then129 ], [ 1, %sw.default ], [ 1, %if.then163 ], [ 1, %if.end175 ], [ 3, %if.else176 ], [ 5, %sw.bb178 ], [ 1, %if.end15 ], [ %., %sw.bb ], [ 1, %if.end55 ], [ 1, %if.end76 ], [ 1, %sw.bb114 ], [ 1, %if.end130 ], [ 1, %sw.bb148 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @smic_detect(%struct.si_sm_data.179* %smic) #0 {
entry:
  %call = call zeroext i8 @read_smic_flags(%struct.si_sm_data.179* %smic)
  %conv = zext i8 %call to i32
  %cmp = icmp eq i32 %conv, 255
  %. = select i1 %cmp, i32 1, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal void @smic_cleanup(%struct.si_sm_data.179* %kcs) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @smic_size() #0 {
entry:
  ret i32 208
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @read_smic_flags(%struct.si_sm_data.179* %smic) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !257
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !253
  %io1 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !257
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 2)
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @start_error_recovery.130(%struct.si_sm_data.179* %smic, i8* %reason) #3 {
entry:
  %error_retries = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 9
  %0 = load i32, i32* %error_retries, align 4, !tbaa !262
  %inc = add i32 %0, 1
  store i32 %inc, i32* %error_retries, align 4, !tbaa !262
  %error_retries1 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 9
  %1 = load i32, i32* %error_retries1, align 4, !tbaa !262
  %cmp = icmp ugt i32 %1, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.20.147, i32 0, i32 0), i8* %reason)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %state = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 10, i32* %state, align 8, !tbaa !255
  br label %if.end4

if.else:                                          ; preds = %entry
  %orig_write_count = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 5
  %3 = load i32, i32* %orig_write_count, align 8, !tbaa !260
  %write_count = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 4
  store i32 %3, i32* %write_count, align 4, !tbaa !259
  %write_pos = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !258
  %read_pos = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !261
  %state3 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 0
  store i32 1, i32* %state3, align 8, !tbaa !255
  %smic_timeout = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 10
  store i64 2000000, i64* %smic_timeout, align 8, !tbaa !264
  br label %if.end4

if.end4:                                          ; preds = %if.else, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @read_smic_status(%struct.si_sm_data.179* %smic) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !257
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !253
  %io1 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !257
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 1)
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_smic_control(%struct.si_sm_data.179* %smic, i8 zeroext %control) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !257
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !254
  %io1 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !257
  call void %1(%struct.si_sm_io* %2, i32 1, i8 zeroext %control)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_smic_flags(%struct.si_sm_data.179* %smic, i8 zeroext %flags) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !257
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !254
  %io1 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !257
  call void %1(%struct.si_sm_io* %2, i32 2, i8 zeroext %flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_next_byte.133(%struct.si_sm_data.179* %smic) #3 {
entry:
  %write_data = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 2
  %write_pos = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 3
  %0 = load i32, i32* %write_pos, align 8, !tbaa !258
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [80 x i8], [80 x i8]* %write_data, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !6
  call void @write_si_sm_data(%struct.si_sm_data.179* %smic, i8 zeroext %1)
  %write_pos1 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 3
  %2 = load i32, i32* %write_pos1, align 8, !tbaa !258
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %write_pos1, align 8, !tbaa !258
  %write_count = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 4
  %3 = load i32, i32* %write_count, align 4, !tbaa !259
  %dec = add nsw i32 %3, -1
  store i32 %dec, i32* %write_count, align 4, !tbaa !259
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @read_smic_data(%struct.si_sm_data.179* %smic) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !257
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !253
  %io1 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !257
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 0)
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @read_next_byte.140(%struct.si_sm_data.179* %smic) #3 {
entry:
  %read_pos = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  %0 = load i32, i32* %read_pos, align 4, !tbaa !261
  %cmp = icmp sge i32 %0, 80
  %call = call zeroext i8 @read_smic_data(%struct.si_sm_data.179* %smic)
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %truncated = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 8
  store i32 1, i32* %truncated, align 8, !tbaa !263
  br label %if.end

if.else:                                          ; preds = %entry
  %read_data = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 6
  %read_pos2 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  %1 = load i32, i32* %read_pos2, align 4, !tbaa !261
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [80 x i8], [80 x i8]* %read_data, i64 0, i64 %idxprom
  store i8 %call, i8* %arrayidx, align 1, !tbaa !6
  %read_pos3 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 7
  %2 = load i32, i32* %read_pos3, align 4, !tbaa !261
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %read_pos3, align 4, !tbaa !261
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_si_sm_data(%struct.si_sm_data.179* %smic, i8 zeroext %data) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !257
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !254
  %io1 = getelementptr inbounds %struct.si_sm_data.179, %struct.si_sm_data.179* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !257
  call void %1(%struct.si_sm_io* %2, i32 0, i8 zeroext %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_init_data(%struct.si_sm_data.269* %bt, %struct.si_sm_io* %io) #0 {
entry:
  %0 = bitcast %struct.si_sm_data.269* %bt to i8*
  %call = call i8* @__memset(i8* %0, i32 0, i64 624)
  %io1 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %1 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !265
  %cmp = icmp ne %struct.si_sm_io* %1, %io
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %io2 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  store %struct.si_sm_io* %io, %struct.si_sm_io** %io2, align 8, !tbaa !265
  %seq = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 1
  store i8 0, i8* %seq, align 4, !tbaa !267
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %state = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 0, i32* %state, align 8, !tbaa !268
  %complete = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 11
  store i32 0, i32* %complete, align 8, !tbaa !269
  %BT_CAP_req2rsp = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 13
  store i64 5000000, i64* %BT_CAP_req2rsp, align 8, !tbaa !270
  %BT_CAP_retries = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 14
  store i32 2, i32* %BT_CAP_retries, align 8, !tbaa !271
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_start_transaction(%struct.si_sm_data.269* %bt, i8* %data, i32 %size) #0 {
entry:
  %cmp = icmp ult i32 %size, 2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp ugt i32 %size, 272
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %state = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %0 = load i32, i32* %state, align 8, !tbaa !268
  %cmp4 = icmp eq i32 %0, 14
  br i1 %cmp4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end3
  %state7 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %1 = load i32, i32* %state7, align 8, !tbaa !268
  %cmp8 = icmp ne i32 %1, 0
  br i1 %cmp8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end6
  %2 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then11, label %if.end16

if.then11:                                        ; preds = %if.end10
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.202, i32 0, i32 0))
  %sub = sub i32 %size, 2
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.1.203, i32 0, i32 0), i32 %sub)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then11
  %i.0 = phi i32 [ 0, %if.then11 ], [ %inc, %for.body ]
  %cmp13 = icmp ult i32 %i.0, %size
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv = zext i8 %3 to i32
  %call14 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2.175, i32 0, i32 0), i32 %conv)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call15 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3.176, i32 0, i32 0))
  br label %if.end16

if.end16:                                         ; preds = %for.end, %if.end10
  %add = add i32 %size, 1
  %conv17 = trunc i32 %add to i8
  %write_data = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx18 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data, i64 0, i64 0
  store i8 %conv17, i8* %arrayidx18, align 8, !tbaa !6
  %4 = load i8, i8* %data, align 1, !tbaa !6
  %write_data19 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx20 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data19, i64 0, i64 1
  store i8 %4, i8* %arrayidx20, align 1, !tbaa !6
  %seq = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 1
  %5 = load i8, i8* %seq, align 4, !tbaa !267
  %inc21 = add i8 %5, 1
  store i8 %inc21, i8* %seq, align 4, !tbaa !267
  %write_data22 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx23 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data22, i64 0, i64 2
  store i8 %5, i8* %arrayidx23, align 2, !tbaa !6
  %write_data24 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arraydecay = getelementptr inbounds [274 x i8], [274 x i8]* %write_data24, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 3
  %add.ptr25 = getelementptr inbounds i8, i8* %data, i64 1
  %sub26 = sub i32 %size, 1
  %conv27 = zext i32 %sub26 to i64
  %call28 = call i8* @__memcpy(i8* %add.ptr, i8* %add.ptr25, i64 %conv27)
  %add29 = add i32 %size, 2
  %write_count = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 4
  store i32 %add29, i32* %write_count, align 4, !tbaa !272
  %error_retries = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 9
  store i32 0, i32* %error_retries, align 8, !tbaa !273
  %nonzero_status = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 10
  store i32 0, i32* %nonzero_status, align 4, !tbaa !274
  %truncated = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 7
  store i32 0, i32* %truncated, align 8, !tbaa !275
  %state30 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 1, i32* %state30, align 8, !tbaa !268
  %BT_CAP_req2rsp = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 13
  %6 = load i64, i64* %BT_CAP_req2rsp, align 8, !tbaa !270
  %timeout = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 8
  store i64 %6, i64* %timeout, align 8, !tbaa !276
  call void @force_result(%struct.si_sm_data.269* %bt, i8 zeroext -1)
  br label %cleanup

cleanup:                                          ; preds = %if.end16, %if.end6, %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end16 ], [ 199, %entry ], [ 200, %if.end ], [ 192, %if.end3 ], [ 213, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_get_result(%struct.si_sm_data.269* %bt, i8* %data, i32 %length) #0 {
entry:
  %read_count = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  %0 = load i32, i32* %read_count, align 4, !tbaa !277
  %sub = sub nsw i32 %0, 2
  %cmp = icmp slt i32 %sub, 3
  %cmp1 = icmp sgt i32 %sub, 272
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @force_result(%struct.si_sm_data.269* %bt, i8 zeroext -1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %msg_len.0 = phi i32 [ 3, %if.then ], [ %sub, %entry ]
  %read_data = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx = getelementptr inbounds [274 x i8], [274 x i8]* %read_data, i64 0, i64 1
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx2 = getelementptr inbounds i8, i8* %data, i64 0
  store i8 %1, i8* %arrayidx2, align 1, !tbaa !6
  %read_data3 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx4 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data3, i64 0, i64 3
  %2 = load i8, i8* %arrayidx4, align 1, !tbaa !6
  %arrayidx5 = getelementptr inbounds i8, i8* %data, i64 1
  store i8 %2, i8* %arrayidx5, align 1, !tbaa !6
  %cmp6 = icmp ult i32 %length, %msg_len.0
  br i1 %cmp6, label %if.then8, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.end
  %truncated = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 7
  %3 = load i32, i32* %truncated, align 8, !tbaa !275
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then8, label %if.else

if.then8:                                         ; preds = %lor.lhs.false7, %if.end
  %arrayidx9 = getelementptr inbounds i8, i8* %data, i64 2
  store i8 -58, i8* %arrayidx9, align 1, !tbaa !6
  br label %if.end13

if.else:                                          ; preds = %lor.lhs.false7
  %add.ptr = getelementptr inbounds i8, i8* %data, i64 2
  %read_data10 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arraydecay = getelementptr inbounds [274 x i8], [274 x i8]* %read_data10, i32 0, i32 0
  %add.ptr11 = getelementptr inbounds i8, i8* %arraydecay, i64 4
  %sub12 = sub nsw i32 %msg_len.0, 2
  %conv = sext i32 %sub12 to i64
  %call = call i8* @__memcpy(i8* %add.ptr, i8* %add.ptr11, i64 %conv)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then8
  %msg_len.1 = phi i32 [ 3, %if.then8 ], [ %msg_len.0, %if.else ]
  %4 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and = and i32 %4, 2
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %if.then15, label %if.end23

if.then15:                                        ; preds = %if.end13
  %call16 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.4.201, i32 0, i32 0), i32 %msg_len.1)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then15
  %i.0 = phi i32 [ 0, %if.then15 ], [ %inc, %for.body ]
  %cmp17 = icmp slt i32 %i.0, %msg_len.1
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx19 = getelementptr inbounds i8, i8* %data, i64 %idxprom
  %5 = load i8, i8* %arrayidx19, align 1, !tbaa !6
  %conv20 = zext i8 %5 to i32
  %call21 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2.175, i32 0, i32 0), i32 %conv20)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call22 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3.176, i32 0, i32 0))
  br label %if.end23

if.end23:                                         ; preds = %for.end, %if.end13
  ret i32 %msg_len.1
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_event(%struct.si_sm_data.269* %bt, i64 %time) #0 {
entry:
  %BT_CAP = alloca [8 x i8], align 1
  %GetBT_CAP = alloca [2 x i8], align 1
  %0 = bitcast [8 x i8]* %BT_CAP to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %io = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %1 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !265
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %1, i32 0, i32 0
  %2 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !253
  %io1 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %3 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !265
  %call = call zeroext i8 %2(%struct.si_sm_io* %3, i32 0)
  %conv = zext i8 %call to i32
  %nonzero_status = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 10
  %4 = load i32, i32* %nonzero_status, align 4, !tbaa !274
  %or = or i32 %4, %conv
  store i32 %or, i32* %nonzero_status, align 4, !tbaa !274
  %5 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and = and i32 %5, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %state = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %6 = load i32, i32* %state, align 8, !tbaa !268
  %7 = load i32, i32* @bt_event.last_printed, align 4, !tbaa !6
  %cmp = icmp ne i32 %6, %7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %state3 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %8 = load i32, i32* %state3, align 8, !tbaa !268
  %conv4 = trunc i32 %8 to i8
  %call5 = call i8* @state2txt(i8 zeroext %conv4)
  %call6 = call i8* @status2txt(i8 zeroext %call)
  %timeout = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 8
  %9 = load i64, i64* %timeout, align 8, !tbaa !276
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.5.164, i32 0, i32 0), i8* %call5, i8* %call6, i64 %9, i64 %time)
  %state8 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %10 = load i32, i32* %state8, align 8, !tbaa !268
  store i32 %10, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %state9 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %11 = load i32, i32* %state9, align 8, !tbaa !268
  %cmp10 = icmp ult i32 %11, 2
  br i1 %cmp10, label %land.lhs.true12, label %if.end17

land.lhs.true12:                                  ; preds = %if.end
  %conv13 = zext i8 %call to i32
  %and14 = and i32 %conv13, 8
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true12
  call void @drain_BMC2HOST(%struct.si_sm_data.269* %bt)
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

if.end17:                                         ; preds = %land.lhs.true12, %if.end
  %state18 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %12 = load i32, i32* %state18, align 8, !tbaa !268
  %cmp19 = icmp ne i32 %12, 0
  br i1 %cmp19, label %land.lhs.true21, label %if.end37

land.lhs.true21:                                  ; preds = %if.end17
  %state22 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %13 = load i32, i32* %state22, align 8, !tbaa !268
  %cmp23 = icmp ult i32 %13, 11
  br i1 %cmp23, label %if.then25, label %if.end37

if.then25:                                        ; preds = %land.lhs.true21
  %timeout26 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 8
  %14 = load i64, i64* %timeout26, align 8, !tbaa !276
  %sub = sub nsw i64 %14, %time
  store i64 %sub, i64* %timeout26, align 8, !tbaa !276
  %timeout27 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 8
  %15 = load i64, i64* %timeout27, align 8, !tbaa !276
  %cmp28 = icmp slt i64 %15, 0
  br i1 %cmp28, label %land.lhs.true30, label %if.end37

land.lhs.true30:                                  ; preds = %if.then25
  %state31 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %16 = load i32, i32* %state31, align 8, !tbaa !268
  %cmp32 = icmp ult i32 %16, 7
  br i1 %cmp32, label %if.then34, label %if.end37

if.then34:                                        ; preds = %land.lhs.true30
  %call35 = call i32 @error_recovery(%struct.si_sm_data.269* %bt, i8 zeroext %call, i8 zeroext -61)
  br label %cleanup

if.end37:                                         ; preds = %land.lhs.true30, %if.then25, %land.lhs.true21, %if.end17
  %state38 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %17 = load i32, i32* %state38, align 8, !tbaa !268
  %Pivot28 = icmp slt i32 %17, 7
  br i1 %Pivot28, label %NodeBlock9, label %NodeBlock25

NodeBlock25:                                      ; preds = %if.end37
  %Pivot26 = icmp slt i32 %17, 10
  br i1 %Pivot26, label %NodeBlock13, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %17, 13
  br i1 %Pivot24, label %NodeBlock17, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %17, 14
  br i1 %Pivot22, label %sw.bb197, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %17, 14
  br i1 %SwitchLeaf20, label %sw.bb148, label %sw.default

NodeBlock17:                                      ; preds = %NodeBlock23
  %Pivot18 = icmp slt i32 %17, 12
  br i1 %Pivot18, label %LeafBlock15, label %sw.bb191

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %17, 10
  br i1 %SwitchLeaf16, label %sw.bb186, label %sw.default

NodeBlock13:                                      ; preds = %NodeBlock25
  %Pivot14 = icmp slt i32 %17, 8
  br i1 %Pivot14, label %sw.bb156, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %17, 9
  br i1 %Pivot12, label %sw.bb158, label %sw.bb179

NodeBlock9:                                       ; preds = %if.end37
  %Pivot10 = icmp slt i32 %17, 3
  br i1 %Pivot10, label %NodeBlock1, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %17, 5
  br i1 %Pivot8, label %NodeBlock3, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %17, 6
  %conv115 = zext i8 %call to i32
  br i1 %Pivot6, label %sw.bb114, label %sw.bb124

NodeBlock3:                                       ; preds = %NodeBlock7
  %Pivot4 = icmp slt i32 %17, 4
  %conv95 = zext i8 %call to i32
  br i1 %Pivot4, label %sw.bb94, label %sw.bb101

NodeBlock1:                                       ; preds = %NodeBlock9
  %Pivot2 = icmp slt i32 %17, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %17, 2
  %conv60 = zext i8 %call to i32
  br i1 %Pivot, label %sw.bb59, label %sw.bb78

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %17, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %conv39 = zext i8 %call to i32
  %and40 = and i32 %conv39, 16
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then42, label %if.end45

if.then42:                                        ; preds = %sw.bb
  %io43 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %18 = load %struct.si_sm_io*, %struct.si_sm_io** %io43, align 8, !tbaa !265
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %18, i32 0, i32 1
  %19 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !254
  %io44 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %20 = load %struct.si_sm_io*, %struct.si_sm_io** %io44, align 8, !tbaa !265
  call void %19(%struct.si_sm_io* %20, i32 0, i8 zeroext 16)
  br label %cleanup

if.end45:                                         ; preds = %sw.bb
  %conv46 = zext i8 %call to i32
  %and47 = and i32 %conv46, 64
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then49, label %if.end53

if.then49:                                        ; preds = %if.end45
  %io50 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %21 = load %struct.si_sm_io*, %struct.si_sm_io** %io50, align 8, !tbaa !265
  %outputb51 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %21, i32 0, i32 1
  %22 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb51, align 8, !tbaa !254
  %io52 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %23 = load %struct.si_sm_io*, %struct.si_sm_io** %io52, align 8, !tbaa !265
  call void %22(%struct.si_sm_io* %23, i32 0, i8 zeroext 64)
  br label %if.end53

if.end53:                                         ; preds = %if.then49, %if.end45
  %BT_CAP_outreqs = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 12
  %24 = load i32, i32* %BT_CAP_outreqs, align 4, !tbaa !278
  %tobool54 = icmp ne i32 %24, 0
  br i1 %tobool54, label %if.end57, label %if.then55

if.then55:                                        ; preds = %if.end53
  %state56 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 12, i32* %state56, align 8, !tbaa !268
  br label %cleanup

if.end57:                                         ; preds = %if.end53
  %BT_CAP_req2rsp = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 13
  %25 = load i64, i64* %BT_CAP_req2rsp, align 8, !tbaa !270
  %timeout58 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 8
  store i64 %25, i64* %timeout58, align 8, !tbaa !276
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

sw.bb59:                                          ; preds = %NodeBlock
  %and61 = and i32 %conv60, 132
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %sw.bb59
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

if.end64:                                         ; preds = %sw.bb59
  %io65 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %26 = load %struct.si_sm_io*, %struct.si_sm_io** %io65, align 8, !tbaa !265
  %inputb66 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %26, i32 0, i32 0
  %27 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb66, align 8, !tbaa !253
  %io67 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %28 = load %struct.si_sm_io*, %struct.si_sm_io** %io67, align 8, !tbaa !265
  %call68 = call zeroext i8 %27(%struct.si_sm_io* %28, i32 0)
  %conv69 = zext i8 %call68 to i32
  %and70 = and i32 %conv69, 64
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %if.then72, label %if.end76

if.then72:                                        ; preds = %if.end64
  %io73 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %29 = load %struct.si_sm_io*, %struct.si_sm_io** %io73, align 8, !tbaa !265
  %outputb74 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %29, i32 0, i32 1
  %30 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb74, align 8, !tbaa !254
  %io75 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %31 = load %struct.si_sm_io*, %struct.si_sm_io** %io75, align 8, !tbaa !265
  call void %30(%struct.si_sm_io* %31, i32 0, i8 zeroext 64)
  br label %if.end76

if.end76:                                         ; preds = %if.then72, %if.end64
  %state77 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 2, i32* %state77, align 8, !tbaa !268
  br label %cleanup

sw.bb78:                                          ; preds = %NodeBlock
  %and80 = and i32 %conv60, 64
  %tobool81 = icmp ne i32 %and80, 0
  br i1 %tobool81, label %if.then82, label %if.end86

if.then82:                                        ; preds = %sw.bb78
  %io83 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %32 = load %struct.si_sm_io*, %struct.si_sm_io** %io83, align 8, !tbaa !265
  %outputb84 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %32, i32 0, i32 1
  %33 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb84, align 8, !tbaa !254
  %io85 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %34 = load %struct.si_sm_io*, %struct.si_sm_io** %io85, align 8, !tbaa !265
  call void %33(%struct.si_sm_io* %34, i32 0, i8 zeroext 64)
  br label %if.end86

if.end86:                                         ; preds = %if.then82, %sw.bb78
  %io87 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %35 = load %struct.si_sm_io*, %struct.si_sm_io** %io87, align 8, !tbaa !265
  %outputb88 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %35, i32 0, i32 1
  %36 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb88, align 8, !tbaa !254
  %io89 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %37 = load %struct.si_sm_io*, %struct.si_sm_io** %io89, align 8, !tbaa !265
  call void %36(%struct.si_sm_io* %37, i32 0, i8 zeroext 1)
  call void @write_all_bytes(%struct.si_sm_data.269* %bt)
  %io90 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %38 = load %struct.si_sm_io*, %struct.si_sm_io** %io90, align 8, !tbaa !265
  %outputb91 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %38, i32 0, i32 1
  %39 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb91, align 8, !tbaa !254
  %io92 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %40 = load %struct.si_sm_io*, %struct.si_sm_io** %io92, align 8, !tbaa !265
  call void %39(%struct.si_sm_io* %40, i32 0, i8 zeroext 4)
  %state93 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 3, i32* %state93, align 8, !tbaa !268
  br label %cleanup

sw.bb94:                                          ; preds = %NodeBlock3
  %and96 = and i32 %conv95, 132
  %tobool97 = icmp ne i32 %and96, 0
  br i1 %tobool97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %sw.bb94
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

if.end99:                                         ; preds = %sw.bb94
  %state100 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 4, i32* %state100, align 8, !tbaa !268
  br label %cleanup

sw.bb101:                                         ; preds = %NodeBlock3
  %and103 = and i32 %conv95, 8
  %tobool104 = icmp ne i32 %and103, 0
  br i1 %tobool104, label %if.end106, label %if.then105

if.then105:                                       ; preds = %sw.bb101
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

if.end106:                                        ; preds = %sw.bb101
  %io107 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %41 = load %struct.si_sm_io*, %struct.si_sm_io** %io107, align 8, !tbaa !265
  %outputb108 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %41, i32 0, i32 1
  %42 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb108, align 8, !tbaa !254
  %io109 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %43 = load %struct.si_sm_io*, %struct.si_sm_io** %io109, align 8, !tbaa !265
  call void %42(%struct.si_sm_io* %43, i32 0, i8 zeroext 64)
  %io110 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %44 = load %struct.si_sm_io*, %struct.si_sm_io** %io110, align 8, !tbaa !265
  %outputb111 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %44, i32 0, i32 1
  %45 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb111, align 8, !tbaa !254
  %io112 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %46 = load %struct.si_sm_io*, %struct.si_sm_io** %io112, align 8, !tbaa !265
  call void %45(%struct.si_sm_io* %46, i32 0, i8 zeroext 8)
  %state113 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 5, i32* %state113, align 8, !tbaa !268
  br label %cleanup

sw.bb114:                                         ; preds = %NodeBlock5
  %and116 = and i32 %conv115, 8
  %tobool117 = icmp ne i32 %and116, 0
  br i1 %tobool117, label %if.then118, label %if.end122

if.then118:                                       ; preds = %sw.bb114
  %io119 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %47 = load %struct.si_sm_io*, %struct.si_sm_io** %io119, align 8, !tbaa !265
  %outputb120 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %47, i32 0, i32 1
  %48 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb120, align 8, !tbaa !254
  %io121 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %49 = load %struct.si_sm_io*, %struct.si_sm_io** %io121, align 8, !tbaa !265
  call void %48(%struct.si_sm_io* %49, i32 0, i8 zeroext 8)
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

if.end122:                                        ; preds = %sw.bb114
  %state123 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 6, i32* %state123, align 8, !tbaa !268
  br label %cleanup

sw.bb124:                                         ; preds = %NodeBlock5
  %and126 = and i32 %conv115, 64
  %tobool127 = icmp ne i32 %and126, 0
  br i1 %tobool127, label %if.end132, label %if.then128

if.then128:                                       ; preds = %sw.bb124
  %io129 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %50 = load %struct.si_sm_io*, %struct.si_sm_io** %io129, align 8, !tbaa !265
  %outputb130 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %50, i32 0, i32 1
  %51 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb130, align 8, !tbaa !254
  %io131 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %52 = load %struct.si_sm_io*, %struct.si_sm_io** %io131, align 8, !tbaa !265
  call void %51(%struct.si_sm_io* %52, i32 0, i8 zeroext 64)
  br label %if.end132

if.end132:                                        ; preds = %if.then128, %sw.bb124
  %io133 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %53 = load %struct.si_sm_io*, %struct.si_sm_io** %io133, align 8, !tbaa !265
  %outputb134 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %53, i32 0, i32 1
  %54 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb134, align 8, !tbaa !254
  %io135 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %55 = load %struct.si_sm_io*, %struct.si_sm_io** %io135, align 8, !tbaa !265
  call void %54(%struct.si_sm_io* %55, i32 0, i8 zeroext 2)
  %call136 = call i32 @read_all_bytes(%struct.si_sm_data.269* %bt)
  %io137 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %56 = load %struct.si_sm_io*, %struct.si_sm_io** %io137, align 8, !tbaa !265
  %outputb138 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %56, i32 0, i32 1
  %57 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb138, align 8, !tbaa !254
  %io139 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %58 = load %struct.si_sm_io*, %struct.si_sm_io** %io139, align 8, !tbaa !265
  call void %57(%struct.si_sm_io* %58, i32 0, i8 zeroext 64)
  %tobool140 = icmp ne i32 %call136, 0
  br i1 %tobool140, label %if.end143, label %if.then141

if.then141:                                       ; preds = %if.end132
  %state142 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 4, i32* %state142, align 8, !tbaa !268
  br label %cleanup

if.end143:                                        ; preds = %if.end132
  %complete = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 11
  %59 = load i32, i32* %complete, align 8, !tbaa !269
  %state144 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 %59, i32* %state144, align 8, !tbaa !268
  %state145 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %60 = load i32, i32* %state145, align 8, !tbaa !268
  %cmp146 = icmp eq i32 %60, 0
  %61 = zext i1 %cmp146 to i64
  %cond = select i1 %cmp146, i32 3, i32 0
  br label %cleanup

sw.bb148:                                         ; preds = %LeafBlock19
  %conv149 = zext i8 %call to i32
  %and150 = and i32 %conv149, 128
  %tobool151 = icmp ne i32 %and150, 0
  br i1 %tobool151, label %cleanup, label %if.then152

if.then152:                                       ; preds = %sw.bb148
  call void @reset_flags(%struct.si_sm_data.269* %bt)
  %io153 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %62 = load %struct.si_sm_io*, %struct.si_sm_io** %io153, align 8, !tbaa !265
  %call154 = call i32 @bt_init_data(%struct.si_sm_data.269* %bt, %struct.si_sm_io* %62)
  br label %cleanup

sw.bb156:                                         ; preds = %NodeBlock13
  call void @reset_flags(%struct.si_sm_data.269* %bt)
  call void @drain_BMC2HOST(%struct.si_sm_data.269* %bt)
  %state157 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 8, i32* %state157, align 8, !tbaa !268
  br label %cleanup

sw.bb158:                                         ; preds = %NodeBlock11
  %io159 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %63 = load %struct.si_sm_io*, %struct.si_sm_io** %io159, align 8, !tbaa !265
  %outputb160 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %63, i32 0, i32 1
  %64 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb160, align 8, !tbaa !254
  %io161 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %65 = load %struct.si_sm_io*, %struct.si_sm_io** %io161, align 8, !tbaa !265
  call void %64(%struct.si_sm_io* %65, i32 0, i8 zeroext 1)
  %io162 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %66 = load %struct.si_sm_io*, %struct.si_sm_io** %io162, align 8, !tbaa !265
  %outputb163 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %66, i32 0, i32 1
  %67 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb163, align 8, !tbaa !254
  %io164 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %68 = load %struct.si_sm_io*, %struct.si_sm_io** %io164, align 8, !tbaa !265
  call void %67(%struct.si_sm_io* %68, i32 1, i8 zeroext 3)
  %io165 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %69 = load %struct.si_sm_io*, %struct.si_sm_io** %io165, align 8, !tbaa !265
  %outputb166 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %69, i32 0, i32 1
  %70 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb166, align 8, !tbaa !254
  %io167 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %71 = load %struct.si_sm_io*, %struct.si_sm_io** %io167, align 8, !tbaa !265
  call void %70(%struct.si_sm_io* %71, i32 1, i8 zeroext 24)
  %io168 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %72 = load %struct.si_sm_io*, %struct.si_sm_io** %io168, align 8, !tbaa !265
  %outputb169 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %72, i32 0, i32 1
  %73 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb169, align 8, !tbaa !254
  %io170 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %74 = load %struct.si_sm_io*, %struct.si_sm_io** %io170, align 8, !tbaa !265
  call void %73(%struct.si_sm_io* %74, i32 1, i8 zeroext 42)
  %io171 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %75 = load %struct.si_sm_io*, %struct.si_sm_io** %io171, align 8, !tbaa !265
  %outputb172 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %75, i32 0, i32 1
  %76 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb172, align 8, !tbaa !254
  %io173 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %77 = load %struct.si_sm_io*, %struct.si_sm_io** %io173, align 8, !tbaa !265
  call void %76(%struct.si_sm_io* %77, i32 1, i8 zeroext 3)
  %io174 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %78 = load %struct.si_sm_io*, %struct.si_sm_io** %io174, align 8, !tbaa !265
  %outputb175 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %78, i32 0, i32 1
  %79 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb175, align 8, !tbaa !254
  %io176 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %80 = load %struct.si_sm_io*, %struct.si_sm_io** %io176, align 8, !tbaa !265
  call void %79(%struct.si_sm_io* %80, i32 0, i8 zeroext 4)
  %timeout177 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 8
  store i64 6000000, i64* %timeout177, align 8, !tbaa !276
  %state178 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 9, i32* %state178, align 8, !tbaa !268
  br label %cleanup

sw.bb179:                                         ; preds = %NodeBlock11
  %timeout180 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 8
  %81 = load i64, i64* %timeout180, align 8, !tbaa !276
  %cmp181 = icmp sgt i64 %81, 0
  br i1 %cmp181, label %cleanup, label %if.end184

if.end184:                                        ; preds = %sw.bb179
  call void @drain_BMC2HOST(%struct.si_sm_data.269* %bt)
  %state185 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 10, i32* %state185, align 8, !tbaa !268
  br label %cleanup

sw.bb186:                                         ; preds = %LeafBlock15
  %read_count = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  store i32 0, i32* %read_count, align 4, !tbaa !277
  %nonzero_status187 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 10
  store i32 0, i32* %nonzero_status187, align 4, !tbaa !274
  %BT_CAP_req2rsp188 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 13
  %82 = load i64, i64* %BT_CAP_req2rsp188, align 8, !tbaa !270
  %timeout189 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 8
  store i64 %82, i64* %timeout189, align 8, !tbaa !276
  %state190 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 1, i32* %state190, align 8, !tbaa !268
  br label %cleanup

sw.bb191:                                         ; preds = %NodeBlock17
  %BT_CAP_outreqs192 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 12
  store i32 1, i32* %BT_CAP_outreqs192, align 4, !tbaa !278
  %83 = bitcast [2 x i8]* %GetBT_CAP to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %83) #7
  %84 = bitcast [2 x i8]* %GetBT_CAP to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %84, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @bt_event.GetBT_CAP, i32 0, i32 0), i64 2, i32 1, i1 false)
  %state193 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 0, i32* %state193, align 8, !tbaa !268
  %arraydecay = getelementptr inbounds [2 x i8], [2 x i8]* %GetBT_CAP, i32 0, i32 0
  %call194 = call i32 @bt_start_transaction(%struct.si_sm_data.269* %bt, i8* %arraydecay, i32 2)
  %85 = bitcast [2 x i8]* %GetBT_CAP to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %85) #7
  %complete195 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 11
  store i32 13, i32* %complete195, align 8, !tbaa !269
  %state196 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 1, i32* %state196, align 8, !tbaa !268
  br label %cleanup

sw.bb197:                                         ; preds = %NodeBlock21
  %arraydecay198 = getelementptr inbounds [8 x i8], [8 x i8]* %BT_CAP, i32 0, i32 0
  %call199 = call i32 @bt_get_result(%struct.si_sm_data.269* %bt, i8* %arraydecay198, i32 8)
  %io200 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %86 = load %struct.si_sm_io*, %struct.si_sm_io** %io200, align 8, !tbaa !265
  %call201 = call i32 @bt_init_data(%struct.si_sm_data.269* %bt, %struct.si_sm_io* %86)
  %cmp202 = icmp eq i32 %call199, 8
  br i1 %cmp202, label %land.lhs.true204, label %if.else

land.lhs.true204:                                 ; preds = %sw.bb197
  %arrayidx = getelementptr inbounds [8 x i8], [8 x i8]* %BT_CAP, i64 0, i64 2
  %87 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %tobool205 = icmp ne i8 %87, 0
  br i1 %tobool205, label %if.else, label %if.then206

if.then206:                                       ; preds = %land.lhs.true204
  %arrayidx207 = getelementptr inbounds [8 x i8], [8 x i8]* %BT_CAP, i64 0, i64 3
  %88 = load i8, i8* %arrayidx207, align 1, !tbaa !6
  %conv208 = zext i8 %88 to i32
  %BT_CAP_outreqs209 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 12
  store i32 %conv208, i32* %BT_CAP_outreqs209, align 4, !tbaa !278
  %arrayidx210 = getelementptr inbounds [8 x i8], [8 x i8]* %BT_CAP, i64 0, i64 6
  %89 = load i8, i8* %arrayidx210, align 1, !tbaa !6
  %conv211 = zext i8 %89 to i64
  %mul = mul nsw i64 %conv211, 1000000
  %BT_CAP_req2rsp212 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 13
  store i64 %mul, i64* %BT_CAP_req2rsp212, align 8, !tbaa !270
  %arrayidx213 = getelementptr inbounds [8 x i8], [8 x i8]* %BT_CAP, i64 0, i64 7
  %90 = load i8, i8* %arrayidx213, align 1, !tbaa !6
  %conv214 = zext i8 %90 to i32
  %BT_CAP_retries = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 14
  store i32 %conv214, i32* %BT_CAP_retries, align 8, !tbaa !271
  br label %if.end216

if.else:                                          ; preds = %land.lhs.true204, %sw.bb197
  %call215 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.6.165, i32 0, i32 0))
  br label %if.end216

if.end216:                                        ; preds = %if.else, %if.then206
  %BT_CAP_outreqs217 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 12
  %91 = load i32, i32* %BT_CAP_outreqs217, align 4, !tbaa !278
  %tobool218 = icmp ne i32 %91, 0
  br i1 %tobool218, label %if.end221, label %if.then219

if.then219:                                       ; preds = %if.end216
  %BT_CAP_outreqs220 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 12
  store i32 1, i32* %BT_CAP_outreqs220, align 4, !tbaa !278
  br label %if.end221

if.end221:                                        ; preds = %if.then219, %if.end216
  %BT_CAP_req2rsp222 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 13
  %92 = load i64, i64* %BT_CAP_req2rsp222, align 8, !tbaa !270
  %div = sdiv i64 %92, 1000000
  %BT_CAP_retries223 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 14
  %93 = load i32, i32* %BT_CAP_retries223, align 8, !tbaa !271
  %call224 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.7.166, i32 0, i32 0), i64 %div, i32 %93)
  %BT_CAP_req2rsp225 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 13
  %94 = load i64, i64* %BT_CAP_req2rsp225, align 8, !tbaa !270
  %timeout226 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 8
  store i64 %94, i64* %timeout226, align 8, !tbaa !276
  br label %cleanup

sw.default:                                       ; preds = %LeafBlock, %LeafBlock15, %LeafBlock19
  %call227 = call i32 @error_recovery(%struct.si_sm_data.269* %bt, i8 zeroext %call, i8 zeroext -1)
  br label %cleanup

cleanup:                                          ; preds = %sw.default, %if.end221, %sw.bb191, %sw.bb186, %if.end184, %sw.bb179, %sw.bb158, %sw.bb156, %if.then152, %sw.bb148, %if.end143, %if.then141, %if.end122, %if.then118, %if.end106, %if.then105, %if.end99, %if.then98, %if.end86, %if.end76, %if.then63, %if.end57, %if.then55, %if.then42, %if.then34, %if.then16
  %retval.0 = phi i32 [ 1, %if.then16 ], [ %call35, %if.then34 ], [ 6, %if.then42 ], [ 4, %if.end57 ], [ 0, %if.then55 ], [ %call227, %sw.default ], [ 1, %if.then63 ], [ 0, %if.end76 ], [ 0, %if.end86 ], [ 1, %if.then98 ], [ 0, %if.end99 ], [ 0, %if.end106 ], [ 1, %if.then105 ], [ 1, %if.then118 ], [ 0, %if.end122 ], [ %cond, %if.end143 ], [ 0, %if.then141 ], [ 1, %sw.bb156 ], [ 1, %sw.bb158 ], [ 1, %if.end184 ], [ 1, %sw.bb186 ], [ 1, %sw.bb191 ], [ 0, %if.end221 ], [ 1, %if.then152 ], [ 1, %sw.bb148 ], [ 1, %sw.bb179 ]
  %95 = bitcast [8 x i8]* %BT_CAP to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %95) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_detect(%struct.si_sm_data.269* %bt) #0 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !265
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !253
  %io1 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !265
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 0)
  %conv = zext i8 %call to i32
  %cmp = icmp eq i32 %conv, 255
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %io3 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %3 = load %struct.si_sm_io*, %struct.si_sm_io** %io3, align 8, !tbaa !265
  %inputb4 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %3, i32 0, i32 0
  %4 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb4, align 8, !tbaa !253
  %io5 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %5 = load %struct.si_sm_io*, %struct.si_sm_io** %io5, align 8, !tbaa !265
  %call6 = call zeroext i8 %4(%struct.si_sm_io* %5, i32 2)
  %conv7 = zext i8 %call6 to i32
  %cmp8 = icmp eq i32 %conv7, 255
  br i1 %cmp8, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  call void @reset_flags(%struct.si_sm_data.269* %bt)
  br label %return

return:                                           ; preds = %if.end, %land.lhs.true
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @bt_cleanup(%struct.si_sm_data.269* %bt) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_size() #0 {
entry:
  ret i32 624
}

; Function Attrs: nounwind uwtable
define internal void @reset_flags(%struct.si_sm_data.269* %bt) #0 {
entry:
  %0 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %io = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %1 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !265
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %1, i32 0, i32 0
  %2 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !253
  %io1 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %3 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !265
  %call = call zeroext i8 %2(%struct.si_sm_io* %3, i32 0)
  %call2 = call i8* @status2txt(i8 zeroext %call)
  %call3 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.48.155, i32 0, i32 0), i8* %call2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %io4 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %4 = load %struct.si_sm_io*, %struct.si_sm_io** %io4, align 8, !tbaa !265
  %inputb5 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %4, i32 0, i32 0
  %5 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb5, align 8, !tbaa !253
  %io6 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %6 = load %struct.si_sm_io*, %struct.si_sm_io** %io6, align 8, !tbaa !265
  %call7 = call zeroext i8 %5(%struct.si_sm_io* %6, i32 0)
  %conv = zext i8 %call7 to i32
  %and = and i32 %conv, 64
  %tobool8 = icmp ne i32 %and, 0
  br i1 %tobool8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %io10 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %7 = load %struct.si_sm_io*, %struct.si_sm_io** %io10, align 8, !tbaa !265
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %7, i32 0, i32 1
  %8 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !254
  %io11 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %9 = load %struct.si_sm_io*, %struct.si_sm_io** %io11, align 8, !tbaa !265
  call void %8(%struct.si_sm_io* %9, i32 0, i8 zeroext 64)
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end
  %io13 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %10 = load %struct.si_sm_io*, %struct.si_sm_io** %io13, align 8, !tbaa !265
  %outputb14 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %10, i32 0, i32 1
  %11 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb14, align 8, !tbaa !254
  %io15 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %12 = load %struct.si_sm_io*, %struct.si_sm_io** %io15, align 8, !tbaa !265
  call void %11(%struct.si_sm_io* %12, i32 0, i8 zeroext 1)
  %io16 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %13 = load %struct.si_sm_io*, %struct.si_sm_io** %io16, align 8, !tbaa !265
  %outputb17 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %13, i32 0, i32 1
  %14 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb17, align 8, !tbaa !254
  %io18 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %15 = load %struct.si_sm_io*, %struct.si_sm_io** %io18, align 8, !tbaa !265
  call void %14(%struct.si_sm_io* %15, i32 0, i8 zeroext 16)
  %io19 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %16 = load %struct.si_sm_io*, %struct.si_sm_io** %io19, align 8, !tbaa !265
  %outputb20 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %16, i32 0, i32 1
  %17 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb20, align 8, !tbaa !254
  %io21 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %18 = load %struct.si_sm_io*, %struct.si_sm_io** %io21, align 8, !tbaa !265
  call void %17(%struct.si_sm_io* %18, i32 2, i8 zeroext -128)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @status2txt(i8 zeroext %status) #0 {
entry:
  %call = call i8* @strcpy(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23.156, i32 0, i32 0))
  %conv = zext i8 %status to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24.157, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %conv2 = zext i8 %status to i32
  %and3 = and i32 %conv2, 64
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.25.158, i32 0, i32 0))
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %conv8 = zext i8 %status to i32
  %and9 = and i32 %conv8, 32
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end7
  %call12 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.26.159, i32 0, i32 0))
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end7
  %conv14 = zext i8 %status to i32
  %and15 = and i32 %conv14, 16
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end13
  %call18 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.160, i32 0, i32 0))
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end13
  %conv20 = zext i8 %status to i32
  %and21 = and i32 %conv20, 8
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end19
  %call24 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.28.161, i32 0, i32 0))
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end19
  %conv26 = zext i8 %status to i32
  %and27 = and i32 %conv26, 4
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end25
  %call30 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.29.162, i32 0, i32 0))
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end25
  %call32 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.30.163, i32 0, i32 0))
  ret i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0)
}

declare i8* @strcpy(i8*, i8*) #1

declare i8* @strcat(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i8* @state2txt(i8 zeroext %state) #0 {
entry:
  %conv = zext i8 %state to i32
  %Pivot28 = icmp slt i32 %conv, 7
  br i1 %Pivot28, label %NodeBlock9, label %NodeBlock25

NodeBlock25:                                      ; preds = %entry
  %Pivot26 = icmp slt i32 %conv, 10
  br i1 %Pivot26, label %NodeBlock13, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %conv, 13
  br i1 %Pivot24, label %NodeBlock17, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %conv, 14
  br i1 %Pivot22, label %return, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %conv, 14
  br i1 %SwitchLeaf20, label %return, label %sw.epilog

NodeBlock17:                                      ; preds = %NodeBlock23
  %Pivot18 = icmp slt i32 %conv, 12
  br i1 %Pivot18, label %LeafBlock15, label %return

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf16, label %return, label %sw.epilog

NodeBlock13:                                      ; preds = %NodeBlock25
  %Pivot14 = icmp slt i32 %conv, 8
  br i1 %Pivot14, label %return, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %conv, 9
  %. = select i1 %Pivot12, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.16.186, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17.187, i32 0, i32 0)
  br label %return

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %conv, 3
  br i1 %Pivot10, label %NodeBlock1, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %conv, 5
  br i1 %Pivot8, label %NodeBlock3, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %conv, 6
  %.29 = select i1 %Pivot6, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.13.188, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.14.189, i32 0, i32 0)
  br label %return

NodeBlock3:                                       ; preds = %NodeBlock7
  %Pivot4 = icmp slt i32 %conv, 4
  %.30 = select i1 %Pivot4, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.11.190, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.12.191, i32 0, i32 0)
  br label %return

NodeBlock1:                                       ; preds = %NodeBlock9
  %Pivot2 = icmp slt i32 %conv, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %conv, 2
  %.31 = select i1 %Pivot, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.9.192, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.10.193, i32 0, i32 0)
  br label %return

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %conv, 0
  br i1 %SwitchLeaf, label %return, label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock15, %LeafBlock19
  br label %return

return:                                           ; preds = %sw.epilog, %LeafBlock, %NodeBlock, %NodeBlock3, %NodeBlock5, %NodeBlock11, %NodeBlock13, %LeafBlock15, %NodeBlock17, %LeafBlock19, %NodeBlock21
  %retval.0 = phi i8* [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.22.194, i32 0, i32 0), %sw.epilog ], [ %., %NodeBlock11 ], [ %.29, %NodeBlock5 ], [ %.30, %NodeBlock3 ], [ %.31, %NodeBlock ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.8.195, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([7 x i8], [7 x i8]* @.str.15.196, i32 0, i32 0), %NodeBlock13 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.18.197, i32 0, i32 0), %LeafBlock15 ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.19.198, i32 0, i32 0), %LeafBlock19 ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.20.199, i32 0, i32 0), %NodeBlock17 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.21.200, i32 0, i32 0), %NodeBlock21 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @drain_BMC2HOST(%struct.si_sm_data.269* %bt) #0 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !265
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !253
  %io1 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !265
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 0)
  %conv = zext i8 %call to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %io2 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %3 = load %struct.si_sm_io*, %struct.si_sm_io** %io2, align 8, !tbaa !265
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %3, i32 0, i32 1
  %4 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !254
  %io3 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %5 = load %struct.si_sm_io*, %struct.si_sm_io** %io3, align 8, !tbaa !265
  call void %4(%struct.si_sm_io* %5, i32 0, i8 zeroext 64)
  %io4 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %6 = load %struct.si_sm_io*, %struct.si_sm_io** %io4, align 8, !tbaa !265
  %outputb5 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %6, i32 0, i32 1
  %7 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb5, align 8, !tbaa !254
  %io6 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %8 = load %struct.si_sm_io*, %struct.si_sm_io** %io6, align 8, !tbaa !265
  call void %7(%struct.si_sm_io* %8, i32 0, i8 zeroext 8)
  %io7 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %9 = load %struct.si_sm_io*, %struct.si_sm_io** %io7, align 8, !tbaa !265
  %inputb8 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %9, i32 0, i32 0
  %10 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb8, align 8, !tbaa !253
  %io9 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %11 = load %struct.si_sm_io*, %struct.si_sm_io** %io9, align 8, !tbaa !265
  %call10 = call zeroext i8 %10(%struct.si_sm_io* %11, i32 0)
  %io11 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %12 = load %struct.si_sm_io*, %struct.si_sm_io** %io11, align 8, !tbaa !265
  %outputb12 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %12, i32 0, i32 1
  %13 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb12, align 8, !tbaa !254
  %io13 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %14 = load %struct.si_sm_io*, %struct.si_sm_io** %io13, align 8, !tbaa !265
  call void %13(%struct.si_sm_io* %14, i32 0, i8 zeroext 8)
  %io14 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %15 = load %struct.si_sm_io*, %struct.si_sm_io** %io14, align 8, !tbaa !265
  %outputb15 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %15, i32 0, i32 1
  %16 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb15, align 8, !tbaa !254
  %io16 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %17 = load %struct.si_sm_io*, %struct.si_sm_io** %io16, align 8, !tbaa !265
  call void %16(%struct.si_sm_io* %17, i32 0, i8 zeroext 2)
  %18 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %tobool17 = icmp ne i32 %18, 0
  br i1 %tobool17, label %if.then18, label %if.end25

if.then18:                                        ; preds = %if.end
  %io19 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %19 = load %struct.si_sm_io*, %struct.si_sm_io** %io19, align 8, !tbaa !265
  %inputb20 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %19, i32 0, i32 0
  %20 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb20, align 8, !tbaa !253
  %io21 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %21 = load %struct.si_sm_io*, %struct.si_sm_io** %io21, align 8, !tbaa !265
  %call22 = call zeroext i8 %20(%struct.si_sm_io* %21, i32 0)
  %call23 = call i8* @status2txt(i8 zeroext %call22)
  %call24 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.31.184, i32 0, i32 0), i8* %call23)
  br label %if.end25

if.end25:                                         ; preds = %if.then18, %if.end
  %io26 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %22 = load %struct.si_sm_io*, %struct.si_sm_io** %io26, align 8, !tbaa !265
  %inputb27 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %22, i32 0, i32 0
  %23 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb27, align 8, !tbaa !253
  %io28 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %24 = load %struct.si_sm_io*, %struct.si_sm_io** %io28, align 8, !tbaa !265
  %call29 = call zeroext i8 %23(%struct.si_sm_io* %24, i32 1)
  %conv30 = zext i8 %call29 to i32
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end25
  %i.0 = phi i32 [ 0, %if.end25 ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, %conv30
  %io32 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %25 = load %struct.si_sm_io*, %struct.si_sm_io** %io32, align 8, !tbaa !265
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %inputb33 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %25, i32 0, i32 0
  %26 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb33, align 8, !tbaa !253
  %io34 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %27 = load %struct.si_sm_io*, %struct.si_sm_io** %io34, align 8, !tbaa !265
  %call35 = call zeroext i8 %26(%struct.si_sm_io* %27, i32 1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %outputb37 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %25, i32 0, i32 1
  %28 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb37, align 8, !tbaa !254
  %io38 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %29 = load %struct.si_sm_io*, %struct.si_sm_io** %io38, align 8, !tbaa !265
  call void %28(%struct.si_sm_io* %29, i32 0, i8 zeroext 64)
  %30 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %tobool39 = icmp ne i32 %30, 0
  br i1 %tobool39, label %if.then40, label %cleanup.cont

if.then40:                                        ; preds = %for.end
  %add = add nsw i32 %conv30, 1
  %call41 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.32.185, i32 0, i32 0), i32 %add)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then40, %for.end, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %entry ], [ 0, %if.then40 ], [ 0, %for.end ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @error_recovery(%struct.si_sm_data.269* %bt, i8 zeroext %status, i8 zeroext %cCode) #0 {
entry:
  %BT_CAP_req2rsp = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 13
  %0 = load i64, i64* %BT_CAP_req2rsp, align 8, !tbaa !270
  %timeout = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 8
  store i64 %0, i64* %timeout, align 8, !tbaa !276
  %conv = zext i8 %cCode to i32
  %SwitchLeaf = icmp eq i32 %conv, 195
  %reason.0 = select i1 %SwitchLeaf, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.33.177, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.34.178, i32 0, i32 0)
  %state = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  %1 = load i32, i32* %state, align 8, !tbaa !268
  %conv1 = trunc i32 %1 to i8
  %call = call i8* @state2txt(i8 zeroext %conv1)
  %call2 = call i8* @status2txt(i8 zeroext %status)
  %call3 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.35.179, i32 0, i32 0), i8* %reason.0, i8* %call, i8* %call2)
  %error_retries = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 9
  %2 = load i32, i32* %error_retries, align 8, !tbaa !273
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %error_retries, align 8, !tbaa !273
  %error_retries4 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 9
  %3 = load i32, i32* %error_retries4, align 8, !tbaa !273
  %BT_CAP_retries = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 14
  %4 = load i32, i32* %BT_CAP_retries, align 8, !tbaa !271
  %cmp = icmp slt i32 %3, %4
  %BT_CAP_retries6 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 14
  %5 = load i32, i32* %BT_CAP_retries6, align 8, !tbaa !271
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %error_retries7 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 9
  %6 = load i32, i32* %error_retries7, align 8, !tbaa !273
  %sub = sub nsw i32 %5, %6
  %call8 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.36.180, i32 0, i32 0), i32 %sub)
  %state9 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 10, i32* %state9, align 8, !tbaa !268
  br label %cleanup

if.end:                                           ; preds = %entry
  %call11 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.37.181, i32 0, i32 0), i32 %5)
  %nonzero_status = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 10
  %7 = load i32, i32* %nonzero_status, align 4, !tbaa !274
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.end
  %call13 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.38.182, i32 0, i32 0))
  br label %if.end24

if.else:                                          ; preds = %if.end
  %seq = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 1
  %8 = load i8, i8* %seq, align 4, !tbaa !267
  %conv14 = zext i8 %8 to i32
  %BT_CAP_retries15 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 14
  %9 = load i32, i32* %BT_CAP_retries15, align 8, !tbaa !271
  %and = and i32 %9, 255
  %conv16 = trunc i32 %and to i8
  %conv17 = zext i8 %conv16 to i32
  %cmp18 = icmp sle i32 %conv14, %conv17
  br i1 %cmp18, label %if.then20, label %if.end24

if.then20:                                        ; preds = %if.else
  %call21 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.39.183, i32 0, i32 0))
  %state22 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 7, i32* %state22, align 8, !tbaa !268
  br label %cleanup

if.end24:                                         ; preds = %if.else, %if.then12
  %state25 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 0, i32* %state25, align 8, !tbaa !268
  %conv26 = zext i8 %cCode to i32
  %SwitchLeaf3 = icmp eq i32 %conv26, 195
  br i1 %SwitchLeaf3, label %sw.bb27, label %sw.epilog35

sw.bb27:                                          ; preds = %if.end24
  %conv28 = zext i8 %status to i32
  %and29 = and i32 %conv28, 128
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.then31, label %sw.epilog35

if.then31:                                        ; preds = %sw.bb27
  %state32 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 0
  store i32 14, i32* %state32, align 8, !tbaa !268
  br label %sw.epilog35

sw.epilog35:                                      ; preds = %if.then31, %sw.bb27, %if.end24
  %cCode.addr.1 = phi i8 [ -64, %if.then31 ], [ %cCode, %sw.bb27 ], [ %cCode, %if.end24 ]
  call void @force_result(%struct.si_sm_data.269* %bt, i8 zeroext %cCode.addr.1)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog35, %if.then20, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 0, %if.then20 ], [ 3, %sw.epilog35 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_all_bytes(%struct.si_sm_data.269* %bt) #3 {
entry:
  %0 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %write_count = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 4
  %1 = load i32, i32* %write_count, align 4, !tbaa !272
  %seq = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 1
  %2 = load i8, i8* %seq, align 4, !tbaa !267
  %conv = zext i8 %2 to i32
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.40.174, i32 0, i32 0), i32 %1, i32 %conv)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %write_count1 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 4
  %3 = load i32, i32* %write_count1, align 4, !tbaa !272
  %cmp = icmp slt i32 %i.0, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %write_data = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [274 x i8], [274 x i8]* %write_data, i64 0, i64 %idxprom
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv3 = zext i8 %4 to i32
  %call4 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2.175, i32 0, i32 0), i32 %conv3)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call5 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3.176, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  br label %for.cond6

for.cond6:                                        ; preds = %for.body10, %if.end
  %i.1 = phi i32 [ 0, %if.end ], [ %inc16, %for.body10 ]
  %write_count7 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 4
  %5 = load i32, i32* %write_count7, align 4, !tbaa !272
  %cmp8 = icmp slt i32 %i.1, %5
  br i1 %cmp8, label %for.body10, label %for.end17

for.body10:                                       ; preds = %for.cond6
  %io = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %6 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !265
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %6, i32 0, i32 1
  %7 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !254
  %io11 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %8 = load %struct.si_sm_io*, %struct.si_sm_io** %io11, align 8, !tbaa !265
  %write_data12 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %idxprom13 = sext i32 %i.1 to i64
  %arrayidx14 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data12, i64 0, i64 %idxprom13
  %9 = load i8, i8* %arrayidx14, align 1, !tbaa !6
  call void %7(%struct.si_sm_io* %8, i32 1, i8 zeroext %9)
  %inc16 = add nsw i32 %i.1, 1
  br label %for.cond6

for.end17:                                        ; preds = %for.cond6
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @read_all_bytes(%struct.si_sm_data.269* %bt) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !265
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !253
  %io1 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !265
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 1)
  %read_data = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx = getelementptr inbounds [274 x i8], [274 x i8]* %read_data, i64 0, i64 0
  store i8 %call, i8* %arrayidx, align 8, !tbaa !6
  %read_data2 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx3 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data2, i64 0, i64 0
  %3 = load i8, i8* %arrayidx3, align 8, !tbaa !6
  %conv = zext i8 %3 to i32
  %read_count = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  store i32 %conv, i32* %read_count, align 4, !tbaa !277
  %read_count4 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  %4 = load i32, i32* %read_count4, align 4, !tbaa !277
  %cmp = icmp slt i32 %4, 4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %read_count6 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  %5 = load i32, i32* %read_count6, align 4, !tbaa !277
  %cmp7 = icmp sge i32 %5, 272
  br i1 %cmp7, label %if.then, label %if.end12

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and = and i32 %6, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.then
  %read_count10 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  %7 = load i32, i32* %read_count10, align 4, !tbaa !277
  %call11 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.41.167, i32 0, i32 0), i32 %7)
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.then
  %truncated = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 7
  store i32 1, i32* %truncated, align 8, !tbaa !275
  br label %cleanup

if.end12:                                         ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end12
  %i.0 = phi i32 [ 1, %if.end12 ], [ %inc, %for.body ]
  %read_count13 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  %8 = load i32, i32* %read_count13, align 4, !tbaa !277
  %cmp14 = icmp ule i32 %i.0, %8
  br i1 %cmp14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %io16 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %9 = load %struct.si_sm_io*, %struct.si_sm_io** %io16, align 8, !tbaa !265
  %inputb17 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %9, i32 0, i32 0
  %10 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb17, align 8, !tbaa !253
  %io18 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 2
  %11 = load %struct.si_sm_io*, %struct.si_sm_io** %io18, align 8, !tbaa !265
  %call19 = call zeroext i8 %10(%struct.si_sm_io* %11, i32 1)
  %read_data20 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %idxprom = zext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data20, i64 0, i64 %idxprom
  store i8 %call19, i8* %arrayidx21, align 1, !tbaa !6
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %read_count22 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  %12 = load i32, i32* %read_count22, align 4, !tbaa !277
  %inc23 = add nsw i32 %12, 1
  store i32 %inc23, i32* %read_count22, align 4, !tbaa !277
  %13 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and24 = and i32 %13, 2
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then26, label %if.end52

if.then26:                                        ; preds = %for.end
  %read_count27 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  %14 = load i32, i32* %read_count27, align 4, !tbaa !277
  %read_data28 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx29 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data28, i64 0, i64 2
  %15 = load i8, i8* %arrayidx29, align 2, !tbaa !6
  %conv30 = zext i8 %15 to i32
  %call31 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.42.168, i32 0, i32 0), i32 %14, i32 %conv30)
  %cmp32 = icmp sgt i32 %14, 16
  %. = select i1 %cmp32, i32 16, i32 %14
  br label %for.cond36

for.cond36:                                       ; preds = %for.body39, %if.then26
  %i.1 = phi i32 [ 0, %if.then26 ], [ %inc46, %for.body39 ]
  %cmp37 = icmp ult i32 %i.1, %.
  br i1 %cmp37, label %for.body39, label %for.end47

for.body39:                                       ; preds = %for.cond36
  %read_data40 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %idxprom41 = zext i32 %i.1 to i64
  %arrayidx42 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data40, i64 0, i64 %idxprom41
  %16 = load i8, i8* %arrayidx42, align 1, !tbaa !6
  %conv43 = zext i8 %16 to i32
  %call44 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.43.169, i32 0, i32 0), i32 %conv43)
  %inc46 = add i32 %i.1, 1
  br label %for.cond36

for.end47:                                        ; preds = %for.cond36
  %read_count48 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  %17 = load i32, i32* %read_count48, align 4, !tbaa !277
  %cmp49 = icmp eq i32 %17, %.
  %18 = zext i1 %cmp49 to i64
  %cond = select i1 %cmp49, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.45.170, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46.171, i32 0, i32 0)
  %call51 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.44.172, i32 0, i32 0), i8* %cond)
  br label %if.end52

if.end52:                                         ; preds = %for.end47, %for.end
  %read_data53 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx54 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data53, i64 0, i64 3
  %19 = load i8, i8* %arrayidx54, align 1, !tbaa !6
  %conv55 = zext i8 %19 to i32
  %write_data = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx56 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data, i64 0, i64 3
  %20 = load i8, i8* %arrayidx56, align 1, !tbaa !6
  %conv57 = zext i8 %20 to i32
  %cmp58 = icmp eq i32 %conv55, %conv57
  br i1 %cmp58, label %land.lhs.true, label %if.end80

land.lhs.true:                                    ; preds = %if.end52
  %read_data60 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx61 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data60, i64 0, i64 2
  %21 = load i8, i8* %arrayidx61, align 2, !tbaa !6
  %conv62 = zext i8 %21 to i32
  %write_data63 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx64 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data63, i64 0, i64 2
  %22 = load i8, i8* %arrayidx64, align 2, !tbaa !6
  %conv65 = zext i8 %22 to i32
  %cmp66 = icmp eq i32 %conv62, %conv65
  br i1 %cmp66, label %land.lhs.true68, label %if.end80

land.lhs.true68:                                  ; preds = %land.lhs.true
  %read_data69 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx70 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data69, i64 0, i64 1
  %23 = load i8, i8* %arrayidx70, align 1, !tbaa !6
  %conv71 = zext i8 %23 to i32
  %and72 = and i32 %conv71, 248
  %write_data73 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx74 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data73, i64 0, i64 1
  %24 = load i8, i8* %arrayidx74, align 1, !tbaa !6
  %conv75 = zext i8 %24 to i32
  %and76 = and i32 %conv75, 248
  %cmp77 = icmp eq i32 %and72, %and76
  br i1 %cmp77, label %cleanup, label %if.end80

if.end80:                                         ; preds = %land.lhs.true68, %land.lhs.true, %if.end52
  %25 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and81 = and i32 %25, 2
  %tobool82 = icmp ne i32 %and81, 0
  br i1 %tobool82, label %if.then83, label %cleanup

if.then83:                                        ; preds = %if.end80
  %write_data84 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx85 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data84, i64 0, i64 1
  %26 = load i8, i8* %arrayidx85, align 1, !tbaa !6
  %conv86 = zext i8 %26 to i32
  %or = or i32 %conv86, 4
  %write_data87 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx88 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data87, i64 0, i64 2
  %27 = load i8, i8* %arrayidx88, align 2, !tbaa !6
  %conv89 = zext i8 %27 to i32
  %write_data90 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx91 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data90, i64 0, i64 3
  %28 = load i8, i8* %arrayidx91, align 1, !tbaa !6
  %conv92 = zext i8 %28 to i32
  %read_data93 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx94 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data93, i64 0, i64 1
  %29 = load i8, i8* %arrayidx94, align 1, !tbaa !6
  %conv95 = zext i8 %29 to i32
  %read_data96 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx97 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data96, i64 0, i64 2
  %30 = load i8, i8* %arrayidx97, align 2, !tbaa !6
  %conv98 = zext i8 %30 to i32
  %read_data99 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx100 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data99, i64 0, i64 3
  %31 = load i8, i8* %arrayidx100, align 1, !tbaa !6
  %conv101 = zext i8 %31 to i32
  %call102 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.47.173, i32 0, i32 0), i32 %or, i32 %conv89, i32 %conv92, i32 %conv95, i32 %conv98, i32 %conv101)
  br label %cleanup

cleanup:                                          ; preds = %if.then83, %if.end80, %land.lhs.true68, %if.end
  %retval.0 = phi i32 [ 1, %if.end ], [ 1, %land.lhs.true68 ], [ 0, %if.then83 ], [ 0, %if.end80 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @force_result(%struct.si_sm_data.269* %bt, i8 zeroext %completion_code) #0 {
entry:
  %read_data = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx = getelementptr inbounds [274 x i8], [274 x i8]* %read_data, i64 0, i64 0
  store i8 4, i8* %arrayidx, align 8, !tbaa !6
  %write_data = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx1 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data, i64 0, i64 1
  %0 = load i8, i8* %arrayidx1, align 1, !tbaa !6
  %conv = zext i8 %0 to i32
  %or = or i32 %conv, 4
  %conv2 = trunc i32 %or to i8
  %read_data3 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx4 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data3, i64 0, i64 1
  store i8 %conv2, i8* %arrayidx4, align 1, !tbaa !6
  %write_data5 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx6 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data5, i64 0, i64 2
  %1 = load i8, i8* %arrayidx6, align 2, !tbaa !6
  %read_data7 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx8 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data7, i64 0, i64 2
  store i8 %1, i8* %arrayidx8, align 2, !tbaa !6
  %write_data9 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 3
  %arrayidx10 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data9, i64 0, i64 3
  %2 = load i8, i8* %arrayidx10, align 1, !tbaa !6
  %read_data11 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx12 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data11, i64 0, i64 3
  store i8 %2, i8* %arrayidx12, align 1, !tbaa !6
  %read_data13 = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 5
  %arrayidx14 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data13, i64 0, i64 4
  store i8 %completion_code, i8* %arrayidx14, align 4, !tbaa !6
  %read_count = getelementptr inbounds %struct.si_sm_data.269, %struct.si_sm_data.269* %bt, i32 0, i32 6
  store i32 5, i32* %read_count, align 4, !tbaa !277
  ret void
}

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone }
attributes #6 = { inlinehint nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }

!llvm.ident = !{!0, !0, !0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!4, !4, i64 0}
!7 = !{!8, !8, i64 0}
!8 = !{!"any pointer", !4, i64 0}
!9 = !{!10, !4, i64 220}
!10 = !{!"smi_info", !3, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !4, i64 32, !11, i64 40, !8, i64 112, !8, i64 120, !4, i64 128, !12, i64 136, !8, i64 184, !8, i64 192, !8, i64 200, !8, i64 208, !3, i64 216, !4, i64 220, !8, i64 224, !8, i64 232, !8, i64 240, !4, i64 248, !14, i64 249, !15, i64 252, !14, i64 256, !3, i64 260, !3, i64 264, !3, i64 268, !16, i64 272, !14, i64 368, !13, i64 376, !15, i64 384, !14, i64 388, !14, i64 389, !14, i64 390, !14, i64 391, !14, i64 392, !19, i64 396, !8, i64 424, !8, i64 432, !14, i64 440, !4, i64 441, !4, i64 444, !8, i64 488, !20, i64 496, !4, i64 512}
!11 = !{!"spinlock", !4, i64 0}
!12 = !{!"si_sm_io", !8, i64 0, !8, i64 8, !8, i64 16, !3, i64 24, !3, i64 28, !3, i64 32, !3, i64 36, !13, i64 40}
!13 = !{!"long", !4, i64 0}
!14 = !{!"_Bool", !4, i64 0}
!15 = !{!"", !3, i64 0}
!16 = !{!"timer_list", !17, i64 0, !13, i64 16, !8, i64 24, !13, i64 32, !3, i64 40, !18, i64 48}
!17 = !{!"hlist_node", !8, i64 0, !8, i64 8}
!18 = !{!"lockdep_map", !8, i64 0, !4, i64 8, !8, i64 24, !3, i64 32, !13, i64 40}
!19 = !{!"ipmi_device_id", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3, !4, i64 4, !4, i64 5, !3, i64 8, !3, i64 12, !4, i64 16, !3, i64 20}
!20 = !{!"list_head", !8, i64 0, !8, i64 8}
!21 = !{!10, !4, i64 32}
!22 = !{!10, !13, i64 176}
!23 = !{!10, !3, i64 172}
!24 = !{!10, !8, i64 184}
!25 = !{!10, !8, i64 152}
!26 = !{!10, !3, i64 160}
!27 = !{!10, !3, i64 164}
!28 = !{!10, !3, i64 168}
!29 = !{!10, !3, i64 268}
!30 = !{!10, !8, i64 200}
!31 = !{!10, !4, i64 441}
!32 = !{!20, !8, i64 0}
!33 = !{!10, !8, i64 496}
!34 = !{!35, !8, i64 0}
!35 = !{!"hotmod_vals", !8, i64 0, !3, i64 8}
!36 = !{!35, !3, i64 8}
!37 = !{!10, !8, i64 192}
!38 = !{!10, !8, i64 424}
!39 = !{!10, !8, i64 136}
!40 = !{!10, !8, i64 144}
!41 = !{!10, !3, i64 216}
!42 = !{!10, !8, i64 208}
!43 = !{!10, !8, i64 8}
!44 = !{!10, !8, i64 16}
!45 = !{!10, !8, i64 24}
!46 = !{!10, !3, i64 0}
!47 = !{!10, !8, i64 432}
!48 = !{!49, !8, i64 464}
!49 = !{!"device", !8, i64 0, !8, i64 8, !50, i64 16, !8, i64 280, !8, i64 288, !56, i64 296, !8, i64 456, !8, i64 464, !8, i64 472, !8, i64 480, !58, i64 488, !59, i64 528, !8, i64 1104, !8, i64 1112, !8, i64 1120, !20, i64 1128, !3, i64 1144, !8, i64 1152, !8, i64 1160, !63, i64 1168, !13, i64 1176, !8, i64 1184, !20, i64 1192, !8, i64 1208, !8, i64 1216, !64, i64 1224, !8, i64 1232, !8, i64 1240, !3, i64 1248, !3, i64 1252, !11, i64 1256, !20, i64 1328, !65, i64 1344, !8, i64 1376, !8, i64 1384, !8, i64 1392, !8, i64 1400, !8, i64 1408, !14, i64 1416, !14, i64 1416}
!50 = !{!"kobject", !8, i64 0, !20, i64 8, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !51, i64 56, !53, i64 64, !3, i64 256, !3, i64 256, !3, i64 256, !3, i64 256, !3, i64 256}
!51 = !{!"kref", !52, i64 0}
!52 = !{!"refcount_struct", !15, i64 0}
!53 = !{!"delayed_work", !54, i64 0, !16, i64 80, !8, i64 176, !3, i64 184}
!54 = !{!"work_struct", !55, i64 0, !20, i64 8, !8, i64 24, !18, i64 32}
!55 = !{!"", !13, i64 0}
!56 = !{!"mutex", !55, i64 0, !11, i64 8, !57, i64 80, !20, i64 88, !8, i64 104, !18, i64 112}
!57 = !{!"optimistic_spin_queue", !15, i64 0}
!58 = !{!"dev_links_info", !20, i64 0, !20, i64 16, !4, i64 32}
!59 = !{!"dev_pm_info", !60, i64 0, !3, i64 4, !3, i64 4, !14, i64 4, !14, i64 4, !14, i64 4, !14, i64 4, !14, i64 4, !14, i64 4, !14, i64 5, !11, i64 8, !20, i64 80, !61, i64 96, !8, i64 192, !14, i64 200, !14, i64 200, !14, i64 200, !16, i64 208, !13, i64 304, !54, i64 312, !62, i64 392, !8, i64 480, !15, i64 488, !15, i64 492, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !14, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 500, !4, i64 504, !4, i64 508, !3, i64 512, !3, i64 516, !13, i64 520, !13, i64 528, !13, i64 536, !13, i64 544, !8, i64 552, !8, i64 560, !8, i64 568}
!60 = !{!"pm_message", !3, i64 0}
!61 = !{!"completion", !3, i64 0, !62, i64 8}
!62 = !{!"__wait_queue_head", !11, i64 0, !20, i64 72}
!63 = !{!"long long", !4, i64 0}
!64 = !{!"dev_archdata", !8, i64 0}
!65 = !{!"klist_node", !8, i64 0, !20, i64 8, !51, i64 24}
!66 = !{!49, !8, i64 280}
!67 = !{!68, !8, i64 56}
!68 = !{!"si_sm_handlers", !8, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !8, i64 56}
!69 = !{!68, !8, i64 8}
!70 = !{!68, !8, i64 40}
!71 = !{!10, !8, i64 112}
!72 = !{!10, !8, i64 120}
!73 = !{!10, !14, i64 256}
!74 = !{!10, !14, i64 388}
!75 = !{!10, !14, i64 249}
!76 = !{!10, !14, i64 440}
!77 = !{!68, !8, i64 48}
!78 = !{!10, !8, i64 224}
!79 = !{i8 0, i8 2}
!80 = !{!10, !4, i64 128}
!81 = !{!49, !8, i64 480}
!82 = !{!20, !8, i64 8}
!83 = !{!10, !8, i64 488}
!84 = !{!10, !14, i64 368}
!85 = !{!68, !8, i64 16}
!86 = !{!13, !13, i64 0}
!87 = !{!10, !13, i64 376}
!88 = !{!68, !8, i64 32}
!89 = !{!10, !14, i64 392}
!90 = !{!10, !14, i64 389}
!91 = !{i32 -2146278010, i32 -2146277971, i32 -2146277950, i32 -2146277913, i32 -2146277890, i32 -2146278020}
!92 = !{!68, !8, i64 24}
!93 = !{!94, !3, i64 308}
!94 = !{!"ipmi_smi_msg", !20, i64 0, !13, i64 16, !8, i64 24, !3, i64 32, !4, i64 36, !3, i64 308, !4, i64 312, !8, i64 584}
!95 = !{!10, !4, i64 248}
!96 = !{!94, !8, i64 584}
!97 = !{!14, !14, i64 0}
!98 = !{!94, !3, i64 32}
!99 = !{!100, !100, i64 0}
!100 = !{!"short", !4, i64 0}
!101 = !{!63, !63, i64 0}
!102 = !{i32 -2146943001}
!103 = !{i32 -2146942963}
!104 = !{i32 -2146943668}
!105 = !{i32 -2146943630}
!106 = !{!10, !8, i64 240}
!107 = !{!10, !14, i64 390}
!108 = !{!10, !14, i64 391}
!109 = !{!110, !8, i64 248}
!110 = !{!"seq_file", !8, i64 0, !13, i64 8, !13, i64 16, !13, i64 24, !13, i64 32, !63, i64 40, !63, i64 48, !63, i64 56, !56, i64 64, !8, i64 224, !3, i64 232, !8, i64 240, !8, i64 248}
!111 = !{!16, !8, i64 24}
!112 = !{!16, !13, i64 32}
!113 = !{!114, !4, i64 0}
!114 = !{!"ipmi_smi_info", !4, i64 0, !8, i64 8, !4, i64 16}
!115 = !{!114, !8, i64 8}
!116 = !{i64 0, i64 8, !7}
!117 = !{i32 -2142115772, i32 -2142115747, i32 -2142115477, i32 -2142115680, i32 -2142115649, i32 -2142115619}
!118 = !{!119, !13, i64 11680}
!119 = !{!"task_struct", !120, i64 0, !13, i64 8, !8, i64 16, !15, i64 24, !3, i64 28, !3, i64 32, !121, i64 40, !3, i64 48, !3, i64 52, !3, i64 56, !13, i64 64, !8, i64 72, !3, i64 80, !3, i64 84, !3, i64 88, !3, i64 92, !3, i64 96, !3, i64 100, !8, i64 104, !122, i64 128, !127, i64 576, !8, i64 648, !128, i64 656, !131, i64 808, !3, i64 816, !3, i64 820, !3, i64 824, !132, i64 832, !13, i64 1856, !14, i64 1864, !20, i64 1872, !3, i64 1888, !133, i64 1896, !20, i64 1928, !134, i64 1944, !124, i64 1984, !8, i64 2008, !8, i64 2016, !135, i64 2024, !136, i64 2064, !3, i64 2084, !3, i64 2088, !3, i64 2092, !3, i64 2096, !13, i64 2104, !3, i64 2112, !3, i64 2116, !3, i64 2116, !3, i64 2116, !3, i64 2116, !3, i64 2120, !3, i64 2120, !3, i64 2120, !3, i64 2120, !3, i64 2120, !3, i64 2120, !3, i64 2120, !3, i64 2120, !13, i64 2128, !137, i64 2136, !3, i64 2184, !3, i64 2188, !8, i64 2192, !8, i64 2200, !20, i64 2208, !20, i64 2224, !8, i64 2240, !20, i64 2248, !20, i64 2264, !4, i64 2280, !20, i64 2352, !20, i64 2368, !8, i64 2384, !8, i64 2392, !8, i64 2400, !63, i64 2408, !63, i64 2416, !63, i64 2424, !138, i64 2432, !13, i64 2520, !13, i64 2528, !63, i64 2536, !63, i64 2544, !13, i64 2552, !13, i64 2560, !141, i64 2568, !4, i64 2592, !8, i64 2640, !8, i64 2648, !8, i64 2656, !4, i64 2664, !8, i64 2680, !142, i64 2688, !143, i64 2696, !13, i64 2712, !8, i64 2720, !8, i64 2728, !8, i64 2736, !8, i64 2744, !8, i64 2752, !144, i64 2760, !144, i64 2768, !144, i64 2776, !145, i64 2784, !13, i64 2808, !13, i64 2816, !3, i64 2824, !8, i64 2832, !8, i64 2840, !15, i64 2848, !3, i64 2852, !146, i64 2856, !3, i64 2872, !3, i64 2876, !11, i64 2880, !139, i64 2952, !147, i64 3024, !148, i64 3032, !8, i64 3040, !8, i64 3048, !8, i64 3056, !3, i64 3064, !13, i64 3072, !13, i64 3080, !3, i64 3088, !3, i64 3092, !3, i64 3096, !3, i64 3100, !13, i64 3104, !13, i64 3112, !3, i64 3120, !3, i64 3124, !3, i64 3128, !3, i64 3132, !63, i64 3136, !3, i64 3144, !3, i64 3148, !4, i64 3152, !3, i64 5840, !3, i64 5844, !8, i64 5848, !8, i64 5856, !8, i64 5864, !8, i64 5872, !8, i64 5880, !8, i64 5888, !13, i64 5896, !8, i64 5904, !149, i64 5912, !63, i64 5968, !63, i64 5976, !63, i64 5984, !144, i64 5992, !150, i64 6120, !3, i64 6176, !3, i64 6180, !8, i64 6184, !20, i64 6192, !3, i64 6208, !8, i64 6216, !8, i64 6224, !20, i64 6232, !8, i64 6248, !4, i64 6256, !56, i64 6272, !20, i64 6432, !8, i64 6448, !100, i64 6456, !100, i64 6458, !3, i64 6460, !3, i64 6464, !3, i64 6468, !3, i64 6472, !13, i64 6480, !63, i64 6488, !63, i64 6496, !63, i64 6504, !151, i64 6512, !20, i64 6528, !8, i64 6544, !8, i64 6552, !13, i64 6560, !4, i64 6568, !13, i64 6592, !152, i64 6600, !151, i64 7632, !8, i64 7648, !153, i64 7656, !8, i64 7672, !3, i64 7680, !3, i64 7684, !3, i64 7688, !13, i64 7696, !3, i64 7704, !4, i64 7712, !63, i64 11552, !63, i64 11560, !3, i64 11568, !3, i64 11572, !8, i64 11576, !63, i64 11584, !15, i64 11592, !15, i64 11596, !13, i64 11600, !13, i64 11608, !4, i64 11616, !3, i64 11620, !8, i64 11624, !8, i64 11632, !8, i64 11640, !3, i64 11648, !3, i64 11652, !3, i64 11656, !8, i64 11664, !3, i64 11672, !3, i64 11676, !13, i64 11680, !3, i64 11688, !8, i64 11696, !15, i64 11704, !154, i64 11712}
!120 = !{!"thread_info", !13, i64 0}
!121 = !{!"llist_node", !8, i64 0}
!122 = !{!"sched_entity", !123, i64 0, !124, i64 16, !20, i64 40, !3, i64 56, !63, i64 64, !63, i64 72, !63, i64 80, !63, i64 88, !63, i64 96, !125, i64 104, !3, i64 320, !8, i64 328, !8, i64 336, !8, i64 344, !126, i64 384}
!123 = !{!"load_weight", !13, i64 0, !3, i64 8}
!124 = !{!"rb_node", !13, i64 0, !8, i64 8, !8, i64 16}
!125 = !{!"sched_statistics", !63, i64 0, !63, i64 8, !63, i64 16, !63, i64 24, !63, i64 32, !63, i64 40, !63, i64 48, !63, i64 56, !63, i64 64, !63, i64 72, !63, i64 80, !63, i64 88, !63, i64 96, !63, i64 104, !63, i64 112, !63, i64 120, !63, i64 128, !63, i64 136, !63, i64 144, !63, i64 152, !63, i64 160, !63, i64 168, !63, i64 176, !63, i64 184, !63, i64 192, !63, i64 200, !63, i64 208}
!126 = !{!"sched_avg", !63, i64 0, !63, i64 8, !3, i64 16, !3, i64 20, !13, i64 24, !13, i64 32}
!127 = !{!"sched_rt_entity", !20, i64 0, !13, i64 16, !13, i64 24, !3, i64 32, !100, i64 36, !100, i64 38, !8, i64 40, !8, i64 48, !8, i64 56, !8, i64 64}
!128 = !{!"sched_dl_entity", !124, i64 0, !63, i64 24, !63, i64 32, !63, i64 40, !63, i64 48, !63, i64 56, !63, i64 64, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !129, i64 88}
!129 = !{!"hrtimer", !130, i64 0, !63, i64 32, !8, i64 40, !8, i64 48, !4, i64 56, !4, i64 57}
!130 = !{!"timerqueue_node", !124, i64 0, !63, i64 24}
!131 = !{!"hlist_head", !8, i64 0}
!132 = !{!"cpumask", !4, i64 0}
!133 = !{!"sched_info", !13, i64 0, !63, i64 8, !63, i64 16, !63, i64 24}
!134 = !{!"plist_node", !3, i64 0, !20, i64 8, !20, i64 24}
!135 = !{!"vmacache", !3, i64 0, !4, i64 8}
!136 = !{!"task_rss_stat", !3, i64 0, !4, i64 4}
!137 = !{!"restart_block", !8, i64 0, !4, i64 8}
!138 = !{!"prev_cputime", !63, i64 0, !63, i64 8, !139, i64 16}
!139 = !{!"raw_spinlock", !140, i64 0, !3, i64 4, !3, i64 8, !8, i64 16, !18, i64 24}
!140 = !{!"qspinlock", !15, i64 0}
!141 = !{!"task_cputime", !63, i64 0, !63, i64 8, !63, i64 16}
!142 = !{!"sysv_sem", !8, i64 0}
!143 = !{!"sysv_shm", !20, i64 0}
!144 = !{!"", !4, i64 0}
!145 = !{!"sigpending", !20, i64 0, !144, i64 16}
!146 = !{!"seccomp", !3, i64 0, !8, i64 8}
!147 = !{!"wake_q_node", !8, i64 0}
!148 = !{!"rb_root", !8, i64 0}
!149 = !{!"task_io_accounting", !63, i64 0, !63, i64 8, !63, i64 16, !63, i64 24, !63, i64 32, !63, i64 40, !63, i64 48}
!150 = !{!"seqcount", !3, i64 0, !18, i64 8}
!151 = !{!"callback_head", !8, i64 0, !8, i64 8}
!152 = !{!"tlbflush_unmap_batch", !132, i64 0, !14, i64 1024, !14, i64 1025}
!153 = !{!"page_frag", !8, i64 0, !3, i64 8, !3, i64 12}
!154 = !{!"thread_struct", !4, i64 0, !13, i64 24, !13, i64 32, !100, i64 40, !100, i64 42, !100, i64 44, !100, i64 46, !3, i64 48, !13, i64 56, !13, i64 64, !4, i64 72, !13, i64 104, !13, i64 112, !13, i64 120, !13, i64 128, !13, i64 136, !8, i64 144, !13, i64 152, !3, i64 160, !55, i64 168, !3, i64 176, !3, i64 176, !155, i64 192}
!155 = !{!"fpu", !3, i64 0, !4, i64 4, !4, i64 5, !4, i64 64}
!156 = !{!119, !13, i64 8}
!157 = !{!158, !13, i64 8}
!158 = !{!"timespec", !13, i64 0, !13, i64 8}
!159 = !{i32 -2146572343}
!160 = !{!158, !13, i64 0}
!161 = !{i32 1715544}
!162 = !{!19, !3, i64 8}
!163 = !{!19, !4, i64 0}
!164 = !{!19, !4, i64 1}
!165 = !{!19, !4, i64 4}
!166 = !{!19, !4, i64 2}
!167 = !{!19, !4, i64 3}
!168 = !{!19, !4, i64 5}
!169 = !{!19, !3, i64 12}
!170 = !{!171, !8, i64 1248}
!171 = !{!"platform_device", !8, i64 0, !3, i64 8, !14, i64 12, !49, i64 16, !3, i64 1440, !8, i64 1448, !8, i64 1456, !8, i64 1464, !8, i64 1472, !172, i64 1480}
!172 = !{!"pdev_archdata"}
!173 = !{!174, !8, i64 192}
!174 = !{!"of_device_id", !4, i64 0, !4, i64 32, !4, i64 64, !8, i64 192}
!175 = !{!176, !13, i64 24}
!176 = !{!"resource", !63, i64 0, !63, i64 8, !8, i64 16, !13, i64 24, !13, i64 32, !8, i64 40, !8, i64 48, !8, i64 56}
!177 = !{!176, !63, i64 0}
!178 = !{!49, !8, i64 1240}
!179 = !{!180, !8, i64 8}
!180 = !{!"acpi_device", !3, i64 0, !8, i64 8, !181, i64 16, !8, i64 32, !20, i64 40, !20, i64 56, !20, i64 72, !20, i64 88, !182, i64 104, !183, i64 108, !184, i64 112, !186, i64 232, !188, i64 400, !191, i64 552, !193, i64 576, !194, i64 584, !8, i64 624, !8, i64 632, !8, i64 640, !8, i64 648, !8, i64 656, !49, i64 664, !3, i64 2088, !3, i64 2092, !20, i64 2096, !56, i64 2112, !8, i64 2272}
!181 = !{!"fwnode_handle", !4, i64 0, !8, i64 8}
!182 = !{!"acpi_device_status", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0}
!183 = !{!"acpi_device_flags", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 1, !3, i64 1, !3, i64 1, !3, i64 1, !3, i64 1}
!184 = !{!"acpi_device_pnp", !4, i64 0, !185, i64 8, !13, i64 16, !8, i64 24, !20, i64 32, !4, i64 48, !4, i64 88, !8, i64 112}
!185 = !{!"acpi_pnp_type", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0}
!186 = !{!"acpi_device_power", !3, i64 0, !187, i64 4, !4, i64 8}
!187 = !{!"acpi_device_power_flags", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0}
!188 = !{!"acpi_device_wakeup", !8, i64 0, !63, i64 8, !63, i64 16, !20, i64 24, !189, i64 40, !190, i64 48, !8, i64 136, !3, i64 144}
!189 = !{!"acpi_device_wakeup_flags", !4, i64 0, !4, i64 0, !4, i64 0, !4, i64 0}
!190 = !{!"acpi_device_wakeup_context", !54, i64 0, !8, i64 80}
!191 = !{!"acpi_device_perf", !3, i64 0, !192, i64 4, !3, i64 8, !8, i64 16}
!192 = !{!"acpi_device_perf_flags", !4, i64 0}
!193 = !{!"acpi_device_dir", !8, i64 0}
!194 = !{!"acpi_device_data", !8, i64 0, !8, i64 8, !8, i64 16, !20, i64 24}
!195 = !{!181, !4, i64 0}
!196 = !{i32 691943}
!197 = !{!12, !13, i64 40}
!198 = !{!12, !3, i64 24}
!199 = !{!12, !3, i64 32}
!200 = !{i32 -2145075461}
!201 = !{i32 -2145072347}
!202 = !{i32 -2145073907}
!203 = !{i32 -2145075259}
!204 = !{i32 -2145072145}
!205 = !{i32 -2145073705}
!206 = !{!12, !8, i64 16}
!207 = !{i32 -2145083634}
!208 = !{i32 -2145081703}
!209 = !{i32 -2145083082}
!210 = !{i32 -2145085434}
!211 = !{i32 -2145082002}
!212 = !{i32 -2145084821}
!213 = !{i32 -2145085129}
!214 = !{!215, !8, i64 32}
!215 = !{!"dmi_device", !20, i64 0, !3, i64 16, !8, i64 24, !8, i64 32}
!216 = !{!217, !4, i64 37}
!217 = !{!"SPMITable", !4, i64 0, !3, i64 4, !4, i64 8, !4, i64 9, !4, i64 10, !4, i64 16, !4, i64 24, !4, i64 28, !4, i64 32, !4, i64 36, !4, i64 37, !100, i64 38, !4, i64 40, !4, i64 41, !100, i64 42, !3, i64 44, !218, i64 48, !4, i64 60, !4, i64 64}
!218 = !{!"acpi_generic_address", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3, !63, i64 4}
!219 = !{!217, !4, i64 36}
!220 = !{!217, !4, i64 40}
!221 = !{!217, !4, i64 41}
!222 = !{!217, !3, i64 44}
!223 = !{!217, !4, i64 49}
!224 = !{!217, !4, i64 50}
!225 = !{!217, !4, i64 48}
!226 = !{!217, !63, i64 52}
!227 = !{!228, !4, i64 1}
!228 = !{!"dmi_header", !4, i64 0, !4, i64 1, !100, i64 2}
!229 = !{!230, !4, i64 0}
!230 = !{!"dmi_ipmi_data", !4, i64 0, !4, i64 1, !13, i64 8, !4, i64 16, !4, i64 17, !4, i64 18}
!231 = !{!230, !4, i64 1}
!232 = !{!230, !13, i64 8}
!233 = !{!230, !4, i64 16}
!234 = !{!230, !4, i64 17}
!235 = !{!230, !4, i64 18}
!236 = !{!237, !3, i64 68}
!237 = !{!"pci_dev", !20, i64 0, !8, i64 16, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !3, i64 56, !100, i64 60, !100, i64 62, !100, i64 64, !100, i64 66, !3, i64 68, !4, i64 72, !4, i64 73, !100, i64 74, !4, i64 76, !4, i64 77, !4, i64 78, !4, i64 79, !4, i64 80, !4, i64 81, !100, i64 82, !8, i64 88, !8, i64 96, !63, i64 104, !238, i64 112, !3, i64 128, !4, i64 132, !3, i64 133, !3, i64 133, !3, i64 133, !3, i64 133, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 134, !3, i64 135, !3, i64 135, !3, i64 136, !3, i64 140, !8, i64 144, !3, i64 152, !49, i64 160, !3, i64 1584, !3, i64 1588, !4, i64 1592, !14, i64 2680, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2681, !3, i64 2682, !3, i64 2682, !3, i64 2682, !3, i64 2682, !3, i64 2682, !3, i64 2682, !3, i64 2682, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2683, !3, i64 2684, !3, i64 2684, !3, i64 2684, !3, i64 2684, !100, i64 2686, !15, i64 2688, !4, i64 2692, !131, i64 2760, !8, i64 2768, !3, i64 2776, !4, i64 2784, !4, i64 2920, !3, i64 3056, !3, i64 3056, !4, i64 3057, !8, i64 3064, !8, i64 3072, !4, i64 3080, !100, i64 3088, !4, i64 3090, !15, i64 3092, !63, i64 3096, !13, i64 3104, !8, i64 3112}
!238 = !{!"device_dma_parameters", !3, i64 0, !13, i64 8}
!239 = !{!10, !8, i64 232}
!240 = !{!237, !3, i64 1588}
!241 = !{!242, !4, i64 0}
!242 = !{!"si_sm_data", !4, i64 0, !8, i64 8, !4, i64 16, !3, i64 288, !3, i64 292, !3, i64 296, !4, i64 300, !3, i64 572, !3, i64 576, !3, i64 580, !13, i64 584, !13, i64 592, !13, i64 600}
!243 = !{!242, !8, i64 8}
!244 = !{!242, !3, i64 288}
!245 = !{!242, !3, i64 292}
!246 = !{!242, !3, i64 296}
!247 = !{!242, !3, i64 572}
!248 = !{!242, !3, i64 580}
!249 = !{!242, !3, i64 576}
!250 = !{!242, !13, i64 584}
!251 = !{!242, !13, i64 592}
!252 = !{!242, !13, i64 600}
!253 = !{!12, !8, i64 0}
!254 = !{!12, !8, i64 8}
!255 = !{!256, !4, i64 0}
!256 = !{!"si_sm_data", !4, i64 0, !8, i64 8, !4, i64 16, !3, i64 96, !3, i64 100, !3, i64 104, !4, i64 108, !3, i64 188, !3, i64 192, !3, i64 196, !13, i64 200}
!257 = !{!256, !8, i64 8}
!258 = !{!256, !3, i64 96}
!259 = !{!256, !3, i64 100}
!260 = !{!256, !3, i64 104}
!261 = !{!256, !3, i64 188}
!262 = !{!256, !3, i64 196}
!263 = !{!256, !3, i64 192}
!264 = !{!256, !13, i64 200}
!265 = !{!266, !8, i64 8}
!266 = !{!"si_sm_data", !4, i64 0, !4, i64 4, !8, i64 8, !4, i64 16, !3, i64 292, !4, i64 296, !3, i64 572, !3, i64 576, !13, i64 584, !3, i64 592, !3, i64 596, !4, i64 600, !3, i64 604, !13, i64 608, !3, i64 616}
!267 = !{!266, !4, i64 4}
!268 = !{!266, !4, i64 0}
!269 = !{!266, !4, i64 600}
!270 = !{!266, !13, i64 608}
!271 = !{!266, !3, i64 616}
!272 = !{!266, !3, i64 292}
!273 = !{!266, !3, i64 592}
!274 = !{!266, !3, i64 596}
!275 = !{!266, !3, i64 576}
!276 = !{!266, !13, i64 584}
!277 = !{!266, !3, i64 572}
!278 = !{!266, !3, i64 604}
