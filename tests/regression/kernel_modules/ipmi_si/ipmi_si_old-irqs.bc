; ModuleID = 'tests/regression/kernel_modules/ipmi_si/ipmi_si_old-irqs.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.46 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.46 = type { i8* }
%struct.kparam_string = type { i32, i8* }
%struct.kparam_array = type { i32, i32, i32*, %struct.kernel_param_ops*, i8* }
%struct.hotmod_vals = type { i8*, i32 }
%struct.mutex = type { %union.anon.1, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%union.anon.1 = type { i32 }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.arch_spinlock = type { %union.anon.1 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.task_struct = type { i64, i8*, %union.anon.1, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, %struct.load_weight, %struct.load_weight, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %union.anon.42, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %union.anon.1, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %union.anon.1, %union.anon.1, i64, i64, %struct.memcg_batch_info, i32, %union.anon.1, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgprot*, %union.anon.1, %union.anon.1, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.mm_rss_stat = type { [3 x %struct.pgprot] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %union.anon.1, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file = type { %union.anon.42, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.pgprot, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %union.anon.1, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.42, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %struct.pgprot, i8* }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %union.anon.1, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.pgprot, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.load_weight*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.arch_spinlock, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.arch_spinlock, void ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %union.anon.1, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.1, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.pgprot }
%struct.shrink_control = type { i32, i64 }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.1, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.36, i64, %union.anon.1, %union.anon.1, %union.anon.1, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.38, i32, i32, %struct.hlist_head, %union.anon.1, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.load_weight*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.36 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.pid = type { %union.anon.1, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.46, i32 }
%struct.swap_info_struct = type opaque
%union.anon.38 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %struct.pgprot, i32, i32, i8*, %struct.lockdep_map }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.3, %union.anon.42, %struct.pgprot, i64 }
%struct.anon.3 = type { %struct.pgprot, %struct.pgprot }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %union.anon.1, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.load_weight = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %union.anon.1, %union.anon.1, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %union.anon.1, i32, %union.anon.12, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %struct.pgprot, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.42, %struct.pgprot }
%union.anon.12 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%struct.user_struct = type { %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %struct.pgprot, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.pgprot }
%struct.user_namespace = type opaque
%struct.group_info = type { %union.anon.1, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.16 }
%union.anon.16 = type { %struct.exception_table_entry }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.19, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.22 }
%union.anon.19 = type { %struct.load_weight }
%union.anon.22 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %union.anon.1, %union.anon.1, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %struct.pgprot, [2 x %struct.if_dqinfo], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.load_weight], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %struct.pgprot, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %struct.pgprot }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %struct.pgprot, i64 ()*, %struct.pgprot, %struct.pgprot }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %struct.pgprot, i32, i32, i64, i64, i64, %struct.pgprot, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %union.anon.1, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%union.anon.42 = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.24 }
%union.anon.24 = type { %struct.anon.28, [80 x i8] }
%struct.anon.28 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.load_weight, %struct.load_weight, i64, i64, i32, i32, %struct.load_weight, %struct.load_weight, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.atomic_notifier_head = type { %struct.spinlock, %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.platform_driver = type { i32 (%struct.platform_device*)*, i32 (%struct.platform_device*)*, void (%struct.platform_device*)*, i32 (%struct.platform_device*, i32)*, i32 (%struct.platform_device*)*, %struct.device_driver, %struct.platform_device_id* }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, %struct.mfd_cell*, %struct.mod_arch_specific }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.shrink_control*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %union.anon.46, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.dev_pm_info = type { %union.anon.1, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %union.anon.1, %union.anon.1, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.work_struct = type { %struct.pgprot, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i8*, i64, %struct.sigset_t*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.sigset_t*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.sigset_t*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.proc_dir_entry*, %struct.arch_spinlock, i64, i8* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32 }
%struct.proc_dir_entry = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.arch_spinlock }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.mfd_cell = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.ipmi_smi_handlers = type { %struct.module*, i32 (i8*, %struct.ipmi_smi*)*, i32 (i8*, %struct.ipmi_smi_info*)*, void (i8*, %struct.ipmi_smi_msg*, i32)*, void (i8*)*, void (i8*, i32)*, void (i8*)*, void (i8*, i32)*, i32 (i8*)*, void (i8*)* }
%struct.ipmi_smi = type opaque
%struct.ipmi_smi_info = type { i32, %struct.device*, %union.ipmi_smi_info_union }
%union.ipmi_smi_info_union = type { %union.anon.46 }
%struct.ipmi_smi_msg = type { %struct.list_head, i64, i8*, i32, [272 x i8], i32, [272 x i8], void (%struct.ipmi_smi_msg*)* }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.__wait_queue_head }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, [6 x i8], %struct.pci_driver*, i64, %struct.shrink_control, i32, i8, i16, i8, i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, [3 x i8], i16, [2 x i8], %union.anon.1, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], %struct.list_head, %struct.kset*, %struct.pci_vpd*, %union.anon.48, %struct.pci_ats*, i64, i64 }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.pci_ops = type { i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.48 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_ats = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)* }
%struct.pnp_driver = type { i8*, %struct.pnp_device_id*, i32, i32 (%struct.pnp_dev*, %struct.pnp_device_id*)*, void (%struct.pnp_dev*)*, void (%struct.pnp_dev*)*, i32 (%struct.pnp_dev*, i32)*, i32 (%struct.pnp_dev*)*, %struct.device_driver }
%struct.pnp_device_id = type { [8 x i8], i64 }
%struct.pnp_dev = type { %struct.device, i64, i32, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.pnp_protocol*, %struct.pnp_card*, %struct.pnp_driver*, %struct.pnp_card_link*, %struct.pnp_id*, i32, i32, i32, %struct.list_head, %struct.list_head, [50 x i8], i32, %struct.proc_dir_entry*, i8* }
%struct.pnp_protocol = type { %struct.list_head, i8*, i32 (%struct.pnp_dev*)*, i32 (%struct.pnp_dev*)*, i32 (%struct.pnp_dev*)*, i1 (%struct.pnp_dev*)*, i32 (%struct.pnp_dev*, i32)*, i32 (%struct.pnp_dev*)*, i8, %struct.device, %struct.list_head, %struct.list_head }
%struct.pnp_card = type { %struct.device, i8, %struct.list_head, %struct.list_head, %struct.list_head, %struct.pnp_protocol*, %struct.pnp_id*, [50 x i8], i8, i8, i32, i8, %struct.proc_dir_entry* }
%struct.pnp_card_link = type { %struct.pnp_card*, %struct.pnp_card_driver*, i8*, %union.anon.1 }
%struct.pnp_card_driver = type { %struct.list_head, i8*, %struct.pnp_card_device_id*, i32, i32 (%struct.pnp_card_link*, %struct.pnp_card_device_id*)*, void (%struct.pnp_card_link*)*, i32 (%struct.pnp_card_link*, i32)*, i32 (%struct.pnp_card_link*)*, %struct.pnp_driver }
%struct.pnp_card_device_id = type { [8 x i8], i64, [8 x %struct.anon.49] }
%struct.anon.49 = type { [8 x i8] }
%struct.pnp_id = type { [8 x i8], %struct.pnp_id* }
%struct.si_sm_handlers = type { i8*, i32 (%struct.si_sm_data*, %struct.si_sm_io*)*, i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*)*, void (%struct.si_sm_data*)*, i32 ()* }
%struct.si_sm_data = type { i32, %struct.si_sm_io*, [272 x i8], i32, i32, i32, [272 x i8], i32, i32, i32, i64, i64, i64 }
%struct.si_sm_io = type { i8 (%struct.si_sm_io*, i32)*, void (%struct.si_sm_io*, i32, i8)*, i8*, i32, i32, i32, i32, i64 }
%struct.si_sm_handlers.12 = type { i8*, i32 (%struct.si_sm_data.13*, %struct.si_sm_io*)*, i32 (%struct.si_sm_data.13*, i8*, i32)*, i32 (%struct.si_sm_data.13*, i8*, i32)*, i32 (%struct.si_sm_data.13*, i64)*, i32 (%struct.si_sm_data.13*)*, void (%struct.si_sm_data.13*)*, i32 ()* }
%struct.si_sm_data.13 = type { i32, %struct.si_sm_io*, [80 x i8], i32, i32, i32, [80 x i8], i32, i32, i32, i64 }
%struct.si_sm_handlers.21 = type { i8*, i32 (%struct.si_sm_data.22*, %struct.si_sm_io*)*, i32 (%struct.si_sm_data.22*, i8*, i32)*, i32 (%struct.si_sm_data.22*, i8*, i32)*, i32 (%struct.si_sm_data.22*, i64)*, i32 (%struct.si_sm_data.22*)*, void (%struct.si_sm_data.22*)*, i32 ()* }
%struct.si_sm_data.22 = type { i32, i8, %struct.si_sm_io*, [274 x i8], i32, [274 x i8], i32, i32, i64, i32, i32, i32, i32, i64, i32 }
%struct.smi_info = type { i32, %struct.ipmi_smi*, %struct.si_sm_data*, %struct.si_sm_handlers*, i32, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.ipmi_smi_msg*, i32, %struct.si_sm_io, i32 (%struct.smi_info*)*, void (%struct.smi_info*)*, i32 (%struct.smi_info*)*, void (%struct.smi_info*)*, i32, i32, void (%struct.smi_info*)*, i8*, i32 (%struct.smi_info*)*, i8, i8, %union.anon.1, i32, i32, i32, i32, %struct.timer_list, i64, %union.anon.1, i32, %struct.ipmi_device_id, %struct.device*, %struct.platform_device*, i32, i8, [11 x %union.anon.1], %struct.task_struct*, %struct.list_head, %union.ipmi_smi_info_union }
%struct.ipmi_device_id = type { i8, i8, i8, i8, i8, i8, i32, i32, [4 x i8], i8 }
%struct.dmi_ipmi_data = type { i8, i8, i64, i8, i8, i8 }
%struct.dmi_device = type { %struct.list_head, i32, i8*, i8* }
%struct.dmi_header = type { i8, i8, i16 }
%struct.SPMITable = type { [4 x i8], i32, i8, i8, [6 x i8], [8 x i8], [4 x i8], [4 x i8], [4 x i8], i8, i8, i16, i8, i8, i16, i32, %struct.acpi_generic_address, [4 x i8], [1 x i8] }
%struct.acpi_generic_address = type <{ i8, i8, i8, i8, i64 }>
%struct.acpi_table_header = type { [4 x i8], i32, i8, i8, [6 x i8], [8 x i8], i32, [4 x i8], i32 }
%struct.acpi_device = type { i32, i8*, %struct.acpi_device*, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.1, %union.anon.1, %struct.acpi_device_pnp, %struct.acpi_device_power, %struct.acpi_device_wakeup, %struct.acpi_device_perf, %struct.acpi_device_dir, %struct.acpi_scan_handler*, %struct.acpi_driver*, i8*, %struct.device, i32, i8, %struct.list_head, %struct.mutex, [1 x i64], %struct.list_head, void (%struct.acpi_device*)* }
%struct.acpi_device_pnp = type { [8 x i8], %union.anon.1, i64, i8*, %struct.list_head, [40 x i8], [20 x i8], %union.acpi_object*, i64 }
%union.acpi_object = type { %struct.anon.55 }
%struct.anon.55 = type { i32, i32, i64, i32 }
%struct.acpi_device_power = type { i32, %union.anon.1, [5 x %struct.acpi_device_power_state] }
%struct.acpi_device_power_state = type { %struct.anon.57, i32, i32, %struct.list_head }
%struct.anon.57 = type { i8, i8 }
%struct.acpi_device_wakeup = type { i8*, i64, i64, %struct.list_head, %struct.lockdep_subclass_key, i32 }
%struct.acpi_device_perf = type { i32, %struct.lockdep_subclass_key, i32, %struct.acpi_device_perf_state* }
%struct.acpi_device_perf_state = type { %struct.lockdep_subclass_key, i8, i8, i32 }
%struct.acpi_device_dir = type { %struct.proc_dir_entry* }
%struct.acpi_scan_handler = type { %struct.acpi_device_id*, %struct.list_head, i32 (%struct.acpi_device*, %struct.acpi_device_id*)*, void (%struct.acpi_device*)*, %struct.acpi_hotplug_profile }
%struct.acpi_hotplug_profile = type { %struct.kobject, i8, i32 }
%struct.acpi_driver = type { [80 x i8], [80 x i8], %struct.acpi_device_id*, i32, %struct.acpi_device_ops, %struct.device_driver, %struct.module* }
%struct.acpi_device_ops = type { i32 (%struct.acpi_device*)*, i32 (%struct.acpi_device*)*, void (%struct.acpi_device*, i32)* }
%struct.acpi_object_list = type { i32, %union.acpi_object* }

@llvm.used = appending global [62 x i8*] [i8* bitcast (%struct.kernel_param* @__param_hotmod to i8*), i8* getelementptr inbounds ([111 x i8], [111 x i8]* @__UNIQUE_ID_hotmod1253, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_tryacpi to i8*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__UNIQUE_ID_tryacpitype1256, i32 0, i32 0), i8* getelementptr inbounds ([102 x i8], [102 x i8]* @__UNIQUE_ID_tryacpi1258, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_trydmi to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_trydmitype1261, i32 0, i32 0), i8* getelementptr inbounds ([100 x i8], [100 x i8]* @__UNIQUE_ID_trydmi1263, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_tryplatform to i8*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__UNIQUE_ID_tryplatformtype1265, i32 0, i32 0), i8* getelementptr inbounds ([135 x i8], [135 x i8]* @__UNIQUE_ID_tryacpi1268, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_trypci to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_trypcitype1270, i32 0, i32 0), i8* getelementptr inbounds ([101 x i8], [101 x i8]* @__UNIQUE_ID_tryacpi1272, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_trydefaults to i8*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__UNIQUE_ID_trydefaultstype1274, i32 0, i32 0), i8* getelementptr inbounds ([125 x i8], [125 x i8]* @__UNIQUE_ID_trydefaults1277, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_string* } }* @__param_type to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_typetype1278, i32 0, i32 0), i8* getelementptr inbounds ([207 x i8], [207 x i8]* @__UNIQUE_ID_type1282, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_addrs to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_addrstype1283, i32 0, i32 0), i8* getelementptr inbounds ([175 x i8], [175 x i8]* @__UNIQUE_ID_addrs1287, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_ports to i8*), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__UNIQUE_ID_portstype1288, i32 0, i32 0), i8* getelementptr inbounds ([170 x i8], [170 x i8]* @__UNIQUE_ID_ports1292, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_irqs to i8*), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__UNIQUE_ID_irqstype1293, i32 0, i32 0), i8* getelementptr inbounds ([173 x i8], [173 x i8]* @__UNIQUE_ID_irqs1297, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_regspacings to i8*), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__UNIQUE_ID_regspacingstype1298, i32 0, i32 0), i8* getelementptr inbounds ([235 x i8], [235 x i8]* @__UNIQUE_ID_regspacings1303, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_regsizes to i8*), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_regsizestype1304, i32 0, i32 0), i8* getelementptr inbounds ([232 x i8], [232 x i8]* @__UNIQUE_ID_regsizes1309, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_regshifts to i8*), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__UNIQUE_ID_regshiftstype1310, i32 0, i32 0), i8* getelementptr inbounds ([197 x i8], [197 x i8]* @__UNIQUE_ID_regshifts1314, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_slave_addrs to i8*), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__UNIQUE_ID_slave_addrstype1315, i32 0, i32 0), i8* getelementptr inbounds ([179 x i8], [179 x i8]* @__UNIQUE_ID_slave_addrs1319, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_force_kipmid to i8*), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__UNIQUE_ID_force_kipmidtype1320, i32 0, i32 0), i8* getelementptr inbounds ([166 x i8], [166 x i8]* @__UNIQUE_ID_force_kipmid1323, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_unload_when_empty to i8*), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_unload_when_emptytype1324, i32 0, i32 0), i8* getelementptr inbounds ([157 x i8], [157 x i8]* @__UNIQUE_ID_unload_when_empty1327, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_kipmid_max_busy_us to i8*), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @__UNIQUE_ID_kipmid_max_busy_ustype1328, i32 0, i32 0), i8* getelementptr inbounds ([186 x i8], [186 x i8]* @__UNIQUE_ID_kipmid_max_busy_us1332, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license3621, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @__UNIQUE_ID_author3622, i32 0, i32 0), i8* getelementptr inbounds ([86 x i8], [86 x i8]* @__UNIQUE_ID_description3624, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_kcs_debug to i8*), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__UNIQUE_ID_kcs_debugtype58, i32 0, i32 0), i8* getelementptr inbounds ([61 x i8], [61 x i8]* @__UNIQUE_ID_kcs_debug59, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_smic_debug to i8*), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__UNIQUE_ID_smic_debugtype61, i32 0, i32 0), i8* getelementptr inbounds ([62 x i8], [62 x i8]* @__UNIQUE_ID_smic_debug62, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_bt_debug to i8*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__UNIQUE_ID_bt_debugtype47, i32 0, i32 0), i8* getelementptr inbounds ([60 x i8], [60 x i8]* @__UNIQUE_ID_bt_debug48, i32 0, i32 0)], section "llvm.metadata"
@__param_hotmod = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.36, i32 0, i32 0), %struct.kernel_param_ops* @__param_ops_hotmod, i16 128, i16 -1, %union.anon.46 zeroinitializer }, section "__param", align 8
@__UNIQUE_ID_hotmod1253 = internal constant [111 x i8] c"parm=hotmod:Add and remove interfaces.  See Documentation/IPMI.txt in the kernel sources for the gory details.\00", section ".modinfo", align 1
@__param_tryacpi = internal constant %struct.kernel_param { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @__param_str_tryacpi, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 0, i16 -1, %union.anon.46 { i8* @si_tryacpi } }, section "__param", align 8
@__UNIQUE_ID_tryacpitype1256 = internal constant [22 x i8] c"parmtype=tryacpi:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_tryacpi1258 = internal constant [102 x i8] c"parm=tryacpi:Setting this to zero will disable the default scan of the interfaces identified via ACPI\00", section ".modinfo", align 1
@__param_trydmi = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_trydmi, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 0, i16 -1, %union.anon.46 { i8* @si_trydmi } }, section "__param", align 8
@__UNIQUE_ID_trydmitype1261 = internal constant [21 x i8] c"parmtype=trydmi:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_trydmi1263 = internal constant [100 x i8] c"parm=trydmi:Setting this to zero will disable the default scan of the interfaces identified via DMI\00", section ".modinfo", align 1
@__param_tryplatform = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_tryplatform, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 0, i16 -1, %union.anon.46 { i8* @si_tryplatform } }, section "__param", align 8
@__UNIQUE_ID_tryplatformtype1265 = internal constant [26 x i8] c"parmtype=tryplatform:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_tryacpi1268 = internal constant [135 x i8] c"parm=tryacpi:Setting this to zero will disable the default scan of the interfaces identified via platform interfaces like openfirmware\00", section ".modinfo", align 1
@__param_trypci = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_trypci, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 0, i16 -1, %union.anon.46 { i8* @si_trypci } }, section "__param", align 8
@__UNIQUE_ID_trypcitype1270 = internal constant [21 x i8] c"parmtype=trypci:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_tryacpi1272 = internal constant [101 x i8] c"parm=tryacpi:Setting this to zero will disable the default scan of the interfaces identified via pci\00", section ".modinfo", align 1
@__param_trydefaults = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_trydefaults, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 0, i16 -1, %union.anon.46 { i8* @si_trydefaults } }, section "__param", align 8
@__UNIQUE_ID_trydefaultstype1274 = internal constant [26 x i8] c"parmtype=trydefaults:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_trydefaults1277 = internal constant [125 x i8] c"parm=trydefaults:Setting this to 'false' will disable the default scan of the KCS and SMIC interface at the standard address\00", section ".modinfo", align 1
@__param_type = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_string* } } { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.53, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_string, i16 0, i16 -1, { %struct.kparam_string* } { %struct.kparam_string* @__param_string_type } }, section "__param", align 8
@__UNIQUE_ID_typetype1278 = internal constant [21 x i8] c"parmtype=type:string\00", section ".modinfo", align 1
@__UNIQUE_ID_type1282 = internal constant [207 x i8] c"parm=type:Defines the type of each interface, each interface separated by commas.  The types are 'kcs', 'smic', and 'bt'.  For example si_type=kcs,bt will set the first interface to kcs and the second to bt\00", section ".modinfo", align 1
@__param_addrs = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_addrs, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_addrs } }, section "__param", align 8
@__UNIQUE_ID_addrstype1283 = internal constant [30 x i8] c"parmtype=addrs:array of ulong\00", section ".modinfo", align 1
@__UNIQUE_ID_addrs1287 = internal constant [175 x i8] c"parm=addrs:Sets the memory address of each interface, the addresses separated by commas.  Only use if an interface is in memory.  Otherwise, set it to zero or leave it blank.\00", section ".modinfo", align 1
@__param_ports = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_ports, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_ports } }, section "__param", align 8
@__UNIQUE_ID_portstype1288 = internal constant [29 x i8] c"parmtype=ports:array of uint\00", section ".modinfo", align 1
@__UNIQUE_ID_ports1292 = internal constant [170 x i8] c"parm=ports:Sets the port address of each interface, the addresses separated by commas.  Only use if an interface is a port.  Otherwise, set it to zero or leave it blank.\00", section ".modinfo", align 1
@__param_irqs = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @__param_str_irqs, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_irqs } }, section "__param", align 8
@__UNIQUE_ID_irqstype1293 = internal constant [27 x i8] c"parmtype=irqs:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_irqs1297 = internal constant [173 x i8] c"parm=irqs:Sets the interrupt of each interface, the addresses separated by commas.  Only use if an interface has an interrupt.  Otherwise, set it to zero or leave it blank.\00", section ".modinfo", align 1
@__param_regspacings = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_regspacings, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_regspacings } }, section "__param", align 8
@__UNIQUE_ID_regspacingstype1298 = internal constant [34 x i8] c"parmtype=regspacings:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_regspacings1303 = internal constant [235 x i8] c"parm=regspacings:The number of bytes between the start address and each successive register used by the interface.  For instance, if the start address is 0xca2 and the spacing is 2, then the second address is at 0xca4.  Defaults to 1.\00", section ".modinfo", align 1
@__param_regsizes = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_regsizes, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_regsizes } }, section "__param", align 8
@__UNIQUE_ID_regsizestype1304 = internal constant [31 x i8] c"parmtype=regsizes:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_regsizes1309 = internal constant [232 x i8] c"parm=regsizes:The size of the specific IPMI register in bytes. This should generally be 1, 2, 4, or 8 for an 8-bit, 16-bit, 32-bit, or 64-bit register.  Use this if you the 8-bit IPMI register has to be read from a larger register.\00", section ".modinfo", align 1
@__param_regshifts = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_regshifts, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_regshifts } }, section "__param", align 8
@__UNIQUE_ID_regshiftstype1310 = internal constant [32 x i8] c"parmtype=regshifts:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_regshifts1314 = internal constant [197 x i8] c"parm=regshifts:The amount to shift the data read from the. IPMI register, in bits.  For instance, if the data is read from a 32-bit word and the IPMI data is in bit 8-15, then the shift would be 8\00", section ".modinfo", align 1
@__param_slave_addrs = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_slave_addrs, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_slave_addrs } }, section "__param", align 8
@__UNIQUE_ID_slave_addrstype1315 = internal constant [34 x i8] c"parmtype=slave_addrs:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_slave_addrs1319 = internal constant [179 x i8] c"parm=slave_addrs:Set the default IPMB slave address for the controller.  Normally this is 0x20, but can be overridden by this parm.  This is an array indexed by interface number.\00", section ".modinfo", align 1
@__param_force_kipmid = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__param_str_force_kipmid, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_force_kipmid } }, section "__param", align 8
@__UNIQUE_ID_force_kipmidtype1320 = internal constant [35 x i8] c"parmtype=force_kipmid:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_force_kipmid1323 = internal constant [166 x i8] c"parm=force_kipmid:Force the kipmi daemon to be enabled (1) or disabled(0).  Normally the IPMI driver auto-detects this, but the value may be overridden by this parm.\00", section ".modinfo", align 1
@__param_unload_when_empty = internal constant %struct.kernel_param { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__param_str_unload_when_empty, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 0, i16 -1, %union.anon.46 { i8* bitcast (i32* @unload_when_empty to i8*) } }, section "__param", align 8
@__UNIQUE_ID_unload_when_emptytype1324 = internal constant [31 x i8] c"parmtype=unload_when_empty:int\00", section ".modinfo", align 1
@__UNIQUE_ID_unload_when_empty1327 = internal constant [157 x i8] c"parm=unload_when_empty:Unload the module if no interfaces are specified or found, default is 1.  Setting to 0 is useful for hot add of devices using hotmod.\00", section ".modinfo", align 1
@__param_kipmid_max_busy_us = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__param_str_kipmid_max_busy_us, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 420, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_kipmid_max_busy_us } }, section "__param", align 8
@__UNIQUE_ID_kipmid_max_busy_ustype1328 = internal constant [42 x i8] c"parmtype=kipmid_max_busy_us:array of uint\00", section ".modinfo", align 1
@__UNIQUE_ID_kipmid_max_busy_us1332 = internal constant [186 x i8] c"parm=kipmid_max_busy_us:Max time (in microseconds) to busy-wait for IPMI data before sleeping. 0 (default) means to wait forever. Set to 100-500 if kipmid is using up a lot of CPU time.\00", section ".modinfo", align 1
@__UNIQUE_ID_license3621 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__UNIQUE_ID_author3622 = internal constant [42 x i8] c"author=Corey Minyard <minyard@mvista.com>\00", section ".modinfo", align 1
@__UNIQUE_ID_description3624 = internal constant [86 x i8] c"description=Interface to the IPMI driver for the KCS, SMIC, and BT system interfaces.\00", section ".modinfo", align 1
@__param_str_kipmid_max_busy_us = internal constant [19 x i8] c"kipmid_max_busy_us\00", align 16
@param_array_ops = external global %struct.kernel_param_ops, align 8
@__param_arr_kipmid_max_busy_us = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_max_busy_us, %struct.kernel_param_ops* @param_ops_uint, i8* bitcast ([4 x i32]* @kipmid_max_busy_us to i8*) }, align 8
@num_max_busy_us = internal global i32 0, align 4
@param_ops_uint = external global %struct.kernel_param_ops, align 8
@kipmid_max_busy_us = internal global [4 x i32] zeroinitializer, align 16
@__param_str_unload_when_empty = internal constant [18 x i8] c"unload_when_empty\00", align 16
@param_ops_int = external global %struct.kernel_param_ops, align 8
@unload_when_empty = internal global i32 1, align 4
@__param_str_force_kipmid = internal constant [13 x i8] c"force_kipmid\00", align 1
@__param_arr_force_kipmid = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_force_kipmid, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @force_kipmid to i8*) }, align 8
@num_force_kipmid = internal global i32 0, align 4
@force_kipmid = internal global [4 x i32] zeroinitializer, align 16
@__param_str_slave_addrs = internal constant [12 x i8] c"slave_addrs\00", align 1
@__param_arr_slave_addrs = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_slave_addrs, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @slave_addrs to i8*) }, align 8
@num_slave_addrs = internal global i32 0, align 4
@slave_addrs = internal global [4 x i32] zeroinitializer, align 16
@__param_str_regshifts = internal constant [10 x i8] c"regshifts\00", align 1
@__param_arr_regshifts = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_regshifts, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @regshifts to i8*) }, align 8
@num_regshifts = internal global i32 0, align 4
@regshifts = internal global [4 x i32] zeroinitializer, align 16
@__param_str_regsizes = internal constant [9 x i8] c"regsizes\00", align 1
@__param_arr_regsizes = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_regsizes, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @regsizes to i8*) }, align 8
@num_regsizes = internal global i32 0, align 4
@regsizes = internal global [4 x i32] zeroinitializer, align 16
@__param_str_regspacings = internal constant [12 x i8] c"regspacings\00", align 1
@__param_arr_regspacings = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_regspacings, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @regspacings to i8*) }, align 8
@num_regspacings = internal global i32 0, align 4
@regspacings = internal global [4 x i32] zeroinitializer, align 16
@__param_str_irqs = internal constant [5 x i8] c"irqs\00", align 1
@__param_arr_irqs = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_irqs, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([4 x i32]* @irqs to i8*) }, align 8
@num_irqs = internal global i32 0, align 4
@irqs = internal global [4 x i32] zeroinitializer, align 16
@__param_str_ports = internal constant [6 x i8] c"ports\00", align 1
@__param_arr_ports = internal constant %struct.kparam_array { i32 4, i32 4, i32* @num_ports, %struct.kernel_param_ops* @param_ops_uint, i8* bitcast ([4 x i32]* @ports to i8*) }, align 8
@num_ports = internal global i32 0, align 4
@ports = internal global [4 x i32] zeroinitializer, align 16
@__param_str_addrs = internal constant [6 x i8] c"addrs\00", align 1
@__param_arr_addrs = internal constant %struct.kparam_array { i32 4, i32 8, i32* @num_addrs, %struct.kernel_param_ops* @param_ops_ulong, i8* bitcast ([4 x i64]* @addrs to i8*) }, align 8
@num_addrs = internal global i32 0, align 4
@param_ops_ulong = external global %struct.kernel_param_ops, align 8
@addrs = internal global [4 x i64] zeroinitializer, align 16
@param_ops_string = external global %struct.kernel_param_ops, align 8
@__param_string_type = internal constant %struct.kparam_string { i32 30, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @si_type_str, i32 0, i32 0) }, align 8
@si_type_str = internal global [30 x i8] zeroinitializer, align 16
@__param_str_trydefaults = internal constant [12 x i8] c"trydefaults\00", align 1
@param_ops_bool = external global %struct.kernel_param_ops, align 8
@si_trydefaults = internal global i8 1, align 1
@__param_str_trypci = internal constant [7 x i8] c"trypci\00", align 1
@si_trypci = internal global i8 1, align 1
@__param_str_tryplatform = internal constant [12 x i8] c"tryplatform\00", align 1
@si_tryplatform = internal global i8 1, align 1
@__param_str_trydmi = internal constant [7 x i8] c"trydmi\00", align 1
@si_trydmi = internal global i8 1, align 1
@__param_str_tryacpi = internal constant [8 x i8] c"tryacpi\00", align 1
@si_tryacpi = internal global i8 1, align 1
@__param_ops_hotmod = internal global %struct.kernel_param_ops { i32 (i8*, %struct.kernel_param*)* @hotmod_handler, i32 (i8*, %struct.kernel_param*)* null, void (i8*)* null }, align 8
@_ctype = external constant [0 x i8], align 1
@hotmod_ops = internal global [3 x %struct.hotmod_vals] [%struct.hotmod_vals { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i32 0 }, %struct.hotmod_vals { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13, i32 0, i32 0), i32 1 }, %struct.hotmod_vals zeroinitializer], align 16
@.str = private unnamed_addr constant [10 x i8] c"operation\00", align 1
@hotmod_si = internal global [4 x %struct.hotmod_vals] [%struct.hotmod_vals { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i32 0 }, %struct.hotmod_vals { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.15, i32 0, i32 0), i32 1 }, %struct.hotmod_vals { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0), i32 2 }, %struct.hotmod_vals zeroinitializer], align 16
@.str.1 = private unnamed_addr constant [15 x i8] c"interface type\00", align 1
@hotmod_as = internal global [3 x %struct.hotmod_vals] [%struct.hotmod_vals { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i32 1 }, %struct.hotmod_vals { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i32 0 }, %struct.hotmod_vals zeroinitializer], align 16
@.str.2 = private unnamed_addr constant [14 x i8] c"address space\00", align 1
@.str.3 = private unnamed_addr constant [40 x i8] c"\014ipmi_si: Invalid hotmod address '%s'\0A\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"rsp\00", align 1
@.str.5 = private unnamed_addr constant [4 x i8] c"rsi\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"rsh\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"irq\00", align 1
@.str.8 = private unnamed_addr constant [5 x i8] c"ipmb\00", align 1
@.str.9 = private unnamed_addr constant [39 x i8] c"\014ipmi_si: Invalid hotmod option '%s'\0A\00", align 1
@smi_infos_lock = internal global %struct.mutex { %union.anon.1 { i32 1 }, %struct.spinlock { %union.anon.0 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.80, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @smi_infos_lock to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @smi_infos_lock to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @smi_infos_lock to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.81, i32 0, i32 0), i32 0, i64 0 } }, align 8
@smi_infos = internal global %struct.list_head { %struct.list_head* @smi_infos, %struct.list_head* @smi_infos }, align 8
@.str.80 = private unnamed_addr constant [25 x i8] c"smi_infos_lock.wait_lock\00", align 1
@.str.81 = private unnamed_addr constant [15 x i8] c"smi_infos_lock\00", align 1
@.str.79 = private unnamed_addr constant [50 x i8] c"\013ipmi_si: Unable to unregister device: errno=%d\0A\00", align 1
@jiffies = external global i64, align 8
@xaction_notifier_list = internal global %struct.atomic_notifier_head { %struct.spinlock { %union.anon.0 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.32, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.notifier_block* null }, align 8
@.str.32 = private unnamed_addr constant [27 x i8] c"xaction_notifier_list.lock\00", align 1
@.str.26 = private unnamed_addr constant [29 x i8] c"Error clearing flags: %2.2x\0A\00", align 1
@.str.27 = private unnamed_addr constant [28 x i8] c"Couldn't get irq info: %x.\0A\00", align 1
@.str.28 = private unnamed_addr constant [43 x i8] c"Maybe ok, but ipmi might run very slowly.\0A\00", align 1
@.str.29 = private unnamed_addr constant [28 x i8] c"Couldn't set irq info: %x.\0A\00", align 1
@.str.30 = private unnamed_addr constant [43 x i8] c"Could not disable interrupts, failed get.\0A\00", align 1
@.str.31 = private unnamed_addr constant [43 x i8] c"Could not disable interrupts, failed set.\0A\00", align 1
@ipmi_addr_src_to_str = internal global [9 x i8*] [i8* null, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.36, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.37, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.39, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.40, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.41, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.43, i32 0, i32 0)], align 16
@si_to_str = internal global [3 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0)], align 16
@addr_space_to_str = internal global [2 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0)], align 16
@.str.44 = private unnamed_addr constant [97 x i8] c"\016ipmi_si: Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\0A\00", align 1
@.str.45 = private unnamed_addr constant [52 x i8] c"\013ipmi_si: Could not allocate state machine memory\0A\00", align 1
@.str.46 = private unnamed_addr constant [39 x i8] c"\013ipmi_si: Could not set up I/O space\0A\00", align 1
@.str.47 = private unnamed_addr constant [39 x i8] c"\016ipmi_si: Interface detection failed\0A\00", align 1
@.str.48 = private unnamed_addr constant [56 x i8] c"\016ipmi_si: There appears to be no BMC at this location\0A\00", align 1
@smi_num = internal global i32 0, align 4
@.str.23 = private unnamed_addr constant [8 x i8] c"ipmi_si\00", align 1
@.str.49 = private unnamed_addr constant [47 x i8] c"\013ipmi_si: Unable to allocate platform device\0A\00", align 1
@ipmi_driver = internal global %struct.platform_driver { i32 (%struct.platform_device*)* @ipmi_probe, i32 (%struct.platform_device*)* @ipmi_remove, void (%struct.platform_device*)* null, i32 (%struct.platform_device*, i32)* null, i32 (%struct.platform_device*)* null, %struct.device_driver { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), %struct.bus_type* null, %struct.module* @__this_module, i8* null, i8 0, %struct.of_device_id* getelementptr inbounds ([4 x %struct.of_device_id], [4 x %struct.of_device_id]* @ipmi_match, i32 0, i32 0), %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.platform_device_id* null }, align 8
@.str.50 = private unnamed_addr constant [59 x i8] c"\013ipmi_si: Unable to register system interface device: %d\0A\00", align 1
@handlers = internal global %struct.ipmi_smi_handlers { %struct.module* @__this_module, i32 (i8*, %struct.ipmi_smi*)* @smi_start_processing, i32 (i8*, %struct.ipmi_smi_info*)* @get_smi_info, void (i8*, %struct.ipmi_smi_msg*, i32)* @sender, void (i8*)* @request_events, void (i8*, i32)* @set_run_to_completion, void (i8*)* @poll, void (i8*, i32)* @set_maintenance_mode, i32 (i8*)* null, void (i8*)* null }, align 8
@.str.51 = private unnamed_addr constant [4 x i8] c"bmc\00", align 1
@.str.52 = private unnamed_addr constant [37 x i8] c"Unable to register device: error %d\0A\00", align 1
@.str.53 = private constant [5 x i8] c"type\00", align 1
@smi_type_proc_ops = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @smi_type_proc_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @single_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.54 = private unnamed_addr constant [33 x i8] c"Unable to create proc entry: %d\0A\00", align 1
@.str.55 = private unnamed_addr constant [9 x i8] c"si_stats\00", align 1
@smi_si_stats_proc_ops = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @smi_si_stats_proc_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @single_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.56 = private unnamed_addr constant [7 x i8] c"params\00", align 1
@smi_params_proc_ops = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @smi_params_proc_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @single_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.57 = private unnamed_addr constant [31 x i8] c"IPMI %s interface initialized\0A\00", align 1
@.str.78 = private unnamed_addr constant [49 x i8] c"%s,%s,0x%lx,rsp=%d,rsi=%d,rsh=%d,irq=%d,ipmb=%d\0A\00", align 1
@.str.66 = private unnamed_addr constant [27 x i8] c"interrupts_enabled:    %d\0A\00", align 1
@.str.67 = private unnamed_addr constant [27 x i8] c"short_timeouts:        %u\0A\00", align 1
@.str.68 = private unnamed_addr constant [27 x i8] c"long_timeouts:         %u\0A\00", align 1
@.str.69 = private unnamed_addr constant [27 x i8] c"idles:                 %u\0A\00", align 1
@.str.70 = private unnamed_addr constant [27 x i8] c"interrupts:            %u\0A\00", align 1
@.str.71 = private unnamed_addr constant [27 x i8] c"attentions:            %u\0A\00", align 1
@.str.72 = private unnamed_addr constant [27 x i8] c"flag_fetches:          %u\0A\00", align 1
@.str.73 = private unnamed_addr constant [27 x i8] c"hosed_count:           %u\0A\00", align 1
@.str.74 = private unnamed_addr constant [27 x i8] c"complete_transactions: %u\0A\00", align 1
@.str.75 = private unnamed_addr constant [27 x i8] c"events:                %u\0A\00", align 1
@.str.76 = private unnamed_addr constant [27 x i8] c"watchdog_pretimeouts:  %u\0A\00", align 1
@.str.77 = private unnamed_addr constant [27 x i8] c"incoming_messages:     %u\0A\00", align 1
@__this_module = external global %struct.module, align 8
@.str.62 = private unnamed_addr constant [23 x i8] c"((&new_smi->si_timer))\00", align 1
@smi_start_processing.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.63 = private unnamed_addr constant [8 x i8] c"kipmi%d\00", align 1
@.str.64 = private unnamed_addr constant [90 x i8] c"Could not start kernel thread due to error %ld, only using timers to drive the interface\0A\00", align 1
@current_task = external global %struct.task_struct*, align 8
@ipmi_match = internal global [4 x %struct.of_device_id] [%struct.of_device_id { [32 x i8] zeroinitializer, [32 x i8] c"ipmi\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [128 x i8] c"ipmi-kcs\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i8* null }, %struct.of_device_id { [32 x i8] zeroinitializer, [32 x i8] c"ipmi\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [128 x i8] c"ipmi-smic\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i8* inttoptr (i64 1 to i8*) }, %struct.of_device_id { [32 x i8] zeroinitializer, [32 x i8] c"ipmi\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", [128 x i8] c"ipmi-bt\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i8* inttoptr (i64 2 to i8*) }, %struct.of_device_id zeroinitializer], align 16
@.str.58 = private unnamed_addr constant [101 x i8] c"\014ipmi_si: Error getting response from get global enables command, the event buffer is not enabled.\0A\00", align 1
@.str.59 = private unnamed_addr constant [92 x i8] c"\014ipmi_si: Invalid return from get global enables command, cannot enable the event buffer.\0A\00", align 1
@.str.60 = private unnamed_addr constant [102 x i8] c"\014ipmi_si: Error getting response from set global, enables command, the event buffer is not enabled.\0A\00", align 1
@.str.61 = private unnamed_addr constant [89 x i8] c"\014ipmi_si: Invalid return from get global,enables command, not enable the event buffer.\0A\00", align 1
@dell_poweredge_bt_xaction_notifier = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @dell_poweredge_bt_xaction_handler, %struct.notifier_block* null, i32 0 }, align 8
@.str.18 = private unnamed_addr constant [4 x i8] c"i/o\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"mem\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"kcs\00", align 1
@.str.15 = private unnamed_addr constant [5 x i8] c"smic\00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"bt\00", align 1
@.str.36 = private constant [7 x i8] c"hotmod\00", align 1
@.str.37 = private unnamed_addr constant [10 x i8] c"hardcoded\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"SPMI\00", align 1
@.str.39 = private unnamed_addr constant [5 x i8] c"ACPI\00", align 1
@.str.40 = private unnamed_addr constant [7 x i8] c"SMBIOS\00", align 1
@.str.41 = private unnamed_addr constant [4 x i8] c"PCI\00", align 1
@.str.42 = private unnamed_addr constant [12 x i8] c"device-tree\00", align 1
@.str.43 = private unnamed_addr constant [8 x i8] c"default\00", align 1
@.str.33 = private unnamed_addr constant [48 x i8] c"\016ipmi_si: Adding %s-specified %s state machine\00", align 1
@.str.34 = private unnamed_addr constant [22 x i8] c" duplicate interface\0A\00", align 1
@.str.24 = private unnamed_addr constant [49 x i8] c"%s unable to claim interrupt %d, running polled\0A\00", align 1
@.str.25 = private unnamed_addr constant [14 x i8] c"Using irq %d\0A\00", align 1
@.str.22 = private unnamed_addr constant [27 x i8] c"Invalid register size: %d\0A\00", align 1
@ioport_resource = external global %struct.resource, align 8
@iomem_resource = external global %struct.resource, align 8
@.str.21 = private unnamed_addr constant [25 x i8] c"&(&info->si_lock)->rlock\00", align 1
@smi_info_alloc.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.19 = private unnamed_addr constant [37 x i8] c"\014ipmi_si: No option given for '%s'\0A\00", align 1
@.str.20 = private unnamed_addr constant [38 x i8] c"\014ipmi_si: Bad option given for '%s'\0A\00", align 1
@.str.10 = private unnamed_addr constant [32 x i8] c"\014ipmi_si: No hotmod %s given.\0A\00", align 1
@.str.11 = private unnamed_addr constant [35 x i8] c"\014ipmi_si: Invalid hotmod %s '%s'\0A\00", align 1
@.str.12 = private unnamed_addr constant [4 x i8] c"add\00", align 1
@.str.13 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@ipmi_pci_devices = internal global [3 x %struct.pci_device_id] [%struct.pci_device_id { i32 4156, i32 4634, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 -1, i32 -1, i32 -1, i32 -1, i32 788224, i32 -256, i64 0 }, %struct.pci_device_id zeroinitializer], align 16
@initialized = internal global i32 0, align 4
@.str.84 = private unnamed_addr constant [42 x i8] c"\013ipmi_si: Unable to register driver: %d\0A\00", align 1
@si_type = internal global [4 x i8*] zeroinitializer, align 16
@.str.85 = private unnamed_addr constant [33 x i8] c"\016IPMI System Interface driver.\0A\00", align 1
@ipmi_pci_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([3 x %struct.pci_device_id], [3 x %struct.pci_device_id]* @ipmi_pci_devices, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @ipmi_pci_probe, void (%struct.pci_dev*)* @ipmi_pci_remove, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, %struct.pci_error_handlers* null, %struct.device_driver zeroinitializer, %struct.__wait_queue_head zeroinitializer }, align 8
@.str.86 = private unnamed_addr constant [46 x i8] c"\013ipmi_si: Unable to register PCI driver: %d\0A\00", align 1
@pci_registered = internal global i32 0, align 4
@ipmi_pnp_driver = internal global %struct.pnp_driver { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), %struct.pnp_device_id* getelementptr inbounds ([2 x %struct.pnp_device_id], [2 x %struct.pnp_device_id]* @pnp_dev_table, i32 0, i32 0), i32 0, i32 (%struct.pnp_dev*, %struct.pnp_device_id*)* @ipmi_pnp_probe, void (%struct.pnp_dev*)* @ipmi_pnp_remove, void (%struct.pnp_dev*)* null, i32 (%struct.pnp_dev*, i32)* null, i32 (%struct.pnp_dev*)* null, %struct.device_driver zeroinitializer }, align 8
@pnp_registered = internal global i32 0, align 4
@.str.87 = private unnamed_addr constant [51 x i8] c"\014ipmi_si: Unable to find any System Interface(s)\0A\00", align 1
@ipmi_defaults = internal global [4 x %struct.exception_table_entry] [%struct.exception_table_entry { i32 0, i32 3234 }, %struct.exception_table_entry { i32 1, i32 3241 }, %struct.exception_table_entry { i32 2, i32 228 }, %struct.exception_table_entry zeroinitializer], align 16
@.str.114 = private unnamed_addr constant [63 x i8] c"\016ipmi_si: Found default %s state machine at %s address 0x%lx\0A\00", align 1
@acpi_disabled = external global i32, align 4
@acpi_failure = internal global i32 0, align 4
@.str.108 = private unnamed_addr constant [31 x i8] c"\016ipmi_si: Bad SPMI legacy %d\0A\00", align 1
@.str.109 = private unnamed_addr constant [43 x i8] c"\013ipmi_si: Could not allocate SI data (3)\0A\00", align 1
@.str.110 = private unnamed_addr constant [29 x i8] c"\016ipmi_si: probing via SPMI\0A\00", align 1
@.str.111 = private unnamed_addr constant [41 x i8] c"\016ipmi_si: Unknown ACPI/SPMI SI type %d\0A\00", align 1
@.str.112 = private unnamed_addr constant [42 x i8] c"\014ipmi_si: Unknown ACPI I/O Address type\0A\00", align 1
@.str.107 = private unnamed_addr constant [3 x i8] c"io\00", align 1
@.str.113 = private unnamed_addr constant [55 x i8] c"\016ipmi_si: SPMI: %s %#lx regsize %d spacing %d irq %d\0A\00", align 1
@.str.101 = private unnamed_addr constant [48 x i8] c"%s unable to claim ACPI GPE %d, running polled\0A\00", align 1
@.str.102 = private unnamed_addr constant [19 x i8] c"Using ACPI GPE %d\0A\00", align 1
@.str.103 = private unnamed_addr constant [39 x i8] c"\013ipmi_si: Could not allocate SI data\0A\00", align 1
@.str.104 = private unnamed_addr constant [31 x i8] c"\016ipmi_si: probing via SMBIOS\0A\00", align 1
@.str.105 = private unnamed_addr constant [48 x i8] c"\014ipmi_si: Unknown SMBIOS I/O Address type: %d\0A\00", align 1
@.str.106 = private unnamed_addr constant [57 x i8] c"\016ipmi_si: SMBIOS: %s %#lx regsize %d spacing %d irq %d\0A\00", align 1
@pnp_dev_table = internal constant [2 x %struct.pnp_device_id] [%struct.pnp_device_id { [8 x i8] c"IPI0001\00", i64 0 }, %struct.pnp_device_id zeroinitializer], align 16
@.str.96 = private unnamed_addr constant [29 x i8] c"\016ipmi_si: probing via ACPI\0A\00", align 1
@.str.97 = private unnamed_addr constant [5 x i8] c"_IFT\00", align 1
@.str.98 = private unnamed_addr constant [24 x i8] c"unknown IPMI type %lld\0A\00", align 1
@.str.99 = private unnamed_addr constant [26 x i8] c"no I/O or memory address\0A\00", align 1
@.str.100 = private unnamed_addr constant [5 x i8] c"_GPE\00", align 1
@.str.94 = private unnamed_addr constant [34 x i8] c"%pR regsize %d spacing %d irq %d\0A\00", align 1
@pnpacpi_protocol = external global %struct.pnp_protocol, align 8
@.str.91 = private unnamed_addr constant [16 x i8] c"probing via PCI\00", align 1
@.str.92 = private unnamed_addr constant [23 x i8] c"Unknown IPMI type: %d\0A\00", align 1
@.str.93 = private unnamed_addr constant [28 x i8] c"couldn't enable PCI device\0A\00", align 1
@.str.95 = private unnamed_addr constant [27 x i8] c"Could not setup I/O space\0A\00", align 1
@.str.88 = private unnamed_addr constant [42 x i8] c"\016ipmi_si: probing via hardcoded address\0A\00", align 1
@.str.89 = private unnamed_addr constant [71 x i8] c"\014ipmi_si: Interface type specified for interface %d, was invalid: %s\0A\00", align 1
@.str.90 = private unnamed_addr constant [105 x i8] c"\014ipmi_si: Interface type specified for interface %d, but port and address were not set or set to zero.\0A\00", align 1
@kcs_smi_handlers = global %struct.si_sm_handlers { i8* null, i32 (%struct.si_sm_data*, %struct.si_sm_io*)* @init_kcs_data, i32 (%struct.si_sm_data*, i8*, i32)* @start_kcs_transaction, i32 (%struct.si_sm_data*, i8*, i32)* @get_kcs_result, i32 (%struct.si_sm_data*, i64)* @kcs_event, i32 (%struct.si_sm_data*)* @kcs_detect, void (%struct.si_sm_data*)* @kcs_cleanup, i32 ()* @kcs_size }, align 8
@kcs_debug = internal global i32 0, align 4
@.str.3.3 = private unnamed_addr constant [23 x i8] c"\017KCS: State = %d, %x\0A\00", align 1
@.str.4.4 = private unnamed_addr constant [32 x i8] c"State machine not idle at start\00", align 1
@.str.5.5 = private unnamed_addr constant [34 x i8] c"Not in write state at write start\00", align 1
@.str.6.6 = private unnamed_addr constant [29 x i8] c"Not in write state for write\00", align 1
@.str.7.7 = private unnamed_addr constant [33 x i8] c"Not in write state for write end\00", align 1
@.str.8.8 = private unnamed_addr constant [34 x i8] c"Not in read or idle in read state\00", align 1
@.str.9.9 = private unnamed_addr constant [29 x i8] c"Not in read state for error2\00", align 1
@.str.10.10 = private unnamed_addr constant [29 x i8] c"Not in idle state for error3\00", align 1
@.str.13.11 = private unnamed_addr constant [22 x i8] c"OBF not ready in time\00", align 1
@.str.12.12 = private unnamed_addr constant [30 x i8] c"\017ipmi_kcs_sm: kcs hosed: %s\0A\00", align 1
@.str.11.13 = private unnamed_addr constant [22 x i8] c"IBF not ready in time\00", align 1
@.str.82 = private unnamed_addr constant [26 x i8] c"\017start_kcs_transaction -\00", align 1
@__param_kcs_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_kcs_debug, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 420, i16 -1, %union.anon.46 { i8* bitcast (i32* @kcs_debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_kcs_debugtype58 = internal constant [23 x i8] c"parmtype=kcs_debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_kcs_debug59 = internal constant [61 x i8] c"parm=kcs_debug:debug bitmask, 1=enable, 2=messages, 4=states\00", section ".modinfo", align 1
@__param_str_kcs_debug = internal constant [10 x i8] c"kcs_debug\00", align 1
@smic_smi_handlers = global %struct.si_sm_handlers.12 { i8* null, i32 (%struct.si_sm_data.13*, %struct.si_sm_io*)* @init_smic_data, i32 (%struct.si_sm_data.13*, i8*, i32)* @start_smic_transaction, i32 (%struct.si_sm_data.13*, i8*, i32)* @smic_get_result, i32 (%struct.si_sm_data.13*, i64)* @smic_event, i32 (%struct.si_sm_data.13*)* @smic_detect, void (%struct.si_sm_data.13*)* @smic_cleanup, i32 ()* @smic_size }, align 8
@smic_debug = internal global i32 1, align 4
@.str.4.88 = private unnamed_addr constant [53 x i8] c"\017smic_event - smic->smic_timeout = %ld, time = %ld\0A\00", align 1
@.str.5.89 = private unnamed_addr constant [16 x i8] c"smic timed out.\00", align 1
@.str.6.91 = private unnamed_addr constant [60 x i8] c"\017smic_event - state = %d, flags = 0x%02x, status = 0x%02x\0A\00", align 1
@.str.7.92 = private unnamed_addr constant [48 x i8] c"state = SMIC_OP_OK, status != SMIC_SC_SMS_READY\00", align 1
@.str.8.94 = private unnamed_addr constant [57 x i8] c"state = SMIC_WRITE_START, status != SMIC_SC_SMS_WR_START\00", align 1
@.str.9.95 = private unnamed_addr constant [55 x i8] c"state = SMIC_WRITE_NEXT, status != SMIC_SC_SMS_WR_NEXT\00", align 1
@.str.10.96 = private unnamed_addr constant [53 x i8] c"state = SMIC_WRITE_END, status != SMIC_SC_SMS_WR_END\00", align 1
@.str.11.97 = private unnamed_addr constant [31 x i8] c"\017SMIC_WRITE_END: data = %02x\0A\00", align 1
@.str.12.98 = private unnamed_addr constant [40 x i8] c"state = SMIC_WRITE_END, data != SUCCESS\00", align 1
@.str.13.99 = private unnamed_addr constant [56 x i8] c"state = SMIC_READ_START, status != SMIC_SC_SMS_RD_START\00", align 1
@.str.14.101 = private unnamed_addr constant [60 x i8] c"state = SMIC_READ_NEXT, status != SMIC_SC_SMS_RD_(NEXT|END)\00", align 1
@.str.15.102 = private unnamed_addr constant [51 x i8] c"state = SMIC_READ_END, status != SMIC_SC_SMS_READY\00", align 1
@.str.16.103 = private unnamed_addr constant [30 x i8] c"\017SMIC_READ_END: data = %02x\0A\00", align 1
@.str.17.104 = private unnamed_addr constant [39 x i8] c"state = SMIC_READ_END, data != SUCCESS\00", align 1
@.str.18.105 = private unnamed_addr constant [20 x i8] c"\017smic->state = %d\0A\00", align 1
@.str.19.106 = private unnamed_addr constant [16 x i8] c"state = UNKNOWN\00", align 1
@.str.20.107 = private unnamed_addr constant [33 x i8] c"\014ipmi_smic_drv: smic hosed: %s\0A\00", align 1
@.str.3.108 = private unnamed_addr constant [20 x i8] c"\017smic_get result -\00", align 1
@.str.115 = private unnamed_addr constant [27 x i8] c"\017start_smic_transaction -\00", align 1
@__param_smic_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__param_str_smic_debug, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 420, i16 -1, %union.anon.46 { i8* bitcast (i32* @smic_debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_smic_debugtype61 = internal constant [24 x i8] c"parmtype=smic_debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_smic_debug62 = internal constant [62 x i8] c"parm=smic_debug:debug bitmask, 1=enable, 2=messages, 4=states\00", section ".modinfo", align 1
@__param_str_smic_debug = internal constant [11 x i8] c"smic_debug\00", align 1
@bt_smi_handlers = global %struct.si_sm_handlers.21 { i8* null, i32 (%struct.si_sm_data.22*, %struct.si_sm_io*)* @bt_init_data, i32 (%struct.si_sm_data.22*, i8*, i32)* @bt_start_transaction, i32 (%struct.si_sm_data.22*, i8*, i32)* @bt_get_result, i32 (%struct.si_sm_data.22*, i64)* @bt_event, i32 (%struct.si_sm_data.22*)* @bt_detect, void (%struct.si_sm_data.22*)* @bt_cleanup, i32 ()* @bt_size }, align 8
@bt_debug = internal global i32 0, align 4
@.str.47.119 = private unnamed_addr constant [26 x i8] c"\014IPMI BT: flag reset %s\0A\00", align 1
@status2txt.buf = internal global [40 x i8] zeroinitializer, align 16
@.str.23.120 = private unnamed_addr constant [3 x i8] c"[ \00", align 1
@.str.24.121 = private unnamed_addr constant [8 x i8] c"B_BUSY \00", align 1
@.str.25.122 = private unnamed_addr constant [8 x i8] c"H_BUSY \00", align 1
@.str.26.123 = private unnamed_addr constant [6 x i8] c"OEM0 \00", align 1
@.str.27.124 = private unnamed_addr constant [5 x i8] c"SMS \00", align 1
@.str.28.125 = private unnamed_addr constant [5 x i8] c"B2H \00", align 1
@.str.29.126 = private unnamed_addr constant [5 x i8] c"H2B \00", align 1
@.str.30.127 = private unnamed_addr constant [2 x i8] c"]\00", align 1
@bt_event.last_printed = internal global i32 11, align 4
@.str.5.128 = private unnamed_addr constant [27 x i8] c"\014BT: %s %s TO=%ld - %ld \0A\00", align 1
@bt_event.GetBT_CAP = private unnamed_addr constant [2 x i8] c"\186", align 1
@.str.6.129 = private unnamed_addr constant [33 x i8] c"\014IPMI BT: using default values\0A\00", align 1
@.str.7.130 = private unnamed_addr constant [40 x i8] c"\014IPMI BT: req2rsp=%ld secs retries=%d\0A\00", align 1
@.str.41.131 = private unnamed_addr constant [26 x i8] c"\014BT: bad raw rsp len=%d\0A\00", align 1
@.str.42.132 = private unnamed_addr constant [30 x i8] c"\014BT: got %d bytes seq=0x%02X\00", align 1
@.str.2.133 = private unnamed_addr constant [6 x i8] c" %02x\00", align 1
@.str.44.134 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.45.135 = private unnamed_addr constant [5 x i8] c" ...\00", align 1
@.str.43.136 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.46.137 = private unnamed_addr constant [73 x i8] c"\014IPMI BT: bad packet: want 0x(%02X, %02X, %02X) got (%02X, %02X, %02X)\0A\00", align 1
@.str.40.138 = private unnamed_addr constant [32 x i8] c"\014BT: write %d bytes seq=0x%02X\00", align 1
@.str.3.139 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.33.140 = private unnamed_addr constant [8 x i8] c"timeout\00", align 1
@.str.34.141 = private unnamed_addr constant [15 x i8] c"internal error\00", align 1
@.str.35.142 = private unnamed_addr constant [24 x i8] c"\014IPMI BT: %s in %s %s \00", align 1
@.str.36.143 = private unnamed_addr constant [17 x i8] c"%d retries left\0A\00", align 1
@.str.37.144 = private unnamed_addr constant [45 x i8] c"\014failed %d retries, sending error response\0A\00", align 1
@.str.38.145 = private unnamed_addr constant [35 x i8] c"\013IPMI BT: stuck, try power cycle\0A\00", align 1
@.str.39.146 = private unnamed_addr constant [33 x i8] c"\014IPMI: BT reset (takes 5 secs)\0A\00", align 1
@.str.31.147 = private unnamed_addr constant [31 x i8] c"\014IPMI BT: stale response %s; \00", align 1
@.str.32.148 = private unnamed_addr constant [18 x i8] c"drained %d bytes\0A\00", align 1
@.str.16.149 = private unnamed_addr constant [7 x i8] c"RESET2\00", align 1
@.str.17.150 = private unnamed_addr constant [7 x i8] c"RESET3\00", align 1
@.str.13.151 = private unnamed_addr constant [10 x i8] c"CLEAR_B2H\00", align 1
@.str.14.152 = private unnamed_addr constant [9 x i8] c"RD_BYTES\00", align 1
@.str.11.153 = private unnamed_addr constant [11 x i8] c"WR_CONSUME\00", align 1
@.str.12.154 = private unnamed_addr constant [8 x i8] c"RD_WAIT\00", align 1
@.str.9.155 = private unnamed_addr constant [8 x i8] c"XACTION\00", align 1
@.str.10.156 = private unnamed_addr constant [9 x i8] c"WR_BYTES\00", align 1
@.str.22.157 = private unnamed_addr constant [10 x i8] c"BAD STATE\00", align 1
@.str.8.158 = private unnamed_addr constant [5 x i8] c"IDLE\00", align 1
@.str.15.159 = private unnamed_addr constant [7 x i8] c"RESET1\00", align 1
@.str.18.160 = private unnamed_addr constant [8 x i8] c"RESTART\00", align 1
@.str.19.161 = private unnamed_addr constant [10 x i8] c"LONG_BUSY\00", align 1
@.str.20.162 = private unnamed_addr constant [10 x i8] c"CAP_BEGIN\00", align 1
@.str.21.163 = private unnamed_addr constant [8 x i8] c"CAP_END\00", align 1
@.str.4.164 = private unnamed_addr constant [23 x i8] c"\014BT: result %d bytes:\00", align 1
@.str.165 = private unnamed_addr constant [37 x i8] c"\014BT: +++++++++++++++++ New command\0A\00", align 1
@.str.1.166 = private unnamed_addr constant [31 x i8] c"\014BT: NetFn/LUN CMD [%d data]:\00", align 1
@__param_bt_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_bt_debug, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 420, i16 -1, %union.anon.46 { i8* bitcast (i32* @bt_debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_bt_debugtype47 = internal constant [22 x i8] c"parmtype=bt_debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_bt_debug48 = internal constant [60 x i8] c"parm=bt_debug:debug bitmask, 1=enable, 2=messages, 4=states\00", section ".modinfo", align 1
@__param_str_bt_debug = internal constant [9 x i8] c"bt_debug\00", align 1

@__mod_pci_device_table = alias %struct.pci_device_id, getelementptr inbounds ([3 x %struct.pci_device_id], [3 x %struct.pci_device_id]* @ipmi_pci_devices, i32 0, i32 0)
@init_module = alias i32 (), i32 ()* @init_ipmi_si
@cleanup_module = alias void (), void ()* @cleanup_ipmi_si

; Function Attrs: nounwind uwtable
define internal i32 @hotmod_handler(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %curr = alloca i8*, align 8
  %n = alloca i8*, align 8
  %addr_space = alloca i32, align 4
  %regspacing = alloca i32, align 4
  %regsize = alloca i32, align 4
  %regshift = alloca i32, align 4
  %irq = alloca i32, align 4
  %ipmb = alloca i32, align 4
  %ival = alloca i32, align 4
  %call = call i8* @kstrdup(i8* %val, i32 208)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i64 @strlen(i8* %call)
  %conv = trunc i64 %call1 to i32
  %sub = sub nsw i32 %conv, 1
  store i32 %sub, i32* %ival, align 4, !tbaa !2
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %0 = load i32, i32* %ival, align 4, !tbaa !2
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %while.cond
  %1 = load i32, i32* %ival, align 4, !tbaa !2
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds i8, i8* %call, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv3 = zext i8 %2 to i32
  %idxprom4 = sext i32 %conv3 to i64
  %arrayidx5 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom4
  %3 = load i8, i8* %arrayidx5, align 1, !tbaa !6
  %conv6 = zext i8 %3 to i32
  %and = and i32 %conv6, 32
  %cmp7 = icmp ne i32 %and, 0
  br i1 %cmp7, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %4 = load i32, i32* %ival, align 4, !tbaa !2
  %idxprom9 = sext i32 %4 to i64
  %arrayidx10 = getelementptr inbounds i8, i8* %call, i64 %idxprom9
  store i8 0, i8* %arrayidx10, align 1, !tbaa !6
  %5 = load i32, i32* %ival, align 4, !tbaa !2
  %dec = add nsw i32 %5, -1
  store i32 %dec, i32* %ival, align 4, !tbaa !2
  br label %while.cond

while.end:                                        ; preds = %land.rhs, %while.cond
  store i8* %call, i8** %curr, align 8, !tbaa !7
  br label %for.cond

for.cond:                                         ; preds = %for.inc187, %while.end
  %6 = load i8*, i8** %curr, align 8, !tbaa !7
  %tobool11 = icmp ne i8* %6, null
  br i1 %tobool11, label %for.body, label %out

for.body:                                         ; preds = %for.cond
  store i32 1, i32* %regspacing, align 4, !tbaa !2
  store i32 1, i32* %regsize, align 4, !tbaa !2
  store i32 0, i32* %regshift, align 4, !tbaa !2
  store i32 0, i32* %irq, align 4, !tbaa !2
  store i32 0, i32* %ipmb, align 4, !tbaa !2
  %7 = load i8*, i8** %curr, align 8, !tbaa !7
  %call12 = call i8* @strchr(i8* %7, i32 58)
  %tobool13 = icmp ne i8* %call12, null
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %for.body
  store i8 0, i8* %call12, align 1, !tbaa !6
  %incdec.ptr = getelementptr inbounds i8, i8* %call12, i32 1
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %for.body
  %next.0 = phi i8* [ %incdec.ptr, %if.then14 ], [ %call12, %for.body ]
  %call16 = call i32 @parse_str(%struct.hotmod_vals* getelementptr inbounds ([3 x %struct.hotmod_vals], [3 x %struct.hotmod_vals]* @hotmod_ops, i32 0, i32 0), i32* %ival, i8** %curr)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %out, label %if.end19

if.end19:                                         ; preds = %if.end15
  %8 = load i32, i32* %ival, align 4, !tbaa !2
  %call20 = call i32 @parse_str(%struct.hotmod_vals* getelementptr inbounds ([4 x %struct.hotmod_vals], [4 x %struct.hotmod_vals]* @hotmod_si, i32 0, i32 0), i32* %ival, i8** %curr)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %out, label %if.end23

if.end23:                                         ; preds = %if.end19
  %9 = load i32, i32* %ival, align 4, !tbaa !2
  %call24 = call i32 @parse_str(%struct.hotmod_vals* getelementptr inbounds ([3 x %struct.hotmod_vals], [3 x %struct.hotmod_vals]* @hotmod_as, i32 0, i32 0), i32* %addr_space, i8** %curr)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %out, label %if.end27

if.end27:                                         ; preds = %if.end23
  %10 = load i8*, i8** %curr, align 8, !tbaa !7
  %call28 = call i8* @strchr(i8* %10, i32 44)
  %tobool29 = icmp ne i8* %call28, null
  br i1 %tobool29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end27
  store i8 0, i8* %call28, align 1, !tbaa !6
  %incdec.ptr31 = getelementptr inbounds i8, i8* %call28, i32 1
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.end27
  %s.0 = phi i8* [ %incdec.ptr31, %if.then30 ], [ %call28, %if.end27 ]
  %11 = load i8*, i8** %curr, align 8, !tbaa !7
  %call33 = call i64 @simple_strtoul(i8* %11, i8** %n, i32 0)
  %12 = load i8*, i8** %n, align 8, !tbaa !7
  %13 = load i8, i8* %12, align 1, !tbaa !6
  %conv34 = sext i8 %13 to i32
  %cmp35 = icmp ne i32 %conv34, 0
  br i1 %cmp35, label %if.then40, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end32
  %14 = load i8*, i8** %curr, align 8, !tbaa !7
  %15 = load i8, i8* %14, align 1, !tbaa !6
  %conv37 = sext i8 %15 to i32
  %cmp38 = icmp eq i32 %conv37, 0
  br i1 %cmp38, label %if.then40, label %if.end42

if.then40:                                        ; preds = %lor.lhs.false, %if.end32
  %16 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

if.end42:                                         ; preds = %lor.lhs.false
  br label %while.cond43

while.cond43:                                     ; preds = %while.cond43.backedge, %if.end42
  %s.1 = phi i8* [ %s.0, %if.end42 ], [ %s.2, %while.cond43.backedge ]
  %tobool44 = icmp ne i8* %s.1, null
  br i1 %tobool44, label %while.body45, label %while.end101

while.body45:                                     ; preds = %while.cond43
  store i8* %s.1, i8** %curr, align 8, !tbaa !7
  %17 = load i8*, i8** %curr, align 8, !tbaa !7
  %call46 = call i8* @strchr(i8* %17, i32 44)
  %tobool47 = icmp ne i8* %call46, null
  br i1 %tobool47, label %if.then48, label %if.end50

if.then48:                                        ; preds = %while.body45
  store i8 0, i8* %call46, align 1, !tbaa !6
  %incdec.ptr49 = getelementptr inbounds i8, i8* %call46, i32 1
  br label %if.end50

if.end50:                                         ; preds = %if.then48, %while.body45
  %s.2 = phi i8* [ %incdec.ptr49, %if.then48 ], [ %call46, %while.body45 ]
  %18 = load i8*, i8** %curr, align 8, !tbaa !7
  %call51 = call i8* @strchr(i8* %18, i32 61)
  %tobool52 = icmp ne i8* %call51, null
  br i1 %tobool52, label %if.then53, label %if.end55

if.then53:                                        ; preds = %if.end50
  store i8 0, i8* %call51, align 1, !tbaa !6
  %incdec.ptr54 = getelementptr inbounds i8, i8* %call51, i32 1
  br label %if.end55

if.end55:                                         ; preds = %if.then53, %if.end50
  %o.0 = phi i8* [ %incdec.ptr54, %if.then53 ], [ %call51, %if.end50 ]
  %19 = load i8*, i8** %curr, align 8, !tbaa !7
  %call56 = call i32 @check_hotmod_int_op(i8* %19, i8* %o.0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i32* %regspacing)
  %cmp57 = icmp slt i32 %call56, 0
  br i1 %cmp57, label %out, label %if.else

if.else:                                          ; preds = %if.end55
  %tobool60 = icmp ne i32 %call56, 0
  br i1 %tobool60, label %while.cond43.backedge, label %if.end63

while.cond43.backedge:                            ; preds = %if.else95, %if.else86, %if.else77, %if.else68, %if.else
  br label %while.cond43

if.end63:                                         ; preds = %if.else
  %20 = load i8*, i8** %curr, align 8, !tbaa !7
  %call64 = call i32 @check_hotmod_int_op(i8* %20, i8* %o.0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5, i32 0, i32 0), i32* %regsize)
  %cmp65 = icmp slt i32 %call64, 0
  br i1 %cmp65, label %out, label %if.else68

if.else68:                                        ; preds = %if.end63
  %tobool69 = icmp ne i32 %call64, 0
  br i1 %tobool69, label %while.cond43.backedge, label %if.end72

if.end72:                                         ; preds = %if.else68
  %21 = load i8*, i8** %curr, align 8, !tbaa !7
  %call73 = call i32 @check_hotmod_int_op(i8* %21, i8* %o.0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i32* %regshift)
  %cmp74 = icmp slt i32 %call73, 0
  br i1 %cmp74, label %out, label %if.else77

if.else77:                                        ; preds = %if.end72
  %tobool78 = icmp ne i32 %call73, 0
  br i1 %tobool78, label %while.cond43.backedge, label %if.end81

if.end81:                                         ; preds = %if.else77
  %22 = load i8*, i8** %curr, align 8, !tbaa !7
  %call82 = call i32 @check_hotmod_int_op(i8* %22, i8* %o.0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0), i32* %irq)
  %cmp83 = icmp slt i32 %call82, 0
  br i1 %cmp83, label %out, label %if.else86

if.else86:                                        ; preds = %if.end81
  %tobool87 = icmp ne i32 %call82, 0
  br i1 %tobool87, label %while.cond43.backedge, label %if.end90

if.end90:                                         ; preds = %if.else86
  %23 = load i8*, i8** %curr, align 8, !tbaa !7
  %call91 = call i32 @check_hotmod_int_op(i8* %23, i8* %o.0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.8, i32 0, i32 0), i32* %ipmb)
  %cmp92 = icmp slt i32 %call91, 0
  br i1 %cmp92, label %out, label %if.else95

if.else95:                                        ; preds = %if.end90
  %tobool96 = icmp ne i32 %call91, 0
  br i1 %tobool96, label %while.cond43.backedge, label %if.end99

if.end99:                                         ; preds = %if.else95
  %24 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

while.end101:                                     ; preds = %while.cond43
  %cmp102 = icmp eq i32 %8, 0
  br i1 %cmp102, label %if.then104, label %if.else154

if.then104:                                       ; preds = %while.end101
  %call.i = call i8* @kzalloc(i64 568, i32 208) #5
  %25 = bitcast i8* %call.i to %struct.smi_info*
  %tobool.i = icmp ne %struct.smi_info* %25, null
  br i1 %tobool.i, label %do.body.i, label %smi_info_alloc.exit

do.body.i:                                        ; preds = %if.then104
  %si_lock3.i = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 5
  %26 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock3.i, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %26 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock.i, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.21, i32 0, i32 0), %struct.lock_class_key* @smi_info_alloc.__key) #5
  br label %smi_info_alloc.exit

smi_info_alloc.exit:                              ; preds = %do.body.i, %if.then104
  %tobool106 = icmp ne %struct.smi_info* %25, null
  br i1 %tobool106, label %if.end108, label %out

if.end108:                                        ; preds = %smi_info_alloc.exit
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 16
  store i32 1, i32* %addr_source, align 4, !tbaa !9
  %si_type109 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 4
  store i32 %9, i32* %si_type109, align 8, !tbaa !19
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  store i64 %call33, i64* %addr_data, align 8, !tbaa !20
  %27 = load i32, i32* %addr_space, align 4, !tbaa !2
  %io110 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 10
  %addr_type = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io110, i32 0, i32 6
  store i32 %27, i32* %addr_type, align 4, !tbaa !21
  %28 = load i32, i32* %addr_space, align 4, !tbaa !2
  %cmp111 = icmp eq i32 %28, 1
  %io_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 11
  %port_setup.sink = select i1 %cmp111, i32 (%struct.smi_info*)* @mem_setup, i32 (%struct.smi_info*)* @port_setup
  store i32 (%struct.smi_info*)* %port_setup.sink, i32 (%struct.smi_info*)** %io_setup, align 8, !tbaa !22
  %io117 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 10
  %addr118 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io117, i32 0, i32 2
  store i8* null, i8** %addr118, align 8, !tbaa !23
  %29 = load i32, i32* %regspacing, align 4, !tbaa !2
  %io119 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 10
  %regspacing120 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io119, i32 0, i32 3
  store i32 %29, i32* %regspacing120, align 8, !tbaa !24
  %io121 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 10
  %regspacing122 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io121, i32 0, i32 3
  %30 = load i32, i32* %regspacing122, align 8, !tbaa !24
  %tobool123 = icmp ne i32 %30, 0
  br i1 %tobool123, label %if.end127, label %if.then124

if.then124:                                       ; preds = %if.end108
  %io125 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 10
  %regspacing126 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io125, i32 0, i32 3
  store i32 1, i32* %regspacing126, align 8, !tbaa !24
  br label %if.end127

if.end127:                                        ; preds = %if.then124, %if.end108
  %31 = load i32, i32* %regsize, align 4, !tbaa !2
  %io128 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 10
  %regsize129 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io128, i32 0, i32 4
  store i32 %31, i32* %regsize129, align 4, !tbaa !25
  %io130 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 10
  %regsize131 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io130, i32 0, i32 4
  %32 = load i32, i32* %regsize131, align 4, !tbaa !25
  %tobool132 = icmp ne i32 %32, 0
  br i1 %tobool132, label %if.end136, label %if.then133

if.then133:                                       ; preds = %if.end127
  %io134 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 10
  %regsize135 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io134, i32 0, i32 4
  store i32 1, i32* %regsize135, align 4, !tbaa !25
  br label %if.end136

if.end136:                                        ; preds = %if.then133, %if.end127
  %33 = load i32, i32* %regshift, align 4, !tbaa !2
  %io137 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 10
  %regshift138 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io137, i32 0, i32 5
  store i32 %33, i32* %regshift138, align 8, !tbaa !26
  %34 = load i32, i32* %irq, align 4, !tbaa !2
  %irq139 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 26
  store i32 %34, i32* %irq139, align 4, !tbaa !27
  %irq140 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 26
  %35 = load i32, i32* %irq140, align 4, !tbaa !27
  %tobool141 = icmp ne i32 %35, 0
  br i1 %tobool141, label %if.then142, label %if.end143

if.then142:                                       ; preds = %if.end136
  %irq_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 13
  store i32 (%struct.smi_info*)* @std_irq_setup, i32 (%struct.smi_info*)** %irq_setup, align 8, !tbaa !28
  br label %if.end143

if.end143:                                        ; preds = %if.then142, %if.end136
  %36 = load i32, i32* %ipmb, align 4, !tbaa !2
  %conv144 = trunc i32 %36 to i8
  %slave_addr = getelementptr inbounds %struct.smi_info, %struct.smi_info* %25, i32 0, i32 35
  store i8 %conv144, i8* %slave_addr, align 4, !tbaa !29
  %call145 = call i32 @add_smi(%struct.smi_info* %25)
  %tobool146 = icmp ne i32 %call145, 0
  br i1 %tobool146, label %if.else152, label %if.then147

if.then147:                                       ; preds = %if.end143
  %call148 = call i32 @try_smi_init(%struct.smi_info* %25)
  %tobool149 = icmp ne i32 %call148, 0
  br i1 %tobool149, label %if.then150, label %for.inc187

if.then150:                                       ; preds = %if.then147
  call void @cleanup_one_si(%struct.smi_info* %25)
  br label %for.inc187

if.else152:                                       ; preds = %if.end143
  %37 = bitcast %struct.smi_info* %25 to i8*
  call void @kfree(i8* %37)
  br label %for.inc187

if.else154:                                       ; preds = %while.end101
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  %38 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.list_head, %struct.list_head* @smi_infos, i32 0, i32 0), align 8, !tbaa !30
  %39 = bitcast %struct.list_head* %38 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %39, i64 -544
  %40 = bitcast i8* %add.ptr to %struct.smi_info*
  br label %for.cond159

for.cond159:                                      ; preds = %for.inc, %if.else154
  %.sink = phi %struct.smi_info* [ %43, %for.inc ], [ %40, %if.else154 ]
  %e.0 = phi %struct.smi_info* [ %40, %if.else154 ], [ %43, %for.inc ]
  %link182 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %.sink, i32 0, i32 38
  %next183 = getelementptr inbounds %struct.list_head, %struct.list_head* %link182, i32 0, i32 0
  %41 = load %struct.list_head*, %struct.list_head** %next183, align 8, !tbaa !31
  %42 = bitcast %struct.list_head* %41 to i8*
  %add.ptr185 = getelementptr inbounds i8, i8* %42, i64 -544
  %43 = bitcast i8* %add.ptr185 to %struct.smi_info*
  %link160 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %e.0, i32 0, i32 38
  %cmp161 = icmp ne %struct.list_head* %link160, @smi_infos
  br i1 %cmp161, label %for.body163, label %for.end

for.body163:                                      ; preds = %for.cond159
  %io164 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %e.0, i32 0, i32 10
  %addr_type165 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io164, i32 0, i32 6
  %44 = load i32, i32* %addr_type165, align 4, !tbaa !21
  %45 = load i32, i32* %addr_space, align 4, !tbaa !2
  %cmp166 = icmp ne i32 %44, %45
  br i1 %cmp166, label %for.inc, label %if.end169

if.end169:                                        ; preds = %for.body163
  %si_type170 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %e.0, i32 0, i32 4
  %46 = load i32, i32* %si_type170, align 8, !tbaa !19
  %cmp171 = icmp ne i32 %46, %9
  br i1 %cmp171, label %for.inc, label %if.end174

if.end174:                                        ; preds = %if.end169
  %io175 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %e.0, i32 0, i32 10
  %addr_data176 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io175, i32 0, i32 7
  %47 = load i64, i64* %addr_data176, align 8, !tbaa !20
  %cmp177 = icmp eq i64 %47, %call33
  br i1 %cmp177, label %if.then179, label %for.inc

if.then179:                                       ; preds = %if.end174
  call void @cleanup_one_si(%struct.smi_info* %e.0)
  br label %for.inc

for.inc:                                          ; preds = %if.then179, %if.end174, %if.end169, %for.body163
  br label %for.cond159

for.end:                                          ; preds = %for.cond159
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  br label %for.inc187

for.inc187:                                       ; preds = %for.end, %if.else152, %if.then150, %if.then147
  store i8* %next.0, i8** %curr, align 8, !tbaa !7
  br label %for.cond

out:                                              ; preds = %smi_info_alloc.exit, %if.end99, %if.end90, %if.end81, %if.end72, %if.end63, %if.end55, %if.then40, %if.end23, %if.end19, %if.end15, %for.cond
  %rv.0 = phi i32 [ -22, %if.end99 ], [ %call56, %if.end55 ], [ %call64, %if.end63 ], [ %call73, %if.end72 ], [ %call82, %if.end81 ], [ %call91, %if.end90 ], [ -12, %smi_info_alloc.exit ], [ %conv, %for.cond ], [ %conv, %if.end23 ], [ %conv, %if.end19 ], [ %conv, %if.end15 ], [ %conv, %if.then40 ]
  call void @kfree(i8* %call)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %rv.0, %out ], [ -12, %entry ]
  ret i32 %retval.0
}

declare i8* @kstrdup(i8*, i32) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

declare i64 @strlen(i8*) #1

declare i8* @strchr(i8*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @parse_str(%struct.hotmod_vals* %v, i32* %val, i8** %curr) #0 {
entry:
  %0 = load i8*, i8** %curr, align 8, !tbaa !7
  %call = call i8* @strchr(i8* %0, i32 44)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  store i8 0, i8* %call, align 1, !tbaa !6
  %incdec.ptr = getelementptr inbounds i8, i8* %call, i32 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.hotmod_vals], [3 x %struct.hotmod_vals]* @hotmod_ops, i64 0, i64 %idxprom
  %name2 = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %arrayidx, i32 0, i32 0
  %2 = load i8*, i8** %name2, align 16, !tbaa !32
  %tobool3 = icmp ne i8* %2, null
  %3 = load i8*, i8** %curr, align 8, !tbaa !7
  br i1 %tobool3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %v, i64 %idxprom4
  %name6 = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %arrayidx5, i32 0, i32 0
  %4 = load i8*, i8** %name6, align 8, !tbaa !32
  %call7 = call i32 @strcmp(i8* %3, i8* %4)
  %cmp = icmp eq i32 %call7, 0
  br i1 %cmp, label %if.then8, label %for.inc

if.then8:                                         ; preds = %for.body
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %v, i64 %idxprom9
  %val11 = getelementptr inbounds %struct.hotmod_vals, %struct.hotmod_vals* %arrayidx10, i32 0, i32 1
  %5 = load i32, i32* %val11, align 8, !tbaa !34
  store i32 %5, i32* %val, align 4, !tbaa !2
  store i8* %incdec.ptr, i8** %curr, align 8, !tbaa !7
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then8, %if.then
  %retval.0 = phi i32 [ 0, %if.then8 ], [ -22, %for.end ], [ -22, %if.then ]
  ret i32 %retval.0
}

declare i64 @simple_strtoul(i8*, i8**, i32) #1

declare i32 @printk(i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @check_hotmod_int_op(i8* %curr, i8* %option, i8* %name, i32* %val) #0 {
entry:
  %n = alloca i8*, align 8
  %call = call i32 @strcmp(i8* %curr, i8* %name)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %tobool = icmp ne i8* %option, null
  br i1 %tobool, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %if.then
  %call3 = call i64 @simple_strtoul(i8* %option, i8** %n, i32 0)
  %conv = trunc i64 %call3 to i32
  store i32 %conv, i32* %val, align 4, !tbaa !2
  %1 = load i8*, i8** %n, align 8, !tbaa !7
  %2 = load i8, i8* %1, align 1, !tbaa !6
  %conv4 = sext i8 %2 to i32
  %cmp5 = icmp ne i32 %conv4, 0
  br i1 %cmp5, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load i8, i8* %option, align 1, !tbaa !6
  %conv7 = sext i8 %3 to i32
  %cmp8 = icmp eq i32 %conv7, 0
  br i1 %cmp8, label %if.then10, label %cleanup

if.then10:                                        ; preds = %lor.lhs.false, %if.end
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then10, %lor.lhs.false, %if.then1, %entry
  %retval.0 = phi i32 [ -22, %if.then10 ], [ -22, %if.then1 ], [ 1, %lor.lhs.false ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @mem_setup(%struct.smi_info* %info) #0 {
entry:
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !20
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %io_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 12
  store void (%struct.smi_info*)* @mem_cleanup, void (%struct.smi_info*)** %io_cleanup, align 8, !tbaa !35
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 4
  %1 = load i32, i32* %regsize, align 4, !tbaa !25
  %Pivot10 = icmp slt i32 %1, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %if.end
  %Pivot8 = icmp slt i32 %1, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %1, 8
  br i1 %SwitchLeaf6, label %sw.epilog, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %1, 4
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %1, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %1, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %1, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %2 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %mem_inq.sink = phi i8 (%struct.si_sm_io*, i32)* [ @intf_mem_inw, %LeafBlock1 ], [ @intf_mem_inl, %LeafBlock3 ], [ @mem_inq, %LeafBlock5 ], [ @intf_mem_inb, %LeafBlock ]
  %mem_outq.sink = phi void (%struct.si_sm_io*, i32, i8)* [ @intf_mem_outw, %LeafBlock1 ], [ @intf_mem_outl, %LeafBlock3 ], [ @mem_outq, %LeafBlock5 ], [ @intf_mem_outb, %LeafBlock ]
  %io15 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %inputb16 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io15, i32 0, i32 0
  store i8 (%struct.si_sm_io*, i32)* %mem_inq.sink, i8 (%struct.si_sm_io*, i32)** %inputb16, align 8, !tbaa !36
  %io17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %outputb18 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io17, i32 0, i32 1
  store void (%struct.si_sm_io*, i32, i8)* %mem_outq.sink, void (%struct.si_sm_io*, i32, i8)** %outputb18, align 8, !tbaa !37
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 15
  %3 = load i32, i32* %io_size, align 8, !tbaa !38
  %io21 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io21, i32 0, i32 3
  %4 = load i32, i32* %regspacing, align 8, !tbaa !24
  %mul = mul i32 %3, %4
  %io22 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regspacing23 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io22, i32 0, i32 3
  %5 = load i32, i32* %regspacing23, align 8, !tbaa !24
  %io24 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regsize25 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io24, i32 0, i32 4
  %6 = load i32, i32* %regsize25, align 4, !tbaa !25
  %sub = sub nsw i32 %5, %6
  %sub26 = sub i32 %mul, %sub
  %conv = sext i32 %sub26 to i64
  %call27 = call %struct.resource* @__request_region(%struct.resource* @iomem_resource, i64 %0, i64 %conv, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i32 0)
  %cmp = icmp eq %struct.resource* %call27, null
  br i1 %cmp, label %cleanup, label %if.end30

if.end30:                                         ; preds = %sw.epilog
  %conv31 = sext i32 %sub26 to i64
  %call32 = call i8* @ioremap(i64 %0, i64 %conv31)
  %io33 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %addr34 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io33, i32 0, i32 2
  store i8* %call32, i8** %addr34, align 8, !tbaa !23
  %io35 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %addr36 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io35, i32 0, i32 2
  %7 = load i8*, i8** %addr36, align 8, !tbaa !23
  %cmp37 = icmp eq i8* %7, null
  br i1 %cmp37, label %if.then39, label %cleanup

if.then39:                                        ; preds = %if.end30
  %conv40 = sext i32 %sub26 to i64
  call void @__release_region(%struct.resource* @iomem_resource, i64 %0, i64 %conv40)
  br label %cleanup

cleanup:                                          ; preds = %if.then39, %if.end30, %sw.epilog, %sw.default, %entry
  %retval.0 = phi i32 [ -5, %if.then39 ], [ -22, %sw.default ], [ -19, %entry ], [ -5, %sw.epilog ], [ 0, %if.end30 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @port_setup(%struct.smi_info* %info) #0 {
entry:
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !20
  %conv = trunc i64 %0 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %io_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 12
  store void (%struct.smi_info*)* @port_cleanup, void (%struct.smi_info*)** %io_cleanup, align 8, !tbaa !35
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 4
  %1 = load i32, i32* %regsize, align 4, !tbaa !25
  %Pivot6 = icmp slt i32 %1, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %1, 4
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %1, 4
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %1, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %1, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %2 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  %port_inl.sink = phi i8 (%struct.si_sm_io*, i32)* [ @port_inw, %LeafBlock1 ], [ @port_inl, %LeafBlock3 ], [ @port_inb, %LeafBlock ]
  %port_outl.sink = phi void (%struct.si_sm_io*, i32, i8)* [ @port_outw, %LeafBlock1 ], [ @port_outl, %LeafBlock3 ], [ @port_outb, %LeafBlock ]
  %io10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %inputb11 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io10, i32 0, i32 0
  store i8 (%struct.si_sm_io*, i32)* %port_inl.sink, i8 (%struct.si_sm_io*, i32)** %inputb11, align 8, !tbaa !36
  %io12 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %outputb13 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io12, i32 0, i32 1
  store void (%struct.si_sm_io*, i32, i8)* %port_outl.sink, void (%struct.si_sm_io*, i32, i8)** %outputb13, align 8, !tbaa !37
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %idx.0 = phi i32 [ 0, %sw.epilog ], [ %inc, %for.inc ]
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 15
  %3 = load i32, i32* %io_size, align 8, !tbaa !38
  %cmp = icmp ult i32 %idx.0, %3
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %io17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io17, i32 0, i32 3
  %4 = load i32, i32* %regspacing, align 8, !tbaa !24
  %mul = mul nsw i32 %idx.0, %4
  %add = add i32 %conv, %mul
  %conv18 = zext i32 %add to i64
  %io19 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regsize20 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io19, i32 0, i32 4
  %5 = load i32, i32* %regsize20, align 4, !tbaa !25
  %conv21 = sext i32 %5 to i64
  %call22 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv18, i64 %conv21, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i32 0)
  %cmp23 = icmp eq %struct.resource* %call22, null
  br i1 %cmp23, label %if.then25, label %for.inc

if.then25:                                        ; preds = %for.body
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then25
  %idx.1 = phi i32 [ %idx.0, %if.then25 ], [ %dec, %while.body ]
  %dec = add nsw i32 %idx.1, -1
  %tobool26 = icmp ne i32 %idx.1, 0
  br i1 %tobool26, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %io27 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regspacing28 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io27, i32 0, i32 3
  %6 = load i32, i32* %regspacing28, align 8, !tbaa !24
  %mul29 = mul nsw i32 %dec, %6
  %add30 = add i32 %conv, %mul29
  %conv31 = zext i32 %add30 to i64
  %io32 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regsize33 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io32, i32 0, i32 4
  %7 = load i32, i32* %regsize33, align 4, !tbaa !25
  %conv34 = sext i32 %7 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv31, i64 %conv34)
  br label %while.cond

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

cleanup:                                          ; preds = %while.cond, %for.cond, %sw.default, %entry
  %retval.0 = phi i32 [ -22, %sw.default ], [ -19, %entry ], [ -5, %while.cond ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @std_irq_setup(%struct.smi_info* %info) #0 {
entry:
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 26
  %0 = load i32, i32* %irq, align 4, !tbaa !27
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 4
  %1 = load i32, i32* %si_type, align 8, !tbaa !19
  %cmp = icmp eq i32 %1, 2
  %irq2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 26
  %2 = load i32, i32* %irq2, align 4, !tbaa !27
  %3 = bitcast %struct.smi_info* %info to i8*
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %call = call i32 @request_irq(i32 %2, i32 (i32, i8*)* @si_bt_irq_handler, i64 160, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i8* %3)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.end9, label %if.then4

if.then4:                                         ; preds = %if.then1
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 1
  %4 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !37
  %io5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  call void %4(%struct.si_sm_io* %io5, i32 2, i8 zeroext 1)
  br label %if.end9

if.else:                                          ; preds = %if.end
  %call8 = call i32 @request_irq(i32 %2, i32 (i32, i8*)* @si_irq_handler, i64 160, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i8* %3)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then4, %if.then1
  %rv.0 = phi i32 [ %call8, %if.else ], [ %call, %if.then4 ], [ %call, %if.then1 ]
  %tobool10 = icmp ne i32 %rv.0, 0
  br i1 %tobool10, label %if.then11, label %if.else15

if.then11:                                        ; preds = %if.end9
  %5 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %irq14 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 26
  store i32 0, i32* %irq14, align 4, !tbaa !27
  br label %cleanup

if.else15:                                        ; preds = %if.end9
  %irq_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 14
  store void (%struct.smi_info*)* @std_irq_cleanup, void (%struct.smi_info*)** %irq_cleanup, align 8, !tbaa !39
  %6 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.else15, %if.then11, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %rv.0, %if.else15 ], [ %rv.0, %if.then11 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @add_smi(%struct.smi_info* %new_smi) #0 {
entry:
  %0 = call i32 (i8*, ...) @printk(i8* null)
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  %call3 = call i32 @is_new_interface(%struct.smi_info* %new_smi)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

if.end:                                           ; preds = %entry
  %2 = call i32 (i8*, ...) @printk(i8* null)
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  store %struct.ipmi_smi* null, %struct.ipmi_smi** %intf, align 8, !tbaa !40
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  store %struct.si_sm_data* null, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  store %struct.si_sm_handlers* null, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %link = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 38
  call void @list_add_tail(%struct.list_head* %link, %struct.list_head* @smi_infos)
  br label %out_err

out_err:                                          ; preds = %if.end, %if.then
  %rv.0 = phi i32 [ 0, %if.end ], [ -16, %if.then ]
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  ret i32 %rv.0
}

; Function Attrs: nounwind uwtable
define internal i32 @try_smi_init(%struct.smi_info* %new_smi) #0 {
entry:
  %0 = call i32 (i8*, ...) @printk(i8* null)
  %si_type6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 4
  %1 = load i32, i32* %si_type6, align 8, !tbaa !19
  %Pivot4 = icmp slt i32 %1, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %1, 2
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %1, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %out_err

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %1, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %out_err

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %NodeBlock
  %bt_smi_handlers.sink = phi %struct.si_sm_handlers* [ bitcast (%struct.si_sm_handlers.12* @smic_smi_handlers to %struct.si_sm_handlers*), %NodeBlock ], [ bitcast (%struct.si_sm_handlers.21* @bt_smi_handlers to %struct.si_sm_handlers*), %LeafBlock1 ], [ @kcs_smi_handlers, %LeafBlock ]
  %handlers10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  store %struct.si_sm_handlers* %bt_smi_handlers.sink, %struct.si_sm_handlers** %handlers10, align 8, !tbaa !42
  %handlers11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  %2 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers11, align 8, !tbaa !42
  %size = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %2, i32 0, i32 7
  %3 = load i32 ()*, i32 ()** %size, align 8, !tbaa !43
  %call12 = call i32 %3()
  %conv13 = sext i32 %call12 to i64
  %call.i = call i8* @__kmalloc(i64 %conv13, i32 208) #5
  %4 = bitcast i8* %call.i to %struct.si_sm_data*
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  store %struct.si_sm_data* %4, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %si_sm15 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %5 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm15, align 8, !tbaa !41
  %tobool = icmp ne %struct.si_sm_data* %5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %sw.epilog
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

if.end:                                           ; preds = %sw.epilog
  %handlers17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  %7 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers17, align 8, !tbaa !42
  %init_data = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %7, i32 0, i32 1
  %8 = load i32 (%struct.si_sm_data*, %struct.si_sm_io*)*, i32 (%struct.si_sm_data*, %struct.si_sm_io*)** %init_data, align 8, !tbaa !45
  %si_sm18 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %9 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm18, align 8, !tbaa !41
  %io19 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 10
  %call20 = call i32 %8(%struct.si_sm_data* %9, %struct.si_sm_io* %io19)
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 15
  store i32 %call20, i32* %io_size, align 8, !tbaa !38
  %io_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 11
  %10 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %io_setup, align 8, !tbaa !22
  %call21 = call i32 %10(%struct.smi_info* %new_smi)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

if.end25:                                         ; preds = %if.end
  %handlers26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  %12 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers26, align 8, !tbaa !42
  %detect = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %12, i32 0, i32 5
  %13 = load i32 (%struct.si_sm_data*)*, i32 (%struct.si_sm_data*)** %detect, align 8, !tbaa !46
  %si_sm27 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %14 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm27, align 8, !tbaa !41
  %call28 = call i32 %13(%struct.si_sm_data* %14)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end36

if.then30:                                        ; preds = %if.end25
  %addr_source31 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 16
  %15 = load i32, i32* %addr_source31, align 4, !tbaa !9
  %tobool32 = icmp ne i32 %15, 0
  br i1 %tobool32, label %if.then33, label %out_err

if.then33:                                        ; preds = %if.then30
  %16 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

if.end36:                                         ; preds = %if.end25
  %call37 = call i32 @try_get_dev_id(%struct.smi_info* %new_smi)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then39, label %if.end45

if.then39:                                        ; preds = %if.end36
  %addr_source40 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 16
  %17 = load i32, i32* %addr_source40, align 4, !tbaa !9
  %tobool41 = icmp ne i32 %17, 0
  br i1 %tobool41, label %if.then42, label %out_err

if.then42:                                        ; preds = %if.then39
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

if.end45:                                         ; preds = %if.end36
  call void @setup_oem_data_handler(%struct.smi_info* %new_smi)
  call void @setup_xaction_handlers(%struct.smi_info* %new_smi)
  %xmit_msgs = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 6
  call void @INIT_LIST_HEAD(%struct.list_head* %xmit_msgs)
  %hp_xmit_msgs = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 7
  call void @INIT_LIST_HEAD(%struct.list_head* %hp_xmit_msgs)
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 8
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !47
  %req_events = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 22
  call void @atomic_set(%union.anon.1* %req_events, i32 0)
  %run_to_completion = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 23
  store i32 0, i32* %run_to_completion, align 8, !tbaa !48
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end45
  %i.0 = phi i32 [ 0, %if.end45 ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 36
  %idxprom47 = sext i32 %i.0 to i64
  %arrayidx48 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats, i64 0, i64 %idxprom47
  call void @atomic_set(%union.anon.1* %arrayidx48, i32 0)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 30
  store i32 1, i32* %interrupt_disabled, align 4, !tbaa !49
  %stop_operation = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 29
  call void @atomic_set(%union.anon.1* %stop_operation, i32 0)
  %19 = load i32, i32* @smi_num, align 4, !tbaa !2
  %intf_num = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 0
  store i32 %19, i32* %intf_num, align 8, !tbaa !50
  %20 = load i32, i32* @smi_num, align 4, !tbaa !2
  %inc49 = add nsw i32 %20, 1
  store i32 %inc49, i32* @smi_num, align 4, !tbaa !2
  %call50 = call i32 @try_enable_event_buffer(%struct.smi_info* %new_smi)
  %cmp51 = icmp eq i32 %call50, 0
  br i1 %cmp51, label %if.then53, label %if.end54

if.then53:                                        ; preds = %for.end
  %has_event_buffer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 21
  store i8 1, i8* %has_event_buffer, align 1, !tbaa !51
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %for.end
  call void @start_clear_flags(%struct.smi_info* %new_smi)
  %irq55 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 26
  %21 = load i32, i32* %irq55, align 4, !tbaa !27
  %tobool56 = icmp ne i32 %21, 0
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.end54
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 9
  store i32 4, i32* %si_state, align 8, !tbaa !52
  br label %if.end58

if.end58:                                         ; preds = %if.then57, %if.end54
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 32
  %22 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !53
  %tobool59 = icmp ne %struct.device* %22, null
  br i1 %tobool59, label %if.end78, label %if.then60

if.then60:                                        ; preds = %if.end58
  %intf_num61 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 0
  %23 = load i32, i32* %intf_num61, align 8, !tbaa !50
  %call62 = call %struct.platform_device* @platform_device_alloc(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i32 %23)
  %pdev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 33
  store %struct.platform_device* %call62, %struct.platform_device** %pdev, align 8, !tbaa !54
  %pdev63 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 33
  %24 = load %struct.platform_device*, %struct.platform_device** %pdev63, align 8, !tbaa !54
  %tobool64 = icmp ne %struct.platform_device* %24, null
  br i1 %tobool64, label %if.end67, label %if.then65

if.then65:                                        ; preds = %if.then60
  %25 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

if.end67:                                         ; preds = %if.then60
  %pdev68 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 33
  %26 = load %struct.platform_device*, %struct.platform_device** %pdev68, align 8, !tbaa !54
  %dev69 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %26, i32 0, i32 3
  %dev70 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 32
  store %struct.device* %dev69, %struct.device** %dev70, align 8, !tbaa !53
  %dev71 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 32
  %27 = load %struct.device*, %struct.device** %dev71, align 8, !tbaa !53
  %driver = getelementptr inbounds %struct.device, %struct.device* %27, i32 0, i32 7
  store %struct.device_driver* getelementptr inbounds (%struct.platform_driver, %struct.platform_driver* @ipmi_driver, i32 0, i32 5), %struct.device_driver** %driver, align 8, !tbaa !55
  %pdev72 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 33
  %28 = load %struct.platform_device*, %struct.platform_device** %pdev72, align 8, !tbaa !54
  %call73 = call i32 @platform_device_add(%struct.platform_device* %28)
  %tobool74 = icmp ne i32 %call73, 0
  br i1 %tobool74, label %if.then75, label %if.end77

if.then75:                                        ; preds = %if.end67
  %29 = call i32 (i8*, ...) @printk(i8* null)
  br label %out_err

if.end77:                                         ; preds = %if.end67
  %dev_registered = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 34
  store i32 1, i32* %dev_registered, align 8, !tbaa !71
  br label %if.end78

if.end78:                                         ; preds = %if.end77, %if.end58
  %30 = bitcast %struct.smi_info* %new_smi to i8*
  %device_id = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 31
  %dev79 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 32
  %31 = load %struct.device*, %struct.device** %dev79, align 8, !tbaa !53
  %slave_addr80 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 35
  %32 = load i8, i8* %slave_addr80, align 4, !tbaa !29
  %call81 = call i32 @ipmi_register_smi(%struct.ipmi_smi_handlers* @handlers, i8* %30, %struct.ipmi_device_id* %device_id, %struct.device* %31, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.51, i32 0, i32 0), i8 zeroext %32)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %if.then83, label %if.end86

if.then83:                                        ; preds = %if.end78
  %33 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %out_err_stop_timer

if.end86:                                         ; preds = %if.end78
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  %34 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !40
  %35 = bitcast %struct.smi_info* %new_smi to i8*
  %call87 = call i32 @ipmi_smi_add_proc_entry(%struct.ipmi_smi* %34, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.53, i32 0, i32 0), %struct.file_operations* @smi_type_proc_ops, i8* %35)
  %tobool88 = icmp ne i32 %call87, 0
  br i1 %tobool88, label %if.then89, label %if.end92

if.then89:                                        ; preds = %if.end86
  %36 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %out_err_stop_timer

if.end92:                                         ; preds = %if.end86
  %intf93 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  %37 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf93, align 8, !tbaa !40
  %38 = bitcast %struct.smi_info* %new_smi to i8*
  %call94 = call i32 @ipmi_smi_add_proc_entry(%struct.ipmi_smi* %37, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.55, i32 0, i32 0), %struct.file_operations* @smi_si_stats_proc_ops, i8* %38)
  %tobool95 = icmp ne i32 %call94, 0
  br i1 %tobool95, label %if.then96, label %if.end99

if.then96:                                        ; preds = %if.end92
  %39 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %out_err_stop_timer

if.end99:                                         ; preds = %if.end92
  %intf100 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  %40 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf100, align 8, !tbaa !40
  %41 = bitcast %struct.smi_info* %new_smi to i8*
  %call101 = call i32 @ipmi_smi_add_proc_entry(%struct.ipmi_smi* %40, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.56, i32 0, i32 0), %struct.file_operations* @smi_params_proc_ops, i8* %41)
  %tobool102 = icmp ne i32 %call101, 0
  br i1 %tobool102, label %if.then103, label %if.end106

if.then103:                                       ; preds = %if.end99
  %42 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %out_err_stop_timer

if.end106:                                        ; preds = %if.end99
  %43 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup154

out_err_stop_timer:                               ; preds = %if.then103, %if.then96, %if.then89, %if.then83
  %rv.0 = phi i32 [ %call81, %if.then83 ], [ %call87, %if.then89 ], [ %call94, %if.then96 ], [ %call101, %if.then103 ]
  %stop_operation112 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 29
  call void @atomic_inc(%union.anon.1* %stop_operation112)
  call void @wait_for_timer_and_thread(%struct.smi_info* %new_smi)
  br label %out_err

out_err:                                          ; preds = %out_err_stop_timer, %if.then75, %if.then65, %if.then42, %if.then39, %if.then33, %if.then30, %if.then23, %if.then, %LeafBlock, %LeafBlock1
  %rv.1 = phi i32 [ %call21, %if.then23 ], [ %rv.0, %out_err_stop_timer ], [ %call73, %if.then75 ], [ %call50, %if.then65 ], [ -12, %if.then ], [ -5, %LeafBlock ], [ -5, %LeafBlock1 ], [ -19, %if.then33 ], [ -19, %if.then30 ], [ %call37, %if.then42 ], [ %call37, %if.then39 ]
  %interrupt_disabled113 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 30
  store i32 1, i32* %interrupt_disabled113, align 4, !tbaa !49
  %intf114 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  %44 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf114, align 8, !tbaa !40
  %tobool115 = icmp ne %struct.ipmi_smi* %44, null
  br i1 %tobool115, label %if.then116, label %if.end120

if.then116:                                       ; preds = %out_err
  %intf117 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  %45 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf117, align 8, !tbaa !40
  %call118 = call i32 @ipmi_unregister_smi(%struct.ipmi_smi* %45)
  %intf119 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 1
  store %struct.ipmi_smi* null, %struct.ipmi_smi** %intf119, align 8, !tbaa !40
  br label %if.end120

if.end120:                                        ; preds = %if.then116, %out_err
  %irq_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 14
  %46 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %irq_cleanup, align 8, !tbaa !39
  %tobool121 = icmp ne void (%struct.smi_info*)* %46, null
  br i1 %tobool121, label %if.then122, label %if.end125

if.then122:                                       ; preds = %if.end120
  %irq_cleanup123 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 14
  %47 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %irq_cleanup123, align 8, !tbaa !39
  call void %47(%struct.smi_info* %new_smi)
  %irq_cleanup124 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 14
  store void (%struct.smi_info*)* null, void (%struct.smi_info*)** %irq_cleanup124, align 8, !tbaa !39
  br label %if.end125

if.end125:                                        ; preds = %if.then122, %if.end120
  call void @synchronize_sched()
  %si_sm126 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %48 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm126, align 8, !tbaa !41
  %tobool127 = icmp ne %struct.si_sm_data* %48, null
  br i1 %tobool127, label %if.then128, label %if.end137

if.then128:                                       ; preds = %if.end125
  %handlers129 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  %49 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers129, align 8, !tbaa !42
  %tobool130 = icmp ne %struct.si_sm_handlers* %49, null
  br i1 %tobool130, label %if.then131, label %if.end134

if.then131:                                       ; preds = %if.then128
  %handlers132 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 3
  %50 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers132, align 8, !tbaa !42
  %cleanup = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %50, i32 0, i32 6
  %51 = load void (%struct.si_sm_data*)*, void (%struct.si_sm_data*)** %cleanup, align 8, !tbaa !72
  %si_sm133 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %52 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm133, align 8, !tbaa !41
  call void %51(%struct.si_sm_data* %52)
  br label %if.end134

if.end134:                                        ; preds = %if.then131, %if.then128
  %si_sm135 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  %53 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm135, align 8, !tbaa !41
  %54 = bitcast %struct.si_sm_data* %53 to i8*
  call void @kfree(i8* %54)
  %si_sm136 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 2
  store %struct.si_sm_data* null, %struct.si_sm_data** %si_sm136, align 8, !tbaa !41
  br label %if.end137

if.end137:                                        ; preds = %if.end134, %if.end125
  %addr_source_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 17
  %55 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %addr_source_cleanup, align 8, !tbaa !73
  %tobool138 = icmp ne void (%struct.smi_info*)* %55, null
  br i1 %tobool138, label %if.then139, label %if.end142

if.then139:                                       ; preds = %if.end137
  %addr_source_cleanup140 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 17
  %56 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %addr_source_cleanup140, align 8, !tbaa !73
  call void %56(%struct.smi_info* %new_smi)
  %addr_source_cleanup141 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 17
  store void (%struct.smi_info*)* null, void (%struct.smi_info*)** %addr_source_cleanup141, align 8, !tbaa !73
  br label %if.end142

if.end142:                                        ; preds = %if.then139, %if.end137
  %io_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 12
  %57 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %io_cleanup, align 8, !tbaa !35
  %tobool143 = icmp ne void (%struct.smi_info*)* %57, null
  br i1 %tobool143, label %if.then144, label %if.end147

if.then144:                                       ; preds = %if.end142
  %io_cleanup145 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 12
  %58 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %io_cleanup145, align 8, !tbaa !35
  call void %58(%struct.smi_info* %new_smi)
  %io_cleanup146 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 12
  store void (%struct.smi_info*)* null, void (%struct.smi_info*)** %io_cleanup146, align 8, !tbaa !35
  br label %if.end147

if.end147:                                        ; preds = %if.then144, %if.end142
  %dev_registered148 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 34
  %59 = load i32, i32* %dev_registered148, align 8, !tbaa !71
  %tobool149 = icmp ne i32 %59, 0
  br i1 %tobool149, label %if.then150, label %cleanup154

if.then150:                                       ; preds = %if.end147
  %pdev151 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 33
  %60 = load %struct.platform_device*, %struct.platform_device** %pdev151, align 8, !tbaa !54
  call void @platform_device_unregister(%struct.platform_device* %60)
  %dev_registered152 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %new_smi, i32 0, i32 34
  store i32 0, i32* %dev_registered152, align 8, !tbaa !71
  br label %cleanup154

cleanup154:                                       ; preds = %if.then150, %if.end147, %if.end106
  %retval.0 = phi i32 [ 0, %if.end106 ], [ %rv.1, %if.then150 ], [ %rv.1, %if.end147 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @cleanup_one_si(%struct.smi_info* %to_clean) #0 {
entry:
  %tobool = icmp ne %struct.smi_info* %to_clean, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %link = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 38
  call void @list_del(%struct.list_head* %link)
  %stop_operation = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 29
  call void @atomic_inc(%union.anon.1* %stop_operation)
  call void @wait_for_timer_and_thread(%struct.smi_info* %to_clean)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %si_lock17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 5
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock17, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  %call19 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 8
  %1 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !47
  %tobool5 = icmp ne %struct.ipmi_smi_msg* %1, null
  br i1 %tobool5, label %while.body, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 9
  %2 = load i32, i32* %si_state, align 8, !tbaa !52
  %cmp6 = icmp ne i32 %2, 0
  br i1 %cmp6, label %while.body, label %while.end

while.body:                                       ; preds = %lor.rhs, %while.cond
  %si_lock8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock8, i64 %call19)
  %3 = bitcast %struct.smi_info* %to_clean to i8*
  call void @poll(i8* %3)
  %call9 = call i64 @schedule_timeout_uninterruptible(i64 1)
  br label %while.cond

while.end:                                        ; preds = %lor.rhs
  call void @disable_si_irq(%struct.smi_info* %to_clean)
  %si_lock24 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock24, i64 %call19)
  br label %while.cond25

while.cond25:                                     ; preds = %while.body33, %while.end
  %curr_msg26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 8
  %4 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg26, align 8, !tbaa !47
  %tobool27 = icmp ne %struct.ipmi_smi_msg* %4, null
  br i1 %tobool27, label %while.body33, label %lor.rhs28

lor.rhs28:                                        ; preds = %while.cond25
  %si_state29 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 9
  %5 = load i32, i32* %si_state29, align 8, !tbaa !52
  %cmp30 = icmp ne i32 %5, 0
  br i1 %cmp30, label %while.body33, label %while.end35

while.body33:                                     ; preds = %lor.rhs28, %while.cond25
  %6 = bitcast %struct.smi_info* %to_clean to i8*
  call void @poll(i8* %6)
  %call34 = call i64 @schedule_timeout_uninterruptible(i64 1)
  br label %while.cond25

while.end35:                                      ; preds = %lor.rhs28
  %irq_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 14
  %7 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %irq_cleanup, align 8, !tbaa !39
  %tobool36 = icmp ne void (%struct.smi_info*)* %7, null
  br i1 %tobool36, label %if.then37, label %if.end39

if.then37:                                        ; preds = %while.end35
  %irq_cleanup38 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 14
  %8 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %irq_cleanup38, align 8, !tbaa !39
  call void %8(%struct.smi_info* %to_clean)
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %while.end35
  br label %while.cond40

while.cond40:                                     ; preds = %while.body48, %if.end39
  %curr_msg41 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 8
  %9 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg41, align 8, !tbaa !47
  %tobool42 = icmp ne %struct.ipmi_smi_msg* %9, null
  br i1 %tobool42, label %while.body48, label %lor.rhs43

lor.rhs43:                                        ; preds = %while.cond40
  %si_state44 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 9
  %10 = load i32, i32* %si_state44, align 8, !tbaa !52
  %cmp45 = icmp ne i32 %10, 0
  br i1 %cmp45, label %while.body48, label %while.end50

while.body48:                                     ; preds = %lor.rhs43, %while.cond40
  %11 = bitcast %struct.smi_info* %to_clean to i8*
  call void @poll(i8* %11)
  %call49 = call i64 @schedule_timeout_uninterruptible(i64 1)
  br label %while.cond40

while.end50:                                      ; preds = %lor.rhs43
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 1
  %12 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !40
  %tobool51 = icmp ne %struct.ipmi_smi* %12, null
  br i1 %tobool51, label %if.then52, label %if.end55

if.then52:                                        ; preds = %while.end50
  %intf53 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 1
  %13 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf53, align 8, !tbaa !40
  %call54 = call i32 @ipmi_unregister_smi(%struct.ipmi_smi* %13)
  br label %if.end55

if.end55:                                         ; preds = %if.then52, %while.end50
  %rv.0 = phi i32 [ %call54, %if.then52 ], [ 0, %while.end50 ]
  %tobool56 = icmp ne i32 %rv.0, 0
  br i1 %tobool56, label %if.then57, label %if.end59

if.then57:                                        ; preds = %if.end55
  %14 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %if.end55
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 3
  %15 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %tobool60 = icmp ne %struct.si_sm_handlers* %15, null
  br i1 %tobool60, label %if.then61, label %if.end63

if.then61:                                        ; preds = %if.end59
  %handlers62 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 3
  %16 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers62, align 8, !tbaa !42
  %cleanup = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %16, i32 0, i32 6
  %17 = load void (%struct.si_sm_data*)*, void (%struct.si_sm_data*)** %cleanup, align 8, !tbaa !72
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 2
  %18 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  call void %17(%struct.si_sm_data* %18)
  br label %if.end63

if.end63:                                         ; preds = %if.then61, %if.end59
  %si_sm64 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 2
  %19 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm64, align 8, !tbaa !41
  %20 = bitcast %struct.si_sm_data* %19 to i8*
  call void @kfree(i8* %20)
  %addr_source_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 17
  %21 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %addr_source_cleanup, align 8, !tbaa !73
  %tobool65 = icmp ne void (%struct.smi_info*)* %21, null
  br i1 %tobool65, label %if.then66, label %if.end68

if.then66:                                        ; preds = %if.end63
  %addr_source_cleanup67 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 17
  %22 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %addr_source_cleanup67, align 8, !tbaa !73
  call void %22(%struct.smi_info* %to_clean)
  br label %if.end68

if.end68:                                         ; preds = %if.then66, %if.end63
  %io_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 12
  %23 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %io_cleanup, align 8, !tbaa !35
  %tobool69 = icmp ne void (%struct.smi_info*)* %23, null
  br i1 %tobool69, label %if.then70, label %if.end72

if.then70:                                        ; preds = %if.end68
  %io_cleanup71 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 12
  %24 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %io_cleanup71, align 8, !tbaa !35
  call void %24(%struct.smi_info* %to_clean)
  br label %if.end72

if.end72:                                         ; preds = %if.then70, %if.end68
  %dev_registered = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 34
  %25 = load i32, i32* %dev_registered, align 8, !tbaa !71
  %tobool73 = icmp ne i32 %25, 0
  br i1 %tobool73, label %if.then74, label %if.end75

if.then74:                                        ; preds = %if.end72
  %pdev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %to_clean, i32 0, i32 33
  %26 = load %struct.platform_device*, %struct.platform_device** %pdev, align 8, !tbaa !54
  call void @platform_device_unregister(%struct.platform_device* %26)
  br label %if.end75

if.end75:                                         ; preds = %if.then74, %if.end72
  %27 = bitcast %struct.smi_info* %to_clean to i8*
  call void @kfree(i8* %27)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end75, %entry
  ret void
}

declare void @kfree(i8*) #1

declare void @mutex_lock_nested(%struct.mutex*, i32) #1

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

declare void @list_del(%struct.list_head*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc(%union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #5, !srcloc !74
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @wait_for_timer_and_thread(%struct.smi_info* %smi_info) #3 {
entry:
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 1
  %0 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !40
  %tobool = icmp ne %struct.ipmi_smi* %0, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %thread = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 37
  %1 = load %struct.task_struct*, %struct.task_struct** %thread, align 8, !tbaa !75
  %cmp = icmp ne %struct.task_struct* %1, null
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %thread2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 37
  %2 = load %struct.task_struct*, %struct.task_struct** %thread2, align 8, !tbaa !75
  %call = call i32 @kthread_stop(%struct.task_struct* %2)
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %si_timer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 27
  %call3 = call i32 @del_timer_sync(%struct.timer_list* %si_timer)
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  ret void
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @poll(i8* %send_info) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %run_to_completion1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 23
  %1 = load i32, i32* %run_to_completion1, align 8, !tbaa !48
  call void @__const_udelay(i64 42950)
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %do.body2

do.body2:                                         ; preds = %entry
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  br label %if.end

if.end:                                           ; preds = %do.body2, %entry
  %flags.0 = phi i64 [ 0, %entry ], [ %call3, %do.body2 ]
  %call6 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 10)
  %tobool7 = icmp ne i32 %1, 0
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.end
  %si_lock9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock9, i64 %flags.0)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end
  ret void
}

declare i64 @schedule_timeout_uninterruptible(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @disable_si_irq(%struct.smi_info* %smi_info) #3 {
entry:
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 26
  %0 = load i32, i32* %irq, align 4, !tbaa !27
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %entry
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  %1 = load i32, i32* %interrupt_disabled, align 4, !tbaa !49
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.end6, label %if.then

if.then:                                          ; preds = %land.lhs.true
  call void @start_disable_irq(%struct.smi_info* %smi_info)
  %interrupt_disabled2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  store i32 1, i32* %interrupt_disabled2, align 4, !tbaa !49
  %stop_operation = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 29
  %call = call i32 @atomic_read(%union.anon.1* %stop_operation)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.end6, label %if.then4

if.then4:                                         ; preds = %if.then
  %si_timer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 27
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !76
  %add = add i64 %2, 2
  %call5 = call i32 @mod_timer(%struct.timer_list* %si_timer, i64 %add)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.then, %land.lhs.true, %entry
  ret void
}

declare i32 @ipmi_unregister_smi(%struct.ipmi_smi*) #1

declare void @platform_device_unregister(%struct.platform_device*) #1

; Function Attrs: nounwind uwtable
define internal void @start_disable_irq(%struct.smi_info* %smi_info) #0 {
entry:
  %msg = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 1
  store i8 47, i8* %arrayidx1, align 1, !tbaa !6
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %0 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %0, i32 0, i32 2
  %1 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !77
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %2 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %arraydecay = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i32 0, i32 0
  %call = call i32 %1(%struct.si_sm_data* %2, i8* %arraydecay, i32 2)
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 8, i32* %si_state, align 8, !tbaa !52
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read(%union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !2
  ret i32 %0
}

declare i32 @mod_timer(%struct.timer_list*, i64) #1

declare void @__const_udelay(i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @smi_event_handler(%struct.smi_info* %smi_info, i32 %time) #0 {
entry:
  %msg = alloca [2 x i8], align 1
  br label %restart

restart:                                          ; preds = %restart.backedge, %entry
  %time.addr.0 = phi i32 [ %time, %entry ], [ 0, %restart.backedge ]
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %0 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %event = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %0, i32 0, i32 4
  %1 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event, align 8, !tbaa !78
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %2 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %conv = sext i32 %time.addr.0 to i64
  %call = call i32 %1(%struct.si_sm_data* %2, i64 %conv)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %restart
  %si_sm_result.0 = phi i32 [ %call, %restart ], [ %call5, %while.body ]
  switch i32 %si_sm_result.0, label %if.end25 [
    i32 0, label %while.body
    i32 3, label %if.then
    i32 5, label %if.then14
  ]

while.body:                                       ; preds = %while.cond
  %handlers2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %3 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers2, align 8, !tbaa !42
  %event3 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %3, i32 0, i32 4
  %4 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event3, align 8, !tbaa !78
  %si_sm4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %5 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm4, align 8, !tbaa !41
  %call5 = call i32 %4(%struct.si_sm_data* %5, i64 0)
  br label %while.cond

if.then:                                          ; preds = %while.cond
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %arrayidx = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats, i64 0, i64 7
  call void @atomic_inc(%union.anon.1* %arrayidx)
  call void @handle_transaction_done(%struct.smi_info* %smi_info)
  %handlers8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %6 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers8, align 8, !tbaa !42
  %event9 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %6, i32 0, i32 4
  %7 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event9, align 8, !tbaa !78
  %si_sm10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %8 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm10, align 8, !tbaa !41
  %call11 = call i32 %7(%struct.si_sm_data* %8, i64 0)
  br label %if.end25

if.then14:                                        ; preds = %while.cond
  %stats15 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %arrayidx16 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats15, i64 0, i64 6
  call void @atomic_inc(%union.anon.1* %arrayidx16)
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 0, i32* %si_state, align 8, !tbaa !52
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %9 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !47
  %cmp17 = icmp ne %struct.ipmi_smi_msg* %9, null
  br i1 %cmp17, label %if.then19, label %if.end

if.then19:                                        ; preds = %if.then14
  call void @return_hosed_msg(%struct.smi_info* %smi_info, i32 255)
  br label %if.end

if.end:                                           ; preds = %if.then19, %if.then14
  %handlers20 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %10 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers20, align 8, !tbaa !42
  %event21 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %10, i32 0, i32 4
  %11 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event21, align 8, !tbaa !78
  %si_sm22 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %12 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm22, align 8, !tbaa !41
  %call23 = call i32 %11(%struct.si_sm_data* %12, i64 0)
  br label %if.end25

if.end25:                                         ; preds = %if.end, %if.then, %while.cond
  %si_sm_result.2 = phi i32 [ %call11, %if.then ], [ %call23, %if.end ], [ %si_sm_result.0, %while.cond ]
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 1
  %13 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !40
  %tobool = icmp ne %struct.ipmi_smi* %13, null
  %lnot = xor i1 %tobool, true
  %lnot26 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot26 to i32
  %conv27 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv27, i64 1)
  %tobool28 = icmp ne i64 %expval, 0
  %cmp29 = icmp eq i32 %si_sm_result.2, 6
  %or.cond = and i1 %tobool28, %cmp29
  br i1 %or.cond, label %if.then31, label %if.end40

if.then31:                                        ; preds = %if.end25
  %stats32 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %arrayidx33 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats32, i64 0, i64 4
  call void @atomic_inc(%union.anon.1* %arrayidx33)
  %arrayidx34 = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx34, align 1, !tbaa !6
  %arrayidx35 = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 1
  store i8 49, i8* %arrayidx35, align 1, !tbaa !6
  %handlers36 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %14 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers36, align 8, !tbaa !42
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %14, i32 0, i32 2
  %15 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !77
  %si_sm37 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %16 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm37, align 8, !tbaa !41
  %arraydecay = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i32 0, i32 0
  %call38 = call i32 %15(%struct.si_sm_data* %16, i8* %arraydecay, i32 2)
  %si_state39 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 1, i32* %si_state39, align 8, !tbaa !52
  br label %restart.backedge

restart.backedge:                                 ; preds = %if.end64, %if.then43, %if.then31
  br label %restart

if.end40:                                         ; preds = %if.end25
  %cmp41 = icmp eq i32 %si_sm_result.2, 4
  br i1 %cmp41, label %if.then43, label %if.end51

if.then43:                                        ; preds = %if.end40
  %stats44 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %arrayidx45 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats44, i64 0, i64 2
  call void @atomic_inc(%union.anon.1* %arrayidx45)
  %call46 = call i32 @start_next_msg(%struct.smi_info* %smi_info)
  %cmp47 = icmp ne i32 %call46, 4
  br i1 %cmp47, label %restart.backedge, label %if.end51

if.end51:                                         ; preds = %if.then43, %if.end40
  %si_sm_result.3 = phi i32 [ %si_sm_result.2, %if.end40 ], [ %call46, %if.then43 ]
  %cmp52 = icmp eq i32 %si_sm_result.3, 4
  br i1 %cmp52, label %land.lhs.true54, label %out

land.lhs.true54:                                  ; preds = %if.end51
  %req_events = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 22
  %call55 = call i32 @atomic_read(%union.anon.1* %req_events)
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %if.then57, label %out

if.then57:                                        ; preds = %land.lhs.true54
  %req_events58 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 22
  call void @atomic_set(%union.anon.1* %req_events58, i32 0)
  %call59 = call %struct.ipmi_smi_msg* @ipmi_alloc_smi_msg()
  %curr_msg60 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store %struct.ipmi_smi_msg* %call59, %struct.ipmi_smi_msg** %curr_msg60, align 8, !tbaa !47
  %curr_msg61 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %17 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg61, align 8, !tbaa !47
  %tobool62 = icmp ne %struct.ipmi_smi_msg* %17, null
  br i1 %tobool62, label %if.end64, label %out

if.end64:                                         ; preds = %if.then57
  %curr_msg65 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %18 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg65, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %18, i32 0, i32 4
  %arrayidx66 = getelementptr inbounds [272 x i8], [272 x i8]* %data, i64 0, i64 0
  store i8 24, i8* %arrayidx66, align 4, !tbaa !6
  %curr_msg67 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %19 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg67, align 8, !tbaa !47
  %data68 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %19, i32 0, i32 4
  %arrayidx69 = getelementptr inbounds [272 x i8], [272 x i8]* %data68, i64 0, i64 1
  store i8 53, i8* %arrayidx69, align 1, !tbaa !6
  %curr_msg70 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %20 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg70, align 8, !tbaa !47
  %data_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %20, i32 0, i32 3
  store i32 2, i32* %data_size, align 8, !tbaa !79
  %handlers71 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %21 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers71, align 8, !tbaa !42
  %start_transaction72 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %21, i32 0, i32 2
  %22 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction72, align 8, !tbaa !77
  %si_sm73 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %23 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm73, align 8, !tbaa !41
  %curr_msg74 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %24 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg74, align 8, !tbaa !47
  %data75 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %24, i32 0, i32 4
  %arraydecay76 = getelementptr inbounds [272 x i8], [272 x i8]* %data75, i32 0, i32 0
  %curr_msg77 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %25 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg77, align 8, !tbaa !47
  %data_size78 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %25, i32 0, i32 3
  %26 = load i32, i32* %data_size78, align 8, !tbaa !79
  %call79 = call i32 %22(%struct.si_sm_data* %23, i8* %arraydecay76, i32 %26)
  %si_state80 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 2, i32* %si_state80, align 8, !tbaa !52
  br label %restart.backedge

out:                                              ; preds = %if.then57, %land.lhs.true54, %if.end51
  ret i32 %si_sm_result.3
}

; Function Attrs: nounwind uwtable
define internal void @handle_transaction_done(%struct.smi_info* %smi_info) #0 {
entry:
  %msg6 = alloca [4 x i8], align 1
  %msg24 = alloca [3 x i8], align 1
  %msg98 = alloca [4 x i8], align 1
  %msg131 = alloca [4 x i8], align 1
  %msg152 = alloca [4 x i8], align 1
  %msg182 = alloca [4 x i8], align 1
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  %0 = load i32, i32* %si_state, align 8, !tbaa !52
  %Pivot16 = icmp slt i32 %0, 5
  br i1 %Pivot16, label %NodeBlock3, label %NodeBlock13

NodeBlock13:                                      ; preds = %entry
  %Pivot14 = icmp slt i32 %0, 7
  br i1 %Pivot14, label %NodeBlock5, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %0, 8
  br i1 %Pivot12, label %sw.bb130, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %0, 9
  br i1 %Pivot10, label %sw.bb151, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %0, 9
  br i1 %SwitchLeaf8, label %sw.bb181, label %sw.epilog

NodeBlock5:                                       ; preds = %NodeBlock13
  %Pivot6 = icmp slt i32 %0, 6
  br i1 %Pivot6, label %sw.bb70, label %sw.bb97

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %0, 2
  br i1 %Pivot4, label %NodeBlock, label %NodeBlock1

NodeBlock1:                                       ; preds = %NodeBlock3
  %Pivot2 = icmp slt i32 %0, 3
  br i1 %Pivot2, label %sw.bb46, label %sw.bb23

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %0, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb5

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %0, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %1 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !47
  %tobool = icmp ne %struct.ipmi_smi_msg* %1, null
  br i1 %tobool, label %if.end, label %sw.epilog

if.end:                                           ; preds = %sw.bb
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %2 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %get_result = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %2, i32 0, i32 3
  %3 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result, align 8, !tbaa !81
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %4 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %curr_msg1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %5 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg1, align 8, !tbaa !47
  %rsp = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %5, i32 0, i32 6
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %rsp, i32 0, i32 0
  %call = call i32 %3(%struct.si_sm_data* %4, i8* %arraydecay, i32 272)
  %curr_msg2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %6 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg2, align 8, !tbaa !47
  %rsp_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %6, i32 0, i32 5
  store i32 %call, i32* %rsp_size, align 4, !tbaa !82
  %curr_msg3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %7 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg3, align 8, !tbaa !47
  %curr_msg4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg4, align 8, !tbaa !47
  call void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %7)
  br label %sw.epilog

sw.bb5:                                           ; preds = %NodeBlock
  %handlers7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %8 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers7, align 8, !tbaa !42
  %get_result8 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %8, i32 0, i32 3
  %9 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result8, align 8, !tbaa !81
  %si_sm9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %10 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm9, align 8, !tbaa !41
  %arraydecay10 = getelementptr inbounds [4 x i8], [4 x i8]* %msg6, i32 0, i32 0
  %call11 = call i32 %9(%struct.si_sm_data* %10, i8* %arraydecay10, i32 4)
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %msg6, i64 0, i64 2
  %11 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv = zext i8 %11 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then13, label %if.else

if.then13:                                        ; preds = %sw.bb5
  %si_state14 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 0, i32* %si_state14, align 8, !tbaa !52
  br label %if.end22

if.else:                                          ; preds = %sw.bb5
  %cmp15 = icmp ult i32 %call11, 4
  br i1 %cmp15, label %if.then17, label %if.else19

if.then17:                                        ; preds = %if.else
  %si_state18 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 0, i32* %si_state18, align 8, !tbaa !52
  br label %if.end22

if.else19:                                        ; preds = %if.else
  %arrayidx20 = getelementptr inbounds [4 x i8], [4 x i8]* %msg6, i64 0, i64 3
  %12 = load i8, i8* %arrayidx20, align 1, !tbaa !6
  %msg_flags = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 20
  store i8 %12, i8* %msg_flags, align 8, !tbaa !83
  call void @handle_flags(%struct.smi_info* %smi_info)
  br label %if.end22

if.end22:                                         ; preds = %if.else19, %if.then17, %if.then13
  br label %sw.epilog

sw.bb23:                                          ; preds = %NodeBlock1
  %handlers25 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %13 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers25, align 8, !tbaa !42
  %get_result26 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %13, i32 0, i32 3
  %14 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result26, align 8, !tbaa !81
  %si_sm27 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %15 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm27, align 8, !tbaa !41
  %arraydecay28 = getelementptr inbounds [3 x i8], [3 x i8]* %msg24, i32 0, i32 0
  %call29 = call i32 %14(%struct.si_sm_data* %15, i8* %arraydecay28, i32 3)
  %arrayidx30 = getelementptr inbounds [3 x i8], [3 x i8]* %msg24, i64 0, i64 2
  %16 = load i8, i8* %arrayidx30, align 1, !tbaa !6
  %conv31 = zext i8 %16 to i32
  %cmp32 = icmp ne i32 %conv31, 0
  br i1 %cmp32, label %if.then34, label %if.end38

if.then34:                                        ; preds = %sw.bb23
  %17 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end38

if.end38:                                         ; preds = %if.then34, %sw.bb23
  %si_state39 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  %18 = load i32, i32* %si_state39, align 8, !tbaa !52
  %cmp40 = icmp eq i32 %18, 4
  br i1 %cmp40, label %if.then42, label %if.else43

if.then42:                                        ; preds = %if.end38
  call void @start_enable_irq(%struct.smi_info* %smi_info)
  br label %if.end45

if.else43:                                        ; preds = %if.end38
  %si_state44 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 0, i32* %si_state44, align 8, !tbaa !52
  br label %if.end45

if.end45:                                         ; preds = %if.else43, %if.then42
  br label %sw.epilog

sw.bb46:                                          ; preds = %NodeBlock1
  %handlers47 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %19 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers47, align 8, !tbaa !42
  %get_result48 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %19, i32 0, i32 3
  %20 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result48, align 8, !tbaa !81
  %si_sm49 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %21 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm49, align 8, !tbaa !41
  %curr_msg50 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %22 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg50, align 8, !tbaa !47
  %rsp51 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %22, i32 0, i32 6
  %arraydecay52 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp51, i32 0, i32 0
  %call53 = call i32 %20(%struct.si_sm_data* %21, i8* %arraydecay52, i32 272)
  %curr_msg54 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %23 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg54, align 8, !tbaa !47
  %rsp_size55 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %23, i32 0, i32 5
  store i32 %call53, i32* %rsp_size55, align 4, !tbaa !82
  %curr_msg56 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %24 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg56, align 8, !tbaa !47
  %curr_msg57 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg57, align 8, !tbaa !47
  %rsp58 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %24, i32 0, i32 6
  %arrayidx59 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp58, i64 0, i64 2
  %25 = load i8, i8* %arrayidx59, align 2, !tbaa !6
  %conv60 = zext i8 %25 to i32
  %cmp61 = icmp ne i32 %conv60, 0
  br i1 %cmp61, label %if.then63, label %if.else67

if.then63:                                        ; preds = %sw.bb46
  %done = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %24, i32 0, i32 7
  %26 = load void (%struct.ipmi_smi_msg*)*, void (%struct.ipmi_smi_msg*)** %done, align 8, !tbaa !84
  call void %26(%struct.ipmi_smi_msg* %24)
  %msg_flags64 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 20
  %27 = load i8, i8* %msg_flags64, align 8, !tbaa !83
  %conv65 = zext i8 %27 to i32
  %and = and i32 %conv65, -3
  %conv66 = trunc i32 %and to i8
  store i8 %conv66, i8* %msg_flags64, align 8, !tbaa !83
  call void @handle_flags(%struct.smi_info* %smi_info)
  br label %sw.epilog

if.else67:                                        ; preds = %sw.bb46
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %arrayidx68 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats, i64 0, i64 8
  call void @atomic_inc(%union.anon.1* %arrayidx68)
  call void @handle_flags(%struct.smi_info* %smi_info)
  call void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %24)
  br label %sw.epilog

sw.bb70:                                          ; preds = %NodeBlock5
  %handlers71 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %28 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers71, align 8, !tbaa !42
  %get_result72 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %28, i32 0, i32 3
  %29 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result72, align 8, !tbaa !81
  %si_sm73 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %30 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm73, align 8, !tbaa !41
  %curr_msg74 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %31 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg74, align 8, !tbaa !47
  %rsp75 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %31, i32 0, i32 6
  %arraydecay76 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp75, i32 0, i32 0
  %call77 = call i32 %29(%struct.si_sm_data* %30, i8* %arraydecay76, i32 272)
  %curr_msg78 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %32 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg78, align 8, !tbaa !47
  %rsp_size79 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %32, i32 0, i32 5
  store i32 %call77, i32* %rsp_size79, align 4, !tbaa !82
  %curr_msg80 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %33 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg80, align 8, !tbaa !47
  %curr_msg81 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg81, align 8, !tbaa !47
  %rsp82 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %33, i32 0, i32 6
  %arrayidx83 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp82, i64 0, i64 2
  %34 = load i8, i8* %arrayidx83, align 2, !tbaa !6
  %conv84 = zext i8 %34 to i32
  %cmp85 = icmp ne i32 %conv84, 0
  br i1 %cmp85, label %if.then87, label %if.else93

if.then87:                                        ; preds = %sw.bb70
  %done88 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %33, i32 0, i32 7
  %35 = load void (%struct.ipmi_smi_msg*)*, void (%struct.ipmi_smi_msg*)** %done88, align 8, !tbaa !84
  call void %35(%struct.ipmi_smi_msg* %33)
  %msg_flags89 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 20
  %36 = load i8, i8* %msg_flags89, align 8, !tbaa !83
  %conv90 = zext i8 %36 to i32
  %and91 = and i32 %conv90, -2
  %conv92 = trunc i32 %and91 to i8
  store i8 %conv92, i8* %msg_flags89, align 8, !tbaa !83
  call void @handle_flags(%struct.smi_info* %smi_info)
  br label %sw.epilog

if.else93:                                        ; preds = %sw.bb70
  %stats94 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %arrayidx95 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats94, i64 0, i64 10
  call void @atomic_inc(%union.anon.1* %arrayidx95)
  call void @handle_flags(%struct.smi_info* %smi_info)
  call void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %33)
  br label %sw.epilog

sw.bb97:                                          ; preds = %NodeBlock5
  %handlers99 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %37 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers99, align 8, !tbaa !42
  %get_result100 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %37, i32 0, i32 3
  %38 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result100, align 8, !tbaa !81
  %si_sm101 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %39 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm101, align 8, !tbaa !41
  %arraydecay102 = getelementptr inbounds [4 x i8], [4 x i8]* %msg98, i32 0, i32 0
  %call103 = call i32 %38(%struct.si_sm_data* %39, i8* %arraydecay102, i32 4)
  %arrayidx104 = getelementptr inbounds [4 x i8], [4 x i8]* %msg98, i64 0, i64 2
  %40 = load i8, i8* %arrayidx104, align 1, !tbaa !6
  %conv105 = zext i8 %40 to i32
  %cmp106 = icmp ne i32 %conv105, 0
  br i1 %cmp106, label %if.then108, label %if.else116

if.then108:                                       ; preds = %sw.bb97
  %41 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %42 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end129

if.else116:                                       ; preds = %sw.bb97
  %arrayidx117 = getelementptr inbounds [4 x i8], [4 x i8]* %msg98, i64 0, i64 0
  store i8 24, i8* %arrayidx117, align 1, !tbaa !6
  %arrayidx118 = getelementptr inbounds [4 x i8], [4 x i8]* %msg98, i64 0, i64 1
  store i8 46, i8* %arrayidx118, align 1, !tbaa !6
  %arrayidx119 = getelementptr inbounds [4 x i8], [4 x i8]* %msg98, i64 0, i64 3
  %43 = load i8, i8* %arrayidx119, align 1, !tbaa !6
  %conv120 = zext i8 %43 to i32
  %or = or i32 %conv120, 1
  %or121 = or i32 %or, 2
  %conv122 = trunc i32 %or121 to i8
  %arrayidx123 = getelementptr inbounds [4 x i8], [4 x i8]* %msg98, i64 0, i64 2
  store i8 %conv122, i8* %arrayidx123, align 1, !tbaa !6
  %handlers124 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %44 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers124, align 8, !tbaa !42
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %44, i32 0, i32 2
  %45 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !77
  %si_sm125 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %46 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm125, align 8, !tbaa !41
  %arraydecay126 = getelementptr inbounds [4 x i8], [4 x i8]* %msg98, i32 0, i32 0
  %call127 = call i32 %45(%struct.si_sm_data* %46, i8* %arraydecay126, i32 3)
  br label %if.end129

if.end129:                                        ; preds = %if.else116, %if.then108
  %.sink = phi i32 [ 7, %if.else116 ], [ 0, %if.then108 ]
  %si_state128 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 %.sink, i32* %si_state128, align 8, !tbaa !52
  br label %sw.epilog

sw.bb130:                                         ; preds = %NodeBlock11
  %handlers132 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %47 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers132, align 8, !tbaa !42
  %get_result133 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %47, i32 0, i32 3
  %48 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result133, align 8, !tbaa !81
  %si_sm134 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %49 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm134, align 8, !tbaa !41
  %arraydecay135 = getelementptr inbounds [4 x i8], [4 x i8]* %msg131, i32 0, i32 0
  %call136 = call i32 %48(%struct.si_sm_data* %49, i8* %arraydecay135, i32 4)
  %arrayidx137 = getelementptr inbounds [4 x i8], [4 x i8]* %msg131, i64 0, i64 2
  %50 = load i8, i8* %arrayidx137, align 1, !tbaa !6
  %conv138 = zext i8 %50 to i32
  %cmp139 = icmp ne i32 %conv138, 0
  br i1 %cmp139, label %if.then141, label %if.else148

if.then141:                                       ; preds = %sw.bb130
  %51 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %52 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end149

if.else148:                                       ; preds = %sw.bb130
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  store i32 0, i32* %interrupt_disabled, align 4, !tbaa !49
  br label %if.end149

if.end149:                                        ; preds = %if.else148, %if.then141
  %si_state150 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 0, i32* %si_state150, align 8, !tbaa !52
  br label %sw.epilog

sw.bb151:                                         ; preds = %NodeBlock9
  %handlers153 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %53 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers153, align 8, !tbaa !42
  %get_result154 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %53, i32 0, i32 3
  %54 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result154, align 8, !tbaa !81
  %si_sm155 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %55 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm155, align 8, !tbaa !41
  %arraydecay156 = getelementptr inbounds [4 x i8], [4 x i8]* %msg152, i32 0, i32 0
  %call157 = call i32 %54(%struct.si_sm_data* %55, i8* %arraydecay156, i32 4)
  %arrayidx158 = getelementptr inbounds [4 x i8], [4 x i8]* %msg152, i64 0, i64 2
  %56 = load i8, i8* %arrayidx158, align 1, !tbaa !6
  %conv159 = zext i8 %56 to i32
  %cmp160 = icmp ne i32 %conv159, 0
  br i1 %cmp160, label %if.then162, label %if.else166

if.then162:                                       ; preds = %sw.bb151
  %57 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end180

if.else166:                                       ; preds = %sw.bb151
  %arrayidx167 = getelementptr inbounds [4 x i8], [4 x i8]* %msg152, i64 0, i64 0
  store i8 24, i8* %arrayidx167, align 1, !tbaa !6
  %arrayidx168 = getelementptr inbounds [4 x i8], [4 x i8]* %msg152, i64 0, i64 1
  store i8 46, i8* %arrayidx168, align 1, !tbaa !6
  %arrayidx169 = getelementptr inbounds [4 x i8], [4 x i8]* %msg152, i64 0, i64 3
  %58 = load i8, i8* %arrayidx169, align 1, !tbaa !6
  %conv170 = zext i8 %58 to i32
  %and171 = and i32 %conv170, -4
  %conv172 = trunc i32 %and171 to i8
  %arrayidx173 = getelementptr inbounds [4 x i8], [4 x i8]* %msg152, i64 0, i64 2
  store i8 %conv172, i8* %arrayidx173, align 1, !tbaa !6
  %handlers174 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %59 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers174, align 8, !tbaa !42
  %start_transaction175 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %59, i32 0, i32 2
  %60 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction175, align 8, !tbaa !77
  %si_sm176 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %61 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm176, align 8, !tbaa !41
  %arraydecay177 = getelementptr inbounds [4 x i8], [4 x i8]* %msg152, i32 0, i32 0
  %call178 = call i32 %60(%struct.si_sm_data* %61, i8* %arraydecay177, i32 3)
  br label %if.end180

if.end180:                                        ; preds = %if.else166, %if.then162
  %.sink17 = phi i32 [ 9, %if.else166 ], [ 0, %if.then162 ]
  %si_state179 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 %.sink17, i32* %si_state179, align 8, !tbaa !52
  br label %sw.epilog

sw.bb181:                                         ; preds = %LeafBlock7
  %handlers183 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %62 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers183, align 8, !tbaa !42
  %get_result184 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %62, i32 0, i32 3
  %63 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result184, align 8, !tbaa !81
  %si_sm185 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %64 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm185, align 8, !tbaa !41
  %arraydecay186 = getelementptr inbounds [4 x i8], [4 x i8]* %msg182, i32 0, i32 0
  %call187 = call i32 %63(%struct.si_sm_data* %64, i8* %arraydecay186, i32 4)
  %arrayidx188 = getelementptr inbounds [4 x i8], [4 x i8]* %msg182, i64 0, i64 2
  %65 = load i8, i8* %arrayidx188, align 1, !tbaa !6
  %conv189 = zext i8 %65 to i32
  %cmp190 = icmp ne i32 %conv189, 0
  br i1 %cmp190, label %if.then192, label %if.end195

if.then192:                                       ; preds = %sw.bb181
  %66 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %if.end195

if.end195:                                        ; preds = %if.then192, %sw.bb181
  %si_state196 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 0, i32* %si_state196, align 8, !tbaa !52
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end195, %if.end180, %if.end149, %if.end129, %if.else93, %if.then87, %if.else67, %if.then63, %if.end45, %if.end22, %if.end, %sw.bb, %LeafBlock, %LeafBlock7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @return_hosed_msg(%struct.smi_info* %smi_info, i32 %cCode) #0 {
entry:
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %0 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !47
  %cmp = icmp slt i32 %cCode, 0
  %cmp1 = icmp sgt i32 %cCode, 255
  %or.cond = or i1 %cmp, %cmp1
  %cCode.addr.0 = select i1 %or.cond, i32 255, i32 %cCode
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 4
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %data, i64 0, i64 0
  %1 = load i8, i8* %arrayidx, align 4, !tbaa !6
  %conv = zext i8 %1 to i32
  %or = or i32 %conv, 4
  %conv2 = trunc i32 %or to i8
  %rsp = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx3 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp, i64 0, i64 0
  store i8 %conv2, i8* %arrayidx3, align 8, !tbaa !6
  %data4 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 4
  %arrayidx5 = getelementptr inbounds [272 x i8], [272 x i8]* %data4, i64 0, i64 1
  %2 = load i8, i8* %arrayidx5, align 1, !tbaa !6
  %rsp6 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx7 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp6, i64 0, i64 1
  store i8 %2, i8* %arrayidx7, align 1, !tbaa !6
  %conv8 = trunc i32 %cCode.addr.0 to i8
  %rsp9 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx10 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp9, i64 0, i64 2
  store i8 %conv8, i8* %arrayidx10, align 2, !tbaa !6
  %rsp_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 5
  store i32 3, i32* %rsp_size, align 4, !tbaa !82
  %curr_msg11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg11, align 8, !tbaa !47
  call void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %0)
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #4

; Function Attrs: nounwind uwtable
define internal i32 @start_next_msg(%struct.smi_info* %smi_info) #0 {
entry:
  %hp_xmit_msgs = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  %call = call i32 @list_empty(%struct.list_head* %hp_xmit_msgs)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %hp_xmit_msgs2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 7
  br label %if.end8.sink.split

if.else:                                          ; preds = %entry
  %xmit_msgs = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 6
  %call3 = call i32 @list_empty(%struct.list_head* %xmit_msgs)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end8, label %if.then5

if.then5:                                         ; preds = %if.else
  %xmit_msgs6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 6
  br label %if.end8.sink.split

if.end8.sink.split:                               ; preds = %if.then5, %if.then
  %xmit_msgs6.sink = phi %struct.list_head* [ %xmit_msgs6, %if.then5 ], [ %hp_xmit_msgs2, %if.then ]
  %next7 = getelementptr inbounds %struct.list_head, %struct.list_head* %xmit_msgs6.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next7, align 8, !tbaa !7
  br label %if.end8

if.end8:                                          ; preds = %if.end8.sink.split, %if.else
  %entry1.1 = phi %struct.list_head* [ null, %if.else ], [ %0, %if.end8.sink.split ]
  %tobool9 = icmp ne %struct.list_head* %entry1.1, null
  br i1 %tobool9, label %if.else11, label %if.then10

if.then10:                                        ; preds = %if.end8
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !47
  ret i32 4

if.else11:                                        ; preds = %if.end8
  call void @list_del(%struct.list_head* %entry1.1)
  %1 = bitcast %struct.list_head* %entry1.1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.ipmi_smi_msg*
  %curr_msg12 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store %struct.ipmi_smi_msg* %2, %struct.ipmi_smi_msg** %curr_msg12, align 8, !tbaa !47
  %3 = bitcast %struct.smi_info* %smi_info to i8*
  %call13 = call i32 @atomic_notifier_call_chain(%struct.atomic_notifier_head* @xaction_notifier_list, i64 0, i8* %3)
  %and = and i32 %call13, 32768
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %NodeBlock, label %if.end16

if.end16:                                         ; preds = %if.else11
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %4 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %4, i32 0, i32 2
  %5 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !77
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %6 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %curr_msg17 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %7 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg17, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %7, i32 0, i32 4
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %data, i32 0, i32 0
  %curr_msg18 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %8 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg18, align 8, !tbaa !47
  %data_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %8, i32 0, i32 3
  %9 = load i32, i32* %data_size, align 8, !tbaa !79
  %call19 = call i32 %5(%struct.si_sm_data* %6, i8* %arraydecay, i32 %9)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.then21, label %NodeBlock

if.then21:                                        ; preds = %if.end16
  call void @return_hosed_msg(%struct.smi_info* %smi_info, i32 %call19)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.then21, %if.end16, %if.else11
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set(%union.anon.1* %v, i32 %i) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !85
  ret void
}

declare %struct.ipmi_smi_msg* @ipmi_alloc_smi_msg() #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !30
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i32 @atomic_notifier_call_chain(%struct.atomic_notifier_head*, i64, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %msg) #0 {
entry:
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 1
  %0 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !40
  call void @ipmi_smi_msg_received(%struct.ipmi_smi* %0, %struct.ipmi_smi_msg* %msg)
  ret void
}

declare void @ipmi_smi_msg_received(%struct.ipmi_smi*, %struct.ipmi_smi_msg*) #1

; Function Attrs: nounwind uwtable
define internal void @handle_flags(%struct.smi_info* %smi_info) #0 {
entry:
  br label %retry

retry:                                            ; preds = %if.then66, %entry
  %msg_flags = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 20
  %0 = load i8, i8* %msg_flags, align 8, !tbaa !83
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %retry
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 36
  %arrayidx = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats, i64 0, i64 9
  call void @atomic_inc(%union.anon.1* %arrayidx)
  call void @start_clear_flags(%struct.smi_info* %smi_info)
  %msg_flags1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 20
  %1 = load i8, i8* %msg_flags1, align 8, !tbaa !83
  %conv2 = zext i8 %1 to i32
  %and3 = and i32 %conv2, -9
  %conv4 = trunc i32 %and3 to i8
  store i8 %conv4, i8* %msg_flags1, align 8, !tbaa !83
  %intf = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 1
  %2 = load %struct.ipmi_smi*, %struct.ipmi_smi** %intf, align 8, !tbaa !40
  call void @ipmi_smi_watchdog_pretimeout(%struct.ipmi_smi* %2)
  br label %if.end73

if.else:                                          ; preds = %retry
  %msg_flags5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 20
  %3 = load i8, i8* %msg_flags5, align 8, !tbaa !83
  %conv6 = zext i8 %3 to i32
  %and7 = and i32 %conv6, 1
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then9, label %if.else25

if.then9:                                         ; preds = %if.else
  %call = call %struct.ipmi_smi_msg* @ipmi_alloc_smi_msg()
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store %struct.ipmi_smi_msg* %call, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !47
  %curr_msg10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %4 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg10, align 8, !tbaa !47
  %tobool11 = icmp ne %struct.ipmi_smi_msg* %4, null
  br i1 %tobool11, label %if.end, label %if.then12

if.then12:                                        ; preds = %if.then9
  call void @disable_si_irq(%struct.smi_info* %smi_info)
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 0, i32* %si_state, align 8, !tbaa !52
  br label %if.end73

if.end:                                           ; preds = %if.then9
  call void @enable_si_irq(%struct.smi_info* %smi_info)
  %curr_msg13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %5 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg13, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %5, i32 0, i32 4
  %arrayidx14 = getelementptr inbounds [272 x i8], [272 x i8]* %data, i64 0, i64 0
  store i8 24, i8* %arrayidx14, align 4, !tbaa !6
  %curr_msg15 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %6 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg15, align 8, !tbaa !47
  %data16 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %6, i32 0, i32 4
  %arrayidx17 = getelementptr inbounds [272 x i8], [272 x i8]* %data16, i64 0, i64 1
  store i8 51, i8* %arrayidx17, align 1, !tbaa !6
  %curr_msg18 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %7 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg18, align 8, !tbaa !47
  %data_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %7, i32 0, i32 3
  store i32 2, i32* %data_size, align 8, !tbaa !79
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %8 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %8, i32 0, i32 2
  %9 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !77
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %10 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %curr_msg19 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %11 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg19, align 8, !tbaa !47
  %data20 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %11, i32 0, i32 4
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %data20, i32 0, i32 0
  %curr_msg21 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %12 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg21, align 8, !tbaa !47
  %data_size22 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %12, i32 0, i32 3
  %13 = load i32, i32* %data_size22, align 8, !tbaa !79
  %call23 = call i32 %9(%struct.si_sm_data* %10, i8* %arraydecay, i32 %13)
  %si_state24 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 5, i32* %si_state24, align 8, !tbaa !52
  br label %if.end73

if.else25:                                        ; preds = %if.else
  %msg_flags26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 20
  %14 = load i8, i8* %msg_flags26, align 8, !tbaa !83
  %conv27 = zext i8 %14 to i32
  %and28 = and i32 %conv27, 2
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then30, label %if.else56

if.then30:                                        ; preds = %if.else25
  %call31 = call %struct.ipmi_smi_msg* @ipmi_alloc_smi_msg()
  %curr_msg32 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store %struct.ipmi_smi_msg* %call31, %struct.ipmi_smi_msg** %curr_msg32, align 8, !tbaa !47
  %curr_msg33 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %15 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg33, align 8, !tbaa !47
  %tobool34 = icmp ne %struct.ipmi_smi_msg* %15, null
  br i1 %tobool34, label %if.end37, label %if.then35

if.then35:                                        ; preds = %if.then30
  call void @disable_si_irq(%struct.smi_info* %smi_info)
  %si_state36 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 0, i32* %si_state36, align 8, !tbaa !52
  br label %if.end73

if.end37:                                         ; preds = %if.then30
  call void @enable_si_irq(%struct.smi_info* %smi_info)
  %curr_msg38 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %16 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg38, align 8, !tbaa !47
  %data39 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %16, i32 0, i32 4
  %arrayidx40 = getelementptr inbounds [272 x i8], [272 x i8]* %data39, i64 0, i64 0
  store i8 24, i8* %arrayidx40, align 4, !tbaa !6
  %curr_msg41 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %17 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg41, align 8, !tbaa !47
  %data42 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %17, i32 0, i32 4
  %arrayidx43 = getelementptr inbounds [272 x i8], [272 x i8]* %data42, i64 0, i64 1
  store i8 53, i8* %arrayidx43, align 1, !tbaa !6
  %curr_msg44 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %18 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg44, align 8, !tbaa !47
  %data_size45 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %18, i32 0, i32 3
  store i32 2, i32* %data_size45, align 8, !tbaa !79
  %handlers46 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %19 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers46, align 8, !tbaa !42
  %start_transaction47 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %19, i32 0, i32 2
  %20 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction47, align 8, !tbaa !77
  %si_sm48 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %21 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm48, align 8, !tbaa !41
  %curr_msg49 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %22 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg49, align 8, !tbaa !47
  %data50 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %22, i32 0, i32 4
  %arraydecay51 = getelementptr inbounds [272 x i8], [272 x i8]* %data50, i32 0, i32 0
  %curr_msg52 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %23 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg52, align 8, !tbaa !47
  %data_size53 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %23, i32 0, i32 3
  %24 = load i32, i32* %data_size53, align 8, !tbaa !79
  %call54 = call i32 %20(%struct.si_sm_data* %21, i8* %arraydecay51, i32 %24)
  %si_state55 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 2, i32* %si_state55, align 8, !tbaa !52
  br label %if.end73

if.else56:                                        ; preds = %if.else25
  %msg_flags57 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 20
  %25 = load i8, i8* %msg_flags57, align 8, !tbaa !83
  %conv58 = zext i8 %25 to i32
  %and59 = and i32 %conv58, 224
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %land.lhs.true, label %if.else68

land.lhs.true:                                    ; preds = %if.else56
  %oem_data_avail_handler = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  %26 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %oem_data_avail_handler, align 8, !tbaa !86
  %tobool61 = icmp ne i32 (%struct.smi_info*)* %26, null
  br i1 %tobool61, label %if.then62, label %if.else68

if.then62:                                        ; preds = %land.lhs.true
  %oem_data_avail_handler63 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  %27 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %oem_data_avail_handler63, align 8, !tbaa !86
  %call64 = call i32 %27(%struct.smi_info* %smi_info)
  %tobool65 = icmp ne i32 %call64, 0
  br i1 %tobool65, label %if.then66, label %if.end73

if.then66:                                        ; preds = %if.then62
  br label %retry

if.else68:                                        ; preds = %land.lhs.true, %if.else56
  %si_state69 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 0, i32* %si_state69, align 8, !tbaa !52
  br label %if.end73

if.end73:                                         ; preds = %if.else68, %if.then62, %if.end37, %if.then35, %if.end, %if.then12, %if.then
  ret void
}

declare i32 @dev_warn(%struct.device*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal void @start_enable_irq(%struct.smi_info* %smi_info) #0 {
entry:
  %msg = alloca [2 x i8], align 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 1
  store i8 47, i8* %arrayidx1, align 1, !tbaa !6
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %0 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %0, i32 0, i32 2
  %1 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !77
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %2 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %arraydecay = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i32 0, i32 0
  %call = call i32 %1(%struct.si_sm_data* %2, i8* %arraydecay, i32 2)
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 6, i32* %si_state, align 8, !tbaa !52
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @start_clear_flags(%struct.smi_info* %smi_info) #0 {
entry:
  %msg = alloca [3 x i8], align 1
  %arrayidx = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 1
  store i8 48, i8* %arrayidx1, align 1, !tbaa !6
  %arrayidx2 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 2
  store i8 8, i8* %arrayidx2, align 1, !tbaa !6
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %0 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %0, i32 0, i32 2
  %1 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !77
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %2 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %arraydecay = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i32 0, i32 0
  %call = call i32 %1(%struct.si_sm_data* %2, i8* %arraydecay, i32 3)
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 9
  store i32 3, i32* %si_state, align 8, !tbaa !52
  ret void
}

declare void @ipmi_smi_watchdog_pretimeout(%struct.ipmi_smi*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @enable_si_irq(%struct.smi_info* %smi_info) #3 {
entry:
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 26
  %0 = load i32, i32* %irq, align 4, !tbaa !27
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  %1 = load i32, i32* %interrupt_disabled, align 4, !tbaa !49
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @start_enable_irq(%struct.smi_info* %smi_info)
  %interrupt_disabled2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 30
  store i32 0, i32* %interrupt_disabled2, align 4, !tbaa !49
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

declare i32 @kthread_stop(%struct.task_struct*) #1

declare i32 @del_timer_sync(%struct.timer_list*) #1

; Function Attrs: nounwind uwtable
define internal i32 @try_get_dev_id(%struct.smi_info* %smi_info) #0 {
entry:
  %msg = alloca [2 x i8], align 1
  %call.i = call i8* @__kmalloc(i64 272, i32 208) #5
  %tobool = icmp ne i8* %call.i, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i64 0, i64 1
  store i8 1, i8* %arrayidx1, align 1, !tbaa !6
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %0 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %0, i32 0, i32 2
  %1 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !77
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %2 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %arraydecay = getelementptr inbounds [2 x i8], [2 x i8]* %msg, i32 0, i32 0
  %call2 = call i32 %1(%struct.si_sm_data* %2, i8* %arraydecay, i32 2)
  %call3 = call i32 @wait_for_msg_done(%struct.smi_info* %smi_info)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %out, label %if.end6

if.end6:                                          ; preds = %if.end
  %handlers7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %3 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers7, align 8, !tbaa !42
  %get_result = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %3, i32 0, i32 3
  %4 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result, align 8, !tbaa !81
  %si_sm8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %5 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm8, align 8, !tbaa !41
  %call9 = call i32 %4(%struct.si_sm_data* %5, i8* %call.i, i32 272)
  %conv = sext i32 %call9 to i64
  %conv10 = trunc i64 %conv to i32
  %device_id = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 31
  %call11 = call i32 @ipmi_demangle_device_id(i8* %call.i, i32 %conv10, %struct.ipmi_device_id* %device_id)
  br label %out

out:                                              ; preds = %if.end6, %if.end
  %rv.0 = phi i32 [ %call11, %if.end6 ], [ %call3, %if.end ]
  call void @kfree(i8* %call.i)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %rv.0, %out ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @setup_oem_data_handler(%struct.smi_info* %smi_info) #0 {
entry:
  call void @setup_dell_poweredge_oem_data_handler(%struct.smi_info* %smi_info)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @setup_xaction_handlers(%struct.smi_info* %smi_info) #0 {
entry:
  call void @setup_dell_poweredge_bt_xaction_handler(%struct.smi_info* %smi_info)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !30
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !87
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @try_enable_event_buffer(%struct.smi_info* %smi_info) #0 {
entry:
  %msg = alloca [3 x i8], align 1
  %call.i = call i8* @__kmalloc(i64 272, i32 208) #5
  %tobool = icmp ne i8* %call.i, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx1 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 1
  store i8 47, i8* %arrayidx1, align 1, !tbaa !6
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %0 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %start_transaction = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %0, i32 0, i32 2
  %1 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction, align 8, !tbaa !77
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %2 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %arraydecay = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i32 0, i32 0
  %call2 = call i32 %1(%struct.si_sm_data* %2, i8* %arraydecay, i32 2)
  %call3 = call i32 @wait_for_msg_done(%struct.smi_info* %smi_info)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

if.end7:                                          ; preds = %if.end
  %handlers8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %4 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers8, align 8, !tbaa !42
  %get_result = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %4, i32 0, i32 3
  %5 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result, align 8, !tbaa !81
  %si_sm9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %6 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm9, align 8, !tbaa !41
  %call10 = call i32 %5(%struct.si_sm_data* %6, i8* %call.i, i32 272)
  %conv = sext i32 %call10 to i64
  %cmp = icmp ult i64 %conv, 4
  br i1 %cmp, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %arrayidx12 = getelementptr inbounds i8, i8* %call.i, i64 0
  %7 = load i8, i8* %arrayidx12, align 1, !tbaa !6
  %conv13 = zext i8 %7 to i32
  %cmp14 = icmp ne i32 %conv13, 28
  br i1 %cmp14, label %if.then26, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %lor.lhs.false
  %arrayidx17 = getelementptr inbounds i8, i8* %call.i, i64 1
  %8 = load i8, i8* %arrayidx17, align 1, !tbaa !6
  %conv18 = zext i8 %8 to i32
  %cmp19 = icmp ne i32 %conv18, 47
  br i1 %cmp19, label %if.then26, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %lor.lhs.false16
  %arrayidx22 = getelementptr inbounds i8, i8* %call.i, i64 2
  %9 = load i8, i8* %arrayidx22, align 1, !tbaa !6
  %conv23 = zext i8 %9 to i32
  %cmp24 = icmp ne i32 %conv23, 0
  br i1 %cmp24, label %if.then26, label %if.end28

if.then26:                                        ; preds = %lor.lhs.false21, %lor.lhs.false16, %lor.lhs.false, %if.end7
  %10 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

if.end28:                                         ; preds = %lor.lhs.false21
  %arrayidx29 = getelementptr inbounds i8, i8* %call.i, i64 3
  %11 = load i8, i8* %arrayidx29, align 1, !tbaa !6
  %conv30 = zext i8 %11 to i32
  %and = and i32 %conv30, 4
  %tobool31 = icmp ne i32 %and, 0
  br i1 %tobool31, label %out, label %if.end33

if.end33:                                         ; preds = %if.end28
  %arrayidx34 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 0
  store i8 24, i8* %arrayidx34, align 1, !tbaa !6
  %arrayidx35 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 1
  store i8 46, i8* %arrayidx35, align 1, !tbaa !6
  %arrayidx36 = getelementptr inbounds i8, i8* %call.i, i64 3
  %12 = load i8, i8* %arrayidx36, align 1, !tbaa !6
  %conv37 = zext i8 %12 to i32
  %or = or i32 %conv37, 4
  %conv38 = trunc i32 %or to i8
  %arrayidx39 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i64 0, i64 2
  store i8 %conv38, i8* %arrayidx39, align 1, !tbaa !6
  %handlers40 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %13 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers40, align 8, !tbaa !42
  %start_transaction41 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %13, i32 0, i32 2
  %14 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %start_transaction41, align 8, !tbaa !77
  %si_sm42 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %15 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm42, align 8, !tbaa !41
  %arraydecay43 = getelementptr inbounds [3 x i8], [3 x i8]* %msg, i32 0, i32 0
  %call44 = call i32 %14(%struct.si_sm_data* %15, i8* %arraydecay43, i32 3)
  %call45 = call i32 @wait_for_msg_done(%struct.smi_info* %smi_info)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.then47, label %if.end49

if.then47:                                        ; preds = %if.end33
  %16 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

if.end49:                                         ; preds = %if.end33
  %handlers50 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %17 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers50, align 8, !tbaa !42
  %get_result51 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %17, i32 0, i32 3
  %18 = load i32 (%struct.si_sm_data*, i8*, i32)*, i32 (%struct.si_sm_data*, i8*, i32)** %get_result51, align 8, !tbaa !81
  %si_sm52 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %19 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm52, align 8, !tbaa !41
  %call53 = call i32 %18(%struct.si_sm_data* %19, i8* %call.i, i32 272)
  %conv54 = sext i32 %call53 to i64
  %cmp55 = icmp ult i64 %conv54, 3
  br i1 %cmp55, label %if.then67, label %lor.lhs.false57

lor.lhs.false57:                                  ; preds = %if.end49
  %arrayidx58 = getelementptr inbounds i8, i8* %call.i, i64 0
  %20 = load i8, i8* %arrayidx58, align 1, !tbaa !6
  %conv59 = zext i8 %20 to i32
  %cmp60 = icmp ne i32 %conv59, 28
  br i1 %cmp60, label %if.then67, label %lor.lhs.false62

lor.lhs.false62:                                  ; preds = %lor.lhs.false57
  %arrayidx63 = getelementptr inbounds i8, i8* %call.i, i64 1
  %21 = load i8, i8* %arrayidx63, align 1, !tbaa !6
  %conv64 = zext i8 %21 to i32
  %cmp65 = icmp ne i32 %conv64, 46
  br i1 %cmp65, label %if.then67, label %if.end69

if.then67:                                        ; preds = %lor.lhs.false62, %lor.lhs.false57, %if.end49
  %22 = call i32 (i8*, ...) @printk(i8* null)
  br label %out

if.end69:                                         ; preds = %lor.lhs.false62
  %arrayidx70 = getelementptr inbounds i8, i8* %call.i, i64 2
  %23 = load i8, i8* %arrayidx70, align 1, !tbaa !6
  %conv71 = zext i8 %23 to i32
  %cmp72 = icmp ne i32 %conv71, 0
  %.call45 = select i1 %cmp72, i32 -2, i32 %call45
  br label %out

out:                                              ; preds = %if.end69, %if.then67, %if.then47, %if.end28, %if.then26, %if.then5
  %rv.1 = phi i32 [ %call3, %if.then5 ], [ -22, %if.then26 ], [ %call45, %if.then47 ], [ -22, %if.then67 ], [ %.call45, %if.end69 ], [ %call3, %if.end28 ]
  call void @kfree(i8* %call.i)
  br label %cleanup

cleanup:                                          ; preds = %out, %entry
  %retval.0 = phi i32 [ %rv.1, %out ], [ -12, %entry ]
  ret i32 %retval.0
}

declare %struct.platform_device* @platform_device_alloc(i8*, i32) #1

declare i32 @platform_device_add(%struct.platform_device*) #1

declare i32 @ipmi_register_smi(%struct.ipmi_smi_handlers*, i8*, %struct.ipmi_device_id*, %struct.device*, i8*, i8 zeroext) #1

declare i32 @dev_err(%struct.device*, i8*, ...) #1

declare i32 @ipmi_smi_add_proc_entry(%struct.ipmi_smi*, i8*, %struct.file_operations*, i8*) #1

declare i32 @_dev_info(%struct.device*, i8*, ...) #1

declare void @synchronize_sched() #1

declare i64 @seq_lseek(%struct.file*, i64, i32) #1

declare i64 @seq_read(%struct.file*, i8*, i64, i64*) #1

; Function Attrs: nounwind uwtable
define internal i32 @smi_params_proc_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %call1 = call i32 @single_open(%struct.file* %file, i32 (%struct.seq_file*, i8*)* @smi_params_proc_show, i8* %call)
  ret i32 %call1
}

declare i32 @single_release(%struct.inode*, %struct.file*) #1

declare i8* @PDE_DATA(%struct.inode*) #1

; Function Attrs: nounwind uwtable
define internal i32 @smi_params_proc_show(%struct.seq_file* %m, i8* %v) #0 {
entry:
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 10
  %0 = load i8*, i8** %private, align 8, !tbaa !88
  %1 = bitcast i8* %0 to %struct.smi_info*
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 4
  %2 = load i32, i32* %si_type, align 8, !tbaa !19
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @si_to_str, i64 0, i64 %idxprom
  %3 = load i8*, i8** %arrayidx, align 8, !tbaa !7
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %addr_type = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 6
  %4 = load i32, i32* %addr_type, align 4, !tbaa !21
  %idxprom1 = sext i32 %4 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8*], [2 x i8*]* @addr_space_to_str, i64 0, i64 %idxprom1
  %5 = load i8*, i8** %arrayidx2, align 8, !tbaa !7
  %io3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io3, i32 0, i32 7
  %6 = load i64, i64* %addr_data, align 8, !tbaa !20
  %io4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io4, i32 0, i32 3
  %7 = load i32, i32* %regspacing, align 8, !tbaa !24
  %io5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io5, i32 0, i32 4
  %8 = load i32, i32* %regsize, align 4, !tbaa !25
  %io6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io6, i32 0, i32 5
  %9 = load i32, i32* %regshift, align 8, !tbaa !26
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 26
  %10 = load i32, i32* %irq, align 4, !tbaa !27
  %slave_addr = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 35
  %11 = load i8, i8* %slave_addr, align 4, !tbaa !29
  %conv = zext i8 %11 to i32
  %call = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.78, i32 0, i32 0), i8* %3, i8* %5, i64 %6, i32 %7, i32 %8, i32 %9, i32 %10, i32 %conv)
  ret i32 %call
}

declare i32 @single_open(%struct.file*, i32 (%struct.seq_file*, i8*)*, i8*) #1

declare i32 @seq_printf(%struct.seq_file*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @smi_si_stats_proc_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %call1 = call i32 @single_open(%struct.file* %file, i32 (%struct.seq_file*, i8*)* @smi_si_stats_proc_show, i8* %call)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @smi_si_stats_proc_show(%struct.seq_file* %m, i8* %v) #0 {
entry:
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 10
  %0 = load i8*, i8** %private, align 8, !tbaa !88
  %1 = bitcast i8* %0 to %struct.smi_info*
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 26
  %2 = load i32, i32* %irq, align 4, !tbaa !27
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 30
  %3 = load i32, i32* %interrupt_disabled, align 4, !tbaa !49
  %tobool1 = icmp ne i32 %3, 0
  %lnot = xor i1 %tobool1, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  %call = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.66, i32 0, i32 0), i32 %land.ext)
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats, i64 0, i64 0
  %call2 = call i32 @atomic_read(%union.anon.1* %arrayidx)
  %call3 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.67, i32 0, i32 0), i32 %call2)
  %stats4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx5 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats4, i64 0, i64 1
  %call6 = call i32 @atomic_read(%union.anon.1* %arrayidx5)
  %call7 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.68, i32 0, i32 0), i32 %call6)
  %stats8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx9 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats8, i64 0, i64 2
  %call10 = call i32 @atomic_read(%union.anon.1* %arrayidx9)
  %call11 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.69, i32 0, i32 0), i32 %call10)
  %stats12 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx13 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats12, i64 0, i64 3
  %call14 = call i32 @atomic_read(%union.anon.1* %arrayidx13)
  %call15 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.70, i32 0, i32 0), i32 %call14)
  %stats16 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx17 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats16, i64 0, i64 4
  %call18 = call i32 @atomic_read(%union.anon.1* %arrayidx17)
  %call19 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.71, i32 0, i32 0), i32 %call18)
  %stats20 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx21 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats20, i64 0, i64 5
  %call22 = call i32 @atomic_read(%union.anon.1* %arrayidx21)
  %call23 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.72, i32 0, i32 0), i32 %call22)
  %stats24 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx25 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats24, i64 0, i64 6
  %call26 = call i32 @atomic_read(%union.anon.1* %arrayidx25)
  %call27 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.73, i32 0, i32 0), i32 %call26)
  %stats28 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx29 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats28, i64 0, i64 7
  %call30 = call i32 @atomic_read(%union.anon.1* %arrayidx29)
  %call31 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.74, i32 0, i32 0), i32 %call30)
  %stats32 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx33 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats32, i64 0, i64 8
  %call34 = call i32 @atomic_read(%union.anon.1* %arrayidx33)
  %call35 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.75, i32 0, i32 0), i32 %call34)
  %stats36 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx37 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats36, i64 0, i64 9
  %call38 = call i32 @atomic_read(%union.anon.1* %arrayidx37)
  %call39 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.76, i32 0, i32 0), i32 %call38)
  %stats40 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 36
  %arrayidx41 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats40, i64 0, i64 10
  %call42 = call i32 @atomic_read(%union.anon.1* %arrayidx41)
  %call43 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.77, i32 0, i32 0), i32 %call42)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @smi_type_proc_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %call1 = call i32 @single_open(%struct.file* %file, i32 (%struct.seq_file*, i8*)* @smi_type_proc_show, i8* %call)
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @smi_type_proc_show(%struct.seq_file* %m, i8* %v) #0 {
entry:
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %m, i32 0, i32 10
  %0 = load i8*, i8** %private, align 8, !tbaa !88
  %1 = bitcast i8* %0 to %struct.smi_info*
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 4
  %2 = load i32, i32* %si_type, align 8, !tbaa !19
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [3 x i8*], [3 x i8*]* @si_to_str, i64 0, i64 %idxprom
  %3 = load i8*, i8** %arrayidx, align 8, !tbaa !7
  %call = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %m, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.43.136, i32 0, i32 0), i8* %3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @smi_start_processing(i8* %send_info, %struct.ipmi_smi* %intf) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %intf1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 1
  store %struct.ipmi_smi* %intf, %struct.ipmi_smi** %intf1, align 8, !tbaa !40
  %irq_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 13
  %1 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %irq_setup, align 8, !tbaa !28
  %tobool = icmp ne i32 (%struct.smi_info*)* %1, null
  br i1 %tobool, label %if.then, label %do.body3

if.then:                                          ; preds = %entry
  %irq_setup2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 13
  %2 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %irq_setup2, align 8, !tbaa !28
  %call = call i32 %2(%struct.smi_info* %0)
  br label %do.body3

do.body3:                                         ; preds = %if.then, %entry
  %si_timer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 27
  call void @init_timer_key(%struct.timer_list* %si_timer, i32 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.62, i32 0, i32 0), %struct.lock_class_key* @smi_start_processing.__key)
  %si_timer4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 27
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %si_timer4, i32 0, i32 3
  store void (i64)* @smi_timeout, void (i64)** %function, align 8, !tbaa !90
  %3 = ptrtoint %struct.smi_info* %0 to i64
  %si_timer5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 27
  %data = getelementptr inbounds %struct.timer_list, %struct.timer_list* %si_timer5, i32 0, i32 4
  store i64 %3, i64* %data, align 8, !tbaa !91
  %4 = load volatile i64, i64* @jiffies, align 8, !tbaa !76
  %last_timeout_jiffies = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 28
  store i64 %4, i64* %last_timeout_jiffies, align 8, !tbaa !92
  %si_timer8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 27
  %5 = load volatile i64, i64* @jiffies, align 8, !tbaa !76
  %add = add i64 %5, 2
  %call9 = call i32 @mod_timer(%struct.timer_list* %si_timer8, i64 %add)
  %intf_num = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 0
  %6 = load i32, i32* %intf_num, align 8, !tbaa !50
  %7 = load i32, i32* @num_force_kipmid, align 4, !tbaa !2
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %if.then10, label %if.else

if.then10:                                        ; preds = %do.body3
  %intf_num11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 0
  %8 = load i32, i32* %intf_num11, align 8, !tbaa !50
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @force_kipmid, i64 0, i64 %idxprom
  %9 = load i32, i32* %arrayidx, align 4, !tbaa !2
  br label %if.end16

if.else:                                          ; preds = %do.body3
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 4
  %10 = load i32, i32* %si_type, align 8, !tbaa !19
  %cmp12 = icmp ne i32 %10, 2
  br i1 %cmp12, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.else
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 26
  %11 = load i32, i32* %irq, align 4, !tbaa !27
  %tobool13 = icmp ne i32 %11, 0
  %. = select i1 %tobool13, i32 0, i32 1
  br label %if.end16

if.end16:                                         ; preds = %land.lhs.true, %if.else, %if.then10
  %enable.1 = phi i32 [ %9, %if.then10 ], [ 0, %if.else ], [ %., %land.lhs.true ]
  %tobool17 = icmp ne i32 %enable.1, 0
  br i1 %tobool17, label %if.then18, label %if.end35

if.then18:                                        ; preds = %if.end16
  %12 = bitcast %struct.smi_info* %0 to i8*
  %intf_num19 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 0
  %13 = load i32, i32* %intf_num19, align 8, !tbaa !50
  %call20 = call %struct.task_struct* (i32 (i8*)*, i8*, i32, i8*, ...) @kthread_create_on_node(i32 (i8*)* @ipmi_thread, i8* %12, i32 -1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.63, i32 0, i32 0), i32 %13)
  %14 = bitcast %struct.task_struct* %call20 to i8*
  %call21 = call i64 @IS_ERR(i8* %14)
  %tobool22 = icmp ne i64 %call21, 0
  br i1 %tobool22, label %if.end25, label %if.then23

if.then23:                                        ; preds = %if.then18
  %call24 = call i32 @wake_up_process(%struct.task_struct* %call20)
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.then18
  %thread = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 37
  store %struct.task_struct* %call20, %struct.task_struct** %thread, align 8, !tbaa !75
  %thread26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 37
  %15 = load %struct.task_struct*, %struct.task_struct** %thread26, align 8, !tbaa !75
  %16 = bitcast %struct.task_struct* %15 to i8*
  %call27 = call i64 @IS_ERR(i8* %16)
  %tobool28 = icmp ne i64 %call27, 0
  br i1 %tobool28, label %if.then29, label %if.end35

if.then29:                                        ; preds = %if.end25
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 32
  %17 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !53
  %thread30 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 37
  %18 = load %struct.task_struct*, %struct.task_struct** %thread30, align 8, !tbaa !75
  %19 = bitcast %struct.task_struct* %18 to i8*
  %call31 = call i64 @PTR_ERR(i8* %19)
  %call32 = call i32 (%struct.device*, i8*, ...) @dev_notice(%struct.device* %17, i8* getelementptr inbounds ([90 x i8], [90 x i8]* @.str.64, i32 0, i32 0), i64 %call31)
  %thread33 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 37
  store %struct.task_struct* null, %struct.task_struct** %thread33, align 8, !tbaa !75
  br label %if.end35

if.end35:                                         ; preds = %if.then29, %if.end25, %if.end16
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_smi_info(i8* %send_info, %struct.ipmi_smi_info* %data) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 16
  %1 = load i32, i32* %addr_source, align 4, !tbaa !9
  %addr_src = getelementptr inbounds %struct.ipmi_smi_info, %struct.ipmi_smi_info* %data, i32 0, i32 0
  store i32 %1, i32* %addr_src, align 8, !tbaa !93
  %dev = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 32
  %2 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !53
  %dev1 = getelementptr inbounds %struct.ipmi_smi_info, %struct.ipmi_smi_info* %data, i32 0, i32 1
  store %struct.device* %2, %struct.device** %dev1, align 8, !tbaa !95
  %addr_info = getelementptr inbounds %struct.ipmi_smi_info, %struct.ipmi_smi_info* %data, i32 0, i32 2
  %addr_info2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 39
  %3 = bitcast %union.ipmi_smi_info_union* %addr_info to i8*
  %4 = bitcast %union.ipmi_smi_info_union* %addr_info2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 8, i32 8, i1 false), !tbaa.struct !96
  %dev3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 32
  %5 = load %struct.device*, %struct.device** %dev3, align 8, !tbaa !53
  %call = call %struct.device* @get_device(%struct.device* %5)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @sender(i8* %send_info, %struct.ipmi_smi_msg* %msg, i32 %priority) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %stop_operation = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 29
  %call = call i32 @atomic_read(%union.anon.1* %stop_operation)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %msg, i32 0, i32 4
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %data, i64 0, i64 0
  %1 = load i8, i8* %arrayidx, align 4, !tbaa !6
  %conv = zext i8 %1 to i32
  %or = or i32 %conv, 4
  %conv1 = trunc i32 %or to i8
  %rsp = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %msg, i32 0, i32 6
  %arrayidx2 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp, i64 0, i64 0
  store i8 %conv1, i8* %arrayidx2, align 8, !tbaa !6
  %data3 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %msg, i32 0, i32 4
  %arrayidx4 = getelementptr inbounds [272 x i8], [272 x i8]* %data3, i64 0, i64 1
  %2 = load i8, i8* %arrayidx4, align 1, !tbaa !6
  %rsp5 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %msg, i32 0, i32 6
  %arrayidx6 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp5, i64 0, i64 1
  store i8 %2, i8* %arrayidx6, align 1, !tbaa !6
  %rsp7 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %msg, i32 0, i32 6
  %arrayidx8 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp7, i64 0, i64 2
  store i8 -1, i8* %arrayidx8, align 2, !tbaa !6
  %rsp_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %msg, i32 0, i32 5
  store i32 3, i32* %rsp_size, align 4, !tbaa !82
  call void @deliver_recv_msg(%struct.smi_info* %0, %struct.ipmi_smi_msg* %msg)
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %run_to_completion = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 23
  %3 = load i32, i32* %run_to_completion, align 8, !tbaa !48
  %tobool9 = icmp ne i32 %3, 0
  br i1 %tobool9, label %if.then10, label %do.body15

if.then10:                                        ; preds = %if.end
  %link = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %msg, i32 0, i32 0
  %xmit_msgs = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 6
  call void @list_add_tail(%struct.list_head* %link, %struct.list_head* %xmit_msgs)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then10
  %.sink = phi i32 [ 250, %while.body ], [ 0, %if.then10 ]
  %call13 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 %.sink)
  %cmp = icmp ne i32 %call13, 4
  br i1 %cmp, label %while.body, label %cleanup.cont

while.body:                                       ; preds = %while.cond
  call void @__const_udelay(i64 1073750)
  br label %while.cond

do.body15:                                        ; preds = %if.end
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %4 to %struct.raw_spinlock*
  %call19 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %cmp22 = icmp sgt i32 %priority, 0
  %link25 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %msg, i32 0, i32 0
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %do.body15
  %hp_xmit_msgs = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 7
  call void @list_add_tail(%struct.list_head* %link25, %struct.list_head* %hp_xmit_msgs)
  br label %if.end28

if.else:                                          ; preds = %do.body15
  %xmit_msgs27 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 6
  call void @list_add_tail(%struct.list_head* %link25, %struct.list_head* %xmit_msgs27)
  br label %if.end28

if.end28:                                         ; preds = %if.else, %if.then24
  %si_state = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 9
  %5 = load i32, i32* %si_state, align 8, !tbaa !52
  %cmp29 = icmp eq i32 %5, 0
  br i1 %cmp29, label %land.lhs.true, label %if.end42

land.lhs.true:                                    ; preds = %if.end28
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 8
  %6 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !47
  %cmp31 = icmp eq %struct.ipmi_smi_msg* %6, null
  br i1 %cmp31, label %if.then33, label %if.end42

if.then33:                                        ; preds = %land.lhs.true
  %7 = load volatile i64, i64* @jiffies, align 8, !tbaa !76
  %last_timeout_jiffies = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 28
  store i64 %7, i64* %last_timeout_jiffies, align 8, !tbaa !92
  %si_timer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 27
  %8 = load volatile i64, i64* @jiffies, align 8, !tbaa !76
  %add = add i64 %8, 2
  %call34 = call i32 @mod_timer(%struct.timer_list* %si_timer, i64 %add)
  %thread = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 37
  %9 = load %struct.task_struct*, %struct.task_struct** %thread, align 8, !tbaa !75
  %tobool35 = icmp ne %struct.task_struct* %9, null
  br i1 %tobool35, label %if.then36, label %if.end39

if.then36:                                        ; preds = %if.then33
  %thread37 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 37
  %10 = load %struct.task_struct*, %struct.task_struct** %thread37, align 8, !tbaa !75
  %call38 = call i32 @wake_up_process(%struct.task_struct* %10)
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %if.then33
  %call40 = call i32 @start_next_msg(%struct.smi_info* %0)
  %call41 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 0)
  br label %if.end42

if.end42:                                         ; preds = %if.end39, %land.lhs.true, %if.end28
  %si_lock43 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock43, i64 %call19)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end42, %while.cond, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @request_events(i8* %send_info) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %stop_operation = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 29
  %call = call i32 @atomic_read(%union.anon.1* %stop_operation)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %has_event_buffer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 21
  %1 = load i8, i8* %has_event_buffer, align 1, !tbaa !51
  %tobool1 = icmp ne i8 %1, 0
  br i1 %tobool1, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %lor.lhs.false
  %req_events = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 22
  call void @atomic_set(%union.anon.1* %req_events, i32 1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_run_to_completion(i8* %send_info, i32 %i_run_to_completion) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %run_to_completion = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 23
  store i32 %i_run_to_completion, i32* %run_to_completion, align 8, !tbaa !48
  %tobool = icmp ne i32 %i_run_to_completion, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %.sink = phi i32 [ 250, %while.body ], [ 0, %if.then ]
  %call1 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 %.sink)
  %cmp = icmp ne i32 %call1, 4
  br i1 %cmp, label %while.body, label %if.end

while.body:                                       ; preds = %while.cond
  call void @__const_udelay(i64 1073750)
  br label %while.cond

if.end:                                           ; preds = %while.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_maintenance_mode(i8* %send_info, i32 %enable) #0 {
entry:
  %0 = bitcast i8* %send_info to %struct.smi_info*
  %tobool = icmp ne i32 %enable, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %req_events = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 22
  call void @atomic_set(%union.anon.1* %req_events, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !87
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

declare i32 @wake_up_process(%struct.task_struct*) #1

declare void @__list_add(%struct.list_head*, %struct.list_head*, %struct.list_head*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

declare %struct.device* @get_device(%struct.device*) #1

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #1

; Function Attrs: nounwind uwtable
define internal void @smi_timeout(i64 %data) #0 {
entry:
  %0 = inttoptr i64 %data to %struct.smi_info*
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %1 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !76
  %last_timeout_jiffies = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 28
  %3 = load i64, i64* %last_timeout_jiffies, align 8, !tbaa !92
  %sub = sub nsw i64 %2, %3
  %mul = mul nsw i64 %sub, 4000
  %conv5 = trunc i64 %mul to i32
  %call6 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 %conv5)
  %si_lock7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock7, i64 %call2)
  %last_timeout_jiffies8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 28
  store i64 %2, i64* %last_timeout_jiffies8, align 8, !tbaa !92
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 26
  %4 = load i32, i32* %irq, align 4, !tbaa !27
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %interrupt_disabled = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 30
  %5 = load i32, i32* %interrupt_disabled, align 4, !tbaa !49
  %tobool9 = icmp ne i32 %5, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %6 = load volatile i64, i64* @jiffies, align 8, !tbaa !76
  %add = add i64 %6, 2
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 36
  %arrayidx = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats, i64 0, i64 1
  call void @atomic_inc(%union.anon.1* %arrayidx)
  br label %do_mod_timer

if.end:                                           ; preds = %land.lhs.true, %entry
  %cmp10 = icmp eq i32 %call6, 1
  %stats13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 36
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %arrayidx14 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats13, i64 0, i64 0
  call void @atomic_inc(%union.anon.1* %arrayidx14)
  br label %if.end19

if.else:                                          ; preds = %if.end
  %arrayidx17 = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats13, i64 0, i64 1
  call void @atomic_inc(%union.anon.1* %arrayidx17)
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then12
  %.sink1 = phi i64 [ 2, %if.else ], [ 1, %if.then12 ]
  %7 = load volatile i64, i64* @jiffies, align 8, !tbaa !76
  %add18 = add i64 %7, %.sink1
  br label %do_mod_timer

do_mod_timer:                                     ; preds = %if.end19, %if.then
  %timeout.1 = phi i64 [ %add18, %if.end19 ], [ %add, %if.then ]
  %cmp20 = icmp ne i32 %call6, 4
  br i1 %cmp20, label %if.then22, label %if.end24

if.then22:                                        ; preds = %do_mod_timer
  %si_timer = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 27
  %call23 = call i32 @mod_timer(%struct.timer_list* %si_timer, i64 %timeout.1)
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %do_mod_timer
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_thread(i8* %data) #0 {
entry:
  %busy_until = alloca %struct.load_weight, align 8
  %0 = bitcast i8* %data to %struct.smi_info*
  call void @ipmi_si_set_not_busy(%struct.load_weight* %busy_until)
  %1 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !97
  call void @set_user_nice(%struct.task_struct* %1, i64 19)
  br label %while.cond

while.cond:                                       ; preds = %if.end23, %entry
  %call1 = call zeroext i1 @kthread_should_stop()
  %lnot = xor i1 %call1, true
  br i1 %lnot, label %do.body2, label %while.end

do.body2:                                         ; preds = %while.cond
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  %call4 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %call7 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 0)
  %si_lock8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock8, i64 %call4)
  %call9 = call i32 @ipmi_thread_busy_wait(i32 %call7, %struct.smi_info* %0, %struct.load_weight* %busy_until)
  switch i32 %call7, label %if.else20 [
    i32 0, label %if.end23
    i32 1, label %land.lhs.true
    i32 4, label %if.then18
  ]

land.lhs.true:                                    ; preds = %do.body2
  %tobool = icmp ne i32 %call9, 0
  br i1 %tobool, label %if.then14, label %if.else15

if.then14:                                        ; preds = %land.lhs.true
  call void @schedule()
  br label %if.end23

if.else15:                                        ; preds = %land.lhs.true
  %cmp16 = icmp eq i32 %call7, 4
  br i1 %cmp16, label %if.then18, label %if.else20

if.then18:                                        ; preds = %if.else15, %do.body2
  %call19 = call i64 @schedule_timeout_interruptible(i64 100)
  br label %if.end23

if.else20:                                        ; preds = %if.else15, %do.body2
  %call21 = call i64 @schedule_timeout_interruptible(i64 1)
  br label %if.end23

if.end23:                                         ; preds = %if.else20, %if.then18, %if.then14, %do.body2
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret i32 0
}

declare %struct.task_struct* @kthread_create_on_node(i32 (i8*)*, i8*, i32, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare i32 @dev_notice(%struct.device*, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @ipmi_si_set_not_busy(%struct.load_weight* %ts) #3 {
entry:
  %tv_nsec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %ts, i32 0, i32 1
  store i64 -1, i64* %tv_nsec, align 8, !tbaa !98
  ret void
}

declare void @set_user_nice(%struct.task_struct*, i64) #1

declare zeroext i1 @kthread_should_stop() #1

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_thread_busy_wait(i32 %smi_result, %struct.smi_info* %smi_info, %struct.load_weight* %busy_until) #0 {
entry:
  %dividend.addr.i = alloca i64, align 8
  %ns.addr.i = alloca i64, align 8
  %now = alloca %struct.load_weight, align 8
  %intf_num = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 0
  %0 = load i32, i32* %intf_num, align 8, !tbaa !50
  %1 = load i32, i32* @num_max_busy_us, align 4, !tbaa !2
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %intf_num1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 0
  %2 = load i32, i32* %intf_num1, align 8, !tbaa !50
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* @kipmid_max_busy_us, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !2
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %max_busy_us.0 = phi i32 [ %3, %if.then ], [ 0, %entry ]
  %cmp2 = icmp eq i32 %max_busy_us.0, 0
  %cmp3 = icmp ne i32 %smi_result, 1
  %or.cond = or i1 %cmp2, %cmp3
  br i1 %or.cond, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  call void @ipmi_si_set_not_busy(%struct.load_weight* %busy_until)
  br label %cleanup17

if.else:                                          ; preds = %if.end
  %call = call i32 @ipmi_si_is_busy(%struct.load_weight* %busy_until)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else6, label %if.then5

if.then5:                                         ; preds = %if.else
  call void @getnstimeofday(%struct.load_weight* %busy_until)
  %conv = zext i32 %max_busy_us.0 to i64
  %mul = mul nsw i64 %conv, 1000
  store i64 %mul, i64* %ns.addr.i, align 8, !tbaa !100
  %tv_nsec.i = getelementptr inbounds %struct.load_weight, %struct.load_weight* %busy_until, i32 0, i32 1
  %4 = load i64, i64* %tv_nsec.i, align 8, !tbaa !98
  %5 = load i64, i64* %ns.addr.i, align 8, !tbaa !100
  %add.i = add i64 %4, %5
  store i64 %add.i, i64* %dividend.addr.i, align 8, !tbaa !100
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %if.then5
  %ret.0.i = phi i32 [ 0, %if.then5 ], [ %inc.i, %while.body.i ]
  %6 = load i64, i64* %dividend.addr.i, align 8, !tbaa !100
  %cmp.i = icmp uge i64 %6, 1000000000
  %7 = load i64, i64* %dividend.addr.i, align 8, !tbaa !100
  br i1 %cmp.i, label %while.body.i, label %__iter_div_u64_rem.exit

while.body.i:                                     ; preds = %while.cond.i
  call void asm "", "=*rm,0,~{dirflag},~{fpsr},~{flags}"(i64* %dividend.addr.i, i64 %7) #5, !srcloc !101
  %8 = load i64, i64* %dividend.addr.i, align 8, !tbaa !100
  %sub.i = sub i64 %8, 1000000000
  store i64 %sub.i, i64* %dividend.addr.i, align 8, !tbaa !100
  %inc.i = add i32 %ret.0.i, 1
  br label %while.cond.i

__iter_div_u64_rem.exit:                          ; preds = %while.cond.i
  store i64 %7, i64* %ns.addr.i, align 8, !tbaa !100
  %conv.i = zext i32 %ret.0.i to i64
  %tv_sec.i = getelementptr inbounds %struct.load_weight, %struct.load_weight* %busy_until, i32 0, i32 0
  %9 = load i64, i64* %tv_sec.i, align 8, !tbaa !102
  %add1.i = add nsw i64 %9, %conv.i
  store i64 %add1.i, i64* %tv_sec.i, align 8, !tbaa !102
  %10 = load i64, i64* %ns.addr.i, align 8, !tbaa !100
  %tv_nsec2.i = getelementptr inbounds %struct.load_weight, %struct.load_weight* %busy_until, i32 0, i32 1
  store i64 %10, i64* %tv_nsec2.i, align 8, !tbaa !98
  br label %cleanup17

if.else6:                                         ; preds = %if.else
  call void @getnstimeofday(%struct.load_weight* %now)
  %call7 = call i32 @timespec_compare(%struct.load_weight* %now, %struct.load_weight* %busy_until)
  %cmp8 = icmp sgt i32 %call7, 0
  %lnot = xor i1 %cmp8, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %cleanup

if.then13:                                        ; preds = %if.else6
  call void @ipmi_si_set_not_busy(%struct.load_weight* %busy_until)
  br label %cleanup

cleanup:                                          ; preds = %if.then13, %if.else6
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then13 ], [ 0, %if.else6 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  %. = select i1 %SwitchLeaf, i32 1, i32 0
  ret i32 %.

cleanup17:                                        ; preds = %__iter_div_u64_rem.exit, %if.then4
  ret i32 1
}

declare void @schedule() #1

declare i64 @schedule_timeout_interruptible(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ipmi_si_is_busy(%struct.load_weight* %ts) #3 {
entry:
  %tv_nsec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %ts, i32 0, i32 1
  %0 = load i64, i64* %tv_nsec, align 8, !tbaa !98
  %cmp = icmp ne i64 %0, -1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare void @getnstimeofday(%struct.load_weight*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @timespec_compare(%struct.load_weight* %lhs, %struct.load_weight* %rhs) #3 {
entry:
  %tv_sec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %lhs, i32 0, i32 0
  %0 = load i64, i64* %tv_sec, align 8, !tbaa !102
  %tv_sec1 = getelementptr inbounds %struct.load_weight, %struct.load_weight* %rhs, i32 0, i32 0
  %1 = load i64, i64* %tv_sec1, align 8, !tbaa !102
  %cmp = icmp slt i64 %0, %1
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tv_sec2 = getelementptr inbounds %struct.load_weight, %struct.load_weight* %lhs, i32 0, i32 0
  %2 = load i64, i64* %tv_sec2, align 8, !tbaa !102
  %tv_sec3 = getelementptr inbounds %struct.load_weight, %struct.load_weight* %rhs, i32 0, i32 0
  %3 = load i64, i64* %tv_sec3, align 8, !tbaa !102
  %cmp4 = icmp sgt i64 %2, %3
  br i1 %cmp4, label %return, label %if.end6

if.end6:                                          ; preds = %if.end
  %tv_nsec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %lhs, i32 0, i32 1
  %4 = load i64, i64* %tv_nsec, align 8, !tbaa !98
  %tv_nsec7 = getelementptr inbounds %struct.load_weight, %struct.load_weight* %rhs, i32 0, i32 1
  %5 = load i64, i64* %tv_nsec7, align 8, !tbaa !98
  %sub = sub nsw i64 %4, %5
  %conv = trunc i64 %sub to i32
  br label %return

return:                                           ; preds = %if.end6, %if.end, %entry
  %retval.0 = phi i32 [ %conv, %if.end6 ], [ -1, %entry ], [ 1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_probe(%struct.platform_device* %dev) #0 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_remove(%struct.platform_device* %dev) #0 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @wait_for_msg_done(%struct.smi_info* %smi_info) #0 {
entry:
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %0 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  %event = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %0, i32 0, i32 4
  %1 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event, align 8, !tbaa !78
  %si_sm = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %2 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm, align 8, !tbaa !41
  %call = call i32 %1(%struct.si_sm_data* %2, i64 0)
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %smi_result.0 = phi i32 [ %call, %entry ], [ %smi_result.1, %if.end14 ]
  switch i32 %smi_result.0, label %if.end17 [
    i32 1, label %if.then
    i32 2, label %if.then
    i32 0, label %if.then8
    i32 5, label %cleanup
  ]

if.then:                                          ; preds = %for.cond, %for.cond
  %call2 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %handlers3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %3 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers3, align 8, !tbaa !42
  %event4 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %3, i32 0, i32 4
  %4 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event4, align 8, !tbaa !78
  %si_sm5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %5 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm5, align 8, !tbaa !41
  %call6 = call i32 %4(%struct.si_sm_data* %5, i64 100)
  br label %if.end14

if.then8:                                         ; preds = %for.cond
  %handlers9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 3
  %6 = load %struct.si_sm_handlers*, %struct.si_sm_handlers** %handlers9, align 8, !tbaa !42
  %event10 = getelementptr inbounds %struct.si_sm_handlers, %struct.si_sm_handlers* %6, i32 0, i32 4
  %7 = load i32 (%struct.si_sm_data*, i64)*, i32 (%struct.si_sm_data*, i64)** %event10, align 8, !tbaa !78
  %si_sm11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 2
  %8 = load %struct.si_sm_data*, %struct.si_sm_data** %si_sm11, align 8, !tbaa !41
  %call12 = call i32 %7(%struct.si_sm_data* %8, i64 0)
  br label %if.end14

if.end14:                                         ; preds = %if.then8, %if.then
  %smi_result.1 = phi i32 [ %call6, %if.then ], [ %call12, %if.then8 ]
  br label %for.cond

if.end17:                                         ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %for.cond
  %retval.0 = phi i32 [ 0, %if.end17 ], [ -19, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @setup_dell_poweredge_bt_xaction_handler(%struct.smi_info* %smi_info) #0 {
entry:
  %device_id = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 31
  %manufacturer_id = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 6
  %0 = load i32, i32* %manufacturer_id, align 4, !tbaa !103
  %cmp = icmp eq i32 %0, 674
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 4
  %1 = load i32, i32* %si_type, align 8, !tbaa !19
  %cmp1 = icmp eq i32 %1, 2
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @register_xaction_notifier(%struct.notifier_block* @dell_poweredge_bt_xaction_notifier)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @register_xaction_notifier(%struct.notifier_block* %nb) #0 {
entry:
  %call = call i32 @atomic_notifier_chain_register(%struct.atomic_notifier_head* @xaction_notifier_list, %struct.notifier_block* %nb)
  ret void
}

declare i32 @atomic_notifier_chain_register(%struct.atomic_notifier_head*, %struct.notifier_block*) #1

; Function Attrs: nounwind uwtable
define internal i32 @dell_poweredge_bt_xaction_handler(%struct.notifier_block* %self, i64 %unused, i8* %in) #0 {
entry:
  %0 = bitcast i8* %in to %struct.smi_info*
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 8
  %1 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !47
  %data1 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %1, i32 0, i32 4
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %data1, i32 0, i32 0
  %curr_msg2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 8
  %2 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg2, align 8, !tbaa !47
  %data_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %2, i32 0, i32 3
  %3 = load i32, i32* %data_size, align 8, !tbaa !79
  %cmp = icmp uge i32 %3, 8
  br i1 %cmp, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %entry
  %arrayidx = getelementptr inbounds i8, i8* %arraydecay, i64 0
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv = zext i8 %4 to i32
  %shr = ashr i32 %conv, 2
  %cmp3 = icmp eq i32 %shr, 10
  br i1 %cmp3, label %land.lhs.true5, label %cleanup

land.lhs.true5:                                   ; preds = %land.lhs.true
  %arrayidx6 = getelementptr inbounds i8, i8* %arraydecay, i64 1
  %5 = load i8, i8* %arrayidx6, align 1, !tbaa !6
  %conv7 = zext i8 %5 to i32
  %cmp8 = icmp eq i32 %conv7, 35
  br i1 %cmp8, label %land.lhs.true10, label %cleanup

land.lhs.true10:                                  ; preds = %land.lhs.true5
  %arrayidx11 = getelementptr inbounds i8, i8* %arraydecay, i64 7
  %6 = load i8, i8* %arrayidx11, align 1, !tbaa !6
  %conv12 = zext i8 %6 to i32
  %cmp13 = icmp eq i32 %conv12, 58
  br i1 %cmp13, label %if.then, label %cleanup

if.then:                                          ; preds = %land.lhs.true10
  call void @return_hosed_msg_badsize(%struct.smi_info* %0)
  br label %cleanup

cleanup:                                          ; preds = %if.then, %land.lhs.true10, %land.lhs.true5, %land.lhs.true, %entry
  %retval.0 = phi i32 [ 32769, %if.then ], [ 0, %land.lhs.true10 ], [ 0, %land.lhs.true5 ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @return_hosed_msg_badsize(%struct.smi_info* %smi_info) #0 {
entry:
  %curr_msg = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  %0 = load %struct.ipmi_smi_msg*, %struct.ipmi_smi_msg** %curr_msg, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 4
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %data, i64 0, i64 0
  %1 = load i8, i8* %arrayidx, align 4, !tbaa !6
  %conv = zext i8 %1 to i32
  %or = or i32 %conv, 4
  %conv1 = trunc i32 %or to i8
  %rsp = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx2 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp, i64 0, i64 0
  store i8 %conv1, i8* %arrayidx2, align 8, !tbaa !6
  %data3 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 4
  %arrayidx4 = getelementptr inbounds [272 x i8], [272 x i8]* %data3, i64 0, i64 1
  %2 = load i8, i8* %arrayidx4, align 1, !tbaa !6
  %rsp5 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx6 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp5, i64 0, i64 1
  store i8 %2, i8* %arrayidx6, align 1, !tbaa !6
  %rsp7 = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 6
  %arrayidx8 = getelementptr inbounds [272 x i8], [272 x i8]* %rsp7, i64 0, i64 2
  store i8 -54, i8* %arrayidx8, align 2, !tbaa !6
  %rsp_size = getelementptr inbounds %struct.ipmi_smi_msg, %struct.ipmi_smi_msg* %0, i32 0, i32 5
  store i32 3, i32* %rsp_size, align 4, !tbaa !82
  %curr_msg9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 8
  store %struct.ipmi_smi_msg* null, %struct.ipmi_smi_msg** %curr_msg9, align 8, !tbaa !47
  call void @deliver_recv_msg(%struct.smi_info* %smi_info, %struct.ipmi_smi_msg* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @setup_dell_poweredge_oem_data_handler(%struct.smi_info* %smi_info) #0 {
entry:
  %device_id = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 31
  %manufacturer_id = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 6
  %0 = load i32, i32* %manufacturer_id, align 4, !tbaa !103
  %cmp = icmp eq i32 %0, 674
  br i1 %cmp, label %if.then, label %if.end29

if.then:                                          ; preds = %entry
  %device_id1 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 0
  %1 = load i8, i8* %device_id1, align 4, !tbaa !104
  %conv = zext i8 %1 to i32
  %cmp2 = icmp eq i32 %conv, 32
  br i1 %cmp2, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %device_revision = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 1
  %2 = load i8, i8* %device_revision, align 1, !tbaa !105
  %conv4 = zext i8 %2 to i32
  %cmp5 = icmp eq i32 %conv4, 128
  br i1 %cmp5, label %land.lhs.true7, label %if.else

land.lhs.true7:                                   ; preds = %land.lhs.true
  %ipmi_version = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 4
  %3 = load i8, i8* %ipmi_version, align 4, !tbaa !106
  %conv8 = zext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 81
  br i1 %cmp9, label %if.then11, label %if.else

if.then11:                                        ; preds = %land.lhs.true7
  %oem_data_avail_handler = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  store i32 (%struct.smi_info*)* @oem_data_avail_to_receive_msg_avail, i32 (%struct.smi_info*)** %oem_data_avail_handler, align 8, !tbaa !86
  br label %if.end29

if.else:                                          ; preds = %land.lhs.true7, %land.lhs.true, %if.then
  %ipmi_version12 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 4
  %4 = load i8, i8* %ipmi_version12, align 4, !tbaa !106
  %conv13 = zext i8 %4 to i32
  %and = and i32 %conv13, 15
  %cmp14 = icmp slt i32 %and, 1
  br i1 %cmp14, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %ipmi_version16 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 4
  %5 = load i8, i8* %ipmi_version16, align 4, !tbaa !106
  %conv17 = zext i8 %5 to i32
  %and18 = and i32 %conv17, 15
  %cmp19 = icmp eq i32 %and18, 1
  br i1 %cmp19, label %land.lhs.true21, label %if.end29

land.lhs.true21:                                  ; preds = %lor.lhs.false
  %ipmi_version22 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %device_id, i32 0, i32 4
  %6 = load i8, i8* %ipmi_version22, align 4, !tbaa !106
  %conv23 = zext i8 %6 to i32
  %shr = ashr i32 %conv23, 4
  %cmp24 = icmp slt i32 %shr, 5
  br i1 %cmp24, label %if.then26, label %if.end29

if.then26:                                        ; preds = %land.lhs.true21, %if.else
  %oem_data_avail_handler27 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 19
  store i32 (%struct.smi_info*)* @oem_data_avail_to_receive_msg_avail, i32 (%struct.smi_info*)** %oem_data_avail_handler27, align 8, !tbaa !86
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %land.lhs.true21, %lor.lhs.false, %if.then11, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @oem_data_avail_to_receive_msg_avail(%struct.smi_info* %smi_info) #0 {
entry:
  %msg_flags = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 20
  %0 = load i8, i8* %msg_flags, align 8, !tbaa !83
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, -225
  %or = or i32 %and, 1
  %conv1 = trunc i32 %or to i8
  %msg_flags2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %smi_info, i32 0, i32 20
  store i8 %conv1, i8* %msg_flags2, align 8, !tbaa !83
  ret i32 1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ipmi_demangle_device_id(i8* %data, i32 %data_len, %struct.ipmi_device_id* %id) #3 {
entry:
  %cmp = icmp ult i32 %data_len, 9
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 0
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %conv = zext i8 %0 to i32
  %cmp1 = icmp ne i32 %conv, 28
  br i1 %cmp1, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %arrayidx3 = getelementptr inbounds i8, i8* %data, i64 1
  %1 = load i8, i8* %arrayidx3, align 1, !tbaa !6
  %conv4 = zext i8 %1 to i32
  %cmp5 = icmp ne i32 %conv4, 1
  br i1 %cmp5, label %return, label %if.end8

if.end8:                                          ; preds = %lor.lhs.false
  %arrayidx9 = getelementptr inbounds i8, i8* %data, i64 2
  %2 = load i8, i8* %arrayidx9, align 1, !tbaa !6
  %conv10 = zext i8 %2 to i32
  %cmp11 = icmp ne i32 %conv10, 0
  br i1 %cmp11, label %return, label %if.end14

if.end14:                                         ; preds = %if.end8
  %add.ptr = getelementptr inbounds i8, i8* %data, i64 3
  %sub = sub i32 %data_len, 3
  %arrayidx15 = getelementptr inbounds i8, i8* %add.ptr, i64 0
  %3 = load i8, i8* %arrayidx15, align 1, !tbaa !6
  %device_id = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 0
  store i8 %3, i8* %device_id, align 4, !tbaa !104
  %arrayidx16 = getelementptr inbounds i8, i8* %add.ptr, i64 1
  %4 = load i8, i8* %arrayidx16, align 1, !tbaa !6
  %device_revision = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 1
  store i8 %4, i8* %device_revision, align 1, !tbaa !105
  %arrayidx17 = getelementptr inbounds i8, i8* %add.ptr, i64 2
  %5 = load i8, i8* %arrayidx17, align 1, !tbaa !6
  %firmware_revision_1 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 2
  store i8 %5, i8* %firmware_revision_1, align 2, !tbaa !107
  %arrayidx18 = getelementptr inbounds i8, i8* %add.ptr, i64 3
  %6 = load i8, i8* %arrayidx18, align 1, !tbaa !6
  %firmware_revision_2 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 3
  store i8 %6, i8* %firmware_revision_2, align 1, !tbaa !108
  %arrayidx19 = getelementptr inbounds i8, i8* %add.ptr, i64 4
  %7 = load i8, i8* %arrayidx19, align 1, !tbaa !6
  %ipmi_version = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 4
  store i8 %7, i8* %ipmi_version, align 4, !tbaa !106
  %arrayidx20 = getelementptr inbounds i8, i8* %add.ptr, i64 5
  %8 = load i8, i8* %arrayidx20, align 1, !tbaa !6
  %additional_device_support = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 5
  store i8 %8, i8* %additional_device_support, align 1, !tbaa !109
  %cmp21 = icmp uge i32 %sub, 11
  br i1 %cmp21, label %if.then23, label %if.else

if.then23:                                        ; preds = %if.end14
  %arrayidx24 = getelementptr inbounds i8, i8* %add.ptr, i64 6
  %9 = load i8, i8* %arrayidx24, align 1, !tbaa !6
  %conv25 = zext i8 %9 to i32
  %arrayidx26 = getelementptr inbounds i8, i8* %add.ptr, i64 7
  %10 = load i8, i8* %arrayidx26, align 1, !tbaa !6
  %conv27 = zext i8 %10 to i32
  %shl = shl i32 %conv27, 8
  %or = or i32 %conv25, %shl
  %arrayidx28 = getelementptr inbounds i8, i8* %add.ptr, i64 8
  %11 = load i8, i8* %arrayidx28, align 1, !tbaa !6
  %conv29 = zext i8 %11 to i32
  %shl30 = shl i32 %conv29, 16
  %or31 = or i32 %or, %shl30
  %manufacturer_id = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 6
  store i32 %or31, i32* %manufacturer_id, align 4, !tbaa !103
  %arrayidx32 = getelementptr inbounds i8, i8* %add.ptr, i64 9
  %12 = load i8, i8* %arrayidx32, align 1, !tbaa !6
  %conv33 = zext i8 %12 to i32
  %arrayidx34 = getelementptr inbounds i8, i8* %add.ptr, i64 10
  %13 = load i8, i8* %arrayidx34, align 1, !tbaa !6
  %conv35 = zext i8 %13 to i32
  %shl36 = shl i32 %conv35, 8
  %or37 = or i32 %conv33, %shl36
  br label %if.end40

if.else:                                          ; preds = %if.end14
  %manufacturer_id38 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 6
  store i32 0, i32* %manufacturer_id38, align 4, !tbaa !103
  br label %if.end40

if.end40:                                         ; preds = %if.else, %if.then23
  %.sink = phi i32 [ 0, %if.else ], [ %or37, %if.then23 ]
  %product_id39 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 7
  store i32 %.sink, i32* %product_id39, align 4, !tbaa !110
  %cmp41 = icmp uge i32 %sub, 15
  br i1 %cmp41, label %if.then43, label %if.else53

if.then43:                                        ; preds = %if.end40
  %cmp44 = icmp uge i64 4, 64
  %aux_firmware_revision = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 8
  %arraydecay = getelementptr inbounds [4 x i8], [4 x i8]* %aux_firmware_revision, i32 0, i32 0
  %add.ptr47 = getelementptr inbounds i8, i8* %add.ptr, i64 11
  br i1 %cmp44, label %if.then46, label %if.else48

if.then46:                                        ; preds = %if.then43
  %call = call i8* @__memcpy(i8* %arraydecay, i8* %add.ptr47, i64 4)
  br label %if.end52

if.else48:                                        ; preds = %if.then43
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %add.ptr47, i64 4, i32 1, i1 false)
  br label %if.end52

if.end52:                                         ; preds = %if.else48, %if.then46
  %aux_firmware_revision_set = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 9
  %bf.load = load i8, i8* %aux_firmware_revision_set, align 4
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %aux_firmware_revision_set, align 4
  br label %return

if.else53:                                        ; preds = %if.end40
  %aux_firmware_revision_set54 = getelementptr inbounds %struct.ipmi_device_id, %struct.ipmi_device_id* %id, i32 0, i32 9
  %bf.load55 = load i8, i8* %aux_firmware_revision_set54, align 4
  %bf.clear56 = and i8 %bf.load55, -2
  store i8 %bf.clear56, i8* %aux_firmware_revision_set54, align 4
  br label %return

return:                                           ; preds = %if.else53, %if.end52, %if.end8, %lor.lhs.false, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -22, %lor.lhs.false ], [ -22, %if.end ], [ -22, %if.end8 ], [ 0, %if.else53 ], [ 0, %if.end52 ]
  ret i32 %retval.0
}

declare i8* @__memcpy(i8*, i8*, i64) #1

declare i8* @__kmalloc(i64, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @is_new_interface(%struct.smi_info* %info) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @smi_infos, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !7
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %1, i64 -544
  %2 = bitcast i8* %add.ptr13 to %struct.smi_info*
  %link = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 38
  %cmp = icmp ne %struct.list_head* %link, @smi_infos
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 10
  %addr_type = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 6
  %3 = load i32, i32* %addr_type, align 4, !tbaa !21
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %addr_type2 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 6
  %4 = load i32, i32* %addr_type2, align 4, !tbaa !21
  %cmp3 = icmp ne i32 %3, %4
  br i1 %cmp3, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %io4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io4, i32 0, i32 7
  %5 = load i64, i64* %addr_data, align 8, !tbaa !20
  %io5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %addr_data6 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io5, i32 0, i32 7
  %6 = load i64, i64* %addr_data6, align 8, !tbaa !20
  %cmp7 = icmp eq i64 %5, %6
  br i1 %cmp7, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %link11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 38
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %link11, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %if.end, %for.cond
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @si_bt_irq_handler(i32 %irq, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.smi_info*
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !37
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  call void %1(%struct.si_sm_io* %io1, i32 2, i8 zeroext 3)
  %call = call i32 @si_irq_handler(i32 %irq, i8* %data)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #3 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @si_irq_handler(i32 %irq, i8* %data) #0 {
entry:
  %0 = bitcast i8* %data to %struct.smi_info*
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %1 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 36
  %arrayidx = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats, i64 0, i64 3
  call void @atomic_inc(%union.anon.1* %arrayidx)
  %call5 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 0)
  %si_lock6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock6, i64 %call2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @std_irq_cleanup(%struct.smi_info* %info) #0 {
entry:
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 4
  %0 = load i32, i32* %si_type, align 8, !tbaa !19
  %cmp = icmp eq i32 %0, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !37
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  call void %1(%struct.si_sm_io* %io1, i32 2, i8 zeroext 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 26
  %2 = load i32, i32* %irq, align 4, !tbaa !27
  %3 = bitcast %struct.smi_info* %info to i8*
  call void @free_irq(i32 %2, i8* %3)
  ret void
}

declare void @free_irq(i32, i8*) #1

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @port_cleanup(%struct.smi_info* %info) #0 {
entry:
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !20
  %conv = trunc i64 %0 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %idx.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 15
  %1 = load i32, i32* %io_size, align 8, !tbaa !38
  %cmp = icmp ult i32 %idx.0, %1
  br i1 %cmp, label %for.body, label %if.end

for.body:                                         ; preds = %for.cond
  %io2 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io2, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !24
  %mul = mul nsw i32 %idx.0, %2
  %add = add i32 %conv, %mul
  %conv3 = zext i32 %add to i64
  %io4 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io4, i32 0, i32 4
  %3 = load i32, i32* %regsize, align 4, !tbaa !25
  %conv5 = sext i32 %3 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv3, i64 %conv5)
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @port_inw(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !111
  %conv = trunc i64 %0 to i32
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %1
  %add = add i32 %conv, %mul
  %call = call zeroext i16 @inw(i32 %add)
  %conv1 = zext i16 %call to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %2 = load i32, i32* %regshift, align 8, !tbaa !113
  %shr = ashr i32 %conv1, %2
  %and = and i32 %shr, 255
  %conv2 = trunc i32 %and to i8
  ret i8 %conv2
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @port_inl(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !111
  %conv = trunc i64 %0 to i32
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %1
  %add = add i32 %conv, %mul
  %call = call i32 @inl(i32 %add)
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %2 = load i32, i32* %regshift, align 8, !tbaa !113
  %shr = lshr i32 %call, %2
  %and = and i32 %shr, 255
  %conv1 = trunc i32 %and to i8
  ret i8 %conv1
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @port_inb(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !111
  %conv = trunc i64 %0 to i32
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %1
  %add = add i32 %conv, %mul
  %call = call zeroext i8 @inb(i32 %add)
  ret i8 %call
}

; Function Attrs: nounwind uwtable
define internal void @port_outw(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !111
  %conv = trunc i64 %0 to i32
  %conv1 = zext i8 %b to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %1 = load i32, i32* %regshift, align 8, !tbaa !113
  %shl = shl i32 %conv1, %1
  %conv2 = trunc i32 %shl to i16
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %2
  %add = add i32 %conv, %mul
  call void @outw(i16 zeroext %conv2, i32 %add)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @port_outl(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !111
  %conv = trunc i64 %0 to i32
  %conv1 = zext i8 %b to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %1 = load i32, i32* %regshift, align 8, !tbaa !113
  %shl = shl i32 %conv1, %1
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %2
  %add = add i32 %conv, %mul
  call void @outl(i32 %shl, i32 %add)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @port_outb(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !111
  %conv = trunc i64 %0 to i32
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %1
  %add = add i32 %conv, %mul
  call void @outb(i8 zeroext %b, i32 %add)
  ret void
}

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #1

declare void @__release_region(%struct.resource*, i64, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #3 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #5, !srcloc !114
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outl(i32 %value, i32 %port) #3 {
entry:
  call void asm sideeffect "outl $0, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %value, i32 %port) #5, !srcloc !115
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outw(i16 zeroext %value, i32 %port) #3 {
entry:
  call void asm sideeffect "outw ${0:w}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i16 %value, i32 %port) #5, !srcloc !116
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #3 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #5, !srcloc !117
  ret i8 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @inl(i32 %port) #3 {
entry:
  %0 = call i32 asm sideeffect "inl ${1:w}, $0", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #5, !srcloc !118
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @inw(i32 %port) #3 {
entry:
  %0 = call i16 asm sideeffect "inw ${1:w}, ${0:w}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #5, !srcloc !119
  ret i16 %0
}

; Function Attrs: nounwind uwtable
define internal void @mem_cleanup(%struct.smi_info* %info) #0 {
entry:
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  %0 = load i64, i64* %addr_data, align 8, !tbaa !20
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %addr2 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 2
  %1 = load i8*, i8** %addr2, align 8, !tbaa !23
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %io3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %addr4 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io3, i32 0, i32 2
  %2 = load i8*, i8** %addr4, align 8, !tbaa !23
  call void @iounmap(i8* %2)
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 15
  %3 = load i32, i32* %io_size, align 8, !tbaa !38
  %io5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io5, i32 0, i32 3
  %4 = load i32, i32* %regspacing, align 8, !tbaa !24
  %mul = mul i32 %3, %4
  %io6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regspacing7 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io6, i32 0, i32 3
  %5 = load i32, i32* %regspacing7, align 8, !tbaa !24
  %io8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io8, i32 0, i32 4
  %6 = load i32, i32* %regsize, align 4, !tbaa !25
  %sub = sub nsw i32 %5, %6
  %sub9 = sub i32 %mul, %sub
  %conv = sext i32 %sub9 to i64
  call void @__release_region(%struct.resource* @iomem_resource, i64 %0, i64 %conv)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @intf_mem_inw(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !120
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call zeroext i16 @readw(i8* %add.ptr)
  %conv = zext i16 %call to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %2 = load i32, i32* %regshift, align 8, !tbaa !113
  %shr = ashr i32 %conv, %2
  %and = and i32 %shr, 255
  %conv1 = trunc i32 %and to i8
  ret i8 %conv1
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @intf_mem_inl(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !120
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i32 @readl(i8* %add.ptr)
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %2 = load i32, i32* %regshift, align 8, !tbaa !113
  %shr = lshr i32 %call, %2
  %and = and i32 %shr, 255
  %conv = trunc i32 %and to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @mem_inq(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !120
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i64 @readq(i8* %add.ptr)
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %2 = load i32, i32* %regshift, align 8, !tbaa !113
  %sh_prom = zext i32 %2 to i64
  %shr = lshr i64 %call, %sh_prom
  %and = and i64 %shr, 255
  %conv = trunc i64 %and to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @intf_mem_inb(%struct.si_sm_io* %io, i32 %offset) #0 {
entry:
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !120
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call zeroext i8 @readb(i8* %add.ptr)
  ret i8 %call
}

; Function Attrs: nounwind uwtable
define internal void @intf_mem_outw(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %conv = zext i8 %b to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %0 = load i32, i32* %regshift, align 8, !tbaa !113
  %shl = shl i32 %conv, %0
  %conv1 = trunc i32 %shl to i8
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %1 = load i8*, i8** %addr, align 8, !tbaa !120
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %2
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %1, i64 %idx.ext
  call void @writeb(i8 zeroext %conv1, i8* %add.ptr)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @intf_mem_outl(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %conv = zext i8 %b to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %0 = load i32, i32* %regshift, align 8, !tbaa !113
  %shl = shl i32 %conv, %0
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %1 = load i8*, i8** %addr, align 8, !tbaa !120
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %2
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %1, i64 %idx.ext
  call void @writel(i32 %shl, i8* %add.ptr)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mem_outq(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %conv = zext i8 %b to i32
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 5
  %0 = load i32, i32* %regshift, align 8, !tbaa !113
  %shl = shl i32 %conv, %0
  %conv1 = sext i32 %shl to i64
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %1 = load i8*, i8** %addr, align 8, !tbaa !120
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %2 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %2
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %1, i64 %idx.ext
  call void @writeq(i64 %conv1, i8* %add.ptr)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @intf_mem_outb(%struct.si_sm_io* %io, i32 %offset, i8 zeroext %b) #0 {
entry:
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !120
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 3
  %1 = load i32, i32* %regspacing, align 8, !tbaa !112
  %mul = mul i32 %offset, %1
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  call void @writeb(i8 zeroext %b, i8* %add.ptr)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ioremap(i64 %offset, i64 %size) #3 {
entry:
  %call = call i8* @ioremap_nocache(i64 %offset, i64 %size)
  ret i8* %call
}

declare i8* @ioremap_nocache(i64, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @writeb(i8 zeroext %val, i8* %addr) #3 {
entry:
  call void asm sideeffect "movb $0,$1", "q,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i8 %val, i8* %addr) #5, !srcloc !121
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @writeq(i64 %val, i8* %addr) #3 {
entry:
  %0 = bitcast i8* %addr to i64*
  call void asm sideeffect "movq $0,$1", "r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64 %val, i64* %0) #5, !srcloc !122
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @writel(i32 %val, i8* %addr) #3 {
entry:
  %0 = bitcast i8* %addr to i32*
  call void asm sideeffect "movl $0,$1", "r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 %val, i32* %0) #5, !srcloc !123
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @readb(i8* %addr) #3 {
entry:
  %0 = call i8 asm sideeffect "movb $1,$0", "=q,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i8* %addr) #5, !srcloc !124
  ret i8 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @readq(i8* %addr) #3 {
entry:
  %0 = bitcast i8* %addr to i64*
  %1 = call i64 asm sideeffect "movq $1,$0", "=r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %0) #5, !srcloc !125
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @readl(i8* %addr) #3 {
entry:
  %0 = bitcast i8* %addr to i32*
  %1 = call i32 asm sideeffect "movl $1,$0", "=r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %0) #5, !srcloc !126
  ret i32 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @readw(i8* %addr) #3 {
entry:
  %0 = bitcast i8* %addr to i16*
  %1 = call i16 asm sideeffect "movw $1,$0", "=r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i16* %0) #5, !srcloc !127
  ret i16 %1
}

declare void @iounmap(i8*) #1

; Function Attrs: inlinehint nounwind uwtable
declare i8* @kzalloc(i64, i32) #3

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #1

declare i32 @strcmp(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @init_ipmi_si() #0 {
entry:
  %0 = load i32, i32* @initialized, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  store i32 1, i32* @initialized, align 4, !tbaa !2
  %1 = load i8, i8* @si_tryplatform, align 1, !tbaa !128, !range !129
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %call = call i32 @platform_driver_register(%struct.platform_driver* @ipmi_driver)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.then2
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end7:                                          ; preds = %if.then2, %if.end
  %3 = load i8, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @si_type_str, i32 0, i32 0), align 1, !tbaa !6
  %conv = sext i8 %3 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then9, label %if.end19

if.then9:                                         ; preds = %if.end7
  br label %for.cond

for.cond:                                         ; preds = %if.then17, %if.then9
  %str.0 = phi i8* [ getelementptr inbounds ([30 x i8], [30 x i8]* @si_type_str, i32 0, i32 0), %if.then9 ], [ %incdec.ptr, %if.then17 ]
  %i.0 = phi i32 [ 0, %if.then9 ], [ %inc, %if.then17 ]
  %cmp10 = icmp slt i32 %i.0, 4
  br i1 %cmp10, label %land.rhs, label %if.end19

land.rhs:                                         ; preds = %for.cond
  %4 = load i8, i8* %str.0, align 1, !tbaa !6
  %conv12 = sext i8 %4 to i32
  %cmp13 = icmp ne i32 %conv12, 0
  br i1 %cmp13, label %for.body, label %if.end19

for.body:                                         ; preds = %land.rhs
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x i8*], [4 x i8*]* @si_type, i64 0, i64 %idxprom
  store i8* %str.0, i8** %arrayidx, align 8, !tbaa !7
  %call15 = call i8* @strchr(i8* %str.0, i32 44)
  %tobool16 = icmp ne i8* %call15, null
  br i1 %tobool16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %for.body
  store i8 0, i8* %call15, align 1, !tbaa !6
  %incdec.ptr = getelementptr inbounds i8, i8* %call15, i32 1
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end19:                                         ; preds = %for.body, %land.rhs, %for.cond, %if.end7
  %5 = call i32 (i8*, ...) @printk(i8* null)
  %call21 = call i32 @hardcode_find_bmc()
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.end24, label %cleanup

if.end24:                                         ; preds = %if.end19
  %6 = load i8, i8* @si_trypci, align 1, !tbaa !128, !range !129
  %tobool25 = trunc i8 %6 to i1
  br i1 %tobool25, label %if.then26, label %if.end33

if.then26:                                        ; preds = %if.end24
  %call27 = call i32 @__pci_register_driver(%struct.pci_driver* @ipmi_pci_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0))
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.then29, label %if.else31

if.then29:                                        ; preds = %if.then26
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end33

if.else31:                                        ; preds = %if.then26
  store i32 1, i32* @pci_registered, align 4, !tbaa !2
  br label %if.end33

if.end33:                                         ; preds = %if.else31, %if.then29, %if.end24
  %8 = load i8, i8* @si_tryacpi, align 1, !tbaa !128, !range !129
  %tobool34 = trunc i8 %8 to i1
  br i1 %tobool34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end33
  %call36 = call i32 @pnp_register_driver(%struct.pnp_driver* @ipmi_pnp_driver)
  store i32 1, i32* @pnp_registered, align 4, !tbaa !2
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end33
  %9 = load i8, i8* @si_trydmi, align 1, !tbaa !128, !range !129
  %tobool38 = trunc i8 %9 to i1
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end37
  call void @dmi_find_bmc()
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %if.end37
  %10 = load i8, i8* @si_tryacpi, align 1, !tbaa !128, !range !129
  %tobool41 = trunc i8 %10 to i1
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end40
  call void @spmi_find_bmc()
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.end40
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc59, %if.end43
  %next.sink = phi %struct.list_head** [ %next, %for.inc59 ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @smi_infos, i32 0, i32 0), %if.end43 ]
  %type.0 = phi i32 [ 0, %if.end43 ], [ %type.2, %for.inc59 ]
  %11 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !7
  %12 = bitcast %struct.list_head* %11 to i8*
  %add.ptr63 = getelementptr inbounds i8, i8* %12, i64 -544
  %13 = bitcast i8* %add.ptr63 to %struct.smi_info*
  %link = getelementptr inbounds %struct.smi_info, %struct.smi_info* %13, i32 0, i32 38
  %cmp45 = icmp ne %struct.list_head* %link, @smi_infos
  br i1 %cmp45, label %for.body47, label %for.end64

for.body47:                                       ; preds = %for.cond44
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %13, i32 0, i32 26
  %14 = load i32, i32* %irq, align 4, !tbaa !27
  %tobool48 = icmp ne i32 %14, 0
  br i1 %tobool48, label %land.lhs.true, label %for.inc59

land.lhs.true:                                    ; preds = %for.body47
  %tobool49 = icmp ne i32 %type.0, 0
  br i1 %tobool49, label %lor.lhs.false, label %if.then52

lor.lhs.false:                                    ; preds = %land.lhs.true
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %13, i32 0, i32 16
  %15 = load i32, i32* %addr_source, align 4, !tbaa !9
  %cmp50 = icmp eq i32 %15, %type.0
  br i1 %cmp50, label %if.then52, label %for.inc59

if.then52:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %call53 = call i32 @try_smi_init(%struct.smi_info* %13)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %for.inc59, label %if.then55

if.then55:                                        ; preds = %if.then52
  %addr_source56 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %13, i32 0, i32 16
  %16 = load i32, i32* %addr_source56, align 4, !tbaa !9
  br label %for.inc59

for.inc59:                                        ; preds = %if.then55, %if.then52, %lor.lhs.false, %for.body47
  %type.2 = phi i32 [ %type.0, %lor.lhs.false ], [ %type.0, %for.body47 ], [ %type.0, %if.then52 ], [ %16, %if.then55 ]
  %link61 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %13, i32 0, i32 38
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %link61, i32 0, i32 0
  br label %for.cond44

for.end64:                                        ; preds = %for.cond44
  %tobool65 = icmp ne i32 %type.0, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %for.end64
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  br label %cleanup

if.end67:                                         ; preds = %for.end64
  br label %for.cond71

for.cond71:                                       ; preds = %for.inc91, %if.end67
  %next94.sink = phi %struct.list_head** [ %next94, %for.inc91 ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @smi_infos, i32 0, i32 0), %if.end67 ]
  %type.3 = phi i32 [ %type.0, %if.end67 ], [ %type.5, %for.inc91 ]
  %17 = load %struct.list_head*, %struct.list_head** %next94.sink, align 8, !tbaa !7
  %18 = bitcast %struct.list_head* %17 to i8*
  %add.ptr96 = getelementptr inbounds i8, i8* %18, i64 -544
  %19 = bitcast i8* %add.ptr96 to %struct.smi_info*
  %link72 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %19, i32 0, i32 38
  %cmp73 = icmp ne %struct.list_head* %link72, @smi_infos
  br i1 %cmp73, label %for.body75, label %for.end97

for.body75:                                       ; preds = %for.cond71
  %irq76 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %19, i32 0, i32 26
  %20 = load i32, i32* %irq76, align 4, !tbaa !27
  %tobool77 = icmp ne i32 %20, 0
  br i1 %tobool77, label %for.inc91, label %land.lhs.true78

land.lhs.true78:                                  ; preds = %for.body75
  %tobool79 = icmp ne i32 %type.3, 0
  br i1 %tobool79, label %lor.lhs.false80, label %if.then84

lor.lhs.false80:                                  ; preds = %land.lhs.true78
  %addr_source81 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %19, i32 0, i32 16
  %21 = load i32, i32* %addr_source81, align 4, !tbaa !9
  %cmp82 = icmp eq i32 %21, %type.3
  br i1 %cmp82, label %if.then84, label %for.inc91

if.then84:                                        ; preds = %lor.lhs.false80, %land.lhs.true78
  %call85 = call i32 @try_smi_init(%struct.smi_info* %19)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %for.inc91, label %if.then87

if.then87:                                        ; preds = %if.then84
  %addr_source88 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %19, i32 0, i32 16
  %22 = load i32, i32* %addr_source88, align 4, !tbaa !9
  br label %for.inc91

for.inc91:                                        ; preds = %if.then87, %if.then84, %lor.lhs.false80, %for.body75
  %type.5 = phi i32 [ %type.3, %for.body75 ], [ %type.3, %lor.lhs.false80 ], [ %type.3, %if.then84 ], [ %22, %if.then87 ]
  %link93 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %19, i32 0, i32 38
  %next94 = getelementptr inbounds %struct.list_head, %struct.list_head* %link93, i32 0, i32 0
  br label %for.cond71

for.end97:                                        ; preds = %for.cond71
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  %tobool98 = icmp ne i32 %type.3, 0
  br i1 %tobool98, label %cleanup, label %if.end100

if.end100:                                        ; preds = %for.end97
  %23 = load i8, i8* @si_trydefaults, align 1, !tbaa !128, !range !129
  %tobool101 = trunc i8 %23 to i1
  br i1 %tobool101, label %if.then102, label %if.end108

if.then102:                                       ; preds = %if.end100
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  %call103 = call i32 @list_empty(%struct.list_head* @smi_infos)
  %tobool104 = icmp ne i32 %call103, 0
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  br i1 %tobool104, label %if.then105, label %if.end108

if.then105:                                       ; preds = %if.then102
  call void @default_find_bmc()
  br label %if.end108

if.end108:                                        ; preds = %if.then105, %if.then102, %if.end100
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  %24 = load i32, i32* @unload_when_empty, align 4, !tbaa !2
  %tobool109 = icmp ne i32 %24, 0
  br i1 %tobool109, label %land.lhs.true110, label %if.else115

land.lhs.true110:                                 ; preds = %if.end108
  %call111 = call i32 @list_empty(%struct.list_head* @smi_infos)
  %tobool112 = icmp ne i32 %call111, 0
  br i1 %tobool112, label %if.then113, label %if.else115

if.then113:                                       ; preds = %land.lhs.true110
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  call void @cleanup_ipmi_si()
  %25 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.else115:                                       ; preds = %land.lhs.true110, %if.end108
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  br label %cleanup

cleanup:                                          ; preds = %if.else115, %if.then113, %for.end97, %if.then66, %if.end19, %if.then4, %entry
  %retval.0 = phi i32 [ %call, %if.then4 ], [ 0, %if.then66 ], [ -19, %if.then113 ], [ 0, %if.else115 ], [ 0, %entry ], [ 0, %if.end19 ], [ 0, %for.end97 ]
  ret i32 %retval.0
}

declare i32 @platform_driver_register(%struct.platform_driver*) #1

; Function Attrs: nounwind uwtable
define internal i32 @hardcode_find_bmc() #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  br label %if.end

if.end:                                           ; preds = %for.cond
  %call.i = call i8* @kzalloc(i64 568, i32 208) #5
  %0 = bitcast i8* %call.i to %struct.smi_info*
  br label %if.end79

if.end79:                                         ; preds = %if.end
  %idxprom83 = sext i32 %i.0 to i64
  %arrayidx84 = getelementptr inbounds [4 x i32], [4 x i32]* @irqs, i64 0, i64 %idxprom83
  %1 = load i32, i32* %arrayidx84, align 4, !tbaa !2
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 26
  store i32 %1, i32* %irq, align 4, !tbaa !27
  br label %for.inc

for.inc:                                          ; preds = %if.end79
  %inc = add nsw i32 %i.0, 1
  br label %for.cond
}

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) #1

declare i32 @pnp_register_driver(%struct.pnp_driver*) #1

; Function Attrs: nounwind uwtable
define internal void @dmi_find_bmc() #0 {
entry:
  %data = alloca %struct.dmi_ipmi_data, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %dev.0 = phi %struct.dmi_device* [ null, %entry ], [ %call, %if.end ]
  %call = call %struct.dmi_device* @dmi_find_device(i32 -1, i8* null, %struct.dmi_device* %dev.0)
  %tobool = icmp ne %struct.dmi_device* %call, null
  %0 = bitcast %struct.dmi_ipmi_data* %data to i8*
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 24, i32 8, i1 false)
  %device_data = getelementptr inbounds %struct.dmi_device, %struct.dmi_device* %call, i32 0, i32 3
  %1 = load i8*, i8** %device_data, align 8, !tbaa !130
  %2 = bitcast i8* %1 to %struct.dmi_header*
  %call1 = call i32 @decode_dmi(%struct.dmi_header* %2, %struct.dmi_ipmi_data* %data)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  call void @try_init_dmi(%struct.dmi_ipmi_data* %data)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @spmi_find_bmc() #0 {
entry:
  %spmi = alloca %struct.SPMITable*, align 8
  %0 = load i32, i32* @acpi_disabled, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  %1 = load i32, i32* @acpi_failure, align 4
  %tobool1 = icmp ne i32 %1, 0
  %or.cond = or i1 %tobool, %tobool1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end5, %if.end3
  %i.0 = phi i32 [ 0, %if.end3 ], [ %inc, %if.end5 ]
  %add = add nsw i32 %i.0, 1
  %2 = bitcast %struct.SPMITable** %spmi to %struct.acpi_table_header**
  %call = call i32 @acpi_get_table(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0), i32 %add, %struct.acpi_table_header** %2)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %for.cond
  %3 = load %struct.SPMITable*, %struct.SPMITable** %spmi, align 8, !tbaa !7
  call void @try_init_spmi(%struct.SPMITable* %3)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @default_find_bmc() #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.exception_table_entry], [4 x %struct.exception_table_entry]* @ipmi_defaults, i64 0, i64 %idxprom
  %port = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx, i32 0, i32 1
  %0 = load i32, i32* %port, align 4, !tbaa !132
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %for.cond
  %call.i = call i8* @kzalloc(i64 568, i32 208) #5
  %1 = bitcast i8* %call.i to %struct.smi_info*
  %tobool.i = icmp ne %struct.smi_info* %1, null
  br i1 %tobool.i, label %do.body.i, label %smi_info_alloc.exit

do.body.i:                                        ; preds = %if.end
  %si_lock3.i = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 5
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock3.i, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock.i, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.21, i32 0, i32 0), %struct.lock_class_key* @smi_info_alloc.__key) #5
  br label %smi_info_alloc.exit

smi_info_alloc.exit:                              ; preds = %do.body.i, %if.end
  %tobool1 = icmp ne %struct.smi_info* %1, null
  br i1 %tobool1, label %if.end3, label %cleanup.cont

if.end3:                                          ; preds = %smi_info_alloc.exit
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 16
  store i32 8, i32* %addr_source, align 4, !tbaa !9
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds [4 x %struct.exception_table_entry], [4 x %struct.exception_table_entry]* @ipmi_defaults, i64 0, i64 %idxprom4
  %type = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx5, i32 0, i32 0
  %3 = load i32, i32* %type, align 8, !tbaa !134
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 4
  store i32 %3, i32* %si_type, align 8, !tbaa !19
  %io_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 11
  store i32 (%struct.smi_info*)* @port_setup, i32 (%struct.smi_info*)** %io_setup, align 8, !tbaa !22
  %idxprom6 = sext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [4 x %struct.exception_table_entry], [4 x %struct.exception_table_entry]* @ipmi_defaults, i64 0, i64 %idxprom6
  %port8 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %arrayidx7, i32 0, i32 1
  %4 = load i32, i32* %port8, align 4, !tbaa !132
  %conv = sext i32 %4 to i64
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 7
  store i64 %conv, i64* %addr_data, align 8, !tbaa !20
  %io9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %addr_type = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io9, i32 0, i32 6
  store i32 0, i32* %addr_type, align 4, !tbaa !21
  %io10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %addr = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io10, i32 0, i32 2
  store i8* null, i8** %addr, align 8, !tbaa !23
  %io11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io11, i32 0, i32 3
  store i32 1, i32* %regspacing, align 8, !tbaa !24
  %io12 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io12, i32 0, i32 4
  store i32 1, i32* %regsize, align 4, !tbaa !25
  %io13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io13, i32 0, i32 5
  store i32 0, i32* %regshift, align 8, !tbaa !26
  %call14 = call i32 @add_smi(%struct.smi_info* %1)
  %cmp = icmp eq i32 %call14, 0
  br i1 %cmp, label %if.then16, label %if.else32

if.then16:                                        ; preds = %if.end3
  %call17 = call i32 @try_smi_init(%struct.smi_info* %1)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.then16
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %for.inc

if.else:                                          ; preds = %if.then16
  call void @cleanup_one_si(%struct.smi_info* %1)
  br label %for.inc

if.else32:                                        ; preds = %if.end3
  %6 = bitcast %struct.smi_info* %1 to i8*
  call void @kfree(i8* %6)
  br label %for.inc

for.inc:                                          ; preds = %if.else32, %if.else, %if.then20
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup.cont:                                     ; preds = %smi_info_alloc.exit, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cleanup_ipmi_si() #0 {
entry:
  %0 = load i32, i32* @initialized, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %1 = load i32, i32* @pci_registered, align 4, !tbaa !2
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void @pci_unregister_driver(%struct.pci_driver* @ipmi_pci_driver)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %2 = load i32, i32* @pnp_registered, align 4, !tbaa !2
  %tobool4 = icmp ne i32 %2, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  call void @pnp_unregister_driver(%struct.pnp_driver* @ipmi_pnp_driver)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  call void @platform_driver_unregister(%struct.platform_driver* @ipmi_driver)
  call void @mutex_lock_nested(%struct.mutex* @smi_infos_lock, i32 0)
  %3 = load %struct.list_head*, %struct.list_head** getelementptr inbounds (%struct.list_head, %struct.list_head* @smi_infos, i32 0, i32 0), align 8, !tbaa !30
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 -544
  %5 = bitcast i8* %add.ptr to %struct.smi_info*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end6
  %.sink = phi %struct.smi_info* [ %8, %for.body ], [ %5, %if.end6 ]
  %e.0 = phi %struct.smi_info* [ %5, %if.end6 ], [ %8, %for.body ]
  %link12 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %.sink, i32 0, i32 38
  %next13 = getelementptr inbounds %struct.list_head, %struct.list_head* %link12, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next13, align 8, !tbaa !31
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr15 = getelementptr inbounds i8, i8* %7, i64 -544
  %8 = bitcast i8* %add.ptr15 to %struct.smi_info*
  %link10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %e.0, i32 0, i32 38
  %cmp = icmp ne %struct.list_head* %link10, @smi_infos
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @cleanup_one_si(%struct.smi_info* %e.0)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @smi_infos_lock)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %entry
  ret void
}

declare void @pci_unregister_driver(%struct.pci_driver*) #1

declare void @pnp_unregister_driver(%struct.pnp_driver*) #1

declare void @platform_driver_unregister(%struct.platform_driver*) #1

declare i32 @acpi_get_table(i8*, i32, %struct.acpi_table_header**) #1

; Function Attrs: nounwind uwtable
define internal void @try_init_spmi(%struct.SPMITable* %spmi) #0 {
entry:
  %IPMIlegacy = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 10
  %0 = load i8, i8* %IPMIlegacy, align 1, !tbaa !135
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call.i = call i8* @kzalloc(i64 568, i32 208) #5
  %2 = bitcast i8* %call.i to %struct.smi_info*
  %tobool.i = icmp ne %struct.smi_info* %2, null
  br i1 %tobool.i, label %do.body.i, label %smi_info_alloc.exit

do.body.i:                                        ; preds = %if.end
  %si_lock3.i = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 5
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock3.i, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %3 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock.i, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.21, i32 0, i32 0), %struct.lock_class_key* @smi_info_alloc.__key) #5
  br label %smi_info_alloc.exit

smi_info_alloc.exit:                              ; preds = %do.body.i, %if.end
  %tobool = icmp ne %struct.smi_info* %2, null
  br i1 %tobool, label %if.end7, label %if.then5

if.then5:                                         ; preds = %smi_info_alloc.exit
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end7:                                          ; preds = %smi_info_alloc.exit
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 16
  store i32 3, i32* %addr_source, align 4, !tbaa !9
  %5 = call i32 (i8*, ...) @printk(i8* null)
  %InterfaceType = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 9
  %6 = load i8, i8* %InterfaceType, align 4, !tbaa !139
  %conv9 = zext i8 %6 to i32
  %Pivot4 = icmp slt i32 %conv9, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end7
  %Pivot = icmp slt i32 %conv9, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv9, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end7
  %SwitchLeaf = icmp eq i32 %conv9, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %7 = call i32 (i8*, ...) @printk(i8* null)
  %8 = bitcast %struct.smi_info* %2 to i8*
  call void @kfree(i8* %8)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %NodeBlock
  %.sink = phi i32 [ 1, %NodeBlock ], [ 2, %LeafBlock1 ], [ 0, %LeafBlock ]
  %si_type13 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 4
  store i32 %.sink, i32* %si_type13, align 8, !tbaa !19
  %InterruptType = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 12
  %9 = load i8, i8* %InterruptType, align 4, !tbaa !140
  %conv17 = zext i8 %9 to i32
  %and = and i32 %conv17, 1
  %tobool18 = icmp ne i32 %and, 0
  br i1 %tobool18, label %if.then19, label %if.else

if.then19:                                        ; preds = %sw.epilog
  %GPE = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 13
  %10 = load i8, i8* %GPE, align 1, !tbaa !141
  %conv20 = zext i8 %10 to i32
  br label %if.end32

if.else:                                          ; preds = %sw.epilog
  %InterruptType21 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 12
  %11 = load i8, i8* %InterruptType21, align 4, !tbaa !140
  %conv22 = zext i8 %11 to i32
  %and23 = and i32 %conv22, 2
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end32

if.then25:                                        ; preds = %if.else
  %GlobalSystemInterrupt = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 15
  %12 = load i32, i32* %GlobalSystemInterrupt, align 4, !tbaa !142
  br label %if.end32

if.end32:                                         ; preds = %if.then25, %if.else, %if.then19
  %.sink6.sink = phi i32 [ %conv20, %if.then19 ], [ %12, %if.then25 ], [ 0, %if.else ]
  %.sink5.sink = phi i32 (%struct.smi_info*)* [ @acpi_gpe_irq_setup, %if.then19 ], [ @std_irq_setup, %if.then25 ], [ null, %if.else ]
  %irq29 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 26
  store i32 %.sink6.sink, i32* %irq29, align 4, !tbaa !27
  %irq_setup30 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 13
  store i32 (%struct.smi_info*)* %.sink5.sink, i32 (%struct.smi_info*)** %irq_setup30, align 8, !tbaa !28
  %addr = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %bit_width = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr, i32 0, i32 1
  %13 = load i8, i8* %bit_width, align 1, !tbaa !143
  %tobool33 = icmp ne i8 %13, 0
  br i1 %tobool33, label %if.then34, label %if.end41

if.then34:                                        ; preds = %if.end32
  %addr35 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %bit_width36 = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr35, i32 0, i32 1
  %14 = load i8, i8* %bit_width36, align 1, !tbaa !143
  %conv37 = zext i8 %14 to i32
  %div = sdiv i32 %conv37, 8
  br label %if.end41

if.end41:                                         ; preds = %if.then34, %if.end32
  %.sink7 = phi i32 [ %div, %if.then34 ], [ 1, %if.end32 ]
  %io39 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 10
  %regspacing40 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io39, i32 0, i32 3
  store i32 %.sink7, i32* %regspacing40, align 8, !tbaa !24
  %io42 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 10
  %regspacing43 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io42, i32 0, i32 3
  %15 = load i32, i32* %regspacing43, align 8, !tbaa !24
  %io44 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io44, i32 0, i32 4
  store i32 %15, i32* %regsize, align 4, !tbaa !25
  %addr45 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %bit_offset = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr45, i32 0, i32 2
  %16 = load i8, i8* %bit_offset, align 2, !tbaa !144
  %conv46 = zext i8 %16 to i32
  %io47 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 10
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io47, i32 0, i32 5
  store i32 %conv46, i32* %regshift, align 8, !tbaa !26
  %addr48 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %space_id = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr48, i32 0, i32 0
  %17 = load i8, i8* %space_id, align 4, !tbaa !145
  %conv49 = zext i8 %17 to i32
  %cmp50 = icmp eq i32 %conv49, 0
  br i1 %cmp50, label %if.end67, label %if.else54

if.else54:                                        ; preds = %if.end41
  %addr55 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %space_id56 = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr55, i32 0, i32 0
  %18 = load i8, i8* %space_id56, align 4, !tbaa !145
  %conv57 = zext i8 %18 to i32
  %cmp58 = icmp eq i32 %conv57, 1
  br i1 %cmp58, label %if.end67, label %if.else64

if.else64:                                        ; preds = %if.else54
  %19 = bitcast %struct.smi_info* %2 to i8*
  call void @kfree(i8* %19)
  %20 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end67:                                         ; preds = %if.else54, %if.end41
  %port_setup.sink = phi i32 (%struct.smi_info*)* [ @port_setup, %if.else54 ], [ @mem_setup, %if.end41 ]
  %.sink8 = phi i32 [ 0, %if.else54 ], [ 1, %if.end41 ]
  %io_setup61 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 11
  store i32 (%struct.smi_info*)* %port_setup.sink, i32 (%struct.smi_info*)** %io_setup61, align 8, !tbaa !22
  %io62 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 10
  %addr_type63 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io62, i32 0, i32 6
  store i32 %.sink8, i32* %addr_type63, align 4, !tbaa !21
  %addr68 = getelementptr inbounds %struct.SPMITable, %struct.SPMITable* %spmi, i32 0, i32 16
  %address = getelementptr inbounds %struct.acpi_generic_address, %struct.acpi_generic_address* %addr68, i32 0, i32 4
  %21 = load i64, i64* %address, align 4, !tbaa !146
  %io69 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %2, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io69, i32 0, i32 7
  store i64 %21, i64* %addr_data, align 8, !tbaa !20
  %22 = call i32 (i8*, ...) @printk(i8* null)
  %call82 = call i32 @add_smi(%struct.smi_info* %2)
  %tobool83 = icmp ne i32 %call82, 0
  br i1 %tobool83, label %if.then84, label %cleanup

if.then84:                                        ; preds = %if.end67
  %23 = bitcast %struct.smi_info* %2 to i8*
  call void @kfree(i8* %23)
  br label %cleanup

cleanup:                                          ; preds = %if.then84, %if.end67, %if.else64, %sw.default, %if.then5, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @acpi_gpe_irq_setup(%struct.smi_info* %info) #0 {
entry:
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 26
  %0 = load i32, i32* %irq, align 4, !tbaa !27
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %irq1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 26
  %1 = load i32, i32* %irq1, align 4, !tbaa !27
  %2 = bitcast %struct.smi_info* %info to i8*
  %call = call i32 @acpi_install_gpe_handler(i8* null, i32 %1, i32 4, i32 (i8*, i32, i8*)* @ipmi_acpi_gpe, i8* %2)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %3 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  %irq5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 26
  store i32 0, i32* %irq5, align 4, !tbaa !27
  br label %cleanup

if.else:                                          ; preds = %if.end
  %irq_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 14
  store void (%struct.smi_info*)* @acpi_gpe_irq_cleanup, void (%struct.smi_info*)** %irq_cleanup, align 8, !tbaa !39
  %4 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then2, %entry
  %retval.0 = phi i32 [ -22, %if.then2 ], [ 0, %if.else ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_acpi_gpe(i8* %gpe_device, i32 %gpe_number, i8* %context) #0 {
entry:
  %0 = bitcast i8* %context to %struct.smi_info*
  %si_lock = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %1 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %stats = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 36
  %arrayidx = getelementptr inbounds [11 x %union.anon.1], [11 x %union.anon.1]* %stats, i64 0, i64 3
  call void @atomic_inc(%union.anon.1* %arrayidx)
  %call5 = call i32 @smi_event_handler(%struct.smi_info* %0, i32 0)
  %si_lock6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %si_lock6, i64 %call2)
  ret i32 1
}

declare i32 @acpi_install_gpe_handler(i8*, i32, i32, i32 (i8*, i32, i8*)*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @acpi_gpe_irq_cleanup(%struct.smi_info* %info) #0 {
entry:
  %irq = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 26
  %0 = load i32, i32* %irq, align 4, !tbaa !27
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %irq1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 26
  %1 = load i32, i32* %irq1, align 4, !tbaa !27
  %call = call i32 @acpi_remove_gpe_handler(i8* null, i32 %1, i32 (i8*, i32, i8*)* @ipmi_acpi_gpe)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare i32 @acpi_remove_gpe_handler(i8*, i32, i32 (i8*, i32, i8*)*) #1

declare %struct.dmi_device* @dmi_find_device(i32, i8*, %struct.dmi_device*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define internal i32 @decode_dmi(%struct.dmi_header* %dm, %struct.dmi_ipmi_data* %dmi) #0 {
entry:
  %base_addr = alloca i64, align 8
  %0 = bitcast %struct.dmi_header* %dm to i8*
  %length = getelementptr inbounds %struct.dmi_header, %struct.dmi_header* %dm, i32 0, i32 1
  %1 = load i8, i8* %length, align 1, !tbaa !147
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 4
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %type = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 0
  store i8 %2, i8* %type, align 8, !tbaa !149
  %cmp = icmp uge i64 8, 64
  %3 = bitcast i64* %base_addr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i8* @__memcpy(i8* %3, i8* %add.ptr, i64 8)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %add.ptr, i64 8, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %conv = zext i8 %1 to i32
  %cmp2 = icmp sge i32 %conv, 17
  %4 = load i64, i64* %base_addr, align 8, !tbaa !76
  br i1 %cmp2, label %if.then4, label %if.else26

if.then4:                                         ; preds = %if.end
  %and = and i64 %4, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.then4
  %5 = load i64, i64* %base_addr, align 8, !tbaa !76
  %and6 = and i64 %5, 65534
  store i64 %and6, i64* %base_addr, align 8, !tbaa !76
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %if.then4
  %.sink = phi i8 [ 0, %if.then5 ], [ 1, %if.then4 ]
  %addr_space8 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 1
  store i8 %.sink, i8* %addr_space8, align 1, !tbaa !151
  %6 = load i64, i64* %base_addr, align 8, !tbaa !76
  %arrayidx10 = getelementptr inbounds i8, i8* %0, i64 16
  %7 = load i8, i8* %arrayidx10, align 1, !tbaa !6
  %conv11 = zext i8 %7 to i32
  %and12 = and i32 %conv11, 16
  %shr = ashr i32 %and12, 4
  %conv13 = sext i32 %shr to i64
  %or = or i64 %6, %conv13
  %base_addr14 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 2
  store i64 %or, i64* %base_addr14, align 8, !tbaa !152
  %arrayidx15 = getelementptr inbounds i8, i8* %0, i64 17
  %8 = load i8, i8* %arrayidx15, align 1, !tbaa !6
  %irq = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 3
  store i8 %8, i8* %irq, align 8, !tbaa !153
  %arrayidx16 = getelementptr inbounds i8, i8* %0, i64 16
  %9 = load i8, i8* %arrayidx16, align 1, !tbaa !6
  %conv17 = zext i8 %9 to i32
  %and18 = and i32 %conv17, 192
  %shr19 = ashr i32 %and18, 6
  %conv20 = trunc i32 %shr19 to i8
  %conv21 = zext i8 %conv20 to i32
  %Pivot4 = icmp slt i32 %conv21, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end9
  %Pivot = icmp slt i32 %conv21, 2
  br i1 %Pivot, label %if.end31, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv21, 2
  br i1 %SwitchLeaf2, label %if.end31, label %cleanup

LeafBlock:                                        ; preds = %if.end9
  %SwitchLeaf = icmp eq i32 %conv21, 0
  br i1 %SwitchLeaf, label %if.end31, label %cleanup

if.else26:                                        ; preds = %if.end
  %and27 = and i64 %4, 65534
  %base_addr28 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 2
  store i64 %and27, i64* %base_addr28, align 8, !tbaa !152
  %addr_space29 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 1
  store i8 0, i8* %addr_space29, align 1, !tbaa !151
  br label %if.end31

if.end31:                                         ; preds = %if.else26, %LeafBlock, %LeafBlock1, %NodeBlock
  %.sink6 = phi i8 [ 1, %if.else26 ], [ 4, %NodeBlock ], [ 16, %LeafBlock1 ], [ 1, %LeafBlock ]
  %offset30 = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 4
  store i8 %.sink6, i8* %offset30, align 1, !tbaa !154
  %arrayidx32 = getelementptr inbounds i8, i8* %0, i64 6
  %10 = load i8, i8* %arrayidx32, align 1, !tbaa !6
  %slave_addr = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %dmi, i32 0, i32 5
  store i8 %10, i8* %slave_addr, align 2, !tbaa !155
  br label %cleanup

cleanup:                                          ; preds = %if.end31, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ 0, %if.end31 ], [ -5, %LeafBlock ], [ -5, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @try_init_dmi(%struct.dmi_ipmi_data* %ipmi_data) #0 {
entry:
  %call.i = call i8* @kzalloc(i64 568, i32 208) #5
  %0 = bitcast i8* %call.i to %struct.smi_info*
  %tobool.i = icmp ne %struct.smi_info* %0, null
  br i1 %tobool.i, label %do.body.i, label %smi_info_alloc.exit

do.body.i:                                        ; preds = %entry
  %si_lock3.i = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock3.i, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %1 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock.i, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.21, i32 0, i32 0), %struct.lock_class_key* @smi_info_alloc.__key) #5
  br label %smi_info_alloc.exit

smi_info_alloc.exit:                              ; preds = %do.body.i, %entry
  %tobool = icmp ne %struct.smi_info* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %smi_info_alloc.exit
  %2 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

if.end:                                           ; preds = %smi_info_alloc.exit
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 16
  store i32 5, i32* %addr_source, align 4, !tbaa !9
  %3 = call i32 (i8*, ...) @printk(i8* null)
  %type = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 0
  %4 = load i8, i8* %type, align 8, !tbaa !149
  %conv = zext i8 %4 to i32
  %Pivot4 = icmp slt i32 %conv, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %conv, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %5 = bitcast %struct.smi_info* %0 to i8*
  call void @kfree(i8* %5)
  br label %cleanup.cont

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %NodeBlock
  %.sink = phi i32 [ 1, %NodeBlock ], [ 2, %LeafBlock1 ], [ 0, %LeafBlock ]
  %si_type6 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 4
  store i32 %.sink, i32* %si_type6, align 8, !tbaa !19
  %addr_space = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 1
  %6 = load i8, i8* %addr_space, align 1, !tbaa !151
  %conv7 = zext i8 %6 to i32
  %Pivot11 = icmp slt i32 %conv7, 1
  br i1 %Pivot11, label %LeafBlock6, label %LeafBlock8

LeafBlock8:                                       ; preds = %sw.epilog
  %SwitchLeaf9 = icmp eq i32 %conv7, 1
  br i1 %SwitchLeaf9, label %sw.epilog17, label %sw.default13

LeafBlock6:                                       ; preds = %sw.epilog
  %SwitchLeaf7 = icmp eq i32 %conv7, 0
  br i1 %SwitchLeaf7, label %sw.epilog17, label %sw.default13

sw.default13:                                     ; preds = %LeafBlock6, %LeafBlock8
  %7 = bitcast %struct.smi_info* %0 to i8*
  call void @kfree(i8* %7)
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

sw.epilog17:                                      ; preds = %LeafBlock6, %LeafBlock8
  %port_setup.sink = phi i32 (%struct.smi_info*)* [ @port_setup, %LeafBlock6 ], [ @mem_setup, %LeafBlock8 ]
  %.sink12 = phi i32 [ 0, %LeafBlock6 ], [ 1, %LeafBlock8 ]
  %io_setup10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 11
  store i32 (%struct.smi_info*)* %port_setup.sink, i32 (%struct.smi_info*)** %io_setup10, align 8, !tbaa !22
  %io11 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %addr_type12 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io11, i32 0, i32 6
  store i32 %.sink12, i32* %addr_type12, align 4, !tbaa !21
  %base_addr = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 2
  %9 = load i64, i64* %base_addr, align 8, !tbaa !152
  %io18 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io18, i32 0, i32 7
  store i64 %9, i64* %addr_data, align 8, !tbaa !20
  %offset = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 4
  %10 = load i8, i8* %offset, align 1, !tbaa !154
  %conv19 = zext i8 %10 to i32
  %io20 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io20, i32 0, i32 3
  store i32 %conv19, i32* %regspacing, align 8, !tbaa !24
  %io21 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %regspacing22 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io21, i32 0, i32 3
  %11 = load i32, i32* %regspacing22, align 8, !tbaa !24
  %tobool23 = icmp ne i32 %11, 0
  br i1 %tobool23, label %if.end27, label %if.then24

if.then24:                                        ; preds = %sw.epilog17
  %io25 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %regspacing26 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io25, i32 0, i32 3
  store i32 1, i32* %regspacing26, align 8, !tbaa !24
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %sw.epilog17
  %io28 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io28, i32 0, i32 4
  store i32 1, i32* %regsize, align 4, !tbaa !25
  %io29 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io29, i32 0, i32 5
  store i32 0, i32* %regshift, align 8, !tbaa !26
  %slave_addr = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 5
  %12 = load i8, i8* %slave_addr, align 2, !tbaa !155
  %slave_addr30 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 35
  store i8 %12, i8* %slave_addr30, align 4, !tbaa !29
  %irq = getelementptr inbounds %struct.dmi_ipmi_data, %struct.dmi_ipmi_data* %ipmi_data, i32 0, i32 3
  %13 = load i8, i8* %irq, align 8, !tbaa !153
  %conv31 = zext i8 %13 to i32
  %irq32 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 26
  store i32 %conv31, i32* %irq32, align 4, !tbaa !27
  %irq33 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 26
  %14 = load i32, i32* %irq33, align 4, !tbaa !27
  %tobool34 = icmp ne i32 %14, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end27
  %irq_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 13
  store i32 (%struct.smi_info*)* @std_irq_setup, i32 (%struct.smi_info*)** %irq_setup, align 8, !tbaa !28
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.end27
  %15 = call i32 (i8*, ...) @printk(i8* null)
  %call48 = call i32 @add_smi(%struct.smi_info* %0)
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.then50, label %cleanup.cont

if.then50:                                        ; preds = %if.end36
  %16 = bitcast %struct.smi_info* %0 to i8*
  call void @kfree(i8* %16)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then50, %if.end36, %sw.default13, %sw.default, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_pnp_probe(%struct.pnp_dev* %dev, %struct.pnp_device_id* %dev_id) #0 {
entry:
  %tmp = alloca i64, align 8
  %call = call %struct.acpi_device* @pnp_acpi_device(%struct.pnp_dev* %dev)
  %tobool = icmp ne %struct.acpi_device* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call.i = call i8* @kzalloc(i64 568, i32 208) #5
  %0 = bitcast i8* %call.i to %struct.smi_info*
  %tobool.i = icmp ne %struct.smi_info* %0, null
  br i1 %tobool.i, label %do.body.i, label %smi_info_alloc.exit

do.body.i:                                        ; preds = %if.end
  %si_lock3.i = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 5
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock3.i, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %1 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock.i, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.21, i32 0, i32 0), %struct.lock_class_key* @smi_info_alloc.__key) #5
  br label %smi_info_alloc.exit

smi_info_alloc.exit:                              ; preds = %do.body.i, %if.end
  %tobool2 = icmp ne %struct.smi_info* %0, null
  br i1 %tobool2, label %if.end4, label %cleanup

if.end4:                                          ; preds = %smi_info_alloc.exit
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 16
  store i32 4, i32* %addr_source, align 4, !tbaa !9
  %2 = call i32 (i8*, ...) @printk(i8* null)
  %handle6 = getelementptr inbounds %struct.acpi_device, %struct.acpi_device* %call, i32 0, i32 1
  %3 = load i8*, i8** %handle6, align 8, !tbaa !156
  %addr_info = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 39
  %acpi_info = bitcast %union.ipmi_smi_info_union* %addr_info to %union.anon.46*
  %acpi_handle = getelementptr inbounds %union.anon.46, %union.anon.46* %acpi_info, i32 0, i32 0
  store i8* %3, i8** %acpi_handle, align 8, !tbaa !6
  %call7 = call i32 @acpi_evaluate_integer(i8* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.97, i32 0, i32 0), %struct.acpi_object_list* null, i64* %tmp)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %err_free, label %if.end10

if.end10:                                         ; preds = %if.end4
  %4 = load i64, i64* %tmp, align 8, !tbaa !100
  %Pivot4 = icmp slt i64 %4, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end10
  %Pivot = icmp slt i64 %4, 3
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i64 %4, 3
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end10
  %SwitchLeaf = icmp eq i64 %4, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %5 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %err_free

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %NodeBlock
  %.sink = phi i32 [ 1, %NodeBlock ], [ 2, %LeafBlock1 ], [ 0, %LeafBlock ]
  %si_type14 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 4
  store i32 %.sink, i32* %si_type14, align 8, !tbaa !19
  %call17 = call %struct.resource* @pnp_get_resource(%struct.pnp_dev* %dev, i64 256, i32 0)
  %tobool18 = icmp ne %struct.resource* %call17, null
  br i1 %tobool18, label %if.end27.sink.split, label %if.else

if.else:                                          ; preds = %sw.epilog
  %call20 = call %struct.resource* @pnp_get_resource(%struct.pnp_dev* %dev, i64 512, i32 0)
  %tobool21 = icmp ne %struct.resource* %call20, null
  br i1 %tobool21, label %if.end27.sink.split, label %if.end27

if.end27.sink.split:                              ; preds = %if.else, %sw.epilog
  %mem_setup.sink = phi i32 (%struct.smi_info*)* [ @mem_setup, %if.else ], [ @port_setup, %sw.epilog ]
  %.sink5 = phi i32 [ 1, %if.else ], [ 0, %sw.epilog ]
  %res.0.ph = phi %struct.resource* [ %call20, %if.else ], [ %call17, %sw.epilog ]
  %io_setup23 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 11
  store i32 (%struct.smi_info*)* %mem_setup.sink, i32 (%struct.smi_info*)** %io_setup23, align 8, !tbaa !22
  %io24 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %addr_type25 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io24, i32 0, i32 6
  store i32 %.sink5, i32* %addr_type25, align 4, !tbaa !21
  br label %if.end27

if.end27:                                         ; preds = %if.end27.sink.split, %if.else
  %res.0 = phi %struct.resource* [ %call20, %if.else ], [ %res.0.ph, %if.end27.sink.split ]
  %tobool28 = icmp ne %struct.resource* %res.0, null
  br i1 %tobool28, label %if.end32, label %if.then29

if.then29:                                        ; preds = %if.end27
  %6 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %err_free

if.end32:                                         ; preds = %if.end27
  %start = getelementptr inbounds %struct.resource, %struct.resource* %res.0, i32 0, i32 0
  %7 = load i64, i64* %start, align 8, !tbaa !169
  %io33 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io33, i32 0, i32 7
  store i64 %7, i64* %addr_data, align 8, !tbaa !20
  %io34 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io34, i32 0, i32 3
  store i32 1, i32* %regspacing, align 8, !tbaa !24
  %io35 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %addr_type36 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io35, i32 0, i32 6
  %8 = load i32, i32* %addr_type36, align 4, !tbaa !21
  %cmp = icmp eq i32 %8, 0
  %cond = select i1 %cmp, i32 256, i32 512
  %conv = sext i32 %cond to i64
  %call37 = call %struct.resource* @pnp_get_resource(%struct.pnp_dev* %dev, i64 %conv, i32 1)
  %tobool38 = icmp ne %struct.resource* %call37, null
  br i1 %tobool38, label %if.then39, label %if.end53

if.then39:                                        ; preds = %if.end32
  %start40 = getelementptr inbounds %struct.resource, %struct.resource* %call37, i32 0, i32 0
  %9 = load i64, i64* %start40, align 8, !tbaa !169
  %io41 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %addr_data42 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io41, i32 0, i32 7
  %10 = load i64, i64* %addr_data42, align 8, !tbaa !20
  %cmp43 = icmp ugt i64 %9, %10
  br i1 %cmp43, label %if.then45, label %if.end53

if.then45:                                        ; preds = %if.then39
  %start46 = getelementptr inbounds %struct.resource, %struct.resource* %call37, i32 0, i32 0
  %11 = load i64, i64* %start46, align 8, !tbaa !169
  %io47 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %addr_data48 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io47, i32 0, i32 7
  %12 = load i64, i64* %addr_data48, align 8, !tbaa !20
  %sub = sub i64 %11, %12
  %conv49 = trunc i64 %sub to i32
  %io50 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %regspacing51 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io50, i32 0, i32 3
  store i32 %conv49, i32* %regspacing51, align 8, !tbaa !24
  br label %if.end53

if.end53:                                         ; preds = %if.then45, %if.then39, %if.end32
  %io54 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io54, i32 0, i32 4
  store i32 1, i32* %regsize, align 4, !tbaa !25
  %io55 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 10
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io55, i32 0, i32 5
  store i32 0, i32* %regshift, align 8, !tbaa !26
  %call56 = call i32 @acpi_evaluate_integer(i8* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.100, i32 0, i32 0), %struct.acpi_object_list* null, i64* %tmp)
  %tobool57 = icmp ne i32 %call56, 0
  br i1 %tobool57, label %if.else60, label %if.then58

if.then58:                                        ; preds = %if.end53
  %13 = load i64, i64* %tmp, align 8, !tbaa !100
  br label %if.end69.sink.split

if.else60:                                        ; preds = %if.end53
  %call61 = call i32 @pnp_irq_valid(%struct.pnp_dev* %dev, i32 0)
  %tobool62 = icmp ne i32 %call61, 0
  br i1 %tobool62, label %if.then63, label %if.end69

if.then63:                                        ; preds = %if.else60
  %call64 = call i64 @pnp_irq(%struct.pnp_dev* %dev, i32 0)
  br label %if.end69.sink.split

if.end69.sink.split:                              ; preds = %if.then63, %if.then58
  %call64.sink = phi i64 [ %call64, %if.then63 ], [ %13, %if.then58 ]
  %std_irq_setup.sink = phi i32 (%struct.smi_info*)* [ @std_irq_setup, %if.then63 ], [ @acpi_gpe_irq_setup, %if.then58 ]
  %conv65 = trunc i64 %call64.sink to i32
  %irq66 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 26
  store i32 %conv65, i32* %irq66, align 4, !tbaa !27
  %irq_setup67 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 13
  store i32 (%struct.smi_info*)* %std_irq_setup.sink, i32 (%struct.smi_info*)** %irq_setup67, align 8, !tbaa !28
  br label %if.end69

if.end69:                                         ; preds = %if.end69.sink.split, %if.else60
  %dev70 = getelementptr inbounds %struct.pnp_dev, %struct.pnp_dev* %dev, i32 0, i32 0
  %dev71 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %0, i32 0, i32 32
  store %struct.device* %dev70, %struct.device** %dev71, align 8, !tbaa !53
  %14 = bitcast %struct.smi_info* %0 to i8*
  call void @pnp_set_drvdata(%struct.pnp_dev* %dev, i8* %14)
  %15 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %call79 = call i32 @add_smi(%struct.smi_info* %0)
  %tobool80 = icmp ne i32 %call79, 0
  br i1 %tobool80, label %err_free, label %cleanup

err_free:                                         ; preds = %if.end69, %if.then29, %sw.default, %if.end4
  %16 = bitcast %struct.smi_info* %0 to i8*
  call void @kfree(i8* %16)
  br label %cleanup

cleanup:                                          ; preds = %err_free, %if.end69, %smi_info_alloc.exit, %entry
  %retval.0 = phi i32 [ -22, %err_free ], [ -19, %entry ], [ -12, %smi_info_alloc.exit ], [ 0, %if.end69 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @ipmi_pnp_remove(%struct.pnp_dev* %dev) #0 {
entry:
  %call = call i8* @pnp_get_drvdata(%struct.pnp_dev* %dev)
  %0 = bitcast i8* %call to %struct.smi_info*
  call void @cleanup_one_si(%struct.smi_info* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pnp_get_drvdata(%struct.pnp_dev* %pdev) #3 {
entry:
  %dev = getelementptr inbounds %struct.pnp_dev, %struct.pnp_dev* %pdev, i32 0, i32 0
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare i8* @dev_get_drvdata(%struct.device*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.acpi_device* @pnp_acpi_device(%struct.pnp_dev* %dev) #3 {
entry:
  %protocol = getelementptr inbounds %struct.pnp_dev, %struct.pnp_dev* %dev, i32 0, i32 8
  %0 = load %struct.pnp_protocol*, %struct.pnp_protocol** %protocol, align 8, !tbaa !171
  %cmp = icmp eq %struct.pnp_protocol* %0, @pnpacpi_protocol
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %data = getelementptr inbounds %struct.pnp_dev, %struct.pnp_dev* %dev, i32 0, i32 21
  %1 = load i8*, i8** %data, align 8, !tbaa !173
  %2 = bitcast i8* %1 to %struct.acpi_device*
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval.0 = phi %struct.acpi_device* [ %2, %if.then ], [ null, %entry ]
  ret %struct.acpi_device* %retval.0
}

declare i32 @acpi_evaluate_integer(i8*, i8*, %struct.acpi_object_list*, i64*) #1

declare %struct.resource* @pnp_get_resource(%struct.pnp_dev*, i64, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pnp_irq_valid(%struct.pnp_dev* %dev, i32 %bar) #3 {
entry:
  %call = call %struct.resource* @pnp_get_resource(%struct.pnp_dev* %dev, i64 1024, i32 %bar)
  %call1 = call i32 @pnp_resource_valid(%struct.resource* %call)
  ret i32 %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @pnp_irq(%struct.pnp_dev* %dev, i32 %bar) #3 {
entry:
  %call = call %struct.resource* @pnp_get_resource(%struct.pnp_dev* %dev, i64 1024, i32 %bar)
  %call1 = call i32 @pnp_resource_valid(%struct.resource* %call)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %start = getelementptr inbounds %struct.resource, %struct.resource* %call, i32 0, i32 0
  %0 = load i64, i64* %start, align 8, !tbaa !169
  br label %cleanup

cleanup:                                          ; preds = %if.then, %entry
  %retval.0 = phi i64 [ %0, %if.then ], [ -1, %entry ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pnp_set_drvdata(%struct.pnp_dev* %pdev, i8* %data) #3 {
entry:
  %dev = getelementptr inbounds %struct.pnp_dev, %struct.pnp_dev* %pdev, i32 0, i32 0
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

declare i32 @dev_set_drvdata(%struct.device*, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pnp_resource_valid(%struct.resource* %res) #3 {
entry:
  %tobool = icmp ne %struct.resource* %res, null
  %. = select i1 %tobool, i32 1, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_pci_probe(%struct.pci_dev* %pdev, %struct.pci_device_id* %ent) #0 {
entry:
  %class = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 11
  %0 = load i32, i32* %class, align 4, !tbaa !174
  %and = and i32 %0, 255
  %call.i = call i8* @kzalloc(i64 568, i32 208) #5
  %1 = bitcast i8* %call.i to %struct.smi_info*
  %tobool.i = icmp ne %struct.smi_info* %1, null
  br i1 %tobool.i, label %do.body.i, label %smi_info_alloc.exit

do.body.i:                                        ; preds = %entry
  %si_lock3.i = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 5
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %si_lock3.i, i32 0, i32 0
  %rlock.i = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock.i, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.21, i32 0, i32 0), %struct.lock_class_key* @smi_info_alloc.__key) #5
  br label %smi_info_alloc.exit

smi_info_alloc.exit:                              ; preds = %do.body.i, %entry
  %tobool = icmp ne %struct.smi_info* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %smi_info_alloc.exit
  %addr_source = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 16
  store i32 6, i32* %addr_source, align 4, !tbaa !9
  %3 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %Pivot4 = icmp slt i32 %and, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %and, 2
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %and, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %4 = bitcast %struct.smi_info* %1 to i8*
  call void @kfree(i8* %4)
  %5 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %NodeBlock
  %.sink = phi i32 [ 0, %NodeBlock ], [ 2, %LeafBlock1 ], [ 1, %LeafBlock ]
  %si_type5 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 4
  store i32 %.sink, i32* %si_type5, align 8, !tbaa !19
  %call8 = call i32 @pci_enable_device(%struct.pci_dev* %pdev)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %sw.epilog
  %6 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  %7 = bitcast %struct.smi_info* %1 to i8*
  call void @kfree(i8* %7)
  br label %cleanup

if.end13:                                         ; preds = %sw.epilog
  %addr_source_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 17
  store void (%struct.smi_info*)* @ipmi_pci_cleanup, void (%struct.smi_info*)** %addr_source_cleanup, align 8, !tbaa !73
  %8 = bitcast %struct.pci_dev* %pdev to i8*
  %addr_source_data = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 18
  store i8* %8, i8** %addr_source_data, align 8, !tbaa !178
  %resource = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 37
  %arrayidx = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource, i64 0, i64 0
  %flags = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx, i32 0, i32 3
  %9 = load i64, i64* %flags, align 8, !tbaa !179
  %and14 = and i64 %9, 256
  %tobool15 = icmp ne i64 %and14, 0
  %io_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 11
  %mem_setup.sink = select i1 %tobool15, i32 (%struct.smi_info*)* @port_setup, i32 (%struct.smi_info*)* @mem_setup
  %.sink5 = select i1 %tobool15, i32 0, i32 1
  store i32 (%struct.smi_info*)* %mem_setup.sink, i32 (%struct.smi_info*)** %io_setup, align 8, !tbaa !22
  %io18 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %addr_type19 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io18, i32 0, i32 6
  store i32 %.sink5, i32* %addr_type19, align 4, !tbaa !21
  %resource21 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 37
  %arrayidx22 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource21, i64 0, i64 0
  %start = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx22, i32 0, i32 0
  %10 = load i64, i64* %start, align 8, !tbaa !169
  %io23 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %addr_data = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io23, i32 0, i32 7
  store i64 %10, i64* %addr_data, align 8, !tbaa !20
  %call24 = call i32 @ipmi_pci_probe_regspacing(%struct.smi_info* %1)
  %io25 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %regspacing = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io25, i32 0, i32 3
  store i32 %call24, i32* %regspacing, align 8, !tbaa !24
  %io26 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io26, i32 0, i32 4
  store i32 1, i32* %regsize, align 4, !tbaa !25
  %io27 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 10
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io27, i32 0, i32 5
  store i32 0, i32* %regshift, align 8, !tbaa !26
  %irq = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 36
  %11 = load i32, i32* %irq, align 4, !tbaa !180
  %irq28 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 26
  store i32 %11, i32* %irq28, align 4, !tbaa !27
  %irq29 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 26
  %12 = load i32, i32* %irq29, align 4, !tbaa !27
  %tobool30 = icmp ne i32 %12, 0
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end13
  %irq_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 13
  store i32 (%struct.smi_info*)* @std_irq_setup, i32 (%struct.smi_info*)** %irq_setup, align 8, !tbaa !28
  br label %if.end32

if.end32:                                         ; preds = %if.then31, %if.end13
  %dev33 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %dev34 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %1, i32 0, i32 32
  store %struct.device* %dev33, %struct.device** %dev34, align 8, !tbaa !53
  %13 = bitcast %struct.smi_info* %1 to i8*
  call void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %13)
  %14 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %call44 = call i32 @add_smi(%struct.smi_info* %1)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %cleanup

if.then46:                                        ; preds = %if.end32
  %15 = bitcast %struct.smi_info* %1 to i8*
  call void @kfree(i8* %15)
  br label %cleanup

cleanup:                                          ; preds = %if.then46, %if.end32, %if.then10, %sw.default, %smi_info_alloc.exit
  %retval.0 = phi i32 [ %call8, %if.then10 ], [ -12, %sw.default ], [ -12, %smi_info_alloc.exit ], [ 0, %if.then46 ], [ 0, %if.end32 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @ipmi_pci_remove(%struct.pci_dev* %pdev) #0 {
entry:
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %pdev)
  %0 = bitcast i8* %call to %struct.smi_info*
  call void @cleanup_one_si(%struct.smi_info* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_get_drvdata(%struct.pci_dev* %pdev) #3 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare i32 @pci_enable_device(%struct.pci_dev*) #1

; Function Attrs: nounwind uwtable
define internal void @ipmi_pci_cleanup(%struct.smi_info* %info) #0 {
entry:
  %addr_source_data = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 18
  %0 = load i8*, i8** %addr_source_data, align 8, !tbaa !178
  %1 = bitcast i8* %0 to %struct.pci_dev*
  call void @pci_disable_device(%struct.pci_dev* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ipmi_pci_probe_regspacing(%struct.smi_info* %info) #0 {
entry:
  %si_type = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 4
  %0 = load i32, i32* %si_type, align 8, !tbaa !19
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end16

if.then:                                          ; preds = %entry
  %io = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regsize = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io, i32 0, i32 4
  store i32 1, i32* %regsize, align 4, !tbaa !25
  %io1 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regshift = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io1, i32 0, i32 5
  store i32 0, i32* %regshift, align 8, !tbaa !26
  %io_size = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 15
  store i32 2, i32* %io_size, align 8, !tbaa !38
  %handlers = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 3
  store %struct.si_sm_handlers* @kcs_smi_handlers, %struct.si_sm_handlers** %handlers, align 8, !tbaa !42
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %if.then
  %regspacing.0 = phi i32 [ 1, %if.then ], [ %mul, %if.end14 ]
  %cmp2 = icmp sle i32 %regspacing.0, 16
  br i1 %cmp2, label %for.body, label %LeafBlock

for.body:                                         ; preds = %for.cond
  %io3 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %regspacing4 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io3, i32 0, i32 3
  store i32 %regspacing.0, i32* %regspacing4, align 8, !tbaa !24
  %io_setup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 11
  %1 = load i32 (%struct.smi_info*)*, i32 (%struct.smi_info*)** %io_setup, align 8, !tbaa !22
  %call = call i32 %1(%struct.smi_info* %info)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then5, label %if.end

if.then5:                                         ; preds = %for.body
  %2 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %LeafBlock

if.end:                                           ; preds = %for.body
  %io7 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io7, i32 0, i32 1
  %3 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !37
  %io8 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  call void %3(%struct.si_sm_io* %io8, i32 1, i8 zeroext 16)
  %io9 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %io9, i32 0, i32 0
  %4 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !36
  %io10 = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 10
  %call11 = call zeroext i8 %4(%struct.si_sm_io* %io10, i32 1)
  %io_cleanup = getelementptr inbounds %struct.smi_info, %struct.smi_info* %info, i32 0, i32 12
  %5 = load void (%struct.smi_info*)*, void (%struct.smi_info*)** %io_cleanup, align 8, !tbaa !35
  call void %5(%struct.smi_info* %info)
  %tobool12 = icmp ne i8 %call11, 0
  br i1 %tobool12, label %LeafBlock, label %if.end14

if.end14:                                         ; preds = %if.end
  %mul = mul nsw i32 %regspacing.0, 4
  br label %for.cond

LeafBlock:                                        ; preds = %if.end, %if.then5, %for.cond
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then5 ], [ 1, %if.end ], [ 0, %for.cond ]
  %retval.0 = phi i32 [ 1, %if.then5 ], [ %regspacing.0, %if.end ], [ undef, %for.cond ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 1
  br i1 %SwitchLeaf, label %return, label %if.end16

if.end16:                                         ; preds = %LeafBlock, %entry
  br label %return

return:                                           ; preds = %if.end16, %LeafBlock
  %retval.1 = phi i32 [ %retval.0, %LeafBlock ], [ 1, %if.end16 ]
  ret i32 %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %data) #3 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

declare void @pci_disable_device(%struct.pci_dev*) #1

; Function Attrs: nounwind uwtable
define internal i32 @init_kcs_data(%struct.si_sm_data* %kcs, %struct.si_sm_io* %io) #0 {
entry:
  %state = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 0, i32* %state, align 8, !tbaa !181
  %io1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  store %struct.si_sm_io* %io, %struct.si_sm_io** %io1, align 8, !tbaa !183
  %write_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !184
  %write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  store i32 0, i32* %write_count, align 4, !tbaa !185
  %orig_write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 5
  store i32 0, i32* %orig_write_count, align 8, !tbaa !186
  %read_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !187
  %error_retries = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 9
  store i32 0, i32* %error_retries, align 4, !tbaa !188
  %truncated = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 8
  store i32 0, i32* %truncated, align 8, !tbaa !189
  %ibf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  store i64 5000000, i64* %ibf_timeout, align 8, !tbaa !190
  %obf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  store i64 5000000, i64* %obf_timeout, align 8, !tbaa !191
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @start_kcs_transaction(%struct.si_sm_data* %kcs, i8* %data, i32 %size) #0 {
entry:
  %cmp = icmp ult i32 %size, 2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp ugt i32 %size, 272
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %state = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  %0 = load i32, i32* %state, align 8, !tbaa !181
  %cmp4 = icmp ne i32 %0, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.end3
  %state5 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  %1 = load i32, i32* %state5, align 8, !tbaa !181
  %cmp6 = icmp ne i32 %1, 10
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %land.lhs.true, %if.end3
  %2 = load i32, i32* @kcs_debug, align 4, !tbaa !2
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end8
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then9
  %i.0 = phi i32 [ 0, %if.then9 ], [ %inc, %for.body ]
  %cmp10 = icmp ult i32 %i.0, %size
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = call i32 (i8*, ...) @printk(i8* null)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end13

if.end13:                                         ; preds = %for.end, %if.end8
  %error_retries = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 9
  store i32 0, i32* %error_retries, align 4, !tbaa !188
  %conv14 = zext i32 %size to i64
  %write_data = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 2
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %write_data, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %data, i64 %conv14, i32 1, i1 false)
  %write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  store i32 %size, i32* %write_count, align 4, !tbaa !185
  %orig_write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 5
  store i32 %size, i32* %orig_write_count, align 8, !tbaa !186
  %write_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !184
  %read_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !187
  %state15 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 1, i32* %state15, align 8, !tbaa !181
  %ibf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  store i64 5000000, i64* %ibf_timeout, align 8, !tbaa !190
  %obf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  store i64 5000000, i64* %obf_timeout, align 8, !tbaa !191
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %land.lhs.true, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end13 ], [ 199, %entry ], [ 200, %if.end ], [ 213, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_kcs_result(%struct.si_sm_data* %kcs, i8* %data, i32 %length) #0 {
entry:
  %read_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %0 = load i32, i32* %read_pos, align 4, !tbaa !187
  %cmp = icmp ult i32 %length, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %read_pos1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  store i32 %length, i32* %read_pos1, align 4, !tbaa !187
  %truncated = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 8
  store i32 1, i32* %truncated, align 8, !tbaa !189
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %read_pos2 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %1 = load i32, i32* %read_pos2, align 4, !tbaa !187
  %conv = sext i32 %1 to i64
  %read_data = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 6
  %arraydecay = getelementptr inbounds [272 x i8], [272 x i8]* %read_data, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %data, i8* %arraydecay, i64 %conv, i32 1, i1 false)
  %cmp3 = icmp uge i32 %length, 3
  br i1 %cmp3, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %if.end
  %read_pos5 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %2 = load i32, i32* %read_pos5, align 4, !tbaa !187
  %cmp6 = icmp slt i32 %2, 3
  br i1 %cmp6, label %if.then8, label %if.end10

if.then8:                                         ; preds = %land.lhs.true
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 2
  store i8 -1, i8* %arrayidx, align 1, !tbaa !6
  %read_pos9 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  store i32 3, i32* %read_pos9, align 4, !tbaa !187
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %land.lhs.true, %if.end
  %truncated11 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 8
  %3 = load i32, i32* %truncated11, align 8, !tbaa !189
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end10
  %arrayidx13 = getelementptr inbounds i8, i8* %data, i64 2
  store i8 -58, i8* %arrayidx13, align 1, !tbaa !6
  %truncated14 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 8
  store i32 0, i32* %truncated14, align 8, !tbaa !189
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end10
  %read_pos16 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %4 = load i32, i32* %read_pos16, align 4, !tbaa !187
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @kcs_event(%struct.si_sm_data* %kcs, i64 %time) #0 {
entry:
  %call = call zeroext i8 @read_status(%struct.si_sm_data* %kcs)
  %0 = load i32, i32* @kcs_debug, align 4, !tbaa !2
  %and = and i32 %0, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call3 = call i32 @check_ibf(%struct.si_sm_data* %kcs, i8 zeroext %call, i64 %time)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.end
  %conv7 = zext i8 %call to i32
  %shr = ashr i32 %conv7, 6
  %and8 = and i32 %shr, 3
  %conv9 = trunc i32 %and8 to i8
  %state10 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  %2 = load i32, i32* %state10, align 8, !tbaa !181
  %Pivot20 = icmp slt i32 %2, 5
  br i1 %Pivot20, label %NodeBlock5, label %NodeBlock17

NodeBlock17:                                      ; preds = %if.end6
  %Pivot18 = icmp slt i32 %2, 8
  br i1 %Pivot18, label %NodeBlock9, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %2, 9
  br i1 %Pivot16, label %sw.bb100, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %2, 10
  br i1 %Pivot14, label %sw.bb111, label %sw.epilog

NodeBlock9:                                       ; preds = %NodeBlock17
  %Pivot10 = icmp slt i32 %2, 6
  br i1 %Pivot10, label %sw.bb55, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %2, 7
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  br i1 %Pivot8, label %sw.bb75, label %sw.bb98

NodeBlock5:                                       ; preds = %if.end6
  %Pivot6 = icmp slt i32 %2, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %2, 3
  br i1 %Pivot4, label %sw.bb21, label %NodeBlock1

NodeBlock1:                                       ; preds = %NodeBlock3
  %Pivot2 = icmp slt i32 %2, 4
  %conv36 = zext i8 %conv9 to i32
  %cmp37 = icmp ne i32 %conv36, 2
  br i1 %Pivot2, label %sw.bb35, label %sw.bb48

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %2, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb15

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %2, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  %conv11 = zext i8 %call to i32
  %and12 = and i32 %conv11, 4
  %tobool13 = icmp ne i32 %and12, 0
  %. = select i1 %tobool13, i32 6, i32 4
  br label %cleanup

sw.bb15:                                          ; preds = %NodeBlock
  %conv16 = zext i8 %conv9 to i32
  %cmp = icmp ne i32 %conv16, 0
  br i1 %cmp, label %if.then18, label %if.end19

if.then18:                                        ; preds = %sw.bb15
  call void @start_error_recovery(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.end19:                                         ; preds = %sw.bb15
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  call void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext 97)
  %state20 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 2, i32* %state20, align 8, !tbaa !181
  br label %sw.epilog

sw.bb21:                                          ; preds = %NodeBlock3
  %conv22 = zext i8 %conv9 to i32
  %cmp23 = icmp ne i32 %conv22, 2
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %sw.bb21
  call void @start_error_recovery(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.end26:                                         ; preds = %sw.bb21
  %call27 = call zeroext i8 @read_data(%struct.si_sm_data* %kcs)
  %write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  %3 = load i32, i32* %write_count, align 4, !tbaa !185
  %cmp28 = icmp eq i32 %3, 1
  br i1 %cmp28, label %if.then30, label %if.else32

if.then30:                                        ; preds = %if.end26
  call void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext 98)
  br label %if.end34

if.else32:                                        ; preds = %if.end26
  call void @write_next_byte(%struct.si_sm_data* %kcs)
  br label %if.end34

if.end34:                                         ; preds = %if.else32, %if.then30
  %.sink = phi i32 [ 3, %if.else32 ], [ 4, %if.then30 ]
  %state33 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 %.sink, i32* %state33, align 8, !tbaa !181
  br label %sw.epilog

sw.bb35:                                          ; preds = %NodeBlock1
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %sw.bb35
  call void @start_error_recovery(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.end40:                                         ; preds = %sw.bb35
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  %write_count41 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  %4 = load i32, i32* %write_count41, align 4, !tbaa !185
  %cmp42 = icmp eq i32 %4, 1
  br i1 %cmp42, label %if.then44, label %if.else46

if.then44:                                        ; preds = %if.end40
  call void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext 98)
  %state45 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 4, i32* %state45, align 8, !tbaa !181
  br label %sw.epilog

if.else46:                                        ; preds = %if.end40
  call void @write_next_byte(%struct.si_sm_data* %kcs)
  br label %sw.epilog

sw.bb48:                                          ; preds = %NodeBlock1
  br i1 %cmp37, label %if.then52, label %if.end53

if.then52:                                        ; preds = %sw.bb48
  call void @start_error_recovery(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.end53:                                         ; preds = %sw.bb48
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  call void @write_next_byte(%struct.si_sm_data* %kcs)
  %state54 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 5, i32* %state54, align 8, !tbaa !181
  br label %sw.epilog

sw.bb55:                                          ; preds = %NodeBlock9
  %conv56 = zext i8 %conv9 to i32
  %cmp57 = icmp ne i32 %conv56, 1
  %conv59 = zext i8 %conv9 to i32
  %cmp60 = icmp ne i32 %conv59, 0
  %or.cond = and i1 %cmp57, %cmp60
  br i1 %or.cond, label %if.then62, label %if.end63

if.then62:                                        ; preds = %sw.bb55
  call void @start_error_recovery(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.end63:                                         ; preds = %sw.bb55
  %conv64 = zext i8 %conv9 to i32
  %cmp65 = icmp eq i32 %conv64, 1
  br i1 %cmp65, label %if.then67, label %if.else72

if.then67:                                        ; preds = %if.end63
  %call68 = call i32 @check_obf(%struct.si_sm_data* %kcs, i8 zeroext %call, i64 %time)
  %tobool69 = icmp ne i32 %call68, 0
  br i1 %tobool69, label %if.end71, label %cleanup

if.end71:                                         ; preds = %if.then67
  call void @read_next_byte(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.else72:                                        ; preds = %if.end63
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  %orig_write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 5
  store i32 0, i32* %orig_write_count, align 8, !tbaa !186
  %state73 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 0, i32* %state73, align 8, !tbaa !181
  br label %cleanup

sw.bb75:                                          ; preds = %NodeBlock7
  %call76 = call zeroext i8 @read_status(%struct.si_sm_data* %kcs)
  %conv77 = zext i8 %call76 to i32
  %and78 = and i32 %conv77, 1
  %tobool79 = icmp ne i32 %and78, 0
  br i1 %tobool79, label %if.then80, label %if.end96

if.then80:                                        ; preds = %sw.bb75
  %tobool83 = icmp ne i32 1, 0
  br i1 %tobool83, label %land.lhs.true84, label %if.end96

land.lhs.true84:                                  ; preds = %if.then80
  %5 = load volatile i64, i64* @jiffies, align 8, !tbaa !76
  %error0_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 12
  %6 = load i64, i64* %error0_timeout, align 8, !tbaa !192
  %sub = sub nsw i64 %5, %6
  %cmp92 = icmp slt i64 %sub, 0
  br i1 %cmp92, label %cleanup, label %if.end96

if.end96:                                         ; preds = %land.lhs.true84, %if.then80, %sw.bb75
  call void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext 96)
  %state97 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 7, i32* %state97, align 8, !tbaa !181
  br label %sw.epilog

sw.bb98:                                          ; preds = %NodeBlock7
  call void @write_data(%struct.si_sm_data* %kcs, i8 zeroext 0)
  %state99 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 8, i32* %state99, align 8, !tbaa !181
  br label %sw.epilog

sw.bb100:                                         ; preds = %NodeBlock15
  %conv101 = zext i8 %conv9 to i32
  %cmp102 = icmp ne i32 %conv101, 1
  br i1 %cmp102, label %if.then104, label %if.end105

if.then104:                                       ; preds = %sw.bb100
  call void @start_error_recovery(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.end105:                                        ; preds = %sw.bb100
  %call106 = call i32 @check_obf(%struct.si_sm_data* %kcs, i8 zeroext %call, i64 %time)
  %tobool107 = icmp ne i32 %call106, 0
  br i1 %tobool107, label %if.end109, label %cleanup

if.end109:                                        ; preds = %if.end105
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  call void @write_data(%struct.si_sm_data* %kcs, i8 zeroext 104)
  %state110 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 9, i32* %state110, align 8, !tbaa !181
  br label %sw.epilog

sw.bb111:                                         ; preds = %NodeBlock13
  %conv112 = zext i8 %conv9 to i32
  %cmp113 = icmp ne i32 %conv112, 0
  br i1 %cmp113, label %if.then115, label %if.end116

if.then115:                                       ; preds = %sw.bb111
  call void @start_error_recovery(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.end116:                                        ; preds = %sw.bb111
  %call117 = call i32 @check_obf(%struct.si_sm_data* %kcs, i8 zeroext %call, i64 %time)
  %tobool118 = icmp ne i32 %call117, 0
  br i1 %tobool118, label %if.end120, label %cleanup

if.end120:                                        ; preds = %if.end116
  call void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %call)
  %orig_write_count121 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 5
  %7 = load i32, i32* %orig_write_count121, align 8, !tbaa !186
  %tobool122 = icmp ne i32 %7, 0
  br i1 %tobool122, label %if.then123, label %if.else124

if.then123:                                       ; preds = %if.end120
  call void @restart_kcs_transaction(%struct.si_sm_data* %kcs)
  br label %sw.epilog

if.else124:                                       ; preds = %if.end120
  %state125 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 0, i32* %state125, align 8, !tbaa !181
  br label %cleanup

sw.epilog:                                        ; preds = %if.then123, %if.then115, %if.end109, %if.then104, %sw.bb98, %if.end96, %if.end71, %if.then62, %if.end53, %if.then52, %if.else46, %if.then44, %if.then39, %if.end34, %if.then25, %if.end19, %if.then18, %LeafBlock, %NodeBlock13
  %state127 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  %8 = load i32, i32* %state127, align 8, !tbaa !181
  %cmp128 = icmp eq i32 %8, 10
  br i1 %cmp128, label %if.then130, label %cleanup

if.then130:                                       ; preds = %sw.epilog
  %io = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %9 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !183
  %call131 = call i32 @init_kcs_data(%struct.si_sm_data* %kcs, %struct.si_sm_io* %9)
  br label %cleanup

cleanup:                                          ; preds = %if.then130, %sw.epilog, %if.else124, %if.end116, %if.end105, %land.lhs.true84, %if.else72, %if.then67, %sw.bb, %if.end
  %retval.0 = phi i32 [ 5, %if.then130 ], [ 3, %if.else72 ], [ 3, %if.else124 ], [ 1, %if.end ], [ %., %sw.bb ], [ 1, %if.then67 ], [ 2, %land.lhs.true84 ], [ 1, %if.end105 ], [ 1, %if.end116 ], [ 0, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @kcs_detect(%struct.si_sm_data* %kcs) #0 {
entry:
  %call = call zeroext i8 @read_status(%struct.si_sm_data* %kcs)
  %conv = zext i8 %call to i32
  %cmp = icmp eq i32 %conv, 255
  %. = select i1 %cmp, i32 1, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal void @kcs_cleanup(%struct.si_sm_data* %kcs) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @kcs_size() #0 {
entry:
  ret i32 608
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @read_status(%struct.si_sm_data* %kcs) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !183
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !193
  %io1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !183
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 1)
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @check_ibf(%struct.si_sm_data* %kcs, i8 zeroext %status, i64 %time) #3 {
entry:
  %conv = zext i8 %status to i32
  %and = and i32 %conv, 2
  %tobool = icmp ne i32 %and, 0
  %ibf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  br i1 %tobool, label %if.then, label %return.sink.split

if.then:                                          ; preds = %entry
  %0 = load i64, i64* %ibf_timeout, align 8, !tbaa !190
  %sub = sub nsw i64 %0, %time
  store i64 %sub, i64* %ibf_timeout, align 8, !tbaa !190
  %ibf_timeout1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  %1 = load i64, i64* %ibf_timeout1, align 8, !tbaa !190
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %if.then3, label %return

if.then3:                                         ; preds = %if.then
  call void @start_error_recovery(%struct.si_sm_data* %kcs)
  %ibf_timeout4 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  br label %return.sink.split

return.sink.split:                                ; preds = %if.then3, %entry
  %ibf_timeout.sink = phi i64* [ %ibf_timeout4, %if.then3 ], [ %ibf_timeout, %entry ]
  store i64 5000000, i64* %ibf_timeout.sink, align 8, !tbaa !190
  br label %return

return:                                           ; preds = %return.sink.split, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 1, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @clear_obf(%struct.si_sm_data* %kcs, i8 zeroext %status) #0 {
entry:
  %conv = zext i8 %status to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call zeroext i8 @read_data(%struct.si_sm_data* %kcs)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @start_error_recovery(%struct.si_sm_data* %kcs) #3 {
entry:
  %error_retries = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 9
  %0 = load i32, i32* %error_retries, align 4, !tbaa !188
  %inc = add i32 %0, 1
  store i32 %inc, i32* %error_retries, align 4, !tbaa !188
  %error_retries1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 9
  %1 = load i32, i32* %error_retries1, align 4, !tbaa !188
  %cmp = icmp ugt i32 %1, 10
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @kcs_debug, align 4, !tbaa !2
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.then
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end4

if.else:                                          ; preds = %entry
  %4 = load volatile i64, i64* @jiffies, align 8, !tbaa !76
  %add = add i64 %4, 500
  %error0_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 12
  store i64 %add, i64* %error0_timeout, align 8, !tbaa !192
  br label %if.end4

if.end4:                                          ; preds = %if.else, %if.then2, %if.then
  %.sink = phi i32 [ 6, %if.else ], [ 10, %if.then2 ], [ 10, %if.then ]
  %state3 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 %.sink, i32* %state3, align 8, !tbaa !181
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext %data) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !183
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !194
  %io1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !183
  call void %1(%struct.si_sm_io* %2, i32 1, i8 zeroext %data)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @read_data(%struct.si_sm_data* %kcs) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !183
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !193
  %io1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !183
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 0)
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_next_byte(%struct.si_sm_data* %kcs) #3 {
entry:
  %write_data = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 2
  %write_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 3
  %0 = load i32, i32* %write_pos, align 8, !tbaa !184
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %write_data, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !6
  call void @write_data(%struct.si_sm_data* %kcs, i8 zeroext %1)
  %write_pos1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 3
  %2 = load i32, i32* %write_pos1, align 8, !tbaa !184
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %write_pos1, align 8, !tbaa !184
  %write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  %3 = load i32, i32* %write_count, align 4, !tbaa !185
  %dec = add nsw i32 %3, -1
  store i32 %dec, i32* %write_count, align 4, !tbaa !185
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @check_obf(%struct.si_sm_data* %kcs, i8 zeroext %status, i64 %time) #3 {
entry:
  %conv = zext i8 %status to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  %obf_timeout5 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  br i1 %tobool, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %0 = load i64, i64* %obf_timeout5, align 8, !tbaa !191
  %sub = sub nsw i64 %0, %time
  store i64 %sub, i64* %obf_timeout5, align 8, !tbaa !191
  %obf_timeout1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  %1 = load i64, i64* %obf_timeout1, align 8, !tbaa !191
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %if.then3, label %return

if.then3:                                         ; preds = %if.then
  call void @start_error_recovery(%struct.si_sm_data* %kcs)
  br label %return

if.end4:                                          ; preds = %entry
  store i64 5000000, i64* %obf_timeout5, align 8, !tbaa !191
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %retval.0 = phi i32 [ 1, %if.end4 ], [ 1, %if.then3 ], [ 0, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @read_next_byte(%struct.si_sm_data* %kcs) #3 {
entry:
  %read_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %0 = load i32, i32* %read_pos, align 4, !tbaa !187
  %cmp = icmp sge i32 %0, 272
  %call = call zeroext i8 @read_data(%struct.si_sm_data* %kcs)
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %truncated = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 8
  store i32 1, i32* %truncated, align 8, !tbaa !189
  br label %if.end

if.else:                                          ; preds = %entry
  %read_data = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 6
  %read_pos2 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %1 = load i32, i32* %read_pos2, align 4, !tbaa !187
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [272 x i8], [272 x i8]* %read_data, i64 0, i64 %idxprom
  store i8 %call, i8* %arrayidx, align 1, !tbaa !6
  %read_pos3 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  %2 = load i32, i32* %read_pos3, align 4, !tbaa !187
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %read_pos3, align 4, !tbaa !187
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @write_data(%struct.si_sm_data* %kcs, i8 zeroext 104)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_data(%struct.si_sm_data* %kcs, i8 zeroext %data) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !183
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !194
  %io1 = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !183
  call void %1(%struct.si_sm_io* %2, i32 0, i8 zeroext %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @restart_kcs_transaction(%struct.si_sm_data* %kcs) #0 {
entry:
  %orig_write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 5
  %0 = load i32, i32* %orig_write_count, align 8, !tbaa !186
  %write_count = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 4
  store i32 %0, i32* %write_count, align 4, !tbaa !185
  %write_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !184
  %read_pos = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !187
  %state = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 0
  store i32 2, i32* %state, align 8, !tbaa !181
  %ibf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 10
  store i64 5000000, i64* %ibf_timeout, align 8, !tbaa !190
  %obf_timeout = getelementptr inbounds %struct.si_sm_data, %struct.si_sm_data* %kcs, i32 0, i32 11
  store i64 5000000, i64* %obf_timeout, align 8, !tbaa !191
  call void @write_cmd(%struct.si_sm_data* %kcs, i8 zeroext 97)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @init_smic_data(%struct.si_sm_data.13* %smic, %struct.si_sm_io* %io) #0 {
entry:
  %state = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 0, i32* %state, align 8, !tbaa !195
  %io1 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  store %struct.si_sm_io* %io, %struct.si_sm_io** %io1, align 8, !tbaa !197
  %write_pos = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !198
  %write_count = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 4
  store i32 0, i32* %write_count, align 4, !tbaa !199
  %orig_write_count = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 5
  store i32 0, i32* %orig_write_count, align 8, !tbaa !200
  %read_pos = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !201
  %error_retries = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 9
  store i32 0, i32* %error_retries, align 4, !tbaa !202
  %truncated = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 8
  store i32 0, i32* %truncated, align 8, !tbaa !203
  %smic_timeout = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 10
  store i64 2000000, i64* %smic_timeout, align 8, !tbaa !204
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @start_smic_transaction(%struct.si_sm_data.13* %smic, i8* %data, i32 %size) #0 {
entry:
  %cmp = icmp ult i32 %size, 2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp ugt i32 %size, 80
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %state = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  %0 = load i32, i32* %state, align 8, !tbaa !195
  %cmp4 = icmp ne i32 %0, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.end3
  %state5 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  %1 = load i32, i32* %state5, align 8, !tbaa !195
  %cmp6 = icmp ne i32 %1, 10
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %land.lhs.true, %if.end3
  %2 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end8
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then9
  %i.0 = phi i32 [ 0, %if.then9 ], [ %inc, %for.body ]
  %cmp10 = icmp ult i32 %i.0, %size
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = call i32 (i8*, ...) @printk(i8* null)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end13

if.end13:                                         ; preds = %for.end, %if.end8
  %error_retries = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 9
  store i32 0, i32* %error_retries, align 4, !tbaa !202
  %conv14 = zext i32 %size to i64
  %write_data = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 2
  %arraydecay = getelementptr inbounds [80 x i8], [80 x i8]* %write_data, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %data, i64 %conv14, i32 1, i1 false)
  %write_count = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 4
  store i32 %size, i32* %write_count, align 4, !tbaa !199
  %orig_write_count = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 5
  store i32 %size, i32* %orig_write_count, align 8, !tbaa !200
  %write_pos = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !198
  %read_pos = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !201
  %state15 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 1, i32* %state15, align 8, !tbaa !195
  %smic_timeout = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 10
  store i64 2000000, i64* %smic_timeout, align 8, !tbaa !204
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %land.lhs.true, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end13 ], [ 199, %entry ], [ 200, %if.end ], [ 213, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @smic_get_result(%struct.si_sm_data.13* %smic, i8* %data, i32 %length) #0 {
entry:
  %0 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %read_pos = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  %2 = load i32, i32* %read_pos, align 4, !tbaa !201
  %cmp = icmp slt i32 %i.0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = call i32 (i8*, ...) @printk(i8* null)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  %read_pos3 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  %5 = load i32, i32* %read_pos3, align 4, !tbaa !201
  %cmp4 = icmp ult i32 %length, %5
  br i1 %cmp4, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %read_pos7 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  store i32 %length, i32* %read_pos7, align 4, !tbaa !201
  %truncated = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 8
  store i32 1, i32* %truncated, align 8, !tbaa !203
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %read_pos9 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  %6 = load i32, i32* %read_pos9, align 4, !tbaa !201
  %conv10 = sext i32 %6 to i64
  %read_data11 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 6
  %arraydecay = getelementptr inbounds [80 x i8], [80 x i8]* %read_data11, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %data, i8* %arraydecay, i64 %conv10, i32 1, i1 false)
  %cmp12 = icmp uge i32 %length, 3
  br i1 %cmp12, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end8
  %read_pos14 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  %7 = load i32, i32* %read_pos14, align 4, !tbaa !201
  %cmp15 = icmp slt i32 %7, 3
  br i1 %cmp15, label %if.then17, label %if.end20

if.then17:                                        ; preds = %land.lhs.true
  %arrayidx18 = getelementptr inbounds i8, i8* %data, i64 2
  store i8 -1, i8* %arrayidx18, align 1, !tbaa !6
  %read_pos19 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  store i32 3, i32* %read_pos19, align 4, !tbaa !201
  br label %if.end20

if.end20:                                         ; preds = %if.then17, %land.lhs.true, %if.end8
  %truncated21 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 8
  %8 = load i32, i32* %truncated21, align 8, !tbaa !203
  %tobool22 = icmp ne i32 %8, 0
  br i1 %tobool22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.end20
  %arrayidx24 = getelementptr inbounds i8, i8* %data, i64 2
  store i8 -58, i8* %arrayidx24, align 1, !tbaa !6
  %truncated25 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 8
  store i32 0, i32* %truncated25, align 8, !tbaa !203
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.end20
  %read_pos27 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  %9 = load i32, i32* %read_pos27, align 4, !tbaa !201
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @smic_event(%struct.si_sm_data.13* %smic, i64 %time) #0 {
entry:
  %state = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  %0 = load i32, i32* %state, align 8, !tbaa !195
  %cmp = icmp eq i32 %0, 10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %io = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %1 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !197
  %call = call i32 @init_smic_data(%struct.si_sm_data.13* %smic, %struct.si_sm_io* %1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %state1 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  %2 = load i32, i32* %state1, align 8, !tbaa !195
  %cmp2 = icmp ne i32 %2, 0
  br i1 %cmp2, label %if.then3, label %if.end15

if.then3:                                         ; preds = %if.end
  %3 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and = and i32 %3, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.then3
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.then3
  %cmp7 = icmp slt i64 %time, 2000000
  br i1 %cmp7, label %if.then8, label %if.end15

if.then8:                                         ; preds = %if.end6
  %smic_timeout9 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 10
  %5 = load i64, i64* %smic_timeout9, align 8, !tbaa !204
  %sub = sub nsw i64 %5, %time
  store i64 %sub, i64* %smic_timeout9, align 8, !tbaa !204
  %smic_timeout10 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 10
  %6 = load i64, i64* %smic_timeout10, align 8, !tbaa !204
  %cmp11 = icmp slt i64 %6, 0
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.then8
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

if.end15:                                         ; preds = %if.then8, %if.end6, %if.end
  %call16 = call zeroext i8 @read_smic_flags(%struct.si_sm_data.13* %smic)
  %conv = zext i8 %call16 to i32
  %and17 = and i32 %conv, 1
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end15
  %call21 = call zeroext i8 @read_smic_status(%struct.si_sm_data.13* %smic)
  %7 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and22 = and i32 %7, 4
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end29

if.then24:                                        ; preds = %if.end20
  %8 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end29

if.end29:                                         ; preds = %if.then24, %if.end20
  %state30 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  %9 = load i32, i32* %state30, align 8, !tbaa !195
  %Pivot20 = icmp slt i32 %9, 5
  br i1 %Pivot20, label %NodeBlock5, label %NodeBlock17

NodeBlock17:                                      ; preds = %if.end29
  %Pivot18 = icmp slt i32 %9, 8
  br i1 %Pivot18, label %NodeBlock9, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %9, 9
  br i1 %Pivot16, label %sw.bb141, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %9, 10
  br i1 %Pivot14, label %sw.bb159, label %LeafBlock11

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %9, 10
  br i1 %SwitchLeaf12, label %sw.bb178, label %sw.default181

NodeBlock9:                                       ; preds = %NodeBlock17
  %Pivot10 = icmp slt i32 %9, 6
  br i1 %Pivot10, label %sw.bb94, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %9, 7
  br i1 %Pivot8, label %sw.bb114, label %sw.bb125

NodeBlock5:                                       ; preds = %if.end29
  %Pivot6 = icmp slt i32 %9, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %9, 3
  br i1 %Pivot4, label %sw.bb40, label %NodeBlock1

NodeBlock1:                                       ; preds = %NodeBlock3
  %Pivot2 = icmp slt i32 %9, 4
  %conv51 = zext i8 %call21 to i32
  br i1 %Pivot2, label %sw.bb50, label %sw.bb71

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %9, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb36

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %9, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default181

sw.bb:                                            ; preds = %LeafBlock
  %conv31 = zext i8 %call16 to i32
  %and32 = and i32 %conv31, 4
  %tobool33 = icmp ne i32 %and32, 0
  %. = select i1 %tobool33, i32 6, i32 4
  br label %cleanup

sw.bb36:                                          ; preds = %NodeBlock
  call void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext 64)
  %conv37 = zext i8 %call16 to i32
  %or = or i32 %conv37, 1
  %conv38 = trunc i32 %or to i8
  call void @write_smic_flags(%struct.si_sm_data.13* %smic, i8 zeroext %conv38)
  %state39 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 2, i32* %state39, align 8, !tbaa !195
  br label %sw.epilog188

sw.bb40:                                          ; preds = %NodeBlock3
  %conv41 = zext i8 %call21 to i32
  %cmp42 = icmp ne i32 %conv41, 192
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %sw.bb40
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

if.end45:                                         ; preds = %sw.bb40
  call void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext 65)
  call void @write_next_byte.93(%struct.si_sm_data.13* %smic)
  %conv46 = zext i8 %call16 to i32
  %or47 = or i32 %conv46, 1
  %conv48 = trunc i32 %or47 to i8
  call void @write_smic_flags(%struct.si_sm_data.13* %smic, i8 zeroext %conv48)
  %state49 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 3, i32* %state49, align 8, !tbaa !195
  br label %sw.epilog188

sw.bb50:                                          ; preds = %NodeBlock1
  %cmp52 = icmp ne i32 %conv51, 193
  br i1 %cmp52, label %if.then54, label %if.end55

if.then54:                                        ; preds = %sw.bb50
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

if.end55:                                         ; preds = %sw.bb50
  %conv56 = zext i8 %call16 to i32
  %and57 = and i32 %conv56, 64
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.then59, label %cleanup

if.then59:                                        ; preds = %if.end55
  %write_count = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 4
  %10 = load i32, i32* %write_count, align 4, !tbaa !199
  %cmp60 = icmp eq i32 %10, 1
  br i1 %cmp60, label %if.then62, label %if.else

if.then62:                                        ; preds = %if.then59
  call void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext 67)
  br label %if.end65

if.else:                                          ; preds = %if.then59
  call void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext 66)
  br label %if.end65

if.end65:                                         ; preds = %if.else, %if.then62
  %.sink = phi i32 [ 4, %if.else ], [ 5, %if.then62 ]
  %state64 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 %.sink, i32* %state64, align 8, !tbaa !195
  call void @write_next_byte.93(%struct.si_sm_data.13* %smic)
  %conv66 = zext i8 %call16 to i32
  %or67 = or i32 %conv66, 1
  %conv68 = trunc i32 %or67 to i8
  call void @write_smic_flags(%struct.si_sm_data.13* %smic, i8 zeroext %conv68)
  br label %sw.epilog188

sw.bb71:                                          ; preds = %NodeBlock1
  %cmp73 = icmp ne i32 %conv51, 194
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %sw.bb71
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

if.end76:                                         ; preds = %sw.bb71
  %conv77 = zext i8 %call16 to i32
  %and78 = and i32 %conv77, 64
  %tobool79 = icmp ne i32 %and78, 0
  br i1 %tobool79, label %if.then80, label %cleanup

if.then80:                                        ; preds = %if.end76
  %write_count81 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 4
  %11 = load i32, i32* %write_count81, align 4, !tbaa !199
  %cmp82 = icmp eq i32 %11, 1
  br i1 %cmp82, label %if.then84, label %if.else86

if.then84:                                        ; preds = %if.then80
  call void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext 67)
  br label %if.end88

if.else86:                                        ; preds = %if.then80
  call void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext 66)
  br label %if.end88

if.end88:                                         ; preds = %if.else86, %if.then84
  %.sink28 = phi i32 [ 4, %if.else86 ], [ 5, %if.then84 ]
  %state87 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 %.sink28, i32* %state87, align 8, !tbaa !195
  call void @write_next_byte.93(%struct.si_sm_data.13* %smic)
  %conv89 = zext i8 %call16 to i32
  %or90 = or i32 %conv89, 1
  %conv91 = trunc i32 %or90 to i8
  call void @write_smic_flags(%struct.si_sm_data.13* %smic, i8 zeroext %conv91)
  br label %sw.epilog188

sw.bb94:                                          ; preds = %NodeBlock9
  %conv95 = zext i8 %call21 to i32
  %cmp96 = icmp ne i32 %conv95, 195
  br i1 %cmp96, label %if.then98, label %if.end99

if.then98:                                        ; preds = %sw.bb94
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

if.end99:                                         ; preds = %sw.bb94
  %call100 = call zeroext i8 @read_smic_data(%struct.si_sm_data.13* %smic)
  %conv101 = zext i8 %call100 to i32
  %cmp102 = icmp ne i32 %conv101, 0
  br i1 %cmp102, label %if.then104, label %if.else111

if.then104:                                       ; preds = %if.end99
  %12 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and105 = and i32 %12, 1
  %tobool106 = icmp ne i32 %and105, 0
  br i1 %tobool106, label %if.then107, label %if.end110

if.then107:                                       ; preds = %if.then104
  %13 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end110

if.end110:                                        ; preds = %if.then107, %if.then104
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

if.else111:                                       ; preds = %if.end99
  %state112 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 6, i32* %state112, align 8, !tbaa !195
  br label %sw.epilog188

sw.bb114:                                         ; preds = %NodeBlock7
  %conv115 = zext i8 %call16 to i32
  %and116 = and i32 %conv115, 128
  %tobool117 = icmp ne i32 %and116, 0
  br i1 %tobool117, label %if.then118, label %cleanup

if.then118:                                       ; preds = %sw.bb114
  call void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext 68)
  %conv119 = zext i8 %call16 to i32
  %or120 = or i32 %conv119, 1
  %conv121 = trunc i32 %or120 to i8
  call void @write_smic_flags(%struct.si_sm_data.13* %smic, i8 zeroext %conv121)
  %state122 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 7, i32* %state122, align 8, !tbaa !195
  br label %sw.epilog188

sw.bb125:                                         ; preds = %NodeBlock7
  %conv126 = zext i8 %call21 to i32
  %cmp127 = icmp ne i32 %conv126, 196
  br i1 %cmp127, label %if.then129, label %if.end130

if.then129:                                       ; preds = %sw.bb125
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

if.end130:                                        ; preds = %sw.bb125
  %conv131 = zext i8 %call16 to i32
  %and132 = and i32 %conv131, 128
  %tobool133 = icmp ne i32 %and132, 0
  br i1 %tobool133, label %if.then134, label %cleanup

if.then134:                                       ; preds = %if.end130
  call void @read_next_byte.100(%struct.si_sm_data.13* %smic)
  call void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext 69)
  %conv135 = zext i8 %call16 to i32
  %or136 = or i32 %conv135, 1
  %conv137 = trunc i32 %or136 to i8
  call void @write_smic_flags(%struct.si_sm_data.13* %smic, i8 zeroext %conv137)
  %state138 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 8, i32* %state138, align 8, !tbaa !195
  br label %sw.epilog188

sw.bb141:                                         ; preds = %NodeBlock15
  %conv142 = zext i8 %call21 to i32
  %Pivot27 = icmp slt i32 %conv142, 198
  br i1 %Pivot27, label %LeafBlock22, label %LeafBlock24

LeafBlock24:                                      ; preds = %sw.bb141
  %SwitchLeaf25 = icmp eq i32 %conv142, 198
  br i1 %SwitchLeaf25, label %sw.bb143, label %sw.default

LeafBlock22:                                      ; preds = %sw.bb141
  %SwitchLeaf23 = icmp eq i32 %conv142, 197
  br i1 %SwitchLeaf23, label %sw.bb148, label %sw.default

sw.bb143:                                         ; preds = %LeafBlock24
  call void @read_next_byte.100(%struct.si_sm_data.13* %smic)
  call void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext 70)
  %conv144 = zext i8 %call16 to i32
  %or145 = or i32 %conv144, 1
  %conv146 = trunc i32 %or145 to i8
  call void @write_smic_flags(%struct.si_sm_data.13* %smic, i8 zeroext %conv146)
  %state147 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 9, i32* %state147, align 8, !tbaa !195
  br label %sw.epilog188

sw.bb148:                                         ; preds = %LeafBlock22
  %conv149 = zext i8 %call16 to i32
  %and150 = and i32 %conv149, 128
  %tobool151 = icmp ne i32 %and150, 0
  br i1 %tobool151, label %if.then152, label %cleanup

if.then152:                                       ; preds = %sw.bb148
  call void @read_next_byte.100(%struct.si_sm_data.13* %smic)
  call void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext 69)
  %conv153 = zext i8 %call16 to i32
  %or154 = or i32 %conv153, 1
  %conv155 = trunc i32 %or154 to i8
  call void @write_smic_flags(%struct.si_sm_data.13* %smic, i8 zeroext %conv155)
  %state156 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 8, i32* %state156, align 8, !tbaa !195
  br label %sw.epilog188

sw.default:                                       ; preds = %LeafBlock22, %LeafBlock24
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

sw.bb159:                                         ; preds = %NodeBlock13
  %conv160 = zext i8 %call21 to i32
  %cmp161 = icmp ne i32 %conv160, 192
  br i1 %cmp161, label %if.then163, label %if.end164

if.then163:                                       ; preds = %sw.bb159
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

if.end164:                                        ; preds = %sw.bb159
  %call165 = call zeroext i8 @read_smic_data(%struct.si_sm_data.13* %smic)
  %conv166 = zext i8 %call165 to i32
  %cmp167 = icmp ne i32 %conv166, 0
  br i1 %cmp167, label %if.then169, label %if.else176

if.then169:                                       ; preds = %if.end164
  %14 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and170 = and i32 %14, 1
  %tobool171 = icmp ne i32 %and170, 0
  br i1 %tobool171, label %if.then172, label %if.end175

if.then172:                                       ; preds = %if.then169
  %15 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end175

if.end175:                                        ; preds = %if.then172, %if.then169
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

if.else176:                                       ; preds = %if.end164
  %state177 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 0, i32* %state177, align 8, !tbaa !195
  br label %cleanup

sw.bb178:                                         ; preds = %LeafBlock11
  %io179 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %16 = load %struct.si_sm_io*, %struct.si_sm_io** %io179, align 8, !tbaa !197
  %call180 = call i32 @init_smic_data(%struct.si_sm_data.13* %smic, %struct.si_sm_io* %16)
  br label %cleanup

sw.default181:                                    ; preds = %LeafBlock, %LeafBlock11
  %17 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and182 = and i32 %17, 1
  %tobool183 = icmp ne i32 %and182, 0
  br i1 %tobool183, label %if.then184, label %sw.epilog188

if.then184:                                       ; preds = %sw.default181
  %18 = call i32 (i8*, ...) @printk(i8* null)
  call void @start_error_recovery.90(%struct.si_sm_data.13* %smic)
  br label %cleanup

sw.epilog188:                                     ; preds = %sw.default181, %if.then152, %sw.bb143, %if.then134, %if.then118, %if.else111, %if.end88, %if.end65, %if.end45, %sw.bb36
  %smic_timeout189 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 10
  store i64 2000000, i64* %smic_timeout189, align 8, !tbaa !204
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog188, %if.then184, %sw.bb178, %if.else176, %if.end175, %if.then163, %sw.default, %sw.bb148, %if.end130, %if.then129, %sw.bb114, %if.end110, %if.then98, %if.end76, %if.then75, %if.end55, %if.then54, %if.then44, %sw.bb, %if.end15, %if.then12, %if.then
  %retval.0 = phi i32 [ 5, %if.then ], [ 1, %if.then12 ], [ 1, %if.then184 ], [ 0, %sw.epilog188 ], [ 1, %if.then44 ], [ 1, %if.then54 ], [ 1, %if.then75 ], [ 1, %if.then98 ], [ 1, %if.end110 ], [ 1, %if.then129 ], [ 1, %sw.default ], [ 1, %if.then163 ], [ 1, %if.end175 ], [ 3, %if.else176 ], [ 5, %sw.bb178 ], [ 1, %if.end15 ], [ %., %sw.bb ], [ 1, %if.end55 ], [ 1, %if.end76 ], [ 1, %sw.bb114 ], [ 1, %if.end130 ], [ 1, %sw.bb148 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @smic_detect(%struct.si_sm_data.13* %smic) #0 {
entry:
  %call = call zeroext i8 @read_smic_flags(%struct.si_sm_data.13* %smic)
  %conv = zext i8 %call to i32
  %cmp = icmp eq i32 %conv, 255
  %. = select i1 %cmp, i32 1, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal void @smic_cleanup(%struct.si_sm_data.13* %kcs) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @smic_size() #0 {
entry:
  ret i32 208
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @read_smic_flags(%struct.si_sm_data.13* %smic) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !197
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !193
  %io1 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !197
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 2)
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @start_error_recovery.90(%struct.si_sm_data.13* %smic) #3 {
entry:
  %error_retries = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 9
  %0 = load i32, i32* %error_retries, align 4, !tbaa !202
  %inc = add i32 %0, 1
  store i32 %inc, i32* %error_retries, align 4, !tbaa !202
  %error_retries1 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 9
  %1 = load i32, i32* %error_retries1, align 4, !tbaa !202
  %cmp = icmp ugt i32 %1, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @smic_debug, align 4, !tbaa !2
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %3 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %state = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 10, i32* %state, align 8, !tbaa !195
  br label %if.end4

if.else:                                          ; preds = %entry
  %orig_write_count = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 5
  %4 = load i32, i32* %orig_write_count, align 8, !tbaa !200
  %write_count = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 4
  store i32 %4, i32* %write_count, align 4, !tbaa !199
  %write_pos = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 3
  store i32 0, i32* %write_pos, align 8, !tbaa !198
  %read_pos = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  store i32 0, i32* %read_pos, align 4, !tbaa !201
  %state3 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 0
  store i32 1, i32* %state3, align 8, !tbaa !195
  %smic_timeout = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 10
  store i64 2000000, i64* %smic_timeout, align 8, !tbaa !204
  br label %if.end4

if.end4:                                          ; preds = %if.else, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @read_smic_status(%struct.si_sm_data.13* %smic) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !197
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !193
  %io1 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !197
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 1)
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_smic_control(%struct.si_sm_data.13* %smic, i8 zeroext %control) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !197
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !194
  %io1 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !197
  call void %1(%struct.si_sm_io* %2, i32 1, i8 zeroext %control)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_smic_flags(%struct.si_sm_data.13* %smic, i8 zeroext %flags) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !197
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !194
  %io1 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !197
  call void %1(%struct.si_sm_io* %2, i32 2, i8 zeroext %flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_next_byte.93(%struct.si_sm_data.13* %smic) #3 {
entry:
  %write_data = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 2
  %write_pos = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 3
  %0 = load i32, i32* %write_pos, align 8, !tbaa !198
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [80 x i8], [80 x i8]* %write_data, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !6
  call void @write_si_sm_data(%struct.si_sm_data.13* %smic, i8 zeroext %1)
  %write_pos1 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 3
  %2 = load i32, i32* %write_pos1, align 8, !tbaa !198
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %write_pos1, align 8, !tbaa !198
  %write_count = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 4
  %3 = load i32, i32* %write_count, align 4, !tbaa !199
  %dec = add nsw i32 %3, -1
  store i32 %dec, i32* %write_count, align 4, !tbaa !199
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @read_smic_data(%struct.si_sm_data.13* %smic) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !197
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !193
  %io1 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !197
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 0)
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @read_next_byte.100(%struct.si_sm_data.13* %smic) #3 {
entry:
  %read_pos = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  %0 = load i32, i32* %read_pos, align 4, !tbaa !201
  %cmp = icmp sge i32 %0, 80
  %call = call zeroext i8 @read_smic_data(%struct.si_sm_data.13* %smic)
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %truncated = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 8
  store i32 1, i32* %truncated, align 8, !tbaa !203
  br label %if.end

if.else:                                          ; preds = %entry
  %read_data = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 6
  %read_pos2 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  %1 = load i32, i32* %read_pos2, align 4, !tbaa !201
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [80 x i8], [80 x i8]* %read_data, i64 0, i64 %idxprom
  store i8 %call, i8* %arrayidx, align 1, !tbaa !6
  %read_pos3 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 7
  %2 = load i32, i32* %read_pos3, align 4, !tbaa !201
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %read_pos3, align 4, !tbaa !201
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_si_sm_data(%struct.si_sm_data.13* %smic, i8 zeroext %data) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !197
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 1
  %1 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !194
  %io1 = getelementptr inbounds %struct.si_sm_data.13, %struct.si_sm_data.13* %smic, i32 0, i32 1
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !197
  call void %1(%struct.si_sm_io* %2, i32 0, i8 zeroext %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_init_data(%struct.si_sm_data.22* %bt, %struct.si_sm_io* %io) #0 {
entry:
  %0 = bitcast %struct.si_sm_data.22* %bt to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 624, i32 8, i1 false)
  %io1 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %1 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !205
  %cmp = icmp ne %struct.si_sm_io* %1, %io
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %io2 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  store %struct.si_sm_io* %io, %struct.si_sm_io** %io2, align 8, !tbaa !205
  %seq = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 1
  store i8 0, i8* %seq, align 4, !tbaa !207
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %state = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 0, i32* %state, align 8, !tbaa !208
  %complete = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 11
  store i32 0, i32* %complete, align 8, !tbaa !209
  %BT_CAP_req2rsp = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 13
  store i64 5000000, i64* %BT_CAP_req2rsp, align 8, !tbaa !210
  %BT_CAP_retries = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 14
  store i32 2, i32* %BT_CAP_retries, align 8, !tbaa !211
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_start_transaction(%struct.si_sm_data.22* %bt, i8* %data, i32 %size) #0 {
entry:
  %cmp = icmp ult i32 %size, 2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp ugt i32 %size, 272
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %state = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %0 = load i32, i32* %state, align 8, !tbaa !208
  %cmp4 = icmp eq i32 %0, 14
  br i1 %cmp4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end3
  %state7 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %1 = load i32, i32* %state7, align 8, !tbaa !208
  %cmp8 = icmp ne i32 %1, 0
  br i1 %cmp8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end6
  %2 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then11, label %if.end16

if.then11:                                        ; preds = %if.end10
  %3 = call i32 (i8*, ...) @printk(i8* null)
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then11
  %i.0 = phi i32 [ 0, %if.then11 ], [ %inc, %for.body ]
  %cmp13 = icmp ult i32 %i.0, %size
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = call i32 (i8*, ...) @printk(i8* null)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end16

if.end16:                                         ; preds = %for.end, %if.end10
  %add = add i32 %size, 1
  %conv17 = trunc i32 %add to i8
  %write_data = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %arrayidx18 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data, i64 0, i64 0
  store i8 %conv17, i8* %arrayidx18, align 8, !tbaa !6
  %7 = load i8, i8* %data, align 1, !tbaa !6
  %write_data19 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %arrayidx20 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data19, i64 0, i64 1
  store i8 %7, i8* %arrayidx20, align 1, !tbaa !6
  %seq = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 1
  %8 = load i8, i8* %seq, align 4, !tbaa !207
  %inc21 = add i8 %8, 1
  store i8 %inc21, i8* %seq, align 4, !tbaa !207
  %write_data22 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %arrayidx23 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data22, i64 0, i64 2
  store i8 %8, i8* %arrayidx23, align 2, !tbaa !6
  %sub24 = sub i32 %size, 1
  %conv25 = zext i32 %sub24 to i64
  %write_data26 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %arraydecay = getelementptr inbounds [274 x i8], [274 x i8]* %write_data26, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 3
  %add.ptr27 = getelementptr inbounds i8, i8* %data, i64 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr, i8* %add.ptr27, i64 %conv25, i32 1, i1 false)
  %add28 = add i32 %size, 2
  %write_count = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 4
  store i32 %add28, i32* %write_count, align 4, !tbaa !212
  %error_retries = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 9
  store i32 0, i32* %error_retries, align 8, !tbaa !213
  %nonzero_status = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 10
  store i32 0, i32* %nonzero_status, align 4, !tbaa !214
  %truncated = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 7
  store i32 0, i32* %truncated, align 8, !tbaa !215
  %state29 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 1, i32* %state29, align 8, !tbaa !208
  %BT_CAP_req2rsp = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 13
  %9 = load i64, i64* %BT_CAP_req2rsp, align 8, !tbaa !210
  %timeout = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 8
  store i64 %9, i64* %timeout, align 8, !tbaa !216
  call void @force_result(%struct.si_sm_data.22* %bt, i8 zeroext -1)
  br label %cleanup

cleanup:                                          ; preds = %if.end16, %if.end6, %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end16 ], [ 199, %entry ], [ 200, %if.end ], [ 192, %if.end3 ], [ 213, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_get_result(%struct.si_sm_data.22* %bt, i8* %data, i32 %length) #0 {
entry:
  %read_count = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 6
  %0 = load i32, i32* %read_count, align 4, !tbaa !217
  %sub = sub nsw i32 %0, 2
  %cmp = icmp slt i32 %sub, 3
  %cmp1 = icmp sgt i32 %sub, 272
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @force_result(%struct.si_sm_data.22* %bt, i8 zeroext -1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %msg_len.0 = phi i32 [ 3, %if.then ], [ %sub, %entry ]
  %read_data = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx = getelementptr inbounds [274 x i8], [274 x i8]* %read_data, i64 0, i64 1
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %arrayidx2 = getelementptr inbounds i8, i8* %data, i64 0
  store i8 %1, i8* %arrayidx2, align 1, !tbaa !6
  %read_data3 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx4 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data3, i64 0, i64 3
  %2 = load i8, i8* %arrayidx4, align 1, !tbaa !6
  %arrayidx5 = getelementptr inbounds i8, i8* %data, i64 1
  store i8 %2, i8* %arrayidx5, align 1, !tbaa !6
  %cmp6 = icmp ult i32 %length, %msg_len.0
  br i1 %cmp6, label %if.then8, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.end
  %truncated = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 7
  %3 = load i32, i32* %truncated, align 8, !tbaa !215
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then8, label %if.else

if.then8:                                         ; preds = %lor.lhs.false7, %if.end
  %arrayidx9 = getelementptr inbounds i8, i8* %data, i64 2
  store i8 -58, i8* %arrayidx9, align 1, !tbaa !6
  br label %if.end13

if.else:                                          ; preds = %lor.lhs.false7
  %sub10 = sub nsw i32 %msg_len.0, 2
  %conv = sext i32 %sub10 to i64
  %add.ptr = getelementptr inbounds i8, i8* %data, i64 2
  %read_data11 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arraydecay = getelementptr inbounds [274 x i8], [274 x i8]* %read_data11, i32 0, i32 0
  %add.ptr12 = getelementptr inbounds i8, i8* %arraydecay, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr, i8* %add.ptr12, i64 %conv, i32 1, i1 false)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then8
  %msg_len.1 = phi i32 [ 3, %if.then8 ], [ %msg_len.0, %if.else ]
  %4 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and = and i32 %4, 2
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %if.then15, label %if.end22

if.then15:                                        ; preds = %if.end13
  %5 = call i32 (i8*, ...) @printk(i8* null)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then15
  %i.0 = phi i32 [ 0, %if.then15 ], [ %inc, %for.body ]
  %cmp16 = icmp slt i32 %i.0, %msg_len.1
  br i1 %cmp16, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = call i32 (i8*, ...) @printk(i8* null)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end22

if.end22:                                         ; preds = %for.end, %if.end13
  ret i32 %msg_len.1
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_event(%struct.si_sm_data.22* %bt, i64 %time) #0 {
entry:
  %BT_CAP = alloca [8 x i8], align 1
  %GetBT_CAP = alloca [2 x i8], align 1
  %io = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !205
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !193
  %io1 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !205
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 0)
  %conv = zext i8 %call to i32
  %nonzero_status = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 10
  %3 = load i32, i32* %nonzero_status, align 4, !tbaa !214
  %or = or i32 %3, %conv
  store i32 %or, i32* %nonzero_status, align 4, !tbaa !214
  %4 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and = and i32 %4, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %state = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %5 = load i32, i32* %state, align 8, !tbaa !208
  %6 = load i32, i32* @bt_event.last_printed, align 4, !tbaa !6
  %cmp = icmp ne i32 %5, %6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %state3 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %7 = load i32, i32* %state3, align 8, !tbaa !208
  %conv4 = trunc i32 %7 to i8
  call void @state2txt(i8 zeroext %conv4)
  call void @status2txt(i8 zeroext %call)
  %8 = call i32 (i8*, ...) @printk(i8* null)
  %state8 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %9 = load i32, i32* %state8, align 8, !tbaa !208
  store i32 %9, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %state9 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %10 = load i32, i32* %state9, align 8, !tbaa !208
  %cmp10 = icmp ult i32 %10, 2
  br i1 %cmp10, label %land.lhs.true12, label %if.end17

land.lhs.true12:                                  ; preds = %if.end
  %conv13 = zext i8 %call to i32
  %and14 = and i32 %conv13, 8
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true12
  call void @drain_BMC2HOST(%struct.si_sm_data.22* %bt)
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

if.end17:                                         ; preds = %land.lhs.true12, %if.end
  %state18 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %11 = load i32, i32* %state18, align 8, !tbaa !208
  %cmp19 = icmp ne i32 %11, 0
  br i1 %cmp19, label %land.lhs.true21, label %if.end37

land.lhs.true21:                                  ; preds = %if.end17
  %state22 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %12 = load i32, i32* %state22, align 8, !tbaa !208
  %cmp23 = icmp ult i32 %12, 11
  br i1 %cmp23, label %if.then25, label %if.end37

if.then25:                                        ; preds = %land.lhs.true21
  %timeout26 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 8
  %13 = load i64, i64* %timeout26, align 8, !tbaa !216
  %sub = sub nsw i64 %13, %time
  store i64 %sub, i64* %timeout26, align 8, !tbaa !216
  %timeout27 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 8
  %14 = load i64, i64* %timeout27, align 8, !tbaa !216
  %cmp28 = icmp slt i64 %14, 0
  br i1 %cmp28, label %land.lhs.true30, label %if.end37

land.lhs.true30:                                  ; preds = %if.then25
  %state31 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %15 = load i32, i32* %state31, align 8, !tbaa !208
  %cmp32 = icmp ult i32 %15, 7
  br i1 %cmp32, label %if.then34, label %if.end37

if.then34:                                        ; preds = %land.lhs.true30
  %call35 = call i32 @error_recovery(%struct.si_sm_data.22* %bt, i8 zeroext %call, i8 zeroext -61)
  br label %cleanup

if.end37:                                         ; preds = %land.lhs.true30, %if.then25, %land.lhs.true21, %if.end17
  %state38 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %16 = load i32, i32* %state38, align 8, !tbaa !208
  %Pivot28 = icmp slt i32 %16, 7
  br i1 %Pivot28, label %NodeBlock9, label %NodeBlock25

NodeBlock25:                                      ; preds = %if.end37
  %Pivot26 = icmp slt i32 %16, 10
  br i1 %Pivot26, label %NodeBlock13, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %16, 13
  br i1 %Pivot24, label %NodeBlock17, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %16, 14
  br i1 %Pivot22, label %sw.bb197, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %16, 14
  br i1 %SwitchLeaf20, label %sw.bb148, label %sw.default

NodeBlock17:                                      ; preds = %NodeBlock23
  %Pivot18 = icmp slt i32 %16, 12
  br i1 %Pivot18, label %LeafBlock15, label %sw.bb191

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %16, 10
  br i1 %SwitchLeaf16, label %sw.bb186, label %sw.default

NodeBlock13:                                      ; preds = %NodeBlock25
  %Pivot14 = icmp slt i32 %16, 8
  br i1 %Pivot14, label %sw.bb156, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %16, 9
  br i1 %Pivot12, label %sw.bb158, label %sw.bb179

NodeBlock9:                                       ; preds = %if.end37
  %Pivot10 = icmp slt i32 %16, 3
  br i1 %Pivot10, label %NodeBlock1, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %16, 5
  br i1 %Pivot8, label %NodeBlock3, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %16, 6
  %conv115 = zext i8 %call to i32
  br i1 %Pivot6, label %sw.bb114, label %sw.bb124

NodeBlock3:                                       ; preds = %NodeBlock7
  %Pivot4 = icmp slt i32 %16, 4
  %conv95 = zext i8 %call to i32
  br i1 %Pivot4, label %sw.bb94, label %sw.bb101

NodeBlock1:                                       ; preds = %NodeBlock9
  %Pivot2 = icmp slt i32 %16, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %16, 2
  %conv60 = zext i8 %call to i32
  br i1 %Pivot, label %sw.bb59, label %sw.bb78

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %16, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %conv39 = zext i8 %call to i32
  %and40 = and i32 %conv39, 16
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then42, label %if.end45

if.then42:                                        ; preds = %sw.bb
  %io43 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %17 = load %struct.si_sm_io*, %struct.si_sm_io** %io43, align 8, !tbaa !205
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %17, i32 0, i32 1
  %18 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !194
  %io44 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %19 = load %struct.si_sm_io*, %struct.si_sm_io** %io44, align 8, !tbaa !205
  call void %18(%struct.si_sm_io* %19, i32 0, i8 zeroext 16)
  br label %cleanup

if.end45:                                         ; preds = %sw.bb
  %conv46 = zext i8 %call to i32
  %and47 = and i32 %conv46, 64
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then49, label %if.end53

if.then49:                                        ; preds = %if.end45
  %io50 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %20 = load %struct.si_sm_io*, %struct.si_sm_io** %io50, align 8, !tbaa !205
  %outputb51 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %20, i32 0, i32 1
  %21 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb51, align 8, !tbaa !194
  %io52 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %22 = load %struct.si_sm_io*, %struct.si_sm_io** %io52, align 8, !tbaa !205
  call void %21(%struct.si_sm_io* %22, i32 0, i8 zeroext 64)
  br label %if.end53

if.end53:                                         ; preds = %if.then49, %if.end45
  %BT_CAP_outreqs = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 12
  %23 = load i32, i32* %BT_CAP_outreqs, align 4, !tbaa !218
  %tobool54 = icmp ne i32 %23, 0
  br i1 %tobool54, label %if.end57, label %if.then55

if.then55:                                        ; preds = %if.end53
  %state56 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 12, i32* %state56, align 8, !tbaa !208
  br label %cleanup

if.end57:                                         ; preds = %if.end53
  %BT_CAP_req2rsp = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 13
  %24 = load i64, i64* %BT_CAP_req2rsp, align 8, !tbaa !210
  %timeout58 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 8
  store i64 %24, i64* %timeout58, align 8, !tbaa !216
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

sw.bb59:                                          ; preds = %NodeBlock
  %and61 = and i32 %conv60, 132
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %sw.bb59
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

if.end64:                                         ; preds = %sw.bb59
  %io65 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %25 = load %struct.si_sm_io*, %struct.si_sm_io** %io65, align 8, !tbaa !205
  %inputb66 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %25, i32 0, i32 0
  %26 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb66, align 8, !tbaa !193
  %io67 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %27 = load %struct.si_sm_io*, %struct.si_sm_io** %io67, align 8, !tbaa !205
  %call68 = call zeroext i8 %26(%struct.si_sm_io* %27, i32 0)
  %conv69 = zext i8 %call68 to i32
  %and70 = and i32 %conv69, 64
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %if.then72, label %if.end76

if.then72:                                        ; preds = %if.end64
  %io73 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %28 = load %struct.si_sm_io*, %struct.si_sm_io** %io73, align 8, !tbaa !205
  %outputb74 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %28, i32 0, i32 1
  %29 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb74, align 8, !tbaa !194
  %io75 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %30 = load %struct.si_sm_io*, %struct.si_sm_io** %io75, align 8, !tbaa !205
  call void %29(%struct.si_sm_io* %30, i32 0, i8 zeroext 64)
  br label %if.end76

if.end76:                                         ; preds = %if.then72, %if.end64
  %state77 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 2, i32* %state77, align 8, !tbaa !208
  br label %cleanup

sw.bb78:                                          ; preds = %NodeBlock
  %and80 = and i32 %conv60, 64
  %tobool81 = icmp ne i32 %and80, 0
  br i1 %tobool81, label %if.then82, label %if.end86

if.then82:                                        ; preds = %sw.bb78
  %io83 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %31 = load %struct.si_sm_io*, %struct.si_sm_io** %io83, align 8, !tbaa !205
  %outputb84 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %31, i32 0, i32 1
  %32 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb84, align 8, !tbaa !194
  %io85 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %33 = load %struct.si_sm_io*, %struct.si_sm_io** %io85, align 8, !tbaa !205
  call void %32(%struct.si_sm_io* %33, i32 0, i8 zeroext 64)
  br label %if.end86

if.end86:                                         ; preds = %if.then82, %sw.bb78
  %io87 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %34 = load %struct.si_sm_io*, %struct.si_sm_io** %io87, align 8, !tbaa !205
  %outputb88 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %34, i32 0, i32 1
  %35 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb88, align 8, !tbaa !194
  %io89 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %36 = load %struct.si_sm_io*, %struct.si_sm_io** %io89, align 8, !tbaa !205
  call void %35(%struct.si_sm_io* %36, i32 0, i8 zeroext 1)
  call void @write_all_bytes(%struct.si_sm_data.22* %bt)
  %io90 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %37 = load %struct.si_sm_io*, %struct.si_sm_io** %io90, align 8, !tbaa !205
  %outputb91 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %37, i32 0, i32 1
  %38 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb91, align 8, !tbaa !194
  %io92 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %39 = load %struct.si_sm_io*, %struct.si_sm_io** %io92, align 8, !tbaa !205
  call void %38(%struct.si_sm_io* %39, i32 0, i8 zeroext 4)
  %state93 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 3, i32* %state93, align 8, !tbaa !208
  br label %cleanup

sw.bb94:                                          ; preds = %NodeBlock3
  %and96 = and i32 %conv95, 132
  %tobool97 = icmp ne i32 %and96, 0
  br i1 %tobool97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %sw.bb94
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

if.end99:                                         ; preds = %sw.bb94
  %state100 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 4, i32* %state100, align 8, !tbaa !208
  br label %cleanup

sw.bb101:                                         ; preds = %NodeBlock3
  %and103 = and i32 %conv95, 8
  %tobool104 = icmp ne i32 %and103, 0
  br i1 %tobool104, label %if.end106, label %if.then105

if.then105:                                       ; preds = %sw.bb101
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

if.end106:                                        ; preds = %sw.bb101
  %io107 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %40 = load %struct.si_sm_io*, %struct.si_sm_io** %io107, align 8, !tbaa !205
  %outputb108 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %40, i32 0, i32 1
  %41 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb108, align 8, !tbaa !194
  %io109 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %42 = load %struct.si_sm_io*, %struct.si_sm_io** %io109, align 8, !tbaa !205
  call void %41(%struct.si_sm_io* %42, i32 0, i8 zeroext 64)
  %io110 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %43 = load %struct.si_sm_io*, %struct.si_sm_io** %io110, align 8, !tbaa !205
  %outputb111 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %43, i32 0, i32 1
  %44 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb111, align 8, !tbaa !194
  %io112 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %45 = load %struct.si_sm_io*, %struct.si_sm_io** %io112, align 8, !tbaa !205
  call void %44(%struct.si_sm_io* %45, i32 0, i8 zeroext 8)
  %state113 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 5, i32* %state113, align 8, !tbaa !208
  br label %cleanup

sw.bb114:                                         ; preds = %NodeBlock5
  %and116 = and i32 %conv115, 8
  %tobool117 = icmp ne i32 %and116, 0
  br i1 %tobool117, label %if.then118, label %if.end122

if.then118:                                       ; preds = %sw.bb114
  %io119 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %46 = load %struct.si_sm_io*, %struct.si_sm_io** %io119, align 8, !tbaa !205
  %outputb120 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %46, i32 0, i32 1
  %47 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb120, align 8, !tbaa !194
  %io121 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %48 = load %struct.si_sm_io*, %struct.si_sm_io** %io121, align 8, !tbaa !205
  call void %47(%struct.si_sm_io* %48, i32 0, i8 zeroext 8)
  store i32 11, i32* @bt_event.last_printed, align 4, !tbaa !6
  br label %cleanup

if.end122:                                        ; preds = %sw.bb114
  %state123 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 6, i32* %state123, align 8, !tbaa !208
  br label %cleanup

sw.bb124:                                         ; preds = %NodeBlock5
  %and126 = and i32 %conv115, 64
  %tobool127 = icmp ne i32 %and126, 0
  br i1 %tobool127, label %if.end132, label %if.then128

if.then128:                                       ; preds = %sw.bb124
  %io129 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %49 = load %struct.si_sm_io*, %struct.si_sm_io** %io129, align 8, !tbaa !205
  %outputb130 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %49, i32 0, i32 1
  %50 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb130, align 8, !tbaa !194
  %io131 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %51 = load %struct.si_sm_io*, %struct.si_sm_io** %io131, align 8, !tbaa !205
  call void %50(%struct.si_sm_io* %51, i32 0, i8 zeroext 64)
  br label %if.end132

if.end132:                                        ; preds = %if.then128, %sw.bb124
  %io133 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %52 = load %struct.si_sm_io*, %struct.si_sm_io** %io133, align 8, !tbaa !205
  %outputb134 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %52, i32 0, i32 1
  %53 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb134, align 8, !tbaa !194
  %io135 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %54 = load %struct.si_sm_io*, %struct.si_sm_io** %io135, align 8, !tbaa !205
  call void %53(%struct.si_sm_io* %54, i32 0, i8 zeroext 2)
  %call136 = call i32 @read_all_bytes(%struct.si_sm_data.22* %bt)
  %io137 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %55 = load %struct.si_sm_io*, %struct.si_sm_io** %io137, align 8, !tbaa !205
  %outputb138 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %55, i32 0, i32 1
  %56 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb138, align 8, !tbaa !194
  %io139 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %57 = load %struct.si_sm_io*, %struct.si_sm_io** %io139, align 8, !tbaa !205
  call void %56(%struct.si_sm_io* %57, i32 0, i8 zeroext 64)
  %tobool140 = icmp ne i32 %call136, 0
  br i1 %tobool140, label %if.end143, label %if.then141

if.then141:                                       ; preds = %if.end132
  %state142 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 4, i32* %state142, align 8, !tbaa !208
  br label %cleanup

if.end143:                                        ; preds = %if.end132
  %complete = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 11
  %58 = load i32, i32* %complete, align 8, !tbaa !209
  %state144 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 %58, i32* %state144, align 8, !tbaa !208
  %state145 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %59 = load i32, i32* %state145, align 8, !tbaa !208
  %cmp146 = icmp eq i32 %59, 0
  %cond = select i1 %cmp146, i32 3, i32 0
  br label %cleanup

sw.bb148:                                         ; preds = %LeafBlock19
  %conv149 = zext i8 %call to i32
  %and150 = and i32 %conv149, 128
  %tobool151 = icmp ne i32 %and150, 0
  br i1 %tobool151, label %cleanup, label %if.then152

if.then152:                                       ; preds = %sw.bb148
  call void @reset_flags(%struct.si_sm_data.22* %bt)
  %io153 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %60 = load %struct.si_sm_io*, %struct.si_sm_io** %io153, align 8, !tbaa !205
  %call154 = call i32 @bt_init_data(%struct.si_sm_data.22* %bt, %struct.si_sm_io* %60)
  br label %cleanup

sw.bb156:                                         ; preds = %NodeBlock13
  call void @reset_flags(%struct.si_sm_data.22* %bt)
  call void @drain_BMC2HOST(%struct.si_sm_data.22* %bt)
  %state157 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 8, i32* %state157, align 8, !tbaa !208
  br label %cleanup

sw.bb158:                                         ; preds = %NodeBlock11
  %io159 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %61 = load %struct.si_sm_io*, %struct.si_sm_io** %io159, align 8, !tbaa !205
  %outputb160 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %61, i32 0, i32 1
  %62 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb160, align 8, !tbaa !194
  %io161 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %63 = load %struct.si_sm_io*, %struct.si_sm_io** %io161, align 8, !tbaa !205
  call void %62(%struct.si_sm_io* %63, i32 0, i8 zeroext 1)
  %io162 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %64 = load %struct.si_sm_io*, %struct.si_sm_io** %io162, align 8, !tbaa !205
  %outputb163 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %64, i32 0, i32 1
  %65 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb163, align 8, !tbaa !194
  %io164 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %66 = load %struct.si_sm_io*, %struct.si_sm_io** %io164, align 8, !tbaa !205
  call void %65(%struct.si_sm_io* %66, i32 1, i8 zeroext 3)
  %io165 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %67 = load %struct.si_sm_io*, %struct.si_sm_io** %io165, align 8, !tbaa !205
  %outputb166 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %67, i32 0, i32 1
  %68 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb166, align 8, !tbaa !194
  %io167 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %69 = load %struct.si_sm_io*, %struct.si_sm_io** %io167, align 8, !tbaa !205
  call void %68(%struct.si_sm_io* %69, i32 1, i8 zeroext 24)
  %io168 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %70 = load %struct.si_sm_io*, %struct.si_sm_io** %io168, align 8, !tbaa !205
  %outputb169 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %70, i32 0, i32 1
  %71 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb169, align 8, !tbaa !194
  %io170 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %72 = load %struct.si_sm_io*, %struct.si_sm_io** %io170, align 8, !tbaa !205
  call void %71(%struct.si_sm_io* %72, i32 1, i8 zeroext 42)
  %io171 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %73 = load %struct.si_sm_io*, %struct.si_sm_io** %io171, align 8, !tbaa !205
  %outputb172 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %73, i32 0, i32 1
  %74 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb172, align 8, !tbaa !194
  %io173 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %75 = load %struct.si_sm_io*, %struct.si_sm_io** %io173, align 8, !tbaa !205
  call void %74(%struct.si_sm_io* %75, i32 1, i8 zeroext 3)
  %io174 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %76 = load %struct.si_sm_io*, %struct.si_sm_io** %io174, align 8, !tbaa !205
  %outputb175 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %76, i32 0, i32 1
  %77 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb175, align 8, !tbaa !194
  %io176 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %78 = load %struct.si_sm_io*, %struct.si_sm_io** %io176, align 8, !tbaa !205
  call void %77(%struct.si_sm_io* %78, i32 0, i8 zeroext 4)
  %timeout177 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 8
  store i64 6000000, i64* %timeout177, align 8, !tbaa !216
  %state178 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 9, i32* %state178, align 8, !tbaa !208
  br label %cleanup

sw.bb179:                                         ; preds = %NodeBlock11
  %timeout180 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 8
  %79 = load i64, i64* %timeout180, align 8, !tbaa !216
  %cmp181 = icmp sgt i64 %79, 0
  br i1 %cmp181, label %cleanup, label %if.end184

if.end184:                                        ; preds = %sw.bb179
  call void @drain_BMC2HOST(%struct.si_sm_data.22* %bt)
  %state185 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 10, i32* %state185, align 8, !tbaa !208
  br label %cleanup

sw.bb186:                                         ; preds = %LeafBlock15
  %read_count = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 6
  store i32 0, i32* %read_count, align 4, !tbaa !217
  %nonzero_status187 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 10
  store i32 0, i32* %nonzero_status187, align 4, !tbaa !214
  %BT_CAP_req2rsp188 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 13
  %80 = load i64, i64* %BT_CAP_req2rsp188, align 8, !tbaa !210
  %timeout189 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 8
  store i64 %80, i64* %timeout189, align 8, !tbaa !216
  %state190 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 1, i32* %state190, align 8, !tbaa !208
  br label %cleanup

sw.bb191:                                         ; preds = %NodeBlock17
  %BT_CAP_outreqs192 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 12
  store i32 1, i32* %BT_CAP_outreqs192, align 4, !tbaa !218
  %81 = bitcast [2 x i8]* %GetBT_CAP to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %81, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @bt_event.GetBT_CAP, i32 0, i32 0), i64 2, i32 1, i1 false)
  %state193 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 0, i32* %state193, align 8, !tbaa !208
  %arraydecay = getelementptr inbounds [2 x i8], [2 x i8]* %GetBT_CAP, i32 0, i32 0
  %call194 = call i32 @bt_start_transaction(%struct.si_sm_data.22* %bt, i8* %arraydecay, i32 2)
  %complete195 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 11
  store i32 13, i32* %complete195, align 8, !tbaa !209
  %state196 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 1, i32* %state196, align 8, !tbaa !208
  br label %cleanup

sw.bb197:                                         ; preds = %NodeBlock21
  %arraydecay198 = getelementptr inbounds [8 x i8], [8 x i8]* %BT_CAP, i32 0, i32 0
  %call199 = call i32 @bt_get_result(%struct.si_sm_data.22* %bt, i8* %arraydecay198, i32 8)
  %io200 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %82 = load %struct.si_sm_io*, %struct.si_sm_io** %io200, align 8, !tbaa !205
  %call201 = call i32 @bt_init_data(%struct.si_sm_data.22* %bt, %struct.si_sm_io* %82)
  %cmp202 = icmp eq i32 %call199, 8
  br i1 %cmp202, label %land.lhs.true204, label %if.else

land.lhs.true204:                                 ; preds = %sw.bb197
  %arrayidx = getelementptr inbounds [8 x i8], [8 x i8]* %BT_CAP, i64 0, i64 2
  %83 = load i8, i8* %arrayidx, align 1, !tbaa !6
  %tobool205 = icmp ne i8 %83, 0
  br i1 %tobool205, label %if.else, label %if.then206

if.then206:                                       ; preds = %land.lhs.true204
  %arrayidx207 = getelementptr inbounds [8 x i8], [8 x i8]* %BT_CAP, i64 0, i64 3
  %84 = load i8, i8* %arrayidx207, align 1, !tbaa !6
  %conv208 = zext i8 %84 to i32
  %BT_CAP_outreqs209 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 12
  store i32 %conv208, i32* %BT_CAP_outreqs209, align 4, !tbaa !218
  %arrayidx210 = getelementptr inbounds [8 x i8], [8 x i8]* %BT_CAP, i64 0, i64 6
  %85 = load i8, i8* %arrayidx210, align 1, !tbaa !6
  %conv211 = zext i8 %85 to i32
  %mul = mul nsw i32 %conv211, 1000000
  %conv212 = sext i32 %mul to i64
  %BT_CAP_req2rsp213 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 13
  store i64 %conv212, i64* %BT_CAP_req2rsp213, align 8, !tbaa !210
  %arrayidx214 = getelementptr inbounds [8 x i8], [8 x i8]* %BT_CAP, i64 0, i64 7
  %86 = load i8, i8* %arrayidx214, align 1, !tbaa !6
  %conv215 = zext i8 %86 to i32
  %BT_CAP_retries = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 14
  store i32 %conv215, i32* %BT_CAP_retries, align 8, !tbaa !211
  br label %if.end217

if.else:                                          ; preds = %land.lhs.true204, %sw.bb197
  %87 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end217

if.end217:                                        ; preds = %if.else, %if.then206
  %BT_CAP_outreqs218 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 12
  %88 = load i32, i32* %BT_CAP_outreqs218, align 4, !tbaa !218
  %tobool219 = icmp ne i32 %88, 0
  br i1 %tobool219, label %if.end222, label %if.then220

if.then220:                                       ; preds = %if.end217
  %BT_CAP_outreqs221 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 12
  store i32 1, i32* %BT_CAP_outreqs221, align 4, !tbaa !218
  br label %if.end222

if.end222:                                        ; preds = %if.then220, %if.end217
  %89 = call i32 (i8*, ...) @printk(i8* null)
  %BT_CAP_req2rsp226 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 13
  %90 = load i64, i64* %BT_CAP_req2rsp226, align 8, !tbaa !210
  %timeout227 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 8
  store i64 %90, i64* %timeout227, align 8, !tbaa !216
  br label %cleanup

sw.default:                                       ; preds = %LeafBlock, %LeafBlock15, %LeafBlock19
  %call228 = call i32 @error_recovery(%struct.si_sm_data.22* %bt, i8 zeroext %call, i8 zeroext -1)
  br label %cleanup

cleanup:                                          ; preds = %sw.default, %if.end222, %sw.bb191, %sw.bb186, %if.end184, %sw.bb179, %sw.bb158, %sw.bb156, %if.then152, %sw.bb148, %if.end143, %if.then141, %if.end122, %if.then118, %if.end106, %if.then105, %if.end99, %if.then98, %if.end86, %if.end76, %if.then63, %if.end57, %if.then55, %if.then42, %if.then34, %if.then16
  %retval.0 = phi i32 [ 1, %if.then16 ], [ %call35, %if.then34 ], [ 6, %if.then42 ], [ 4, %if.end57 ], [ 0, %if.then55 ], [ %call228, %sw.default ], [ 1, %if.then63 ], [ 0, %if.end76 ], [ 0, %if.end86 ], [ 1, %if.then98 ], [ 0, %if.end99 ], [ 0, %if.end106 ], [ 1, %if.then105 ], [ 1, %if.then118 ], [ 0, %if.end122 ], [ %cond, %if.end143 ], [ 0, %if.then141 ], [ 1, %sw.bb156 ], [ 1, %sw.bb158 ], [ 1, %if.end184 ], [ 1, %sw.bb186 ], [ 1, %sw.bb191 ], [ 0, %if.end222 ], [ 1, %if.then152 ], [ 1, %sw.bb148 ], [ 1, %sw.bb179 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_detect(%struct.si_sm_data.22* %bt) #0 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !205
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !193
  %io1 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !205
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 0)
  %conv = zext i8 %call to i32
  %cmp = icmp eq i32 %conv, 255
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %io3 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %3 = load %struct.si_sm_io*, %struct.si_sm_io** %io3, align 8, !tbaa !205
  %inputb4 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %3, i32 0, i32 0
  %4 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb4, align 8, !tbaa !193
  %io5 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %5 = load %struct.si_sm_io*, %struct.si_sm_io** %io5, align 8, !tbaa !205
  %call6 = call zeroext i8 %4(%struct.si_sm_io* %5, i32 2)
  %conv7 = zext i8 %call6 to i32
  %cmp8 = icmp eq i32 %conv7, 255
  br i1 %cmp8, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  call void @reset_flags(%struct.si_sm_data.22* %bt)
  br label %return

return:                                           ; preds = %if.end, %land.lhs.true
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %land.lhs.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @bt_cleanup(%struct.si_sm_data.22* %bt) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bt_size() #0 {
entry:
  ret i32 624
}

; Function Attrs: nounwind uwtable
define internal void @reset_flags(%struct.si_sm_data.22* %bt) #0 {
entry:
  %0 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %io = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %1 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !205
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %1, i32 0, i32 0
  %2 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !193
  %io1 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %3 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !205
  %call = call zeroext i8 %2(%struct.si_sm_io* %3, i32 0)
  call void @status2txt(i8 zeroext %call)
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %io4 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %5 = load %struct.si_sm_io*, %struct.si_sm_io** %io4, align 8, !tbaa !205
  %inputb5 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %5, i32 0, i32 0
  %6 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb5, align 8, !tbaa !193
  %io6 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %7 = load %struct.si_sm_io*, %struct.si_sm_io** %io6, align 8, !tbaa !205
  %call7 = call zeroext i8 %6(%struct.si_sm_io* %7, i32 0)
  %conv = zext i8 %call7 to i32
  %and = and i32 %conv, 64
  %tobool8 = icmp ne i32 %and, 0
  br i1 %tobool8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %io10 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %8 = load %struct.si_sm_io*, %struct.si_sm_io** %io10, align 8, !tbaa !205
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %8, i32 0, i32 1
  %9 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !194
  %io11 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %10 = load %struct.si_sm_io*, %struct.si_sm_io** %io11, align 8, !tbaa !205
  call void %9(%struct.si_sm_io* %10, i32 0, i8 zeroext 64)
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end
  %io13 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %11 = load %struct.si_sm_io*, %struct.si_sm_io** %io13, align 8, !tbaa !205
  %outputb14 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %11, i32 0, i32 1
  %12 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb14, align 8, !tbaa !194
  %io15 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %13 = load %struct.si_sm_io*, %struct.si_sm_io** %io15, align 8, !tbaa !205
  call void %12(%struct.si_sm_io* %13, i32 0, i8 zeroext 1)
  %io16 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %14 = load %struct.si_sm_io*, %struct.si_sm_io** %io16, align 8, !tbaa !205
  %outputb17 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %14, i32 0, i32 1
  %15 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb17, align 8, !tbaa !194
  %io18 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %16 = load %struct.si_sm_io*, %struct.si_sm_io** %io18, align 8, !tbaa !205
  call void %15(%struct.si_sm_io* %16, i32 0, i8 zeroext 16)
  %io19 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %17 = load %struct.si_sm_io*, %struct.si_sm_io** %io19, align 8, !tbaa !205
  %outputb20 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %17, i32 0, i32 1
  %18 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb20, align 8, !tbaa !194
  %io21 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %19 = load %struct.si_sm_io*, %struct.si_sm_io** %io21, align 8, !tbaa !205
  call void %18(%struct.si_sm_io* %19, i32 2, i8 zeroext -128)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @status2txt(i8 zeroext %status) #0 {
entry:
  %call = call i8* @strcpy(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23.120, i32 0, i32 0))
  %conv = zext i8 %status to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24.121, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %conv2 = zext i8 %status to i32
  %and3 = and i32 %conv2, 64
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.25.122, i32 0, i32 0))
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %conv8 = zext i8 %status to i32
  %and9 = and i32 %conv8, 32
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end7
  %call12 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.26.123, i32 0, i32 0))
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end7
  %conv14 = zext i8 %status to i32
  %and15 = and i32 %conv14, 16
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end13
  %call18 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27.124, i32 0, i32 0))
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end13
  %conv20 = zext i8 %status to i32
  %and21 = and i32 %conv20, 8
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end19
  %call24 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.28.125, i32 0, i32 0))
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end19
  %conv26 = zext i8 %status to i32
  %and27 = and i32 %conv26, 4
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end25
  %call30 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.29.126, i32 0, i32 0))
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end25
  %call32 = call i8* @strcat(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @status2txt.buf, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.30.127, i32 0, i32 0))
  ret void
}

declare i8* @strcpy(i8*, i8*) #1

declare i8* @strcat(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @state2txt(i8 zeroext %state) #0 {
entry:
  %conv = zext i8 %state to i32
  %Pivot28 = icmp slt i32 %conv, 7
  br i1 %Pivot28, label %NodeBlock9, label %NodeBlock25

NodeBlock25:                                      ; preds = %entry
  %Pivot26 = icmp slt i32 %conv, 10
  br i1 %Pivot26, label %NodeBlock13, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %conv, 13
  br i1 %Pivot24, label %NodeBlock17, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %conv, 14
  br i1 %Pivot22, label %return, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %conv, 14
  br i1 %SwitchLeaf20, label %return, label %sw.epilog

NodeBlock17:                                      ; preds = %NodeBlock23
  %Pivot18 = icmp slt i32 %conv, 12
  br i1 %Pivot18, label %LeafBlock15, label %return

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf16, label %return, label %sw.epilog

NodeBlock13:                                      ; preds = %NodeBlock25
  %Pivot14 = icmp slt i32 %conv, 8
  br i1 %Pivot14, label %return, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  br label %return

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %conv, 3
  br i1 %Pivot10, label %NodeBlock1, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %conv, 5
  br i1 %Pivot8, label %NodeBlock3, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  br label %return

NodeBlock3:                                       ; preds = %NodeBlock7
  br label %return

NodeBlock1:                                       ; preds = %NodeBlock9
  %Pivot2 = icmp slt i32 %conv, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  br label %return

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %conv, 0
  br i1 %SwitchLeaf, label %return, label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock15, %LeafBlock19
  br label %return

return:                                           ; preds = %sw.epilog, %LeafBlock, %NodeBlock, %NodeBlock3, %NodeBlock5, %NodeBlock11, %NodeBlock13, %LeafBlock15, %NodeBlock17, %LeafBlock19, %NodeBlock21
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @drain_BMC2HOST(%struct.si_sm_data.22* %bt) #0 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !205
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !193
  %io1 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !205
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 0)
  %conv = zext i8 %call to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %io2 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %3 = load %struct.si_sm_io*, %struct.si_sm_io** %io2, align 8, !tbaa !205
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %3, i32 0, i32 1
  %4 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !194
  %io3 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %5 = load %struct.si_sm_io*, %struct.si_sm_io** %io3, align 8, !tbaa !205
  call void %4(%struct.si_sm_io* %5, i32 0, i8 zeroext 64)
  %io4 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %6 = load %struct.si_sm_io*, %struct.si_sm_io** %io4, align 8, !tbaa !205
  %outputb5 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %6, i32 0, i32 1
  %7 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb5, align 8, !tbaa !194
  %io6 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %8 = load %struct.si_sm_io*, %struct.si_sm_io** %io6, align 8, !tbaa !205
  call void %7(%struct.si_sm_io* %8, i32 0, i8 zeroext 8)
  %io7 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %9 = load %struct.si_sm_io*, %struct.si_sm_io** %io7, align 8, !tbaa !205
  %inputb8 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %9, i32 0, i32 0
  %10 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb8, align 8, !tbaa !193
  %io9 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %11 = load %struct.si_sm_io*, %struct.si_sm_io** %io9, align 8, !tbaa !205
  %call10 = call zeroext i8 %10(%struct.si_sm_io* %11, i32 0)
  %io11 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %12 = load %struct.si_sm_io*, %struct.si_sm_io** %io11, align 8, !tbaa !205
  %outputb12 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %12, i32 0, i32 1
  %13 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb12, align 8, !tbaa !194
  %io13 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %14 = load %struct.si_sm_io*, %struct.si_sm_io** %io13, align 8, !tbaa !205
  call void %13(%struct.si_sm_io* %14, i32 0, i8 zeroext 8)
  %io14 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %15 = load %struct.si_sm_io*, %struct.si_sm_io** %io14, align 8, !tbaa !205
  %outputb15 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %15, i32 0, i32 1
  %16 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb15, align 8, !tbaa !194
  %io16 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %17 = load %struct.si_sm_io*, %struct.si_sm_io** %io16, align 8, !tbaa !205
  call void %16(%struct.si_sm_io* %17, i32 0, i8 zeroext 2)
  %18 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %tobool17 = icmp ne i32 %18, 0
  br i1 %tobool17, label %if.then18, label %if.end25

if.then18:                                        ; preds = %if.end
  %io19 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %19 = load %struct.si_sm_io*, %struct.si_sm_io** %io19, align 8, !tbaa !205
  %inputb20 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %19, i32 0, i32 0
  %20 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb20, align 8, !tbaa !193
  %io21 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %21 = load %struct.si_sm_io*, %struct.si_sm_io** %io21, align 8, !tbaa !205
  %call22 = call zeroext i8 %20(%struct.si_sm_io* %21, i32 0)
  call void @status2txt(i8 zeroext %call22)
  %22 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end25

if.end25:                                         ; preds = %if.then18, %if.end
  %io26 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %23 = load %struct.si_sm_io*, %struct.si_sm_io** %io26, align 8, !tbaa !205
  %inputb27 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %23, i32 0, i32 0
  %24 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb27, align 8, !tbaa !193
  %io28 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %25 = load %struct.si_sm_io*, %struct.si_sm_io** %io28, align 8, !tbaa !205
  %call29 = call zeroext i8 %24(%struct.si_sm_io* %25, i32 1)
  %conv30 = zext i8 %call29 to i32
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end25
  %i.0 = phi i32 [ 0, %if.end25 ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, %conv30
  %io32 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %26 = load %struct.si_sm_io*, %struct.si_sm_io** %io32, align 8, !tbaa !205
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %inputb33 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %26, i32 0, i32 0
  %27 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb33, align 8, !tbaa !193
  %io34 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %28 = load %struct.si_sm_io*, %struct.si_sm_io** %io34, align 8, !tbaa !205
  %call35 = call zeroext i8 %27(%struct.si_sm_io* %28, i32 1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %outputb37 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %26, i32 0, i32 1
  %29 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb37, align 8, !tbaa !194
  %io38 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %30 = load %struct.si_sm_io*, %struct.si_sm_io** %io38, align 8, !tbaa !205
  call void %29(%struct.si_sm_io* %30, i32 0, i8 zeroext 64)
  %31 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %tobool39 = icmp ne i32 %31, 0
  br i1 %tobool39, label %if.then40, label %cleanup.cont

if.then40:                                        ; preds = %for.end
  %32 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then40, %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @error_recovery(%struct.si_sm_data.22* %bt, i8 zeroext %status, i8 zeroext %cCode) #0 {
entry:
  %BT_CAP_req2rsp = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 13
  %0 = load i64, i64* %BT_CAP_req2rsp, align 8, !tbaa !210
  %timeout = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 8
  store i64 %0, i64* %timeout, align 8, !tbaa !216
  %state = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  %1 = load i32, i32* %state, align 8, !tbaa !208
  %conv1 = trunc i32 %1 to i8
  call void @state2txt(i8 zeroext %conv1)
  call void @status2txt(i8 zeroext %status)
  %2 = call i32 (i8*, ...) @printk(i8* null)
  %error_retries = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 9
  %3 = load i32, i32* %error_retries, align 8, !tbaa !213
  %inc = add nsw i32 %3, 1
  store i32 %inc, i32* %error_retries, align 8, !tbaa !213
  %error_retries4 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 9
  %4 = load i32, i32* %error_retries4, align 8, !tbaa !213
  %BT_CAP_retries = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 14
  %5 = load i32, i32* %BT_CAP_retries, align 8, !tbaa !211
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = call i32 (i8*, ...) @printk(i8* null)
  %state9 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 10, i32* %state9, align 8, !tbaa !208
  br label %cleanup

if.end:                                           ; preds = %entry
  %7 = call i32 (i8*, ...) @printk(i8* null)
  %nonzero_status = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 10
  %8 = load i32, i32* %nonzero_status, align 4, !tbaa !214
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.end
  %9 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end24

if.else:                                          ; preds = %if.end
  %seq = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 1
  %10 = load i8, i8* %seq, align 4, !tbaa !207
  %conv14 = zext i8 %10 to i32
  %BT_CAP_retries15 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 14
  %11 = load i32, i32* %BT_CAP_retries15, align 8, !tbaa !211
  %and = and i32 %11, 255
  %conv16 = trunc i32 %and to i8
  %conv17 = zext i8 %conv16 to i32
  %cmp18 = icmp sle i32 %conv14, %conv17
  br i1 %cmp18, label %if.then20, label %if.end24

if.then20:                                        ; preds = %if.else
  %12 = call i32 (i8*, ...) @printk(i8* null)
  %state22 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 7, i32* %state22, align 8, !tbaa !208
  br label %cleanup

if.end24:                                         ; preds = %if.else, %if.then12
  %state25 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 0, i32* %state25, align 8, !tbaa !208
  %conv26 = zext i8 %cCode to i32
  %SwitchLeaf3 = icmp eq i32 %conv26, 195
  br i1 %SwitchLeaf3, label %sw.bb27, label %sw.epilog35

sw.bb27:                                          ; preds = %if.end24
  %conv28 = zext i8 %status to i32
  %and29 = and i32 %conv28, 128
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.then31, label %sw.epilog35

if.then31:                                        ; preds = %sw.bb27
  %state32 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 0
  store i32 14, i32* %state32, align 8, !tbaa !208
  br label %sw.epilog35

sw.epilog35:                                      ; preds = %if.then31, %sw.bb27, %if.end24
  %cCode.addr.1 = phi i8 [ -64, %if.then31 ], [ %cCode, %sw.bb27 ], [ %cCode, %if.end24 ]
  call void @force_result(%struct.si_sm_data.22* %bt, i8 zeroext %cCode.addr.1)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog35, %if.then20, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 0, %if.then20 ], [ 3, %sw.epilog35 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @write_all_bytes(%struct.si_sm_data.22* %bt) #3 {
entry:
  %0 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = call i32 (i8*, ...) @printk(i8* null)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %write_count1 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 4
  %2 = load i32, i32* %write_count1, align 4, !tbaa !212
  %cmp = icmp slt i32 %i.0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = call i32 (i8*, ...) @printk(i8* null)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  br label %for.cond6

for.cond6:                                        ; preds = %for.body10, %if.end
  %i.1 = phi i32 [ 0, %if.end ], [ %inc16, %for.body10 ]
  %write_count7 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 4
  %5 = load i32, i32* %write_count7, align 4, !tbaa !212
  %cmp8 = icmp slt i32 %i.1, %5
  br i1 %cmp8, label %for.body10, label %for.end17

for.body10:                                       ; preds = %for.cond6
  %io = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %6 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !205
  %outputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %6, i32 0, i32 1
  %7 = load void (%struct.si_sm_io*, i32, i8)*, void (%struct.si_sm_io*, i32, i8)** %outputb, align 8, !tbaa !194
  %io11 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %8 = load %struct.si_sm_io*, %struct.si_sm_io** %io11, align 8, !tbaa !205
  %write_data12 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %idxprom13 = sext i32 %i.1 to i64
  %arrayidx14 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data12, i64 0, i64 %idxprom13
  %9 = load i8, i8* %arrayidx14, align 1, !tbaa !6
  call void %7(%struct.si_sm_io* %8, i32 1, i8 zeroext %9)
  %inc16 = add nsw i32 %i.1, 1
  br label %for.cond6

for.end17:                                        ; preds = %for.cond6
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @read_all_bytes(%struct.si_sm_data.22* %bt) #3 {
entry:
  %io = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %0 = load %struct.si_sm_io*, %struct.si_sm_io** %io, align 8, !tbaa !205
  %inputb = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %0, i32 0, i32 0
  %1 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb, align 8, !tbaa !193
  %io1 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %2 = load %struct.si_sm_io*, %struct.si_sm_io** %io1, align 8, !tbaa !205
  %call = call zeroext i8 %1(%struct.si_sm_io* %2, i32 1)
  %read_data = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx = getelementptr inbounds [274 x i8], [274 x i8]* %read_data, i64 0, i64 0
  store i8 %call, i8* %arrayidx, align 8, !tbaa !6
  %read_data2 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx3 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data2, i64 0, i64 0
  %3 = load i8, i8* %arrayidx3, align 8, !tbaa !6
  %conv = zext i8 %3 to i32
  %read_count = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 6
  store i32 %conv, i32* %read_count, align 4, !tbaa !217
  %read_count4 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 6
  %4 = load i32, i32* %read_count4, align 4, !tbaa !217
  %cmp = icmp slt i32 %4, 4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %read_count6 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 6
  %5 = load i32, i32* %read_count6, align 4, !tbaa !217
  %cmp7 = icmp sge i32 %5, 272
  br i1 %cmp7, label %if.then, label %if.end12

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and = and i32 %6, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.then
  %7 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.then
  %truncated = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 7
  store i32 1, i32* %truncated, align 8, !tbaa !215
  br label %cleanup

if.end12:                                         ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end12
  %i.0 = phi i8 [ 1, %if.end12 ], [ %inc, %for.body ]
  %conv13 = zext i8 %i.0 to i32
  %read_count14 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 6
  %8 = load i32, i32* %read_count14, align 4, !tbaa !217
  %cmp15 = icmp sle i32 %conv13, %8
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %io17 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %9 = load %struct.si_sm_io*, %struct.si_sm_io** %io17, align 8, !tbaa !205
  %inputb18 = getelementptr inbounds %struct.si_sm_io, %struct.si_sm_io* %9, i32 0, i32 0
  %10 = load i8 (%struct.si_sm_io*, i32)*, i8 (%struct.si_sm_io*, i32)** %inputb18, align 8, !tbaa !193
  %io19 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 2
  %11 = load %struct.si_sm_io*, %struct.si_sm_io** %io19, align 8, !tbaa !205
  %call20 = call zeroext i8 %10(%struct.si_sm_io* %11, i32 1)
  %read_data21 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %idxprom = zext i8 %i.0 to i64
  %arrayidx22 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data21, i64 0, i64 %idxprom
  store i8 %call20, i8* %arrayidx22, align 1, !tbaa !6
  %inc = add i8 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %read_count23 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 6
  %12 = load i32, i32* %read_count23, align 4, !tbaa !217
  %inc24 = add nsw i32 %12, 1
  store i32 %inc24, i32* %read_count23, align 4, !tbaa !217
  %13 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and25 = and i32 %13, 2
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then27, label %if.end54

if.then27:                                        ; preds = %for.end
  %read_count28 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 6
  %14 = load i32, i32* %read_count28, align 4, !tbaa !217
  %15 = call i32 (i8*, ...) @printk(i8* null)
  %cmp33 = icmp sgt i32 %14, 16
  %. = select i1 %cmp33, i32 16, i32 %14
  br label %for.cond37

for.cond37:                                       ; preds = %for.body41, %if.then27
  %i.1 = phi i8 [ 0, %if.then27 ], [ %inc48, %for.body41 ]
  %conv38 = zext i8 %i.1 to i32
  %cmp39 = icmp slt i32 %conv38, %.
  br i1 %cmp39, label %for.body41, label %for.end49

for.body41:                                       ; preds = %for.cond37
  %16 = call i32 (i8*, ...) @printk(i8* null)
  %inc48 = add i8 %i.1, 1
  br label %for.cond37

for.end49:                                        ; preds = %for.cond37
  %17 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end54

if.end54:                                         ; preds = %for.end49, %for.end
  %read_data55 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx56 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data55, i64 0, i64 3
  %18 = load i8, i8* %arrayidx56, align 1, !tbaa !6
  %conv57 = zext i8 %18 to i32
  %write_data = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %arrayidx58 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data, i64 0, i64 3
  %19 = load i8, i8* %arrayidx58, align 1, !tbaa !6
  %conv59 = zext i8 %19 to i32
  %cmp60 = icmp eq i32 %conv57, %conv59
  br i1 %cmp60, label %land.lhs.true, label %if.end82

land.lhs.true:                                    ; preds = %if.end54
  %read_data62 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx63 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data62, i64 0, i64 2
  %20 = load i8, i8* %arrayidx63, align 2, !tbaa !6
  %conv64 = zext i8 %20 to i32
  %write_data65 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %arrayidx66 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data65, i64 0, i64 2
  %21 = load i8, i8* %arrayidx66, align 2, !tbaa !6
  %conv67 = zext i8 %21 to i32
  %cmp68 = icmp eq i32 %conv64, %conv67
  br i1 %cmp68, label %land.lhs.true70, label %if.end82

land.lhs.true70:                                  ; preds = %land.lhs.true
  %read_data71 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx72 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data71, i64 0, i64 1
  %22 = load i8, i8* %arrayidx72, align 1, !tbaa !6
  %conv73 = zext i8 %22 to i32
  %and74 = and i32 %conv73, 248
  %write_data75 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %arrayidx76 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data75, i64 0, i64 1
  %23 = load i8, i8* %arrayidx76, align 1, !tbaa !6
  %conv77 = zext i8 %23 to i32
  %and78 = and i32 %conv77, 248
  %cmp79 = icmp eq i32 %and74, %and78
  br i1 %cmp79, label %cleanup, label %if.end82

if.end82:                                         ; preds = %land.lhs.true70, %land.lhs.true, %if.end54
  %24 = load i32, i32* @bt_debug, align 4, !tbaa !2
  %and83 = and i32 %24, 2
  %tobool84 = icmp ne i32 %and83, 0
  br i1 %tobool84, label %if.then85, label %cleanup

if.then85:                                        ; preds = %if.end82
  %25 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.then85, %if.end82, %land.lhs.true70, %if.end
  %retval.0 = phi i32 [ 1, %if.end ], [ 1, %land.lhs.true70 ], [ 0, %if.then85 ], [ 0, %if.end82 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @force_result(%struct.si_sm_data.22* %bt, i8 zeroext %completion_code) #0 {
entry:
  %read_data = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx = getelementptr inbounds [274 x i8], [274 x i8]* %read_data, i64 0, i64 0
  store i8 4, i8* %arrayidx, align 8, !tbaa !6
  %write_data = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %arrayidx1 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data, i64 0, i64 1
  %0 = load i8, i8* %arrayidx1, align 1, !tbaa !6
  %conv = zext i8 %0 to i32
  %or = or i32 %conv, 4
  %conv2 = trunc i32 %or to i8
  %read_data3 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx4 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data3, i64 0, i64 1
  store i8 %conv2, i8* %arrayidx4, align 1, !tbaa !6
  %write_data5 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %arrayidx6 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data5, i64 0, i64 2
  %1 = load i8, i8* %arrayidx6, align 2, !tbaa !6
  %read_data7 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx8 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data7, i64 0, i64 2
  store i8 %1, i8* %arrayidx8, align 2, !tbaa !6
  %write_data9 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 3
  %arrayidx10 = getelementptr inbounds [274 x i8], [274 x i8]* %write_data9, i64 0, i64 3
  %2 = load i8, i8* %arrayidx10, align 1, !tbaa !6
  %read_data11 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx12 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data11, i64 0, i64 3
  store i8 %2, i8* %arrayidx12, align 1, !tbaa !6
  %read_data13 = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 5
  %arrayidx14 = getelementptr inbounds [274 x i8], [274 x i8]* %read_data13, i64 0, i64 4
  store i8 %completion_code, i8* %arrayidx14, align 4, !tbaa !6
  %read_count = getelementptr inbounds %struct.si_sm_data.22, %struct.si_sm_data.22* %bt, i32 0, i32 6
  store i32 5, i32* %read_count, align 4, !tbaa !217
  ret void
}

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone }
attributes #5 = { nounwind }

!llvm.ident = !{!0, !0, !0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!4, !4, i64 0}
!7 = !{!8, !8, i64 0}
!8 = !{!"any pointer", !4, i64 0}
!9 = !{!10, !4, i64 244}
!10 = !{!"smi_info", !3, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !4, i64 32, !11, i64 40, !12, i64 112, !12, i64 128, !8, i64 144, !4, i64 152, !13, i64 160, !8, i64 208, !8, i64 216, !8, i64 224, !8, i64 232, !3, i64 240, !4, i64 244, !8, i64 248, !8, i64 256, !8, i64 264, !4, i64 272, !4, i64 273, !15, i64 276, !3, i64 280, !3, i64 284, !3, i64 288, !3, i64 292, !16, i64 296, !14, i64 424, !15, i64 432, !3, i64 436, !18, i64 440, !8, i64 464, !8, i64 472, !3, i64 480, !4, i64 484, !4, i64 488, !8, i64 536, !12, i64 544, !4, i64 560}
!11 = !{!"spinlock", !4, i64 0}
!12 = !{!"list_head", !8, i64 0, !8, i64 8}
!13 = !{!"si_sm_io", !8, i64 0, !8, i64 8, !8, i64 16, !3, i64 24, !3, i64 28, !3, i64 32, !3, i64 36, !14, i64 40}
!14 = !{!"long", !4, i64 0}
!15 = !{!"", !3, i64 0}
!16 = !{!"timer_list", !12, i64 0, !14, i64 16, !8, i64 24, !8, i64 32, !14, i64 40, !3, i64 48, !3, i64 52, !8, i64 56, !4, i64 64, !17, i64 80}
!17 = !{!"lockdep_map", !8, i64 0, !4, i64 8, !8, i64 24, !3, i64 32, !14, i64 40}
!18 = !{!"ipmi_device_id", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3, !4, i64 4, !4, i64 5, !3, i64 8, !3, i64 12, !4, i64 16, !3, i64 20}
!19 = !{!10, !4, i64 32}
!20 = !{!10, !14, i64 200}
!21 = !{!10, !3, i64 196}
!22 = !{!10, !8, i64 208}
!23 = !{!10, !8, i64 176}
!24 = !{!10, !3, i64 184}
!25 = !{!10, !3, i64 188}
!26 = !{!10, !3, i64 192}
!27 = !{!10, !3, i64 292}
!28 = !{!10, !8, i64 224}
!29 = !{!10, !4, i64 484}
!30 = !{!12, !8, i64 0}
!31 = !{!10, !8, i64 544}
!32 = !{!33, !8, i64 0}
!33 = !{!"hotmod_vals", !8, i64 0, !3, i64 8}
!34 = !{!33, !3, i64 8}
!35 = !{!10, !8, i64 216}
!36 = !{!10, !8, i64 160}
!37 = !{!10, !8, i64 168}
!38 = !{!10, !3, i64 240}
!39 = !{!10, !8, i64 232}
!40 = !{!10, !8, i64 8}
!41 = !{!10, !8, i64 16}
!42 = !{!10, !8, i64 24}
!43 = !{!44, !8, i64 56}
!44 = !{!"si_sm_handlers", !8, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !8, i64 56}
!45 = !{!44, !8, i64 8}
!46 = !{!44, !8, i64 40}
!47 = !{!10, !8, i64 144}
!48 = !{!10, !3, i64 280}
!49 = !{!10, !3, i64 436}
!50 = !{!10, !3, i64 0}
!51 = !{!10, !4, i64 273}
!52 = !{!10, !4, i64 152}
!53 = !{!10, !8, i64 464}
!54 = !{!10, !8, i64 472}
!55 = !{!56, !8, i64 272}
!56 = !{!"device", !8, i64 0, !8, i64 8, !57, i64 16, !8, i64 80, !8, i64 88, !59, i64 96, !8, i64 264, !8, i64 272, !8, i64 280, !60, i64 288, !8, i64 880, !3, i64 888, !8, i64 896, !67, i64 904, !8, i64 912, !12, i64 920, !8, i64 936, !68, i64 944, !8, i64 960, !69, i64 968, !3, i64 976, !3, i64 980, !11, i64 984, !12, i64 1056, !70, i64 1072, !8, i64 1104, !8, i64 1112, !8, i64 1120, !8, i64 1128}
!57 = !{!"kobject", !8, i64 0, !12, i64 8, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !58, i64 56, !3, i64 60, !3, i64 60, !3, i64 60, !3, i64 60, !3, i64 60}
!58 = !{!"kref", !15, i64 0}
!59 = !{!"mutex", !15, i64 0, !11, i64 8, !12, i64 80, !8, i64 96, !8, i64 104, !8, i64 112, !17, i64 120}
!60 = !{!"dev_pm_info", !61, i64 0, !3, i64 4, !3, i64 4, !62, i64 4, !62, i64 4, !62, i64 4, !62, i64 4, !11, i64 8, !12, i64 80, !63, i64 96, !8, i64 192, !62, i64 200, !62, i64 200, !16, i64 208, !14, i64 336, !65, i64 344, !64, i64 424, !15, i64 512, !15, i64 516, !3, i64 520, !3, i64 520, !3, i64 520, !3, i64 520, !3, i64 520, !3, i64 520, !3, i64 521, !3, i64 521, !3, i64 521, !3, i64 521, !3, i64 521, !4, i64 524, !4, i64 528, !3, i64 532, !3, i64 536, !14, i64 544, !14, i64 552, !14, i64 560, !14, i64 568, !8, i64 576, !8, i64 584}
!61 = !{!"pm_message", !3, i64 0}
!62 = !{!"_Bool", !4, i64 0}
!63 = !{!"completion", !3, i64 0, !64, i64 8}
!64 = !{!"__wait_queue_head", !11, i64 0, !12, i64 72}
!65 = !{!"work_struct", !66, i64 0, !12, i64 8, !8, i64 24, !17, i64 32}
!66 = !{!"", !14, i64 0}
!67 = !{!"long long", !4, i64 0}
!68 = !{!"dev_archdata", !8, i64 0, !8, i64 8}
!69 = !{!"acpi_dev_node", !8, i64 0}
!70 = !{!"klist_node", !8, i64 0, !12, i64 8, !58, i64 24}
!71 = !{!10, !3, i64 480}
!72 = !{!44, !8, i64 48}
!73 = !{!10, !8, i64 248}
!74 = !{i32 -2146130833, i32 -2146130794, i32 -2146130773, i32 -2146130736, i32 -2146130713, i32 -2146130843}
!75 = !{!10, !8, i64 536}
!76 = !{!14, !14, i64 0}
!77 = !{!44, !8, i64 16}
!78 = !{!44, !8, i64 32}
!79 = !{!80, !3, i64 32}
!80 = !{!"ipmi_smi_msg", !12, i64 0, !14, i64 16, !8, i64 24, !3, i64 32, !4, i64 36, !3, i64 308, !4, i64 312, !8, i64 584}
!81 = !{!44, !8, i64 24}
!82 = !{!80, !3, i64 308}
!83 = !{!10, !4, i64 272}
!84 = !{!80, !8, i64 584}
!85 = !{!15, !3, i64 0}
!86 = !{!10, !8, i64 264}
!87 = !{!12, !8, i64 8}
!88 = !{!89, !8, i64 240}
!89 = !{!"seq_file", !8, i64 0, !14, i64 8, !14, i64 16, !14, i64 24, !67, i64 32, !67, i64 40, !67, i64 48, !59, i64 56, !8, i64 224, !3, i64 232, !8, i64 240}
!90 = !{!16, !8, i64 32}
!91 = !{!16, !14, i64 40}
!92 = !{!10, !14, i64 424}
!93 = !{!94, !4, i64 0}
!94 = !{!"ipmi_smi_info", !4, i64 0, !8, i64 8, !4, i64 16}
!95 = !{!94, !8, i64 8}
!96 = !{i64 0, i64 8, !7}
!97 = !{i32 -2146670842}
!98 = !{!99, !14, i64 8}
!99 = !{!"timespec", !14, i64 0, !14, i64 8}
!100 = !{!67, !67, i64 0}
!101 = !{i32 1307228}
!102 = !{!99, !14, i64 0}
!103 = !{!18, !3, i64 8}
!104 = !{!18, !4, i64 0}
!105 = !{!18, !4, i64 1}
!106 = !{!18, !4, i64 4}
!107 = !{!18, !4, i64 2}
!108 = !{!18, !4, i64 3}
!109 = !{!18, !4, i64 5}
!110 = !{!18, !3, i64 12}
!111 = !{!13, !14, i64 40}
!112 = !{!13, !3, i64 24}
!113 = !{!13, !3, i64 32}
!114 = !{i32 -2145484446}
!115 = !{i32 -2145481332}
!116 = !{i32 -2145482892}
!117 = !{i32 -2145484244}
!118 = !{i32 -2145481130}
!119 = !{i32 -2145482690}
!120 = !{!13, !8, i64 16}
!121 = !{i32 -2145501170}
!122 = !{i32 -2145499239}
!123 = !{i32 -2145500618}
!124 = !{i32 -2145502970}
!125 = !{i32 -2145499538}
!126 = !{i32 -2145502357}
!127 = !{i32 -2145502665}
!128 = !{!62, !62, i64 0}
!129 = !{i8 0, i8 2}
!130 = !{!131, !8, i64 32}
!131 = !{!"dmi_device", !12, i64 0, !3, i64 16, !8, i64 24, !8, i64 32}
!132 = !{!133, !3, i64 4}
!133 = !{!"ipmi_default_vals", !3, i64 0, !3, i64 4}
!134 = !{!133, !3, i64 0}
!135 = !{!136, !4, i64 37}
!136 = !{!"SPMITable", !4, i64 0, !3, i64 4, !4, i64 8, !4, i64 9, !4, i64 10, !4, i64 16, !4, i64 24, !4, i64 28, !4, i64 32, !4, i64 36, !4, i64 37, !137, i64 38, !4, i64 40, !4, i64 41, !137, i64 42, !3, i64 44, !138, i64 48, !4, i64 60, !4, i64 64}
!137 = !{!"short", !4, i64 0}
!138 = !{!"acpi_generic_address", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3, !67, i64 4}
!139 = !{!136, !4, i64 36}
!140 = !{!136, !4, i64 40}
!141 = !{!136, !4, i64 41}
!142 = !{!136, !3, i64 44}
!143 = !{!136, !4, i64 49}
!144 = !{!136, !4, i64 50}
!145 = !{!136, !4, i64 48}
!146 = !{!136, !67, i64 52}
!147 = !{!148, !4, i64 1}
!148 = !{!"dmi_header", !4, i64 0, !4, i64 1, !137, i64 2}
!149 = !{!150, !4, i64 0}
!150 = !{!"dmi_ipmi_data", !4, i64 0, !4, i64 1, !14, i64 8, !4, i64 16, !4, i64 17, !4, i64 18}
!151 = !{!150, !4, i64 1}
!152 = !{!150, !14, i64 8}
!153 = !{!150, !4, i64 16}
!154 = !{!150, !4, i64 17}
!155 = !{!150, !4, i64 18}
!156 = !{!157, !8, i64 8}
!157 = !{!"acpi_device", !3, i64 0, !8, i64 8, !8, i64 16, !12, i64 24, !12, i64 40, !12, i64 56, !158, i64 72, !159, i64 76, !160, i64 80, !162, i64 208, !164, i64 376, !166, i64 424, !168, i64 448, !8, i64 456, !8, i64 464, !8, i64 472, !56, i64 480, !4, i64 1616, !4, i64 1620, !12, i64 1624, !59, i64 1640, !4, i64 1808, !12, i64 1816, !8, i64 1832}
!158 = !{!"acpi_device_status", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0}
!159 = !{!"acpi_device_flags", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 1}
!160 = !{!"acpi_device_pnp", !4, i64 0, !161, i64 8, !14, i64 16, !8, i64 24, !12, i64 32, !4, i64 48, !4, i64 88, !8, i64 112, !14, i64 120}
!161 = !{!"acpi_pnp_type", !3, i64 0, !3, i64 0, !3, i64 0}
!162 = !{!"acpi_device_power", !3, i64 0, !163, i64 4, !4, i64 8}
!163 = !{!"acpi_device_power_flags", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0}
!164 = !{!"acpi_device_wakeup", !8, i64 0, !67, i64 8, !67, i64 16, !12, i64 24, !165, i64 40, !3, i64 44}
!165 = !{!"acpi_device_wakeup_flags", !4, i64 0, !4, i64 0, !4, i64 0}
!166 = !{!"acpi_device_perf", !3, i64 0, !167, i64 4, !3, i64 8, !8, i64 16}
!167 = !{!"acpi_device_perf_flags", !4, i64 0}
!168 = !{!"acpi_device_dir", !8, i64 0}
!169 = !{!170, !67, i64 0}
!170 = !{!"resource", !67, i64 0, !67, i64 8, !8, i64 16, !14, i64 24, !8, i64 32, !8, i64 40, !8, i64 48}
!171 = !{!172, !8, i64 1216}
!172 = !{!"pnp_dev", !56, i64 0, !67, i64 1136, !3, i64 1144, !3, i64 1148, !12, i64 1152, !12, i64 1168, !12, i64 1184, !12, i64 1200, !8, i64 1216, !8, i64 1224, !8, i64 1232, !8, i64 1240, !8, i64 1248, !3, i64 1256, !3, i64 1260, !3, i64 1264, !12, i64 1272, !12, i64 1288, !4, i64 1304, !3, i64 1356, !8, i64 1360, !8, i64 1368}
!173 = !{!172, !8, i64 1368}
!174 = !{!175, !3, i64 68}
!175 = !{!"pci_dev", !12, i64 0, !8, i64 16, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !3, i64 56, !137, i64 60, !137, i64 62, !137, i64 64, !137, i64 66, !3, i64 68, !4, i64 72, !4, i64 73, !4, i64 74, !4, i64 75, !4, i64 76, !4, i64 77, !4, i64 78, !4, i64 79, !137, i64 80, !8, i64 88, !67, i64 96, !176, i64 104, !3, i64 120, !4, i64 124, !3, i64 125, !3, i64 125, !3, i64 125, !3, i64 125, !3, i64 126, !3, i64 126, !3, i64 126, !3, i64 126, !3, i64 126, !3, i64 126, !3, i64 126, !3, i64 128, !3, i64 132, !8, i64 136, !3, i64 144, !56, i64 152, !3, i64 1288, !3, i64 1292, !4, i64 1296, !62, i64 2248, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2250, !3, i64 2250, !3, i64 2250, !3, i64 2250, !3, i64 2250, !3, i64 2250, !3, i64 2250, !3, i64 2251, !3, i64 2251, !3, i64 2251, !3, i64 2251, !3, i64 2251, !3, i64 2251, !3, i64 2251, !3, i64 2251, !137, i64 2252, !15, i64 2256, !4, i64 2260, !177, i64 2328, !8, i64 2336, !3, i64 2344, !4, i64 2352, !4, i64 2488, !12, i64 2624, !8, i64 2640, !8, i64 2648, !4, i64 2656, !8, i64 2664, !67, i64 2672, !14, i64 2680}
!176 = !{!"device_dma_parameters", !3, i64 0, !14, i64 8}
!177 = !{!"hlist_head", !8, i64 0}
!178 = !{!10, !8, i64 256}
!179 = !{!170, !14, i64 24}
!180 = !{!175, !3, i64 1292}
!181 = !{!182, !4, i64 0}
!182 = !{!"si_sm_data", !4, i64 0, !8, i64 8, !4, i64 16, !3, i64 288, !3, i64 292, !3, i64 296, !4, i64 300, !3, i64 572, !3, i64 576, !3, i64 580, !14, i64 584, !14, i64 592, !14, i64 600}
!183 = !{!182, !8, i64 8}
!184 = !{!182, !3, i64 288}
!185 = !{!182, !3, i64 292}
!186 = !{!182, !3, i64 296}
!187 = !{!182, !3, i64 572}
!188 = !{!182, !3, i64 580}
!189 = !{!182, !3, i64 576}
!190 = !{!182, !14, i64 584}
!191 = !{!182, !14, i64 592}
!192 = !{!182, !14, i64 600}
!193 = !{!13, !8, i64 0}
!194 = !{!13, !8, i64 8}
!195 = !{!196, !4, i64 0}
!196 = !{!"si_sm_data", !4, i64 0, !8, i64 8, !4, i64 16, !3, i64 96, !3, i64 100, !3, i64 104, !4, i64 108, !3, i64 188, !3, i64 192, !3, i64 196, !14, i64 200}
!197 = !{!196, !8, i64 8}
!198 = !{!196, !3, i64 96}
!199 = !{!196, !3, i64 100}
!200 = !{!196, !3, i64 104}
!201 = !{!196, !3, i64 188}
!202 = !{!196, !3, i64 196}
!203 = !{!196, !3, i64 192}
!204 = !{!196, !14, i64 200}
!205 = !{!206, !8, i64 8}
!206 = !{!"si_sm_data", !4, i64 0, !4, i64 4, !8, i64 8, !4, i64 16, !3, i64 292, !4, i64 296, !3, i64 572, !3, i64 576, !14, i64 584, !3, i64 592, !3, i64 596, !4, i64 600, !3, i64 604, !14, i64 608, !3, i64 616}
!207 = !{!206, !4, i64 4}
!208 = !{!206, !4, i64 0}
!209 = !{!206, !4, i64 600}
!210 = !{!206, !14, i64 608}
!211 = !{!206, !3, i64 616}
!212 = !{!206, !3, i64 292}
!213 = !{!206, !3, i64 592}
!214 = !{!206, !3, i64 596}
!215 = !{!206, !3, i64 576}
!216 = !{!206, !14, i64 584}
!217 = !{!206, !3, i64 572}
!218 = !{!206, !3, i64 604}
