; ModuleID = 'sound/oss/opl3.bc'
source_filename = "sound/oss/opl3.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.3 }
%union.anon.3 = type { i8* }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, %struct.memcg_batch_info, i32, %struct.atomic_t, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.atomic64_t = type { i64 }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file = type { %union.anon.0, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%union.anon.0 = type { %struct.list_head }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.25, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.1, i8* }
%union.anon.1 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.19, i32 }
%union.anon.19 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%union.anon.25 = type { %struct.list_head }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.20, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.21, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.24, i32, i32, %struct.hlist_head, %struct.atomic_t, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.20 = type { i32 }
%union.anon.21 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.22 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.22 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.7, i32 }
%union.anon.7 = type { i8* }
%struct.swap_info_struct = type opaque
%union.anon.24 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t, i32, i32, i8*, %struct.lockdep_map }
%union.arch_rwlock_t = type { i64 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.8, %union.anon.14, %union.anon.16, i64 }
%struct.anon.8 = type { %union.anon.9, %union.anon.10 }
%union.anon.9 = type { i64 }
%union.anon.10 = type { i64 }
%union.anon.14 = type { %struct.list_head }
%union.anon.16 = type { i64 }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %struct.atomic_t, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.27, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.28, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.29, %union.anon.30 }
%union.anon.27 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.28 = type { i64 }
%union.anon.29 = type { %struct.list_head }
%union.anon.30 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.31 }
%union.anon.31 = type { %struct.anon.32 }
%struct.anon.32 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.34, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.37 }
%union.anon.34 = type { %struct.anon.35 }
%struct.anon.35 = type { i64, i64 }
%union.anon.37 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.spinlock = type { %union.anon.4 }
%union.anon.4 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.arch_spinlock = type { %union.anon.5 }
%union.anon.5 = type { i32 }
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.39 }
%union.anon.39 = type { %struct.anon.43, [80 x i8] }
%struct.anon.43 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.atomic_t = type { i32 }
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.opl_devinfo = type { i32, i32, i32, i32, [18 x i32], [18 x %struct.voice_info], %struct.voice_alloc_info*, %struct.channel_info*, [256 x %struct.sbi_instrument], [18 x %struct.sbi_instrument*], %struct.synth_info, i32, i32, i8, i32 }
%struct.voice_info = type { i8, i64, i64, i64, i64, i32, i32, i32 }
%struct.voice_alloc_info = type { i32, i32, i32, [32 x i16], i32, [32 x i32] }
%struct.channel_info = type { i32, i32, i32, [128 x i8] }
%struct.sbi_instrument = type { i16, i16, i32, [32 x i8] }
%struct.synth_info = type { [30 x i8], i32, i32, i32, i32, i32, i32, i32, i32, [19 x i32] }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.synth_operations = type { %struct.module*, i8*, %struct.synth_info*, i32, i32, i32, i32 (i32, i32)*, void (i32)*, i32 (i32, i32, i8*)*, i32 (i32, i32, i32, i32)*, i32 (i32, i32, i32, i32)*, i32 (i32, i32, i32)*, void (i32)*, void (i32, i8*)*, i32 (i32, i32, i8*, i32, i32)*, void (i32, i32, i32)*, void (i32, i32, i32, i32)*, void (i32, i32, i32)*, void (i32, i32)*, void (i32, i32, i32)*, i32 (i32, i32, i32, %struct.voice_alloc_info*)*, void (i32, i32, i32)*, i32 (i32, i8*, i32)*, %struct.voice_alloc_info, [16 x %struct.channel_info], i32, [64 x i8], i32 }
%struct.physical_voice_info = type { i8, i8, i16, [4 x i8] }

@__param_str_io = internal constant [3 x i8] c"io\00", align 1
@param_ops_int = external global %struct.kernel_param_ops, align 8
@io = internal global i32 -1, align 4
@__param_io = internal constant %struct.kernel_param { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @__param_str_io, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 0, i16 -1, %union.anon.3 { i8* bitcast (i32* @io to i8*) } }, section "__param", align 8
@__UNIQUE_ID_iotype1206 = internal constant [16 x i8] c"parmtype=io:int\00", section ".modinfo", align 1
@__UNIQUE_ID_license1258 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@smp_ops = external global %struct.smp_ops, align 8
@.str = private unnamed_addr constant [82 x i8] c"\016YM3812 and OPL-3 driver Copyright (C) by Hannu Savolainen, Rob Hooft 1993-1996\0A\00", align 1
@__this_module = external global %struct.module, align 8
@me = internal global i32 0, align 4
@devc = internal global %struct.opl_devinfo* null, align 8
@.str.1 = private unnamed_addr constant [34 x i8] c"\013opl3: Only one OPL3 supported.\0A\00", align 1
@.str.2 = private unnamed_addr constant [66 x i8] c"\013opl3: Can't allocate memory for the device control structure \0A \00", align 1
@.str.3 = private unnamed_addr constant [5 x i8] c"OPL2\00", align 1
@ioport_resource = external global %struct.resource, align 8
@.str.4 = private unnamed_addr constant [38 x i8] c"\014opl3: I/O port 0x%x already in use\0A\00", align 1
@.str.5 = private unnamed_addr constant [24 x i8] c"\016OPL3 not detected %x\0A\00", align 1
@detected_model = internal global i32 0, align 4
@.str.6 = private unnamed_addr constant [5 x i8] c"OPL4\00", align 1
@.str.7 = private unnamed_addr constant [51 x i8] c"\013opl3: Device control structure not initialized.\0A\00", align 1
@.str.8 = private unnamed_addr constant [31 x i8] c"\014opl3: Too many synthesizers\0A\00", align 1
@opl3_operations = internal global %struct.synth_operations { %struct.module* @__this_module, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), %struct.synth_info* null, i32 0, i32 0, i32 0, i32 (i32, i32)* @opl3_open, void (i32)* @opl3_close, i32 (i32, i32, i8*)* @opl3_ioctl, i32 (i32, i32, i32, i32)* @opl3_kill_note, i32 (i32, i32, i32, i32)* @opl3_start_note, i32 (i32, i32, i32)* @opl3_set_instr, void (i32)* @opl3_reset, void (i32, i8*)* @opl3_hw_control, i32 (i32, i32, i8*, i32, i32)* @opl3_load_patch, void (i32, i32, i32)* @opl3_aftertouch, void (i32, i32, i32, i32)* @opl3_controller, void (i32, i32, i32)* @opl3_panning, void (i32, i32)* @opl3_volume_method, void (i32, i32, i32)* @opl3_bender, i32 (i32, i32, i32, %struct.voice_alloc_info*)* @opl3_alloc_voice, void (i32, i32, i32)* @opl3_setup_voice, i32 (i32, i8*, i32)* null, %struct.voice_alloc_info zeroinitializer, [16 x %struct.channel_info] zeroinitializer, i32 0, [64 x i8] zeroinitializer, i32 0 }, align 8
@synth_devs = external global [11 x %struct.synth_operations*], align 16
@.str.9 = private unnamed_addr constant [20 x i8] c"Yamaha OPL4/OPL3 FM\00", align 1
@.str.10 = private unnamed_addr constant [12 x i8] c"Yamaha OPL3\00", align 1
@pv_map = internal global [18 x %struct.physical_voice_info] [%struct.physical_voice_info { i8 0, i8 2, i16 0, [4 x i8] c"\00\03\08\0B" }, %struct.physical_voice_info { i8 1, i8 2, i16 0, [4 x i8] c"\01\04\09\0C" }, %struct.physical_voice_info { i8 2, i8 2, i16 0, [4 x i8] c"\02\05\0A\0D" }, %struct.physical_voice_info { i8 3, i8 2, i16 0, [4 x i8] c"\08\0B\00\00" }, %struct.physical_voice_info { i8 4, i8 2, i16 0, [4 x i8] c"\09\0C\00\00" }, %struct.physical_voice_info { i8 5, i8 2, i16 0, [4 x i8] c"\0A\0D\00\00" }, %struct.physical_voice_info { i8 6, i8 2, i16 0, [4 x i8] c"\10\13\00\00" }, %struct.physical_voice_info { i8 7, i8 2, i16 0, [4 x i8] c"\11\14\00\00" }, %struct.physical_voice_info { i8 8, i8 2, i16 0, [4 x i8] c"\12\15\00\00" }, %struct.physical_voice_info { i8 0, i8 2, i16 1, [4 x i8] c"\00\03\08\0B" }, %struct.physical_voice_info { i8 1, i8 2, i16 1, [4 x i8] c"\01\04\09\0C" }, %struct.physical_voice_info { i8 2, i8 2, i16 1, [4 x i8] c"\02\05\0A\0D" }, %struct.physical_voice_info { i8 3, i8 2, i16 1, [4 x i8] c"\08\0B\00\00" }, %struct.physical_voice_info { i8 4, i8 2, i16 1, [4 x i8] c"\09\0C\00\00" }, %struct.physical_voice_info { i8 5, i8 2, i16 1, [4 x i8] c"\0A\0D\00\00" }, %struct.physical_voice_info { i8 6, i8 2, i16 1, [4 x i8] c"\10\13\00\00" }, %struct.physical_voice_info { i8 7, i8 2, i16 1, [4 x i8] c"\11\14\00\00" }, %struct.physical_voice_info { i8 8, i8 2, i16 1, [4 x i8] c"\12\15\00\00" }], align 16
@.str.11 = private unnamed_addr constant [12 x i8] c"Yamaha OPL2\00", align 1
@.str.12 = private unnamed_addr constant [4 x i8] c"OPL\00", align 1
@.str.13 = private unnamed_addr constant [72 x i8] c"\014Warning: Obsolete ioctl(SNDCTL_FM_LOAD_INSTR) used. Fix the program.\0A\00", align 1
@.str.14 = private unnamed_addr constant [42 x i8] c"\014FM Error: Invalid instrument number %d\0A\00", align 1
@.str.15 = private unnamed_addr constant [62 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/uaccess_64.h\00", align 1
@.str.16 = private unnamed_addr constant [27 x i8] c"Buffer overflow detected!\0A\00", align 1
@.str.17 = private unnamed_addr constant [53 x i8] c"\014FM warning: Invalid patch format field (key) 0x%x\0A\00", align 1
@enter_4op_mode.v4op = internal global [18 x i32] [i32 0, i32 1, i32 2, i32 9, i32 10, i32 11, i32 6, i32 7, i32 8, i32 15, i32 16, i32 17, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0], align 16
@.str.18 = private unnamed_addr constant [57 x i8] c"\014opl3: Initializing voice %d with undefined instrument\0A\00", align 1
@fm_volume_table = internal global [128 x i8] c"\C0\D0\D8\DD\E0\E3\E5\E6\E8\E9\EB\EC\ED\EE\EE\EF\F0\F1\F1\F2\F3\F3\F4\F4\F5\F5\F6\F6\F6\F7\F7\F8\F8\F8\F9\F9\F9\FA\FA\FA\FB\FB\FB\FB\FC\FC\FC\FC\FD\FD\FD\FD\FE\FE\FE\FE\FE\FF\FF\FF\FF\00\00\00\00\00\00\01\01\01\01\01\01\02\02\02\02\02\02\02\03\03\03\03\03\03\03\04\04\04\04\04\04\04\04\05\05\05\05\05\05\05\05\05\06\06\06\06\06\06\06\06\06\07\07\07\07\07\07\07\07\07\07\08\08\08\08\08", align 16
@.str.19 = private unnamed_addr constant [36 x i8] c"\014FM Error: Patch record too short\0A\00", align 1
@llvm.used = appending global [3 x i8*] [i8* bitcast (%struct.kernel_param* @__param_io to i8*), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__UNIQUE_ID_iotype1206, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license1258, i32 0, i32 0)], section "llvm.metadata"

@init_module = alias i32 (), i32 ()* @init_opl3
@cleanup_module = alias void (), void ()* @cleanup_opl3

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @init_opl3() #1 section ".init.text" {
entry:
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([82 x i8], [82 x i8]* @.str, i32 0, i32 0))
  %0 = load i32, i32* @io, align 4, !tbaa !12
  %cmp = icmp ne i32 %0, -1
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %1 = load i32, i32* @io, align 4, !tbaa !12
  %call1 = call i32 @opl3_detect(i32 %1)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %if.then
  %2 = load i32, i32* @io, align 4, !tbaa !12
  %call3 = call i32 @opl3_init(i32 %2, %struct.module* @__this_module)
  store i32 %call3, i32* @me, align 4, !tbaa !12
  br label %return

return:                                           ; preds = %entry, %if.end, %if.then
  %retval.0 = phi i32 [ -19, %if.then ], [ 0, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @cleanup_opl3() #1 section ".exit.text" {
entry:
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %tobool = icmp ne %struct.opl_devinfo* %0, null
  %1 = load i32, i32* @io, align 4
  %cmp = icmp ne i32 %1, -1
  %or.cond = and i1 %tobool, %cmp
  br i1 %or.cond, label %if.then, label %if.end9

if.then:                                          ; preds = %entry
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %base = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 0
  %3 = load i32, i32* %base, align 8, !tbaa !15
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.then
  %4 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %base3 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %4, i32 0, i32 0
  %5 = load i32, i32* %base3, align 8, !tbaa !15
  %conv = sext i32 %5 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv, i64 4)
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %is_opl4 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %6, i32 0, i32 14
  %7 = load i32, i32* %is_opl4, align 8, !tbaa !18
  %tobool4 = icmp ne i32 %7, 0
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.then2
  %8 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %base6 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %8, i32 0, i32 0
  %9 = load i32, i32* %base6, align 8, !tbaa !15
  %sub = sub nsw i32 %9, 8
  %conv7 = sext i32 %sub to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv7, i64 2)
  br label %if.end8

if.end8:                                          ; preds = %if.then2, %if.then5, %if.then
  %10 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %11 = bitcast %struct.opl_devinfo* %10 to i8*
  call void @kfree(i8* %11)
  store %struct.opl_devinfo* null, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %12 = load i32, i32* @me, align 4, !tbaa !12
  call void @sound_unload_synthdev(i32 %12)
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %entry
  ret void
}

declare i32 @printk(i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal i32 @opl3_detect(i32 %ioaddr) #3 {
entry:
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %cmp = icmp ne %struct.opl_devinfo* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.1, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i8* @kzalloc(i64 11656, i32 208)
  %1 = bitcast i8* %call1 to %struct.opl_devinfo*
  store %struct.opl_devinfo* %1, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %cmp2 = icmp eq %struct.opl_devinfo* %2, null
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.2, i32 0, i32 0))
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %3 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %3, i32 0, i32 10
  %name = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info, i32 0, i32 0
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %name, i32 0, i32 0
  %call6 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.3, i32 0, i32 0))
  %conv = sext i32 %ioaddr to i64
  %4 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info7 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %4, i32 0, i32 10
  %name8 = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info7, i32 0, i32 0
  %arraydecay9 = getelementptr inbounds [30 x i8], [30 x i8]* %name8, i32 0, i32 0
  %call10 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv, i64 4, i8* %arraydecay9, i32 0)
  %tobool = icmp ne %struct.resource* %call10, null
  br i1 %tobool, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.end5
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.4, i32 0, i32 0), i32 %ioaddr)
  br label %cleanup_devc

if.end13:                                         ; preds = %if.end5
  %5 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %base = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %5, i32 0, i32 0
  store i32 %ioaddr, i32* %base, align 8, !tbaa !15
  call void @opl3_command(i32 %ioaddr, i32 4, i32 96)
  call void @opl3_command(i32 %ioaddr, i32 4, i32 128)
  %call14 = call zeroext i8 @inb(i32 %ioaddr)
  %conv15 = zext i8 %call14 to i32
  %cmp16 = icmp ne i32 %conv15, 0
  %conv18 = zext i8 %call14 to i32
  %cmp19 = icmp ne i32 %conv18, 6
  %or.cond = and i1 %cmp16, %cmp19
  %conv22 = zext i8 %call14 to i32
  %cmp23 = icmp ne i32 %conv22, 2
  %or.cond1 = and i1 %or.cond, %cmp23
  %conv26 = zext i8 %call14 to i32
  %cmp27 = icmp ne i32 %conv26, 15
  %or.cond2 = and i1 %or.cond1, %cmp27
  %conv30 = zext i8 %call14 to i32
  br i1 %or.cond2, label %if.then29, label %if.end32

if.then29:                                        ; preds = %if.end13
  %call31 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.5, i32 0, i32 0), i32 %conv30)
  %conv76 = sext i32 %ioaddr to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv76, i64 4)
  br label %cleanup_devc

if.end32:                                         ; preds = %if.end13
  %cmp34 = icmp eq i32 %conv30, 6
  br i1 %cmp34, label %if.then36, label %if.else

if.then36:                                        ; preds = %if.end32
  store i32 2, i32* @detected_model, align 4, !tbaa !12
  br label %if.end72

if.else:                                          ; preds = %if.end32
  %conv37 = zext i8 %call14 to i32
  %cmp38 = icmp eq i32 %conv37, 0
  %conv40 = zext i8 %call14 to i32
  %cmp41 = icmp eq i32 %conv40, 15
  %or.cond3 = or i1 %cmp38, %cmp41
  br i1 %or.cond3, label %if.then43, label %if.end72

if.then43:                                        ; preds = %if.else
  store i32 3, i32* @detected_model, align 4, !tbaa !12
  %add = add nsw i32 %ioaddr, 2
  call void @opl3_command(i32 %add, i32 5, i32 0)
  %add44 = add nsw i32 %ioaddr, 2
  call void @opl3_command(i32 %add44, i32 5, i32 3)
  %call45 = call zeroext i8 @inb(i32 %ioaddr)
  %conv46 = zext i8 %call45 to i32
  %cmp47 = icmp eq i32 %conv46, 2
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.then43
  store i32 4, i32* @detected_model, align 4, !tbaa !12
  br label %if.end50

if.end50:                                         ; preds = %if.then49, %if.then43
  %sub = sub nsw i32 %ioaddr, 8
  %conv51 = sext i32 %sub to i64
  %call52 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv51, i64 2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.6, i32 0, i32 0), i32 0)
  %tobool53 = icmp ne %struct.resource* %call52, null
  br i1 %tobool53, label %if.then54, label %if.end69

if.then54:                                        ; preds = %if.end50
  %sub56 = sub nsw i32 %ioaddr, 8
  call void @outb(i8 zeroext 2, i32 %sub56)
  call void @__const_udelay(i64 42950)
  %sub57 = sub nsw i32 %ioaddr, 7
  %call58 = call zeroext i8 @inb(i32 %sub57)
  %conv59 = zext i8 %call58 to i32
  call void @__const_udelay(i64 42950)
  %cmp60 = icmp eq i32 %conv59, 32
  br i1 %cmp60, label %if.then62, label %if.else65

if.then62:                                        ; preds = %if.then54
  store i32 4, i32* @detected_model, align 4, !tbaa !12
  %sub63 = sub nsw i32 %ioaddr, 8
  call void @outb(i8 zeroext -8, i32 %sub63)
  call void @__const_udelay(i64 42950)
  %sub64 = sub nsw i32 %ioaddr, 7
  call void @outb(i8 zeroext 27, i32 %sub64)
  call void @__const_udelay(i64 42950)
  br label %if.end69

if.else65:                                        ; preds = %if.then54
  %sub66 = sub nsw i32 %ioaddr, 8
  %conv67 = sext i32 %sub66 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv67, i64 2)
  store i32 3, i32* @detected_model, align 4, !tbaa !12
  br label %if.end69

if.end69:                                         ; preds = %if.then62, %if.else65, %if.end50
  %add70 = add nsw i32 %ioaddr, 2
  call void @opl3_command(i32 %add70, i32 5, i32 0)
  br label %if.end72

if.end72:                                         ; preds = %if.end69, %if.else, %if.then36
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end72
  %i.0 = phi i32 [ 0, %if.end72 ], [ %inc, %for.body ]
  %cmp73 = icmp slt i32 %i.0, 9
  br i1 %cmp73, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add75 = add nsw i32 176, %i.0
  call void @opl3_command(i32 %ioaddr, i32 %add75, i32 0)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @opl3_command(i32 %ioaddr, i32 1, i32 32)
  call void @opl3_command(i32 %ioaddr, i32 189, i32 0)
  br label %cleanup

cleanup_devc:                                     ; preds = %if.then29, %if.then11
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %7 = bitcast %struct.opl_devinfo* %6 to i8*
  call void @kfree(i8* %7)
  store %struct.opl_devinfo* null, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  br label %cleanup

cleanup:                                          ; preds = %cleanup_devc, %for.end, %if.then3, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 0, %if.then3 ], [ 0, %cleanup_devc ], [ 1, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @opl3_init(i32 %ioaddr, %struct.module* %owner) #3 {
entry:
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %cmp = icmp eq %struct.opl_devinfo* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.7, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @sound_alloc_synthdev()
  %cmp2 = icmp eq i32 %call1, -1
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.8, i32 0, i32 0))
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %1 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %1, i32 0, i32 3
  store i32 9, i32* %nr_voice, align 4, !tbaa !19
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 10
  %device = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info, i32 0, i32 1
  store i32 0, i32* %device, align 8, !tbaa !20
  %3 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info6 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %3, i32 0, i32 10
  %synth_type = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info6, i32 0, i32 2
  store i32 0, i32* %synth_type, align 4, !tbaa !21
  %4 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info7 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %4, i32 0, i32 10
  %synth_subtype = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info7, i32 0, i32 3
  store i32 0, i32* %synth_subtype, align 8, !tbaa !22
  %5 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info8 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %5, i32 0, i32 10
  %perc_mode = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info8, i32 0, i32 4
  store i32 0, i32* %perc_mode, align 4, !tbaa !23
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info9 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %6, i32 0, i32 10
  %nr_voices = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info9, i32 0, i32 5
  store i32 9, i32* %nr_voices, align 8, !tbaa !24
  %7 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info10 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %7, i32 0, i32 10
  %nr_drums = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info10, i32 0, i32 6
  store i32 0, i32* %nr_drums, align 4, !tbaa !25
  %8 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info11 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %8, i32 0, i32 10
  %instr_bank_size = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info11, i32 0, i32 7
  store i32 256, i32* %instr_bank_size, align 8, !tbaa !26
  %9 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info12 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %9, i32 0, i32 10
  %capabilities = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info12, i32 0, i32 8
  store i32 0, i32* %capabilities, align 4, !tbaa !27
  %10 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %left_io = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %10, i32 0, i32 1
  store i32 %ioaddr, i32* %left_io, align 4, !tbaa !28
  %add = add nsw i32 %ioaddr, 2
  %11 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %right_io = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %11, i32 0, i32 2
  store i32 %add, i32* %right_io, align 8, !tbaa !29
  %12 = load i32, i32* @detected_model, align 4, !tbaa !12
  %cmp13 = icmp sle i32 %12, 2
  %13 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %model = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %13, i32 0, i32 12
  br i1 %cmp13, label %if.end19.sink.split, label %if.else

if.else:                                          ; preds = %if.end5
  store i32 2, i32* %model, align 8, !tbaa !30
  %14 = load i32, i32* @detected_model, align 4, !tbaa !12
  %cmp16 = icmp eq i32 %14, 4
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.else
  %15 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %is_opl4 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %15, i32 0, i32 14
  br label %if.end19.sink.split

if.end19.sink.split:                              ; preds = %if.end5, %if.then17
  %is_opl4.sink = phi i32* [ %is_opl4, %if.then17 ], [ %model, %if.end5 ]
  store i32 1, i32* %is_opl4.sink, align 8, !tbaa !12
  br label %if.end19

if.end19:                                         ; preds = %if.end19.sink.split, %if.else
  %16 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info20 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %16, i32 0, i32 10
  store %struct.synth_info* %fm_info20, %struct.synth_info** getelementptr inbounds (%struct.synth_operations, %struct.synth_operations* @opl3_operations, i32 0, i32 2), align 8, !tbaa !31
  %idxprom = sext i32 %call1 to i64
  %arrayidx = getelementptr inbounds [11 x %struct.synth_operations*], [11 x %struct.synth_operations*]* @synth_devs, i64 0, i64 %idxprom
  store %struct.synth_operations* @opl3_operations, %struct.synth_operations** %arrayidx, align 8, !tbaa !14
  %tobool = icmp ne %struct.module* %owner, null
  br i1 %tobool, label %if.then21, label %if.end25

if.then21:                                        ; preds = %if.end19
  %idxprom22 = sext i32 %call1 to i64
  %arrayidx23 = getelementptr inbounds [11 x %struct.synth_operations*], [11 x %struct.synth_operations*]* @synth_devs, i64 0, i64 %idxprom22
  %17 = load %struct.synth_operations*, %struct.synth_operations** %arrayidx23, align 8, !tbaa !14
  %owner24 = getelementptr inbounds %struct.synth_operations, %struct.synth_operations* %17, i32 0, i32 0
  store %struct.module* %owner, %struct.module** %owner24, align 8, !tbaa !34
  br label %if.end25

if.end25:                                         ; preds = %if.then21, %if.end19
  call void @sequencer_init()
  %18 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %v_alloc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %18, i32 0, i32 6
  store %struct.voice_alloc_info* getelementptr inbounds (%struct.synth_operations, %struct.synth_operations* @opl3_operations, i32 0, i32 23), %struct.voice_alloc_info** %v_alloc, align 8, !tbaa !35
  %19 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %chn_info = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %19, i32 0, i32 7
  store %struct.channel_info* getelementptr inbounds (%struct.synth_operations, %struct.synth_operations* @opl3_operations, i32 0, i32 24, i64 0), %struct.channel_info** %chn_info, align 8, !tbaa !36
  %20 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %model26 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %20, i32 0, i32 12
  %21 = load i32, i32* %model26, align 8, !tbaa !30
  %cmp27 = icmp eq i32 %21, 2
  %22 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  br i1 %cmp27, label %if.then28, label %if.else69

if.then28:                                        ; preds = %if.end25
  %is_opl429 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %22, i32 0, i32 14
  %23 = load i32, i32* %is_opl429, align 8, !tbaa !18
  %tobool30 = icmp ne i32 %23, 0
  %24 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info32 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %24, i32 0, i32 10
  %name = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info32, i32 0, i32 0
  %arraydecay = getelementptr inbounds [30 x i8], [30 x i8]* %name, i32 0, i32 0
  br i1 %tobool30, label %if.then31, label %if.else34

if.then31:                                        ; preds = %if.then28
  %call33 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.9, i32 0, i32 0))
  br label %if.end39

if.else34:                                        ; preds = %if.then28
  %call38 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.10, i32 0, i32 0))
  br label %if.end39

if.end39:                                         ; preds = %if.else34, %if.then31
  %25 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice40 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %25, i32 0, i32 3
  store i32 18, i32* %nr_voice40, align 4, !tbaa !19
  %26 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %v_alloc41 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %26, i32 0, i32 6
  %27 = load %struct.voice_alloc_info*, %struct.voice_alloc_info** %v_alloc41, align 8, !tbaa !35
  %max_voice = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %27, i32 0, i32 0
  store i32 18, i32* %max_voice, align 4, !tbaa !37
  %28 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info42 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %28, i32 0, i32 10
  %nr_drums43 = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info42, i32 0, i32 6
  store i32 0, i32* %nr_drums43, align 4, !tbaa !25
  %29 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info44 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %29, i32 0, i32 10
  %synth_subtype45 = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info44, i32 0, i32 3
  store i32 1, i32* %synth_subtype45, align 8, !tbaa !22
  %30 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info46 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %30, i32 0, i32 10
  %capabilities47 = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info46, i32 0, i32 8
  %31 = load i32, i32* %capabilities47, align 4, !tbaa !27
  %or = or i32 %31, 2
  store i32 %or, i32* %capabilities47, align 4, !tbaa !27
  br label %for.cond

for.cond:                                         ; preds = %if.end66, %if.end39
  %i.0 = phi i32 [ 0, %if.end39 ], [ %inc, %if.end66 ]
  %cmp48 = icmp slt i32 %i.0, 18
  br i1 %cmp48, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom49 = sext i32 %i.0 to i64
  %arrayidx50 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom49
  %ioaddr51 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx50, i32 0, i32 2
  %32 = load i16, i16* %ioaddr51, align 2, !tbaa !38
  %conv = zext i16 %32 to i32
  %cmp52 = icmp eq i32 %conv, 0
  %33 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  br i1 %cmp52, label %if.then54, label %if.else60

if.then54:                                        ; preds = %for.body
  %left_io55 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %33, i32 0, i32 1
  %34 = load i32, i32* %left_io55, align 4, !tbaa !28
  br label %if.end66

if.else60:                                        ; preds = %for.body
  %right_io61 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %33, i32 0, i32 2
  %35 = load i32, i32* %right_io61, align 8, !tbaa !29
  br label %if.end66

if.end66:                                         ; preds = %if.else60, %if.then54
  %.sink = phi i32 [ %35, %if.else60 ], [ %34, %if.then54 ]
  %conv62 = trunc i32 %.sink to i16
  %idxprom63 = sext i32 %i.0 to i64
  %arrayidx64 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom63
  %ioaddr65 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx64, i32 0, i32 2
  store i16 %conv62, i16* %ioaddr65, align 2, !tbaa !38
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %36 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %right_io67 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %36, i32 0, i32 2
  %37 = load i32, i32* %right_io67, align 8, !tbaa !29
  call void @opl3_command(i32 %37, i32 5, i32 1)
  %38 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %right_io68 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %38, i32 0, i32 2
  %39 = load i32, i32* %right_io68, align 8, !tbaa !29
  call void @opl3_command(i32 %39, i32 4, i32 0)
  br label %if.end91

if.else69:                                        ; preds = %if.end25
  %fm_info70 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %22, i32 0, i32 10
  %name71 = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info70, i32 0, i32 0
  %arraydecay72 = getelementptr inbounds [30 x i8], [30 x i8]* %name71, i32 0, i32 0
  %call73 = call i8* @strcpy(i8* %arraydecay72, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.11, i32 0, i32 0))
  %40 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice74 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %40, i32 0, i32 3
  store i32 9, i32* %nr_voice74, align 4, !tbaa !19
  %41 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %v_alloc75 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %41, i32 0, i32 6
  %42 = load %struct.voice_alloc_info*, %struct.voice_alloc_info** %v_alloc75, align 8, !tbaa !35
  %max_voice76 = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %42, i32 0, i32 0
  store i32 9, i32* %max_voice76, align 4, !tbaa !37
  %43 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info77 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %43, i32 0, i32 10
  %nr_drums78 = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info77, i32 0, i32 6
  store i32 0, i32* %nr_drums78, align 4, !tbaa !25
  br label %for.cond79

for.cond79:                                       ; preds = %for.body82, %if.else69
  %i.1 = phi i32 [ 0, %if.else69 ], [ %inc89, %for.body82 ]
  %cmp80 = icmp slt i32 %i.1, 18
  br i1 %cmp80, label %for.body82, label %if.end91

for.body82:                                       ; preds = %for.cond79
  %44 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %left_io83 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %44, i32 0, i32 1
  %45 = load i32, i32* %left_io83, align 4, !tbaa !28
  %conv84 = trunc i32 %45 to i16
  %idxprom85 = sext i32 %i.1 to i64
  %arrayidx86 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom85
  %ioaddr87 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx86, i32 0, i32 2
  store i16 %conv84, i16* %ioaddr87, align 2, !tbaa !38
  %inc89 = add nsw i32 %i.1, 1
  br label %for.cond79

if.end91:                                         ; preds = %for.cond79, %for.end
  %46 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info92 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %46, i32 0, i32 10
  %name93 = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info92, i32 0, i32 0
  %arraydecay94 = getelementptr inbounds [30 x i8], [30 x i8]* %name93, i32 0, i32 0
  call void @conf_printf2(i8* %arraydecay94, i32 %ioaddr, i32 0, i32 -1, i32 -1)
  br label %for.cond95

for.cond95:                                       ; preds = %for.body98, %if.end91
  %i.2 = phi i32 [ 0, %if.end91 ], [ %inc102, %for.body98 ]
  %cmp96 = icmp slt i32 %i.2, 256
  br i1 %cmp96, label %for.body98, label %cleanup

for.body98:                                       ; preds = %for.cond95
  %47 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %i_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %47, i32 0, i32 8
  %idxprom99 = sext i32 %i.2 to i64
  %arrayidx100 = getelementptr inbounds [256 x %struct.sbi_instrument], [256 x %struct.sbi_instrument]* %i_map, i64 0, i64 %idxprom99
  %channel = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %arrayidx100, i32 0, i32 2
  store i32 -1, i32* %channel, align 4, !tbaa !41
  %inc102 = add nsw i32 %i.2, 1
  br label %for.cond95

cleanup:                                          ; preds = %for.cond95, %if.then3, %if.then
  %retval.0 = phi i32 [ -1, %if.then ], [ -1, %if.then3 ], [ %call1, %for.cond95 ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

declare i8* @strcpy(i8*, i8*) #2

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #2

; Function Attrs: nounwind uwtable
define internal void @opl3_command(i32 %io_addr, i32 %addr, i32 %val) #3 {
entry:
  %and = and i32 %addr, 255
  %conv = trunc i32 %and to i8
  call void @outb(i8 zeroext %conv, i32 %io_addr)
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %model = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 12
  %1 = load i32, i32* %model, align 8, !tbaa !30
  %cmp = icmp ne i32 %1, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @__const_udelay(i64 42950)
  br label %if.end

if.else:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.else
  %i.0 = phi i32 [ 0, %if.else ], [ %inc, %for.body ]
  %cmp2 = icmp slt i32 %i.0, 2
  br i1 %cmp2, label %for.body, label %if.end

for.body:                                         ; preds = %for.cond
  %call = call zeroext i8 @inb(i32 %io_addr)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end:                                           ; preds = %for.cond, %if.then
  %and4 = and i32 %val, 255
  %conv5 = trunc i32 %and4 to i8
  %add = add nsw i32 %io_addr, 1
  call void @outb(i8 zeroext %conv5, i32 %add)
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %model6 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 12
  %3 = load i32, i32* %model6, align 8, !tbaa !30
  %cmp7 = icmp ne i32 %3, 2
  br i1 %cmp7, label %if.then9, label %if.else10

if.then9:                                         ; preds = %if.end
  call void @__const_udelay(i64 128850)
  br label %if.end19

if.else10:                                        ; preds = %if.end
  br label %for.cond11

for.cond11:                                       ; preds = %for.body14, %if.else10
  %i.1 = phi i32 [ 0, %if.else10 ], [ %inc17, %for.body14 ]
  %cmp12 = icmp slt i32 %i.1, 2
  br i1 %cmp12, label %for.body14, label %if.end19

for.body14:                                       ; preds = %for.cond11
  %call15 = call zeroext i8 @inb(i32 %io_addr)
  %inc17 = add nsw i32 %i.1, 1
  br label %for.cond11

if.end19:                                         ; preds = %for.cond11, %if.then9
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #0 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #8, !srcloc !43
  ret i8 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #0 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #8, !srcloc !44
  ret void
}

declare void @__const_udelay(i64) #2

declare void @__release_region(%struct.resource*, i64, i64) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

declare void @kfree(i8*) #2

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #5 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare i8* @__kmalloc(i64, i32) #2

declare i32 @sound_alloc_synthdev() #2

declare void @sequencer_init() #2

declare void @conf_printf2(i8*, i32, i32, i32, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @opl3_open(i32 %dev, i32 %mode) #3 {
entry:
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %busy = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 11
  %1 = load i32, i32* %busy, align 4, !tbaa !45
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %busy1 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 11
  store i32 1, i32* %busy1, align 4, !tbaa !45
  %3 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %model = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %3, i32 0, i32 12
  %4 = load i32, i32* %model, align 8, !tbaa !30
  %cmp = icmp eq i32 %4, 2
  %5 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 18, i32 9
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %6, i32 0, i32 3
  store i32 %cond, i32* %nr_voice, align 4, !tbaa !19
  %7 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %v_alloc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %7, i32 0, i32 6
  %8 = load %struct.voice_alloc_info*, %struct.voice_alloc_info** %v_alloc, align 8, !tbaa !35
  %max_voice = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %8, i32 0, i32 0
  store i32 %cond, i32* %max_voice, align 4, !tbaa !37
  %9 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %v_alloc2 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %9, i32 0, i32 6
  %10 = load %struct.voice_alloc_info*, %struct.voice_alloc_info** %v_alloc2, align 8, !tbaa !35
  %timestamp = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %10, i32 0, i32 4
  store i32 0, i32* %timestamp, align 4, !tbaa !46
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %cmp3 = icmp slt i32 %i.0, 18
  %11 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %v_alloc4 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %11, i32 0, i32 6
  %12 = load %struct.voice_alloc_info*, %struct.voice_alloc_info** %v_alloc4, align 8, !tbaa !35
  %map = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %12, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x i16], [32 x i16]* %map, i64 0, i64 %idxprom
  store i16 0, i16* %arrayidx, align 2, !tbaa !47
  %13 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %v_alloc5 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %13, i32 0, i32 6
  %14 = load %struct.voice_alloc_info*, %struct.voice_alloc_info** %v_alloc5, align 8, !tbaa !35
  %alloc_times = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %14, i32 0, i32 5
  %idxprom6 = sext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [32 x i32], [32 x i32]* %alloc_times, i64 0, i64 %idxprom6
  store i32 0, i32* %arrayidx7, align 4, !tbaa !12
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmask = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %11, i32 0, i32 13
  store i8 0, i8* %cmask, align 4, !tbaa !48
  %15 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %model8 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %15, i32 0, i32 12
  %16 = load i32, i32* %model8, align 8, !tbaa !30
  %cmp9 = icmp eq i32 %16, 2
  br i1 %cmp9, label %if.then10, label %cleanup

if.then10:                                        ; preds = %for.end
  %17 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %right_io = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %17, i32 0, i32 2
  %18 = load i32, i32* %right_io, align 8, !tbaa !29
  %19 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %cmask11 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %19, i32 0, i32 13
  %20 = load i8, i8* %cmask11, align 4, !tbaa !48
  %conv = zext i8 %20 to i32
  call void @opl3_command(i32 %18, i32 4, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then10, %entry
  %retval.0 = phi i32 [ -16, %entry ], [ 0, %if.then10 ], [ 0, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @opl3_close(i32 %dev) #3 {
entry:
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %busy = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 11
  store i32 0, i32* %busy, align 4, !tbaa !45
  %1 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %model = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %1, i32 0, i32 12
  %2 = load i32, i32* %model, align 8, !tbaa !30
  %cmp = icmp eq i32 %2, 2
  %3 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 18, i32 9
  %4 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %4, i32 0, i32 3
  store i32 %cond, i32* %nr_voice, align 4, !tbaa !19
  %5 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %v_alloc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %5, i32 0, i32 6
  %6 = load %struct.voice_alloc_info*, %struct.voice_alloc_info** %v_alloc, align 8, !tbaa !35
  %max_voice = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %6, i32 0, i32 0
  store i32 %cond, i32* %max_voice, align 4, !tbaa !37
  %7 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %7, i32 0, i32 10
  %nr_drums = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info, i32 0, i32 6
  store i32 0, i32* %nr_drums, align 4, !tbaa !25
  %8 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info1 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %8, i32 0, i32 10
  %perc_mode = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info1, i32 0, i32 4
  store i32 0, i32* %perc_mode, align 4, !tbaa !23
  call void @opl3_reset(i32 %dev)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @opl3_ioctl(i32 %dev, i32 %cmd, i8* %arg) #3 {
entry:
  %ins = alloca %struct.sbi_instrument, align 4
  %0 = bitcast %struct.sbi_instrument* %ins to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %0) #8
  %Pivot10 = icmp slt i32 %cmd, 1074024719
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %cmd, 1076384007
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %cmd, 1076384007
  br i1 %SwitchLeaf6, label %sw.bb, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %cmd, 1074024719
  br i1 %SwitchLeaf4, label %sw.bb19, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %cmd, -1064546046
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, -1064546046
  br i1 %SwitchLeaf2, label %sw.bb10, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, -1073458930
  br i1 %SwitchLeaf, label %cleanup, label %sw.default

sw.bb:                                            ; preds = %LeafBlock5
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([72 x i8], [72 x i8]* @.str.13, i32 0, i32 0))
  %1 = bitcast %struct.sbi_instrument* %ins to i8*
  %call1 = call i64 @copy_from_user(i8* %1, i8* %arg, i64 40)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %sw.bb
  %channel = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %ins, i32 0, i32 2
  %2 = load i32, i32* %channel, align 4, !tbaa !41
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %channel2 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %ins, i32 0, i32 2
  %3 = load i32, i32* %channel2, align 4, !tbaa !41
  %cmp3 = icmp sge i32 %3, 256
  br i1 %cmp3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  %channel5 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %ins, i32 0, i32 2
  %4 = load i32, i32* %channel5, align 4, !tbaa !41
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.14, i32 0, i32 0), i32 %4)
  br label %cleanup

if.end7:                                          ; preds = %lor.lhs.false
  %channel8 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %ins, i32 0, i32 2
  %5 = load i32, i32* %channel8, align 4, !tbaa !41
  %call9 = call i32 @store_instr(i32 %5, %struct.sbi_instrument* %ins)
  br label %cleanup

sw.bb10:                                          ; preds = %LeafBlock1
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %6, i32 0, i32 3
  %7 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp11 = icmp eq i32 %7, 12
  br i1 %cmp11, label %cond.end, label %cond.false

cond.false:                                       ; preds = %sw.bb10
  %8 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice12 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %8, i32 0, i32 3
  %9 = load i32, i32* %nr_voice12, align 4, !tbaa !19
  br label %cond.end

cond.end:                                         ; preds = %sw.bb10, %cond.false
  %cond = phi i32 [ %9, %cond.false ], [ 6, %sw.bb10 ]
  %10 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %10, i32 0, i32 10
  %nr_voices = getelementptr inbounds %struct.synth_info, %struct.synth_info* %fm_info, i32 0, i32 5
  store i32 %cond, i32* %nr_voices, align 8, !tbaa !24
  %11 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %fm_info13 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %11, i32 0, i32 10
  %12 = bitcast %struct.synth_info* %fm_info13 to i8*
  %call14 = call i32 @copy_to_user(i8* %arg, i8* %12, i32 140)
  %tobool15 = icmp ne i32 %call14, 0
  %. = select i1 %tobool15, i32 -14, i32 0
  br label %cleanup

sw.bb19:                                          ; preds = %LeafBlock3
  %13 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %model = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %13, i32 0, i32 12
  %14 = load i32, i32* %model, align 8, !tbaa !30
  %cmp20 = icmp eq i32 %14, 2
  br i1 %cmp20, label %if.then21, label %cleanup

if.then21:                                        ; preds = %sw.bb19
  call void @enter_4op_mode()
  br label %cleanup

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  br label %cleanup

cleanup:                                          ; preds = %sw.bb19, %if.then21, %LeafBlock, %cond.end, %sw.bb, %sw.default, %if.end7, %if.then4
  %retval.0 = phi i32 [ -22, %sw.default ], [ -22, %if.then4 ], [ %call9, %if.end7 ], [ -14, %sw.bb ], [ %., %cond.end ], [ 2147483647, %LeafBlock ], [ 0, %if.then21 ], [ 0, %sw.bb19 ]
  %15 = bitcast %struct.sbi_instrument* %ins to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %15) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @opl3_kill_note(i32 %devno, i32 %voice, i32 %note, i32 %velocity) #3 {
entry:
  %cmp = icmp slt i32 %voice, 0
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 3
  %1 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp1 = icmp sge i32 %voice, %1
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %v_alloc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 6
  %3 = load %struct.voice_alloc_info*, %struct.voice_alloc_info** %v_alloc, align 8, !tbaa !35
  %map2 = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %3, i32 0, i32 3
  %idxprom = sext i32 %voice to i64
  %arrayidx = getelementptr inbounds [32 x i16], [32 x i16]* %map2, i64 0, i64 %idxprom
  store i16 0, i16* %arrayidx, align 2, !tbaa !47
  %4 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %4, i32 0, i32 4
  %idxprom3 = sext i32 %voice to i64
  %arrayidx4 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map, i64 0, i64 %idxprom3
  %5 = load i32, i32* %arrayidx4, align 4, !tbaa !12
  %idxprom5 = sext i32 %5 to i64
  %arrayidx6 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom5
  %voice_mode = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx6, i32 0, i32 1
  %6 = load i8, i8* %voice_mode, align 1, !tbaa !49
  %conv = zext i8 %6 to i32
  %cmp7 = icmp eq i32 %conv, 0
  br i1 %cmp7, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end
  %ioaddr = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx6, i32 0, i32 2
  %7 = load i16, i16* %ioaddr, align 2, !tbaa !38
  %conv11 = zext i16 %7 to i32
  %voice_num = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx6, i32 0, i32 0
  %8 = load i8, i8* %voice_num, align 2, !tbaa !50
  %conv12 = zext i8 %8 to i32
  %add = add nsw i32 176, %conv12
  %9 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %9, i32 0, i32 5
  %idxprom13 = sext i32 %voice to i64
  %arrayidx14 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc, i64 0, i64 %idxprom13
  %keyon_byte = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx14, i32 0, i32 0
  %10 = load i8, i8* %keyon_byte, align 8, !tbaa !51
  %conv15 = zext i8 %10 to i32
  %and = and i32 %conv15, -33
  call void @opl3_command(i32 %conv11, i32 %add, i32 %and)
  %11 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc16 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %11, i32 0, i32 5
  %idxprom17 = sext i32 %voice to i64
  %arrayidx18 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc16, i64 0, i64 %idxprom17
  %keyon_byte19 = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx18, i32 0, i32 0
  store i8 0, i8* %keyon_byte19, align 8, !tbaa !51
  %12 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc20 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %12, i32 0, i32 5
  %idxprom21 = sext i32 %voice to i64
  %arrayidx22 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc20, i64 0, i64 %idxprom21
  %bender = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx22, i32 0, i32 1
  store i64 0, i64* %bender, align 8, !tbaa !54
  %13 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc23 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %13, i32 0, i32 5
  %idxprom24 = sext i32 %voice to i64
  %arrayidx25 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc23, i64 0, i64 %idxprom24
  %volume = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx25, i32 0, i32 5
  store i32 64, i32* %volume, align 8, !tbaa !55
  %14 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc26 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %14, i32 0, i32 5
  %idxprom27 = sext i32 %voice to i64
  %arrayidx28 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc26, i64 0, i64 %idxprom27
  %panning = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx28, i32 0, i32 7
  store i32 65535, i32* %panning, align 8, !tbaa !56
  %15 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc29 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %15, i32 0, i32 5
  %idxprom30 = sext i32 %voice to i64
  %arrayidx31 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc29, i64 0, i64 %idxprom30
  %bender_range = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx31, i32 0, i32 2
  store i64 200, i64* %bender_range, align 8, !tbaa !57
  %16 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc32 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %16, i32 0, i32 5
  %idxprom33 = sext i32 %voice to i64
  %arrayidx34 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc32, i64 0, i64 %idxprom33
  %orig_freq = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx34, i32 0, i32 3
  store i64 0, i64* %orig_freq, align 8, !tbaa !58
  %17 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc35 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %17, i32 0, i32 5
  %idxprom36 = sext i32 %voice to i64
  %arrayidx37 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc35, i64 0, i64 %idxprom36
  %current_freq = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx37, i32 0, i32 4
  store i64 0, i64* %current_freq, align 8, !tbaa !59
  %18 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc38 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %18, i32 0, i32 5
  %idxprom39 = sext i32 %voice to i64
  %arrayidx40 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc38, i64 0, i64 %idxprom39
  %mode = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx40, i32 0, i32 6
  store i32 0, i32* %mode, align 4, !tbaa !60
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %lor.lhs.false, %if.end10
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @opl3_start_note(i32 %dev, i32 %voice, i32 %note, i32 %volume) #3 {
entry:
  %block = alloca i32, align 4
  %fnum = alloca i32, align 4
  %0 = bitcast i32* %block to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i32* %fnum to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %cmp = icmp slt i32 %voice, 0
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 3
  %3 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp1 = icmp sge i32 %voice, %3
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %4 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %4, i32 0, i32 4
  %idxprom = sext i32 %voice to i64
  %arrayidx = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map, i64 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %idxprom2 = sext i32 %5 to i64
  %arrayidx3 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom2
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %6, i32 0, i32 5
  %idxprom4 = sext i32 %voice to i64
  %arrayidx5 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc, i64 0, i64 %idxprom4
  %panning = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx5, i32 0, i32 7
  %7 = load i32, i32* %panning, align 8, !tbaa !56
  %voice_mode6 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 1
  %8 = load i8, i8* %voice_mode6, align 1, !tbaa !49
  %conv = zext i8 %8 to i32
  %cmp7 = icmp eq i32 %conv, 0
  br i1 %cmp7, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end
  %cmp11 = icmp eq i32 %note, 255
  br i1 %cmp11, label %if.then13, label %if.end18

if.then13:                                        ; preds = %if.end10
  %9 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc14 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %9, i32 0, i32 5
  %idxprom15 = sext i32 %voice to i64
  %arrayidx16 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc14, i64 0, i64 %idxprom15
  %volume17 = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx16, i32 0, i32 5
  %10 = load i32, i32* %volume17, align 8, !tbaa !55
  call void @set_voice_volume(i32 %voice, i32 %volume, i32 %10)
  br label %cleanup

if.end18:                                         ; preds = %if.end10
  %ioaddr = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %11 = load i16, i16* %ioaddr, align 2, !tbaa !38
  %conv19 = zext i16 %11 to i32
  %op = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx20 = getelementptr inbounds [4 x i8], [4 x i8]* %op, i64 0, i64 1
  %12 = load i8, i8* %arrayidx20, align 1, !tbaa !61
  %conv21 = zext i8 %12 to i32
  %add = add nsw i32 64, %conv21
  call void @opl3_command(i32 %conv19, i32 %add, i32 255)
  %ioaddr22 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %13 = load i16, i16* %ioaddr22, align 2, !tbaa !38
  %conv23 = zext i16 %13 to i32
  %op24 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx25 = getelementptr inbounds [4 x i8], [4 x i8]* %op24, i64 0, i64 0
  %14 = load i8, i8* %arrayidx25, align 2, !tbaa !61
  %conv26 = zext i8 %14 to i32
  %add27 = add nsw i32 64, %conv26
  call void @opl3_command(i32 %conv23, i32 %add27, i32 255)
  %voice_mode28 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 1
  %15 = load i8, i8* %voice_mode28, align 1, !tbaa !49
  %conv29 = zext i8 %15 to i32
  %cmp30 = icmp eq i32 %conv29, 4
  br i1 %cmp30, label %if.then32, label %if.end45

if.then32:                                        ; preds = %if.end18
  %ioaddr33 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %16 = load i16, i16* %ioaddr33, align 2, !tbaa !38
  %conv34 = zext i16 %16 to i32
  %op35 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx36 = getelementptr inbounds [4 x i8], [4 x i8]* %op35, i64 0, i64 2
  %17 = load i8, i8* %arrayidx36, align 2, !tbaa !61
  %conv37 = zext i8 %17 to i32
  %add38 = add nsw i32 64, %conv37
  call void @opl3_command(i32 %conv34, i32 %add38, i32 255)
  %ioaddr39 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %18 = load i16, i16* %ioaddr39, align 2, !tbaa !38
  %conv40 = zext i16 %18 to i32
  %op41 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx42 = getelementptr inbounds [4 x i8], [4 x i8]* %op41, i64 0, i64 3
  %19 = load i8, i8* %arrayidx42, align 1, !tbaa !61
  %conv43 = zext i8 %19 to i32
  %add44 = add nsw i32 64, %conv43
  call void @opl3_command(i32 %conv40, i32 %add44, i32 255)
  br label %if.end45

if.end45:                                         ; preds = %if.then32, %if.end18
  %ioaddr46 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %20 = load i16, i16* %ioaddr46, align 2, !tbaa !38
  %conv47 = zext i16 %20 to i32
  %voice_num = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 0
  %21 = load i8, i8* %voice_num, align 2, !tbaa !50
  %conv48 = zext i8 %21 to i32
  %add49 = add nsw i32 176, %conv48
  call void @opl3_command(i32 %conv47, i32 %add49, i32 0)
  %22 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %act_i = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %22, i32 0, i32 9
  %idxprom50 = sext i32 %voice to i64
  %arrayidx51 = getelementptr inbounds [18 x %struct.sbi_instrument*], [18 x %struct.sbi_instrument*]* %act_i, i64 0, i64 %idxprom50
  %23 = load %struct.sbi_instrument*, %struct.sbi_instrument** %arrayidx51, align 8, !tbaa !14
  %tobool = icmp ne %struct.sbi_instrument* %23, null
  %24 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8
  %i_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %24, i32 0, i32 8
  %arrayidx53 = getelementptr inbounds [256 x %struct.sbi_instrument], [256 x %struct.sbi_instrument]* %i_map, i64 0, i64 0
  %instr.0 = select i1 %tobool, %struct.sbi_instrument* %23, %struct.sbi_instrument* %arrayidx53
  %channel = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 2
  %25 = load i32, i32* %channel, align 4, !tbaa !41
  %cmp55 = icmp slt i32 %25, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.end45
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.18, i32 0, i32 0), i32 %voice)
  br label %cleanup

if.end58:                                         ; preds = %if.end45
  %voice_mode59 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 1
  %26 = load i8, i8* %voice_mode59, align 1, !tbaa !49
  %conv60 = zext i8 %26 to i32
  %cmp61 = icmp eq i32 %conv60, 2
  br i1 %cmp61, label %land.lhs.true, label %if.end67

land.lhs.true:                                    ; preds = %if.end58
  %key = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 0
  %27 = load i16, i16* %key, align 4, !tbaa !62
  %conv63 = zext i16 %27 to i32
  %cmp64 = icmp eq i32 %conv63, 1021
  br i1 %cmp64, label %cleanup, label %if.end67

if.end67:                                         ; preds = %land.lhs.true, %if.end58
  %voice_mode68 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 1
  %28 = load i8, i8* %voice_mode68, align 1, !tbaa !49
  %conv69 = zext i8 %28 to i32
  %cmp70 = icmp eq i32 %conv69, 4
  br i1 %cmp70, label %if.then72, label %if.end94

if.then72:                                        ; preds = %if.end67
  %ioaddr73 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %29 = load i16, i16* %ioaddr73, align 2, !tbaa !38
  %conv74 = zext i16 %29 to i32
  %30 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %left_io = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %30, i32 0, i32 1
  %31 = load i32, i32* %left_io, align 4, !tbaa !28
  %cmp75 = icmp eq i32 %conv74, %31
  %32 = zext i1 %cmp75 to i64
  %cond = select i1 %cmp75, i32 0, i32 3
  %voice_num77 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 0
  %33 = load i8, i8* %voice_num77, align 2, !tbaa !50
  %conv78 = zext i8 %33 to i32
  %add79 = add nsw i32 %cond, %conv78
  %key80 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 0
  %34 = load i16, i16* %key80, align 4, !tbaa !62
  %conv81 = zext i16 %34 to i32
  %cmp82 = icmp ne i32 %conv81, 1021
  %shl = shl i32 1, %add79
  br i1 %cmp82, label %if.then84, label %if.else

if.then84:                                        ; preds = %if.then72
  %neg = xor i32 %shl, -1
  %35 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %cmask = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %35, i32 0, i32 13
  %36 = load i8, i8* %cmask, align 4, !tbaa !48
  %conv85 = zext i8 %36 to i32
  %and = and i32 %conv85, %neg
  br label %if.end91

if.else:                                          ; preds = %if.then72
  %37 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %cmask88 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %37, i32 0, i32 13
  %38 = load i8, i8* %cmask88, align 4, !tbaa !48
  %conv89 = zext i8 %38 to i32
  %or = or i32 %conv89, %shl
  br label %if.end91

if.end91:                                         ; preds = %if.else, %if.then84
  %or.sink = phi i32 [ %or, %if.else ], [ %and, %if.then84 ]
  %cmask88.sink = phi i8* [ %cmask88, %if.else ], [ %cmask, %if.then84 ]
  %voice_mode.0 = phi i32 [ 2, %if.then84 ], [ %conv69, %if.else ]
  %conv90 = trunc i32 %or.sink to i8
  store i8 %conv90, i8* %cmask88.sink, align 4, !tbaa !48
  %39 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %right_io = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %39, i32 0, i32 2
  %40 = load i32, i32* %right_io, align 8, !tbaa !29
  %41 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %cmask92 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %41, i32 0, i32 13
  %42 = load i8, i8* %cmask92, align 4, !tbaa !48
  %conv93 = zext i8 %42 to i32
  call void @opl3_command(i32 %40, i32 4, i32 %conv93)
  br label %if.end94

if.end94:                                         ; preds = %if.end91, %if.end67
  %voice_mode.1 = phi i32 [ %voice_mode.0, %if.end91 ], [ %conv69, %if.end67 ]
  %ioaddr95 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %43 = load i16, i16* %ioaddr95, align 2, !tbaa !38
  %conv96 = zext i16 %43 to i32
  %op97 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx98 = getelementptr inbounds [4 x i8], [4 x i8]* %op97, i64 0, i64 0
  %44 = load i8, i8* %arrayidx98, align 2, !tbaa !61
  %conv99 = zext i8 %44 to i32
  %add100 = add nsw i32 32, %conv99
  %operators = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx101 = getelementptr inbounds [32 x i8], [32 x i8]* %operators, i64 0, i64 0
  %45 = load i8, i8* %arrayidx101, align 4, !tbaa !61
  %conv102 = zext i8 %45 to i32
  call void @opl3_command(i32 %conv96, i32 %add100, i32 %conv102)
  %ioaddr103 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %46 = load i16, i16* %ioaddr103, align 2, !tbaa !38
  %conv104 = zext i16 %46 to i32
  %op105 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx106 = getelementptr inbounds [4 x i8], [4 x i8]* %op105, i64 0, i64 1
  %47 = load i8, i8* %arrayidx106, align 1, !tbaa !61
  %conv107 = zext i8 %47 to i32
  %add108 = add nsw i32 32, %conv107
  %operators109 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx110 = getelementptr inbounds [32 x i8], [32 x i8]* %operators109, i64 0, i64 1
  %48 = load i8, i8* %arrayidx110, align 1, !tbaa !61
  %conv111 = zext i8 %48 to i32
  call void @opl3_command(i32 %conv104, i32 %add108, i32 %conv111)
  %ioaddr112 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %49 = load i16, i16* %ioaddr112, align 2, !tbaa !38
  %conv113 = zext i16 %49 to i32
  %op114 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx115 = getelementptr inbounds [4 x i8], [4 x i8]* %op114, i64 0, i64 0
  %50 = load i8, i8* %arrayidx115, align 2, !tbaa !61
  %conv116 = zext i8 %50 to i32
  %add117 = add nsw i32 96, %conv116
  %operators118 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx119 = getelementptr inbounds [32 x i8], [32 x i8]* %operators118, i64 0, i64 4
  %51 = load i8, i8* %arrayidx119, align 4, !tbaa !61
  %conv120 = zext i8 %51 to i32
  call void @opl3_command(i32 %conv113, i32 %add117, i32 %conv120)
  %ioaddr121 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %52 = load i16, i16* %ioaddr121, align 2, !tbaa !38
  %conv122 = zext i16 %52 to i32
  %op123 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx124 = getelementptr inbounds [4 x i8], [4 x i8]* %op123, i64 0, i64 1
  %53 = load i8, i8* %arrayidx124, align 1, !tbaa !61
  %conv125 = zext i8 %53 to i32
  %add126 = add nsw i32 96, %conv125
  %operators127 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx128 = getelementptr inbounds [32 x i8], [32 x i8]* %operators127, i64 0, i64 5
  %54 = load i8, i8* %arrayidx128, align 1, !tbaa !61
  %conv129 = zext i8 %54 to i32
  call void @opl3_command(i32 %conv122, i32 %add126, i32 %conv129)
  %ioaddr130 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %55 = load i16, i16* %ioaddr130, align 2, !tbaa !38
  %conv131 = zext i16 %55 to i32
  %op132 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx133 = getelementptr inbounds [4 x i8], [4 x i8]* %op132, i64 0, i64 0
  %56 = load i8, i8* %arrayidx133, align 2, !tbaa !61
  %conv134 = zext i8 %56 to i32
  %add135 = add nsw i32 128, %conv134
  %operators136 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx137 = getelementptr inbounds [32 x i8], [32 x i8]* %operators136, i64 0, i64 6
  %57 = load i8, i8* %arrayidx137, align 2, !tbaa !61
  %conv138 = zext i8 %57 to i32
  call void @opl3_command(i32 %conv131, i32 %add135, i32 %conv138)
  %ioaddr139 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %58 = load i16, i16* %ioaddr139, align 2, !tbaa !38
  %conv140 = zext i16 %58 to i32
  %op141 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx142 = getelementptr inbounds [4 x i8], [4 x i8]* %op141, i64 0, i64 1
  %59 = load i8, i8* %arrayidx142, align 1, !tbaa !61
  %conv143 = zext i8 %59 to i32
  %add144 = add nsw i32 128, %conv143
  %operators145 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx146 = getelementptr inbounds [32 x i8], [32 x i8]* %operators145, i64 0, i64 7
  %60 = load i8, i8* %arrayidx146, align 1, !tbaa !61
  %conv147 = zext i8 %60 to i32
  call void @opl3_command(i32 %conv140, i32 %add144, i32 %conv147)
  %ioaddr148 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %61 = load i16, i16* %ioaddr148, align 2, !tbaa !38
  %conv149 = zext i16 %61 to i32
  %op150 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx151 = getelementptr inbounds [4 x i8], [4 x i8]* %op150, i64 0, i64 0
  %62 = load i8, i8* %arrayidx151, align 2, !tbaa !61
  %conv152 = zext i8 %62 to i32
  %add153 = add nsw i32 224, %conv152
  %operators154 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx155 = getelementptr inbounds [32 x i8], [32 x i8]* %operators154, i64 0, i64 8
  %63 = load i8, i8* %arrayidx155, align 4, !tbaa !61
  %conv156 = zext i8 %63 to i32
  call void @opl3_command(i32 %conv149, i32 %add153, i32 %conv156)
  %ioaddr157 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %64 = load i16, i16* %ioaddr157, align 2, !tbaa !38
  %conv158 = zext i16 %64 to i32
  %op159 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx160 = getelementptr inbounds [4 x i8], [4 x i8]* %op159, i64 0, i64 1
  %65 = load i8, i8* %arrayidx160, align 1, !tbaa !61
  %conv161 = zext i8 %65 to i32
  %add162 = add nsw i32 224, %conv161
  %operators163 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx164 = getelementptr inbounds [32 x i8], [32 x i8]* %operators163, i64 0, i64 9
  %66 = load i8, i8* %arrayidx164, align 1, !tbaa !61
  %conv165 = zext i8 %66 to i32
  call void @opl3_command(i32 %conv158, i32 %add162, i32 %conv165)
  %operators166 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx167 = getelementptr inbounds [32 x i8], [32 x i8]* %operators166, i64 0, i64 10
  %67 = load i8, i8* %arrayidx167, align 2, !tbaa !61
  %cmp168 = icmp ne i32 %7, 65535
  br i1 %cmp168, label %if.then170, label %if.end193

if.then170:                                       ; preds = %if.end94
  %conv171 = zext i8 %67 to i32
  %and172 = and i32 %conv171, -49
  %conv173 = trunc i32 %and172 to i8
  %cmp174 = icmp slt i32 %7, -64
  br i1 %cmp174, label %if.then176, label %if.else180

if.then176:                                       ; preds = %if.then170
  %conv177 = zext i8 %conv173 to i32
  %or178 = or i32 %conv177, 16
  br label %if.end192

if.else180:                                       ; preds = %if.then170
  %cmp181 = icmp sgt i32 %7, 64
  %conv184 = zext i8 %conv173 to i32
  %.sink = select i1 %cmp181, i32 32, i32 48
  %or189 = or i32 %conv184, %.sink
  br label %if.end192

if.end192:                                        ; preds = %if.else180, %if.then176
  %or189.sink = phi i32 [ %or189, %if.else180 ], [ %or178, %if.then176 ]
  %conv190 = trunc i32 %or189.sink to i8
  br label %if.end193

if.end193:                                        ; preds = %if.end192, %if.end94
  %fpc.2 = phi i8 [ %conv190, %if.end192 ], [ %67, %if.end94 ]
  %conv194 = zext i8 %fpc.2 to i32
  %and195 = and i32 %conv194, 48
  %tobool196 = icmp ne i32 %and195, 0
  %conv198 = zext i8 %fpc.2 to i32
  %or199 = or i32 %conv198, 48
  %conv200 = trunc i32 %or199 to i8
  %fpc.3 = select i1 %tobool196, i8 %fpc.2, i8 %conv200
  %ioaddr202 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %68 = load i16, i16* %ioaddr202, align 2, !tbaa !38
  %conv203 = zext i16 %68 to i32
  %voice_num204 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 0
  %69 = load i8, i8* %voice_num204, align 2, !tbaa !50
  %conv205 = zext i8 %69 to i32
  %add206 = add nsw i32 192, %conv205
  %conv207 = zext i8 %fpc.3 to i32
  call void @opl3_command(i32 %conv203, i32 %add206, i32 %conv207)
  %cmp208 = icmp eq i32 %voice_mode.1, 4
  br i1 %cmp208, label %if.then210, label %if.end300

if.then210:                                       ; preds = %if.end193
  %ioaddr211 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %70 = load i16, i16* %ioaddr211, align 2, !tbaa !38
  %conv212 = zext i16 %70 to i32
  %op213 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx214 = getelementptr inbounds [4 x i8], [4 x i8]* %op213, i64 0, i64 2
  %71 = load i8, i8* %arrayidx214, align 2, !tbaa !61
  %conv215 = zext i8 %71 to i32
  %add216 = add nsw i32 32, %conv215
  %operators217 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx218 = getelementptr inbounds [32 x i8], [32 x i8]* %operators217, i64 0, i64 11
  %72 = load i8, i8* %arrayidx218, align 1, !tbaa !61
  %conv219 = zext i8 %72 to i32
  call void @opl3_command(i32 %conv212, i32 %add216, i32 %conv219)
  %ioaddr220 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %73 = load i16, i16* %ioaddr220, align 2, !tbaa !38
  %conv221 = zext i16 %73 to i32
  %op222 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx223 = getelementptr inbounds [4 x i8], [4 x i8]* %op222, i64 0, i64 3
  %74 = load i8, i8* %arrayidx223, align 1, !tbaa !61
  %conv224 = zext i8 %74 to i32
  %add225 = add nsw i32 32, %conv224
  %operators226 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx227 = getelementptr inbounds [32 x i8], [32 x i8]* %operators226, i64 0, i64 12
  %75 = load i8, i8* %arrayidx227, align 4, !tbaa !61
  %conv228 = zext i8 %75 to i32
  call void @opl3_command(i32 %conv221, i32 %add225, i32 %conv228)
  %ioaddr229 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %76 = load i16, i16* %ioaddr229, align 2, !tbaa !38
  %conv230 = zext i16 %76 to i32
  %op231 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx232 = getelementptr inbounds [4 x i8], [4 x i8]* %op231, i64 0, i64 2
  %77 = load i8, i8* %arrayidx232, align 2, !tbaa !61
  %conv233 = zext i8 %77 to i32
  %add234 = add nsw i32 96, %conv233
  %operators235 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx236 = getelementptr inbounds [32 x i8], [32 x i8]* %operators235, i64 0, i64 15
  %78 = load i8, i8* %arrayidx236, align 1, !tbaa !61
  %conv237 = zext i8 %78 to i32
  call void @opl3_command(i32 %conv230, i32 %add234, i32 %conv237)
  %ioaddr238 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %79 = load i16, i16* %ioaddr238, align 2, !tbaa !38
  %conv239 = zext i16 %79 to i32
  %op240 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx241 = getelementptr inbounds [4 x i8], [4 x i8]* %op240, i64 0, i64 3
  %80 = load i8, i8* %arrayidx241, align 1, !tbaa !61
  %conv242 = zext i8 %80 to i32
  %add243 = add nsw i32 96, %conv242
  %operators244 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx245 = getelementptr inbounds [32 x i8], [32 x i8]* %operators244, i64 0, i64 16
  %81 = load i8, i8* %arrayidx245, align 4, !tbaa !61
  %conv246 = zext i8 %81 to i32
  call void @opl3_command(i32 %conv239, i32 %add243, i32 %conv246)
  %ioaddr247 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %82 = load i16, i16* %ioaddr247, align 2, !tbaa !38
  %conv248 = zext i16 %82 to i32
  %op249 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx250 = getelementptr inbounds [4 x i8], [4 x i8]* %op249, i64 0, i64 2
  %83 = load i8, i8* %arrayidx250, align 2, !tbaa !61
  %conv251 = zext i8 %83 to i32
  %add252 = add nsw i32 128, %conv251
  %operators253 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx254 = getelementptr inbounds [32 x i8], [32 x i8]* %operators253, i64 0, i64 17
  %84 = load i8, i8* %arrayidx254, align 1, !tbaa !61
  %conv255 = zext i8 %84 to i32
  call void @opl3_command(i32 %conv248, i32 %add252, i32 %conv255)
  %ioaddr256 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %85 = load i16, i16* %ioaddr256, align 2, !tbaa !38
  %conv257 = zext i16 %85 to i32
  %op258 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx259 = getelementptr inbounds [4 x i8], [4 x i8]* %op258, i64 0, i64 3
  %86 = load i8, i8* %arrayidx259, align 1, !tbaa !61
  %conv260 = zext i8 %86 to i32
  %add261 = add nsw i32 128, %conv260
  %operators262 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx263 = getelementptr inbounds [32 x i8], [32 x i8]* %operators262, i64 0, i64 18
  %87 = load i8, i8* %arrayidx263, align 2, !tbaa !61
  %conv264 = zext i8 %87 to i32
  call void @opl3_command(i32 %conv257, i32 %add261, i32 %conv264)
  %ioaddr265 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %88 = load i16, i16* %ioaddr265, align 2, !tbaa !38
  %conv266 = zext i16 %88 to i32
  %op267 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx268 = getelementptr inbounds [4 x i8], [4 x i8]* %op267, i64 0, i64 2
  %89 = load i8, i8* %arrayidx268, align 2, !tbaa !61
  %conv269 = zext i8 %89 to i32
  %add270 = add nsw i32 224, %conv269
  %operators271 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx272 = getelementptr inbounds [32 x i8], [32 x i8]* %operators271, i64 0, i64 19
  %90 = load i8, i8* %arrayidx272, align 1, !tbaa !61
  %conv273 = zext i8 %90 to i32
  call void @opl3_command(i32 %conv266, i32 %add270, i32 %conv273)
  %ioaddr274 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %91 = load i16, i16* %ioaddr274, align 2, !tbaa !38
  %conv275 = zext i16 %91 to i32
  %op276 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx277 = getelementptr inbounds [4 x i8], [4 x i8]* %op276, i64 0, i64 3
  %92 = load i8, i8* %arrayidx277, align 1, !tbaa !61
  %conv278 = zext i8 %92 to i32
  %add279 = add nsw i32 224, %conv278
  %operators280 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx281 = getelementptr inbounds [32 x i8], [32 x i8]* %operators280, i64 0, i64 20
  %93 = load i8, i8* %arrayidx281, align 4, !tbaa !61
  %conv282 = zext i8 %93 to i32
  call void @opl3_command(i32 %conv275, i32 %add279, i32 %conv282)
  %operators283 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx284 = getelementptr inbounds [32 x i8], [32 x i8]* %operators283, i64 0, i64 21
  %94 = load i8, i8* %arrayidx284, align 1, !tbaa !61
  %conv285 = zext i8 %94 to i32
  %and286 = and i32 %conv285, 48
  %tobool287 = icmp ne i32 %and286, 0
  %conv289 = zext i8 %94 to i32
  %or290 = or i32 %conv289, 48
  %conv291 = trunc i32 %or290 to i8
  %fpc.4 = select i1 %tobool287, i8 %94, i8 %conv291
  %ioaddr293 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %95 = load i16, i16* %ioaddr293, align 2, !tbaa !38
  %conv294 = zext i16 %95 to i32
  %voice_num295 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 0
  %96 = load i8, i8* %voice_num295, align 2, !tbaa !50
  %conv296 = zext i8 %96 to i32
  %add297 = add nsw i32 192, %conv296
  %add298 = add nsw i32 %add297, 3
  %conv299 = zext i8 %fpc.4 to i32
  call void @opl3_command(i32 %conv294, i32 %add298, i32 %conv299)
  br label %if.end300

if.end300:                                        ; preds = %if.then210, %if.end193
  %97 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc301 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %97, i32 0, i32 5
  %idxprom302 = sext i32 %voice to i64
  %arrayidx303 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc301, i64 0, i64 %idxprom302
  %mode = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx303, i32 0, i32 6
  store i32 %voice_mode.1, i32* %mode, align 4, !tbaa !60
  %98 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc304 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %98, i32 0, i32 5
  %idxprom305 = sext i32 %voice to i64
  %arrayidx306 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc304, i64 0, i64 %idxprom305
  %volume307 = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx306, i32 0, i32 5
  %99 = load i32, i32* %volume307, align 8, !tbaa !55
  call void @set_voice_volume(i32 %voice, i32 %volume, i32 %99)
  %call308 = call i32 @note_to_freq(i32 %note)
  %div = sdiv i32 %call308, 1000
  %conv309 = sext i32 %div to i64
  %100 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc310 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %100, i32 0, i32 5
  %idxprom311 = sext i32 %voice to i64
  %arrayidx312 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc310, i64 0, i64 %idxprom311
  %orig_freq = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx312, i32 0, i32 3
  store i64 %conv309, i64* %orig_freq, align 8, !tbaa !58
  %conv313 = trunc i64 %conv309 to i32
  %101 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc314 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %101, i32 0, i32 5
  %idxprom315 = sext i32 %voice to i64
  %arrayidx316 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc314, i64 0, i64 %idxprom315
  %orig_freq317 = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx316, i32 0, i32 3
  %102 = load i64, i64* %orig_freq317, align 8, !tbaa !58
  %103 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc318 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %103, i32 0, i32 5
  %idxprom319 = sext i32 %voice to i64
  %arrayidx320 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc318, i64 0, i64 %idxprom319
  %bender = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx320, i32 0, i32 1
  %104 = load i64, i64* %bender, align 8, !tbaa !54
  %conv321 = trunc i64 %104 to i32
  %105 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc322 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %105, i32 0, i32 5
  %idxprom323 = sext i32 %voice to i64
  %arrayidx324 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc322, i64 0, i64 %idxprom323
  %bender_range = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx324, i32 0, i32 2
  %106 = load i64, i64* %bender_range, align 8, !tbaa !57
  %conv325 = trunc i64 %106 to i32
  %call326 = call i64 @compute_finetune(i64 %102, i32 %conv321, i32 %conv325, i32 0)
  %conv327 = trunc i64 %call326 to i32
  %conv328 = sext i32 %conv327 to i64
  %107 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc329 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %107, i32 0, i32 5
  %idxprom330 = sext i32 %voice to i64
  %arrayidx331 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc329, i64 0, i64 %idxprom330
  %current_freq = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx331, i32 0, i32 4
  store i64 %conv328, i64* %current_freq, align 8, !tbaa !59
  call void @freq_to_fnum(i32 %conv327, i32* %block, i32* %fnum)
  %108 = load i32, i32* %fnum, align 4, !tbaa !12
  %and332 = and i32 %108, 255
  %conv333 = trunc i32 %and332 to i8
  %ioaddr334 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %109 = load i16, i16* %ioaddr334, align 2, !tbaa !38
  %conv335 = zext i16 %109 to i32
  %voice_num336 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 0
  %110 = load i8, i8* %voice_num336, align 2, !tbaa !50
  %conv337 = zext i8 %110 to i32
  %add338 = add nsw i32 160, %conv337
  %conv339 = zext i8 %conv333 to i32
  call void @opl3_command(i32 %conv335, i32 %add338, i32 %conv339)
  %111 = load i32, i32* %block, align 4, !tbaa !12
  %and340 = and i32 %111, 7
  %shl341 = shl i32 %and340, 2
  %or342 = or i32 32, %shl341
  %112 = load i32, i32* %fnum, align 4, !tbaa !12
  %shr = ashr i32 %112, 8
  %and343 = and i32 %shr, 3
  %or344 = or i32 %or342, %and343
  %conv345 = trunc i32 %or344 to i8
  %113 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc346 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %113, i32 0, i32 5
  %idxprom347 = sext i32 %voice to i64
  %arrayidx348 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc346, i64 0, i64 %idxprom347
  %keyon_byte = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx348, i32 0, i32 0
  store i8 %conv345, i8* %keyon_byte, align 8, !tbaa !51
  %ioaddr349 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %114 = load i16, i16* %ioaddr349, align 2, !tbaa !38
  %conv350 = zext i16 %114 to i32
  %voice_num351 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 0
  %115 = load i8, i8* %voice_num351, align 2, !tbaa !50
  %conv352 = zext i8 %115 to i32
  %add353 = add nsw i32 176, %conv352
  %conv354 = zext i8 %conv345 to i32
  call void @opl3_command(i32 %conv350, i32 %add353, i32 %conv354)
  %cmp355 = icmp eq i32 %voice_mode.1, 4
  br i1 %cmp355, label %if.then357, label %cleanup

if.then357:                                       ; preds = %if.end300
  %ioaddr358 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %116 = load i16, i16* %ioaddr358, align 2, !tbaa !38
  %conv359 = zext i16 %116 to i32
  %voice_num360 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 0
  %117 = load i8, i8* %voice_num360, align 2, !tbaa !50
  %conv361 = zext i8 %117 to i32
  %add362 = add nsw i32 176, %conv361
  %add363 = add nsw i32 %add362, 3
  %conv364 = zext i8 %conv345 to i32
  call void @opl3_command(i32 %conv359, i32 %add363, i32 %conv364)
  br label %cleanup

cleanup:                                          ; preds = %if.end300, %if.then357, %land.lhs.true, %if.end, %entry, %lor.lhs.false, %if.then57, %if.then13
  %118 = bitcast i32* %fnum to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %118) #8
  %119 = bitcast i32* %block to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %119) #8
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @opl3_set_instr(i32 %dev, i32 %voice, i32 %instr_no) #3 {
entry:
  %cmp = icmp slt i32 %voice, 0
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 3
  %1 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp1 = icmp sge i32 %voice, %1
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %cmp2 = icmp slt i32 %instr_no, 0
  %cmp4 = icmp sge i32 %instr_no, 256
  %or.cond = or i1 %cmp2, %cmp4
  %instr_no.addr.0 = select i1 %or.cond, i32 0, i32 %instr_no
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %i_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 8
  %idxprom = sext i32 %instr_no.addr.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.sbi_instrument], [256 x %struct.sbi_instrument]* %i_map, i64 0, i64 %idxprom
  %3 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %act_i = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %3, i32 0, i32 9
  %idxprom7 = sext i32 %voice to i64
  %arrayidx8 = getelementptr inbounds [18 x %struct.sbi_instrument*], [18 x %struct.sbi_instrument*]* %act_i, i64 0, i64 %idxprom7
  store %struct.sbi_instrument* %arrayidx, %struct.sbi_instrument** %arrayidx8, align 8, !tbaa !14
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @opl3_reset(i32 %devno) #3 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 18
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 4
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map, i64 0, i64 %idxprom
  store i32 %i.0, i32* %arrayidx, align 4, !tbaa !12
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond1

for.cond1:                                        ; preds = %if.end, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc73, %if.end ]
  %1 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %1, i32 0, i32 3
  %2 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp2 = icmp slt i32 %i.1, %2
  %3 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  br i1 %cmp2, label %for.body3, label %for.end74

for.body3:                                        ; preds = %for.cond1
  %lv_map4 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %3, i32 0, i32 4
  %idxprom5 = sext i32 %i.1 to i64
  %arrayidx6 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map4, i64 0, i64 %idxprom5
  %4 = load i32, i32* %arrayidx6, align 4, !tbaa !12
  %idxprom7 = sext i32 %4 to i64
  %arrayidx8 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom7
  %ioaddr = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx8, i32 0, i32 2
  %5 = load i16, i16* %ioaddr, align 2, !tbaa !38
  %conv = zext i16 %5 to i32
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map9 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %6, i32 0, i32 4
  %idxprom10 = sext i32 %i.1 to i64
  %arrayidx11 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map9, i64 0, i64 %idxprom10
  %7 = load i32, i32* %arrayidx11, align 4, !tbaa !12
  %idxprom12 = sext i32 %7 to i64
  %arrayidx13 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom12
  %op = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx13, i32 0, i32 3
  %arrayidx14 = getelementptr inbounds [4 x i8], [4 x i8]* %op, i64 0, i64 0
  %8 = load i8, i8* %arrayidx14, align 4, !tbaa !61
  %conv15 = zext i8 %8 to i32
  %add = add nsw i32 64, %conv15
  call void @opl3_command(i32 %conv, i32 %add, i32 255)
  %9 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map16 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %9, i32 0, i32 4
  %idxprom17 = sext i32 %i.1 to i64
  %arrayidx18 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map16, i64 0, i64 %idxprom17
  %10 = load i32, i32* %arrayidx18, align 4, !tbaa !12
  %idxprom19 = sext i32 %10 to i64
  %arrayidx20 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom19
  %ioaddr21 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx20, i32 0, i32 2
  %11 = load i16, i16* %ioaddr21, align 2, !tbaa !38
  %conv22 = zext i16 %11 to i32
  %12 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map23 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %12, i32 0, i32 4
  %idxprom24 = sext i32 %i.1 to i64
  %arrayidx25 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map23, i64 0, i64 %idxprom24
  %13 = load i32, i32* %arrayidx25, align 4, !tbaa !12
  %idxprom26 = sext i32 %13 to i64
  %arrayidx27 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom26
  %op28 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx27, i32 0, i32 3
  %arrayidx29 = getelementptr inbounds [4 x i8], [4 x i8]* %op28, i64 0, i64 1
  %14 = load i8, i8* %arrayidx29, align 1, !tbaa !61
  %conv30 = zext i8 %14 to i32
  %add31 = add nsw i32 64, %conv30
  call void @opl3_command(i32 %conv22, i32 %add31, i32 255)
  %15 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map32 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %15, i32 0, i32 4
  %idxprom33 = sext i32 %i.1 to i64
  %arrayidx34 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map32, i64 0, i64 %idxprom33
  %16 = load i32, i32* %arrayidx34, align 4, !tbaa !12
  %idxprom35 = sext i32 %16 to i64
  %arrayidx36 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom35
  %voice_mode = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx36, i32 0, i32 1
  %17 = load i8, i8* %voice_mode, align 1, !tbaa !49
  %conv37 = zext i8 %17 to i32
  %cmp38 = icmp eq i32 %conv37, 4
  br i1 %cmp38, label %if.then, label %if.end

if.then:                                          ; preds = %for.body3
  %18 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map40 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %18, i32 0, i32 4
  %idxprom41 = sext i32 %i.1 to i64
  %arrayidx42 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map40, i64 0, i64 %idxprom41
  %19 = load i32, i32* %arrayidx42, align 4, !tbaa !12
  %idxprom43 = sext i32 %19 to i64
  %arrayidx44 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom43
  %ioaddr45 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx44, i32 0, i32 2
  %20 = load i16, i16* %ioaddr45, align 2, !tbaa !38
  %conv46 = zext i16 %20 to i32
  %21 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map47 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %21, i32 0, i32 4
  %idxprom48 = sext i32 %i.1 to i64
  %arrayidx49 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map47, i64 0, i64 %idxprom48
  %22 = load i32, i32* %arrayidx49, align 4, !tbaa !12
  %idxprom50 = sext i32 %22 to i64
  %arrayidx51 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom50
  %op52 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx51, i32 0, i32 3
  %arrayidx53 = getelementptr inbounds [4 x i8], [4 x i8]* %op52, i64 0, i64 2
  %23 = load i8, i8* %arrayidx53, align 2, !tbaa !61
  %conv54 = zext i8 %23 to i32
  %add55 = add nsw i32 64, %conv54
  call void @opl3_command(i32 %conv46, i32 %add55, i32 255)
  %24 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map56 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %24, i32 0, i32 4
  %idxprom57 = sext i32 %i.1 to i64
  %arrayidx58 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map56, i64 0, i64 %idxprom57
  %25 = load i32, i32* %arrayidx58, align 4, !tbaa !12
  %idxprom59 = sext i32 %25 to i64
  %arrayidx60 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom59
  %ioaddr61 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx60, i32 0, i32 2
  %26 = load i16, i16* %ioaddr61, align 2, !tbaa !38
  %conv62 = zext i16 %26 to i32
  %27 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map63 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %27, i32 0, i32 4
  %idxprom64 = sext i32 %i.1 to i64
  %arrayidx65 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map63, i64 0, i64 %idxprom64
  %28 = load i32, i32* %arrayidx65, align 4, !tbaa !12
  %idxprom66 = sext i32 %28 to i64
  %arrayidx67 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom66
  %op68 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx67, i32 0, i32 3
  %arrayidx69 = getelementptr inbounds [4 x i8], [4 x i8]* %op68, i64 0, i64 3
  %29 = load i8, i8* %arrayidx69, align 1, !tbaa !61
  %conv70 = zext i8 %29 to i32
  %add71 = add nsw i32 64, %conv70
  call void @opl3_command(i32 %conv62, i32 %add71, i32 255)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body3
  %call = call i32 @opl3_kill_note(i32 %devno, i32 %i.1, i32 0, i32 64)
  %inc73 = add nsw i32 %i.1, 1
  br label %for.cond1

for.end74:                                        ; preds = %for.cond1
  %model = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %3, i32 0, i32 12
  %30 = load i32, i32* %model, align 8, !tbaa !30
  %cmp75 = icmp eq i32 %30, 2
  br i1 %cmp75, label %if.then77, label %if.end89

if.then77:                                        ; preds = %for.end74
  %31 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice78 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %31, i32 0, i32 3
  store i32 18, i32* %nr_voice78, align 4, !tbaa !19
  %32 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %v_alloc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %32, i32 0, i32 6
  %33 = load %struct.voice_alloc_info*, %struct.voice_alloc_info** %v_alloc, align 8, !tbaa !35
  %max_voice = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %33, i32 0, i32 0
  store i32 18, i32* %max_voice, align 4, !tbaa !37
  br label %for.cond79

for.cond79:                                       ; preds = %for.body82, %if.then77
  %i.2 = phi i32 [ 0, %if.then77 ], [ %inc87, %for.body82 ]
  %cmp80 = icmp slt i32 %i.2, 18
  br i1 %cmp80, label %for.body82, label %if.end89

for.body82:                                       ; preds = %for.cond79
  %idxprom83 = sext i32 %i.2 to i64
  %arrayidx84 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom83
  %voice_mode85 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx84, i32 0, i32 1
  store i8 2, i8* %voice_mode85, align 1, !tbaa !49
  %inc87 = add nsw i32 %i.2, 1
  br label %for.cond79

if.end89:                                         ; preds = %for.cond79, %for.end74
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @opl3_hw_control(i32 %dev, i8* %event) #3 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @opl3_load_patch(i32 %dev, i32 %format, i8* %addr, i32 %count, i32 %pmgr_flag) #3 {
entry:
  %ins = alloca %struct.sbi_instrument, align 4
  %0 = bitcast %struct.sbi_instrument* %ins to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %0) #8
  %conv = sext i32 %count to i64
  %cmp = icmp ult i64 %conv, 40
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.19, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.sbi_instrument* %ins to i8*
  %call2 = call i64 @copy_from_user(i8* %1, i8* %addr, i64 40)
  %tobool = icmp ne i64 %call2, 0
  br i1 %tobool, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %channel = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %ins, i32 0, i32 2
  %2 = load i32, i32* %channel, align 4, !tbaa !41
  %cmp5 = icmp slt i32 %2, 0
  br i1 %cmp5, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end4
  %channel7 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %ins, i32 0, i32 2
  %3 = load i32, i32* %channel7, align 4, !tbaa !41
  %cmp8 = icmp sge i32 %3, 256
  br i1 %cmp8, label %if.then10, label %if.end13

if.then10:                                        ; preds = %lor.lhs.false, %if.end4
  %channel11 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %ins, i32 0, i32 2
  %4 = load i32, i32* %channel11, align 4, !tbaa !41
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.14, i32 0, i32 0), i32 %4)
  br label %cleanup

if.end13:                                         ; preds = %lor.lhs.false
  %conv14 = trunc i32 %format to i16
  %key = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %ins, i32 0, i32 0
  store i16 %conv14, i16* %key, align 4, !tbaa !62
  %channel15 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %ins, i32 0, i32 2
  %5 = load i32, i32* %channel15, align 4, !tbaa !41
  %call16 = call i32 @store_instr(i32 %5, %struct.sbi_instrument* %ins)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.end13, %if.then10, %if.then
  %retval.0 = phi i32 [ -22, %if.then ], [ -22, %if.then10 ], [ %call16, %if.end13 ], [ -14, %if.end ]
  %6 = bitcast %struct.sbi_instrument* %ins to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %6) #8
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @opl3_aftertouch(i32 %dev, i32 %voice, i32 %pressure) #3 {
entry:
  %cmp = icmp slt i32 %voice, 0
  br i1 %cmp, label %cleanup.cont, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 3
  %1 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp1 = icmp sge i32 %voice, %1
  br i1 %cmp1, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 4
  %idxprom = sext i32 %voice to i64
  %arrayidx = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %idxprom2 = sext i32 %3 to i64
  %arrayidx3 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom2
  %voice_mode = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 1
  %4 = load i8, i8* %voice_mode, align 1, !tbaa !49
  %conv = zext i8 %4 to i32
  %cmp4 = icmp eq i32 %conv, 0
  br i1 %cmp4, label %cleanup.cont, label %if.end7

if.end7:                                          ; preds = %if.end
  %5 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %act_i = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %5, i32 0, i32 9
  %idxprom8 = sext i32 %voice to i64
  %arrayidx9 = getelementptr inbounds [18 x %struct.sbi_instrument*], [18 x %struct.sbi_instrument*]* %act_i, i64 0, i64 %idxprom8
  %6 = load %struct.sbi_instrument*, %struct.sbi_instrument** %arrayidx9, align 8, !tbaa !14
  %tobool = icmp ne %struct.sbi_instrument* %6, null
  %7 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8
  %i_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %7, i32 0, i32 8
  %arrayidx11 = getelementptr inbounds [256 x %struct.sbi_instrument], [256 x %struct.sbi_instrument]* %i_map, i64 0, i64 0
  %instr.0 = select i1 %tobool, %struct.sbi_instrument* %6, %struct.sbi_instrument* %arrayidx11
  %8 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %8, i32 0, i32 5
  %idxprom13 = sext i32 %voice to i64
  %arrayidx14 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc, i64 0, i64 %idxprom13
  %mode = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx14, i32 0, i32 6
  %9 = load i32, i32* %mode, align 4, !tbaa !60
  %cmp15 = icmp eq i32 %9, 4
  %operators = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  br i1 %cmp15, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end7
  %arrayidx18 = getelementptr inbounds [32 x i8], [32 x i8]* %operators, i64 0, i64 10
  %10 = load i8, i8* %arrayidx18, align 2, !tbaa !61
  %conv19 = zext i8 %10 to i32
  %and = and i32 %conv19, 1
  %shl = shl i32 %and, 1
  %operators20 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx21 = getelementptr inbounds [32 x i8], [32 x i8]* %operators20, i64 0, i64 21
  %11 = load i8, i8* %arrayidx21, align 1, !tbaa !61
  %conv22 = zext i8 %11 to i32
  %and23 = and i32 %conv22, 1
  %or = or i32 %shl, %and23
  %Pivot6 = icmp slt i32 %or, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.then17
  %Pivot4 = icmp slt i32 %or, 3
  br i1 %Pivot4, label %sw.bb64, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %or, 3
  br i1 %SwitchLeaf2, label %sw.bb93, label %cleanup.cont

NodeBlock:                                        ; preds = %if.then17
  %Pivot = icmp slt i32 %or, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb35

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %or, 0
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup.cont

sw.bb:                                            ; preds = %LeafBlock
  %operators24 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx25 = getelementptr inbounds [32 x i8], [32 x i8]* %operators24, i64 0, i64 14
  %12 = load i8, i8* %arrayidx25, align 2, !tbaa !61
  %conv26 = zext i8 %12 to i32
  %cmp27 = icmp sgt i32 %pressure, 110
  %or30 = or i32 %conv26, 64
  %or30.conv26 = select i1 %cmp27, i32 %or30, i32 %conv26
  %ioaddr = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %13 = load i16, i16* %ioaddr, align 2, !tbaa !38
  %conv32 = zext i16 %13 to i32
  %op = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx33 = getelementptr inbounds [4 x i8], [4 x i8]* %op, i64 0, i64 3
  %14 = load i8, i8* %arrayidx33, align 1, !tbaa !61
  %conv34 = zext i8 %14 to i32
  %add = add nsw i32 32, %conv34
  call void @opl3_command(i32 %conv32, i32 %add, i32 %or30.conv26)
  br label %cleanup.cont

sw.bb35:                                          ; preds = %NodeBlock
  %operators36 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx37 = getelementptr inbounds [32 x i8], [32 x i8]* %operators36, i64 0, i64 1
  %15 = load i8, i8* %arrayidx37, align 1, !tbaa !61
  %conv38 = zext i8 %15 to i32
  %cmp39 = icmp sgt i32 %pressure, 110
  %or42 = or i32 %conv38, 64
  %or42.conv38 = select i1 %cmp39, i32 %or42, i32 %conv38
  %ioaddr44 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %16 = load i16, i16* %ioaddr44, align 2, !tbaa !38
  %conv45 = zext i16 %16 to i32
  %op46 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx47 = getelementptr inbounds [4 x i8], [4 x i8]* %op46, i64 0, i64 1
  %17 = load i8, i8* %arrayidx47, align 1, !tbaa !61
  %conv48 = zext i8 %17 to i32
  %add49 = add nsw i32 32, %conv48
  call void @opl3_command(i32 %conv45, i32 %add49, i32 %or42.conv38)
  %operators50 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx51 = getelementptr inbounds [32 x i8], [32 x i8]* %operators50, i64 0, i64 14
  %18 = load i8, i8* %arrayidx51, align 2, !tbaa !61
  %conv52 = zext i8 %18 to i32
  %cmp53 = icmp sgt i32 %pressure, 110
  %or56 = or i32 %conv52, 64
  %tmp.2 = select i1 %cmp53, i32 %or56, i32 %conv52
  %ioaddr58 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %19 = load i16, i16* %ioaddr58, align 2, !tbaa !38
  %conv59 = zext i16 %19 to i32
  %op60 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx61 = getelementptr inbounds [4 x i8], [4 x i8]* %op60, i64 0, i64 3
  %20 = load i8, i8* %arrayidx61, align 1, !tbaa !61
  %conv62 = zext i8 %20 to i32
  %add63 = add nsw i32 32, %conv62
  call void @opl3_command(i32 %conv59, i32 %add63, i32 %tmp.2)
  br label %cleanup.cont

sw.bb64:                                          ; preds = %NodeBlock3
  %operators65 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx66 = getelementptr inbounds [32 x i8], [32 x i8]* %operators65, i64 0, i64 0
  %21 = load i8, i8* %arrayidx66, align 4, !tbaa !61
  %conv67 = zext i8 %21 to i32
  %cmp68 = icmp sgt i32 %pressure, 110
  %or71 = or i32 %conv67, 64
  %or71.conv67 = select i1 %cmp68, i32 %or71, i32 %conv67
  %ioaddr73 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %22 = load i16, i16* %ioaddr73, align 2, !tbaa !38
  %conv74 = zext i16 %22 to i32
  %op75 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx76 = getelementptr inbounds [4 x i8], [4 x i8]* %op75, i64 0, i64 0
  %23 = load i8, i8* %arrayidx76, align 2, !tbaa !61
  %conv77 = zext i8 %23 to i32
  %add78 = add nsw i32 32, %conv77
  call void @opl3_command(i32 %conv74, i32 %add78, i32 %or71.conv67)
  %operators79 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx80 = getelementptr inbounds [32 x i8], [32 x i8]* %operators79, i64 0, i64 14
  %24 = load i8, i8* %arrayidx80, align 2, !tbaa !61
  %conv81 = zext i8 %24 to i32
  %cmp82 = icmp sgt i32 %pressure, 110
  %or85 = or i32 %conv81, 64
  %tmp.4 = select i1 %cmp82, i32 %or85, i32 %conv81
  %ioaddr87 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %25 = load i16, i16* %ioaddr87, align 2, !tbaa !38
  %conv88 = zext i16 %25 to i32
  %op89 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx90 = getelementptr inbounds [4 x i8], [4 x i8]* %op89, i64 0, i64 3
  %26 = load i8, i8* %arrayidx90, align 1, !tbaa !61
  %conv91 = zext i8 %26 to i32
  %add92 = add nsw i32 32, %conv91
  call void @opl3_command(i32 %conv88, i32 %add92, i32 %tmp.4)
  br label %cleanup.cont

sw.bb93:                                          ; preds = %LeafBlock1
  %operators94 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx95 = getelementptr inbounds [32 x i8], [32 x i8]* %operators94, i64 0, i64 0
  %27 = load i8, i8* %arrayidx95, align 4, !tbaa !61
  %conv96 = zext i8 %27 to i32
  %cmp97 = icmp sgt i32 %pressure, 110
  %or100 = or i32 %conv96, 64
  %or100.conv96 = select i1 %cmp97, i32 %or100, i32 %conv96
  %ioaddr102 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %28 = load i16, i16* %ioaddr102, align 2, !tbaa !38
  %conv103 = zext i16 %28 to i32
  %op104 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx105 = getelementptr inbounds [4 x i8], [4 x i8]* %op104, i64 0, i64 0
  %29 = load i8, i8* %arrayidx105, align 2, !tbaa !61
  %conv106 = zext i8 %29 to i32
  %add107 = add nsw i32 32, %conv106
  call void @opl3_command(i32 %conv103, i32 %add107, i32 %or100.conv96)
  %operators108 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx109 = getelementptr inbounds [32 x i8], [32 x i8]* %operators108, i64 0, i64 13
  %30 = load i8, i8* %arrayidx109, align 1, !tbaa !61
  %conv110 = zext i8 %30 to i32
  %cmp111 = icmp sgt i32 %pressure, 110
  %or114 = or i32 %conv110, 64
  %tmp.6 = select i1 %cmp111, i32 %or114, i32 %conv110
  %ioaddr116 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %31 = load i16, i16* %ioaddr116, align 2, !tbaa !38
  %conv117 = zext i16 %31 to i32
  %op118 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx119 = getelementptr inbounds [4 x i8], [4 x i8]* %op118, i64 0, i64 2
  %32 = load i8, i8* %arrayidx119, align 2, !tbaa !61
  %conv120 = zext i8 %32 to i32
  %add121 = add nsw i32 32, %conv120
  call void @opl3_command(i32 %conv117, i32 %add121, i32 %tmp.6)
  %operators122 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx123 = getelementptr inbounds [32 x i8], [32 x i8]* %operators122, i64 0, i64 14
  %33 = load i8, i8* %arrayidx123, align 2, !tbaa !61
  %conv124 = zext i8 %33 to i32
  %cmp125 = icmp sgt i32 %pressure, 110
  %or128 = or i32 %conv124, 64
  %or128.conv124 = select i1 %cmp125, i32 %or128, i32 %conv124
  %ioaddr130 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %34 = load i16, i16* %ioaddr130, align 2, !tbaa !38
  %conv131 = zext i16 %34 to i32
  %op132 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx133 = getelementptr inbounds [4 x i8], [4 x i8]* %op132, i64 0, i64 3
  %35 = load i8, i8* %arrayidx133, align 1, !tbaa !61
  %conv134 = zext i8 %35 to i32
  %add135 = add nsw i32 32, %conv134
  call void @opl3_command(i32 %conv131, i32 %add135, i32 %or128.conv124)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end7
  %arrayidx137 = getelementptr inbounds [32 x i8], [32 x i8]* %operators, i64 0, i64 0
  %36 = load i8, i8* %arrayidx137, align 4, !tbaa !61
  %conv138 = zext i8 %36 to i32
  %cmp139 = icmp sgt i32 %pressure, 110
  %or142 = or i32 %conv138, 64
  %or142.conv138 = select i1 %cmp139, i32 %or142, i32 %conv138
  %ioaddr144 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %37 = load i16, i16* %ioaddr144, align 2, !tbaa !38
  %conv145 = zext i16 %37 to i32
  %op146 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx147 = getelementptr inbounds [4 x i8], [4 x i8]* %op146, i64 0, i64 0
  %38 = load i8, i8* %arrayidx147, align 2, !tbaa !61
  %conv148 = zext i8 %38 to i32
  %add149 = add nsw i32 32, %conv148
  call void @opl3_command(i32 %conv145, i32 %add149, i32 %or142.conv138)
  %operators150 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx151 = getelementptr inbounds [32 x i8], [32 x i8]* %operators150, i64 0, i64 10
  %39 = load i8, i8* %arrayidx151, align 2, !tbaa !61
  %conv152 = zext i8 %39 to i32
  %and153 = and i32 %conv152, 1
  %tobool154 = icmp ne i32 %and153, 0
  br i1 %tobool154, label %if.then155, label %cleanup.cont

if.then155:                                       ; preds = %if.else
  %operators156 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx157 = getelementptr inbounds [32 x i8], [32 x i8]* %operators156, i64 0, i64 1
  %40 = load i8, i8* %arrayidx157, align 1, !tbaa !61
  %conv158 = zext i8 %40 to i32
  %cmp159 = icmp sgt i32 %pressure, 110
  %or162 = or i32 %conv158, 64
  %or162.conv158 = select i1 %cmp159, i32 %or162, i32 %conv158
  %ioaddr164 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %41 = load i16, i16* %ioaddr164, align 2, !tbaa !38
  %conv165 = zext i16 %41 to i32
  %op166 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx167 = getelementptr inbounds [4 x i8], [4 x i8]* %op166, i64 0, i64 1
  %42 = load i8, i8* %arrayidx167, align 1, !tbaa !61
  %conv168 = zext i8 %42 to i32
  %add169 = add nsw i32 32, %conv168
  call void @opl3_command(i32 %conv165, i32 %add169, i32 %or162.conv158)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %lor.lhs.false, %entry, %if.end, %if.else, %if.then155, %sw.bb, %sw.bb35, %sw.bb64, %sw.bb93, %LeafBlock1, %LeafBlock
  %cleanup.dest.slot.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %entry ], [ 1, %if.end ], [ 0, %if.else ], [ 0, %if.then155 ], [ 0, %sw.bb ], [ 0, %sw.bb35 ], [ 0, %sw.bb64 ], [ 0, %sw.bb93 ], [ 0, %LeafBlock1 ], [ 0, %LeafBlock ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @opl3_controller(i32 %dev, i32 %voice, i32 %ctrl_num, i32 %value) #3 {
entry:
  %cmp = icmp slt i32 %voice, 0
  br i1 %cmp, label %sw.epilog, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 3
  %1 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp1 = icmp sge i32 %voice, %1
  br i1 %cmp1, label %sw.epilog, label %NodeBlock7

NodeBlock7:                                       ; preds = %lor.lhs.false
  %Pivot8 = icmp slt i32 %ctrl_num, 254
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %ctrl_num, 255
  br i1 %Pivot6, label %sw.bb2, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %ctrl_num, 255
  br i1 %SwitchLeaf4, label %sw.bb, label %sw.epilog

NodeBlock:                                        ; preds = %NodeBlock7
  %Pivot = icmp slt i32 %ctrl_num, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %ctrl_num, 10
  br i1 %SwitchLeaf2, label %sw.bb7, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %ctrl_num, 7
  br i1 %SwitchLeaf, label %sw.bb3, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock3
  call void @bend_pitch(i32 %dev, i32 %voice, i32 %value)
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock5
  %conv = sext i32 %value to i64
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 5
  %idxprom = sext i32 %voice to i64
  %arrayidx = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc, i64 0, i64 %idxprom
  %bender_range = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx, i32 0, i32 2
  store i64 %conv, i64* %bender_range, align 8, !tbaa !57
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock
  %div = sdiv i32 %value, 128
  %3 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc4 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %3, i32 0, i32 5
  %idxprom5 = sext i32 %voice to i64
  %arrayidx6 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc4, i64 0, i64 %idxprom5
  %volume = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx6, i32 0, i32 5
  store i32 %div, i32* %volume, align 8, !tbaa !55
  br label %sw.epilog

sw.bb7:                                           ; preds = %LeafBlock1
  %mul = mul nsw i32 %value, 2
  %sub = sub nsw i32 %mul, 128
  %4 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc8 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %4, i32 0, i32 5
  %idxprom9 = sext i32 %voice to i64
  %arrayidx10 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc8, i64 0, i64 %idxprom9
  %panning = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx10, i32 0, i32 7
  store i32 %sub, i32* %panning, align 8, !tbaa !56
  br label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %entry, %lor.lhs.false, %sw.bb7, %sw.bb3, %sw.bb2, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @opl3_panning(i32 %dev, i32 %voice, i32 %value) #3 {
entry:
  %cmp = icmp slt i32 %voice, 0
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 3
  %1 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp1 = icmp sge i32 %voice, %1
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 5
  %idxprom = sext i32 %voice to i64
  %arrayidx = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc, i64 0, i64 %idxprom
  %panning = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx, i32 0, i32 7
  store i32 %value, i32* %panning, align 8, !tbaa !56
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @opl3_volume_method(i32 %dev, i32 %mode) #3 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @opl3_bender(i32 %dev, i32 %voice, i32 %value) #3 {
entry:
  %cmp = icmp slt i32 %voice, 0
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 3
  %1 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp1 = icmp sge i32 %voice, %1
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %sub = sub nsw i32 %value, 8192
  call void @bend_pitch(i32 %dev, i32 %voice, i32 %sub)
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @opl3_alloc_voice(i32 %dev, i32 %chn, i32 %note, %struct.voice_alloc_info* %alloc) #3 {
entry:
  %cmp = icmp slt i32 %chn, 0
  %cmp1 = icmp sgt i32 %chn, 15
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %chn_info = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 7
  %1 = load %struct.channel_info*, %struct.channel_info** %chn_info, align 8, !tbaa !36
  %idxprom = sext i32 %chn to i64
  %arrayidx = getelementptr inbounds %struct.channel_info, %struct.channel_info* %1, i64 %idxprom
  %pgm_num = getelementptr inbounds %struct.channel_info, %struct.channel_info* %arrayidx, i32 0, i32 0
  %2 = load i32, i32* %pgm_num, align 4, !tbaa !63
  br label %if.end

if.end:                                           ; preds = %entry, %if.else
  %instr_no.0 = phi i32 [ %2, %if.else ], [ 0, %entry ]
  %3 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %i_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %3, i32 0, i32 8
  %idxprom2 = sext i32 %instr_no.0 to i64
  %arrayidx3 = getelementptr inbounds [256 x %struct.sbi_instrument], [256 x %struct.sbi_instrument]* %i_map, i64 0, i64 %idxprom2
  %channel = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %arrayidx3, i32 0, i32 2
  %4 = load i32, i32* %channel, align 4, !tbaa !41
  %cmp4 = icmp slt i32 %4, 0
  br i1 %cmp4, label %if.end16, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %if.end
  %5 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %5, i32 0, i32 3
  %6 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp6 = icmp ne i32 %6, 12
  br i1 %cmp6, label %if.end16, label %if.else8

if.else8:                                         ; preds = %lor.lhs.false5
  %7 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice9 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %7, i32 0, i32 3
  %8 = load i32, i32* %nr_voice9, align 4, !tbaa !19
  %cmp10 = icmp eq i32 %8, 12
  br i1 %cmp10, label %if.then11, label %if.end16

if.then11:                                        ; preds = %if.else8
  %key = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %arrayidx3, i32 0, i32 0
  %9 = load i16, i16* %key, align 4, !tbaa !62
  %conv = zext i16 %9 to i32
  %cmp12 = icmp eq i32 %conv, 1021
  %conv13 = zext i1 %cmp12 to i32
  br label %if.end16

if.end16:                                         ; preds = %if.then11, %if.else8, %if.end, %lor.lhs.false5
  %is4op.1 = phi i32 [ 0, %lor.lhs.false5 ], [ 0, %if.end ], [ %conv13, %if.then11 ], [ 0, %if.else8 ]
  %tobool = icmp ne i32 %is4op.1, 0
  br i1 %tobool, label %if.end26, label %if.else18

if.else18:                                        ; preds = %if.end16
  %10 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice19 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %10, i32 0, i32 3
  %11 = load i32, i32* %nr_voice19, align 4, !tbaa !19
  %cmp20 = icmp eq i32 %11, 12
  %. = select i1 %cmp20, i32 6, i32 0
  %12 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice25 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %12, i32 0, i32 3
  %13 = load i32, i32* %nr_voice25, align 4, !tbaa !19
  br label %if.end26

if.end26:                                         ; preds = %if.end16, %if.else18
  %avail.0 = phi i32 [ %13, %if.else18 ], [ 6, %if.end16 ]
  %first.1 = phi i32 [ %., %if.else18 ], [ 0, %if.end16 ]
  br label %for.cond

for.cond:                                         ; preds = %if.end44, %if.end26
  %best.0 = phi i32 [ %first.1, %if.end26 ], [ %best.1, %if.end44 ]
  %p.2 = phi i32 [ %first.1, %if.end26 ], [ %rem, %if.end44 ]
  %i.0 = phi i32 [ 0, %if.end26 ], [ %inc, %if.end44 ]
  %best_time.0 = phi i32 [ 2147483647, %if.end26 ], [ %best_time.1, %if.end44 ]
  %cmp27 = icmp slt i32 %i.0, %avail.0
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %map = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %alloc, i32 0, i32 3
  %idxprom29 = sext i32 %p.2 to i64
  %arrayidx30 = getelementptr inbounds [32 x i16], [32 x i16]* %map, i64 0, i64 %idxprom29
  %14 = load i16, i16* %arrayidx30, align 2, !tbaa !47
  %conv31 = zext i16 %14 to i32
  %cmp32 = icmp eq i32 %conv31, 0
  br i1 %cmp32, label %cleanup, label %if.end35

if.end35:                                         ; preds = %for.body
  %alloc_times = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %alloc, i32 0, i32 5
  %idxprom36 = sext i32 %p.2 to i64
  %arrayidx37 = getelementptr inbounds [32 x i32], [32 x i32]* %alloc_times, i64 0, i64 %idxprom36
  %15 = load i32, i32* %arrayidx37, align 4, !tbaa !12
  %cmp38 = icmp slt i32 %15, %best_time.0
  br i1 %cmp38, label %if.then40, label %if.end44

if.then40:                                        ; preds = %if.end35
  %alloc_times41 = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %alloc, i32 0, i32 5
  %idxprom42 = sext i32 %p.2 to i64
  %arrayidx43 = getelementptr inbounds [32 x i32], [32 x i32]* %alloc_times41, i64 0, i64 %idxprom42
  %16 = load i32, i32* %arrayidx43, align 4, !tbaa !12
  br label %if.end44

if.end44:                                         ; preds = %if.then40, %if.end35
  %best.1 = phi i32 [ %p.2, %if.then40 ], [ %best.0, %if.end35 ]
  %best_time.1 = phi i32 [ %16, %if.then40 ], [ %best_time.0, %if.end35 ]
  %add = add nsw i32 %p.2, 1
  %rem = srem i32 %add, %avail.0
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp45 = icmp slt i32 %best.0, 0
  %.best.0 = select i1 %cmp45, i32 0, i32 %best.0
  %17 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice49 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %17, i32 0, i32 3
  %18 = load i32, i32* %nr_voice49, align 4, !tbaa !19
  %cmp50 = icmp sgt i32 %.best.0, %18
  br i1 %cmp50, label %if.then52, label %cleanup

if.then52:                                        ; preds = %for.end
  %19 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice53 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %19, i32 0, i32 3
  %20 = load i32, i32* %nr_voice53, align 4, !tbaa !19
  %sub = sub nsw i32 %.best.0, %20
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then52, %for.body
  %retval.0 = phi i32 [ %p.2, %for.body ], [ %sub, %if.then52 ], [ %.best.0, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @opl3_setup_voice(i32 %dev, i32 %voice, i32 %chn) #3 {
entry:
  %cmp = icmp slt i32 %voice, 0
  br i1 %cmp, label %cleanup.cont, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 3
  %1 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp1 = icmp sge i32 %voice, %1
  br i1 %cmp1, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %cmp2 = icmp slt i32 %chn, 0
  %cmp4 = icmp sgt i32 %chn, 15
  %or.cond = or i1 %cmp2, %cmp4
  br i1 %or.cond, label %cleanup.cont, label %if.end6

if.end6:                                          ; preds = %if.end
  %idxprom = sext i32 %dev to i64
  %arrayidx = getelementptr inbounds [11 x %struct.synth_operations*], [11 x %struct.synth_operations*]* @synth_devs, i64 0, i64 %idxprom
  %2 = load %struct.synth_operations*, %struct.synth_operations** %arrayidx, align 8, !tbaa !14
  %chn_info = getelementptr inbounds %struct.synth_operations, %struct.synth_operations* %2, i32 0, i32 24
  %idxprom7 = sext i32 %chn to i64
  %arrayidx8 = getelementptr inbounds [16 x %struct.channel_info], [16 x %struct.channel_info]* %chn_info, i64 0, i64 %idxprom7
  %pgm_num = getelementptr inbounds %struct.channel_info, %struct.channel_info* %arrayidx8, i32 0, i32 0
  %3 = load i32, i32* %pgm_num, align 4, !tbaa !63
  %call = call i32 @opl3_set_instr(i32 %dev, i32 %voice, i32 %3)
  %4 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %4, i32 0, i32 5
  %idxprom9 = sext i32 %voice to i64
  %arrayidx10 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc, i64 0, i64 %idxprom9
  %bender = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx10, i32 0, i32 1
  store i64 0, i64* %bender, align 8, !tbaa !54
  %bender_range = getelementptr inbounds %struct.channel_info, %struct.channel_info* %arrayidx8, i32 0, i32 2
  %5 = load i32, i32* %bender_range, align 4, !tbaa !65
  %conv = sext i32 %5 to i64
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc11 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %6, i32 0, i32 5
  %idxprom12 = sext i32 %voice to i64
  %arrayidx13 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc11, i64 0, i64 %idxprom12
  %bender_range14 = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx13, i32 0, i32 2
  store i64 %conv, i64* %bender_range14, align 8, !tbaa !57
  %controllers = getelementptr inbounds %struct.channel_info, %struct.channel_info* %arrayidx8, i32 0, i32 3
  %arrayidx15 = getelementptr inbounds [128 x i8], [128 x i8]* %controllers, i64 0, i64 7
  %7 = load i8, i8* %arrayidx15, align 1, !tbaa !61
  %conv16 = zext i8 %7 to i32
  %8 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc17 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %8, i32 0, i32 5
  %idxprom18 = sext i32 %voice to i64
  %arrayidx19 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc17, i64 0, i64 %idxprom18
  %volume = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx19, i32 0, i32 5
  store i32 %conv16, i32* %volume, align 8, !tbaa !55
  %controllers20 = getelementptr inbounds %struct.channel_info, %struct.channel_info* %arrayidx8, i32 0, i32 3
  %arrayidx21 = getelementptr inbounds [128 x i8], [128 x i8]* %controllers20, i64 0, i64 10
  %9 = load i8, i8* %arrayidx21, align 2, !tbaa !61
  %conv22 = zext i8 %9 to i32
  %mul = mul nsw i32 %conv22, 2
  %sub = sub nsw i32 %mul, 128
  %10 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc23 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %10, i32 0, i32 5
  %idxprom24 = sext i32 %voice to i64
  %arrayidx25 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc23, i64 0, i64 %idxprom24
  %panning = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx25, i32 0, i32 7
  store i32 %sub, i32* %panning, align 8, !tbaa !56
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end6, %lor.lhs.false, %entry, %if.end
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end6 ], [ 1, %lor.lhs.false ], [ 1, %entry ], [ 1, %if.end ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #0 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.15, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.16, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  %tobool17 = icmp ne i32 1, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind uwtable
define internal i32 @store_instr(i32 %instr_no, %struct.sbi_instrument* %instr) #3 {
entry:
  %key = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr, i32 0, i32 0
  %0 = load i16, i16* %key, align 4, !tbaa !62
  %conv = zext i16 %0 to i32
  %cmp = icmp ne i32 %conv, 509
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %key2 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr, i32 0, i32 0
  %1 = load i16, i16* %key2, align 4, !tbaa !62
  %conv3 = zext i16 %1 to i32
  %cmp4 = icmp ne i32 %conv3, 1021
  br i1 %cmp4, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %model = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 12
  %3 = load i32, i32* %model, align 8, !tbaa !30
  %cmp6 = icmp ne i32 %3, 2
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %key8 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr, i32 0, i32 0
  %4 = load i16, i16* %key8, align 4, !tbaa !62
  %conv9 = zext i16 %4 to i32
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.17, i32 0, i32 0), i32 %conv9)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false, %entry
  %cmp10 = icmp uge i64 40, 64
  %5 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %i_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %5, i32 0, i32 8
  %idxprom = sext i32 %instr_no to i64
  %arrayidx = getelementptr inbounds [256 x %struct.sbi_instrument], [256 x %struct.sbi_instrument]* %i_map, i64 0, i64 %idxprom
  %6 = bitcast %struct.sbi_instrument* %arrayidx to i8*
  %7 = bitcast %struct.sbi_instrument* %instr to i8*
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %call13 = call i8* @__memcpy(i8* %6, i8* %7, i64 40)
  br label %if.end17

if.else:                                          ; preds = %if.end
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 40, i32 1, i1 false)
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then12
  %__ret.0 = phi i8* [ %call13, %if.then12 ], [ %6, %if.else ]
  ret i32 0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @copy_to_user(i8* %dst, i8* %src, i32 %size) #5 {
entry:
  call void @might_fault()
  %call = call i64 @_copy_to_user(i8* %dst, i8* %src, i32 %size)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @enter_4op_mode() #3 {
entry:
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %cmask = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 13
  store i8 63, i8* %cmask, align 4, !tbaa !48
  %1 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %right_io = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %1, i32 0, i32 2
  %2 = load i32, i32* %right_io, align 8, !tbaa !29
  call void @opl3_command(i32 %2, i32 4, i32 63)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom
  %voice_mode = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx, i32 0, i32 1
  store i8 4, i8* %voice_mode, align 1, !tbaa !49
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond1

for.cond1:                                        ; preds = %for.body3, %for.end
  %i.1 = phi i32 [ 3, %for.end ], [ %inc8, %for.body3 ]
  %cmp2 = icmp slt i32 %i.1, 6
  br i1 %cmp2, label %for.body3, label %for.end9

for.body3:                                        ; preds = %for.cond1
  %idxprom4 = sext i32 %i.1 to i64
  %arrayidx5 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom4
  %voice_mode6 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx5, i32 0, i32 1
  store i8 0, i8* %voice_mode6, align 1, !tbaa !49
  %inc8 = add nsw i32 %i.1, 1
  br label %for.cond1

for.end9:                                         ; preds = %for.cond1
  br label %for.cond10

for.cond10:                                       ; preds = %for.body12, %for.end9
  %i.2 = phi i32 [ 9, %for.end9 ], [ %inc17, %for.body12 ]
  %cmp11 = icmp slt i32 %i.2, 12
  br i1 %cmp11, label %for.body12, label %for.end18

for.body12:                                       ; preds = %for.cond10
  %idxprom13 = sext i32 %i.2 to i64
  %arrayidx14 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom13
  %voice_mode15 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx14, i32 0, i32 1
  store i8 4, i8* %voice_mode15, align 1, !tbaa !49
  %inc17 = add nsw i32 %i.2, 1
  br label %for.cond10

for.end18:                                        ; preds = %for.cond10
  br label %for.cond19

for.cond19:                                       ; preds = %for.body21, %for.end18
  %i.3 = phi i32 [ 12, %for.end18 ], [ %inc26, %for.body21 ]
  %cmp20 = icmp slt i32 %i.3, 15
  br i1 %cmp20, label %for.body21, label %for.end27

for.body21:                                       ; preds = %for.cond19
  %idxprom22 = sext i32 %i.3 to i64
  %arrayidx23 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom22
  %voice_mode24 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx23, i32 0, i32 1
  store i8 0, i8* %voice_mode24, align 1, !tbaa !49
  %inc26 = add nsw i32 %i.3, 1
  br label %for.cond19

for.end27:                                        ; preds = %for.cond19
  br label %for.cond28

for.cond28:                                       ; preds = %for.body30, %for.end27
  %i.4 = phi i32 [ 0, %for.end27 ], [ %inc36, %for.body30 ]
  %cmp29 = icmp slt i32 %i.4, 12
  br i1 %cmp29, label %for.body30, label %for.end37

for.body30:                                       ; preds = %for.cond28
  %idxprom31 = sext i32 %i.4 to i64
  %arrayidx32 = getelementptr inbounds [18 x i32], [18 x i32]* @enter_4op_mode.v4op, i64 0, i64 %idxprom31
  %3 = load i32, i32* %arrayidx32, align 4, !tbaa !12
  %4 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %4, i32 0, i32 4
  %idxprom33 = sext i32 %i.4 to i64
  %arrayidx34 = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map, i64 0, i64 %idxprom33
  store i32 %3, i32* %arrayidx34, align 4, !tbaa !12
  %inc36 = add nsw i32 %i.4, 1
  br label %for.cond28

for.end37:                                        ; preds = %for.cond28
  %5 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %5, i32 0, i32 3
  store i32 12, i32* %nr_voice, align 4, !tbaa !19
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %v_alloc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %6, i32 0, i32 6
  %7 = load %struct.voice_alloc_info*, %struct.voice_alloc_info** %v_alloc, align 8, !tbaa !35
  %max_voice = getelementptr inbounds %struct.voice_alloc_info, %struct.voice_alloc_info* %7, i32 0, i32 0
  store i32 12, i32* %max_voice, align 4, !tbaa !37
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #6

declare void @might_fault() #2

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #7

declare i64 @_copy_from_user(i8*, i8*, i32) #2

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #2

declare i8* @__memcpy(i8*, i8*, i64) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #4

declare i64 @_copy_to_user(i8*, i8*, i32) #2

; Function Attrs: nounwind uwtable
define internal void @set_voice_volume(i32 %voice, i32 %volume, i32 %main_vol) #3 {
entry:
  %vol1 = alloca i8, align 1
  %vol2 = alloca i8, align 1
  %vol3 = alloca i8, align 1
  %vol4 = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %vol1) #8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %vol2) #8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %vol3) #8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %vol4) #8
  %cmp = icmp slt i32 %voice, 0
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %nr_voice = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %0, i32 0, i32 3
  %1 = load i32, i32* %nr_voice, align 4, !tbaa !19
  %cmp1 = icmp sge i32 %voice, %1
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 4
  %idxprom = sext i32 %voice to i64
  %arrayidx = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %idxprom2 = sext i32 %3 to i64
  %arrayidx3 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom2
  %4 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %act_i = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %4, i32 0, i32 9
  %idxprom4 = sext i32 %voice to i64
  %arrayidx5 = getelementptr inbounds [18 x %struct.sbi_instrument*], [18 x %struct.sbi_instrument*]* %act_i, i64 0, i64 %idxprom4
  %5 = load %struct.sbi_instrument*, %struct.sbi_instrument** %arrayidx5, align 8, !tbaa !14
  %tobool = icmp ne %struct.sbi_instrument* %5, null
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8
  %i_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %6, i32 0, i32 8
  %arrayidx7 = getelementptr inbounds [256 x %struct.sbi_instrument], [256 x %struct.sbi_instrument]* %i_map, i64 0, i64 0
  %instr.0 = select i1 %tobool, %struct.sbi_instrument* %5, %struct.sbi_instrument* %arrayidx7
  %channel = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 2
  %7 = load i32, i32* %channel, align 4, !tbaa !41
  %cmp9 = icmp slt i32 %7, 0
  br i1 %cmp9, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end
  %8 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %8, i32 0, i32 5
  %idxprom12 = sext i32 %voice to i64
  %arrayidx13 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc, i64 0, i64 %idxprom12
  %mode = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx13, i32 0, i32 6
  %9 = load i32, i32* %mode, align 4, !tbaa !60
  %cmp14 = icmp eq i32 %9, 0
  br i1 %cmp14, label %cleanup, label %if.end16

if.end16:                                         ; preds = %if.end11
  %10 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc17 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %10, i32 0, i32 5
  %idxprom18 = sext i32 %voice to i64
  %arrayidx19 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc17, i64 0, i64 %idxprom18
  %mode20 = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx19, i32 0, i32 6
  %11 = load i32, i32* %mode20, align 4, !tbaa !60
  %cmp21 = icmp eq i32 %11, 2
  %operators = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx23 = getelementptr inbounds [32 x i8], [32 x i8]* %operators, i64 0, i64 2
  %12 = load i8, i8* %arrayidx23, align 2, !tbaa !61
  store i8 %12, i8* %vol1, align 1, !tbaa !61
  %operators24 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx25 = getelementptr inbounds [32 x i8], [32 x i8]* %operators24, i64 0, i64 3
  %13 = load i8, i8* %arrayidx25, align 1, !tbaa !61
  store i8 %13, i8* %vol2, align 1, !tbaa !61
  %operators26 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  br i1 %cmp21, label %if.then22, label %if.else42

if.then22:                                        ; preds = %if.end16
  %arrayidx27 = getelementptr inbounds [32 x i8], [32 x i8]* %operators26, i64 0, i64 10
  %14 = load i8, i8* %arrayidx27, align 2, !tbaa !61
  %conv = zext i8 %14 to i32
  %and = and i32 %conv, 1
  %tobool28 = icmp ne i32 %and, 0
  br i1 %tobool28, label %if.then29, label %if.else

if.then29:                                        ; preds = %if.then22
  call void @calc_vol(i8* %vol1, i32 %volume, i32 %main_vol)
  call void @calc_vol(i8* %vol2, i32 %volume, i32 %main_vol)
  br label %if.end30

if.else:                                          ; preds = %if.then22
  call void @calc_vol(i8* %vol2, i32 %volume, i32 %main_vol)
  br label %if.end30

if.end30:                                         ; preds = %if.else, %if.then29
  %ioaddr = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %15 = load i16, i16* %ioaddr, align 2, !tbaa !38
  %conv31 = zext i16 %15 to i32
  %op = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx32 = getelementptr inbounds [4 x i8], [4 x i8]* %op, i64 0, i64 0
  %16 = load i8, i8* %arrayidx32, align 2, !tbaa !61
  %conv33 = zext i8 %16 to i32
  %add = add nsw i32 64, %conv33
  %17 = load i8, i8* %vol1, align 1, !tbaa !61
  %conv34 = zext i8 %17 to i32
  call void @opl3_command(i32 %conv31, i32 %add, i32 %conv34)
  %ioaddr35 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %18 = load i16, i16* %ioaddr35, align 2, !tbaa !38
  %conv36 = zext i16 %18 to i32
  %op37 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx38 = getelementptr inbounds [4 x i8], [4 x i8]* %op37, i64 0, i64 1
  %19 = load i8, i8* %arrayidx38, align 1, !tbaa !61
  %conv39 = zext i8 %19 to i32
  %add40 = add nsw i32 64, %conv39
  %20 = load i8, i8* %vol2, align 1, !tbaa !61
  %conv41 = zext i8 %20 to i32
  call void @opl3_command(i32 %conv36, i32 %add40, i32 %conv41)
  br label %cleanup

if.else42:                                        ; preds = %if.end16
  %arrayidx48 = getelementptr inbounds [32 x i8], [32 x i8]* %operators26, i64 0, i64 13
  %21 = load i8, i8* %arrayidx48, align 1, !tbaa !61
  store i8 %21, i8* %vol3, align 1, !tbaa !61
  %operators49 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx50 = getelementptr inbounds [32 x i8], [32 x i8]* %operators49, i64 0, i64 14
  %22 = load i8, i8* %arrayidx50, align 2, !tbaa !61
  store i8 %22, i8* %vol4, align 1, !tbaa !61
  %operators51 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx52 = getelementptr inbounds [32 x i8], [32 x i8]* %operators51, i64 0, i64 10
  %23 = load i8, i8* %arrayidx52, align 2, !tbaa !61
  %conv53 = zext i8 %23 to i32
  %and54 = and i32 %conv53, 1
  %shl = shl i32 %and54, 1
  %operators55 = getelementptr inbounds %struct.sbi_instrument, %struct.sbi_instrument* %instr.0, i32 0, i32 3
  %arrayidx56 = getelementptr inbounds [32 x i8], [32 x i8]* %operators55, i64 0, i64 21
  %24 = load i8, i8* %arrayidx56, align 1, !tbaa !61
  %conv57 = zext i8 %24 to i32
  %and58 = and i32 %conv57, 1
  %or = or i32 %shl, %and58
  %Pivot6 = icmp slt i32 %or, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.else42
  %Pivot4 = icmp slt i32 %or, 3
  br i1 %Pivot4, label %sw.bb60, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %or, 3
  br i1 %SwitchLeaf2, label %sw.bb61, label %sw.epilog

NodeBlock:                                        ; preds = %if.else42
  %Pivot = icmp slt i32 %or, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb59

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %or, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @calc_vol(i8* %vol4, i32 %volume, i32 %main_vol)
  br label %sw.epilog

sw.bb59:                                          ; preds = %NodeBlock
  call void @calc_vol(i8* %vol2, i32 %volume, i32 %main_vol)
  call void @calc_vol(i8* %vol4, i32 %volume, i32 %main_vol)
  br label %sw.epilog

sw.bb60:                                          ; preds = %NodeBlock3
  call void @calc_vol(i8* %vol1, i32 %volume, i32 %main_vol)
  call void @calc_vol(i8* %vol4, i32 %volume, i32 %main_vol)
  br label %sw.epilog

sw.bb61:                                          ; preds = %LeafBlock1
  call void @calc_vol(i8* %vol1, i32 %volume, i32 %main_vol)
  call void @calc_vol(i8* %vol3, i32 %volume, i32 %main_vol)
  call void @calc_vol(i8* %vol4, i32 %volume, i32 %main_vol)
  br label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock1, %LeafBlock, %sw.bb61, %sw.bb60, %sw.bb59, %sw.bb
  %ioaddr62 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %25 = load i16, i16* %ioaddr62, align 2, !tbaa !38
  %conv63 = zext i16 %25 to i32
  %op64 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx65 = getelementptr inbounds [4 x i8], [4 x i8]* %op64, i64 0, i64 0
  %26 = load i8, i8* %arrayidx65, align 2, !tbaa !61
  %conv66 = zext i8 %26 to i32
  %add67 = add nsw i32 64, %conv66
  %27 = load i8, i8* %vol1, align 1, !tbaa !61
  %conv68 = zext i8 %27 to i32
  call void @opl3_command(i32 %conv63, i32 %add67, i32 %conv68)
  %ioaddr69 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %28 = load i16, i16* %ioaddr69, align 2, !tbaa !38
  %conv70 = zext i16 %28 to i32
  %op71 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx72 = getelementptr inbounds [4 x i8], [4 x i8]* %op71, i64 0, i64 1
  %29 = load i8, i8* %arrayidx72, align 1, !tbaa !61
  %conv73 = zext i8 %29 to i32
  %add74 = add nsw i32 64, %conv73
  %30 = load i8, i8* %vol2, align 1, !tbaa !61
  %conv75 = zext i8 %30 to i32
  call void @opl3_command(i32 %conv70, i32 %add74, i32 %conv75)
  %ioaddr76 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %31 = load i16, i16* %ioaddr76, align 2, !tbaa !38
  %conv77 = zext i16 %31 to i32
  %op78 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx79 = getelementptr inbounds [4 x i8], [4 x i8]* %op78, i64 0, i64 2
  %32 = load i8, i8* %arrayidx79, align 2, !tbaa !61
  %conv80 = zext i8 %32 to i32
  %add81 = add nsw i32 64, %conv80
  %33 = load i8, i8* %vol3, align 1, !tbaa !61
  %conv82 = zext i8 %33 to i32
  call void @opl3_command(i32 %conv77, i32 %add81, i32 %conv82)
  %ioaddr83 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 2
  %34 = load i16, i16* %ioaddr83, align 2, !tbaa !38
  %conv84 = zext i16 %34 to i32
  %op85 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx3, i32 0, i32 3
  %arrayidx86 = getelementptr inbounds [4 x i8], [4 x i8]* %op85, i64 0, i64 3
  %35 = load i8, i8* %arrayidx86, align 1, !tbaa !61
  %conv87 = zext i8 %35 to i32
  %add88 = add nsw i32 64, %conv87
  %36 = load i8, i8* %vol4, align 1, !tbaa !61
  %conv89 = zext i8 %36 to i32
  call void @opl3_command(i32 %conv84, i32 %add88, i32 %conv89)
  br label %cleanup

cleanup:                                          ; preds = %if.end30, %sw.epilog, %if.end11, %if.end, %entry, %lor.lhs.false
  %cleanup.dest.slot.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %entry ], [ 1, %if.end ], [ 1, %if.end11 ], [ 0, %sw.epilog ], [ 0, %if.end30 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %vol4) #8
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %vol3) #8
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %vol2) #8
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %vol1) #8
  ret void
}

declare i32 @note_to_freq(i32) #2

declare i64 @compute_finetune(i64, i32, i32, i32) #2

; Function Attrs: nounwind uwtable
define internal void @freq_to_fnum(i32 %freq, i32* %block, i32* %fnum) #3 {
entry:
  %cmp = icmp eq i32 %freq, 0
  br i1 %cmp, label %if.end12, label %if.else

if.else:                                          ; preds = %entry
  %cmp1 = icmp slt i32 %freq, 261
  br i1 %cmp1, label %if.then2, label %if.else4

if.then2:                                         ; preds = %if.else
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then2
  %f.0 = phi i32 [ %freq, %if.then2 ], [ %shl, %while.body ]
  %octave.0 = phi i32 [ 5, %if.then2 ], [ %dec, %while.body ]
  %cmp3 = icmp slt i32 %f.0, 261
  br i1 %cmp3, label %while.body, label %if.end12

while.body:                                       ; preds = %while.cond
  %dec = add nsw i32 %octave.0, -1
  %shl = shl i32 %f.0, 1
  br label %while.cond

if.else4:                                         ; preds = %if.else
  %cmp5 = icmp sgt i32 %freq, 493
  br i1 %cmp5, label %if.then6, label %if.end12

if.then6:                                         ; preds = %if.else4
  br label %while.cond7

while.cond7:                                      ; preds = %while.body9, %if.then6
  %f.1 = phi i32 [ %freq, %if.then6 ], [ %shr, %while.body9 ]
  %octave.1 = phi i32 [ 5, %if.then6 ], [ %inc, %while.body9 ]
  %cmp8 = icmp sgt i32 %f.1, 493
  br i1 %cmp8, label %while.body9, label %if.end12

while.body9:                                      ; preds = %while.cond7
  %inc = add nsw i32 %octave.1, 1
  %shr = ashr i32 %f.1, 1
  br label %while.cond7

if.end12:                                         ; preds = %while.cond, %while.cond7, %if.else4, %entry
  %octave.4 = phi i32 [ 0, %entry ], [ %octave.0, %while.cond ], [ 5, %if.else4 ], [ %octave.1, %while.cond7 ]
  %cmp13 = icmp sgt i32 %octave.4, 7
  %.octave.4 = select i1 %cmp13, i32 7, i32 %octave.4
  %sub = sub nsw i32 20, %.octave.4
  %shl16 = shl i32 1, %sub
  %mul = mul nsw i32 %freq, %shl16
  %div = sdiv i32 %mul, 49716
  store i32 %div, i32* %fnum, align 4, !tbaa !12
  store i32 %.octave.4, i32* %block, align 4, !tbaa !12
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @calc_vol(i8* %regbyte, i32 %volume, i32 %main_vol) #3 {
entry:
  %0 = load i8, i8* %regbyte, align 1, !tbaa !61
  %conv = zext i8 %0 to i32
  %neg = xor i32 %conv, -1
  %and = and i32 %neg, 63
  %cmp = icmp sgt i32 %main_vol, 127
  %.main_vol = select i1 %cmp, i32 127, i32 %main_vol
  %mul = mul nsw i32 %volume, %.main_vol
  %div = sdiv i32 %mul, 127
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %entry
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [128 x i8], [128 x i8]* @fm_volume_table, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !61
  %conv3 = sext i8 %1 to i32
  %add = add nsw i32 %and, %conv3
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %entry
  %level.0 = phi i32 [ %add, %if.then2 ], [ %and, %entry ]
  %cmp5 = icmp sgt i32 %level.0, 63
  %.level.0 = select i1 %cmp5, i32 63, i32 %level.0
  %cmp9 = icmp slt i32 %.level.0, 0
  %level.2 = select i1 %cmp9, i32 0, i32 %.level.0
  %2 = load i8, i8* %regbyte, align 1, !tbaa !61
  %conv13 = zext i8 %2 to i32
  %and14 = and i32 %conv13, 192
  %neg15 = xor i32 %level.2, -1
  %and16 = and i32 %neg15, 63
  %or = or i32 %and14, %and16
  %conv17 = trunc i32 %or to i8
  store i8 %conv17, i8* %regbyte, align 1, !tbaa !61
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @bend_pitch(i32 %dev, i32 %voice, i32 %value) #3 {
entry:
  %block = alloca i32, align 4
  %fnum = alloca i32, align 4
  %0 = bitcast i32* %block to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #8
  %1 = bitcast i32* %fnum to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #8
  %2 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %lv_map = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %2, i32 0, i32 4
  %idxprom = sext i32 %voice to i64
  %arrayidx = getelementptr inbounds [18 x i32], [18 x i32]* %lv_map, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !12
  %idxprom1 = sext i32 %3 to i64
  %arrayidx2 = getelementptr inbounds [18 x %struct.physical_voice_info], [18 x %struct.physical_voice_info]* @pv_map, i64 0, i64 %idxprom1
  %voice_mode = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx2, i32 0, i32 1
  %4 = load i8, i8* %voice_mode, align 1, !tbaa !49
  %conv = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv4 = sext i32 %value to i64
  %5 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %5, i32 0, i32 5
  %idxprom5 = sext i32 %voice to i64
  %arrayidx6 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc, i64 0, i64 %idxprom5
  %bender = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx6, i32 0, i32 1
  store i64 %conv4, i64* %bender, align 8, !tbaa !54
  %tobool = icmp ne i32 %value, 0
  br i1 %tobool, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.end
  %6 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc9 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %6, i32 0, i32 5
  %idxprom10 = sext i32 %voice to i64
  %arrayidx11 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc9, i64 0, i64 %idxprom10
  %keyon_byte = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx11, i32 0, i32 0
  %7 = load i8, i8* %keyon_byte, align 8, !tbaa !51
  %conv12 = zext i8 %7 to i32
  %and = and i32 %conv12, 32
  %tobool13 = icmp ne i32 %and, 0
  br i1 %tobool13, label %if.end15, label %cleanup

if.end15:                                         ; preds = %if.end8
  %8 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc16 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %8, i32 0, i32 5
  %idxprom17 = sext i32 %voice to i64
  %arrayidx18 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc16, i64 0, i64 %idxprom17
  %orig_freq = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx18, i32 0, i32 3
  %9 = load i64, i64* %orig_freq, align 8, !tbaa !58
  %10 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc19 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %10, i32 0, i32 5
  %idxprom20 = sext i32 %voice to i64
  %arrayidx21 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc19, i64 0, i64 %idxprom20
  %bender22 = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx21, i32 0, i32 1
  %11 = load i64, i64* %bender22, align 8, !tbaa !54
  %conv23 = trunc i64 %11 to i32
  %12 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc24 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %12, i32 0, i32 5
  %idxprom25 = sext i32 %voice to i64
  %arrayidx26 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc24, i64 0, i64 %idxprom25
  %bender_range = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx26, i32 0, i32 2
  %13 = load i64, i64* %bender_range, align 8, !tbaa !57
  %conv27 = trunc i64 %13 to i32
  %call = call i64 @compute_finetune(i64 %9, i32 %conv23, i32 %conv27, i32 0)
  %conv28 = trunc i64 %call to i32
  %conv29 = sext i32 %conv28 to i64
  %14 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc30 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %14, i32 0, i32 5
  %idxprom31 = sext i32 %voice to i64
  %arrayidx32 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc30, i64 0, i64 %idxprom31
  %current_freq = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx32, i32 0, i32 4
  store i64 %conv29, i64* %current_freq, align 8, !tbaa !59
  call void @freq_to_fnum(i32 %conv28, i32* %block, i32* %fnum)
  %15 = load i32, i32* %fnum, align 4, !tbaa !12
  %and33 = and i32 %15, 255
  %conv34 = trunc i32 %and33 to i8
  %ioaddr = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx2, i32 0, i32 2
  %16 = load i16, i16* %ioaddr, align 2, !tbaa !38
  %conv35 = zext i16 %16 to i32
  %voice_num = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx2, i32 0, i32 0
  %17 = load i8, i8* %voice_num, align 2, !tbaa !50
  %conv36 = zext i8 %17 to i32
  %add = add nsw i32 160, %conv36
  %conv37 = zext i8 %conv34 to i32
  call void @opl3_command(i32 %conv35, i32 %add, i32 %conv37)
  %18 = load i32, i32* %block, align 4, !tbaa !12
  %and38 = and i32 %18, 7
  %shl = shl i32 %and38, 2
  %or = or i32 32, %shl
  %19 = load i32, i32* %fnum, align 4, !tbaa !12
  %shr = ashr i32 %19, 8
  %and39 = and i32 %shr, 3
  %or40 = or i32 %or, %and39
  %conv41 = trunc i32 %or40 to i8
  %20 = load %struct.opl_devinfo*, %struct.opl_devinfo** @devc, align 8, !tbaa !14
  %voc42 = getelementptr inbounds %struct.opl_devinfo, %struct.opl_devinfo* %20, i32 0, i32 5
  %idxprom43 = sext i32 %voice to i64
  %arrayidx44 = getelementptr inbounds [18 x %struct.voice_info], [18 x %struct.voice_info]* %voc42, i64 0, i64 %idxprom43
  %keyon_byte45 = getelementptr inbounds %struct.voice_info, %struct.voice_info* %arrayidx44, i32 0, i32 0
  store i8 %conv41, i8* %keyon_byte45, align 8, !tbaa !51
  %ioaddr46 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx2, i32 0, i32 2
  %21 = load i16, i16* %ioaddr46, align 2, !tbaa !38
  %conv47 = zext i16 %21 to i32
  %voice_num48 = getelementptr inbounds %struct.physical_voice_info, %struct.physical_voice_info* %arrayidx2, i32 0, i32 0
  %22 = load i8, i8* %voice_num48, align 2, !tbaa !50
  %conv49 = zext i8 %22 to i32
  %add50 = add nsw i32 176, %conv49
  %conv51 = zext i8 %conv41 to i32
  call void @opl3_command(i32 %conv47, i32 %add50, i32 %conv51)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end, %entry, %if.end15
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end15 ], [ 1, %entry ], [ 1, %if.end ], [ 1, %if.end8 ]
  %23 = bitcast i32* %fnum to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %23) #8
  %24 = bitcast i32* %block to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %24) #8
  ret void
}

declare void @sound_unload_synthdev(i32) #2

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind readnone }
attributes #8 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !13, i64 0}
!13 = !{!"int", !5, i64 0}
!14 = !{!4, !4, i64 0}
!15 = !{!16, !13, i64 0}
!16 = !{!"opl_devinfo", !13, i64 0, !13, i64 4, !13, i64 8, !13, i64 12, !5, i64 16, !5, i64 88, !4, i64 1096, !4, i64 1104, !5, i64 1112, !5, i64 11352, !17, i64 11496, !13, i64 11636, !13, i64 11640, !5, i64 11644, !13, i64 11648}
!17 = !{!"synth_info", !5, i64 0, !13, i64 32, !13, i64 36, !13, i64 40, !13, i64 44, !13, i64 48, !13, i64 52, !13, i64 56, !13, i64 60, !5, i64 64}
!18 = !{!16, !13, i64 11648}
!19 = !{!16, !13, i64 12}
!20 = !{!16, !13, i64 11528}
!21 = !{!16, !13, i64 11532}
!22 = !{!16, !13, i64 11536}
!23 = !{!16, !13, i64 11540}
!24 = !{!16, !13, i64 11544}
!25 = !{!16, !13, i64 11548}
!26 = !{!16, !13, i64 11552}
!27 = !{!16, !13, i64 11556}
!28 = !{!16, !13, i64 4}
!29 = !{!16, !13, i64 8}
!30 = !{!16, !13, i64 11640}
!31 = !{!32, !4, i64 16}
!32 = !{!"synth_operations", !4, i64 0, !4, i64 8, !4, i64 16, !13, i64 24, !13, i64 28, !13, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !33, i64 176, !5, i64 384, !13, i64 2624, !5, i64 2628, !13, i64 2692}
!33 = !{!"voice_alloc_info", !13, i64 0, !13, i64 4, !13, i64 8, !5, i64 12, !13, i64 76, !5, i64 80}
!34 = !{!32, !4, i64 0}
!35 = !{!16, !4, i64 1096}
!36 = !{!16, !4, i64 1104}
!37 = !{!33, !13, i64 0}
!38 = !{!39, !40, i64 2}
!39 = !{!"physical_voice_info", !5, i64 0, !5, i64 1, !40, i64 2, !5, i64 4}
!40 = !{!"short", !5, i64 0}
!41 = !{!42, !13, i64 4}
!42 = !{!"sbi_instrument", !40, i64 0, !40, i64 2, !13, i64 4, !5, i64 8}
!43 = !{i32 -2145567004}
!44 = !{i32 -2145567206}
!45 = !{!16, !13, i64 11636}
!46 = !{!33, !13, i64 76}
!47 = !{!40, !40, i64 0}
!48 = !{!16, !5, i64 11644}
!49 = !{!39, !5, i64 1}
!50 = !{!39, !5, i64 0}
!51 = !{!52, !5, i64 0}
!52 = !{!"voice_info", !5, i64 0, !53, i64 8, !53, i64 16, !53, i64 24, !53, i64 32, !13, i64 40, !13, i64 44, !13, i64 48}
!53 = !{!"long", !5, i64 0}
!54 = !{!52, !53, i64 8}
!55 = !{!52, !13, i64 40}
!56 = !{!52, !13, i64 48}
!57 = !{!52, !53, i64 16}
!58 = !{!52, !53, i64 24}
!59 = !{!52, !53, i64 32}
!60 = !{!52, !13, i64 44}
!61 = !{!5, !5, i64 0}
!62 = !{!42, !40, i64 0}
!63 = !{!64, !13, i64 0}
!64 = !{!"channel_info", !13, i64 0, !13, i64 4, !13, i64 8, !5, i64 12}
!65 = !{!64, !13, i64 8}
