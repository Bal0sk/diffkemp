; ModuleID = 'tests/regression/kernel_modules/rfkill/rfkill_new-rfkill_default_state.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm "\09.section \22___kcrctab+rfkill_get_led_trigger_name\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_get_led_trigger_name\09"
module asm "\09.long\09__crc_rfkill_get_led_trigger_name\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_set_led_trigger_name\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_set_led_trigger_name\09"
module asm "\09.long\09__crc_rfkill_set_led_trigger_name\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_set_hw_state\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_set_hw_state\09"
module asm "\09.long\09__crc_rfkill_set_hw_state\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_set_sw_state\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_set_sw_state\09"
module asm "\09.long\09__crc_rfkill_set_sw_state\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_init_sw_state\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_init_sw_state\09"
module asm "\09.long\09__crc_rfkill_init_sw_state\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_set_states\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_set_states\09"
module asm "\09.long\09__crc_rfkill_set_states\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_find_type\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_find_type\09"
module asm "\09.long\09__crc_rfkill_find_type\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_pause_polling\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_pause_polling\09"
module asm "\09.long\09__crc_rfkill_pause_polling\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_resume_polling\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_resume_polling\09"
module asm "\09.long\09__crc_rfkill_resume_polling\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_blocked\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_blocked\09"
module asm "\09.long\09__crc_rfkill_blocked\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_alloc\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_alloc\09"
module asm "\09.long\09__crc_rfkill_alloc\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_register\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_register\09"
module asm "\09.long\09__crc_rfkill_register\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_unregister\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_unregister\09"
module asm "\09.long\09__crc_rfkill_unregister\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+rfkill_destroy\22, \22a\22\09"
module asm "\09.weak\09__crc_rfkill_destroy\09"
module asm "\09.long\09__crc_rfkill_destroy\09"
module asm "\09.previous\09\09\09\09\09"

%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %union.anon.3, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.0, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %union.anon.3, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %struct.qspinlock, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.3, %union.anon.3, %union.anon.0, %union.anon.3, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.atomic_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %union.anon.3, %struct.list_head, %struct.raw_spinlock, %struct.qspinlock, %struct.task_struct*, %struct.lockdep_map }
%struct.task_struct = type { %union.anon.3, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %union.anon.0, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.atomic_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %union.anon.3*, %struct.atomic_t, %struct.atomic_t, %union.anon.3, %union.anon.3, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %union.anon.3, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %union.anon.3, i64, %struct.timerqueue_node, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.mm_rss_stat = type { [4 x %union.anon.3] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.12 }
%union.anon.12 = type { %struct.anon.16, [80 x i8] }
%struct.anon.16 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.22, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.22 = type { %struct.anon.23 }
%struct.anon.23 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %union.anon.3, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.timespec }
%struct.timespec = type { i64, i64 }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %union.anon.3* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %union.anon.3, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.0 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.atomic_t, %struct.atomic_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.2, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.bdi_writeback = type opaque
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.3 = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.atomic_t, %struct.atomic_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.3, i64, %struct.atomic_t, %struct.atomic_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.3, i64, i64, i64, %union.anon.3, %struct.key*, %struct.key*, %struct.hlist_node, %struct.atomic_t, %union.anon.3 }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.atomic_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.vm_operations_struct = type opaque
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.qspinlock }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %union.anon.3, %struct.spinlock, %struct.qspinlock, %struct.list_head, i8*, %struct.lockdep_map }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.qspinlock, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.51 = type { i8* }
%struct.anon.58 = type { i8, i8 }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %union.anon.51, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.atomic_t, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type opaque
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.device_node = type opaque
%struct.fwnode_handle = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.subsys_private = type opaque
%struct.miscdevice = type { i32, i8*, %struct.file_operations*, %struct.list_head, %struct.device*, %struct.device*, %struct.attribute_group**, i8*, i16 }
%struct.led_trigger = type { i8*, void (%struct.led_classdev*)*, void (%struct.led_classdev*)*, %struct.rwlock_t, %struct.list_head, %struct.list_head }
%struct.led_classdev = type { i8*, i32, i32, i32, i64, void (%struct.led_classdev*, i32)*, i32 (%struct.led_classdev*, i32)*, i32 (%struct.led_classdev*)*, i32 (%struct.led_classdev*, i64*, i64*)*, %struct.device*, %struct.attribute_group**, %struct.list_head, i8*, i64, i64, %struct.timer_list, i32, i32, {}*, %struct.work_struct, i32, %struct.rw_semaphore, %struct.led_trigger*, %struct.list_head, i8*, i8, i32, %struct.kernfs_node*, %struct.mutex }
%struct.input_handler = type { i8*, void (%struct.input_handle*, i32, i32, i32)*, void (%struct.input_handle*, %struct.input_value*, i32)*, i1 (%struct.input_handle*, i32, i32, i32)*, i1 (%struct.input_handler*, %struct.input_dev*)*, i32 (%struct.input_handler*, %struct.input_dev*, %struct.input_device_id*)*, void (%struct.input_handle*)*, void (%struct.input_handle*)*, i8, i32, i8*, %struct.input_device_id*, %struct.list_head, %struct.list_head }
%struct.input_handle = type { i8*, i32, i8*, %struct.input_dev*, %struct.input_handler*, %struct.list_head, %struct.list_head }
%struct.input_dev = type { i8*, i8*, i8*, %struct.input_id, [1 x i64], [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i32, i32, i32, i8*, i32 (%struct.input_dev*, %struct.input_keymap_entry*, i32*)*, i32 (%struct.input_dev*, %struct.input_keymap_entry*)*, %struct.ff_device*, i32, %struct.timer_list, [2 x i32], %struct.input_mt*, %struct.input_absinfo*, [12 x i64], [1 x i64], [1 x i64], [1 x i64], i32 (%struct.input_dev*)*, void (%struct.input_dev*)*, i32 (%struct.input_dev*, %struct.file*)*, i32 (%struct.input_dev*, i32, i32, i32)*, %struct.input_handle*, %struct.spinlock, %struct.mutex, i32, i8, %struct.device, %struct.list_head, %struct.list_head, i32, i32, %struct.input_value*, i8 }
%struct.input_id = type { i16, i16, i16, i16 }
%struct.input_keymap_entry = type { i8, i8, i16, i32, [32 x i8] }
%struct.ff_device = type { i32 (%struct.input_dev*, %struct.ff_effect*, %struct.ff_effect*)*, i32 (%struct.input_dev*, i32)*, i32 (%struct.input_dev*, i32, i32)*, void (%struct.input_dev*, i16)*, void (%struct.input_dev*, i16)*, void (%struct.ff_device*)*, i8*, [2 x i64], %struct.mutex, i32, %struct.ff_effect*, [0 x %struct.file*] }
%struct.ff_effect = type { i16, i16, i16, %struct.ff_trigger, %struct.ff_trigger, %union.anon.1.21 }
%struct.ff_trigger = type { i16, i16 }
%union.anon.1.21 = type { %struct.ff_periodic_effect }
%struct.ff_periodic_effect = type { i16, i16, i16, i16, i16, %struct.input_id, i32, i16* }
%struct.input_mt = type opaque
%struct.input_absinfo = type { i32, i32, i32, i32, i32, i32 }
%struct.input_value = type { i16, i16, i32 }
%struct.input_device_id = type { i64, i16, i16, i16, i16, [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i64 }
%struct.rfkill = type { %struct.spinlock, i32, i64, i32, i8, i8, i8, i8, %struct.rfkill_ops*, i8*, %struct.led_trigger, i8*, %struct.device, %struct.list_head, %struct.delayed_work, %struct.work_struct, %struct.work_struct, [0 x i8] }
%struct.rfkill_ops = type { void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)*, i32 (i8*, i1)* }
%struct.rfkill_data = type { %struct.list_head, %struct.list_head, %struct.mutex, %struct.__wait_queue_head, i8 }
%struct.rfkill_int_event = type { %struct.list_head, %struct.rfkill_event }
%struct.rfkill_event = type { i32, i8, i8, i8, i8 }
%union.anon.60 = type { %struct.list_head* }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }

@llvm.used = appending global [24 x i8*] [i8* getelementptr inbounds ([41 x i8], [41 x i8]* @__UNIQUE_ID_author8, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @__UNIQUE_ID_author9, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_description10, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license11, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_default_state to i8*), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__UNIQUE_ID_default_statetype12, i32 0, i32 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @__UNIQUE_ID_default_state13, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_get_led_trigger_name to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_led_trigger_name to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_hw_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_sw_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_init_sw_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_states to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_find_type to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_pause_polling to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_resume_polling to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_blocked to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_alloc to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_unregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_destroy to i8*), i8* bitcast (%struct.kernel_param* @__param_master_switch_mode to i8*), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @__UNIQUE_ID_master_switch_modetype8, i32 0, i32 0), i8* getelementptr inbounds ([102 x i8], [102 x i8]* @__UNIQUE_ID_master_switch_mode9, i32 0, i32 0)], section "llvm.metadata"
@__UNIQUE_ID_author8 = internal constant [41 x i8] c"author=Ivo van Doorn <IvDoorn@gmail.com>\00", section ".modinfo", align 1
@__UNIQUE_ID_author9 = internal constant [49 x i8] c"author=Johannes Berg <johannes@sipsolutions.net>\00", section ".modinfo", align 1
@__UNIQUE_ID_description10 = internal constant [30 x i8] c"description=RF switch support\00", section ".modinfo", align 1
@__UNIQUE_ID_license11 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__param_default_state = internal constant %struct.kernel_param { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__param_str_default_state, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_uint, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @rfkill_default_state to i8*) } }, section "__param", align 8
@__UNIQUE_ID_default_statetype12 = internal constant [28 x i8] c"parmtype=default_state:uint\00", section ".modinfo", align 1
@__UNIQUE_ID_default_state13 = internal constant [76 x i8] c"parm=default_state:Default initial state for all radio types, 0 = radio off\00", section ".modinfo", align 1
@__ksymtab_rfkill_get_led_trigger_name = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (%struct.rfkill*)* @rfkill_get_led_trigger_name to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_rfkill_get_led_trigger_name, i32 0, i32 0) }, section "___ksymtab+rfkill_get_led_trigger_name", align 8
@__ksymtab_rfkill_set_led_trigger_name = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*, i8*)* @rfkill_set_led_trigger_name to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_rfkill_set_led_trigger_name, i32 0, i32 0) }, section "___ksymtab+rfkill_set_led_trigger_name", align 8
@__ksymtab_rfkill_set_hw_state = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.rfkill*, i1)* @rfkill_set_hw_state to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_rfkill_set_hw_state, i32 0, i32 0) }, section "___ksymtab+rfkill_set_hw_state", align 8
@__ksymtab_rfkill_set_sw_state = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.rfkill*, i1)* @rfkill_set_sw_state to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_rfkill_set_sw_state, i32 0, i32 0) }, section "___ksymtab+rfkill_set_sw_state", align 8
@__ksymtab_rfkill_init_sw_state = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*, i1)* @rfkill_init_sw_state to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_rfkill_init_sw_state, i32 0, i32 0) }, section "___ksymtab+rfkill_init_sw_state", align 8
@__ksymtab_rfkill_set_states = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*, i1, i1)* @rfkill_set_states to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rfkill_set_states, i32 0, i32 0) }, section "___ksymtab+rfkill_set_states", align 8
@__ksymtab_rfkill_find_type = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i8*)* @rfkill_find_type to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_rfkill_find_type, i32 0, i32 0) }, section "___ksymtab+rfkill_find_type", align 8
@__ksymtab_rfkill_pause_polling = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_pause_polling to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_rfkill_pause_polling, i32 0, i32 0) }, section "___ksymtab+rfkill_pause_polling", align 8
@__ksymtab_rfkill_resume_polling = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_resume_polling to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_rfkill_resume_polling, i32 0, i32 0) }, section "___ksymtab+rfkill_resume_polling", align 8
@__ksymtab_rfkill_blocked = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.rfkill*)* @rfkill_blocked to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rfkill_blocked, i32 0, i32 0) }, section "___ksymtab+rfkill_blocked", align 8
@__ksymtab_rfkill_alloc = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rfkill* (i8*, %struct.device*, i32, %struct.rfkill_ops*, i8*)* @rfkill_alloc to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_rfkill_alloc, i32 0, i32 0) }, section "___ksymtab+rfkill_alloc", align 8
@__ksymtab_rfkill_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rfkill*)* @rfkill_register to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_rfkill_register, i32 0, i32 0) }, section "___ksymtab+rfkill_register", align 8
@__ksymtab_rfkill_unregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_unregister to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rfkill_unregister, i32 0, i32 0) }, section "___ksymtab+rfkill_unregister", align 8
@__ksymtab_rfkill_destroy = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_destroy to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rfkill_destroy, i32 0, i32 0) }, section "___ksymtab+rfkill_destroy", align 8
@__kstrtab_rfkill_destroy = internal constant [15 x i8] c"rfkill_destroy\00", section "__ksymtab_strings", align 1
@__kstrtab_rfkill_unregister = internal constant [18 x i8] c"rfkill_unregister\00", section "__ksymtab_strings", align 1
@.str = private unnamed_addr constant [18 x i8] c"net/rfkill/core.c\00", align 1
@rfkill_global_mutex = internal global %struct.mutex { %union.anon.3 zeroinitializer, %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.10, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.qspinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @rfkill_global_mutex to i8*), i64 88) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @rfkill_global_mutex to i8*), i64 88) to %struct.list_head*) }, i8* bitcast (%struct.mutex* @rfkill_global_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.11, i32 0, i32 0), i32 0, i64 0 } }, align 8
@rfkill_any_work = internal global %struct.work_struct zeroinitializer, align 8
@system_wq = external global %struct.workqueue_struct*, align 8
@rfkill_fds = internal global %struct.list_head { %struct.list_head* @rfkill_fds, %struct.list_head* @rfkill_fds }, align 8
@.str.10 = private unnamed_addr constant [30 x i8] c"rfkill_global_mutex.wait_lock\00", align 1
@.str.11 = private unnamed_addr constant [20 x i8] c"rfkill_global_mutex\00", align 1
@__kstrtab_rfkill_register = internal constant [16 x i8] c"rfkill_register\00", section "__ksymtab_strings", align 1
@rfkill_register.rfkill_no = internal global i64 0, align 8
@.str.2 = private unnamed_addr constant [10 x i8] c"rfkill%lu\00", align 1
@rfkill_list = internal global %struct.list_head { %struct.list_head* @rfkill_list, %struct.list_head* @rfkill_list }, align 8
@.str.3 = private unnamed_addr constant [30 x i8] c"(&(&rfkill->poll_work)->work)\00", align 1
@rfkill_register.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.5 = private unnamed_addr constant [31 x i8] c"(&(&rfkill->poll_work)->timer)\00", align 1
@rfkill_register.__key.4 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.7 = private unnamed_addr constant [23 x i8] c"(&rfkill->uevent_work)\00", align 1
@rfkill_register.__key.6 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.9 = private unnamed_addr constant [21 x i8] c"(&rfkill->sync_work)\00", align 1
@rfkill_register.__key.8 = internal global %struct.lock_class_key zeroinitializer, align 1
@system_power_efficient_wq = external global %struct.workqueue_struct*, align 8
@rfkill_epo_lock_active = internal global i8 0, align 1
@rfkill_input_disabled = internal global %struct.atomic_t zeroinitializer, align 4
@rfkill_global_states = internal global [9 x %struct.anon.58] zeroinitializer, align 16
@__kstrtab_rfkill_alloc = internal constant [13 x i8] c"rfkill_alloc\00", section "__ksymtab_strings", align 1
@.str.1 = private unnamed_addr constant [24 x i8] c"&(&rfkill->lock)->rlock\00", align 1
@rfkill_alloc.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@rfkill_class = internal global %struct.class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1.8, i32 0, i32 0), %struct.module* null, %struct.class_attribute* null, %struct.attribute_group** null, %struct.attribute_group** getelementptr inbounds ([2 x %struct.attribute_group*], [2 x %struct.attribute_group*]* @rfkill_dev_groups, i32 0, i32 0), %struct.kobject* null, i32 (%struct.device*, %struct.kobj_uevent_env*)* @rfkill_dev_uevent, i8* (%struct.device*, i16*)* null, void (%struct.class*)* null, void (%struct.device*)* @rfkill_release, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.kobj_ns_type_operations* null, i8* (%struct.device*)* null, %struct.dev_pm_ops* @rfkill_pm_ops, %struct.subsys_private* null }, align 8
@rfkill_dev_groups = internal global [2 x %struct.attribute_group*] [%struct.attribute_group* @rfkill_dev_group, %struct.attribute_group* null], align 16
@rfkill_pm_ops = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* @rfkill_suspend, i32 (%struct.device*)* @rfkill_resume, i32 (%struct.device*)* @rfkill_suspend, i32 (%struct.device*)* @rfkill_resume, i32 (%struct.device*)* @rfkill_suspend, i32 (%struct.device*)* @rfkill_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null }, align 8
@.str.30 = private unnamed_addr constant [15 x i8] c"RFKILL_NAME=%s\00", align 1
@rfkill_types = internal constant [9 x i8*] [i8* null, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0)], align 16
@.str.31 = private unnamed_addr constant [15 x i8] c"RFKILL_TYPE=%s\00", align 1
@.str.32 = private unnamed_addr constant [16 x i8] c"RFKILL_STATE=%d\00", align 1
@.str.12 = private unnamed_addr constant [5 x i8] c"wlan\00", align 1
@.str.13 = private unnamed_addr constant [10 x i8] c"bluetooth\00", align 1
@.str.14 = private unnamed_addr constant [14 x i8] c"ultrawideband\00", align 1
@.str.15 = private unnamed_addr constant [6 x i8] c"wimax\00", align 1
@.str.16 = private unnamed_addr constant [5 x i8] c"wwan\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"gps\00", align 1
@.str.18 = private unnamed_addr constant [3 x i8] c"fm\00", align 1
@.str.19 = private unnamed_addr constant [4 x i8] c"nfc\00", align 1
@rfkill_dev_group = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([8 x %struct.attribute*], [8 x %struct.attribute*]* @rfkill_dev_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@rfkill_dev_attrs = internal global [8 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_name, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_type, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_index, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_persistent, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_state, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_soft, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_hard, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_name = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.21, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @name_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_type = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.23, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @type_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_index = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.24, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @index_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_persistent = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.26, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @persistent_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_state = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.27, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @state_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @state_store }, align 8
@dev_attr_soft = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.28, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @soft_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @soft_store }, align 8
@dev_attr_hard = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.29, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @hard_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.29 = private unnamed_addr constant [5 x i8] c"hard\00", align 1
@.str.25 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.28 = private unnamed_addr constant [5 x i8] c"soft\00", align 1
@.str.27 = private unnamed_addr constant [6 x i8] c"state\00", align 1
@.str.26 = private unnamed_addr constant [11 x i8] c"persistent\00", align 1
@.str.24 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str.23 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.22 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.21 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@__kstrtab_rfkill_blocked = internal constant [15 x i8] c"rfkill_blocked\00", section "__ksymtab_strings", align 1
@__kstrtab_rfkill_resume_polling = internal constant [22 x i8] c"rfkill_resume_polling\00", section "__ksymtab_strings", align 1
@__kstrtab_rfkill_pause_polling = internal constant [21 x i8] c"rfkill_pause_polling\00", section "__ksymtab_strings", align 1
@__kstrtab_rfkill_find_type = internal constant [17 x i8] c"rfkill_find_type\00", section "__ksymtab_strings", align 1
@__kstrtab_rfkill_set_states = internal constant [18 x i8] c"rfkill_set_states\00", section "__ksymtab_strings", align 1
@__kstrtab_rfkill_init_sw_state = internal constant [21 x i8] c"rfkill_init_sw_state\00", section "__ksymtab_strings", align 1
@__kstrtab_rfkill_set_sw_state = internal constant [20 x i8] c"rfkill_set_sw_state\00", section "__ksymtab_strings", align 1
@__kstrtab_rfkill_set_hw_state = internal constant [20 x i8] c"rfkill_set_hw_state\00", section "__ksymtab_strings", align 1
@__kstrtab_rfkill_set_led_trigger_name = internal constant [28 x i8] c"rfkill_set_led_trigger_name\00", section "__ksymtab_strings", align 1
@__kstrtab_rfkill_get_led_trigger_name = internal constant [28 x i8] c"rfkill_get_led_trigger_name\00", section "__ksymtab_strings", align 1
@__param_str_default_state = internal constant [14 x i8] c"default_state\00", align 1
@__this_module = external global %struct.module, align 64
@param_ops_uint = external constant %struct.kernel_param_ops, align 8
@rfkill_default_state = internal global i32 1, align 4
@rfkill_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@rfkill_miscdev = internal global %struct.miscdevice { i32 255, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1.8, i32 0, i32 0), %struct.file_operations* @rfkill_fops, %struct.list_head zeroinitializer, %struct.device* null, %struct.device* null, %struct.attribute_group** null, i8* null, i16 0 }, align 8
@rfkill_any_led_trigger = internal global %struct.led_trigger zeroinitializer, align 8
@.str.40 = private unnamed_addr constant [19 x i8] c"(&rfkill_any_work)\00", align 1
@rfkill_any_led_trigger_register.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.41 = private unnamed_addr constant [11 x i8] c"rfkill-any\00", align 1
@rfkill_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* @rfkill_fop_read, i64 (%struct.file*, i8*, i64, i64*)* @rfkill_fop_write, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @rfkill_fop_poll, i64 (%struct.file*, i32, i64)* @rfkill_fop_ioctl, i64 (%struct.file*, i32, i64)* @rfkill_fop_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @rfkill_fop_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @rfkill_fop_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.39 = private unnamed_addr constant [33 x i8] c"\017rfkill: input handler enabled\0A\00", align 1
@.str.36 = private unnamed_addr constant [11 x i8] c"&data->mtx\00", align 1
@rfkill_fop_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.38 = private unnamed_addr constant [17 x i8] c"&data->read_wait\00", align 1
@rfkill_fop_open.__key.37 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.35 = private unnamed_addr constant [34 x i8] c"\017rfkill: input handler disabled\0A\00", align 1
@.str.33 = private unnamed_addr constant [33 x i8] c"./arch/x86/include/asm/uaccess.h\00", align 1
@.str.34 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@__param_master_switch_mode = internal constant %struct.kernel_param { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__param_str_master_switch_mode, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_uint, i16 0, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @rfkill_master_switch_mode to i8*) } }, section "__param", align 8
@__UNIQUE_ID_master_switch_modetype8 = internal constant [33 x i8] c"parmtype=master_switch_mode:uint\00", section ".modinfo", align 1
@__UNIQUE_ID_master_switch_mode9 = internal constant [102 x i8] c"parm=master_switch_mode:SW_RFKILL_ALL ON should: 0=do nothing (only unlock); 1=restore; 2=unblock all\00", section ".modinfo", align 1
@__param_str_master_switch_mode = internal constant [19 x i8] c"master_switch_mode\00", align 16
@rfkill_master_switch_mode = internal global i32 2, align 4
@rfkill_master_switch_op = internal global i32 0, align 4
@rfkill_op_lock = internal global %struct.spinlock zeroinitializer, align 8
@.str.6 = private unnamed_addr constant [26 x i8] c"&(&rfkill_op_lock)->rlock\00", align 1
@rfkill_handler_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@jiffies = external global i64, align 8
@rfkill_last_scheduled = internal global i64 0, align 8
@rfkill_handler = internal global %struct.input_handler { i8* null, void (%struct.input_handle*, i32, i32, i32)* @rfkill_event.7, void (%struct.input_handle*, %struct.input_value*, i32)* null, i1 (%struct.input_handle*, i32, i32, i32)* null, i1 (%struct.input_handler*, %struct.input_dev*)* null, i32 (%struct.input_handler*, %struct.input_dev*, %struct.input_device_id*)* @rfkill_connect, void (%struct.input_handle*)* @rfkill_disconnect, void (%struct.input_handle*)* @rfkill_start, i8 0, i32 0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1.8, i32 0, i32 0), %struct.input_device_id* getelementptr inbounds ([7 x %struct.input_device_id], [7 x %struct.input_device_id]* @rfkill_ids, i32 0, i32 0), %struct.list_head zeroinitializer, %struct.list_head zeroinitializer }, align 8
@.str.1.8 = private unnamed_addr constant [7 x i8] c"rfkill\00", align 1
@rfkill_ids = internal constant [7 x %struct.input_device_id] [%struct.input_device_id { i64 48, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 2], [12 x i64] [i64 0, i64 0, i64 0, i64 70368744177664, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] zeroinitializer, i64 0 }, %struct.input_device_id { i64 48, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 2], [12 x i64] [i64 0, i64 0, i64 0, i64 35184372088832, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] zeroinitializer, i64 0 }, %struct.input_device_id { i64 48, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 2], [12 x i64] [i64 0, i64 0, i64 0, i64 140737488355328, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] zeroinitializer, i64 0 }, %struct.input_device_id { i64 48, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 2], [12 x i64] [i64 0, i64 0, i64 0, i64 18014398509481984, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] zeroinitializer, i64 0 }, %struct.input_device_id { i64 48, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 2], [12 x i64] [i64 0, i64 0, i64 0, i64 36028797018963968, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] zeroinitializer, i64 0 }, %struct.input_device_id { i64 4112, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 32], [12 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] [i64 8], i64 0 }, %struct.input_device_id zeroinitializer], align 16
@rfkill_op = internal global i32 0, align 4
@rfkill_op_pending = internal global i8 0, align 1
@rfkill_op_work = internal global %struct.delayed_work { %struct.work_struct { %union.anon.3 { i64 137438953424 }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.delayed_work* @rfkill_op_work to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.delayed_work* @rfkill_op_work to i8*), i64 8) to %struct.list_head*) }, void (%struct.work_struct*)* @rfkill_op_handler, %struct.lockdep_map { %struct.lock_class_key* bitcast (%struct.delayed_work* @rfkill_op_work to %struct.lock_class_key*), [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.2.11, i32 0, i32 0), i32 0, i64 0 } }, %struct.timer_list { %struct.hlist_node { %struct.hlist_node* inttoptr (i64 -2401263026318605568 to %struct.hlist_node*), %struct.hlist_node** null }, i64 0, void (i64)* @delayed_work_timer_fn, i64 ptrtoint (%struct.delayed_work* @rfkill_op_work to i64), i32 2097152, %struct.lockdep_map { %struct.lock_class_key* bitcast ([23 x i8]* @.str.3.12 to %struct.lock_class_key*), [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3.12, i32 0, i32 0), i32 0, i64 0 } }, %struct.workqueue_struct* null, i32 0 }, align 8
@.str.2.11 = private unnamed_addr constant [22 x i8] c"(rfkill_op_work).work\00", align 1
@.str.3.12 = private unnamed_addr constant [23 x i8] c"net/rfkill/input.c:140\00", align 1
@rfkill_sw_pending = internal global [1 x i64] zeroinitializer, align 8
@rfkill_sw_state = internal global [1 x i64] zeroinitializer, align 8
@.str.4 = private unnamed_addr constant [19 x i8] c"net/rfkill/input.c\00", align 1
@.str.5.13 = private unnamed_addr constant [70 x i8] c"Unknown requested operation %d! rfkill Emergency Power Off activated\0A\00", align 1

@init_module = alias i32 (), i32 ()* @rfkill_init
@cleanup_module = alias void (), void ()* @rfkill_exit

; Function Attrs: nounwind uwtable
define void @rfkill_destroy(%struct.rfkill* %rfkill) #0 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  call void @put_device(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @put_device(%struct.device*) #1

; Function Attrs: nounwind uwtable
define void @rfkill_unregister(%struct.rfkill* %rfkill) #0 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 1067, i64 12) #7, !srcloc !2
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %0 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %0, i32 0, i32 0
  %1 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !7
  %tobool10 = icmp ne void (%struct.rfkill*, i8*)* %1, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %do.end9
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %poll_work)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %do.end9
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %call13 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %uevent_work)
  %sync_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 16
  %call14 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %sync_work)
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  store i8 0, i8* %registered, align 4, !tbaa !9
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  call void @device_del(%struct.device* %dev)
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  call void @rfkill_send_events(%struct.rfkill* %rfkill, i32 1)
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  call void @list_del_init(%struct.list_head* %node)
  call void @rfkill_any_led_trigger_event()
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  call void @rfkill_led_trigger_unregister(%struct.rfkill* %rfkill)
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #2

declare zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work*) #1

declare zeroext i1 @cancel_work_sync(%struct.work_struct*) #1

declare void @device_del(%struct.device*) #1

declare void @mutex_lock_nested(%struct.mutex*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_send_events(%struct.rfkill* %rfkill, i32 %op) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_fds, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !3
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr7 to %struct.rfkill_data*
  %list = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @rfkill_fds
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i8* @kzalloc(i64 24, i32 20971712)
  %3 = bitcast i8* %call to %struct.rfkill_int_event*
  %tobool = icmp ne %struct.rfkill_int_event* %3, null
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %ev1 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %3, i32 0, i32 1
  call void @rfkill_fill_event(%struct.rfkill_event* %ev1, %struct.rfkill* %rfkill, i32 %op)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx, i32 0)
  %list2 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %3, i32 0, i32 0
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 1
  call void @list_add_tail(%struct.list_head* %list2, %struct.list_head* %events)
  %mtx3 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx3)
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 3
  call void @__wake_up(%struct.__wait_queue_head* %read_wait, i32 1, i32 1, i8* null)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %list5 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list5, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #3 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_any_led_trigger_event() #0 {
entry:
  call void @schedule_work(%struct.work_struct* @rfkill_any_work)
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_led_trigger_unregister(%struct.rfkill* %rfkill) #0 {
entry:
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 10
  call void @led_trigger_unregister(%struct.led_trigger* %led_trigger)
  ret void
}

declare void @led_trigger_unregister(%struct.led_trigger*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @schedule_work(%struct.work_struct* %work) #3 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !3
  call void @queue_work(%struct.workqueue_struct* %0, %struct.work_struct* %work)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_work(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #3 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 8192, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret void
}

declare zeroext i1 @queue_work_on(i32, %struct.workqueue_struct*, %struct.work_struct*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #3 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !11
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !13
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #3 {
entry:
  %__u = alloca %union.anon.60, align 8
  %__val = bitcast %union.anon.60* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !14
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.60* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !15
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !15
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !11
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #4

declare zeroext i1 @__list_del_entry_valid(%struct.list_head*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  %__u = alloca %union.anon.60, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !11
  %__val = bitcast %union.anon.60* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !14
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.60* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !15
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !15
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_fill_event(%struct.rfkill_event* %ev, %struct.rfkill* %rfkill, i32 %op) #0 {
entry:
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %0 = load i32, i32* %idx, align 8, !tbaa !17
  %idx1 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 0
  store i32 %0, i32* %idx1, align 1, !tbaa !19
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 1
  %1 = load i32, i32* %type, align 8, !tbaa !14
  %conv = trunc i32 %1 to i8
  %type2 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  store i8 %conv, i8* %type2, align 1, !tbaa !21
  %conv3 = trunc i32 %op to i8
  %op4 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  store i8 %conv3, i8* %op4, align 1, !tbaa !22
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call7 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %3 = load i64, i64* %state, align 8, !tbaa !23
  %and = and i64 %3, 1
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = trunc i32 %lnot.ext to i8
  %hard = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 4
  store i8 %conv11, i8* %hard, align 1, !tbaa !25
  %state12 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %4 = load i64, i64* %state12, align 8, !tbaa !23
  %and13 = and i64 %4, 6
  %tobool14 = icmp ne i64 %and13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = trunc i32 %lnot.ext18 to i8
  %soft = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  store i8 %conv19, i8* %soft, align 1, !tbaa !26
  %lock20 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock20, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %5 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call7) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !11
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  %__u = alloca %union.anon.60, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !11
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !13
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !11
  %__val = bitcast %union.anon.60* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !14
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.60* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %arraydecay to i64*
  %2 = load i64, i64* %1, align 8, !tbaa !15
  %3 = bitcast i8* %0 to i64*
  store volatile i64 %2, i64* %3, align 8, !tbaa !15
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_add_valid(%struct.list_head*, %struct.list_head*, %struct.list_head*) #1

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

declare noalias i8* @__kmalloc(i64, i32) #1

; Function Attrs: nounwind uwtable
define i32 @rfkill_register(%struct.rfkill* %rfkill) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %.compoundliteral = alloca %union.anon.3, align 8
  %.compoundliteral55 = alloca %union.anon.3, align 8
  %.compoundliteral68 = alloca %union.anon.3, align 8
  %dev1 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 1004, i64 12) #7, !srcloc !27
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  %0 = load i8, i8* %registered, align 4, !tbaa !9, !range !28
  %tobool11 = trunc i8 %0 to i1
  br i1 %tobool11, label %unlock, label %if.end13

if.end13:                                         ; preds = %do.end10
  %1 = load i64, i64* @rfkill_register.rfkill_no, align 8, !tbaa !23
  %conv14 = trunc i64 %1 to i32
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  store i32 %conv14, i32* %idx, align 8, !tbaa !17
  %2 = load i64, i64* @rfkill_register.rfkill_no, align 8, !tbaa !23
  %call = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev1, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i64 %2)
  %3 = load i64, i64* @rfkill_register.rfkill_no, align 8, !tbaa !23
  %inc = add i64 %3, 1
  store i64 %inc, i64* @rfkill_register.rfkill_no, align 8, !tbaa !23
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  call void @list_add_tail(%struct.list_head* %node, %struct.list_head* @rfkill_list)
  %call15 = call i32 @device_add(%struct.device* %dev1)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %remove, label %if.end18

if.end18:                                         ; preds = %if.end13
  %call19 = call i32 @rfkill_led_trigger_register(%struct.rfkill* %rfkill)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %devdel, label %if.end22

if.end22:                                         ; preds = %if.end18
  %registered23 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  store i8 1, i8* %registered23, align 4, !tbaa !9
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %poll_work26 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %work27 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work26, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work27, i32 0, i32 0
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !29
  %4 = bitcast %union.anon.3* %data to i8*
  %5 = bitcast %union.anon.3* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 8, i32 8, i1 false), !tbaa.struct !31
  %poll_work28 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %work29 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work28, i32 0, i32 0
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work29, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.3, i32 0, i32 0), %struct.lock_class_key* @rfkill_register.__key, i32 0)
  %poll_work30 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %work31 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work30, i32 0, i32 0
  %entry32 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work31, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry32)
  %poll_work33 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %work34 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work33, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work34, i32 0, i32 2
  store void (%struct.work_struct*)* @rfkill_poll, void (%struct.work_struct*)** %func, align 8, !tbaa !32
  %poll_work39 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work39, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2097152, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.5, i32 0, i32 0), %struct.lock_class_key* @rfkill_register.__key.4)
  %poll_work42 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %timer43 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work42, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer43, i32 0, i32 2
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !35
  %poll_work44 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %6 = ptrtoint %struct.delayed_work* %poll_work44 to i64
  %poll_work45 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %timer46 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work45, i32 0, i32 1
  %data47 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer46, i32 0, i32 3
  store i64 %6, i64* %data47, align 8, !tbaa !38
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  call void @__init_work(%struct.work_struct* %uevent_work, i32 0)
  %uevent_work53 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %data54 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work53, i32 0, i32 0
  %counter56 = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral55, i32 0, i32 0
  store i64 137438953408, i64* %counter56, align 8, !tbaa !29
  %7 = bitcast %union.anon.3* %data54 to i8*
  %8 = bitcast %union.anon.3* %.compoundliteral55 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false), !tbaa.struct !31
  %uevent_work57 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %lockdep_map58 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work57, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map58, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.7, i32 0, i32 0), %struct.lock_class_key* @rfkill_register.__key.6, i32 0)
  %uevent_work59 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %entry60 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work59, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry60)
  %uevent_work61 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %func62 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work61, i32 0, i32 2
  store void (%struct.work_struct*)* @rfkill_uevent_work, void (%struct.work_struct*)** %func62, align 8, !tbaa !32
  %sync_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 16
  call void @__init_work(%struct.work_struct* %sync_work, i32 0)
  %sync_work66 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 16
  %data67 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work66, i32 0, i32 0
  %counter69 = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral68, i32 0, i32 0
  store i64 137438953408, i64* %counter69, align 8, !tbaa !29
  %9 = bitcast %union.anon.3* %data67 to i8*
  %10 = bitcast %union.anon.3* %.compoundliteral68 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false), !tbaa.struct !31
  %sync_work70 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 16
  %lockdep_map71 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work70, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map71, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.9, i32 0, i32 0), %struct.lock_class_key* @rfkill_register.__key.8, i32 0)
  %sync_work72 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 16
  %entry73 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work72, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry73)
  %sync_work74 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 16
  %func75 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work74, i32 0, i32 2
  store void (%struct.work_struct*)* @rfkill_sync_work, void (%struct.work_struct*)** %func75, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %11 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %11, i32 0, i32 0
  %12 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !7
  %tobool78 = icmp ne void (%struct.rfkill*, i8*)* %12, null
  br i1 %tobool78, label %if.then79, label %if.end83

if.then79:                                        ; preds = %if.end22
  %13 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_power_efficient_wq, align 8, !tbaa !3
  %poll_work80 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %call81 = call i64 @round_jiffies_relative(i64 1250)
  call void @queue_delayed_work(%struct.workqueue_struct* %13, %struct.delayed_work* %poll_work80, i64 %call81)
  br label %if.end83

if.end83:                                         ; preds = %if.then79, %if.end22
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %14 = load i8, i8* %persistent, align 1, !tbaa !9, !range !28
  %tobool84 = trunc i8 %14 to i1
  br i1 %tobool84, label %lor.lhs.false, label %if.then87

lor.lhs.false:                                    ; preds = %if.end83
  %15 = load i8, i8* @rfkill_epo_lock_active, align 1, !tbaa !9, !range !28
  %tobool85 = trunc i8 %15 to i1
  br i1 %tobool85, label %if.then87, label %if.else

if.then87:                                        ; preds = %lor.lhs.false, %if.end83
  %sync_work88 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 16
  call void @schedule_work(%struct.work_struct* %sync_work88)
  br label %if.end100

if.else:                                          ; preds = %lor.lhs.false
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %16 = load i64, i64* %state, align 8, !tbaa !23
  %and = and i64 %16, 2
  %tobool90 = icmp ne i64 %and, 0
  %lnot91 = xor i1 %tobool90, true
  %lnot93 = xor i1 %lnot91, true
  %frombool = zext i1 %lnot93 to i8
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %17 = load volatile i32, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @rfkill_input_disabled, i32 0, i32 0), align 4, !tbaa !17
  %18 = bitcast i8* %arraydecay.i to i32*
  store i32 %17, i32* %18, align 4, !tbaa !17
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %19 = load i32, i32* %__val.i, align 4, !tbaa !14
  %tobool96 = icmp ne i32 %19, 0
  br i1 %tobool96, label %if.end100, label %if.then97

if.then97:                                        ; preds = %if.else
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 1
  %20 = load i32, i32* %type, align 8, !tbaa !14
  %tobool98 = trunc i8 %frombool to i1
  call void @__rfkill_switch_all(i32 %20, i1 zeroext %tobool98)
  br label %if.end100

if.end100:                                        ; preds = %if.then97, %if.else, %if.then87
  call void @rfkill_any_led_trigger_event()
  call void @rfkill_send_events(%struct.rfkill* %rfkill, i32 0)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

devdel:                                           ; preds = %if.end18
  %dev101 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  call void @device_del(%struct.device* %dev101)
  br label %remove

remove:                                           ; preds = %devdel, %if.end13
  %error.0 = phi i32 [ %call19, %devdel ], [ %call15, %if.end13 ]
  %node102 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  call void @list_del_init(%struct.list_head* %node102)
  br label %unlock

unlock:                                           ; preds = %remove, %do.end10
  %error.1 = phi i32 [ %error.0, %remove ], [ -114, %do.end10 ]
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %unlock, %if.end100
  %retval.0 = phi i32 [ %error.1, %unlock ], [ 0, %if.end100 ]
  ret i32 %retval.0
}

declare i32 @dev_set_name(%struct.device*, i8*, ...) #1

declare i32 @device_add(%struct.device*) #1

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_led_trigger_register(%struct.rfkill* %rfkill) #0 {
entry:
  %ledtrigname = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  %0 = load i8*, i8** %ledtrigname, align 8, !tbaa !3
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  %call = call i8* @dev_name(%struct.device* %dev)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %entry
  %cond = phi i8* [ %call, %cond.false ], [ %0, %entry ]
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 10
  %name = getelementptr inbounds %struct.led_trigger, %struct.led_trigger* %led_trigger, i32 0, i32 0
  store i8* %cond, i8** %name, align 8, !tbaa !3
  %led_trigger1 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 10
  %activate = getelementptr inbounds %struct.led_trigger, %struct.led_trigger* %led_trigger1, i32 0, i32 1
  store void (%struct.led_classdev*)* @rfkill_led_trigger_activate, void (%struct.led_classdev*)** %activate, align 8, !tbaa !3
  %led_trigger2 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 10
  %call3 = call i32 @led_trigger_register(%struct.led_trigger* %led_trigger2)
  ret i32 %call3
}

declare void @__init_work(%struct.work_struct*, i32) #1

declare void @lockdep_init_map(%struct.lockdep_map*, i8*, %struct.lock_class_key*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_poll(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1688
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 8
  %2 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %2, i32 0, i32 0
  %3 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !7
  %data = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 9
  %4 = load i8*, i8** %data, align 8, !tbaa !3
  call void %3(%struct.rfkill* %1, i8* %4)
  %5 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_power_efficient_wq, align 8, !tbaa !3
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 14
  %call = call i64 @round_jiffies_relative(i64 1250)
  call void @queue_delayed_work(%struct.workqueue_struct* %5, %struct.delayed_work* %poll_work, i64 %call)
  ret void
}

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #1

declare void @delayed_work_timer_fn(i64) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_uevent_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1880
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  call void @rfkill_event(%struct.rfkill* %1)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_sync_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1960
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 1
  %2 = load i32, i32* %type, align 8, !tbaa !14
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur1 = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx, i32 0, i32 0
  %3 = load i8, i8* %cur1, align 2, !tbaa !39, !range !28
  %tobool = trunc i8 %3 to i1
  %frombool = zext i1 %tobool to i8
  %tobool2 = trunc i8 %frombool to i1
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %tobool2)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  ret void
}

declare i64 @round_jiffies_relative(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 8192, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rfkill_switch_all(i32 %type, i1 zeroext %blocked) #0 {
entry:
  %frombool = zext i1 %blocked to i8
  %tobool = trunc i8 %frombool to i1
  %cmp.i = icmp ne i32 %type, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry
  %idxprom.i = zext i32 %type to i64
  %arrayidx.i = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom.i
  %cur.i = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx.i, i32 0, i32 0
  %frombool1.i = zext i1 %tobool to i8
  store i8 %frombool1.i, i8* %cur.i, align 2, !tbaa !39
  br label %rfkill_update_global_state.exit

if.end.i:                                         ; preds = %entry
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %if.end.i
  %i.0.i = phi i32 [ 0, %if.end.i ], [ %inc.i, %for.body.i ]
  %cmp2.i = icmp slt i32 %i.0.i, 9
  br i1 %cmp2.i, label %for.body.i, label %rfkill_update_global_state.exit

for.body.i:                                       ; preds = %for.cond.i
  %idxprom4.i = sext i32 %i.0.i to i64
  %arrayidx5.i = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom4.i
  %cur6.i = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx5.i, i32 0, i32 0
  %frombool7.i = zext i1 %tobool to i8
  store i8 %frombool7.i, i8* %cur6.i, align 2, !tbaa !39
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

rfkill_update_global_state.exit:                  ; preds = %for.cond.i, %if.then.i
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %rfkill_update_global_state.exit
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %rfkill_update_global_state.exit ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !3
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %1, i64 -1672
  %2 = bitcast i8* %add.ptr8 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 13
  %cmp = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %type1 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 1
  %3 = load i32, i32* %type1, align 8, !tbaa !14
  %cmp2 = icmp ne i32 %3, %type
  %cmp3 = icmp ne i32 %type, 0
  %or.cond = and i1 %cmp2, %cmp3
  br i1 %or.cond, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %tobool4 = trunc i8 %frombool to i1
  call void @rfkill_set_block(%struct.rfkill* %2, i1 zeroext %tobool4)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %node6 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 13
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node6, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_set_block(%struct.rfkill* %rfkill, i1 zeroext %blocked) #0 {
entry:
  %frombool = zext i1 %blocked to i8
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 11
  %power_state = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 0
  %event = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %power_state, i32 0, i32 0
  %0 = load i32, i32* %event, align 8, !tbaa !17
  %and = and i32 %0, 6
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %1 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %query = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %1, i32 0, i32 1
  %2 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %query, align 8, !tbaa !41
  %tobool3 = icmp ne void (%struct.rfkill*, i8*)* %2, null
  br i1 %tobool3, label %if.then4, label %do.body8

if.then4:                                         ; preds = %if.end
  %ops5 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %3 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops5, align 8, !tbaa !3
  %query6 = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %3, i32 0, i32 1
  %4 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %query6, align 8, !tbaa !41
  %data = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %5 = load i8*, i8** %data, align 8, !tbaa !3
  call void %4(%struct.rfkill* %rfkill, i8* %5)
  br label %do.body8

do.body8:                                         ; preds = %if.then4, %if.end
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  %call10 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i1)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %7 = load i64, i64* %state, align 8, !tbaa !23
  %and13 = and i64 %7, 2
  %tobool14 = icmp ne i64 %and13, 0
  %frombool15 = zext i1 %tobool14 to i8
  %tobool16 = trunc i8 %frombool15 to i1
  %state18 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %8 = load i64, i64* %state18, align 8, !tbaa !23
  %and20 = and i64 %8, -5
  %or = or i64 %8, 4
  %and20.sink = select i1 %tobool16, i64 %or, i64 %and20
  store i64 %and20.sink, i64* %state18, align 8, !tbaa !23
  %tobool22 = trunc i8 %frombool to i1
  %state24 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %9 = load i64, i64* %state24, align 8, !tbaa !23
  %and28 = and i64 %9, -3
  %or25 = or i64 %9, 2
  %and28.sink = select i1 %tobool22, i64 %or25, i64 %and28
  store i64 %and28.sink, i64* %state24, align 8, !tbaa !23
  %state30 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %10 = load i64, i64* %state30, align 8, !tbaa !23
  %or31 = or i64 %10, 2147483648
  store i64 %or31, i64* %state30, align 8, !tbaa !23
  %lock32 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock32, i32 0, i32 0
  %rlock.i5 = bitcast %union.anon.1* %11 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i5, i64 %call10) #7
  %ops33 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %12 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops33, align 8, !tbaa !3
  %set_block = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %12, i32 0, i32 2
  %13 = load i32 (i8*, i1)*, i32 (i8*, i1)** %set_block, align 8, !tbaa !42
  %data34 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %14 = load i8*, i8** %data34, align 8, !tbaa !3
  %tobool35 = trunc i8 %frombool to i1
  %call36 = call i32 %13(i8* %14, i1 zeroext %tobool35)
  %lock44 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %15 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock44, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %15 to %struct.raw_spinlock*
  %call46 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %tobool51 = icmp ne i32 %call36, 0
  br i1 %tobool51, label %if.then52, label %if.end63

if.then52:                                        ; preds = %do.body8
  %state53 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %16 = load i64, i64* %state53, align 8, !tbaa !23
  %and54 = and i64 %16, 4
  %tobool55 = icmp ne i64 %and54, 0
  %state57 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %17 = load i64, i64* %state57, align 8, !tbaa !23
  %and61 = and i64 %17, -3
  %or58 = or i64 %17, 2
  %and61.sink = select i1 %tobool55, i64 %or58, i64 %and61
  store i64 %and61.sink, i64* %state57, align 8, !tbaa !23
  br label %if.end63

if.end63:                                         ; preds = %if.then52, %do.body8
  %state64 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %18 = load i64, i64* %state64, align 8, !tbaa !23
  %and65 = and i64 %18, -2147483649
  store i64 %and65, i64* %state64, align 8, !tbaa !23
  %state66 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %19 = load i64, i64* %state66, align 8, !tbaa !23
  %and67 = and i64 %19, -5
  store i64 %and67, i64* %state66, align 8, !tbaa !23
  %state68 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %20 = load i64, i64* %state68, align 8, !tbaa !23
  %and69 = and i64 %20, 2
  %tobool70 = icmp ne i64 %and69, 0
  %frombool71 = zext i1 %tobool70 to i8
  %lock72 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %21 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock72, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %21 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i2, i64 %call46) #7
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  call void @rfkill_any_led_trigger_event()
  %tobool73 = trunc i8 %frombool15 to i1
  %conv74 = zext i1 %tobool73 to i32
  %tobool75 = trunc i8 %frombool71 to i1
  %conv76 = zext i1 %tobool75 to i32
  %cmp77 = icmp ne i32 %conv74, %conv76
  br i1 %cmp77, label %if.then79, label %cleanup.cont

if.then79:                                        ; preds = %if.end63
  call void @rfkill_event(%struct.rfkill* %rfkill)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then79, %if.end63, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_led_trigger_event(%struct.rfkill* %rfkill) #0 {
entry:
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  %0 = load i8, i8* %registered, align 4, !tbaa !9, !range !28
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 10
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %1 = load i64, i64* %state, align 8, !tbaa !23
  %and = and i64 %1, 7
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  call void @led_trigger_event(%struct.led_trigger* %led_trigger, i32 0)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end
  call void @led_trigger_event(%struct.led_trigger* %led_trigger, i32 255)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.else, %if.then2, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_event(%struct.rfkill* %rfkill) #0 {
entry:
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  %0 = load i8, i8* %registered, align 4, !tbaa !9, !range !28
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i32 @kobject_uevent(%struct.kobject* %kobj, i32 2)
  call void @rfkill_send_events(%struct.rfkill* %rfkill, i32 2)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare i32 @kobject_uevent(%struct.kobject*, i32) #1

declare void @led_trigger_event(%struct.led_trigger*, i32) #1

declare zeroext i1 @queue_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name(%struct.device* %dev) #3 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !43
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !43
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_led_trigger_activate(%struct.led_classdev* %led) #0 {
entry:
  %trigger = getelementptr inbounds %struct.led_classdev, %struct.led_classdev* %led, i32 0, i32 22
  %0 = load %struct.led_trigger*, %struct.led_trigger** %trigger, align 8, !tbaa !60
  %1 = bitcast %struct.led_trigger* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -112
  %2 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @rfkill_led_trigger_event(%struct.rfkill* %2)
  ret void
}

declare i32 @led_trigger_register(%struct.led_trigger*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name(%struct.kobject* %kobj) #3 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !65
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define %struct.rfkill* @rfkill_alloc(i8* %name, %struct.device* %parent, i32 %type, %struct.rfkill_ops* %ops, i8* %ops_data) #0 {
entry:
  %tobool = icmp ne %struct.rfkill_ops* %ops, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 924)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %set_block = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %ops, i32 0, i32 2
  %0 = load i32 (i8*, i1)*, i32 (i8*, i1)** %set_block, align 8, !tbaa !42
  %tobool20 = icmp ne i32 (i8*, i1)* %0, null
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end18
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 927)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.end18
  %tobool38 = icmp ne i32 %lnot.ext26, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %tobool45 = icmp ne i64 %expval44, 0
  br i1 %tobool45, label %cleanup, label %if.end47

if.end47:                                         ; preds = %if.end36
  %tobool49 = icmp ne i8* %name, null
  %lnot50 = xor i1 %tobool49, true
  %lnot52 = xor i1 %lnot50, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %tobool56 = icmp ne i32 %lnot.ext55, 0
  %lnot57 = xor i1 %tobool56, true
  %lnot59 = xor i1 %lnot57, true
  %lnot.ext60 = zext i1 %lnot59 to i32
  %conv61 = sext i32 %lnot.ext60 to i64
  %expval62 = call i64 @llvm.expect.i64(i64 %conv61, i64 0)
  %tobool63 = icmp ne i64 %expval62, 0
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.end47
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 930)
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %if.end47
  %tobool67 = icmp ne i32 %lnot.ext55, 0
  %lnot68 = xor i1 %tobool67, true
  %lnot70 = xor i1 %lnot68, true
  %lnot.ext71 = zext i1 %lnot70 to i32
  %conv72 = sext i32 %lnot.ext71 to i64
  %expval73 = call i64 @llvm.expect.i64(i64 %conv72, i64 0)
  %tobool74 = icmp ne i64 %expval73, 0
  br i1 %tobool74, label %cleanup, label %if.end76

if.end76:                                         ; preds = %if.end65
  %cmp = icmp eq i32 %type, 0
  %cmp79 = icmp uge i32 %type, 9
  %.cmp79 = select i1 %cmp, i1 true, i1 %cmp79
  %lnot81 = xor i1 %.cmp79, true
  %lnot83 = xor i1 %lnot81, true
  %lnot.ext84 = zext i1 %lnot83 to i32
  %tobool85 = icmp ne i32 %lnot.ext84, 0
  %lnot86 = xor i1 %tobool85, true
  %lnot88 = xor i1 %lnot86, true
  %lnot.ext89 = zext i1 %lnot88 to i32
  %conv90 = sext i32 %lnot.ext89 to i64
  %expval91 = call i64 @llvm.expect.i64(i64 %conv90, i64 0)
  %tobool92 = icmp ne i64 %expval91, 0
  br i1 %tobool92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.end76
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 933)
  br label %if.end94

if.end94:                                         ; preds = %if.then93, %if.end76
  %tobool96 = icmp ne i32 %lnot.ext84, 0
  %lnot97 = xor i1 %tobool96, true
  %lnot99 = xor i1 %lnot97, true
  %lnot.ext100 = zext i1 %lnot99 to i32
  %conv101 = sext i32 %lnot.ext100 to i64
  %expval102 = call i64 @llvm.expect.i64(i64 %conv101, i64 0)
  %tobool103 = icmp ne i64 %expval102, 0
  br i1 %tobool103, label %cleanup, label %if.end105

if.end105:                                        ; preds = %if.end94
  %call = call i64 @strlen(i8* %name)
  %add = add i64 2040, %call
  %add106 = add i64 %add, 1
  %call107 = call i8* @kzalloc(i64 %add106, i32 20971712)
  %1 = bitcast i8* %call107 to %struct.rfkill*
  %tobool108 = icmp ne %struct.rfkill* %1, null
  br i1 %tobool108, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end105
  %lock113 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock113, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.1, i32 0, i32 0), %struct.lock_class_key* @rfkill_alloc.__key)
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 13
  call void @INIT_LIST_HEAD(%struct.list_head* %node)
  %type116 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 1
  store i32 %type, i32* %type116, align 8, !tbaa !14
  %name117 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 17
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %name117, i32 0, i32 0
  %call118 = call i8* @strcpy(i8* %arraydecay, i8* %name)
  %ops119 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 8
  store %struct.rfkill_ops* %ops, %struct.rfkill_ops** %ops119, align 8, !tbaa !3
  %data = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 9
  store i8* %ops_data, i8** %data, align 8, !tbaa !3
  %dev120 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 12
  %class = getelementptr inbounds %struct.device, %struct.device* %dev120, i32 0, i32 33
  store %struct.class* @rfkill_class, %struct.class** %class, align 8, !tbaa !66
  %parent121 = getelementptr inbounds %struct.device, %struct.device* %dev120, i32 0, i32 0
  store %struct.device* %parent, %struct.device** %parent121, align 8, !tbaa !67
  call void @device_initialize(%struct.device* %dev120)
  br label %cleanup

cleanup:                                          ; preds = %do.body, %if.end105, %if.end94, %if.end65, %if.end36, %if.end
  %retval.0 = phi %struct.rfkill* [ %1, %do.body ], [ null, %if.end ], [ null, %if.end36 ], [ null, %if.end65 ], [ null, %if.end94 ], [ null, %if.end105 ]
  ret %struct.rfkill* %retval.0
}

declare void @warn_slowpath_null(i8*, i32) #1

declare i64 @strlen(i8*) #1

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #1

declare i8* @strcpy(i8*, i8*) #1

declare void @device_initialize(%struct.device*) #1

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_dev_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -248
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %name = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 17
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %name, i32 0, i32 0
  %call = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i32 0, i32 0), i8* %arraydecay)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 1
  %2 = load i32, i32* %type, align 8, !tbaa !14
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [9 x i8*], [9 x i8*]* @rfkill_types, i64 0, i64 %idxprom
  %3 = load i8*, i8** %arrayidx, align 8, !tbaa !3
  %call1 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.31, i32 0, i32 0), i8* %3)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %do.body5

do.body5:                                         ; preds = %if.end
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  %call8 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %state11 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  %5 = load i64, i64* %state11, align 8, !tbaa !23
  %conv12 = trunc i64 %5 to i32
  %lock13 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock13, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call8) #7
  %conv14 = zext i32 %conv12 to i64
  %call15 = call zeroext i8 @user_state_from_blocked(i64 %conv14)
  %conv16 = zext i8 %call15 to i32
  %call17 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.32, i32 0, i32 0), i32 %conv16)
  br label %cleanup

cleanup:                                          ; preds = %do.body5, %if.end, %entry
  %retval.0 = phi i32 [ %call17, %do.body5 ], [ %call, %entry ], [ %call1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_release(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -248
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %2 = bitcast %struct.rfkill* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_suspend(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -248
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %suspended = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 7
  store i8 1, i8* %suspended, align 1, !tbaa !9
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 14
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %poll_work)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_resume(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -248
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %suspended = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 7
  store i8 0, i8* %suspended, align 1, !tbaa !9
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 5
  %2 = load i8, i8* %persistent, align 1, !tbaa !9, !range !28
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  %3 = load i64, i64* %state, align 8, !tbaa !23
  %and = and i64 %3, 2
  %tobool1 = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %frombool = zext i1 %lnot2 to i8
  %tobool3 = trunc i8 %frombool to i1
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %tobool3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 8
  %4 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %4, i32 0, i32 0
  %5 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !7
  %tobool4 = icmp ne void (%struct.rfkill*, i8*)* %5, null
  br i1 %tobool4, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end
  %polling_paused = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 6
  %6 = load i8, i8* %polling_paused, align 2, !tbaa !9, !range !28
  %tobool5 = trunc i8 %6 to i1
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %7 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_power_efficient_wq, align 8, !tbaa !3
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 14
  call void @queue_delayed_work(%struct.workqueue_struct* %7, %struct.delayed_work* %poll_work, i64 0)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %land.lhs.true, %if.end
  ret i32 0
}

declare void @kfree(i8*) #1

declare i32 @add_uevent_var(%struct.kobj_uevent_env*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal zeroext i8 @user_state_from_blocked(i64 %state) #0 {
entry:
  %and = and i64 %state, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %and1 = and i64 %state, 2
  %tobool2 = icmp ne i64 %and1, 0
  %. = select i1 %tobool2, i8 0, i8 1
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i8 [ 2, %entry ], [ %., %if.end ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @hard_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

declare i32 @sprintf(i8*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i64 @soft_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @soft_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %state = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -248
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %call = call zeroext i1 @capable(i32 12)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @kstrtoul(i8* %buf, i32 0, i64* %state)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end3:                                          ; preds = %if.end
  %2 = load i64, i64* %state, align 8, !tbaa !23
  %cmp = icmp ugt i64 %2, 1
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end3
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %3 = load i64, i64* %state, align 8, !tbaa !23
  %tobool7 = icmp ne i64 %3, 0
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %tobool7)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end3, %if.then2, %entry
  %retval.0 = phi i64 [ %conv, %if.then2 ], [ %count, %if.end6 ], [ -1, %entry ], [ -22, %if.end3 ]
  ret i64 %retval.0
}

declare zeroext i1 @capable(i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #3 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

declare i32 @kstrtoull(i8*, i32, i64*) #1

; Function Attrs: nounwind uwtable
define internal i64 @state_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -248
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  %2 = load i64, i64* %state, align 8, !tbaa !23
  %call = call zeroext i8 @user_state_from_blocked(i64 %2)
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv2 = sext i32 %3 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @state_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %state = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -248
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %call = call zeroext i1 @capable(i32 12)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @kstrtoul(i8* %buf, i32 0, i64* %state)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end3:                                          ; preds = %if.end
  %2 = load i64, i64* %state, align 8, !tbaa !23
  %cmp = icmp ne i64 %2, 0
  %3 = load i64, i64* %state, align 8
  %cmp5 = icmp ne i64 %3, 1
  %or.cond = and i1 %cmp, %cmp5
  br i1 %or.cond, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end3
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %4 = load i64, i64* %state, align 8, !tbaa !23
  %cmp9 = icmp eq i64 %4, 0
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %cmp9)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end3, %if.then2, %entry
  %retval.0 = phi i64 [ %conv, %if.then2 ], [ %count, %if.end8 ], [ -1, %entry ], [ -22, %if.end3 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @persistent_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv1 = sext i32 %0 to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @index_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @type_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @name_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_blocked(%struct.rfkill* %rfkill) #0 {
entry:
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %state5 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %1 = load i64, i64* %state5, align 8, !tbaa !23
  %conv6 = trunc i64 %1 to i32
  %lock7 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock7, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #7
  %conv8 = zext i32 %conv6 to i64
  %and = and i64 %conv8, 7
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot9 = xor i1 %lnot, true
  ret i1 %lnot9
}

; Function Attrs: nounwind uwtable
define void @rfkill_resume_polling(%struct.rfkill* %rfkill) #0 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 842, i64 12) #7, !srcloc !68
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %0 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %0, i32 0, i32 0
  %1 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !7
  %tobool10 = icmp ne void (%struct.rfkill*, i8*)* %1, null
  br i1 %tobool10, label %if.end12, label %return

if.end12:                                         ; preds = %do.end9
  %polling_paused = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 6
  store i8 0, i8* %polling_paused, align 2, !tbaa !9
  %suspended = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %2 = load i8, i8* %suspended, align 1, !tbaa !9, !range !28
  %tobool13 = trunc i8 %2 to i1
  br i1 %tobool13, label %return, label %if.end15

if.end15:                                         ; preds = %if.end12
  %3 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_power_efficient_wq, align 8, !tbaa !3
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  call void @queue_delayed_work(%struct.workqueue_struct* %3, %struct.delayed_work* %poll_work, i64 0)
  br label %return

return:                                           ; preds = %if.end15, %if.end12, %do.end9
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_pause_polling(%struct.rfkill* %rfkill) #0 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 830, i64 12) #7, !srcloc !69
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %0 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %0, i32 0, i32 0
  %1 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !7
  %tobool10 = icmp ne void (%struct.rfkill*, i8*)* %1, null
  br i1 %tobool10, label %if.end12, label %return

if.end12:                                         ; preds = %do.end9
  %polling_paused = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 6
  store i8 1, i8* %polling_paused, align 2, !tbaa !9
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %poll_work)
  br label %return

return:                                           ; preds = %if.end12, %do.end9
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rfkill_find_type(i8* %name) #0 {
entry:
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then, label %do.body1

if.then:                                          ; preds = %entry
  call void @__compiletime_assert_653()
  br label %do.body1

do.body1:                                         ; preds = %if.then, %entry
  %tobool5 = icmp ne i8* %name, null
  br i1 %tobool5, label %if.end7, label %cleanup

if.end7:                                          ; preds = %do.body1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %i.0 = phi i32 [ 1, %if.end7 ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 9
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x i8*], [9 x i8*]* @rfkill_types, i64 0, i64 %idxprom
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !3
  %call = call i32 @strcmp(i8* %name, i8* %0)
  %tobool9 = icmp ne i32 %call, 0
  br i1 %tobool9, label %for.inc, label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond, %do.body1
  %retval.0 = phi i32 [ 0, %do.body1 ], [ %i.0, %for.body ], [ 0, %for.cond ]
  ret i32 %retval.0
}

declare void @__compiletime_assert_653() #1

declare i32 @strcmp(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define void @rfkill_set_states(%struct.rfkill* %rfkill, i1 zeroext %sw, i1 zeroext %hw) #0 {
entry:
  %frombool = zext i1 %sw to i8
  %frombool1 = zext i1 %hw to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.body12

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 607, i64 12) #7, !srcloc !70
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.body12:                                        ; preds = %entry
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call14 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %1 = load i64, i64* %state, align 8, !tbaa !23
  %and = and i64 %1, 2
  %tobool19 = icmp ne i64 %and, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %frombool24 = zext i1 %lnot22 to i8
  %state25 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %2 = load i64, i64* %state25, align 8, !tbaa !23
  %and26 = and i64 %2, 1
  %tobool27 = icmp ne i64 %and26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %frombool32 = zext i1 %lnot30 to i8
  %tobool33 = trunc i8 %frombool to i1
  call void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool33)
  %tobool34 = trunc i8 %frombool1 to i1
  %state36 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %3 = load i64, i64* %state36, align 8, !tbaa !23
  %and38 = and i64 %3, -2
  %or = or i64 %3, 1
  %and38.sink = select i1 %tobool34, i64 %or, i64 %and38
  store i64 %and38.sink, i64* %state36, align 8, !tbaa !23
  %lock40 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock40, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call14) #7
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  %5 = load i8, i8* %registered, align 4, !tbaa !9, !range !28
  %tobool41 = trunc i8 %5 to i1
  br i1 %tobool41, label %if.else43, label %if.then42

if.then42:                                        ; preds = %do.body12
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  store i8 1, i8* %persistent, align 1, !tbaa !9
  br label %if.end59

if.else43:                                        ; preds = %do.body12
  %tobool44 = trunc i8 %frombool24 to i1
  %conv45 = zext i1 %tobool44 to i32
  %tobool46 = trunc i8 %frombool to i1
  %conv47 = zext i1 %tobool46 to i32
  %cmp48 = icmp ne i32 %conv45, %conv47
  br i1 %cmp48, label %if.then56, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else43
  %tobool50 = trunc i8 %frombool32 to i1
  %conv51 = zext i1 %tobool50 to i32
  %tobool52 = trunc i8 %frombool1 to i1
  %conv53 = zext i1 %tobool52 to i32
  %cmp54 = icmp ne i32 %conv51, %conv53
  br i1 %cmp54, label %if.then56, label %if.end58

if.then56:                                        ; preds = %lor.lhs.false, %if.else43
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  call void @schedule_work(%struct.work_struct* %uevent_work)
  br label %if.end58

if.end58:                                         ; preds = %if.then56, %lor.lhs.false
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  call void @rfkill_any_led_trigger_event()
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %if.then42
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #0 {
entry:
  %frombool = zext i1 %blocked to i8
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %0 = load i64, i64* %state, align 8, !tbaa !23
  %and = and i64 %0, 2147483648
  %tobool = icmp ne i64 %and, 0
  %. = select i1 %tobool, i32 4, i32 2
  %tobool1 = trunc i8 %frombool to i1
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %entry
  %conv = zext i32 %. to i64
  %state3 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %1 = load i64, i64* %state3, align 8, !tbaa !23
  %or = or i64 %1, %conv
  store i64 %or, i64* %state3, align 8, !tbaa !23
  br label %if.end7

if.else:                                          ; preds = %entry
  %neg = xor i32 %., -1
  %conv4 = zext i32 %neg to i64
  %state5 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %2 = load i64, i64* %state5, align 8, !tbaa !23
  %and6 = and i64 %2, %conv4
  store i64 %and6, i64* %state5, align 8, !tbaa !23
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_init_sw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #0 {
entry:
  %frombool = zext i1 %blocked to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.body10

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 592, i64 12) #7, !srcloc !71
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.body10:                                        ; preds = %entry
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  %0 = load i8, i8* %registered, align 4, !tbaa !9, !range !28
  %tobool11 = trunc i8 %0 to i1
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %do.body20, label %do.body30

do.body20:                                        ; preds = %do.body10
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 593, i64 12) #7, !srcloc !72
  br label %do.body21

do.body21:                                        ; preds = %do.body21, %do.body20
  br label %do.body21

do.body30:                                        ; preds = %do.body10
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  %call32 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %tobool37 = trunc i8 %frombool to i1
  call void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool37)
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  store i8 1, i8* %persistent, align 1, !tbaa !9
  %lock38 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock38, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call32) #7
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #0 {
entry:
  %frombool = zext i1 %blocked to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.body11

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 566, i64 12) #7, !srcloc !73
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.body11:                                        ; preds = %entry
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call13 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %1 = load i64, i64* %state, align 8, !tbaa !23
  %and = and i64 %1, 2
  %tobool18 = icmp ne i64 %and, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %frombool23 = zext i1 %lnot21 to i8
  %tobool24 = trunc i8 %frombool to i1
  call void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool24)
  %state25 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %2 = load i64, i64* %state25, align 8, !tbaa !23
  %and26 = and i64 %2, 1
  %tobool27 = icmp ne i64 %and26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %frombool32 = zext i1 %lnot30 to i8
  %tobool33 = trunc i8 %frombool to i1
  %tobool35 = trunc i8 %frombool32 to i1
  %3 = select i1 %tobool33, i1 true, i1 %tobool35
  %frombool37 = zext i1 %3 to i8
  %lock38 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock38, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call13) #7
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  %5 = load i8, i8* %registered, align 4, !tbaa !9, !range !28
  %tobool39 = trunc i8 %5 to i1
  br i1 %tobool39, label %if.end42, label %cleanup

if.end42:                                         ; preds = %do.body11
  %tobool43 = trunc i8 %frombool23 to i1
  %conv44 = zext i1 %tobool43 to i32
  %tobool45 = trunc i8 %frombool37 to i1
  %conv46 = zext i1 %tobool45 to i32
  %cmp47 = icmp ne i32 %conv44, %conv46
  br i1 %cmp47, label %land.lhs.true, label %if.end52

land.lhs.true:                                    ; preds = %if.end42
  %tobool49 = trunc i8 %frombool32 to i1
  br i1 %tobool49, label %if.end52, label %if.then50

if.then50:                                        ; preds = %land.lhs.true
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  call void @schedule_work(%struct.work_struct* %uevent_work)
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %land.lhs.true, %if.end42
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  call void @rfkill_any_led_trigger_event()
  br label %cleanup

cleanup:                                          ; preds = %if.end52, %do.body11
  %tobool53 = trunc i8 %frombool37 to i1
  ret i1 %tobool53
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_set_hw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #0 {
entry:
  %frombool = zext i1 %blocked to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.body11

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 526, i64 12) #7, !srcloc !74
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.body11:                                        ; preds = %entry
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call13 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %1 = load i64, i64* %state, align 8, !tbaa !23
  %and = and i64 %1, 1
  %tobool18 = icmp ne i64 %and, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %frombool23 = zext i1 %lnot21 to i8
  %tobool24 = trunc i8 %frombool to i1
  %state26 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %2 = load i64, i64* %state26, align 8, !tbaa !23
  %and28 = and i64 %2, -2
  %or = or i64 %2, 1
  %and28.sink = select i1 %tobool24, i64 %or, i64 %and28
  store i64 %and28.sink, i64* %state26, align 8, !tbaa !23
  %state30 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %3 = load i64, i64* %state30, align 8, !tbaa !23
  %and31 = and i64 %3, 7
  %tobool32 = icmp ne i64 %and31, 0
  %lnot33 = xor i1 %tobool32, true
  %lnot35 = xor i1 %lnot33, true
  %frombool37 = zext i1 %lnot35 to i8
  %lock38 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock38, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call13) #7
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  call void @rfkill_any_led_trigger_event()
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  %5 = load i8, i8* %registered, align 4, !tbaa !9, !range !28
  %tobool39 = trunc i8 %5 to i1
  br i1 %tobool39, label %land.lhs.true, label %if.end49

land.lhs.true:                                    ; preds = %do.body11
  %tobool41 = trunc i8 %frombool23 to i1
  %conv42 = zext i1 %tobool41 to i32
  %tobool43 = trunc i8 %frombool to i1
  %conv44 = zext i1 %tobool43 to i32
  %cmp45 = icmp ne i32 %conv42, %conv44
  br i1 %cmp45, label %if.then47, label %if.end49

if.then47:                                        ; preds = %land.lhs.true
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  call void @schedule_work(%struct.work_struct* %uevent_work)
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %land.lhs.true, %do.body11
  %tobool50 = trunc i8 %frombool37 to i1
  ret i1 %tobool50
}

; Function Attrs: nounwind uwtable
define void @rfkill_set_led_trigger_name(%struct.rfkill* %rfkill, i8* %name) #0 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 161, i64 12) #7, !srcloc !75
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ledtrigname = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  store i8* %name, i8** %ledtrigname, align 8, !tbaa !3
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @rfkill_get_led_trigger_name(%struct.rfkill* %rfkill) #0 {
entry:
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 10
  %name = getelementptr inbounds %struct.led_trigger, %struct.led_trigger* %led_trigger, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !3
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @rfkill_switch_all(i32 %type, i1 zeroext %blocked) #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %frombool = zext i1 %blocked to i8
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = load volatile i32, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @rfkill_input_disabled, i32 0, i32 0), align 4, !tbaa !17
  %1 = bitcast i8* %arraydecay.i to i32*
  store i32 %0, i32* %1, align 4, !tbaa !17
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %2 = load i32, i32* %__val.i, align 4, !tbaa !14
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %3 = load i8, i8* @rfkill_epo_lock_active, align 1, !tbaa !9, !range !28
  %tobool1 = trunc i8 %3 to i1
  br i1 %tobool1, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %tobool3 = trunc i8 %frombool to i1
  call void @__rfkill_switch_all(i32 %type, i1 zeroext %tobool3)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %return

return:                                           ; preds = %if.end4, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_epo() #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = load volatile i32, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @rfkill_input_disabled, i32 0, i32 0), align 4, !tbaa !17
  %1 = bitcast i8* %arraydecay.i to i32*
  store i32 %0, i32* %1, align 4, !tbaa !17
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %2 = load i32, i32* %__val.i, align 4, !tbaa !14
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  store i8 1, i8* @rfkill_epo_lock_active, align 1, !tbaa !9
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %next.sink = phi %struct.list_head** [ %next, %for.body ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %if.end ]
  %3 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !3
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %4, i64 -1672
  %5 = bitcast i8* %add.ptr4 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %5, i32 0, i32 13
  %cmp = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @rfkill_set_block(%struct.rfkill* %5, i1 zeroext true)
  %node2 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %5, i32 0, i32 13
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond5

for.cond5:                                        ; preds = %for.body7, %for.end
  %i.0 = phi i32 [ 0, %for.end ], [ %inc, %for.body7 ]
  %cmp6 = icmp slt i32 %i.0, 9
  br i1 %cmp6, label %for.body7, label %for.end15

for.body7:                                        ; preds = %for.cond5
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx, i32 0, i32 0
  %6 = load i8, i8* %cur, align 2, !tbaa !39, !range !28
  %tobool8 = trunc i8 %6 to i1
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom9
  %sav = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx10, i32 0, i32 1
  %frombool = zext i1 %tobool8 to i8
  store i8 %frombool, i8* %sav, align 1, !tbaa !76
  %idxprom11 = sext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom11
  %cur13 = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx12, i32 0, i32 0
  store i8 1, i8* %cur13, align 2, !tbaa !39
  %inc = add nsw i32 %i.0, 1
  br label %for.cond5

for.end15:                                        ; preds = %for.cond5
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end15, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_restore_states() #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = load volatile i32, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @rfkill_input_disabled, i32 0, i32 0), align 4, !tbaa !17
  %1 = bitcast i8* %arraydecay.i to i32*
  store i32 %0, i32* %1, align 4, !tbaa !17
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %2 = load i32, i32* %__val.i, align 4, !tbaa !14
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  store i8 0, i8* @rfkill_epo_lock_active, align 1, !tbaa !9
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom
  %sav = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx, i32 0, i32 1
  %3 = load i8, i8* %sav, align 1, !tbaa !76, !range !28
  %tobool1 = trunc i8 %3 to i1
  call void @__rfkill_switch_all(i32 %i.0, i1 zeroext %tobool1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_remove_epo_lock() #0 {
entry:
  %__u.i = alloca %struct.atomic_t, align 4
  %__c.i = bitcast %struct.atomic_t* %__u.i to [1 x i8]*
  %arraydecay.i = getelementptr inbounds [1 x i8], [1 x i8]* %__c.i, i32 0, i32 0
  %0 = load volatile i32, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @rfkill_input_disabled, i32 0, i32 0), align 4, !tbaa !17
  %1 = bitcast i8* %arraydecay.i to i32*
  store i32 %0, i32* %1, align 4, !tbaa !17
  %__val.i = bitcast %struct.atomic_t* %__u.i to i32*
  %2 = load i32, i32* %__val.i, align 4, !tbaa !14
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  store i8 0, i8* @rfkill_epo_lock_active, align 1, !tbaa !9
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_is_epo_lock_active() #0 {
entry:
  %0 = load i8, i8* @rfkill_epo_lock_active, align 1, !tbaa !9, !range !28
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_get_global_sw_state(i32 %type) #0 {
entry:
  %idxprom = zext i32 %type to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx, i32 0, i32 0
  %0 = load i8, i8* %cur, align 2, !tbaa !39, !range !28
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_init() #5 section ".init.text" {
entry:
  %0 = load i32, i32* @rfkill_default_state, align 4, !tbaa !17
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  br label %for.body.i

for.body.i:                                       ; preds = %for.cond.i
  %idxprom4.i = sext i32 %i.0.i to i64
  %arrayidx5.i = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom4.i
  %cur6.i = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx5.i, i32 0, i32 0
  %frombool7.i = zext i1 %lnot to i8
  store i8 %frombool7.i, i8* %cur6.i, align 2, !tbaa !39
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i
}

declare i32 @__class_register(%struct.class*, %struct.lock_class_key*) #1

declare i32 @misc_register(%struct.miscdevice*) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_any_led_trigger_register() #0 {
entry:
  %.compoundliteral = alloca %union.anon.3, align 8
  call void @__init_work(%struct.work_struct* @rfkill_any_work, i32 0)
  %counter = getelementptr inbounds %union.anon.3, %union.anon.3* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !29
  %0 = bitcast %union.anon.3* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast (%struct.work_struct* @rfkill_any_work to i8*), i8* %0, i64 8, i32 8, i1 false), !tbaa.struct !31
  call void @lockdep_init_map(%struct.lockdep_map* getelementptr inbounds (%struct.work_struct, %struct.work_struct* @rfkill_any_work, i32 0, i32 3), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.40, i32 0, i32 0), %struct.lock_class_key* @rfkill_any_led_trigger_register.__key, i32 0)
  call void @INIT_LIST_HEAD(%struct.list_head* getelementptr inbounds (%struct.work_struct, %struct.work_struct* @rfkill_any_work, i32 0, i32 1))
  store void (%struct.work_struct*)* @rfkill_any_led_trigger_worker, void (%struct.work_struct*)** getelementptr inbounds (%struct.work_struct, %struct.work_struct* @rfkill_any_work, i32 0, i32 2), align 8, !tbaa !32
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.41, i32 0, i32 0), i8** getelementptr inbounds (%struct.led_trigger, %struct.led_trigger* @rfkill_any_led_trigger, i32 0, i32 0), align 8, !tbaa !77
  store void (%struct.led_classdev*)* @rfkill_any_led_trigger_activate, void (%struct.led_classdev*)** getelementptr inbounds (%struct.led_trigger, %struct.led_trigger* @rfkill_any_led_trigger, i32 0, i32 1), align 8, !tbaa !81
  %call = call i32 @led_trigger_register(%struct.led_trigger* @rfkill_any_led_trigger)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_any_led_trigger_unregister() #0 {
entry:
  call void @led_trigger_unregister(%struct.led_trigger* @rfkill_any_led_trigger)
  %call = call zeroext i1 @cancel_work_sync(%struct.work_struct* @rfkill_any_work)
  ret void
}

declare void @misc_deregister(%struct.miscdevice*) #1

declare void @class_unregister(%struct.class*) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_any_led_trigger_worker(%struct.work_struct* %work) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !3
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %1, i64 -1672
  %2 = bitcast i8* %add.ptr4 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 13
  %cmp = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 2
  %3 = load i64, i64* %state, align 8, !tbaa !23
  %and = and i64 %3, 7
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.body
  %node2 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 13
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %brightness.0 = phi i32 [ 255, %for.body ], [ 0, %for.cond ]
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  call void @led_trigger_event(%struct.led_trigger* @rfkill_any_led_trigger, i32 %brightness.0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_any_led_trigger_activate(%struct.led_classdev* %led_cdev) #0 {
entry:
  call void @rfkill_any_led_trigger_event()
  ret void
}

declare i64 @no_llseek(%struct.file*, i64, i32) #1

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_fop_read(%struct.file* %file, i8* %buf, i64 %count, i64* %pos) #0 {
entry:
  %__wait = alloca %struct.__wait_queue, align 8
  %__UNIQUE_ID_min1_14 = alloca i64, align 8
  %__UNIQUE_ID_min2_15 = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !82
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx, i32 0)
  br label %while.cond

while.cond:                                       ; preds = %if.end26, %entry
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 6
  %2 = load i32, i32* %f_flags, align 8, !tbaa !87
  %and = and i32 %2, 2048
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %out, label %if.end

if.end:                                           ; preds = %while.body
  %mtx2 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx2)
  call void @__might_sleep(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 1177, i32 0)
  %events6 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %call7 = call i32 @list_empty(%struct.list_head* %events6)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then9, label %if.end21

if.then9:                                         ; preds = %if.end
  call void @init_wait_entry(%struct.__wait_queue* %__wait, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.then9
  %__ret10.0 = phi i64 [ 0, %if.then9 ], [ %__ret10.1, %cleanup.cont ]
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 3
  %call11 = call i64 @prepare_to_wait_event(%struct.__wait_queue_head* %read_wait, %struct.__wait_queue* %__wait, i32 1)
  %events12 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %call13 = call i32 @list_empty(%struct.list_head* %events12)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.end16, label %NodeBlock

if.end16:                                         ; preds = %for.cond
  %tobool17 = icmp ne i64 %call11, 0
  br i1 %tobool17, label %NodeBlock, label %if.end19

if.end19:                                         ; preds = %if.end16
  call void @schedule()
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end19, %if.end16, %for.cond
  %__ret10.1 = phi i64 [ %__ret10.0, %if.end19 ], [ %__ret10.0, %for.cond ], [ %call11, %if.end16 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end19 ], [ 9, %for.cond ], [ 11, %if.end16 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 11
  br i1 %Pivot, label %LeafBlock, label %__out

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 9
  br i1 %SwitchLeaf, label %for.end, label %cleanup.cont

cleanup.cont:                                     ; preds = %LeafBlock
  br label %for.cond

for.end:                                          ; preds = %LeafBlock
  %read_wait20 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 3
  call void @finish_wait(%struct.__wait_queue_head* %read_wait20, %struct.__wait_queue* %__wait)
  br label %__out

__out:                                            ; preds = %for.end, %NodeBlock
  %conv = trunc i64 %__ret10.1 to i32
  br label %if.end21

if.end21:                                         ; preds = %__out, %if.end
  %__ret.0 = phi i32 [ %conv, %__out ], [ 0, %if.end ]
  %mtx23 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx23, i32 0)
  %tobool24 = icmp ne i32 %__ret.0, 0
  br i1 %tobool24, label %out, label %if.end26

if.end26:                                         ; preds = %if.end21
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %events27 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %events27, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !13
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.rfkill_int_event*
  store i64 8, i64* %__UNIQUE_ID_min1_14, align 8, !tbaa !23
  store i64 %count, i64* %__UNIQUE_ID_min2_15, align 8, !tbaa !23
  %6 = load i64, i64* %__UNIQUE_ID_min1_14, align 8, !tbaa !23
  %7 = load i64, i64* %__UNIQUE_ID_min2_15, align 8, !tbaa !23
  %cmp31 = icmp ult i64 %6, %7
  %8 = load i64, i64* %__UNIQUE_ID_min1_14, align 8
  %9 = load i64, i64* %__UNIQUE_ID_min2_15, align 8
  %cond = select i1 %cmp31, i64 %8, i64 %9
  %conv33 = trunc i64 %cond to i32
  %ev34 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %5, i32 0, i32 1
  %10 = bitcast %struct.rfkill_event* %ev34 to i8*
  %11 = call i64 @llvm.objectsize.i64.p0i8(i8* %10, i1 false, i1 true) #7
  %conv.i = trunc i64 %11 to i32
  %conv1.i = trunc i64 %cond to i32
  call void @kasan_check_read(i8* %10, i32 %conv1.i) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.33, i32 0, i32 0), i32 718) #7
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, %cond
  %12 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %12 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #7
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %while.end
  call void @__check_object_size(i8* %10, i64 %cond, i1 zeroext true) #7
  %conv8.i = trunc i64 %cond to i32
  %call.i = call i64 @_copy_to_user(i8* %buf, i8* %10, i32 %conv8.i) #7
  br label %copy_to_user.exit

if.else.i:                                        ; preds = %while.end
  call void @copy_user_overflow(i32 %conv.i, i64 %cond) #7
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ %cond, %if.else.i ]
  %tobool36 = icmp ne i64 %n.addr.0.i, 0
  %.conv33 = select i1 %tobool36, i32 -14, i32 %conv33
  %list = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %5, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  %13 = bitcast %struct.rfkill_int_event* %5 to i8*
  call void @kfree(i8* %13)
  br label %out

out:                                              ; preds = %copy_to_user.exit, %if.end21, %while.body
  %ret.1 = phi i32 [ %.conv33, %copy_to_user.exit ], [ -11, %while.body ], [ %__ret.0, %if.end21 ]
  %mtx39 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx39)
  %conv40 = sext i32 %ret.1 to i64
  ret i64 %conv40
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_fop_write(%struct.file* %file, i8* %buf, i64 %count, i64* %pos) #0 {
entry:
  %ev = alloca %struct.rfkill_event, align 1
  %__UNIQUE_ID_min1_16 = alloca i64, align 8
  %__UNIQUE_ID_min2_17 = alloca i64, align 8
  %cmp = icmp ult i64 %count, 7
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  store i64 %count, i64* %__UNIQUE_ID_min1_16, align 8, !tbaa !23
  store i64 8, i64* %__UNIQUE_ID_min2_17, align 8, !tbaa !23
  %0 = load i64, i64* %__UNIQUE_ID_min1_16, align 8, !tbaa !23
  %1 = load i64, i64* %__UNIQUE_ID_min2_17, align 8, !tbaa !23
  %cmp2 = icmp ult i64 %0, %1
  %2 = load i64, i64* %__UNIQUE_ID_min1_16, align 8
  %3 = load i64, i64* %__UNIQUE_ID_min2_17, align 8
  %cond = select i1 %cmp2, i64 %2, i64 %3
  %4 = bitcast %struct.rfkill_event* %ev to i8*
  %5 = call i64 @llvm.objectsize.i64.p0i8(i8* %4, i1 false, i1 true) #7
  %conv.i = trunc i64 %5 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.33, i32 0, i32 0), i32 696) #7
  %conv1.i = trunc i64 %cond to i32
  call void @kasan_check_write(i8* %4, i32 %conv1.i) #7
  %cmp.i1 = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, %cond
  %6 = select i1 %cmp.i1, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %6 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #7
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i2, label %if.else.i

if.then.i2:                                       ; preds = %if.end
  call void @__check_object_size(i8* %4, i64 %cond, i1 zeroext false) #7
  %conv8.i = trunc i64 %cond to i32
  %call.i = call i64 @_copy_from_user(i8* %4, i8* %buf, i32 %conv8.i) #7
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %if.end
  call void @copy_user_overflow(i32 %conv.i, i64 %cond) #7
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i2
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i2 ], [ %cond, %if.else.i ]
  %tobool = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool, label %cleanup, label %if.end5

if.end5:                                          ; preds = %copy_from_user.exit
  %type = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %7 = load i8, i8* %type, align 1, !tbaa !21
  %conv6 = zext i8 %7 to i32
  %cmp7 = icmp sge i32 %conv6, 9
  br i1 %cmp7, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end5
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %op = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  %8 = load i8, i8* %op, align 1, !tbaa !22
  %conv11 = zext i8 %8 to i32
  %Pivot = icmp slt i32 %conv11, 3
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end10
  %SwitchLeaf2 = icmp eq i32 %conv11, 3
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.epilog

LeafBlock:                                        ; preds = %if.end10
  %SwitchLeaf = icmp eq i32 %conv11, 2
  br i1 %SwitchLeaf, label %sw.bb35, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock1
  %type12 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %9 = load i8, i8* %type12, align 1, !tbaa !21
  %conv13 = zext i8 %9 to i32
  %soft = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  %10 = load i8, i8* %soft, align 1, !tbaa !26
  %tobool14 = icmp ne i8 %10, 0
  %cmp.i = icmp ne i32 %conv13, 0
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %sw.bb
  %idxprom.i = zext i32 %conv13 to i64
  %arrayidx.i = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom.i
  %cur.i = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx.i, i32 0, i32 0
  %frombool1.i = zext i1 %tobool14 to i8
  store i8 %frombool1.i, i8* %cur.i, align 2, !tbaa !39
  br label %rfkill_update_global_state.exit

if.end.i:                                         ; preds = %sw.bb
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %if.end.i
  %i.0.i = phi i32 [ 0, %if.end.i ], [ %inc.i, %for.body.i ]
  %cmp2.i = icmp slt i32 %i.0.i, 9
  br i1 %cmp2.i, label %for.body.i, label %rfkill_update_global_state.exit

for.body.i:                                       ; preds = %for.cond.i
  %idxprom4.i = sext i32 %i.0.i to i64
  %arrayidx5.i = getelementptr inbounds [9 x %struct.anon.58], [9 x %struct.anon.58]* @rfkill_global_states, i64 0, i64 %idxprom4.i
  %cur6.i = getelementptr inbounds %struct.anon.58, %struct.anon.58* %arrayidx5.i, i32 0, i32 0
  %frombool7.i = zext i1 %tobool14 to i8
  store i8 %frombool7.i, i8* %cur6.i, align 2, !tbaa !39
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

rfkill_update_global_state.exit:                  ; preds = %for.cond.i, %if.then.i
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %rfkill_update_global_state.exit
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %rfkill_update_global_state.exit ]
  %11 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !3
  %12 = bitcast %struct.list_head* %11 to i8*
  %add.ptr34 = getelementptr inbounds i8, i8* %12, i64 -1672
  %13 = bitcast i8* %add.ptr34 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %13, i32 0, i32 13
  %cmp16 = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp16, label %for.body, label %sw.epilog

for.body:                                         ; preds = %for.cond
  %type18 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %13, i32 0, i32 1
  %14 = load i32, i32* %type18, align 8, !tbaa !14
  %type19 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %15 = load i8, i8* %type19, align 1, !tbaa !21
  %conv20 = zext i8 %15 to i32
  %cmp21 = icmp eq i32 %14, %conv20
  br i1 %cmp21, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %type23 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %16 = load i8, i8* %type23, align 1, !tbaa !21
  %conv24 = zext i8 %16 to i32
  %cmp25 = icmp eq i32 %conv24, 0
  br i1 %cmp25, label %if.then27, label %for.inc

if.then27:                                        ; preds = %lor.lhs.false, %for.body
  %soft28 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  %17 = load i8, i8* %soft28, align 1, !tbaa !26
  %tobool29 = icmp ne i8 %17, 0
  call void @rfkill_set_block(%struct.rfkill* %13, i1 zeroext %tobool29)
  br label %for.inc

for.inc:                                          ; preds = %if.then27, %lor.lhs.false
  %node32 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %13, i32 0, i32 13
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node32, i32 0, i32 0
  br label %for.cond

sw.bb35:                                          ; preds = %LeafBlock
  br label %for.cond39

for.cond39:                                       ; preds = %for.inc61, %sw.bb35
  %next64.sink = phi %struct.list_head** [ %next64, %for.inc61 ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %sw.bb35 ]
  %18 = load %struct.list_head*, %struct.list_head** %next64.sink, align 8, !tbaa !3
  %19 = bitcast %struct.list_head* %18 to i8*
  %add.ptr66 = getelementptr inbounds i8, i8* %19, i64 -1672
  %20 = bitcast i8* %add.ptr66 to %struct.rfkill*
  %node40 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 13
  %cmp41 = icmp ne %struct.list_head* %node40, @rfkill_list
  br i1 %cmp41, label %for.body43, label %sw.epilog

for.body43:                                       ; preds = %for.cond39
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 3
  %21 = load i32, i32* %idx, align 8, !tbaa !17
  %idx44 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 0
  %22 = load i32, i32* %idx44, align 1, !tbaa !19
  %cmp45 = icmp eq i32 %21, %22
  br i1 %cmp45, label %land.lhs.true, label %for.inc61

land.lhs.true:                                    ; preds = %for.body43
  %type47 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 1
  %23 = load i32, i32* %type47, align 8, !tbaa !14
  %type48 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %24 = load i8, i8* %type48, align 1, !tbaa !21
  %conv49 = zext i8 %24 to i32
  %cmp50 = icmp eq i32 %23, %conv49
  br i1 %cmp50, label %if.then57, label %lor.lhs.false52

lor.lhs.false52:                                  ; preds = %land.lhs.true
  %type53 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %25 = load i8, i8* %type53, align 1, !tbaa !21
  %conv54 = zext i8 %25 to i32
  %cmp55 = icmp eq i32 %conv54, 0
  br i1 %cmp55, label %if.then57, label %for.inc61

if.then57:                                        ; preds = %lor.lhs.false52, %land.lhs.true
  %soft58 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  %26 = load i8, i8* %soft58, align 1, !tbaa !26
  %tobool59 = icmp ne i8 %26, 0
  call void @rfkill_set_block(%struct.rfkill* %20, i1 zeroext %tobool59)
  br label %for.inc61

for.inc61:                                        ; preds = %if.then57, %lor.lhs.false52, %for.body43
  %node63 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 13
  %next64 = getelementptr inbounds %struct.list_head, %struct.list_head* %node63, i32 0, i32 0
  br label %for.cond39

sw.epilog:                                        ; preds = %for.cond39, %for.cond, %LeafBlock, %LeafBlock1
  %ret.0 = phi i32 [ 0, %for.cond ], [ 0, %for.cond39 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ]
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  %tobool68 = icmp ne i32 %ret.0, 0
  %conv70 = sext i32 %ret.0 to i64
  %cond73 = select i1 %tobool68, i64 %conv70, i64 %cond
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %if.end5, %copy_from_user.exit, %entry
  %retval.0 = phi i64 [ -22, %entry ], [ -14, %copy_from_user.exit ], [ -22, %if.end5 ], [ %cond73, %sw.epilog ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_fop_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !82
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 3
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* %read_wait, %struct.poll_table_struct* %wait)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx, i32 0)
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 260, i32 65
  %mtx1 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx1)
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_fop_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !82
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  %shr = lshr i32 %cmd, 8
  %and = and i32 %shr, 255
  %cmp = icmp ne i32 %and, 82
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %shr1 = lshr i32 %cmd, 0
  %and2 = and i32 %shr1, 255
  %cmp3 = icmp ne i32 %and2, 1
  br i1 %cmp3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx, i32 0)
  %input_handler = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 4
  %2 = load i8, i8* %input_handler, align 8, !tbaa !88, !range !28
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.end12, label %if.then6

if.then6:                                         ; preds = %if.end5
  %3 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @rfkill_input_disabled, i64 0, i32 0), i32 1, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @rfkill_input_disabled, i64 0, i32 0)) #7, !srcloc !90
  %add.i = add nsw i32 1, %3
  %cmp7 = icmp eq i32 %add.i, 1
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.then6
  %4 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.then6
  %input_handler11 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 4
  store i8 1, i8* %input_handler11, align 8, !tbaa !88
  br label %if.end12

if.end12:                                         ; preds = %if.end10, %if.end5
  %mtx13 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx13)
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.end, %entry
  %retval.0 = phi i64 [ 0, %if.end12 ], [ -38, %entry ], [ -38, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_fop_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i8* @kzalloc(i64 288, i32 20971712)
  %0 = bitcast i8* %call to %struct.rfkill_data*
  %tobool = icmp ne %struct.rfkill_data* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %events)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @__mutex_init(%struct.mutex* %mtx, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.36, i32 0, i32 0), %struct.lock_class_key* @rfkill_fop_open.__key)
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 3
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %read_wait, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.38, i32 0, i32 0), %struct.lock_class_key* @rfkill_fop_open.__key.37)
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %mtx4 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx4, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %if.end9, %if.end
  %next.sink = phi %struct.list_head** [ %next, %if.end9 ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %if.end ]
  %1 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !3
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr15 = getelementptr inbounds i8, i8* %2, i64 -1672
  %3 = bitcast i8* %add.ptr15 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %3, i32 0, i32 13
  %cmp = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call6 = call i8* @kzalloc(i64 24, i32 20971712)
  %4 = bitcast i8* %call6 to %struct.rfkill_int_event*
  %tobool7 = icmp ne %struct.rfkill_int_event* %4, null
  br i1 %tobool7, label %if.end9, label %free

if.end9:                                          ; preds = %for.body
  %ev10 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %4, i32 0, i32 1
  call void @rfkill_fill_event(%struct.rfkill_event* %ev10, %struct.rfkill* %3, i32 0)
  %list = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %4, i32 0, i32 0
  %events11 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %events11)
  %node13 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %3, i32 0, i32 13
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node13, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %list16 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 0
  call void @list_add(%struct.list_head* %list16, %struct.list_head* @rfkill_fds)
  %mtx17 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx17)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  %5 = bitcast %struct.rfkill_data* %0 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %5, i8** %private_data, align 8, !tbaa !82
  %call18 = call i32 @nonseekable_open(%struct.inode* %inode, %struct.file* %file)
  br label %cleanup

free:                                             ; preds = %for.body
  %mtx19 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx19)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  %mtx20 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_destroy(%struct.mutex* %mtx20)
  %events22 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  %next23 = getelementptr inbounds %struct.list_head, %struct.list_head* %events22, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next23, align 8, !tbaa !13
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr25 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr25 to %struct.rfkill_int_event*
  br label %for.cond31

for.cond31:                                       ; preds = %for.body35, %free
  %.sink = phi %struct.rfkill_int_event* [ %11, %for.body35 ], [ %8, %free ]
  %ev.0 = phi %struct.rfkill_int_event* [ %8, %free ], [ %11, %for.body35 ]
  %list38 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %.sink, i32 0, i32 0
  %next39 = getelementptr inbounds %struct.list_head, %struct.list_head* %list38, i32 0, i32 0
  %9 = load %struct.list_head*, %struct.list_head** %next39, align 8, !tbaa !91
  %10 = bitcast %struct.list_head* %9 to i8*
  %add.ptr41 = getelementptr inbounds i8, i8* %10, i64 0
  %11 = bitcast i8* %add.ptr41 to %struct.rfkill_int_event*
  %list32 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %ev.0, i32 0, i32 0
  %events33 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  %cmp34 = icmp ne %struct.list_head* %list32, %events33
  br i1 %cmp34, label %for.body35, label %for.end42

for.body35:                                       ; preds = %for.cond31
  %12 = bitcast %struct.rfkill_int_event* %ev.0 to i8*
  call void @kfree(i8* %12)
  br label %for.cond31

for.end42:                                        ; preds = %for.cond31
  %13 = bitcast %struct.rfkill_data* %0 to i8*
  call void @kfree(i8* %13)
  br label %cleanup

cleanup:                                          ; preds = %for.end42, %for.end, %entry
  %retval.0 = phi i32 [ -12, %for.end42 ], [ %call18, %for.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_fop_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !82
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %list = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_destroy(%struct.mutex* %mtx)
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %events, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !13
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.rfkill_int_event*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.rfkill_int_event* [ %7, %for.body ], [ %4, %entry ]
  %ev.0 = phi %struct.rfkill_int_event* [ %4, %entry ], [ %7, %for.body ]
  %list10 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %.sink, i32 0, i32 0
  %next11 = getelementptr inbounds %struct.list_head, %struct.list_head* %list10, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next11, align 8, !tbaa !91
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %6, i64 0
  %7 = bitcast i8* %add.ptr13 to %struct.rfkill_int_event*
  %list7 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %ev.0, i32 0, i32 0
  %events8 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %list7, %events8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = bitcast %struct.rfkill_int_event* %ev.0 to i8*
  call void @kfree(i8* %8)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %input_handler = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 4
  %9 = load i8, i8* %input_handler, align 8, !tbaa !88, !range !28
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then, label %if.end17

if.then:                                          ; preds = %for.end
  %10 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @rfkill_input_disabled, i64 0, i32 0), i32 -1, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @rfkill_input_disabled, i64 0, i32 0)) #7, !srcloc !90
  %add.i = add nsw i32 -1, %10
  %cmp14 = icmp eq i32 %add.i, 0
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.then
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.then, %for.end
  %12 = bitcast %struct.rfkill_data* %1 to i8*
  call void @kfree(i8* %12)
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del(%struct.list_head* %entry1) #3 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !13
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !11
  ret void
}

declare void @mutex_destroy(%struct.mutex*) #1

declare i32 @printk(i8*, ...) #1

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #1

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !13
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

declare i32 @nonseekable_open(%struct.inode*, %struct.file*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #3 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !93
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !93
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #3 {
entry:
  %__u = alloca %union.anon.60, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.60* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  %1 = bitcast i8* %0 to i64*
  %2 = load volatile i64, i64* %1, align 8, !tbaa !15
  %3 = bitcast i8* %arraydecay to i64*
  store i64 %2, i64* %3, align 8, !tbaa !15
  %__val = bitcast %union.anon.60* %__u to %struct.list_head**
  %4 = load %struct.list_head*, %struct.list_head** %__val, align 8, !tbaa !14
  %cmp = icmp eq %struct.list_head* %4, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #6

declare void @__might_fault(i8*, i32) #1

declare void @kasan_check_write(i8*, i32) #1

declare i64 @_copy_from_user(i8*, i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @copy_user_overflow(i32 %size, i64 %count) #3 {
entry:
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.33, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.34, i32 0, i32 0), i32 %size, i64 %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #1

declare void @__check_object_size(i8*, i64, i1 zeroext) #1

declare void @__might_sleep(i8*, i32, i32) #1

declare void @init_wait_entry(%struct.__wait_queue*, i32) #1

declare i64 @prepare_to_wait_event(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #1

declare void @schedule() #1

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

declare void @kasan_check_read(i8*, i32) #1

declare i64 @_copy_to_user(i8*, i8*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_exit() #5 section ".exit.text" {
entry:
  call void @rfkill_handler_exit()
  call void @rfkill_any_led_trigger_unregister()
  call void @misc_deregister(%struct.miscdevice* @rfkill_miscdev)
  call void @class_unregister(%struct.class* @rfkill_class)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rfkill_handler_init() #5 section ".init.text" {
entry:
  %0 = load i32, i32* @rfkill_master_switch_mode, align 4, !tbaa !14
  %Pivot4 = icmp slt i32 %0, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %0, 2
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %0, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %return

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %0, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %return

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %NodeBlock
  %.sink = phi i32 [ 1, %NodeBlock ], [ 2, %LeafBlock ], [ 3, %LeafBlock1 ]
  store i32 %.sink, i32* @rfkill_master_switch_op, align 4, !tbaa !14
  call void @__raw_spin_lock_init(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), %struct.lock_class_key* @rfkill_handler_init.__key)
  %1 = load volatile i64, i64* @jiffies, align 8, !tbaa !23
  %call.i = call i64 @__msecs_to_jiffies(i32 200) #7
  %sub = sub i64 %1, %call.i
  %sub6 = sub i64 %sub, 1
  store i64 %sub6, i64* @rfkill_last_scheduled, align 8, !tbaa !23
  %call7 = call i32 @input_register_handler(%struct.input_handler* @rfkill_handler)
  br label %return

return:                                           ; preds = %sw.epilog, %LeafBlock, %LeafBlock1
  %retval.0 = phi i32 [ %call7, %sw.epilog ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ]
  ret i32 %retval.0
}

declare i32 @input_register_handler(%struct.input_handler*) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_event.7(%struct.input_handle* %handle, i32 %type, i32 %code, i32 %data) #0 {
entry:
  %cmp = icmp eq i32 %type, 1
  %cmp1 = icmp eq i32 %data, 1
  %or.cond = and i1 %cmp, %cmp1
  br i1 %or.cond, label %NodeBlock9, label %if.else

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %code, 239
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %code, 246
  br i1 %Pivot8, label %LeafBlock1, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %code, 247
  br i1 %Pivot6, label %sw.bb4, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %code, 247
  br i1 %SwitchLeaf4, label %sw.bb5, label %if.end10

LeafBlock1:                                       ; preds = %NodeBlock7
  %SwitchLeaf2 = icmp eq i32 %code, 239
  br i1 %SwitchLeaf2, label %sw.bb3, label %if.end10

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %code, 238
  br i1 %Pivot, label %LeafBlock, label %sw.bb

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %code, 237
  br i1 %SwitchLeaf, label %sw.bb2, label %if.end10

sw.bb:                                            ; preds = %NodeBlock
  call void @rfkill_schedule_toggle(i32 1)
  br label %if.end10

sw.bb2:                                           ; preds = %LeafBlock
  call void @rfkill_schedule_toggle(i32 2)
  br label %if.end10

sw.bb3:                                           ; preds = %LeafBlock1
  call void @rfkill_schedule_toggle(i32 3)
  br label %if.end10

sw.bb4:                                           ; preds = %NodeBlock5
  call void @rfkill_schedule_toggle(i32 4)
  br label %if.end10

sw.bb5:                                           ; preds = %LeafBlock3
  call void @rfkill_schedule_toggle(i32 0)
  br label %if.end10

if.else:                                          ; preds = %entry
  %cmp6 = icmp eq i32 %type, 5
  %cmp8 = icmp eq i32 %code, 3
  %or.cond11 = and i1 %cmp6, %cmp8
  br i1 %or.cond11, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.else
  call void @rfkill_schedule_evsw_rfkillall(i32 %data)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.else, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_connect(%struct.input_handler* %handler, %struct.input_dev* %dev, %struct.input_device_id* %id) #0 {
entry:
  %call = call i8* @kzalloc.14(i64 72, i32 20971712)
  %0 = bitcast i8* %call to %struct.input_handle*
  %tobool = icmp ne %struct.input_handle* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev1 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %0, i32 0, i32 3
  store %struct.input_dev* %dev, %struct.input_dev** %dev1, align 8, !tbaa !95
  %handler2 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %0, i32 0, i32 4
  store %struct.input_handler* %handler, %struct.input_handler** %handler2, align 8, !tbaa !97
  %name = getelementptr inbounds %struct.input_handle, %struct.input_handle* %0, i32 0, i32 2
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1.8, i32 0, i32 0), i8** %name, align 8, !tbaa !98
  %call3 = call i32 @input_register_handle(%struct.input_handle* %0)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %err_free_handle, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @input_open_device(%struct.input_handle* %0)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %err_unregister_handle, label %cleanup

err_unregister_handle:                            ; preds = %if.end6
  call void @input_unregister_handle(%struct.input_handle* %0)
  br label %err_free_handle

err_free_handle:                                  ; preds = %err_unregister_handle, %if.end
  %error.0 = phi i32 [ %call7, %err_unregister_handle ], [ %call3, %if.end ]
  %1 = bitcast %struct.input_handle* %0 to i8*
  call void @kfree(i8* %1)
  br label %cleanup

cleanup:                                          ; preds = %err_free_handle, %if.end6, %entry
  %retval.0 = phi i32 [ %error.0, %err_free_handle ], [ -12, %entry ], [ 0, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_disconnect(%struct.input_handle* %handle) #0 {
entry:
  call void @input_close_device(%struct.input_handle* %handle)
  call void @input_unregister_handle(%struct.input_handle* %handle)
  %0 = bitcast %struct.input_handle* %handle to i8*
  call void @kfree(i8* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_start(%struct.input_handle* %handle) #0 {
entry:
  %dev = getelementptr inbounds %struct.input_handle, %struct.input_handle* %handle, i32 0, i32 3
  %0 = load %struct.input_dev*, %struct.input_dev** %dev, align 8, !tbaa !95
  %event_lock = getelementptr inbounds %struct.input_dev, %struct.input_dev* %0, i32 0, i32 35
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %event_lock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %1 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i) #7
  %dev1 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %handle, i32 0, i32 3
  %2 = load %struct.input_dev*, %struct.input_dev** %dev1, align 8, !tbaa !95
  %evbit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %2, i32 0, i32 5
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %evbit, i32 0, i32 0
  %3 = load volatile i64, i64* %arraydecay, align 8, !tbaa !23
  %and1.i3 = and i64 32, %3
  %cmp.i4 = icmp ne i64 %and1.i3, 0
  br i1 %cmp.i4, label %cond.true6, label %if.end

cond.true6:                                       ; preds = %entry
  %dev7 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %handle, i32 0, i32 3
  %4 = load %struct.input_dev*, %struct.input_dev** %dev7, align 8, !tbaa !95
  %swbit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %4, i32 0, i32 13
  %arraydecay8 = getelementptr inbounds [1 x i64], [1 x i64]* %swbit, i32 0, i32 0
  %5 = load volatile i64, i64* %arraydecay8, align 8, !tbaa !23
  %and1.i1 = and i64 8, %5
  %cmp.i2 = icmp ne i64 %and1.i1, 0
  br i1 %cmp.i2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.true6
  %dev15 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %handle, i32 0, i32 3
  %6 = load %struct.input_dev*, %struct.input_dev** %dev15, align 8, !tbaa !95
  %sw = getelementptr inbounds %struct.input_dev, %struct.input_dev* %6, i32 0, i32 29
  %arraydecay16 = getelementptr inbounds [1 x i64], [1 x i64]* %sw, i32 0, i32 0
  %7 = load volatile i64, i64* %arraydecay16, align 8, !tbaa !23
  %and1.i = and i64 8, %7
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv = zext i1 %cmp.i to i32
  call void @rfkill_schedule_evsw_rfkillall(i32 %conv)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.true6, %entry
  %dev18 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %handle, i32 0, i32 3
  %8 = load %struct.input_dev*, %struct.input_dev** %dev18, align 8, !tbaa !95
  %event_lock19 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %8, i32 0, i32 35
  %9 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %event_lock19, i32 0, i32 0
  %rlock.i5 = bitcast %union.anon.1* %9 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i5) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_schedule_evsw_rfkillall(i32 %state) #0 {
entry:
  %tobool = icmp ne i32 %state, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = load i32, i32* @rfkill_master_switch_op, align 4, !tbaa !14
  call void @rfkill_schedule_global_op(i32 %0)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @rfkill_schedule_global_op(i32 0)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @rfkill_schedule_global_op(i32 %op) #0 {
entry:
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0))
  store i32 %op, i32* @rfkill_op, align 4, !tbaa !14
  store i8 1, i8* @rfkill_op_pending, align 1, !tbaa !9
  %cmp5 = icmp eq i32 %op, 0
  br i1 %cmp5, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %call7 = call zeroext i1 @rfkill_is_epo_lock_active()
  br i1 %call7, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !3
  call void @mod_delayed_work(%struct.workqueue_struct* %0, %struct.delayed_work* @rfkill_op_work, i64 0)
  %1 = load volatile i64, i64* @jiffies, align 8, !tbaa !23
  store i64 %1, i64* @rfkill_last_scheduled, align 8, !tbaa !23
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  call void @rfkill_schedule_ratelimited()
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0), i64 %call2) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @mod_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %call = call zeroext i1 @mod_delayed_work_on(i32 8192, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_schedule_ratelimited() #0 {
entry:
  %0 = load i64, i64* @rfkill_last_scheduled, align 8, !tbaa !23
  %call = call i64 @rfkill_ratelimit(i64 %0)
  %call1 = call zeroext i1 @schedule_delayed_work(%struct.delayed_work* @rfkill_op_work, i64 %call)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load volatile i64, i64* @jiffies, align 8, !tbaa !23
  store i64 %1, i64* @rfkill_last_scheduled, align 8, !tbaa !23
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_ratelimit(i64 %last) #0 {
entry:
  %call.i = call i64 @__msecs_to_jiffies(i32 200) #7
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %add = add i64 %last, %call.i
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !23
  %sub = sub i64 %add, %0
  %cmp8 = icmp slt i64 %sub, 0
  br i1 %cmp8, label %cond.end, label %cond.false

cond.false:                                       ; preds = %land.lhs.true, %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %land.lhs.true
  %cond = phi i64 [ %call.i, %cond.false ], [ 0, %land.lhs.true ]
  ret i64 %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @schedule_delayed_work(%struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !3
  %call = call zeroext i1 @queue_delayed_work.10(%struct.workqueue_struct* %0, %struct.delayed_work* %dwork, i64 %delay)
  ret i1 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @queue_delayed_work.10(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 8192, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret i1 %call
}

declare zeroext i1 @mod_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_op_handler(%struct.work_struct* %work) #0 {
entry:
  %oldbit.i1 = alloca i8, align 1
  %oldbit.i = alloca i8, align 1
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0)) #7
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %0 = load i8, i8* @rfkill_op_pending, align 1, !tbaa !9, !range !28
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %do.body
  %1 = load i32, i32* @rfkill_op, align 4, !tbaa !14
  store i8 0, i8* @rfkill_op_pending, align 1, !tbaa !9
  %call = call i8* @__memset(i8* bitcast ([1 x i64]* @rfkill_sw_pending to i8*), i32 0, i64 8)
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0)) #7
  call void @__rfkill_handle_global_op(i32 %1)
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0)) #7
  %2 = load i8, i8* @rfkill_op_pending, align 1, !tbaa !9, !range !28
  %tobool1 = trunc i8 %2 to i1
  %. = select i1 %tobool1, i32 3, i32 0
  %SwitchLeaf = icmp eq i32 %., 3
  br i1 %SwitchLeaf, label %do.cond, label %if.end3

if.end3:                                          ; preds = %if.then, %do.body
  %call4 = call zeroext i1 @rfkill_is_epo_lock_active()
  br i1 %call4, label %do.cond, label %if.end6

if.end6:                                          ; preds = %if.end3
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %i.0 = phi i32 [ 0, %if.end6 ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 9
  br i1 %cmp, label %for.body, label %do.cond

for.body:                                         ; preds = %for.cond
  %conv = zext i32 %i.0 to i64
  call void asm sideeffect "btr $2,$1\0A\09\0A\09setc $0\0A", "=*qm,=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i1, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_pending, i32 0, i32 0), i64 %conv, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_pending, i32 0, i32 0)) #7, !srcloc !99
  %3 = load i8, i8* %oldbit.i1, align 1, !tbaa !9, !range !28
  %tobool.i2 = trunc i8 %3 to i1
  br i1 %tobool.i2, label %if.then8, label %for.inc

if.then8:                                         ; preds = %for.body
  %conv9 = zext i32 %i.0 to i64
  call void asm sideeffect "btr $2,$1\0A\09\0A\09setc $0\0A", "=*qm,=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_state, i32 0, i32 0), i64 %conv9, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_state, i32 0, i32 0)) #7, !srcloc !99
  %4 = load i8, i8* %oldbit.i, align 1, !tbaa !9, !range !28
  %tobool.i = trunc i8 %4 to i1
  %frombool = zext i1 %tobool.i to i8
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0)) #7
  %tobool11 = trunc i8 %frombool to i1
  call void @__rfkill_handle_normal_op(i32 %i.0, i1 zeroext %tobool11)
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0)) #7
  br label %for.inc

for.inc:                                          ; preds = %if.then8, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

do.cond:                                          ; preds = %for.cond, %if.end3, %if.then
  %5 = load i8, i8* @rfkill_op_pending, align 1, !tbaa !9, !range !28
  %tobool13 = trunc i8 %5 to i1
  br i1 %tobool13, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0)) #7
  ret void
}

declare i8* @__memset(i8*, i32, i64) #1

; Function Attrs: nounwind uwtable
define internal void @__rfkill_handle_global_op(i32 %op) #0 {
entry:
  %Pivot6 = icmp slt i32 %op, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %op, 3
  br i1 %Pivot4, label %sw.bb2, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %op, 3
  br i1 %SwitchLeaf2, label %sw.bb3, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %op, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb1

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %op, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  call void @rfkill_epo()
  br label %sw.epilog

sw.bb1:                                           ; preds = %NodeBlock
  call void @rfkill_restore_states()
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock3
  call void @rfkill_remove_epo_lock()
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  call void @rfkill_remove_epo_lock()
  br label %for.cond

for.cond:                                         ; preds = %for.body, %sw.bb3
  %i.0 = phi i32 [ 0, %sw.bb3 ], [ %inc, %for.body ]
  %cmp = icmp ult i32 %i.0, 9
  br i1 %cmp, label %for.body, label %sw.epilog

for.body:                                         ; preds = %for.cond
  call void @rfkill_switch_all(i32 %i.0, i1 zeroext false)
  %inc = add i32 %i.0, 1
  br label %for.cond

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  call void @rfkill_epo()
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %sw.default
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.4, i32 0, i32 0), i32 81, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.5.13, i32 0, i32 0), i32 %op)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.default
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end, %for.cond, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rfkill_handle_normal_op(i32 %type, i1 zeroext %complement) #0 {
entry:
  %frombool = zext i1 %complement to i8
  %call = call zeroext i1 @rfkill_get_global_sw_state(i32 %type)
  %frombool1 = zext i1 %call to i8
  %tobool = trunc i8 %frombool to i1
  %tobool2 = trunc i8 %frombool1 to i1
  %lnot = xor i1 %tobool2, true
  %frombool3 = zext i1 %lnot to i8
  %blocked.0 = select i1 %tobool, i8 %frombool3, i8 %frombool1
  %tobool4 = trunc i8 %blocked.0 to i1
  call void @rfkill_switch_all(i32 %type, i1 zeroext %tobool4)
  ret void
}

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @input_close_device(%struct.input_handle*) #1

declare void @input_unregister_handle(%struct.input_handle*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.14(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #7
  ret i8* %call.i
}

declare i32 @input_register_handle(%struct.input_handle*) #1

declare i32 @input_open_device(%struct.input_handle*) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_schedule_toggle(i32 %type) #0 {
entry:
  %call = call zeroext i1 @rfkill_is_epo_lock_active()
  br i1 %call, label %cleanup.cont, label %do.body1

do.body1:                                         ; preds = %entry
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0))
  %0 = load i8, i8* @rfkill_op_pending, align 1, !tbaa !9, !range !28
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end9, label %if.then6

if.then6:                                         ; preds = %do.body1
  %conv7 = zext i32 %type to i64
  call void asm sideeffect "bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_pending, i32 0, i32 0), i64 %conv7, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_pending, i32 0, i32 0)) #7, !srcloc !100
  %conv8 = zext i32 %type to i64
  call void asm sideeffect "btc $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_state, i32 0, i32 0), i64 %conv8, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_state, i32 0, i32 0)) #7, !srcloc !101
  call void @rfkill_schedule_ratelimited()
  br label %if.end9

if.end9:                                          ; preds = %if.then6, %do.body1
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0), i64 %call3) #7
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end9, %entry
  ret void
}

declare i64 @__msecs_to_jiffies(i32) #1

; Function Attrs: nounwind uwtable
define void @rfkill_handler_exit() #5 section ".exit.text" {
entry:
  call void @input_unregister_handler(%struct.input_handler* @rfkill_handler)
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* @rfkill_op_work)
  ret void
}

declare void @input_unregister_handler(%struct.input_handler*) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readnone }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind }
attributes #5 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind }

!llvm.ident = !{!0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 -2143641855, i32 -2143641830, i32 -2143641560, i32 -2143641763, i32 -2143641732, i32 -2143641702}
!3 = !{!4, !4, i64 0}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!8, !4, i64 0}
!8 = !{!"rfkill_ops", !4, i64 0, !4, i64 8, !4, i64 16}
!9 = !{!10, !10, i64 0}
!10 = !{!"_Bool", !5, i64 0}
!11 = !{!12, !4, i64 8}
!12 = !{!"list_head", !4, i64 0, !4, i64 8}
!13 = !{!12, !4, i64 0}
!14 = !{!5, !5, i64 0}
!15 = !{!16, !16, i64 0}
!16 = !{!"long long", !5, i64 0}
!17 = !{!18, !18, i64 0}
!18 = !{!"int", !5, i64 0}
!19 = !{!20, !18, i64 0}
!20 = !{!"rfkill_event", !18, i64 0, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7}
!21 = !{!20, !5, i64 4}
!22 = !{!20, !5, i64 5}
!23 = !{!24, !24, i64 0}
!24 = !{!"long", !5, i64 0}
!25 = !{!20, !5, i64 7}
!26 = !{!20, !5, i64 6}
!27 = !{i32 -2143646659, i32 -2143646634, i32 -2143646364, i32 -2143646567, i32 -2143646536, i32 -2143646506}
!28 = !{i8 0, i8 2}
!29 = !{!30, !24, i64 0}
!30 = !{!"", !24, i64 0}
!31 = !{i64 0, i64 8, !23}
!32 = !{!33, !4, i64 24}
!33 = !{!"work_struct", !30, i64 0, !12, i64 8, !4, i64 24, !34, i64 32}
!34 = !{!"lockdep_map", !4, i64 0, !5, i64 8, !4, i64 24, !18, i64 32, !24, i64 40}
!35 = !{!36, !4, i64 24}
!36 = !{!"timer_list", !37, i64 0, !24, i64 16, !4, i64 24, !24, i64 32, !18, i64 40, !34, i64 48}
!37 = !{!"hlist_node", !4, i64 0, !4, i64 8}
!38 = !{!36, !24, i64 32}
!39 = !{!40, !10, i64 0}
!40 = !{!"", !10, i64 0, !10, i64 1}
!41 = !{!8, !4, i64 8}
!42 = !{!8, !4, i64 16}
!43 = !{!44, !4, i64 280}
!44 = !{!"device", !4, i64 0, !4, i64 8, !45, i64 16, !4, i64 280, !4, i64 288, !50, i64 296, !4, i64 456, !4, i64 464, !4, i64 472, !4, i64 480, !53, i64 488, !54, i64 528, !4, i64 1104, !4, i64 1112, !4, i64 1120, !12, i64 1128, !18, i64 1144, !4, i64 1152, !4, i64 1160, !16, i64 1168, !24, i64 1176, !4, i64 1184, !12, i64 1192, !4, i64 1208, !4, i64 1216, !58, i64 1224, !4, i64 1232, !4, i64 1240, !18, i64 1248, !18, i64 1252, !51, i64 1256, !12, i64 1328, !59, i64 1344, !4, i64 1376, !4, i64 1384, !4, i64 1392, !4, i64 1400, !4, i64 1408, !10, i64 1416, !10, i64 1416}
!45 = !{!"kobject", !4, i64 0, !12, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !46, i64 56, !49, i64 64, !18, i64 256, !18, i64 256, !18, i64 256, !18, i64 256, !18, i64 256}
!46 = !{!"kref", !47, i64 0}
!47 = !{!"refcount_struct", !48, i64 0}
!48 = !{!"", !18, i64 0}
!49 = !{!"delayed_work", !33, i64 0, !36, i64 80, !4, i64 176, !18, i64 184}
!50 = !{!"mutex", !30, i64 0, !51, i64 8, !52, i64 80, !12, i64 88, !4, i64 104, !34, i64 112}
!51 = !{!"spinlock", !5, i64 0}
!52 = !{!"optimistic_spin_queue", !48, i64 0}
!53 = !{!"dev_links_info", !12, i64 0, !12, i64 16, !5, i64 32}
!54 = !{!"dev_pm_info", !55, i64 0, !18, i64 4, !18, i64 4, !10, i64 4, !10, i64 4, !10, i64 4, !10, i64 4, !10, i64 4, !10, i64 4, !10, i64 5, !51, i64 8, !12, i64 80, !56, i64 96, !4, i64 192, !10, i64 200, !10, i64 200, !10, i64 200, !36, i64 208, !24, i64 304, !33, i64 312, !57, i64 392, !4, i64 480, !48, i64 488, !48, i64 492, !18, i64 496, !18, i64 496, !18, i64 496, !18, i64 496, !18, i64 496, !18, i64 496, !10, i64 497, !18, i64 497, !18, i64 497, !18, i64 497, !18, i64 497, !18, i64 497, !18, i64 500, !5, i64 504, !5, i64 508, !18, i64 512, !18, i64 516, !24, i64 520, !24, i64 528, !24, i64 536, !24, i64 544, !4, i64 552, !4, i64 560, !4, i64 568}
!55 = !{!"pm_message", !18, i64 0}
!56 = !{!"completion", !18, i64 0, !57, i64 8}
!57 = !{!"__wait_queue_head", !51, i64 0, !12, i64 72}
!58 = !{!"dev_archdata", !4, i64 0}
!59 = !{!"klist_node", !4, i64 0, !12, i64 8, !46, i64 24}
!60 = !{!61, !4, i64 480}
!61 = !{!"led_classdev", !4, i64 0, !5, i64 8, !5, i64 12, !18, i64 16, !24, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !12, i64 80, !4, i64 96, !24, i64 104, !24, i64 112, !36, i64 120, !18, i64 216, !18, i64 220, !4, i64 224, !33, i64 232, !18, i64 312, !62, i64 320, !4, i64 480, !12, i64 488, !4, i64 504, !10, i64 512, !18, i64 516, !4, i64 520, !50, i64 528}
!62 = !{!"rw_semaphore", !30, i64 0, !12, i64 8, !63, i64 24, !52, i64 96, !4, i64 104, !34, i64 112}
!63 = !{!"raw_spinlock", !64, i64 0, !18, i64 4, !18, i64 8, !4, i64 16, !34, i64 24}
!64 = !{!"qspinlock", !48, i64 0}
!65 = !{!45, !4, i64 0}
!66 = !{!44, !4, i64 1376}
!67 = !{!44, !4, i64 0}
!68 = !{i32 -2143659212, i32 -2143659187, i32 -2143658917, i32 -2143659120, i32 -2143659089, i32 -2143659059}
!69 = !{i32 -2143661010, i32 -2143660985, i32 -2143660715, i32 -2143660918, i32 -2143660887, i32 -2143660857}
!70 = !{i32 -2143676640, i32 -2143676615, i32 -2143676345, i32 -2143676548, i32 -2143676517, i32 -2143676487}
!71 = !{i32 -2143679307, i32 -2143679282, i32 -2143679012, i32 -2143679215, i32 -2143679184, i32 -2143679154}
!72 = !{i32 -2143678796, i32 -2143678771, i32 -2143678501, i32 -2143678704, i32 -2143678673, i32 -2143678643}
!73 = !{i32 -2143681485, i32 -2143681460, i32 -2143681190, i32 -2143681393, i32 -2143681362, i32 -2143681332}
!74 = !{i32 -2143683897, i32 -2143683872, i32 -2143683602, i32 -2143683805, i32 -2143683774, i32 -2143683744}
!75 = !{i32 -2143693387, i32 -2143693362, i32 -2143693092, i32 -2143693295, i32 -2143693264, i32 -2143693234}
!76 = !{!40, !10, i64 1}
!77 = !{!78, !4, i64 0}
!78 = !{!"led_trigger", !4, i64 0, !4, i64 8, !4, i64 16, !79, i64 24, !12, i64 96, !12, i64 112}
!79 = !{!"", !80, i64 0, !18, i64 8, !18, i64 12, !4, i64 16, !34, i64 24}
!80 = !{!"qrwlock", !48, i64 0, !64, i64 4}
!81 = !{!78, !4, i64 8}
!82 = !{!83, !4, i64 456}
!83 = !{!"file", !5, i64 0, !84, i64 16, !4, i64 32, !4, i64 40, !51, i64 48, !30, i64 120, !18, i64 128, !18, i64 132, !50, i64 136, !16, i64 296, !85, i64 304, !4, i64 400, !86, i64 408, !16, i64 440, !4, i64 448, !4, i64 456, !12, i64 464, !12, i64 480, !4, i64 496}
!84 = !{!"path", !4, i64 0, !4, i64 8}
!85 = !{!"fown_struct", !79, i64 0, !4, i64 72, !5, i64 80, !48, i64 84, !48, i64 88, !18, i64 92}
!86 = !{!"file_ra_state", !24, i64 0, !18, i64 8, !18, i64 12, !18, i64 16, !18, i64 20, !16, i64 24}
!87 = !{!83, !18, i64 128}
!88 = !{!89, !10, i64 280}
!89 = !{!"rfkill_data", !12, i64 0, !12, i64 16, !50, i64 32, !57, i64 192, !10, i64 280}
!90 = !{i32 -2146324835, i32 -2146324796, i32 -2146324775, i32 -2146324738, i32 -2146324715, i32 -2146324706}
!91 = !{!92, !4, i64 0}
!92 = !{!"rfkill_int_event", !12, i64 0, !20, i64 16}
!93 = !{!94, !4, i64 0}
!94 = !{!"poll_table_struct", !4, i64 0, !24, i64 8}
!95 = !{!96, !4, i64 24}
!96 = !{!"input_handle", !4, i64 0, !18, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !12, i64 40, !12, i64 56}
!97 = !{!96, !4, i64 32}
!98 = !{!96, !4, i64 16}
!99 = !{i32 559445, i32 559457, i32 -2146884026}
!100 = !{i32 553873}
!101 = !{i32 556452}
