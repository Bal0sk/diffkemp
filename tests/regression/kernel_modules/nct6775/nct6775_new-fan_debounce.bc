; ModuleID = 'tests/regression/kernel_modules/nct6775/nct6775_new-fan_debounce.bc'
source_filename = "drivers/hwmon/nct6775.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.49, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.5, i32 }
%union.anon.5 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.32, %union.anon.33, %union.anon.37, %union.anon.41, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%union.anon.32 = type { i64 }
%union.anon.33 = type { i64 }
%union.anon.37 = type { %struct.list_head }
%union.anon.41 = type { i64 }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct*, %struct.lockdep_map }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.7, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon.7 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.12 }
%union.anon.12 = type { %struct.anon.16, [80 x i8] }
%struct.anon.16 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.22, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.22 = type { %struct.anon.23 }
%struct.anon.23 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.anon.29 }
%struct.anon.29 = type { i64, i64 }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.49 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.42, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.43, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.kgid_t = type { i32 }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.42 = type { i32 }
%struct.timespec = type { i64, i64 }
%struct.bdi_writeback = type opaque
%union.anon.43 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%union.anon.0 = type { %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type opaque
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.53, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.53 = type { i64 }
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, i64, %struct.atomic64_t, %struct.key*, %struct.key*, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.vm_operations_struct = type opaque
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head, i8*, %struct.lockdep_map }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.51 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.platform_driver = type { i32 (%struct.platform_device*)*, i32 (%struct.platform_device*)*, void (%struct.platform_device*)*, i32 (%struct.platform_device*, i32)*, i32 (%struct.platform_device*)*, %struct.device_driver, %struct.platform_device_id*, i8 }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, i8*, %struct.mfd_cell*, %struct.pdev_archdata }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type opaque
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type opaque
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.resource = type { i64, i64, i8*, i64, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.mfd_cell = type opaque
%struct.pdev_archdata = type {}
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.sensor_template_group = type { %struct.sensor_device_template**, i16 (%struct.kobject*, %struct.attribute*, i32)*, i32 }
%struct.sensor_device_template = type { %struct.device_attribute, %union.anon.58, i8 }
%union.anon.58 = type { i32 }
%struct.pv_cpu_ops = type { i64 (i32)*, void (i32, i64)*, i64 ()*, void (i64)*, i64 ()*, void (i64)*, i64 ()*, void (i64)*, void ()*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (i8*, i32)*, i64 ()*, void (%struct.thread_struct*, i32)*, void (i32)*, void (%struct.desc_struct*, i32, i8*)*, void (%struct.desc_struct*, i32, i8*, i32)*, void (%struct.gate_struct64*, i32, %struct.gate_struct64*)*, void (%struct.desc_struct*, i32)*, void (%struct.desc_struct*, i32)*, void (%struct.tss_struct*, %struct.thread_struct*)*, void (i32)*, void ()*, void ()*, void (i32*, i32*, i32*, i32*)*, i64 (i32)*, void (i32, i32, i32)*, i64 (i32, i32*)*, i32 (i32, i32, i32)*, i64 (i32)*, void ()*, void ()*, void ()*, void (%struct.task_struct*)*, void (%struct.task_struct*)* }
%struct.desc_ptr = type <{ i16, i64 }>
%struct.gate_struct64 = type { i16, i16, i16, i16, i32, i32 }
%struct.tss_struct = type { %struct.x86_hw_tss, [1025 x i64], [16 x i8] }
%struct.x86_hw_tss = type <{ i32, i64, i64, i64, i64, [7 x i64], i32, i32, i16, i16 }>
%struct.anon.59 = type { i8, i8 }
%struct.sensor_device_attribute = type { %struct.device_attribute, i32 }
%struct.nct6775_sio_data = type { i32, i32 }
%struct._ddebug = type { i8*, i8*, i8*, i8*, i32 }
%struct.nct6775_data = type { i32, i32, i32, i8*, [6 x %struct.attribute_group*], [5 x [10 x i16]], [10 x i8], [10 x i16], i8**, i32, i16, i16, i16, i8, i8*, i8*, i16*, [2 x i16*], i16*, i16*, i16*, i16*, i16*, i16*, [3 x i16*], i16*, i8*, i8*, [7 x i16*], i16*, i16*, i8, i16*, i16*, i16*, i16*, i16*, i16*, i16*, i16*, [3 x i16*], i16*, i16*, i16*, i32 (i16, i32)*, i32 (i16, i32)*, %struct.mutex, i8, i64, i8, i8, [15 x [3 x i8]], [6 x i32], [6 x i16], [6 x i8], [6 x i8], i8, i8, i8, i8, i8, i8, i8, [6 x i8], [6 x i8], [5 x [10 x i16]], i64, i64, i8, [6 x i8], [6 x i32], [7 x [6 x i8]], [6 x i8], i8, [6 x i32], [6 x i32], i8, [2 x [6 x i8]], i8, [3 x [6 x i8]], i32, [6 x [7 x i8]], [6 x [7 x i8]], [6 x i8], [6 x i8], [3 x [6 x i8]], i8, i8, i8, i16, i16, i16, i8, i8, i8, i8 }
%struct.sensor_device_attr_u = type { %union.anon.60, [32 x i8] }
%union.anon.60 = type { %struct.sensor_device_attribute }
%struct.sensor_device_attribute_2 = type { %struct.device_attribute, i8, i8 }

@__param_str_force_id = internal constant [9 x i8] c"force_id\00", align 1
@__this_module = external global %struct.module, align 64
@param_ops_ushort = external constant %struct.kernel_param_ops, align 8
@force_id = internal global i16 0, align 2
@__param_force_id = internal constant %struct.kernel_param { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_force_id, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_ushort, i16 0, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i16* @force_id to i8*) } }, section "__param", align 8
@__UNIQUE_ID_force_idtype12 = internal constant [25 x i8] c"parmtype=force_id:ushort\00", section ".modinfo", align 1
@__UNIQUE_ID_force_id13 = internal constant [46 x i8] c"parm=force_id:Override the detected device ID\00", section ".modinfo", align 1
@__param_str_fan_debounce = internal constant [13 x i8] c"fan_debounce\00", align 1
@fan_debounce = internal global i16 0, align 2
@__param_fan_debounce = internal constant %struct.kernel_param { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__param_str_fan_debounce, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_ushort, i16 0, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i16* @fan_debounce to i8*) } }, section "__param", align 8
@__UNIQUE_ID_fan_debouncetype14 = internal constant [29 x i8] c"parmtype=fan_debounce:ushort\00", section ".modinfo", align 1
@__UNIQUE_ID_fan_debounce15 = internal constant [55 x i8] c"parm=fan_debounce:Enable debouncing for fan RPM signal\00", section ".modinfo", align 1
@__UNIQUE_ID_author52 = internal constant [42 x i8] c"author=Guenter Roeck <linux@roeck-us.net>\00", section ".modinfo", align 1
@__UNIQUE_ID_description53 = internal constant [53 x i8] c"description=Driver for NCT6775F and compatible chips\00", section ".modinfo", align 1
@__UNIQUE_ID_license54 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@sensors_nct6775_init.sioaddr = private unnamed_addr constant [2 x i32] [i32 46, i32 78], align 4
@nct6775_driver = internal global %struct.platform_driver { i32 (%struct.platform_device*)* @nct6775_probe, i32 (%struct.platform_device*)* null, void (%struct.platform_device*)* null, i32 (%struct.platform_device*, i32)* null, i32 (%struct.platform_device*)* null, %struct.device_driver { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), %struct.bus_type* null, %struct.module* null, i8* null, i8 0, i32 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* @nct6775_dev_pm_ops, %struct.driver_private* null }, %struct.platform_device_id* null, i8 0 }, align 8
@.str = private unnamed_addr constant [8 x i8] c"nct6775\00", align 1
@pdev = internal global [2 x %struct.platform_device*] zeroinitializer, align 16
@nct6775_dev_pm_ops = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* @nct6775_suspend, i32 (%struct.device*)* @nct6775_resume, i32 (%struct.device*)* @nct6775_suspend, i32 (%struct.device*)* @nct6775_resume, i32 (%struct.device*)* @nct6775_suspend, i32 (%struct.device*)* @nct6775_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null }, align 8
@ioport_resource = external global %struct.resource, align 8
@nct6775_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.1 = private unnamed_addr constant [19 x i8] c"&data->update_lock\00", align 1
@nct6775_device_names = internal constant [7 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.9, i32 0, i32 0)], align 16
@nct6776_temp_label = internal constant [23 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.21, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.28, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.29, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.30, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.31, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.32, i32 0, i32 0)], align 16
@NCT6106_REG_IN = internal constant [9 x i16] [i16 0, i16 1, i16 2, i16 3, i16 4, i16 5, i16 7, i16 8, i16 9], align 16
@NCT6106_REG_IN_MIN = internal constant [9 x i16] [i16 145, i16 147, i16 149, i16 151, i16 153, i16 155, i16 159, i16 161, i16 163], align 16
@NCT6106_REG_IN_MAX = internal constant [9 x i16] [i16 144, i16 146, i16 148, i16 150, i16 152, i16 154, i16 158, i16 160, i16 162], align 16
@NCT6106_REG_TARGET = internal constant [3 x i16] [i16 273, i16 289, i16 305], align 2
@NCT6106_REG_FAN = internal constant [3 x i16] [i16 32, i16 34, i16 36], align 2
@NCT6106_REG_FAN_MODE = internal constant [3 x i16] [i16 275, i16 291, i16 307], align 2
@NCT6106_REG_FAN_MIN = internal constant [3 x i16] [i16 224, i16 226, i16 228], align 2
@NCT6106_REG_FAN_PULSES = internal constant [5 x i16] [i16 246, i16 246, i16 246, i16 0, i16 0], align 2
@NCT6106_FAN_PULSE_SHIFT = internal constant [5 x i16] [i16 0, i16 2, i16 4, i16 0, i16 0], align 2
@NCT6106_REG_FAN_STOP_TIME = internal constant [3 x i16] [i16 280, i16 296, i16 312], align 2
@NCT6106_REG_FAN_STEP_UP_TIME = internal constant [3 x i16] [i16 276, i16 292, i16 308], align 2
@NCT6106_REG_FAN_STEP_DOWN_TIME = internal constant [3 x i16] [i16 277, i16 293, i16 309], align 2
@NCT6106_REG_PWM = internal constant [3 x i16] [i16 281, i16 297, i16 313], align 2
@NCT6106_REG_FAN_START_OUTPUT = internal constant [3 x i16] [i16 279, i16 295, i16 311], align 2
@NCT6106_REG_FAN_STOP_OUTPUT = internal constant [3 x i16] [i16 278, i16 294, i16 310], align 2
@NCT6106_REG_WEIGHT_DUTY_STEP = internal constant [3 x i16] [i16 363, i16 379, i16 380], align 2
@NCT6106_REG_WEIGHT_DUTY_BASE = internal constant [3 x i16] [i16 365, i16 381, i16 397], align 2
@NCT6106_REG_PWM_READ = internal constant [3 x i16] [i16 74, i16 75, i16 76], align 2
@NCT6106_REG_PWM_MODE = internal constant [3 x i8] c"\F3\F3\F3", align 1
@NCT6106_PWM_MODE_MASK = internal constant [3 x i8] c"\01\02\04", align 1
@NCT6106_REG_AUTO_TEMP = internal constant [3 x i16] [i16 352, i16 368, i16 384], align 2
@NCT6106_REG_AUTO_PWM = internal constant [3 x i16] [i16 356, i16 372, i16 388], align 2
@NCT6106_REG_CRITICAL_TEMP = internal constant [3 x i16] [i16 282, i16 298, i16 314], align 2
@NCT6106_REG_CRITICAL_TEMP_TOLERANCE = internal constant [3 x i16] [i16 283, i16 299, i16 315], align 2
@NCT6106_REG_CRITICAL_PWM_ENABLE = internal constant [3 x i16] [i16 284, i16 300, i16 316], align 2
@NCT6106_REG_CRITICAL_PWM = internal constant [3 x i16] [i16 285, i16 301, i16 317], align 2
@NCT6106_REG_TEMP_OFFSET = internal constant [3 x i16] [i16 785, i16 786, i16 787], align 2
@NCT6106_REG_TEMP_SOURCE = internal constant [6 x i16] [i16 176, i16 177, i16 178, i16 179, i16 180, i16 181], align 2
@NCT6106_REG_TEMP_SEL = internal constant [3 x i16] [i16 272, i16 288, i16 304], align 2
@NCT6106_REG_WEIGHT_TEMP_SEL = internal constant [3 x i16] [i16 360, i16 376, i16 392], align 2
@NCT6106_REG_WEIGHT_TEMP_STEP = internal constant [3 x i16] [i16 361, i16 377, i16 393], align 2
@NCT6106_REG_WEIGHT_TEMP_STEP_TOL = internal constant [3 x i16] [i16 362, i16 378, i16 394], align 2
@NCT6106_REG_WEIGHT_TEMP_BASE = internal constant [3 x i16] [i16 364, i16 380, i16 396], align 2
@NCT6106_REG_ALARM = internal constant [7 x i16] [i16 119, i16 120, i16 121, i16 122, i16 123, i16 124, i16 125], align 2
@NCT6106_ALARM_BITS = internal constant [32 x i8] c"\00\01\02\03\04\05\07\08\09\FF\FF\FF\FF\FF\FF\FF !\22\FF\FF\FF\FF\FF\10\11\12\13\14\150\FF", align 16
@NCT6106_REG_BEEP = internal constant [5 x i16] [i16 960, i16 961, i16 962, i16 963, i16 964], align 2
@NCT6106_BEEP_BITS = internal constant [32 x i8] c"\00\01\02\03\04\05\07\08\09\0A\0B\0C\FF\FF\FF \18\19\1A\1B\1C\FF\FF\FF\10\11\12\13\14\15\22\FF", align 16
@NCT6106_REG_TEMP = internal constant [6 x i16] [i16 16, i16 17, i16 18, i16 19, i16 20, i16 21], align 2
@NCT6106_REG_TEMP_MON = internal constant [3 x i16] [i16 24, i16 25, i16 26], align 2
@NCT6106_REG_TEMP_OVER = internal constant [6 x i16] [i16 194, i16 198, i16 202, i16 206, i16 210, i16 214], align 2
@NCT6106_REG_TEMP_HYST = internal constant [6 x i16] [i16 195, i16 199, i16 203, i16 207, i16 211, i16 215], align 2
@NCT6106_REG_TEMP_CONFIG = internal constant [6 x i16] [i16 183, i16 184, i16 185, i16 186, i16 187, i16 188], align 2
@NCT6106_REG_TEMP_ALTERNATE = internal constant [22 x i16] [i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 81, i16 82, i16 84, i16 0, i16 0, i16 0, i16 0, i16 0], align 16
@NCT6106_REG_TEMP_CRIT = internal constant [22 x i16] [i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 516, i16 517, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0], align 16
@NCT6106_REG_TEMP_CRIT_L = internal constant [6 x i16] [i16 192, i16 196, i16 200, i16 204, i16 208, i16 212], align 2
@NCT6106_REG_TEMP_CRIT_H = internal constant [6 x i16] [i16 193, i16 197, i16 201, i16 207, i16 209, i16 213], align 2
@NCT6775_ALARM_BITS = internal constant [32 x i8] c"\00\01\02\03\08\15\14\10\11\FF\FF\FF\FF\FF\FF\FF\06\07\0B\FF\FF\FF\FF\FF\04\05\0D\FF\FF\FF\0C\FF", align 16
@NCT6775_BEEP_BITS = internal constant [32 x i8] c"\00\01\02\03\08\09\0A\10\11\FF\FF\FF\FF\FF\FF\15\06\07\0B\1C\FF\FF\FF\FF\04\05\0D\FF\FF\FF\0C\FF", align 16
@nct6775_temp_label = internal constant [21 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.33, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.34, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.36, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.37, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.38, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.39, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.28, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.29, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.30, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.31, i32 0, i32 0)], align 16
@NCT6775_REG_IN = internal constant [10 x i16] [i16 32, i16 33, i16 34, i16 35, i16 36, i16 37, i16 38, i16 1360, i16 1361, i16 1362], align 16
@NCT6775_REG_IN_MIN = internal constant [15 x i16] [i16 44, i16 46, i16 48, i16 50, i16 52, i16 54, i16 56, i16 1365, i16 1367, i16 1369, i16 1371, i16 1373, i16 1375, i16 1377, i16 1379], align 16
@NCT6775_REG_IN_MAX = internal constant [15 x i16] [i16 43, i16 45, i16 47, i16 49, i16 51, i16 53, i16 55, i16 1364, i16 1366, i16 1368, i16 1370, i16 1372, i16 1374, i16 1376, i16 1378], align 16
@NCT6775_REG_TARGET = internal constant [6 x i16] [i16 257, i16 513, i16 769, i16 2049, i16 2305, i16 2561], align 2
@NCT6775_REG_FAN = internal constant [5 x i16] [i16 1584, i16 1586, i16 1588, i16 1590, i16 1592], align 2
@NCT6775_REG_FAN_MODE = internal constant [6 x i16] [i16 258, i16 514, i16 770, i16 2050, i16 2306, i16 2562], align 2
@NCT6775_REG_FAN_MIN = internal constant [3 x i16] [i16 59, i16 60, i16 61], align 2
@NCT6775_REG_FAN_PULSES = internal constant [5 x i16] [i16 1601, i16 1602, i16 1603, i16 1604, i16 0], align 2
@NCT6775_FAN_PULSE_SHIFT = internal constant [6 x i16] zeroinitializer, align 2
@NCT6775_REG_FAN_STOP_TIME = internal constant [6 x i16] [i16 263, i16 519, i16 775, i16 2055, i16 2311, i16 2567], align 2
@NCT6775_REG_FAN_STEP_UP_TIME = internal constant [6 x i16] [i16 260, i16 516, i16 772, i16 2052, i16 2308, i16 2564], align 2
@NCT6775_REG_FAN_STEP_DOWN_TIME = internal constant [6 x i16] [i16 259, i16 515, i16 771, i16 2051, i16 2307, i16 2563], align 2
@NCT6775_REG_PWM = internal constant [6 x i16] [i16 265, i16 521, i16 777, i16 2057, i16 2313, i16 2569], align 2
@NCT6775_REG_FAN_START_OUTPUT = internal constant [6 x i16] [i16 262, i16 518, i16 774, i16 2054, i16 2310, i16 2566], align 2
@NCT6775_REG_FAN_STOP_OUTPUT = internal constant [6 x i16] [i16 261, i16 517, i16 773, i16 2053, i16 2309, i16 2565], align 2
@NCT6775_REG_FAN_MAX_OUTPUT = internal constant [3 x i16] [i16 266, i16 522, i16 778], align 2
@NCT6775_REG_FAN_STEP_OUTPUT = internal constant [3 x i16] [i16 267, i16 523, i16 779], align 2
@NCT6775_REG_WEIGHT_DUTY_STEP = internal constant [6 x i16] [i16 316, i16 572, i16 828, i16 2108, i16 2364, i16 2620], align 2
@NCT6775_REG_PWM_READ = internal constant [6 x i16] [i16 1, i16 3, i16 17, i16 19, i16 21, i16 2569], align 2
@NCT6775_REG_PWM_MODE = internal constant [3 x i8] c"\04\04\12", align 1
@NCT6775_PWM_MODE_MASK = internal constant [3 x i8] c"\01\02\01", align 1
@NCT6775_REG_AUTO_TEMP = internal constant [6 x i16] [i16 289, i16 545, i16 801, i16 2081, i16 2337, i16 2593], align 2
@NCT6775_REG_AUTO_PWM = internal constant [6 x i16] [i16 295, i16 551, i16 807, i16 2087, i16 2343, i16 2599], align 2
@NCT6775_REG_CRITICAL_TEMP = internal constant [6 x i16] [i16 309, i16 565, i16 821, i16 2101, i16 2357, i16 2613], align 2
@NCT6775_REG_CRITICAL_TEMP_TOLERANCE = internal constant [6 x i16] [i16 312, i16 568, i16 824, i16 2104, i16 2360, i16 2616], align 2
@NCT6775_REG_TEMP_OFFSET = internal constant [3 x i16] [i16 1108, i16 1109, i16 1110], align 2
@NCT6775_REG_TEMP_SOURCE = internal constant [6 x i16] [i16 1569, i16 1570, i16 1571, i16 1572, i16 1573, i16 1574], align 2
@NCT6775_REG_TEMP_SEL = internal constant [6 x i16] [i16 256, i16 512, i16 768, i16 2048, i16 2304, i16 2560], align 2
@NCT6775_REG_WEIGHT_TEMP_SEL = internal constant [6 x i16] [i16 313, i16 569, i16 825, i16 2105, i16 2361, i16 2617], align 2
@NCT6775_REG_WEIGHT_TEMP_STEP = internal constant [6 x i16] [i16 314, i16 570, i16 826, i16 2106, i16 2362, i16 2618], align 2
@NCT6775_REG_WEIGHT_TEMP_STEP_TOL = internal constant [6 x i16] [i16 315, i16 571, i16 827, i16 2107, i16 2363, i16 2619], align 2
@NCT6775_REG_WEIGHT_TEMP_BASE = internal constant [6 x i16] [i16 317, i16 573, i16 829, i16 2109, i16 2365, i16 2621], align 2
@NCT6775_REG_ALARM = internal constant [7 x i16] [i16 1113, i16 1114, i16 1115, i16 0, i16 0, i16 0, i16 0], align 2
@NCT6775_REG_BEEP = internal constant [5 x i16] [i16 86, i16 87, i16 1107, i16 78, i16 0], align 2
@NCT6775_REG_TEMP = internal constant [6 x i16] [i16 39, i16 336, i16 592, i16 1579, i16 1580, i16 1581], align 2
@NCT6775_REG_TEMP_MON = internal constant [3 x i16] [i16 115, i16 117, i16 119], align 2
@NCT6775_REG_TEMP_OVER = internal constant [6 x i16] [i16 57, i16 341, i16 597, i16 1650, i16 1655, i16 1660], align 2
@NCT6775_REG_TEMP_HYST = internal constant [6 x i16] [i16 58, i16 339, i16 595, i16 1651, i16 1656, i16 1661], align 2
@NCT6775_REG_TEMP_CONFIG = internal constant [6 x i16] [i16 0, i16 338, i16 594, i16 1576, i16 1577, i16 1578], align 2
@NCT6775_REG_TEMP_ALTERNATE = internal constant [20 x i16] [i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 1633, i16 1634, i16 1636, i16 0, i16 0, i16 0, i16 0], align 16
@NCT6775_REG_TEMP_CRIT = internal constant [20 x i16] [i16 0, i16 0, i16 0, i16 0, i16 2560, i16 2561, i16 2562, i16 2563, i16 2564, i16 2565, i16 2566, i16 2567, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0], align 16
@NCT6776_ALARM_BITS = internal constant [32 x i8] c"\00\01\02\03\08\15\14\10\11\FF\FF\FF\FF\FF\FF\FF\06\07\0B\0A\17\FF\FF\FF\04\05\0D\FF\FF\FF\0C\09", align 16
@NCT6776_BEEP_BITS = internal constant [32 x i8] c"\00\01\02\03\04\05\06\07\08\FF\FF\FF\FF\FF\FF\18\19\1A\1B\1C\1D\FF\FF\FF\10\11\12\13\14\15\1E\1F", align 16
@NCT6776_REG_FAN_MIN = internal constant [5 x i16] [i16 1594, i16 1596, i16 1598, i16 1600, i16 1602], align 2
@NCT6776_REG_FAN_PULSES = internal constant [5 x i16] [i16 1604, i16 1605, i16 1606, i16 0, i16 0], align 2
@NCT6776_REG_TOLERANCE_H = internal constant [6 x i16] [i16 268, i16 524, i16 780, i16 2060, i16 2316, i16 2572], align 2
@NCT6776_REG_WEIGHT_DUTY_BASE = internal constant [6 x i16] [i16 318, i16 574, i16 830, i16 2110, i16 2366, i16 2622], align 2
@NCT6776_REG_PWM_MODE = internal constant [6 x i8] c"\04\00\00\00\00\00", align 1
@NCT6776_PWM_MODE_MASK = internal constant [6 x i8] c"\01\00\00\00\00\00", align 1
@NCT6776_REG_BEEP = internal constant [5 x i16] [i16 178, i16 179, i16 180, i16 181, i16 0], align 2
@NCT6776_REG_TEMP_CONFIG = internal constant [6 x i16] [i16 24, i16 338, i16 594, i16 1576, i16 1577, i16 1578], align 2
@NCT6776_REG_TEMP_ALTERNATE = internal constant [22 x i16] [i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 1025, i16 1026, i16 1028, i16 0, i16 0, i16 0, i16 0, i16 0], align 16
@NCT6776_REG_TEMP_CRIT = internal constant [22 x i16] [i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 1801, i16 1802, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0], align 16
@NCT6779_ALARM_BITS = internal constant [32 x i8] c"\00\01\02\03\08\15\14\10\11\18\19\1A\1B\1C\1D\FF\06\07\0B\0A\17\FF\FF\FF\04\05\0D\FF\FF\FF\0C\09", align 16
@NCT6779_BEEP_BITS = internal constant [32 x i8] c"\00\01\02\03\04\05\06\07\08\09\0A\0B\0C\0D\0E\18\19\1A\1B\1C\1D\FF\FF\FF\10\11\FF\FF\FF\FF\1E\1F", align 16
@nct6779_temp_label = internal constant [32 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.40, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.41, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.43, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.21, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.28, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.29, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.30, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.31, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.44, i32 0, i32 0)], align 16
@NCT6779_REG_IN = internal constant [15 x i16] [i16 1152, i16 1153, i16 1154, i16 1155, i16 1156, i16 1157, i16 1158, i16 1159, i16 1160, i16 1161, i16 1162, i16 1163, i16 1164, i16 1165, i16 1166], align 16
@NCT6779_REG_FAN = internal constant [6 x i16] [i16 1200, i16 1202, i16 1204, i16 1206, i16 1208, i16 1210], align 2
@NCT6779_REG_FAN_PULSES = internal constant [6 x i16] [i16 1604, i16 1605, i16 1606, i16 1607, i16 1608, i16 1609], align 2
@NCT6779_REG_CRITICAL_PWM_ENABLE = internal constant [6 x i16] [i16 310, i16 566, i16 822, i16 2102, i16 2358, i16 2614], align 2
@NCT6779_REG_CRITICAL_PWM = internal constant [6 x i16] [i16 311, i16 567, i16 823, i16 2103, i16 2359, i16 2615], align 2
@NCT6779_REG_TEMP_OFFSET = internal constant [6 x i16] [i16 1108, i16 1109, i16 1110, i16 1098, i16 1099, i16 1100], align 2
@NCT6779_REG_ALARM = internal constant [7 x i16] [i16 1113, i16 1114, i16 1115, i16 1384, i16 0, i16 0, i16 0], align 2
@NCT6779_REG_TEMP = internal constant [2 x i16] [i16 39, i16 336], align 2
@NCT6779_REG_TEMP_MON = internal constant [5 x i16] [i16 115, i16 117, i16 119, i16 121, i16 123], align 2
@NCT6779_REG_TEMP_OVER = internal constant [2 x i16] [i16 57, i16 341], align 2
@NCT6779_REG_TEMP_HYST = internal constant [2 x i16] [i16 58, i16 339], align 2
@NCT6779_REG_TEMP_CONFIG = internal constant [2 x i16] [i16 24, i16 338], align 2
@NCT6779_REG_TEMP_ALTERNATE = internal constant [31 x i16] [i16 1168, i16 1169, i16 1170, i16 1171, i16 1172, i16 1173, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 1024, i16 1025, i16 1026, i16 1028, i16 1029, i16 1030, i16 1031, i16 1032, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0], align 16
@NCT6779_REG_TEMP_CRIT = internal constant [31 x i16] [i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 1801, i16 1802, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0, i16 0], align 16
@NCT6791_ALARM_BITS = internal constant [32 x i8] c"\00\01\02\03\08\15\14\10\11\18\19\1A\1B\1C\1D\FF\06\07\0B\0A\17!\FF\FF\04\05\0D\FF\FF\FF\0C\09", align 16
@nct6792_temp_label = internal constant [32 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.40, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.41, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.43, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.21, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.28, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.29, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.30, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.31, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.45, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.44, i32 0, i32 0)], align 16
@nct6793_temp_label = internal constant [32 x i8*] [i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.40, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.41, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.43, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.47, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.48, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.49, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.50, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.51, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.52, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.45, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.44, i32 0, i32 0)], align 16
@NCT6791_REG_WEIGHT_DUTY_STEP = internal constant [6 x i16] [i16 0, i16 572, i16 0, i16 0, i16 0, i16 0], align 2
@NCT6791_REG_WEIGHT_DUTY_BASE = internal constant [6 x i16] [i16 0, i16 574, i16 0, i16 0, i16 0, i16 0], align 2
@NCT6791_REG_WEIGHT_TEMP_SEL = internal constant [6 x i16] [i16 0, i16 569, i16 0, i16 0, i16 0, i16 0], align 2
@NCT6791_REG_WEIGHT_TEMP_STEP = internal constant [6 x i16] [i16 0, i16 570, i16 0, i16 0, i16 0, i16 0], align 2
@NCT6791_REG_WEIGHT_TEMP_STEP_TOL = internal constant [6 x i16] [i16 0, i16 571, i16 0, i16 0, i16 0, i16 0], align 2
@NCT6791_REG_WEIGHT_TEMP_BASE = internal constant [6 x i16] [i16 0, i16 573, i16 0, i16 0, i16 0, i16 0], align 2
@NCT6791_REG_ALARM = internal constant [7 x i16] [i16 1113, i16 1114, i16 1115, i16 1384, i16 1117, i16 0, i16 0], align 2
@NCT6792_REG_BEEP = internal constant [5 x i16] [i16 178, i16 179, i16 180, i16 181, i16 191], align 2
@NCT6792_REG_TEMP_MON = internal constant [6 x i16] [i16 115, i16 117, i16 119, i16 121, i16 123, i16 125], align 2
@.str.2 = private unnamed_addr constant [85 x i8] c"Invalid temperature source %d at index %d, source register 0x%x, temp register 0x%x\0A\00", align 1
@.str.3 = private unnamed_addr constant [34 x i8] c"Enabled fan debounce for chip %s\0A\00", align 1
@nct6775_pwm_template_group = internal constant %struct.sensor_template_group { %struct.sensor_device_template** getelementptr inbounds ([37 x %struct.sensor_device_template*], [37 x %struct.sensor_device_template*]* @nct6775_attributes_pwm_template, i32 0, i32 0), i16 (%struct.kobject*, %struct.attribute*, i32)* @nct6775_pwm_is_visible, i32 1 }, align 8
@nct6775_in_template_group = internal constant %struct.sensor_template_group { %struct.sensor_device_template** getelementptr inbounds ([6 x %struct.sensor_device_template*], [6 x %struct.sensor_device_template*]* @nct6775_attributes_in_template, i32 0, i32 0), i16 (%struct.kobject*, %struct.attribute*, i32)* @nct6775_in_is_visible, i32 0 }, align 8
@nct6775_fan_template_group = internal constant %struct.sensor_template_group { %struct.sensor_device_template** getelementptr inbounds ([7 x %struct.sensor_device_template*], [7 x %struct.sensor_device_template*]* @nct6775_attributes_fan_template, i32 0, i32 0), i16 (%struct.kobject*, %struct.attribute*, i32)* @nct6775_fan_is_visible, i32 1 }, align 8
@nct6775_temp_template_group = internal constant %struct.sensor_template_group { %struct.sensor_device_template** getelementptr inbounds ([11 x %struct.sensor_device_template*], [11 x %struct.sensor_device_template*]* @nct6775_attributes_temp_template, i32 0, i32 0), i16 (%struct.kobject*, %struct.attribute*, i32)* @nct6775_temp_is_visible, i32 1 }, align 8
@nct6775_group_other = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* @nct6775_other_is_visible, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([7 x %struct.attribute*], [7 x %struct.attribute*]* @nct6775_attributes_other, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@.str.4 = private unnamed_addr constant [8 x i8] c"nct6106\00", align 1
@.str.5 = private unnamed_addr constant [8 x i8] c"nct6776\00", align 1
@.str.6 = private unnamed_addr constant [8 x i8] c"nct6779\00", align 1
@.str.7 = private unnamed_addr constant [8 x i8] c"nct6791\00", align 1
@.str.8 = private unnamed_addr constant [8 x i8] c"nct6792\00", align 1
@.str.9 = private unnamed_addr constant [8 x i8] c"nct6793\00", align 1
@.str.10 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.11 = private unnamed_addr constant [7 x i8] c"SYSTIN\00", align 1
@.str.12 = private unnamed_addr constant [7 x i8] c"CPUTIN\00", align 1
@.str.13 = private unnamed_addr constant [7 x i8] c"AUXTIN\00", align 1
@.str.14 = private unnamed_addr constant [14 x i8] c"SMBUSMASTER 0\00", align 1
@.str.15 = private unnamed_addr constant [14 x i8] c"SMBUSMASTER 1\00", align 1
@.str.16 = private unnamed_addr constant [14 x i8] c"SMBUSMASTER 2\00", align 1
@.str.17 = private unnamed_addr constant [14 x i8] c"SMBUSMASTER 3\00", align 1
@.str.18 = private unnamed_addr constant [14 x i8] c"SMBUSMASTER 4\00", align 1
@.str.19 = private unnamed_addr constant [14 x i8] c"SMBUSMASTER 5\00", align 1
@.str.20 = private unnamed_addr constant [14 x i8] c"SMBUSMASTER 6\00", align 1
@.str.21 = private unnamed_addr constant [14 x i8] c"SMBUSMASTER 7\00", align 1
@.str.22 = private unnamed_addr constant [13 x i8] c"PECI Agent 0\00", align 1
@.str.23 = private unnamed_addr constant [13 x i8] c"PECI Agent 1\00", align 1
@.str.24 = private unnamed_addr constant [22 x i8] c"PCH_CHIP_CPU_MAX_TEMP\00", align 1
@.str.25 = private unnamed_addr constant [14 x i8] c"PCH_CHIP_TEMP\00", align 1
@.str.26 = private unnamed_addr constant [13 x i8] c"PCH_CPU_TEMP\00", align 1
@.str.27 = private unnamed_addr constant [13 x i8] c"PCH_MCH_TEMP\00", align 1
@.str.28 = private unnamed_addr constant [14 x i8] c"PCH_DIM0_TEMP\00", align 1
@.str.29 = private unnamed_addr constant [14 x i8] c"PCH_DIM1_TEMP\00", align 1
@.str.30 = private unnamed_addr constant [14 x i8] c"PCH_DIM2_TEMP\00", align 1
@.str.31 = private unnamed_addr constant [14 x i8] c"PCH_DIM3_TEMP\00", align 1
@.str.32 = private unnamed_addr constant [10 x i8] c"BYTE_TEMP\00", align 1
@.str.33 = private unnamed_addr constant [11 x i8] c"AMD SB-TSI\00", align 1
@.str.34 = private unnamed_addr constant [13 x i8] c"PECI Agent 2\00", align 1
@.str.35 = private unnamed_addr constant [13 x i8] c"PECI Agent 3\00", align 1
@.str.36 = private unnamed_addr constant [13 x i8] c"PECI Agent 4\00", align 1
@.str.37 = private unnamed_addr constant [13 x i8] c"PECI Agent 5\00", align 1
@.str.38 = private unnamed_addr constant [13 x i8] c"PECI Agent 6\00", align 1
@.str.39 = private unnamed_addr constant [13 x i8] c"PECI Agent 7\00", align 1
@.str.40 = private unnamed_addr constant [8 x i8] c"AUXTIN0\00", align 1
@.str.41 = private unnamed_addr constant [8 x i8] c"AUXTIN1\00", align 1
@.str.42 = private unnamed_addr constant [8 x i8] c"AUXTIN2\00", align 1
@.str.43 = private unnamed_addr constant [8 x i8] c"AUXTIN3\00", align 1
@.str.44 = private unnamed_addr constant [13 x i8] c"Virtual_TEMP\00", align 1
@.str.45 = private unnamed_addr constant [25 x i8] c"PECI Agent 0 Calibration\00", align 1
@.str.46 = private unnamed_addr constant [25 x i8] c"PECI Agent 1 Calibration\00", align 1
@.str.47 = private unnamed_addr constant [14 x i8] c"Agent0 Dimm0 \00", align 1
@.str.48 = private unnamed_addr constant [13 x i8] c"Agent0 Dimm1\00", align 1
@.str.49 = private unnamed_addr constant [13 x i8] c"Agent1 Dimm0\00", align 1
@.str.50 = private unnamed_addr constant [13 x i8] c"Agent1 Dimm1\00", align 1
@.str.51 = private unnamed_addr constant [11 x i8] c"BYTE_TEMP0\00", align 1
@.str.52 = private unnamed_addr constant [11 x i8] c"BYTE_TEMP1\00", align 1
@pv_cpu_ops = external global %struct.pv_cpu_ops, align 8
@.str.53 = private unnamed_addr constant [7 x i8] c"ASRock\00", align 1
@.str.54 = private unnamed_addr constant [11 x i8] c"Z77 Pro4-M\00", align 1
@nct6775_create_attr_group.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@nct6775_create_attr_group.__key.55 = internal global %struct.lock_class_key zeroinitializer, align 1
@nct6775_attributes_pwm_template = internal global [37 x %struct.sensor_device_template*] [%struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm to %struct.sensor_device_template*), %struct.sensor_device_template* @sensor_dev_template_pwm_mode, %struct.sensor_device_template* @sensor_dev_template_pwm_enable, %struct.sensor_device_template* @sensor_dev_template_pwm_temp_sel, %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_temp_tolerance to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_crit_temp_tolerance to %struct.sensor_device_template*), %struct.sensor_device_template* @sensor_dev_template_pwm_target_temp, %struct.sensor_device_template* @sensor_dev_template_fan_target, %struct.sensor_device_template* @sensor_dev_template_fan_tolerance, %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_stop_time to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_step_up_time to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_step_down_time to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_start to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_floor to %struct.sensor_device_template*), %struct.sensor_device_template* @sensor_dev_template_pwm_weight_temp_sel, %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_weight_temp_step to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_weight_temp_step_tol to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_weight_temp_step_base to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_weight_duty_step to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_max to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_step to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_weight_duty_base to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point1_pwm to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point1_temp to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point2_pwm to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point2_temp to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point3_pwm to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point3_temp to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point4_pwm to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point4_temp to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point5_pwm to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point5_temp to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point6_pwm to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point6_temp to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point7_pwm to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_pwm_auto_point7_temp to %struct.sensor_device_template*), %struct.sensor_device_template* null], align 16
@sensor_dev_template_pwm_mode = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_mode, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_mode }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_pwm_enable = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.62, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_enable, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_enable }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_pwm_temp_sel = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.65, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_temp_sel, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_temp_sel }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_pwm_target_temp = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.70, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_target_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_target_temp }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_fan_target = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.71, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_target_speed, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_target_speed }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_fan_tolerance = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.72, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_speed_tolerance, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_speed_tolerance }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_pwm_weight_temp_sel = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.83, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_weight_temp_sel, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_weight_temp_sel }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@.str.56 = private unnamed_addr constant [6 x i8] c"pwm%d\00", align 1
@sensor_dev_template_pwm = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.56, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 zeroinitializer, [2 x i8] undef }, i8 1 }, align 8
@.str.58 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@jiffies = external global i64, align 8
@nct6775_select_fan_div.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.nct6775_select_fan_div, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.59, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.60, i32 0, i32 0), i8 76, i8 5, i8 4, i8 0 }, section "__verbose", align 8
@__func__.nct6775_select_fan_div = private unnamed_addr constant [23 x i8] c"nct6775_select_fan_div\00", align 1
@.str.59 = private unnamed_addr constant [24 x i8] c"drivers/hwmon/nct6775.c\00", align 1
@.str.60 = private unnamed_addr constant [45 x i8] c"Modifying fan%d clock divider from %u to %u\0A\00", align 1
@NCT6775_REG_CRITICAL_ENAB = internal constant [3 x i16] [i16 308, i16 564, i16 820], align 2
@.str.61 = private unnamed_addr constant [11 x i8] c"pwm%d_mode\00", align 1
@.str.62 = private unnamed_addr constant [13 x i8] c"pwm%d_enable\00", align 1
@.str.63 = private unnamed_addr constant [61 x i8] c"Inconsistent trip points, not switching to SmartFan IV mode\0A\00", align 1
@.str.64 = private unnamed_addr constant [34 x i8] c"Adjust trip points and try again\0A\00", align 1
@.str.65 = private unnamed_addr constant [15 x i8] c"pwm%d_temp_sel\00", align 1
@.str.66 = private unnamed_addr constant [21 x i8] c"pwm%d_temp_tolerance\00", align 1
@sensor_dev_template_pwm_temp_tolerance = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.66, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_tolerance, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_tolerance }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 zeroinitializer, [2 x i8] undef }, i8 1 }, align 8
@.str.68 = private unnamed_addr constant [26 x i8] c"pwm%d_crit_temp_tolerance\00", align 1
@sensor_dev_template_pwm_crit_temp_tolerance = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.68, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_tolerance, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_tolerance }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 1 }, [2 x i8] undef }, i8 1 }, align 8
@.str.70 = private unnamed_addr constant [18 x i8] c"pwm%d_target_temp\00", align 1
@.str.71 = private unnamed_addr constant [13 x i8] c"fan%d_target\00", align 1
@.str.72 = private unnamed_addr constant [16 x i8] c"fan%d_tolerance\00", align 1
@.str.73 = private unnamed_addr constant [16 x i8] c"pwm%d_stop_time\00", align 1
@sensor_dev_template_pwm_stop_time = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.73, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_time, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_time }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 zeroinitializer, [2 x i8] undef }, i8 1 }, align 8
@.str.75 = private unnamed_addr constant [19 x i8] c"pwm%d_step_up_time\00", align 1
@sensor_dev_template_pwm_step_up_time = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.75, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_time, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_time }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 1 }, [2 x i8] undef }, i8 1 }, align 8
@.str.77 = private unnamed_addr constant [21 x i8] c"pwm%d_step_down_time\00", align 1
@sensor_dev_template_pwm_step_down_time = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.77, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_time, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_time }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 2 }, [2 x i8] undef }, i8 1 }, align 8
@.str.79 = private unnamed_addr constant [12 x i8] c"pwm%d_start\00", align 1
@sensor_dev_template_pwm_start = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.79, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 1 }, [2 x i8] undef }, i8 1 }, align 8
@.str.81 = private unnamed_addr constant [12 x i8] c"pwm%d_floor\00", align 1
@sensor_dev_template_pwm_floor = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.81, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 2 }, [2 x i8] undef }, i8 1 }, align 8
@.str.83 = private unnamed_addr constant [22 x i8] c"pwm%d_weight_temp_sel\00", align 1
@.str.84 = private unnamed_addr constant [23 x i8] c"pwm%d_weight_temp_step\00", align 1
@sensor_dev_template_pwm_weight_temp_step = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.84, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_weight_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_weight_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 zeroinitializer, [2 x i8] undef }, i8 1 }, align 8
@.str.86 = private unnamed_addr constant [27 x i8] c"pwm%d_weight_temp_step_tol\00", align 1
@sensor_dev_template_pwm_weight_temp_step_tol = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.86, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_weight_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_weight_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 1 }, [2 x i8] undef }, i8 1 }, align 8
@.str.88 = private unnamed_addr constant [28 x i8] c"pwm%d_weight_temp_step_base\00", align 1
@sensor_dev_template_pwm_weight_temp_step_base = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.88, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_weight_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_weight_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 2 }, [2 x i8] undef }, i8 1 }, align 8
@.str.90 = private unnamed_addr constant [23 x i8] c"pwm%d_weight_duty_step\00", align 1
@sensor_dev_template_pwm_weight_duty_step = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.90, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 5 }, [2 x i8] undef }, i8 1 }, align 8
@.str.92 = private unnamed_addr constant [10 x i8] c"pwm%d_max\00", align 1
@sensor_dev_template_pwm_max = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.92, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 3 }, [2 x i8] undef }, i8 1 }, align 8
@.str.94 = private unnamed_addr constant [11 x i8] c"pwm%d_step\00", align 1
@sensor_dev_template_pwm_step = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.94, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 4 }, [2 x i8] undef }, i8 1 }, align 8
@.str.96 = private unnamed_addr constant [23 x i8] c"pwm%d_weight_duty_base\00", align 1
@sensor_dev_template_pwm_weight_duty_base = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.96, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 6 }, [2 x i8] undef }, i8 1 }, align 8
@.str.98 = private unnamed_addr constant [22 x i8] c"pwm%d_auto_point1_pwm\00", align 1
@sensor_dev_template_pwm_auto_point1_pwm = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.98, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 zeroinitializer, [2 x i8] undef }, i8 1 }, align 8
@.str.100 = private unnamed_addr constant [23 x i8] c"pwm%d_auto_point1_temp\00", align 1
@sensor_dev_template_pwm_auto_point1_temp = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.100, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 zeroinitializer, [2 x i8] undef }, i8 1 }, align 8
@.str.102 = private unnamed_addr constant [22 x i8] c"pwm%d_auto_point2_pwm\00", align 1
@sensor_dev_template_pwm_auto_point2_pwm = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.102, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 1 }, [2 x i8] undef }, i8 1 }, align 8
@.str.104 = private unnamed_addr constant [23 x i8] c"pwm%d_auto_point2_temp\00", align 1
@sensor_dev_template_pwm_auto_point2_temp = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.104, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 1 }, [2 x i8] undef }, i8 1 }, align 8
@.str.106 = private unnamed_addr constant [22 x i8] c"pwm%d_auto_point3_pwm\00", align 1
@sensor_dev_template_pwm_auto_point3_pwm = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.106, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 2 }, [2 x i8] undef }, i8 1 }, align 8
@.str.108 = private unnamed_addr constant [23 x i8] c"pwm%d_auto_point3_temp\00", align 1
@sensor_dev_template_pwm_auto_point3_temp = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.108, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 2 }, [2 x i8] undef }, i8 1 }, align 8
@.str.110 = private unnamed_addr constant [22 x i8] c"pwm%d_auto_point4_pwm\00", align 1
@sensor_dev_template_pwm_auto_point4_pwm = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.110, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 3 }, [2 x i8] undef }, i8 1 }, align 8
@.str.112 = private unnamed_addr constant [23 x i8] c"pwm%d_auto_point4_temp\00", align 1
@sensor_dev_template_pwm_auto_point4_temp = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.112, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 3 }, [2 x i8] undef }, i8 1 }, align 8
@.str.114 = private unnamed_addr constant [22 x i8] c"pwm%d_auto_point5_pwm\00", align 1
@sensor_dev_template_pwm_auto_point5_pwm = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.114, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 4 }, [2 x i8] undef }, i8 1 }, align 8
@.str.116 = private unnamed_addr constant [23 x i8] c"pwm%d_auto_point5_temp\00", align 1
@sensor_dev_template_pwm_auto_point5_temp = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.116, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 4 }, [2 x i8] undef }, i8 1 }, align 8
@.str.118 = private unnamed_addr constant [22 x i8] c"pwm%d_auto_point6_pwm\00", align 1
@sensor_dev_template_pwm_auto_point6_pwm = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.118, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 5 }, [2 x i8] undef }, i8 1 }, align 8
@.str.120 = private unnamed_addr constant [23 x i8] c"pwm%d_auto_point6_temp\00", align 1
@sensor_dev_template_pwm_auto_point6_temp = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.120, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 5 }, [2 x i8] undef }, i8 1 }, align 8
@.str.122 = private unnamed_addr constant [22 x i8] c"pwm%d_auto_point7_pwm\00", align 1
@sensor_dev_template_pwm_auto_point7_pwm = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.122, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_pwm }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 6 }, [2 x i8] undef }, i8 1 }, align 8
@.str.124 = private unnamed_addr constant [23 x i8] c"pwm%d_auto_point7_temp\00", align 1
@sensor_dev_template_pwm_auto_point7_temp = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.124, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_auto_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_auto_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 6 }, [2 x i8] undef }, i8 1 }, align 8
@nct6775_attributes_in_template = internal global [6 x %struct.sensor_device_template*] [%struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_in_input to %struct.sensor_device_template*), %struct.sensor_device_template* @sensor_dev_template_in_alarm, %struct.sensor_device_template* @sensor_dev_template_in_beep, %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_in_min to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_in_max to %struct.sensor_device_template*), %struct.sensor_device_template* null], align 16
@sensor_dev_template_in_alarm = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.129, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_in_beep = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.131, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_beep, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_beep }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@.str.126 = private unnamed_addr constant [11 x i8] c"in%d_input\00", align 1
@sensor_dev_template_in_input = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.126, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_reg, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 zeroinitializer, [2 x i8] undef }, i8 1 }, align 8
@.str.128 = private unnamed_addr constant [5 x i8] c"%ld\0A\00", align 1
@scale_in = internal constant [15 x i16] [i16 800, i16 800, i16 1600, i16 1600, i16 800, i16 800, i16 800, i16 1600, i16 1600, i16 800, i16 800, i16 800, i16 800, i16 800, i16 800], align 16
@.str.129 = private unnamed_addr constant [11 x i8] c"in%d_alarm\00", align 1
@.str.130 = private unnamed_addr constant [4 x i8] c"%u\0A\00", align 1
@.str.131 = private unnamed_addr constant [10 x i8] c"in%d_beep\00", align 1
@.str.132 = private unnamed_addr constant [9 x i8] c"in%d_min\00", align 1
@sensor_dev_template_in_min = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.132, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_reg, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_reg }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 1 }, [2 x i8] undef }, i8 1 }, align 8
@.str.134 = private unnamed_addr constant [9 x i8] c"in%d_max\00", align 1
@sensor_dev_template_in_max = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.134, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_reg, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_reg }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 2 }, [2 x i8] undef }, i8 1 }, align 8
@nct6775_attributes_fan_template = internal global [7 x %struct.sensor_device_template*] [%struct.sensor_device_template* @sensor_dev_template_fan_input, %struct.sensor_device_template* @sensor_dev_template_fan_alarm, %struct.sensor_device_template* @sensor_dev_template_fan_beep, %struct.sensor_device_template* @sensor_dev_template_fan_pulses, %struct.sensor_device_template* @sensor_dev_template_fan_min, %struct.sensor_device_template* @sensor_dev_template_fan_div, %struct.sensor_device_template* null], align 16
@sensor_dev_template_fan_input = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.136, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_fan_alarm = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.137, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %union.anon.58 { i32 16 }, i8 0 }, align 8
@sensor_dev_template_fan_beep = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.138, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_beep, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_beep }, %union.anon.58 { i32 16 }, i8 0 }, align 8
@sensor_dev_template_fan_pulses = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.139, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_pulses, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_pulses }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_fan_min = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.140, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_min }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_fan_div = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.145, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_div, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@.str.136 = private unnamed_addr constant [12 x i8] c"fan%d_input\00", align 1
@.str.137 = private unnamed_addr constant [12 x i8] c"fan%d_alarm\00", align 1
@.str.138 = private unnamed_addr constant [11 x i8] c"fan%d_beep\00", align 1
@.str.139 = private unnamed_addr constant [13 x i8] c"fan%d_pulses\00", align 1
@.str.140 = private unnamed_addr constant [10 x i8] c"fan%d_min\00", align 1
@.str.141 = private unnamed_addr constant [36 x i8] c"fan%u low limit and alarm disabled\0A\00", align 1
@.str.142 = private unnamed_addr constant [54 x i8] c"fan%u low limit %lu below minimum %u, set to minimum\0A\00", align 1
@.str.143 = private unnamed_addr constant [54 x i8] c"fan%u low limit %lu above maximum %u, set to maximum\0A\00", align 1
@store_fan_min.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.store_fan_min, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.59, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.144, i32 0, i32 0), i8 -98, i8 7, i8 4, i8 0 }, section "__verbose", align 8
@__func__.store_fan_min = private unnamed_addr constant [14 x i8] c"store_fan_min\00", align 1
@.str.144 = private unnamed_addr constant [43 x i8] c"fan%u clock divider changed from %u to %u\0A\00", align 1
@.str.145 = private unnamed_addr constant [10 x i8] c"fan%d_div\00", align 1
@nct6775_attributes_temp_template = internal global [11 x %struct.sensor_device_template*] [%struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_temp_input to %struct.sensor_device_template*), %struct.sensor_device_template* @sensor_dev_template_temp_label, %struct.sensor_device_template* @sensor_dev_template_temp_alarm, %struct.sensor_device_template* @sensor_dev_template_temp_beep, %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_temp_max to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_temp_max_hyst to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_temp_crit to %struct.sensor_device_template*), %struct.sensor_device_template* bitcast ({ %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 }* @sensor_dev_template_temp_lcrit to %struct.sensor_device_template*), %struct.sensor_device_template* @sensor_dev_template_temp_offset, %struct.sensor_device_template* @sensor_dev_template_temp_type, %struct.sensor_device_template* null], align 16
@sensor_dev_template_temp_label = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.148, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_label, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_temp_alarm = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.150, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_temp_beep = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.151, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_beep, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_beep }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_temp_offset = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.160, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_offset }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@sensor_dev_template_temp_type = internal global %struct.sensor_device_template { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.161, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_type, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_type }, %union.anon.58 zeroinitializer, i8 0 }, align 8
@.str.146 = private unnamed_addr constant [13 x i8] c"temp%d_input\00", align 1
@sensor_dev_template_temp_input = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.146, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 zeroinitializer, [2 x i8] undef }, i8 1 }, align 8
@.str.148 = private unnamed_addr constant [13 x i8] c"temp%d_label\00", align 1
@.str.149 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.150 = private unnamed_addr constant [13 x i8] c"temp%d_alarm\00", align 1
@.str.151 = private unnamed_addr constant [12 x i8] c"temp%d_beep\00", align 1
@.str.152 = private unnamed_addr constant [11 x i8] c"temp%d_max\00", align 1
@sensor_dev_template_temp_max = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 1 }, [2 x i8] undef }, i8 1 }, align 8
@.str.154 = private unnamed_addr constant [16 x i8] c"temp%d_max_hyst\00", align 1
@sensor_dev_template_temp_max_hyst = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.154, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 2 }, [2 x i8] undef }, i8 1 }, align 8
@.str.156 = private unnamed_addr constant [12 x i8] c"temp%d_crit\00", align 1
@sensor_dev_template_temp_crit = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.156, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 3 }, [2 x i8] undef }, i8 1 }, align 8
@.str.158 = private unnamed_addr constant [13 x i8] c"temp%d_lcrit\00", align 1
@sensor_dev_template_temp_lcrit = internal global { %struct.device_attribute, { %struct.anon.59, [2 x i8] }, i8 } { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.158, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp }, { %struct.anon.59, [2 x i8] } { %struct.anon.59 { i8 0, i8 4 }, [2 x i8] undef }, i8 1 }, align 8
@.str.160 = private unnamed_addr constant [14 x i8] c"temp%d_offset\00", align 1
@.str.161 = private unnamed_addr constant [12 x i8] c"temp%d_type\00", align 1
@nct6775_attributes_other = internal global [7 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_cpu0_vid, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_intrusion0_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_intrusion1_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_intrusion0_beep, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_intrusion1_beep, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_beep_enable, i32 0, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_cpu0_vid = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.162, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @cpu0_vid_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@sensor_dev_attr_intrusion0_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.163, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @clear_caseopen }, i32 30 }, align 8
@sensor_dev_attr_intrusion1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.164, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @clear_caseopen }, i32 31 }, align 8
@sensor_dev_attr_intrusion0_beep = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.165, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_beep, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_beep }, i32 30 }, align 8
@sensor_dev_attr_intrusion1_beep = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.166, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_beep, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_beep }, i32 31 }, align 8
@sensor_dev_attr_beep_enable = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.167, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_beep, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_beep }, i32 15 }, align 8
@.str.162 = private unnamed_addr constant [9 x i8] c"cpu0_vid\00", align 1
@.str.163 = private unnamed_addr constant [17 x i8] c"intrusion0_alarm\00", align 1
@NCT6775_REG_CR_CASEOPEN_CLR = internal constant [2 x i8] c"\E6\EE", align 1
@NCT6775_CR_CASEOPEN_CLR_MASK = internal constant [2 x i8] c" \01", align 1
@.str.164 = private unnamed_addr constant [17 x i8] c"intrusion1_alarm\00", align 1
@.str.165 = private unnamed_addr constant [16 x i8] c"intrusion0_beep\00", align 1
@.str.166 = private unnamed_addr constant [16 x i8] c"intrusion1_beep\00", align 1
@.str.167 = private unnamed_addr constant [12 x i8] c"beep_enable\00", align 1
@.str.168 = private unnamed_addr constant [63 x i8] c"\016nct6775: Enabling hardware monitor logical device mappings.\0A\00", align 1
@nct6775_find.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__func__.nct6775_find, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.59, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.169, i32 0, i32 0), i8 -77, i8 16, i8 4, i8 0 }, section "__verbose", align 8
@__func__.nct6775_find = private unnamed_addr constant [13 x i8] c"nct6775_find\00", align 1
@.str.169 = private unnamed_addr constant [29 x i8] c"unsupported chip ID: 0x%04x\0A\00", align 1
@.str.170 = private unnamed_addr constant [38 x i8] c"nct6775: unsupported chip ID: 0x%04x\0A\00", align 1
@.str.171 = private unnamed_addr constant [73 x i8] c"\013nct6775: Refusing to enable a Super-I/O device with a base I/O port 0\0A\00", align 1
@.str.172 = private unnamed_addr constant [70 x i8] c"\014nct6775: Forcibly enabling Super-I/O. Sensor is probably unusable.\0A\00", align 1
@.str.173 = private unnamed_addr constant [51 x i8] c"\016nct6775: Found %s or compatible chip at %#x:%#x\0A\00", align 1
@nct6775_sio_names = internal constant [7 x i8*] [i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.174, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.175, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.176, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.177, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.178, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.179, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.180, i32 0, i32 0)], section ".init.rodata", align 16
@.str.174 = private unnamed_addr constant [9 x i8] c"NCT6106D\00", align 1
@.str.175 = private unnamed_addr constant [9 x i8] c"NCT6775F\00", align 1
@.str.176 = private unnamed_addr constant [11 x i8] c"NCT6776D/F\00", align 1
@.str.177 = private unnamed_addr constant [9 x i8] c"NCT6779D\00", align 1
@.str.178 = private unnamed_addr constant [9 x i8] c"NCT6791D\00", align 1
@.str.179 = private unnamed_addr constant [9 x i8] c"NCT6792D\00", align 1
@.str.180 = private unnamed_addr constant [9 x i8] c"NCT6793D\00", align 1
@llvm.used = appending global [9 x i8*] [i8* bitcast (%struct.kernel_param* @__param_force_id to i8*), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__UNIQUE_ID_force_idtype12, i32 0, i32 0), i8* getelementptr inbounds ([46 x i8], [46 x i8]* @__UNIQUE_ID_force_id13, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_fan_debounce to i8*), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__UNIQUE_ID_fan_debouncetype14, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @__UNIQUE_ID_fan_debounce15, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @__UNIQUE_ID_author52, i32 0, i32 0), i8* getelementptr inbounds ([53 x i8], [53 x i8]* @__UNIQUE_ID_description53, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license54, i32 0, i32 0)], section "llvm.metadata"

@init_module = alias i32 (), i32 ()* @sensors_nct6775_init
@cleanup_module = alias void (), void ()* @sensors_nct6775_exit

; Function Attrs: nounwind uwtable
define internal i32 @sensors_nct6775_init() #0 section ".init.text" {
entry:
  %res = alloca %struct.resource, align 8
  %sio_data = alloca %struct.nct6775_sio_data, align 4
  %sioaddr = alloca [2 x i32], align 4
  %0 = bitcast %struct.resource* %res to i8*
  %1 = bitcast %struct.nct6775_sio_data* %sio_data to i8*
  %2 = bitcast [2 x i32]* %sioaddr to i8*
  %3 = bitcast [2 x i32]* %sioaddr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* bitcast ([2 x i32]* @sensors_nct6775_init.sioaddr to i8*), i64 8, i32 4, i1 false)
  %call = call i32 @__platform_driver_register(%struct.platform_driver* @nct6775_driver, %struct.module* @__this_module)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %found.0 = phi i8 [ 0, %if.end ], [ %found.1, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %sioaddr, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %call2 = call i32 @nct6775_find(i32 %4, %struct.nct6775_sio_data* %sio_data)
  %cmp3 = icmp sle i32 %call2, 0
  br i1 %cmp3, label %for.inc, label %if.end6

if.end6:                                          ; preds = %for.body
  %call7 = call %struct.platform_device* @platform_device_alloc(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i32 %call2)
  %idxprom8 = sext i32 %i.0 to i64
  %arrayidx9 = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom8
  store %struct.platform_device* %call7, %struct.platform_device** %arrayidx9, align 8, !tbaa !6
  %idxprom10 = sext i32 %i.0 to i64
  %arrayidx11 = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom10
  %5 = load %struct.platform_device*, %struct.platform_device** %arrayidx11, align 8, !tbaa !6
  %tobool12 = icmp ne %struct.platform_device* %5, null
  br i1 %tobool12, label %if.end14, label %exit_device_unregister

if.end14:                                         ; preds = %if.end6
  %idxprom15 = sext i32 %i.0 to i64
  %arrayidx16 = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom15
  %6 = load %struct.platform_device*, %struct.platform_device** %arrayidx16, align 8, !tbaa !6
  %7 = bitcast %struct.nct6775_sio_data* %sio_data to i8*
  %call17 = call i32 @platform_device_add_data(%struct.platform_device* %6, i8* %7, i64 8)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %exit_device_put, label %if.end20

if.end20:                                         ; preds = %if.end14
  %8 = bitcast %struct.resource* %res to i8*
  %call21 = call i8* @__memset(i8* %8, i32 0, i64 64)
  %name = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 2
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8** %name, align 8, !tbaa !8
  %add = add nsw i32 %call2, 5
  %conv22 = sext i32 %add to i64
  %start = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 0
  store i64 %conv22, i64* %start, align 8, !tbaa !12
  %add23 = add nsw i32 %call2, 5
  %add24 = add nsw i32 %add23, 2
  %sub = sub nsw i32 %add24, 1
  %conv25 = sext i32 %sub to i64
  %end = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 1
  store i64 %conv25, i64* %end, align 8, !tbaa !13
  %flags = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 3
  store i64 256, i64* %flags, align 8, !tbaa !14
  %call26 = call i32 @acpi_check_resource_conflict(%struct.resource* %res)
  %tobool27 = icmp ne i32 %call26, 0
  %idxprom29 = sext i32 %i.0 to i64
  %arrayidx30 = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom29
  %9 = load %struct.platform_device*, %struct.platform_device** %arrayidx30, align 8, !tbaa !6
  br i1 %tobool27, label %if.then28, label %if.end33

if.then28:                                        ; preds = %if.end20
  call void @platform_device_put(%struct.platform_device* %9)
  %idxprom31 = sext i32 %i.0 to i64
  %arrayidx32 = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom31
  store %struct.platform_device* null, %struct.platform_device** %arrayidx32, align 8, !tbaa !6
  br label %for.inc

if.end33:                                         ; preds = %if.end20
  %call36 = call i32 @platform_device_add_resources(%struct.platform_device* %9, %struct.resource* %res, i32 1)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %exit_device_put, label %if.end39

if.end39:                                         ; preds = %if.end33
  %idxprom40 = sext i32 %i.0 to i64
  %arrayidx41 = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom40
  %10 = load %struct.platform_device*, %struct.platform_device** %arrayidx41, align 8, !tbaa !6
  %call42 = call i32 @platform_device_add(%struct.platform_device* %10)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %exit_device_put, label %for.inc

for.inc:                                          ; preds = %if.end39, %if.then28, %for.body
  %found.1 = phi i8 [ 1, %if.then28 ], [ %found.0, %for.body ], [ 1, %if.end39 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool46 = trunc i8 %found.0 to i1
  br i1 %tobool46, label %cleanup, label %exit_unregister

exit_device_put:                                  ; preds = %if.end39, %if.end33, %if.end14
  %err.0 = phi i32 [ %call17, %if.end14 ], [ %call36, %if.end33 ], [ %call42, %if.end39 ]
  %idxprom49 = sext i32 %i.0 to i64
  %arrayidx50 = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom49
  %11 = load %struct.platform_device*, %struct.platform_device** %arrayidx50, align 8, !tbaa !6
  call void @platform_device_put(%struct.platform_device* %11)
  br label %exit_device_unregister

exit_device_unregister:                           ; preds = %exit_device_put, %if.end6
  %err.1 = phi i32 [ %err.0, %exit_device_put ], [ -12, %if.end6 ]
  br label %while.cond

while.cond:                                       ; preds = %if.end59, %exit_device_unregister
  %i.1 = phi i32 [ %i.0, %exit_device_unregister ], [ %dec, %if.end59 ]
  %dec = add nsw i32 %i.1, -1
  %cmp51 = icmp sge i32 %dec, 0
  br i1 %cmp51, label %while.body, label %exit_unregister

while.body:                                       ; preds = %while.cond
  %idxprom53 = sext i32 %dec to i64
  %arrayidx54 = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom53
  %12 = load %struct.platform_device*, %struct.platform_device** %arrayidx54, align 8, !tbaa !6
  %tobool55 = icmp ne %struct.platform_device* %12, null
  br i1 %tobool55, label %if.then56, label %if.end59

if.then56:                                        ; preds = %while.body
  %idxprom57 = sext i32 %dec to i64
  %arrayidx58 = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom57
  %13 = load %struct.platform_device*, %struct.platform_device** %arrayidx58, align 8, !tbaa !6
  call void @platform_device_unregister(%struct.platform_device* %13)
  br label %if.end59

if.end59:                                         ; preds = %if.then56, %while.body
  br label %while.cond

exit_unregister:                                  ; preds = %while.cond, %for.end
  %err.2 = phi i32 [ -19, %for.end ], [ %err.1, %while.cond ]
  call void @platform_driver_unregister(%struct.platform_driver* @nct6775_driver)
  br label %cleanup

cleanup:                                          ; preds = %exit_unregister, %for.end, %entry
  %retval.0 = phi i32 [ %err.2, %exit_unregister ], [ %call, %entry ], [ 0, %for.end ]
  %14 = bitcast [2 x i32]* %sioaddr to i8*
  %15 = bitcast %struct.nct6775_sio_data* %sio_data to i8*
  %16 = bitcast %struct.resource* %res to i8*
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sensors_nct6775_exit() #0 section ".exit.text" {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom
  %0 = load %struct.platform_device*, %struct.platform_device** %arrayidx, align 8, !tbaa !6
  %tobool = icmp ne %struct.platform_device* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %idxprom2 = sext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds [2 x %struct.platform_device*], [2 x %struct.platform_device*]* @pdev, i64 0, i64 %idxprom2
  %1 = load %struct.platform_device*, %struct.platform_device** %arrayidx3, align 8, !tbaa !6
  call void @platform_device_unregister(%struct.platform_device* %1)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @platform_driver_unregister(%struct.platform_driver* @nct6775_driver)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #1

declare i32 @__platform_driver_register(%struct.platform_driver*, %struct.module*) #2

; Function Attrs: nounwind uwtable
define internal i32 @nct6775_find(i32 %sioaddr, %struct.nct6775_sio_data* %sio_data) #0 section ".init.text" {
entry:
  %call = call i32 @superio_enter(i32 %sioaddr)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @superio_inb(i32 %sioaddr, i32 32)
  %shl = shl i32 %call1, 8
  %call2 = call i32 @superio_inb(i32 %sioaddr, i32 33)
  %or = or i32 %shl, %call2
  %conv = trunc i32 %or to i16
  %0 = load i16, i16* @force_id, align 2, !tbaa !15
  %conv3 = zext i16 %0 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  %conv5 = zext i16 %conv to i32
  %cmp = icmp ne i32 %conv5, 65535
  %or.cond = and i1 %tobool4, %cmp
  %1 = load i16, i16* @force_id, align 2
  %val.0 = select i1 %or.cond, i16 %1, i16 %conv
  %conv9 = zext i16 %val.0 to i32
  %and = and i32 %conv9, 65520
  %Pivot22 = icmp slt i32 %and, 50528
  br i1 %Pivot22, label %NodeBlock5, label %NodeBlock19

NodeBlock19:                                      ; preds = %if.end
  %Pivot20 = icmp slt i32 %and, 51472
  br i1 %Pivot20, label %NodeBlock11, label %NodeBlock17

NodeBlock17:                                      ; preds = %NodeBlock19
  %Pivot18 = icmp slt i32 %and, 53536
  br i1 %Pivot18, label %LeafBlock13, label %LeafBlock15

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %and, 53536
  br i1 %SwitchLeaf16, label %sw.epilog, label %sw.default

LeafBlock13:                                      ; preds = %NodeBlock17
  %SwitchLeaf14 = icmp eq i32 %and, 51472
  br i1 %SwitchLeaf14, label %sw.epilog, label %sw.default

NodeBlock11:                                      ; preds = %NodeBlock19
  %Pivot12 = icmp slt i32 %and, 51200
  br i1 %Pivot12, label %LeafBlock7, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock11
  %SwitchLeaf10 = icmp eq i32 %and, 51200
  br i1 %SwitchLeaf10, label %sw.epilog, label %sw.default

LeafBlock7:                                       ; preds = %NodeBlock11
  %SwitchLeaf8 = icmp eq i32 %and, 50528
  br i1 %SwitchLeaf8, label %sw.epilog, label %sw.default

NodeBlock5:                                       ; preds = %if.end
  %Pivot6 = icmp slt i32 %and, 49968
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %and, 50256
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %and, 50256
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 49968
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %and, 46192
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock13, %LeafBlock15
  %conv22 = zext i16 %val.0 to i32
  %cmp23 = icmp ne i32 %conv22, 65535
  br i1 %cmp23, label %do.body, label %if.end34

do.body:                                          ; preds = %sw.default
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @nct6775_find.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and26 = and i32 %bf.clear, 1
  %tobool27 = icmp ne i32 %and26, 0
  %lnot = xor i1 %tobool27, true
  %lnot28 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot28 to i32
  %conv29 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv29, i64 1)
  %tobool30 = icmp ne i64 %expval, 0
  br i1 %tobool30, label %if.then31, label %if.end34

if.then31:                                        ; preds = %do.body
  %conv32 = zext i16 %val.0 to i32
  call void (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @nct6775_find.descriptor to %struct._ddebug*), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.170, i32 0, i32 0), i32 %conv32)
  br label %if.end34

if.end34:                                         ; preds = %if.then31, %do.body, %sw.default
  call void @superio_exit(i32 %sioaddr)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock13, %LeafBlock15
  %.sink = phi i32 [ 1, %LeafBlock ], [ 2, %LeafBlock1 ], [ 3, %LeafBlock7 ], [ 4, %LeafBlock9 ], [ 5, %LeafBlock13 ], [ 6, %LeafBlock15 ], [ 0, %LeafBlock3 ]
  %kind21 = getelementptr inbounds %struct.nct6775_sio_data, %struct.nct6775_sio_data* %sio_data, i32 0, i32 1
  store i32 %.sink, i32* %kind21, align 4, !tbaa !17
  call void @superio_select(i32 %sioaddr, i32 11)
  %call35 = call i32 @superio_inb(i32 %sioaddr, i32 96)
  %shl36 = shl i32 %call35, 8
  %call37 = call i32 @superio_inb(i32 %sioaddr, i32 97)
  %or38 = or i32 %shl36, %call37
  %conv39 = trunc i32 %or38 to i16
  %conv40 = zext i16 %conv39 to i32
  %and41 = and i32 %conv40, -8
  %cmp42 = icmp eq i32 %and41, 0
  br i1 %cmp42, label %if.then44, label %if.end46

if.then44:                                        ; preds = %sw.epilog
  %2 = call i32 (i8*, ...) @printk(i8* null)
  call void @superio_exit(i32 %sioaddr)
  br label %cleanup

if.end46:                                         ; preds = %sw.epilog
  %call47 = call i32 @superio_inb(i32 %sioaddr, i32 48)
  %conv48 = trunc i32 %call47 to i16
  %conv49 = zext i16 %conv48 to i32
  %and50 = and i32 %conv49, 1
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %if.end56, label %if.then52

if.then52:                                        ; preds = %if.end46
  %3 = call i32 (i8*, ...) @printk(i8* null)
  %conv54 = zext i16 %conv48 to i32
  %or55 = or i32 %conv54, 1
  call void @superio_outb(i32 %sioaddr, i32 48, i32 %or55)
  br label %if.end56

if.end56:                                         ; preds = %if.then52, %if.end46
  %kind57 = getelementptr inbounds %struct.nct6775_sio_data, %struct.nct6775_sio_data* %sio_data, i32 0, i32 1
  %4 = load i32, i32* %kind57, align 4, !tbaa !17
  %cmp58 = icmp eq i32 %4, 4
  br i1 %cmp58, label %if.then67, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end56
  %kind60 = getelementptr inbounds %struct.nct6775_sio_data, %struct.nct6775_sio_data* %sio_data, i32 0, i32 1
  %5 = load i32, i32* %kind60, align 4, !tbaa !17
  %cmp61 = icmp eq i32 %5, 5
  br i1 %cmp61, label %if.then67, label %lor.lhs.false63

lor.lhs.false63:                                  ; preds = %lor.lhs.false
  %kind64 = getelementptr inbounds %struct.nct6775_sio_data, %struct.nct6775_sio_data* %sio_data, i32 0, i32 1
  %6 = load i32, i32* %kind64, align 4, !tbaa !17
  %cmp65 = icmp eq i32 %6, 6
  br i1 %cmp65, label %if.then67, label %if.end68

if.then67:                                        ; preds = %lor.lhs.false63, %lor.lhs.false, %if.end56
  call void @nct6791_enable_io_mapping(i32 %sioaddr)
  br label %if.end68

if.end68:                                         ; preds = %if.then67, %lor.lhs.false63
  call void @superio_exit(i32 %sioaddr)
  %7 = call i32 (i8*, ...) @printk(i8* null)
  %sioreg = getelementptr inbounds %struct.nct6775_sio_data, %struct.nct6775_sio_data* %sio_data, i32 0, i32 0
  store i32 %sioaddr, i32* %sioreg, align 4, !tbaa !19
  br label %cleanup

cleanup:                                          ; preds = %if.end68, %if.then44, %if.end34, %entry
  %retval.0 = phi i32 [ -19, %if.then44 ], [ %and41, %if.end68 ], [ -19, %if.end34 ], [ %call, %entry ]
  ret i32 %retval.0
}

declare %struct.platform_device* @platform_device_alloc(i8*, i32) #2

declare i32 @platform_device_add_data(%struct.platform_device*, i8*, i64) #2

declare i8* @__memset(i8*, i32, i64) #2

declare i32 @acpi_check_resource_conflict(%struct.resource*) #2

declare void @platform_device_put(%struct.platform_device*) #2

declare i32 @platform_device_add_resources(%struct.platform_device*, %struct.resource*, i32) #2

declare i32 @platform_device_add(%struct.platform_device*) #2

declare void @platform_device_unregister(%struct.platform_device*) #2

declare void @platform_driver_unregister(%struct.platform_driver*) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #1

; Function Attrs: nounwind uwtable
define internal i32 @nct6775_probe(%struct.platform_device* %pdev) #3 {
entry:
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %platform_data.i = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 8
  %0 = load i8*, i8** %platform_data.i, align 8, !tbaa !20
  %1 = bitcast i8* %0 to %struct.nct6775_sio_data*
  br label %if.end

if.end:                                           ; preds = %entry
  %dev5 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call.i = call noalias i8* @devm_kmalloc(%struct.device* %dev5, i64 1280, i32 21004480) #6
  %2 = bitcast i8* %call.i to %struct.nct6775_data*
  br label %if.end805

if.end805:                                        ; preds = %if.end
  %3 = load i16, i16* @fan_debounce, align 2, !tbaa !15
  %tobool806 = icmp ne i16 %3, 0
  br i1 %tobool806, label %if.then807, label %cleanup

if.then807:                                       ; preds = %if.end805
  %sioreg808 = getelementptr inbounds %struct.nct6775_sio_data, %struct.nct6775_sio_data* %1, i32 0, i32 0
  %4 = load i32, i32* %sioreg808, align 4, !tbaa !19
  call void @superio_select(i32 %4, i32 11)
  %sioreg809 = getelementptr inbounds %struct.nct6775_sio_data, %struct.nct6775_sio_data* %1, i32 0, i32 0
  %5 = load i32, i32* %sioreg809, align 4, !tbaa !19
  %call810 = call i32 @superio_inb(i32 %5, i32 240)
  %conv811 = trunc i32 %call810 to i8
  %kind812 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 2
  %6 = load i32, i32* %kind812, align 8, !tbaa !44
  %Pivot41 = icmp slt i32 %6, 2
  br i1 %Pivot41, label %NodeBlock33, label %NodeBlock38

NodeBlock38:                                      ; preds = %if.then807
  %Pivot39 = icmp slt i32 %6, 4
  br i1 %Pivot39, label %sw.bb821, label %LeafBlock35

LeafBlock35:                                      ; preds = %NodeBlock38
  %.off36 = add i32 %6, -4
  %SwitchLeaf37 = icmp ule i32 %.off36, 2
  br i1 %SwitchLeaf37, label %sw.bb825, label %sw.epilog829

NodeBlock33:                                      ; preds = %if.then807
  %Pivot34 = icmp slt i32 %6, 1
  br i1 %Pivot34, label %LeafBlock31, label %sw.bb817

LeafBlock31:                                      ; preds = %NodeBlock33
  %SwitchLeaf32 = icmp eq i32 %6, 0
  br i1 %SwitchLeaf32, label %sw.bb813, label %sw.epilog829

sw.bb813:                                         ; preds = %LeafBlock31
  %conv814 = zext i8 %conv811 to i32
  %or815 = or i32 %conv814, 224
  %conv816 = trunc i32 %or815 to i8
  br label %sw.epilog829

sw.bb817:                                         ; preds = %NodeBlock33
  %conv818 = zext i8 %conv811 to i32
  %or819 = or i32 %conv818, 30
  %conv820 = trunc i32 %or819 to i8
  br label %sw.epilog829

sw.bb821:                                         ; preds = %NodeBlock38
  %conv822 = zext i8 %conv811 to i32
  %or823 = or i32 %conv822, 62
  %conv824 = trunc i32 %or823 to i8
  br label %sw.epilog829

sw.bb825:                                         ; preds = %LeafBlock35
  %conv826 = zext i8 %conv811 to i32
  %or827 = or i32 %conv826, 126
  %conv828 = trunc i32 %or827 to i8
  br label %sw.epilog829

sw.epilog829:                                     ; preds = %sw.bb825, %sw.bb821, %sw.bb817, %sw.bb813, %LeafBlock31, %LeafBlock35
  %tmp.0 = phi i8 [ %conv816, %sw.bb813 ], [ %conv820, %sw.bb817 ], [ %conv824, %sw.bb821 ], [ %conv828, %sw.bb825 ], [ %conv811, %LeafBlock35 ], [ %conv811, %LeafBlock31 ]
  %sioreg830 = getelementptr inbounds %struct.nct6775_sio_data, %struct.nct6775_sio_data* %1, i32 0, i32 0
  %7 = load i32, i32* %sioreg830, align 4, !tbaa !19
  %conv831 = zext i8 %tmp.0 to i32
  call void @superio_outb(i32 %7, i32 240, i32 %conv831)
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog829, %if.end805
  ret i32 0
}

declare %struct.resource* @platform_get_resource(%struct.platform_device*, i32, i32) #2

declare %struct.resource* @__devm_request_region(%struct.device*, %struct.resource*, i64, i64, i8*) #2

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @platform_set_drvdata(%struct.platform_device* %pdev, i8* %data) #4 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @fan_from_reg13(i16 zeroext %reg) #3 {
entry:
  %conv = zext i16 %reg to i32
  %and = and i32 %conv, 65311
  %cmp = icmp eq i32 %and, 65311
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv2 = zext i16 %reg to i32
  %and3 = and i32 %conv2, 31
  %conv4 = zext i16 %reg to i32
  %and5 = and i32 %conv4, 65280
  %shr = ashr i32 %and5, 3
  %or = or i32 %and3, %shr
  %conv6 = trunc i32 %or to i16
  %conv7 = zext i16 %conv6 to i32
  %cmp8 = icmp eq i32 %conv7, 0
  br i1 %cmp8, label %return, label %if.end11

if.end11:                                         ; preds = %if.end
  %conv12 = zext i16 %conv6 to i32
  %div = udiv i32 1350000, %conv12
  br label %return

return:                                           ; preds = %if.end11, %if.end, %entry
  %retval.0 = phi i32 [ %div, %if.end11 ], [ 0, %entry ], [ 0, %if.end ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @fan_from_reg16(i16 zeroext %reg, i32 %divreg) #3 {
entry:
  %conv = zext i16 %reg to i32
  %cmp = icmp eq i32 %conv, 0
  %conv2 = zext i16 %reg to i32
  %cmp3 = icmp eq i32 %conv2, 65535
  %or.cond = or i1 %cmp, %cmp3
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv5 = zext i16 %reg to i32
  %shl = shl i32 %conv5, %divreg
  %div = udiv i32 1350000, %shl
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %div, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @fan_from_reg8(i16 zeroext %reg, i32 %divreg) #3 {
entry:
  %conv = zext i16 %reg to i32
  %cmp = icmp eq i32 %conv, 0
  %conv2 = zext i16 %reg to i32
  %cmp3 = icmp eq i32 %conv2, 255
  %or.cond = or i1 %cmp, %cmp3
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv5 = zext i16 %reg to i32
  %shl = shl i32 %conv5, %divreg
  %div = udiv i32 1350000, %shl
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %div, %if.end ], [ 0, %entry ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %reg) #3 {
entry:
  %call = call zeroext i1 @is_word_sized(%struct.nct6775_data* %data, i16 zeroext %reg)
  %conv = zext i1 %call to i32
  call void @nct6775_set_bank(%struct.nct6775_data* %data, i16 zeroext %reg)
  %conv1 = zext i16 %reg to i32
  %and = and i32 %conv1, 255
  %conv2 = trunc i32 %and to i8
  %addr = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 0
  %0 = load i32, i32* %addr, align 8, !tbaa !46
  %add = add nsw i32 %0, 0
  call void @outb_p(i8 zeroext %conv2, i32 %add)
  %addr3 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 0
  %1 = load i32, i32* %addr3, align 8, !tbaa !46
  %add4 = add nsw i32 %1, 1
  %call5 = call zeroext i8 @inb_p(i32 %add4)
  %conv6 = zext i8 %call5 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv7 = zext i16 %reg to i32
  %and8 = and i32 %conv7, 255
  %add9 = add nsw i32 %and8, 1
  %conv10 = trunc i32 %add9 to i8
  %addr11 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 0
  %2 = load i32, i32* %addr11, align 8, !tbaa !46
  %add12 = add nsw i32 %2, 0
  call void @outb_p(i8 zeroext %conv10, i32 %add12)
  %shl = shl i32 %conv6, 8
  %addr13 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 0
  %3 = load i32, i32* %addr13, align 8, !tbaa !46
  %add14 = add nsw i32 %3, 1
  %call15 = call zeroext i8 @inb_p(i32 %add14)
  %conv16 = zext i8 %call15 to i32
  %add17 = add nsw i32 %shl, %conv16
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %res.0 = phi i32 [ %add17, %if.then ], [ %conv6, %entry ]
  %conv18 = trunc i32 %res.0 to i16
  ret i16 %conv18
}

; Function Attrs: nounwind uwtable
define internal void @add_temp_sensors(%struct.nct6775_data* %data, i16* %regp, i32* %available, i32* %mask) #3 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %LeafBlock ]
  %pwm_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 68
  %0 = load i8, i8* %pwm_num, align 8, !tbaa !47
  %conv = zext i8 %0 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %for.cond
  %1 = load i32, i32* %available, align 4, !tbaa !2
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i16, i16* %regp, i64 %idxprom
  %2 = load i16, i16* %arrayidx, align 2, !tbaa !15
  %tobool2 = icmp ne i16 %2, 0
  br i1 %tobool2, label %if.end, label %LeafBlock

if.end:                                           ; preds = %for.body
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds i16, i16* %regp, i64 %idxprom3
  %3 = load i16, i16* %arrayidx4, align 2, !tbaa !15
  %call = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %3)
  %conv5 = trunc i16 %call to i8
  %conv6 = zext i8 %conv5 to i32
  %and = and i32 %conv6, 31
  %conv7 = trunc i32 %and to i8
  %tobool8 = icmp ne i8 %conv7, 0
  br i1 %tobool8, label %lor.lhs.false, label %LeafBlock

lor.lhs.false:                                    ; preds = %if.end
  %4 = load i32, i32* %mask, align 4, !tbaa !2
  %conv9 = zext i8 %conv7 to i32
  %shl = shl i32 1, %conv9
  %and10 = and i32 %4, %shl
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %LeafBlock, label %if.end13

if.end13:                                         ; preds = %lor.lhs.false
  %conv14 = zext i8 %conv7 to i32
  %temp_label_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 9
  %5 = load i32, i32* %temp_label_num, align 8, !tbaa !48
  %cmp15 = icmp sge i32 %conv14, %5
  br i1 %cmp15, label %LeafBlock, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %if.end13
  %temp_label = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 8
  %6 = load i8**, i8*** %temp_label, align 8, !tbaa !49
  %idxprom18 = zext i8 %conv7 to i64
  %arrayidx19 = getelementptr inbounds i8*, i8** %6, i64 %idxprom18
  %7 = load i8*, i8** %arrayidx19, align 8, !tbaa !6
  %call20 = call i64 @strlen(i8* %7)
  %tobool21 = icmp ne i64 %call20, 0
  br i1 %tobool21, label %if.end23, label %LeafBlock

if.end23:                                         ; preds = %lor.lhs.false17
  %8 = load i32, i32* %available, align 4, !tbaa !2
  %conv24 = sext i32 %8 to i64
  %9 = call i64 asm "rep; bsf $1,$0", "=r,rm,~{dirflag},~{fpsr},~{flags}"(i64 %conv24) #7, !srcloc !50
  %conv26 = trunc i64 %9 to i32
  %REG_TEMP_SOURCE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 37
  %10 = load i16*, i16** %REG_TEMP_SOURCE, align 8, !tbaa !51
  %idxprom27 = sext i32 %conv26 to i64
  %arrayidx28 = getelementptr inbounds i16, i16* %10, i64 %idxprom27
  %11 = load i16, i16* %arrayidx28, align 2, !tbaa !15
  %conv29 = zext i8 %conv7 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %11, i16 zeroext %conv29)
  %shl31 = shl i32 1, %conv26
  %neg = xor i32 %shl31, -1
  %12 = load i32, i32* %available, align 4, !tbaa !2
  %and32 = and i32 %12, %neg
  store i32 %and32, i32* %available, align 4, !tbaa !2
  %conv33 = zext i8 %conv7 to i32
  %shl34 = shl i32 1, %conv33
  %13 = load i32, i32* %mask, align 4, !tbaa !2
  %or = or i32 %13, %shl34
  store i32 %or, i32* %mask, align 4, !tbaa !2
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end23, %lor.lhs.false17, %if.end13, %lor.lhs.false, %if.end, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.rhs, %for.cond
  ret void
}

declare i64 @strlen(i8*) #2

declare void @_dev_info(%struct.device*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @nct6775_init_device(%struct.nct6775_data* %data) #4 {
entry:
  %REG_CONFIG = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 10
  %0 = load i16, i16* %REG_CONFIG, align 4, !tbaa !52
  %tobool = icmp ne i16 %0, 0
  br i1 %tobool, label %if.then, label %if.end9

if.then:                                          ; preds = %entry
  %REG_CONFIG1 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 10
  %1 = load i16, i16* %REG_CONFIG1, align 4, !tbaa !52
  %call = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %1)
  %conv = trunc i16 %call to i8
  %conv2 = zext i8 %conv to i32
  %and = and i32 %conv2, 1
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.end9, label %if.then4

if.then4:                                         ; preds = %if.then
  %REG_CONFIG5 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 10
  %2 = load i16, i16* %REG_CONFIG5, align 4, !tbaa !52
  %conv6 = zext i8 %conv to i32
  %or = or i32 %conv6, 1
  %conv7 = trunc i32 %or to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %2, i16 zeroext %conv7)
  br label %if.end9

if.end9:                                          ; preds = %if.then4, %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %i.0 = phi i32 [ 0, %if.end9 ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %have_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 89
  %3 = load i16, i16* %have_temp, align 2, !tbaa !53
  %conv11 = zext i16 %3 to i32
  %shl = shl i32 1, %i.0
  %and12 = and i32 %conv11, %shl
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.end15, label %for.inc

if.end15:                                         ; preds = %for.body
  %reg_temp_config = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 7
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [10 x i16], [10 x i16]* %reg_temp_config, i64 0, i64 %idxprom
  %4 = load i16, i16* %arrayidx, align 2, !tbaa !15
  %tobool16 = icmp ne i16 %4, 0
  br i1 %tobool16, label %if.end18, label %for.inc

if.end18:                                         ; preds = %if.end15
  %reg_temp_config19 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 7
  %idxprom20 = sext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds [10 x i16], [10 x i16]* %reg_temp_config19, i64 0, i64 %idxprom20
  %5 = load i16, i16* %arrayidx21, align 2, !tbaa !15
  %call22 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %5)
  %conv23 = trunc i16 %call22 to i8
  %conv24 = zext i8 %conv23 to i32
  %and25 = and i32 %conv24, 1
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then27, label %for.inc

if.then27:                                        ; preds = %if.end18
  %reg_temp_config28 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 7
  %idxprom29 = sext i32 %i.0 to i64
  %arrayidx30 = getelementptr inbounds [10 x i16], [10 x i16]* %reg_temp_config28, i64 0, i64 %idxprom29
  %6 = load i16, i16* %arrayidx30, align 2, !tbaa !15
  %conv31 = zext i8 %conv23 to i32
  %and32 = and i32 %conv31, 254
  %conv33 = trunc i32 %and32 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %6, i16 zeroext %conv33)
  br label %for.inc

for.inc:                                          ; preds = %if.then27, %if.end18, %if.end15, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %REG_VBAT = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 11
  %7 = load i16, i16* %REG_VBAT, align 2, !tbaa !54
  %call36 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %7)
  %conv37 = trunc i16 %call36 to i8
  %conv38 = zext i8 %conv37 to i32
  %and39 = and i32 %conv38, 1
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.end47, label %if.then41

if.then41:                                        ; preds = %for.end
  %REG_VBAT42 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 11
  %8 = load i16, i16* %REG_VBAT42, align 2, !tbaa !54
  %conv43 = zext i8 %conv37 to i32
  %or44 = or i32 %conv43, 1
  %conv45 = trunc i32 %or44 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %8, i16 zeroext %conv45)
  br label %if.end47

if.end47:                                         ; preds = %if.then41, %for.end
  %REG_DIODE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 12
  %9 = load i16, i16* %REG_DIODE, align 8, !tbaa !55
  %call48 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %9)
  %conv49 = trunc i16 %call48 to i8
  br label %for.cond50

for.cond50:                                       ; preds = %for.inc78, %if.end47
  %i.1 = phi i32 [ 0, %if.end47 ], [ %inc79, %for.inc78 ]
  %temp_fixed_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 62
  %10 = load i8, i8* %temp_fixed_num, align 2, !tbaa !56
  %conv51 = zext i8 %10 to i32
  %cmp52 = icmp slt i32 %i.1, %conv51
  br i1 %cmp52, label %for.body54, label %for.end80

for.body54:                                       ; preds = %for.cond50
  %have_temp_fixed = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 90
  %11 = load i16, i16* %have_temp_fixed, align 8, !tbaa !57
  %conv55 = zext i16 %11 to i32
  %shl56 = shl i32 1, %i.1
  %and57 = and i32 %conv55, %shl56
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.end60, label %for.inc78

if.end60:                                         ; preds = %for.body54
  %conv61 = zext i8 %conv37 to i32
  %DIODE_MASK = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 13
  %12 = load i8, i8* %DIODE_MASK, align 2, !tbaa !58
  %conv62 = zext i8 %12 to i32
  %shl63 = shl i32 %conv62, %i.1
  %and64 = and i32 %conv61, %shl63
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %if.then66, label %if.end77

if.then66:                                        ; preds = %if.end60
  %conv67 = zext i8 %conv49 to i32
  %shr = ashr i32 %conv67, %i.1
  %DIODE_MASK68 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 13
  %13 = load i8, i8* %DIODE_MASK68, align 2, !tbaa !58
  %conv69 = zext i8 %13 to i32
  %and70 = and i32 %shr, %conv69
  %sub = sub nsw i32 3, %and70
  %conv71 = trunc i32 %sub to i8
  br label %if.end77

if.end77:                                         ; preds = %if.then66, %if.end60
  %.sink = phi i8 [ %conv71, %if.then66 ], [ 4, %if.end60 ]
  %temp_type74 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 63
  %idxprom75 = sext i32 %i.1 to i64
  %arrayidx76 = getelementptr inbounds [6 x i8], [6 x i8]* %temp_type74, i64 0, i64 %idxprom75
  store i8 %.sink, i8* %arrayidx76, align 1, !tbaa !59
  br label %for.inc78

for.inc78:                                        ; preds = %if.end77, %for.body54
  %inc79 = add nsw i32 %i.1, 1
  br label %for.cond50

for.end80:                                        ; preds = %for.cond50
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @superio_enter(i32 %ioreg) #4 {
entry:
  %conv = sext i32 %ioreg to i64
  %call = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %conv, i64 2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i32 4194304)
  %tobool = icmp ne %struct.resource* %call, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  call void @outb(i8 zeroext -121, i32 %ioreg)
  call void @outb(i8 zeroext -121, i32 %ioreg)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -16, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
declare i32 @superio_inb(i32, i32) #4

; Function Attrs: inlinehint nounwind uwtable
declare void @superio_select(i32, i32) #4

declare zeroext i8 @vid_which_vrm() #2

; Function Attrs: inlinehint nounwind uwtable
declare void @superio_outb(i32, i32, i32) #4

; Function Attrs: nounwind uwtable
define internal void @nct6775_check_fan_inputs(%struct.nct6775_data* %data) #3 {
entry:
  %sioreg1 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 1
  %0 = load i32, i32* %sioreg1, align 4, !tbaa !60
  call void @superio_select(i32 %0, i32 11)
  %call = call i32 @superio_inb(i32 %0, i32 48)
  %conv = trunc i32 %call to i8
  %sio_reg_enable = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 95
  store i8 %conv, i8* %sio_reg_enable, align 1, !tbaa !61
  %kind = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 2
  %1 = load i32, i32* %kind, align 8, !tbaa !44
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call3 = call i32 @superio_inb(i32 %0, i32 44)
  %and = and i32 %call3, 64
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  %and4 = and i32 %call3, 128
  %tobool5 = icmp ne i32 %and4, 0
  %frombool6 = zext i1 %tobool5 to i8
  %call7 = call i32 @superio_inb(i32 %0, i32 42)
  %and8 = and i32 %call7, 128
  %tobool9 = icmp ne i32 %and8, 0
  %lnot = xor i1 %tobool9, true
  %frombool10 = zext i1 %lnot to i8
  br label %if.end150

if.else:                                          ; preds = %entry
  %kind11 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 2
  %2 = load i32, i32* %kind11, align 8, !tbaa !44
  %cmp12 = icmp eq i32 %2, 2
  br i1 %cmp12, label %if.then14, label %if.else87

if.then14:                                        ; preds = %if.else
  %call15 = call i32 @superio_inb(i32 %0, i32 39)
  %and16 = and i32 %call15, 128
  %tobool17 = icmp ne i32 %and16, 0
  %frombool18 = zext i1 %tobool17 to i8
  %call19 = call i8* @dmi_get_system_info(i32 9)
  %call20 = call i8* @dmi_get_system_info(i32 10)
  %tobool21 = icmp ne i8* %call20, null
  %tobool22 = icmp ne i8* %call19, null
  %or.cond = and i1 %tobool21, %tobool22
  br i1 %or.cond, label %land.lhs.true23, label %if.end42

land.lhs.true23:                                  ; preds = %if.then14
  %call24 = call i32 @strcmp(i8* %call19, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.53, i32 0, i32 0))
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.end42, label %if.then26

if.then26:                                        ; preds = %land.lhs.true23
  %call27 = call i32 @strcmp(i8* %call20, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.54, i32 0, i32 0))
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.end42, label %if.then29

if.then29:                                        ; preds = %if.then26
  %sio_reg_enable30 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 95
  %3 = load i8, i8* %sio_reg_enable30, align 1, !tbaa !61
  %conv31 = zext i8 %3 to i32
  %and32 = and i32 %conv31, 224
  %cmp33 = icmp ne i32 %and32, 224
  br i1 %cmp33, label %if.then35, label %if.end42

if.then35:                                        ; preds = %if.then29
  %sio_reg_enable36 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 95
  %4 = load i8, i8* %sio_reg_enable36, align 1, !tbaa !61
  %conv37 = zext i8 %4 to i32
  %or = or i32 %conv37, 224
  %conv38 = trunc i32 %or to i8
  store i8 %conv38, i8* %sio_reg_enable36, align 1, !tbaa !61
  %sio_reg_enable39 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 95
  %5 = load i8, i8* %sio_reg_enable39, align 1, !tbaa !61
  %conv40 = zext i8 %5 to i32
  call void @superio_outb(i32 %0, i32 48, i32 %conv40)
  br label %if.end42

if.end42:                                         ; preds = %if.then35, %if.then29, %if.then26, %land.lhs.true23, %if.then14
  %sio_reg_enable43 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 95
  %6 = load i8, i8* %sio_reg_enable43, align 1, !tbaa !61
  %conv44 = zext i8 %6 to i32
  %and45 = and i32 %conv44, 128
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %if.then47, label %if.else50

if.then47:                                        ; preds = %if.end42
  %tobool48 = trunc i8 %frombool18 to i1
  br label %if.end56

if.else50:                                        ; preds = %if.end42
  %call51 = call i32 @superio_inb(i32 %0, i32 36)
  %and52 = and i32 %call51, 64
  %tobool53 = icmp ne i32 %and52, 0
  %lnot54 = xor i1 %tobool53, true
  br label %if.end56

if.end56:                                         ; preds = %if.else50, %if.then47
  %lnot54.sink = phi i1 [ %lnot54, %if.else50 ], [ %tobool48, %if.then47 ]
  %frombool55 = zext i1 %lnot54.sink to i8
  %sio_reg_enable57 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 95
  %7 = load i8, i8* %sio_reg_enable57, align 1, !tbaa !61
  %conv58 = zext i8 %7 to i32
  %and59 = and i32 %conv58, 64
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %if.then61, label %if.else64

if.then61:                                        ; preds = %if.end56
  %tobool62 = trunc i8 %frombool18 to i1
  br label %if.end69

if.else64:                                        ; preds = %if.end56
  %call65 = call i32 @superio_inb(i32 %0, i32 28)
  %and66 = and i32 %call65, 1
  %tobool67 = icmp ne i32 %and66, 0
  br label %if.end69

if.end69:                                         ; preds = %if.else64, %if.then61
  %tobool67.sink = phi i1 [ %tobool67, %if.else64 ], [ %tobool62, %if.then61 ]
  %frombool68 = zext i1 %tobool67.sink to i8
  %sio_reg_enable70 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 95
  %8 = load i8, i8* %sio_reg_enable70, align 1, !tbaa !61
  %conv71 = zext i8 %8 to i32
  %and72 = and i32 %conv71, 32
  %tobool73 = icmp ne i32 %and72, 0
  br i1 %tobool73, label %if.then74, label %if.else77

if.then74:                                        ; preds = %if.end69
  %tobool75 = trunc i8 %frombool18 to i1
  br label %if.end82

if.else77:                                        ; preds = %if.end69
  %call78 = call i32 @superio_inb(i32 %0, i32 28)
  %and79 = and i32 %call78, 2
  %tobool80 = icmp ne i32 %and79, 0
  br label %if.end82

if.end82:                                         ; preds = %if.else77, %if.then74
  %tobool80.sink = phi i1 [ %tobool80, %if.else77 ], [ %tobool75, %if.then74 ]
  %frombool81 = zext i1 %tobool80.sink to i8
  %tobool83 = trunc i8 %frombool68 to i1
  %frombool84 = zext i1 %tobool83 to i8
  %tobool85 = trunc i8 %frombool55 to i1
  %frombool86 = zext i1 %tobool85 to i8
  br label %if.end150

if.else87:                                        ; preds = %if.else
  %kind88 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 2
  %9 = load i32, i32* %kind88, align 8, !tbaa !44
  %cmp89 = icmp eq i32 %9, 0
  br i1 %cmp89, label %if.then91, label %if.else100

if.then91:                                        ; preds = %if.else87
  %call92 = call i32 @superio_inb(i32 %0, i32 36)
  %and93 = and i32 %call92, 128
  %tobool94 = icmp ne i32 %and93, 0
  %lnot95 = xor i1 %tobool94, true
  %frombool96 = zext i1 %lnot95 to i8
  %and97 = and i32 %call92, 8
  %tobool98 = icmp ne i32 %and97, 0
  %frombool99 = zext i1 %tobool98 to i8
  br label %if.end150

if.else100:                                       ; preds = %if.else87
  %call101 = call i32 @superio_inb(i32 %0, i32 28)
  %and102 = and i32 %call101, 32
  %tobool103 = icmp ne i32 %and102, 0
  %lnot104 = xor i1 %tobool103, true
  %frombool105 = zext i1 %lnot104 to i8
  %and106 = and i32 %call101, 64
  %tobool107 = icmp ne i32 %and106, 0
  %lnot108 = xor i1 %tobool107, true
  %frombool109 = zext i1 %lnot108 to i8
  %and110 = and i32 %call101, 128
  %tobool111 = icmp ne i32 %and110, 0
  %lnot112 = xor i1 %tobool111, true
  %frombool113 = zext i1 %lnot112 to i8
  %and114 = and i32 %call101, 1
  %tobool115 = icmp ne i32 %and114, 0
  %lnot116 = xor i1 %tobool115, true
  %frombool117 = zext i1 %lnot116 to i8
  %and118 = and i32 %call101, 2
  %tobool119 = icmp ne i32 %and118, 0
  %lnot120 = xor i1 %tobool119, true
  %frombool121 = zext i1 %lnot120 to i8
  %and122 = and i32 %call101, 4
  %tobool123 = icmp ne i32 %and122, 0
  %lnot124 = xor i1 %tobool123, true
  %frombool125 = zext i1 %lnot124 to i8
  %tobool126 = trunc i8 %frombool109 to i1
  %frombool127 = zext i1 %tobool126 to i8
  %kind128 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 2
  %10 = load i32, i32* %kind128, align 8, !tbaa !44
  %cmp129 = icmp eq i32 %10, 4
  br i1 %cmp129, label %if.then138, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else100
  %kind131 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 2
  %11 = load i32, i32* %kind131, align 8, !tbaa !44
  %cmp132 = icmp eq i32 %11, 5
  br i1 %cmp132, label %if.then138, label %lor.lhs.false134

lor.lhs.false134:                                 ; preds = %lor.lhs.false
  %kind135 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 2
  %12 = load i32, i32* %kind135, align 8, !tbaa !44
  %cmp136 = icmp eq i32 %12, 6
  br i1 %cmp136, label %if.then138, label %if.end150

if.then138:                                       ; preds = %lor.lhs.false134, %lor.lhs.false, %if.else100
  %call139 = call i32 @superio_inb(i32 %0, i32 45)
  %and140 = and i32 %call139, 2
  %tobool141 = icmp ne i32 %and140, 0
  %frombool142 = zext i1 %tobool141 to i8
  %and143 = and i32 %call139, 1
  %tobool144 = icmp ne i32 %and143, 0
  %frombool145 = zext i1 %tobool144 to i8
  br label %if.end150

if.end150:                                        ; preds = %if.then138, %lor.lhs.false134, %if.then91, %if.end82, %if.then
  %pwm6pin.3 = phi i8 [ 0, %if.then ], [ 0, %if.end82 ], [ 0, %if.then91 ], [ %frombool145, %if.then138 ], [ 0, %lor.lhs.false134 ]
  %pwm5pin.2 = phi i8 [ 0, %if.then ], [ 0, %if.end82 ], [ 0, %if.then91 ], [ %frombool125, %lor.lhs.false134 ], [ %frombool125, %if.then138 ]
  %pwm4pin.2 = phi i8 [ 0, %if.then ], [ 0, %if.end82 ], [ 0, %if.then91 ], [ %frombool121, %lor.lhs.false134 ], [ %frombool121, %if.then138 ]
  %pwm3pin.2 = phi i8 [ %frombool6, %if.then ], [ %frombool86, %if.end82 ], [ %frombool99, %if.then91 ], [ %frombool117, %lor.lhs.false134 ], [ %frombool117, %if.then138 ]
  %fan6pin.3 = phi i8 [ 0, %if.then ], [ 0, %if.end82 ], [ 0, %if.then91 ], [ %frombool142, %if.then138 ], [ 0, %lor.lhs.false134 ]
  %fan5pin.3 = phi i8 [ 0, %if.then ], [ %frombool81, %if.end82 ], [ 0, %if.then91 ], [ %frombool113, %lor.lhs.false134 ], [ %frombool113, %if.then138 ]
  %fan4min.2 = phi i8 [ 0, %if.then ], [ %frombool84, %if.end82 ], [ 0, %if.then91 ], [ %frombool127, %lor.lhs.false134 ], [ %frombool127, %if.then138 ]
  %fan4pin.3 = phi i8 [ %frombool10, %if.then ], [ %frombool68, %if.end82 ], [ 0, %if.then91 ], [ %frombool109, %lor.lhs.false134 ], [ %frombool109, %if.then138 ]
  %fan3pin.3 = phi i8 [ %frombool, %if.then ], [ %frombool55, %if.end82 ], [ %frombool96, %if.then91 ], [ %frombool105, %lor.lhs.false134 ], [ %frombool105, %if.then138 ]
  %tobool151 = trunc i8 %fan3pin.3 to i1
  %conv152 = zext i1 %tobool151 to i32
  %shl = shl i32 %conv152, 2
  %or153 = or i32 3, %shl
  %tobool154 = trunc i8 %fan4pin.3 to i1
  %conv155 = zext i1 %tobool154 to i32
  %shl156 = shl i32 %conv155, 3
  %or157 = or i32 %or153, %shl156
  %tobool158 = trunc i8 %fan5pin.3 to i1
  %conv159 = zext i1 %tobool158 to i32
  %shl160 = shl i32 %conv159, 4
  %or161 = or i32 %or157, %shl160
  %tobool162 = trunc i8 %fan6pin.3 to i1
  %conv163 = zext i1 %tobool162 to i32
  %shl164 = shl i32 %conv163, 5
  %or165 = or i32 %or161, %shl164
  %conv166 = trunc i32 %or165 to i8
  %has_fan = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 57
  store i8 %conv166, i8* %has_fan, align 1, !tbaa !62
  %tobool167 = trunc i8 %fan3pin.3 to i1
  %conv168 = zext i1 %tobool167 to i32
  %shl169 = shl i32 %conv168, 2
  %or170 = or i32 3, %shl169
  %tobool171 = trunc i8 %fan4min.2 to i1
  %conv172 = zext i1 %tobool171 to i32
  %shl173 = shl i32 %conv172, 3
  %or174 = or i32 %or170, %shl173
  %tobool175 = trunc i8 %fan5pin.3 to i1
  %conv176 = zext i1 %tobool175 to i32
  %shl177 = shl i32 %conv176, 4
  %or178 = or i32 %or174, %shl177
  %conv179 = trunc i32 %or178 to i8
  %has_fan_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 58
  store i8 %conv179, i8* %has_fan_min, align 2, !tbaa !63
  %tobool180 = trunc i8 %pwm3pin.2 to i1
  %conv181 = zext i1 %tobool180 to i32
  %shl182 = shl i32 %conv181, 2
  %or183 = or i32 3, %shl182
  %tobool184 = trunc i8 %pwm4pin.2 to i1
  %conv185 = zext i1 %tobool184 to i32
  %shl186 = shl i32 %conv185, 3
  %or187 = or i32 %or183, %shl186
  %tobool188 = trunc i8 %pwm5pin.2 to i1
  %conv189 = zext i1 %tobool188 to i32
  %shl190 = shl i32 %conv189, 4
  %or191 = or i32 %or187, %shl190
  %tobool192 = trunc i8 %pwm6pin.3 to i1
  %conv193 = zext i1 %tobool192 to i32
  %shl194 = shl i32 %conv193, 5
  %or195 = or i32 %or191, %shl194
  %conv196 = trunc i32 %or195 to i8
  %has_pwm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 56
  store i8 %conv196, i8* %has_pwm, align 8, !tbaa !64
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @superio_exit(i32 %ioreg) #4 {
entry:
  call void @outb(i8 zeroext -86, i32 %ioreg)
  call void @outb(i8 zeroext 2, i32 %ioreg)
  %add = add nsw i32 %ioreg, 1
  call void @outb(i8 zeroext 2, i32 %add)
  %conv = sext i32 %ioreg to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %conv, i64 2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @nct6775_init_fan_common(%struct.nct6775_data* %data) #3 {
entry:
  %has_fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 59
  %0 = load i8, i8* %has_fan_div, align 1, !tbaa !65, !range !66
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @nct6775_init_fan_div(%struct.nct6775_data* %data)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %has_fan_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 58
  %1 = load i8, i8* %has_fan_min, align 2, !tbaa !63
  %conv2 = zext i8 %1 to i32
  %shl = shl i32 1, %i.0
  %and = and i32 %conv2, %shl
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then4, label %for.inc

if.then4:                                         ; preds = %for.body
  %REG_FAN_MIN = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 21
  %2 = load i16*, i16** %REG_FAN_MIN, align 8, !tbaa !67
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i16, i16* %2, i64 %idxprom
  %3 = load i16, i16* %arrayidx, align 2, !tbaa !15
  %call = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %3)
  %conv5 = trunc i16 %call to i8
  %tobool6 = icmp ne i8 %conv5, 0
  br i1 %tobool6, label %for.inc, label %if.then7

if.then7:                                         ; preds = %if.then4
  %REG_FAN_MIN8 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 21
  %4 = load i16*, i16** %REG_FAN_MIN8, align 8, !tbaa !67
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds i16, i16* %4, i64 %idxprom9
  %5 = load i16, i16* %arrayidx10, align 2, !tbaa !15
  %has_fan_div11 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 59
  %6 = load i8, i8* %has_fan_div11, align 1, !tbaa !65, !range !66
  %tobool12 = trunc i8 %6 to i1
  %cond = select i1 %tobool12, i32 255, i32 65311
  %conv14 = trunc i32 %cond to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %5, i16 zeroext %conv14)
  br label %for.inc

for.inc:                                          ; preds = %if.then7, %if.then4, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @nct6775_create_attr_group(%struct.device* %dev, %struct.sensor_template_group* %tg, i32 %repeat) #3 {
entry:
  %cmp = icmp sle i32 %repeat, 0
  br i1 %cmp, label %cleanup.sink.split, label %if.end

if.end:                                           ; preds = %entry
  %templates = getelementptr inbounds %struct.sensor_template_group, %struct.sensor_template_group* %tg, i32 0, i32 0
  %0 = load %struct.sensor_device_template**, %struct.sensor_device_template*** %templates, align 8, !tbaa !68
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %t.0 = phi %struct.sensor_device_template** [ %0, %if.end ], [ %incdec.ptr, %for.inc ]
  %count.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %1 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.0, align 8, !tbaa !6
  %tobool = icmp ne %struct.sensor_device_template* %1, null
  br i1 %tobool, label %for.inc, label %for.end

for.inc:                                          ; preds = %for.cond
  %incdec.ptr = getelementptr inbounds %struct.sensor_device_template*, %struct.sensor_device_template** %t.0, i32 1
  %inc = add nsw i32 %count.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp1 = icmp eq i32 %count.0, 0
  br i1 %cmp1, label %cleanup.sink.split, label %if.end4

if.end4:                                          ; preds = %for.end
  %call.i2 = call noalias i8* @devm_kmalloc(%struct.device* %dev, i64 40, i32 21004480) #6
  %2 = bitcast i8* %call.i2 to %struct.attribute_group*
  %cmp6 = icmp eq %struct.attribute_group* %2, null
  br i1 %cmp6, label %cleanup.sink.split, label %if.end9

if.end9:                                          ; preds = %if.end4
  %mul = mul nsw i32 %repeat, %count.0
  %add = add nsw i32 %mul, 1
  %conv = sext i32 %add to i64
  %mul10 = mul i64 8, %conv
  %call.i1 = call noalias i8* @devm_kmalloc(%struct.device* %dev, i64 %mul10, i32 21004480) #6
  %3 = bitcast i8* %call.i1 to %struct.attribute**
  %cmp12 = icmp eq %struct.attribute** %3, null
  br i1 %cmp12, label %cleanup.sink.split, label %if.end16

if.end16:                                         ; preds = %if.end9
  %conv17 = sext i32 %repeat to i64
  %mul18 = mul i64 88, %conv17
  %conv19 = sext i32 %count.0 to i64
  %mul20 = mul i64 %mul18, %conv19
  %call.i = call noalias i8* @devm_kmalloc(%struct.device* %dev, i64 %mul20, i32 21004480) #6
  %4 = bitcast i8* %call.i to %struct.sensor_device_attr_u*
  %cmp22 = icmp eq %struct.sensor_device_attr_u* %4, null
  br i1 %cmp22, label %cleanup.sink.split, label %if.end26

if.end26:                                         ; preds = %if.end16
  %attrs27 = getelementptr inbounds %struct.attribute_group, %struct.attribute_group* %2, i32 0, i32 3
  store %struct.attribute** %3, %struct.attribute*** %attrs27, align 8, !tbaa !70
  %is_visible = getelementptr inbounds %struct.sensor_template_group, %struct.sensor_template_group* %tg, i32 0, i32 1
  %5 = load i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.attribute*, i32)** %is_visible, align 8, !tbaa !72
  %is_visible28 = getelementptr inbounds %struct.attribute_group, %struct.attribute_group* %2, i32 0, i32 1
  store i16 (%struct.kobject*, %struct.attribute*, i32)* %5, i16 (%struct.kobject*, %struct.attribute*, i32)** %is_visible28, align 8, !tbaa !73
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc106, %if.end26
  %attrs.0 = phi %struct.attribute** [ %3, %if.end26 ], [ %attrs.1, %for.inc106 ]
  %su.0 = phi %struct.sensor_device_attr_u* [ %4, %if.end26 ], [ %su.1, %for.inc106 ]
  %i.0 = phi i32 [ 0, %if.end26 ], [ %inc107, %for.inc106 ]
  %cmp30 = icmp slt i32 %i.0, %repeat
  br i1 %cmp30, label %for.body32, label %cleanup

for.body32:                                       ; preds = %for.cond29
  %templates33 = getelementptr inbounds %struct.sensor_template_group, %struct.sensor_template_group* %tg, i32 0, i32 0
  %6 = load %struct.sensor_device_template**, %struct.sensor_device_template*** %templates33, align 8, !tbaa !68
  br label %while.cond

while.cond:                                       ; preds = %if.end102, %for.body32
  %attrs.1 = phi %struct.attribute** [ %attrs.0, %for.body32 ], [ %incdec.ptr103, %if.end102 ]
  %su.1 = phi %struct.sensor_device_attr_u* [ %su.0, %for.body32 ], [ %incdec.ptr104, %if.end102 ]
  %t.1 = phi %struct.sensor_device_template** [ %6, %for.body32 ], [ %incdec.ptr105, %if.end102 ]
  %7 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %cmp34 = icmp ne %struct.sensor_device_template* %7, null
  br i1 %cmp34, label %while.body, label %for.inc106

while.body:                                       ; preds = %while.cond
  %name = getelementptr inbounds %struct.sensor_device_attr_u, %struct.sensor_device_attr_u* %su.1, i32 0, i32 1
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %8 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %dev_attr = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %8, i32 0, i32 0
  %attr = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr, i32 0, i32 0
  %name36 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 0
  %9 = load i8*, i8** %name36, align 8, !tbaa !74
  %base = getelementptr inbounds %struct.sensor_template_group, %struct.sensor_template_group* %tg, i32 0, i32 2
  %10 = load i32, i32* %base, align 8, !tbaa !79
  %add37 = add nsw i32 %10, %i.0
  %call38 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 32, i8* %9, i32 %add37)
  %11 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %s2 = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %11, i32 0, i32 2
  %12 = load i8, i8* %s2, align 4, !tbaa !80, !range !66
  %tobool39 = trunc i8 %12 to i1
  %u = getelementptr inbounds %struct.sensor_device_attr_u, %struct.sensor_device_attr_u* %su.1, i32 0, i32 0
  br i1 %tobool39, label %if.then40, label %if.else

if.then40:                                        ; preds = %while.body
  %a241 = bitcast %union.anon.60* %u to %struct.sensor_device_attribute_2*
  %dev_attr42 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %a241, i32 0, i32 0
  %attr43 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr42, i32 0, i32 0
  %key = getelementptr inbounds %struct.attribute, %struct.attribute* %attr43, i32 0, i32 3
  store %struct.lock_class_key* @nct6775_create_attr_group.__key, %struct.lock_class_key** %key, align 8, !tbaa !81
  %name44 = getelementptr inbounds %struct.sensor_device_attr_u, %struct.sensor_device_attr_u* %su.1, i32 0, i32 1
  %arraydecay45 = getelementptr inbounds [32 x i8], [32 x i8]* %name44, i32 0, i32 0
  %dev_attr46 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %a241, i32 0, i32 0
  %attr47 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr46, i32 0, i32 0
  %name48 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr47, i32 0, i32 0
  store i8* %arraydecay45, i8** %name48, align 8, !tbaa !82
  %13 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %u49 = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %13, i32 0, i32 1
  %s = bitcast %union.anon.58* %u49 to %struct.anon.59*
  %nr = getelementptr inbounds %struct.anon.59, %struct.anon.59* %s, i32 0, i32 0
  %14 = load i8, i8* %nr, align 8, !tbaa !59
  %conv50 = zext i8 %14 to i32
  %add51 = add nsw i32 %conv50, %i.0
  %conv52 = trunc i32 %add51 to i8
  %nr53 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %a241, i32 0, i32 2
  store i8 %conv52, i8* %nr53, align 1, !tbaa !84
  %15 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %u54 = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %15, i32 0, i32 1
  %s55 = bitcast %union.anon.58* %u54 to %struct.anon.59*
  %index = getelementptr inbounds %struct.anon.59, %struct.anon.59* %s55, i32 0, i32 1
  %16 = load i8, i8* %index, align 1, !tbaa !59
  %index56 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %a241, i32 0, i32 1
  store i8 %16, i8* %index56, align 8, !tbaa !85
  %17 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %dev_attr57 = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %17, i32 0, i32 0
  %attr58 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr57, i32 0, i32 0
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr58, i32 0, i32 1
  %18 = load i16, i16* %mode, align 8, !tbaa !86
  %dev_attr59 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %a241, i32 0, i32 0
  %attr60 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr59, i32 0, i32 0
  %mode61 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr60, i32 0, i32 1
  store i16 %18, i16* %mode61, align 8, !tbaa !87
  %19 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %dev_attr62 = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %19, i32 0, i32 0
  %show = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr62, i32 0, i32 1
  %20 = load i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show, align 8, !tbaa !88
  %dev_attr63 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %a241, i32 0, i32 0
  %show64 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr63, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* %20, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show64, align 8, !tbaa !89
  %21 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %dev_attr65 = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %21, i32 0, i32 0
  %store = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr65, i32 0, i32 2
  %22 = load i64 (%struct.device*, %struct.device_attribute*, i8*, i64)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store, align 8, !tbaa !90
  %dev_attr66 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %a241, i32 0, i32 0
  %store67 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr66, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* %22, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store67, align 8, !tbaa !91
  %dev_attr68 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %a241, i32 0, i32 0
  br label %if.end102

if.else:                                          ; preds = %while.body
  %a1 = bitcast %union.anon.60* %u to %struct.sensor_device_attribute*
  %dev_attr72 = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %a1, i32 0, i32 0
  %attr73 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr72, i32 0, i32 0
  %key74 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr73, i32 0, i32 3
  store %struct.lock_class_key* @nct6775_create_attr_group.__key.55, %struct.lock_class_key** %key74, align 8, !tbaa !81
  %name77 = getelementptr inbounds %struct.sensor_device_attr_u, %struct.sensor_device_attr_u* %su.1, i32 0, i32 1
  %arraydecay78 = getelementptr inbounds [32 x i8], [32 x i8]* %name77, i32 0, i32 0
  %dev_attr79 = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %a1, i32 0, i32 0
  %attr80 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr79, i32 0, i32 0
  %name81 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr80, i32 0, i32 0
  store i8* %arraydecay78, i8** %name81, align 8, !tbaa !92
  %23 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %u82 = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %23, i32 0, i32 1
  %index83 = bitcast %union.anon.58* %u82 to i32*
  %24 = load i32, i32* %index83, align 8, !tbaa !59
  %add84 = add nsw i32 %24, %i.0
  %index85 = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %a1, i32 0, i32 1
  store i32 %add84, i32* %index85, align 8, !tbaa !94
  %25 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %dev_attr86 = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %25, i32 0, i32 0
  %attr87 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr86, i32 0, i32 0
  %mode88 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr87, i32 0, i32 1
  %26 = load i16, i16* %mode88, align 8, !tbaa !86
  %dev_attr89 = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %a1, i32 0, i32 0
  %attr90 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr89, i32 0, i32 0
  %mode91 = getelementptr inbounds %struct.attribute, %struct.attribute* %attr90, i32 0, i32 1
  store i16 %26, i16* %mode91, align 8, !tbaa !95
  %27 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %dev_attr92 = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %27, i32 0, i32 0
  %show93 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr92, i32 0, i32 1
  %28 = load i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show93, align 8, !tbaa !88
  %dev_attr94 = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %a1, i32 0, i32 0
  %show95 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr94, i32 0, i32 1
  store i64 (%struct.device*, %struct.device_attribute*, i8*)* %28, i64 (%struct.device*, %struct.device_attribute*, i8*)** %show95, align 8, !tbaa !96
  %29 = load %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, align 8, !tbaa !6
  %dev_attr96 = getelementptr inbounds %struct.sensor_device_template, %struct.sensor_device_template* %29, i32 0, i32 0
  %store97 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr96, i32 0, i32 2
  %30 = load i64 (%struct.device*, %struct.device_attribute*, i8*, i64)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store97, align 8, !tbaa !90
  %dev_attr98 = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %a1, i32 0, i32 0
  %store99 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr98, i32 0, i32 2
  store i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* %30, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)** %store99, align 8, !tbaa !97
  %dev_attr100 = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %a1, i32 0, i32 0
  br label %if.end102

if.end102:                                        ; preds = %if.else, %if.then40
  %dev_attr100.sink = phi %struct.device_attribute* [ %dev_attr100, %if.else ], [ %dev_attr68, %if.then40 ]
  %attr101 = getelementptr inbounds %struct.device_attribute, %struct.device_attribute* %dev_attr100.sink, i32 0, i32 0
  store %struct.attribute* %attr101, %struct.attribute** %attrs.1, align 8, !tbaa !6
  %incdec.ptr103 = getelementptr inbounds %struct.attribute*, %struct.attribute** %attrs.1, i32 1
  %incdec.ptr104 = getelementptr inbounds %struct.sensor_device_attr_u, %struct.sensor_device_attr_u* %su.1, i32 1
  %incdec.ptr105 = getelementptr inbounds %struct.sensor_device_template*, %struct.sensor_device_template** %t.1, i32 1
  br label %while.cond

for.inc106:                                       ; preds = %while.cond
  %inc107 = add nsw i32 %i.0, 1
  br label %for.cond29

cleanup.sink.split:                               ; preds = %if.end16, %if.end9, %if.end4, %for.end, %entry
  %.sink = phi i64 [ -22, %for.end ], [ -12, %if.end4 ], [ -12, %if.end9 ], [ -12, %if.end16 ], [ -22, %entry ]
  %call25 = call i8* @ERR_PTR(i64 %.sink)
  %31 = bitcast i8* %call25 to %struct.attribute_group*
  br label %cleanup

cleanup:                                          ; preds = %cleanup.sink.split, %for.cond29
  %retval.0 = phi %struct.attribute_group* [ %2, %for.cond29 ], [ %31, %cleanup.sink.split ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #4 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #4 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare %struct.device* @devm_hwmon_device_register_with_groups(%struct.device*, i8*, i8*, %struct.attribute_group**) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @PTR_ERR_OR_ZERO(i8* %ptr) #4 {
entry:
  %call = call zeroext i1 @IS_ERR(i8* %ptr)
  br i1 %call, label %if.then, label %return

if.then:                                          ; preds = %entry
  %call1 = call i64 @PTR_ERR(i8* %ptr)
  %conv = trunc i64 %call1 to i32
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval.0 = phi i32 [ %conv, %if.then ], [ 0, %entry ]
  ret void
}

declare noalias i8* @devm_kmalloc(%struct.device*, i64, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !98
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @is_word_sized(%struct.nct6775_data* %data, i16 zeroext %reg) #3 {
entry:
  %kind = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 2
  %0 = load i32, i32* %kind, align 8, !tbaa !44
  %Pivot6 = icmp slt i32 %0, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %0, 3
  br i1 %Pivot4, label %sw.bb95, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %.off = add i32 %0, -3
  %SwitchLeaf2 = icmp ule i32 %.off, 3
  br i1 %SwitchLeaf2, label %sw.bb160, label %return

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %0, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb32

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %0, 0
  br i1 %SwitchLeaf, label %sw.bb, label %return

sw.bb:                                            ; preds = %LeafBlock
  %conv = zext i16 %reg to i32
  %cmp = icmp eq i32 %conv, 32
  %conv2 = zext i16 %reg to i32
  %cmp3 = icmp eq i32 %conv2, 34
  %or.cond = or i1 %cmp, %cmp3
  %conv6 = zext i16 %reg to i32
  %cmp7 = icmp eq i32 %conv6, 36
  %or.cond7 = or i1 %or.cond, %cmp7
  %conv10 = zext i16 %reg to i32
  %cmp11 = icmp eq i32 %conv10, 224
  %or.cond8 = or i1 %or.cond7, %cmp11
  %conv14 = zext i16 %reg to i32
  %cmp15 = icmp eq i32 %conv14, 226
  %or.cond9 = or i1 %or.cond8, %cmp15
  %conv18 = zext i16 %reg to i32
  %cmp19 = icmp eq i32 %conv18, 228
  %or.cond10 = or i1 %or.cond9, %cmp19
  %conv22 = zext i16 %reg to i32
  %cmp23 = icmp eq i32 %conv22, 273
  %or.cond11 = or i1 %or.cond10, %cmp23
  %conv26 = zext i16 %reg to i32
  %cmp27 = icmp eq i32 %conv26, 289
  %or.cond12 = or i1 %or.cond11, %cmp27
  br i1 %or.cond12, label %return, label %lor.rhs

lor.rhs:                                          ; preds = %sw.bb
  %conv29 = zext i16 %reg to i32
  %cmp30 = icmp eq i32 %conv29, 305
  br label %return

sw.bb32:                                          ; preds = %NodeBlock
  %conv33 = zext i16 %reg to i32
  %and = and i32 %conv33, 65280
  %cmp34 = icmp eq i32 %and, 256
  br i1 %cmp34, label %land.lhs.true, label %lor.lhs.false36

lor.lhs.false36:                                  ; preds = %sw.bb32
  %conv37 = zext i16 %reg to i32
  %and38 = and i32 %conv37, 65280
  %cmp39 = icmp eq i32 %and38, 512
  br i1 %cmp39, label %land.lhs.true, label %lor.lhs.false55

land.lhs.true:                                    ; preds = %lor.lhs.false36, %sw.bb32
  %conv41 = zext i16 %reg to i32
  %and42 = and i32 %conv41, 255
  %cmp43 = icmp eq i32 %and42, 80
  br i1 %cmp43, label %return, label %lor.lhs.false45

lor.lhs.false45:                                  ; preds = %land.lhs.true
  %conv46 = zext i16 %reg to i32
  %and47 = and i32 %conv46, 255
  %cmp48 = icmp eq i32 %and47, 83
  br i1 %cmp48, label %return, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %lor.lhs.false45
  %conv51 = zext i16 %reg to i32
  %and52 = and i32 %conv51, 255
  %cmp53 = icmp eq i32 %and52, 85
  br i1 %cmp53, label %return, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %lor.lhs.false50, %lor.lhs.false36
  %conv56 = zext i16 %reg to i32
  %and57 = and i32 %conv56, 65520
  %cmp58 = icmp eq i32 %and57, 1584
  %conv61 = zext i16 %reg to i32
  %cmp62 = icmp eq i32 %conv61, 1600
  %or.cond13 = or i1 %cmp58, %cmp62
  %conv65 = zext i16 %reg to i32
  %cmp66 = icmp eq i32 %conv65, 1602
  %or.cond14 = or i1 %or.cond13, %cmp66
  %conv69 = zext i16 %reg to i32
  %cmp70 = icmp eq i32 %conv69, 1634
  %or.cond15 = or i1 %or.cond14, %cmp70
  br i1 %or.cond15, label %return, label %lor.lhs.false72

lor.lhs.false72:                                  ; preds = %lor.lhs.false55
  %conv73 = zext i16 %reg to i32
  %and74 = and i32 %conv73, 65520
  %cmp75 = icmp eq i32 %and74, 1616
  %conv78 = zext i16 %reg to i32
  br i1 %cmp75, label %land.lhs.true77, label %lor.lhs.false82

land.lhs.true77:                                  ; preds = %lor.lhs.false72
  %and79 = and i32 %conv78, 15
  %cmp80 = icmp sge i32 %and79, 6
  %conv83 = zext i16 %reg to i32
  %cmp84 = icmp eq i32 %conv83, 115
  %or.cond16 = or i1 %cmp80, %cmp84
  %conv87 = zext i16 %reg to i32
  %cmp88 = icmp eq i32 %conv87, 117
  %or.cond18 = or i1 %or.cond16, %cmp88
  br i1 %or.cond18, label %return, label %lor.rhs90

lor.lhs.false82:                                  ; preds = %lor.lhs.false72
  %cmp84.old = icmp eq i32 %conv78, 115
  %.old17 = zext i16 %reg to i32
  %cmp88.old = icmp eq i32 %.old17, 117
  %or.cond20 = or i1 %cmp84.old, %cmp88.old
  br i1 %or.cond20, label %return, label %lor.rhs90

lor.rhs90:                                        ; preds = %lor.lhs.false82, %land.lhs.true77
  %conv91 = zext i16 %reg to i32
  %cmp92 = icmp eq i32 %conv91, 119
  br label %return

sw.bb95:                                          ; preds = %NodeBlock3
  %conv96 = zext i16 %reg to i32
  %and97 = and i32 %conv96, 65280
  %cmp98 = icmp eq i32 %and97, 256
  br i1 %cmp98, label %land.lhs.true105, label %lor.lhs.false100

lor.lhs.false100:                                 ; preds = %sw.bb95
  %conv101 = zext i16 %reg to i32
  %and102 = and i32 %conv101, 65280
  %cmp103 = icmp eq i32 %and102, 512
  br i1 %cmp103, label %land.lhs.true105, label %lor.lhs.false120

land.lhs.true105:                                 ; preds = %lor.lhs.false100, %sw.bb95
  %conv106 = zext i16 %reg to i32
  %and107 = and i32 %conv106, 255
  %cmp108 = icmp eq i32 %and107, 80
  br i1 %cmp108, label %return, label %lor.lhs.false110

lor.lhs.false110:                                 ; preds = %land.lhs.true105
  %conv111 = zext i16 %reg to i32
  %and112 = and i32 %conv111, 255
  %cmp113 = icmp eq i32 %and112, 83
  br i1 %cmp113, label %return, label %lor.lhs.false115

lor.lhs.false115:                                 ; preds = %lor.lhs.false110
  %conv116 = zext i16 %reg to i32
  %and117 = and i32 %conv116, 255
  %cmp118 = icmp eq i32 %and117, 85
  br i1 %cmp118, label %return, label %lor.lhs.false120

lor.lhs.false120:                                 ; preds = %lor.lhs.false115, %lor.lhs.false100
  %conv121 = zext i16 %reg to i32
  %and122 = and i32 %conv121, 65520
  %cmp123 = icmp eq i32 %and122, 1584
  %conv126 = zext i16 %reg to i32
  %cmp127 = icmp eq i32 %conv126, 1026
  %or.cond22 = or i1 %cmp123, %cmp127
  %conv130 = zext i16 %reg to i32
  %cmp131 = icmp eq i32 %conv130, 1600
  %or.cond24 = or i1 %or.cond22, %cmp131
  %conv134 = zext i16 %reg to i32
  %cmp135 = icmp eq i32 %conv134, 1602
  %or.cond26 = or i1 %or.cond24, %cmp135
  br i1 %or.cond26, label %return, label %lor.lhs.false137

lor.lhs.false137:                                 ; preds = %lor.lhs.false120
  %conv138 = zext i16 %reg to i32
  %and139 = and i32 %conv138, 65520
  %cmp140 = icmp eq i32 %and139, 1616
  %conv143 = zext i16 %reg to i32
  br i1 %cmp140, label %land.lhs.true142, label %lor.lhs.false147

land.lhs.true142:                                 ; preds = %lor.lhs.false137
  %and144 = and i32 %conv143, 15
  %cmp145 = icmp sge i32 %and144, 6
  %conv148 = zext i16 %reg to i32
  %cmp149 = icmp eq i32 %conv148, 115
  %or.cond28 = or i1 %cmp145, %cmp149
  %conv152 = zext i16 %reg to i32
  %cmp153 = icmp eq i32 %conv152, 117
  %or.cond30 = or i1 %or.cond28, %cmp153
  br i1 %or.cond30, label %return, label %lor.rhs155

lor.lhs.false147:                                 ; preds = %lor.lhs.false137
  %cmp149.old = icmp eq i32 %conv143, 115
  %.old29 = zext i16 %reg to i32
  %cmp153.old = icmp eq i32 %.old29, 117
  %or.cond32 = or i1 %cmp149.old, %cmp153.old
  br i1 %or.cond32, label %return, label %lor.rhs155

lor.rhs155:                                       ; preds = %lor.lhs.false147, %land.lhs.true142
  %conv156 = zext i16 %reg to i32
  %cmp157 = icmp eq i32 %conv156, 119
  br label %return

sw.bb160:                                         ; preds = %LeafBlock1
  %conv161 = zext i16 %reg to i32
  %cmp162 = icmp eq i32 %conv161, 336
  %conv165 = zext i16 %reg to i32
  %cmp166 = icmp eq i32 %conv165, 339
  %or.cond34 = or i1 %cmp162, %cmp166
  %conv169 = zext i16 %reg to i32
  %cmp170 = icmp eq i32 %conv169, 341
  %or.cond36 = or i1 %or.cond34, %cmp170
  br i1 %or.cond36, label %return, label %lor.lhs.false172

lor.lhs.false172:                                 ; preds = %sw.bb160
  %conv173 = zext i16 %reg to i32
  %and174 = and i32 %conv173, 65520
  %cmp175 = icmp eq i32 %and174, 1200
  %conv178 = zext i16 %reg to i32
  br i1 %cmp175, label %land.lhs.true177, label %lor.lhs.false182

land.lhs.true177:                                 ; preds = %lor.lhs.false172
  %and179 = and i32 %conv178, 15
  %cmp180 = icmp slt i32 %and179, 11
  %conv183 = zext i16 %reg to i32
  %cmp184 = icmp eq i32 %conv183, 1026
  %or.cond38 = or i1 %cmp180, %cmp184
  %conv187 = zext i16 %reg to i32
  %cmp188 = icmp eq i32 %conv187, 1594
  %or.cond40 = or i1 %or.cond38, %cmp188
  %.old43 = zext i16 %reg to i32
  %cmp192.old = icmp eq i32 %.old43, 1596
  %or.cond46 = or i1 %or.cond40, %cmp192.old
  %conv195 = zext i16 %reg to i32
  %cmp196 = icmp eq i32 %conv195, 1598
  %or.cond48 = or i1 %or.cond46, %cmp196
  %.old51 = zext i16 %reg to i32
  %cmp200.old = icmp eq i32 %.old51, 1600
  %or.cond54 = or i1 %or.cond48, %cmp200.old
  %conv203 = zext i16 %reg to i32
  %cmp204 = icmp eq i32 %conv203, 1602
  %or.cond56 = or i1 %or.cond54, %cmp204
  %.old59 = zext i16 %reg to i32
  %cmp208.old = icmp eq i32 %.old59, 115
  %or.cond62 = or i1 %or.cond56, %cmp208.old
  %conv211 = zext i16 %reg to i32
  %cmp212 = icmp eq i32 %conv211, 117
  %or.cond64 = or i1 %or.cond62, %cmp212
  %.old67 = zext i16 %reg to i32
  %cmp216.old = icmp eq i32 %.old67, 119
  %or.cond70 = or i1 %or.cond64, %cmp216.old
  %conv219 = zext i16 %reg to i32
  %cmp220 = icmp eq i32 %conv219, 121
  %or.cond72 = or i1 %or.cond70, %cmp220
  %.old75 = zext i16 %reg to i32
  %cmp224.old = icmp eq i32 %.old75, 123
  %or.cond78 = or i1 %or.cond72, %cmp224.old
  br i1 %or.cond78, label %return, label %lor.rhs226

lor.lhs.false182:                                 ; preds = %lor.lhs.false172
  %cmp184.old = icmp eq i32 %conv178, 1026
  %.old39 = zext i16 %reg to i32
  %cmp188.old = icmp eq i32 %.old39, 1594
  %or.cond42 = or i1 %cmp184.old, %cmp188.old
  %conv191 = zext i16 %reg to i32
  %cmp192 = icmp eq i32 %conv191, 1596
  %or.cond44 = or i1 %or.cond42, %cmp192
  %.old47 = zext i16 %reg to i32
  %cmp196.old = icmp eq i32 %.old47, 1598
  %or.cond50 = or i1 %or.cond44, %cmp196.old
  %conv199 = zext i16 %reg to i32
  %cmp200 = icmp eq i32 %conv199, 1600
  %or.cond52 = or i1 %or.cond50, %cmp200
  %.old55 = zext i16 %reg to i32
  %cmp204.old = icmp eq i32 %.old55, 1602
  %or.cond58 = or i1 %or.cond52, %cmp204.old
  %conv207 = zext i16 %reg to i32
  %cmp208 = icmp eq i32 %conv207, 115
  %or.cond60 = or i1 %or.cond58, %cmp208
  %.old63 = zext i16 %reg to i32
  %cmp212.old = icmp eq i32 %.old63, 117
  %or.cond66 = or i1 %or.cond60, %cmp212.old
  %conv215 = zext i16 %reg to i32
  %cmp216 = icmp eq i32 %conv215, 119
  %or.cond68 = or i1 %or.cond66, %cmp216
  %.old71 = zext i16 %reg to i32
  %cmp220.old = icmp eq i32 %.old71, 121
  %or.cond74 = or i1 %or.cond68, %cmp220.old
  %conv223 = zext i16 %reg to i32
  %cmp224 = icmp eq i32 %conv223, 123
  %or.cond76 = or i1 %or.cond74, %cmp224
  br i1 %or.cond76, label %return, label %lor.rhs226

lor.rhs226:                                       ; preds = %lor.lhs.false182, %land.lhs.true177
  %conv227 = zext i16 %reg to i32
  %cmp228 = icmp eq i32 %conv227, 125
  br label %return

return:                                           ; preds = %lor.rhs226, %lor.lhs.false182, %land.lhs.true177, %sw.bb160, %lor.rhs155, %lor.lhs.false147, %land.lhs.true142, %lor.lhs.false120, %lor.lhs.false115, %lor.lhs.false110, %land.lhs.true105, %lor.rhs90, %lor.lhs.false82, %land.lhs.true77, %lor.lhs.false55, %lor.lhs.false50, %lor.lhs.false45, %land.lhs.true, %lor.rhs, %sw.bb, %LeafBlock, %LeafBlock1
  %retval.0 = phi i1 [ true, %sw.bb ], [ %cmp30, %lor.rhs ], [ true, %lor.lhs.false82 ], [ true, %land.lhs.true77 ], [ true, %lor.lhs.false55 ], [ true, %lor.lhs.false50 ], [ true, %lor.lhs.false45 ], [ true, %land.lhs.true ], [ %cmp92, %lor.rhs90 ], [ true, %lor.lhs.false147 ], [ true, %land.lhs.true142 ], [ true, %lor.lhs.false120 ], [ true, %lor.lhs.false115 ], [ true, %lor.lhs.false110 ], [ true, %land.lhs.true105 ], [ %cmp157, %lor.rhs155 ], [ true, %lor.lhs.false182 ], [ true, %land.lhs.true177 ], [ true, %sw.bb160 ], [ %cmp228, %lor.rhs226 ], [ false, %LeafBlock ], [ false, %LeafBlock1 ]
  ret i1 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @nct6775_set_bank(%struct.nct6775_data* %data, i16 zeroext %reg) #4 {
entry:
  %conv = zext i16 %reg to i32
  %shr = ashr i32 %conv, 8
  %conv1 = trunc i32 %shr to i8
  %bank2 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 49
  %0 = load i8, i8* %bank2, align 8, !tbaa !99
  %conv3 = zext i8 %0 to i32
  %conv4 = zext i8 %conv1 to i32
  %cmp = icmp ne i32 %conv3, %conv4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %addr = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 0
  %1 = load i32, i32* %addr, align 8, !tbaa !46
  %add = add nsw i32 %1, 0
  call void @outb_p(i8 zeroext 78, i32 %add)
  %addr6 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 0
  %2 = load i32, i32* %addr6, align 8, !tbaa !46
  %add7 = add nsw i32 %2, 1
  call void @outb_p(i8 zeroext %conv1, i32 %add7)
  %bank8 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 49
  store i8 %conv1, i8* %bank8, align 8, !tbaa !99
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb_p(i8 zeroext %value, i32 %port) #4 {
entry:
  call void @outb(i8 zeroext %value, i32 %port)
  call void @slow_down_io()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb_p(i32 %port) #4 {
entry:
  %call = call zeroext i8 @inb(i32 %port)
  call void @slow_down_io()
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #4 {
entry:
  call void @simpll__inlineasm_0(i8 %value, i32 %port)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @slow_down_io() #4 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.pv_cpu_ops, %struct.pv_cpu_ops* @pv_cpu_ops, i32 0, i32 24), align 8, !tbaa !100
  call void %0()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #4 {
entry:
  %0 = call i8 @simpll__inlineasm_1(i32 %port)
  ret i8 %0
}

; Function Attrs: nounwind uwtable
define internal void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %reg, i16 zeroext %value) #3 {
entry:
  %call = call zeroext i1 @is_word_sized(%struct.nct6775_data* %data, i16 zeroext %reg)
  %conv = zext i1 %call to i32
  call void @nct6775_set_bank(%struct.nct6775_data* %data, i16 zeroext %reg)
  %conv1 = zext i16 %reg to i32
  %and = and i32 %conv1, 255
  %conv2 = trunc i32 %and to i8
  %addr = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 0
  %0 = load i32, i32* %addr, align 8, !tbaa !46
  %add = add nsw i32 %0, 0
  call void @outb_p(i8 zeroext %conv2, i32 %add)
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv3 = zext i16 %value to i32
  %shr = ashr i32 %conv3, 8
  %conv4 = trunc i32 %shr to i8
  %addr5 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 0
  %1 = load i32, i32* %addr5, align 8, !tbaa !46
  %add6 = add nsw i32 %1, 1
  call void @outb_p(i8 zeroext %conv4, i32 %add6)
  %conv7 = zext i16 %reg to i32
  %and8 = and i32 %conv7, 255
  %add9 = add nsw i32 %and8, 1
  %conv10 = trunc i32 %add9 to i8
  %addr11 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 0
  %2 = load i32, i32* %addr11, align 8, !tbaa !46
  %add12 = add nsw i32 %2, 0
  call void @outb_p(i8 zeroext %conv10, i32 %add12)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %conv13 = zext i16 %value to i32
  %and14 = and i32 %conv13, 255
  %conv15 = trunc i32 %and14 to i8
  %addr16 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 0
  %3 = load i32, i32* %addr16, align 8, !tbaa !46
  %add17 = add nsw i32 %3, 1
  call void @outb_p(i8 zeroext %conv15, i32 %add17)
  ret void
}

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #2

declare i8* @dmi_get_system_info(i32) #2

declare i32 @strcmp(i8*, i8*) #2

declare void @__release_region(%struct.resource*, i64, i64) #2

; Function Attrs: nounwind uwtable
define internal void @nct6775_init_fan_div(%struct.nct6775_data* %data) #3 {
entry:
  call void @nct6775_update_fan_div_common(%struct.nct6775_data* %data)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %has_fan = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 57
  %0 = load i8, i8* %has_fan, align 1, !tbaa !62
  %conv2 = zext i8 %0 to i32
  %shl = shl i32 1, %i.0
  %and = and i32 %conv2, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %if.then6, label %for.inc

if.then6:                                         ; preds = %if.end
  %fan_div7 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %idxprom8 = sext i32 %i.0 to i64
  %arrayidx9 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div7, i64 0, i64 %idxprom8
  store i8 7, i8* %arrayidx9, align 1, !tbaa !59
  call void @nct6775_write_fan_div_common(%struct.nct6775_data* %data, i32 %i.0)
  br label %for.inc

for.inc:                                          ; preds = %if.then6, %if.end, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @nct6775_update_fan_div_common(%struct.nct6775_data* %data) #3 {
entry:
  %kind = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 2
  %0 = load i32, i32* %kind, align 8, !tbaa !44
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @nct6775_update_fan_div(%struct.nct6775_data* %data)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @nct6775_write_fan_div_common(%struct.nct6775_data* %data, i32 %nr) #3 {
entry:
  %kind = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 2
  %0 = load i32, i32* %kind, align 8, !tbaa !44
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @nct6775_write_fan_div(%struct.nct6775_data* %data, i32 %nr)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @nct6775_update_fan_div(%struct.nct6775_data* %data) #3 {
entry:
  %call = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext 1286)
  %conv = trunc i16 %call to i8
  %conv1 = zext i8 %conv to i32
  %and = and i32 %conv1, 7
  %conv2 = trunc i32 %and to i8
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 0
  store i8 %conv2, i8* %arrayidx, align 2, !tbaa !59
  %conv3 = zext i8 %conv to i32
  %and4 = and i32 %conv3, 112
  %shr = ashr i32 %and4, 4
  %conv5 = trunc i32 %shr to i8
  %fan_div6 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %arrayidx7 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div6, i64 0, i64 1
  store i8 %conv5, i8* %arrayidx7, align 1, !tbaa !59
  %call8 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext 1287)
  %conv9 = trunc i16 %call8 to i8
  %conv10 = zext i8 %conv9 to i32
  %and11 = and i32 %conv10, 7
  %conv12 = trunc i32 %and11 to i8
  %fan_div13 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %arrayidx14 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div13, i64 0, i64 2
  store i8 %conv12, i8* %arrayidx14, align 2, !tbaa !59
  %has_fan = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 57
  %0 = load i8, i8* %has_fan, align 1, !tbaa !62
  %conv15 = zext i8 %0 to i32
  %and16 = and i32 %conv15, 8
  %tobool = icmp ne i32 %and16, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv17 = zext i8 %conv9 to i32
  %and18 = and i32 %conv17, 112
  %shr19 = ashr i32 %and18, 4
  %conv20 = trunc i32 %shr19 to i8
  %fan_div21 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %arrayidx22 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div21, i64 0, i64 3
  store i8 %conv20, i8* %arrayidx22, align 1, !tbaa !59
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @nct6775_write_fan_div(%struct.nct6775_data* %data, i32 %nr) #3 {
entry:
  %Pivot6 = icmp slt i32 %nr, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %nr, 3
  br i1 %Pivot4, label %sw.bb18, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %nr, 3
  br i1 %SwitchLeaf2, label %sw.bb30, label %sw.epilog

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %nr, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb6

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %nr, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %call = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext 1286)
  %conv = zext i16 %call to i32
  %and = and i32 %conv, 112
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 0
  %0 = load i8, i8* %arrayidx, align 2, !tbaa !59
  %conv1 = zext i8 %0 to i32
  %and2 = and i32 %conv1, 7
  %or = or i32 %and, %and2
  %conv3 = trunc i32 %or to i8
  %conv4 = zext i8 %conv3 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext 1286, i16 zeroext %conv4)
  br label %sw.epilog

sw.bb6:                                           ; preds = %NodeBlock
  %call7 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext 1286)
  %conv8 = zext i16 %call7 to i32
  %and9 = and i32 %conv8, 7
  %fan_div10 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %arrayidx11 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div10, i64 0, i64 1
  %1 = load i8, i8* %arrayidx11, align 1, !tbaa !59
  %conv12 = zext i8 %1 to i32
  %shl = shl i32 %conv12, 4
  %and13 = and i32 %shl, 112
  %or14 = or i32 %and9, %and13
  %conv15 = trunc i32 %or14 to i8
  %conv16 = zext i8 %conv15 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext 1286, i16 zeroext %conv16)
  br label %sw.epilog

sw.bb18:                                          ; preds = %NodeBlock3
  %call19 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext 1287)
  %conv20 = zext i16 %call19 to i32
  %and21 = and i32 %conv20, 112
  %fan_div22 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %arrayidx23 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div22, i64 0, i64 2
  %2 = load i8, i8* %arrayidx23, align 2, !tbaa !59
  %conv24 = zext i8 %2 to i32
  %and25 = and i32 %conv24, 7
  %or26 = or i32 %and21, %and25
  %conv27 = trunc i32 %or26 to i8
  %conv28 = zext i8 %conv27 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext 1287, i16 zeroext %conv28)
  br label %sw.epilog

sw.bb30:                                          ; preds = %LeafBlock1
  %call31 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext 1287)
  %conv32 = zext i16 %call31 to i32
  %and33 = and i32 %conv32, 7
  %fan_div34 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %arrayidx35 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div34, i64 0, i64 3
  %3 = load i8, i8* %arrayidx35, align 1, !tbaa !59
  %conv36 = zext i8 %3 to i32
  %shl37 = shl i32 %conv36, 4
  %and38 = and i32 %shl37, 112
  %or39 = or i32 %and33, %and38
  %conv40 = trunc i32 %or39 to i8
  %conv41 = zext i8 %conv40 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext 1287, i16 zeroext %conv41)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb30, %sw.bb18, %sw.bb6, %sw.bb, %LeafBlock, %LeafBlock1
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR(i64 %error) #4 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

declare i32 @snprintf(i8*, i64, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal zeroext i16 @nct6775_pwm_is_visible(%struct.kobject* %kobj, %struct.attribute* %attr, i32 %index) #3 {
entry:
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %call = call i8* @dev_get_drvdata(%struct.device* %1)
  %2 = bitcast i8* %call to %struct.nct6775_data*
  %div = sdiv i32 %index, 36
  %rem = srem i32 %index, 36
  %has_pwm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 56
  %3 = load i8, i8* %has_pwm, align 8, !tbaa !64
  %conv = zext i8 %3 to i32
  %shl = shl i32 1, %div
  %and = and i32 %conv, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %cleanup49

if.end:                                           ; preds = %entry
  %cmp = icmp sge i32 %rem, 14
  %cmp2 = icmp sle i32 %rem, 18
  %or.cond = and i1 %cmp, %cmp2
  %cmp4 = icmp eq i32 %rem, 21
  %or.cond1 = or i1 %or.cond, %cmp4
  br i1 %or.cond1, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.end
  %REG_WEIGHT_TEMP_SEL = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 39
  %4 = load i16*, i16** %REG_WEIGHT_TEMP_SEL, align 8, !tbaa !102
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %5 = load i16, i16* %arrayidx, align 2, !tbaa !15
  %tobool7 = icmp ne i16 %5, 0
  br i1 %tobool7, label %if.end10, label %cleanup49

if.end10:                                         ; preds = %if.then6, %if.end
  switch i32 %rem, label %if.end36 [
    i32 19, label %land.lhs.true13
    i32 20, label %land.lhs.true21
    i32 21, label %land.lhs.true30
  ]

land.lhs.true13:                                  ; preds = %if.end10
  %REG_PWM = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 28
  %arrayidx14 = getelementptr inbounds [7 x i16*], [7 x i16*]* %REG_PWM, i64 0, i64 3
  %6 = load i16*, i16** %arrayidx14, align 8, !tbaa !6
  %cmp15 = icmp eq i16* %6, null
  br i1 %cmp15, label %cleanup49, label %if.end18

if.end18:                                         ; preds = %land.lhs.true13
  switch i32 %rem, label %if.end36 [
    i32 20, label %land.lhs.true21
    i32 21, label %land.lhs.true30
  ]

land.lhs.true21:                                  ; preds = %if.end18, %if.end10
  %REG_PWM22 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 28
  %arrayidx23 = getelementptr inbounds [7 x i16*], [7 x i16*]* %REG_PWM22, i64 0, i64 4
  %7 = load i16*, i16** %arrayidx23, align 8, !tbaa !6
  %cmp24 = icmp eq i16* %7, null
  br i1 %cmp24, label %cleanup49, label %if.end27

if.end27:                                         ; preds = %land.lhs.true21
  %cmp28 = icmp eq i32 %rem, 21
  br i1 %cmp28, label %land.lhs.true30, label %if.end36

land.lhs.true30:                                  ; preds = %if.end27, %if.end18, %if.end10
  %REG_PWM31 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 28
  %arrayidx32 = getelementptr inbounds [7 x i16*], [7 x i16*]* %REG_PWM31, i64 0, i64 6
  %8 = load i16*, i16** %arrayidx32, align 8, !tbaa !6
  %cmp33 = icmp eq i16* %8, null
  br i1 %cmp33, label %cleanup49, label %if.end36

if.end36:                                         ; preds = %land.lhs.true30, %if.end27, %if.end18, %if.end10
  %cmp37 = icmp sge i32 %rem, 22
  %cmp40 = icmp sle i32 %rem, 35
  %or.cond2 = and i1 %cmp37, %cmp40
  br i1 %or.cond2, label %if.then42, label %if.end48

if.then42:                                        ; preds = %if.end36
  %sub = sub nsw i32 %rem, 22
  %div43 = sdiv i32 %sub, 2
  %auto_pwm_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 80
  %9 = load i32, i32* %auto_pwm_num, align 4, !tbaa !103
  %cmp44 = icmp sgt i32 %div43, %9
  %. = select i1 %cmp44, i32 1, i32 0
  %SwitchLeaf = icmp eq i32 %., 0
  br i1 %SwitchLeaf, label %if.end48, label %cleanup49

if.end48:                                         ; preds = %if.then42, %if.end36
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 1
  %10 = load i16, i16* %mode, align 8, !tbaa !104
  br label %cleanup49

cleanup49:                                        ; preds = %if.end48, %if.then42, %land.lhs.true30, %land.lhs.true21, %land.lhs.true13, %if.then6, %entry
  %retval.1 = phi i16 [ %10, %if.end48 ], [ 0, %entry ], [ 0, %if.then6 ], [ 0, %land.lhs.true13 ], [ 0, %land.lhs.true21 ], [ 0, %land.lhs.true30 ], [ 0, %if.then42 ]
  ret i16 %retval.1
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 2
  %2 = load i8, i8* %nr1, align 1, !tbaa !84
  %conv = zext i8 %2 to i32
  %index2 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 1
  %3 = load i8, i8* %index2, align 8, !tbaa !85
  %conv3 = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv3, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %pwm_enable = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 70
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %pwm_enable, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4, !tbaa !59
  %cmp5 = icmp ugt i32 %4, 1
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %REG_PWM_READ = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 29
  %5 = load i16*, i16** %REG_PWM_READ, align 8, !tbaa !105
  %idxprom7 = sext i32 %conv to i64
  %arrayidx8 = getelementptr inbounds i16, i16* %5, i64 %idxprom7
  %6 = load i16, i16* %arrayidx8, align 2, !tbaa !15
  %call9 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %call, i16 zeroext %6)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %7 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv18 = sext i32 %7 to i64
  ret i64 %conv18
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %minval = alloca [7 x i32], align 16
  %maxval = alloca [7 x i32], align 16
  %__UNIQUE_ID_min1_30 = alloca i64, align 8
  %__UNIQUE_ID_min1_28 = alloca i64, align 8
  %__UNIQUE_ID_min2_29 = alloca i64, align 8
  %__UNIQUE_ID_min2_31 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !84
  %conv = zext i8 %3 to i32
  %index2 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 1
  %4 = load i8, i8* %index2, align 8, !tbaa !85
  %conv3 = zext i8 %4 to i32
  %5 = bitcast i64* %val to i8*
  %6 = bitcast [7 x i32]* %minval to i8*
  %arrayinit.begin = getelementptr inbounds [7 x i32], [7 x i32]* %minval, i64 0, i64 0
  store i32 0, i32* %arrayinit.begin, align 4, !tbaa !2
  %arrayinit.element = getelementptr inbounds i32, i32* %arrayinit.begin, i64 1
  store i32 1, i32* %arrayinit.element, align 4, !tbaa !2
  %arrayinit.element4 = getelementptr inbounds i32, i32* %arrayinit.element, i64 1
  store i32 1, i32* %arrayinit.element4, align 4, !tbaa !2
  %arrayinit.element5 = getelementptr inbounds i32, i32* %arrayinit.element4, i64 1
  %pwm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 71
  %arrayidx = getelementptr inbounds [7 x [6 x i8]], [7 x [6 x i8]]* %pwm, i64 0, i64 2
  %idxprom = sext i32 %conv to i64
  %arrayidx6 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx, i64 0, i64 %idxprom
  %7 = load i8, i8* %arrayidx6, align 1, !tbaa !59
  %conv7 = zext i8 %7 to i32
  store i32 %conv7, i32* %arrayinit.element5, align 4, !tbaa !2
  %arrayinit.element8 = getelementptr inbounds i32, i32* %arrayinit.element5, i64 1
  store i32 0, i32* %arrayinit.element8, align 4, !tbaa !2
  %arrayinit.element9 = getelementptr inbounds i32, i32* %arrayinit.element8, i64 1
  store i32 0, i32* %arrayinit.element9, align 4, !tbaa !2
  %arrayinit.element10 = getelementptr inbounds i32, i32* %arrayinit.element9, i64 1
  store i32 0, i32* %arrayinit.element10, align 4, !tbaa !2
  %8 = bitcast [7 x i32]* %maxval to i8*
  %arrayinit.begin11 = getelementptr inbounds [7 x i32], [7 x i32]* %maxval, i64 0, i64 0
  store i32 255, i32* %arrayinit.begin11, align 4, !tbaa !2
  %arrayinit.element12 = getelementptr inbounds i32, i32* %arrayinit.begin11, i64 1
  store i32 255, i32* %arrayinit.element12, align 4, !tbaa !2
  %arrayinit.element13 = getelementptr inbounds i32, i32* %arrayinit.element12, i64 1
  %pwm14 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 71
  %arrayidx15 = getelementptr inbounds [7 x [6 x i8]], [7 x [6 x i8]]* %pwm14, i64 0, i64 3
  %idxprom16 = sext i32 %conv to i64
  %arrayidx17 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx15, i64 0, i64 %idxprom16
  %9 = load i8, i8* %arrayidx17, align 1, !tbaa !59
  %conv18 = zext i8 %9 to i32
  %tobool = icmp ne i32 %conv18, 0
  %conv18. = select i1 %tobool, i32 %conv18, i32 255
  store i32 %conv18., i32* %arrayinit.element13, align 4, !tbaa !2
  %arrayinit.element19 = getelementptr inbounds i32, i32* %arrayinit.element13, i64 1
  store i32 255, i32* %arrayinit.element19, align 4, !tbaa !2
  %arrayinit.element20 = getelementptr inbounds i32, i32* %arrayinit.element19, i64 1
  store i32 255, i32* %arrayinit.element20, align 4, !tbaa !2
  %arrayinit.element21 = getelementptr inbounds i32, i32* %arrayinit.element20, i64 1
  store i32 255, i32* %arrayinit.element21, align 4, !tbaa !2
  %arrayinit.element22 = getelementptr inbounds i32, i32* %arrayinit.element21, i64 1
  store i32 255, i32* %arrayinit.element22, align 4, !tbaa !2
  %call23 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call23, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv25 = sext i32 %call23 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %10 = bitcast i64* %__UNIQUE_ID_min1_30 to i8*
  %11 = bitcast i64* %__UNIQUE_ID_min1_28 to i8*
  %12 = load i64, i64* %val, align 8, !tbaa !106
  store i64 %12, i64* %__UNIQUE_ID_min1_28, align 8, !tbaa !106
  %13 = bitcast i64* %__UNIQUE_ID_min2_29 to i8*
  %idxprom26 = sext i32 %conv3 to i64
  %arrayidx27 = getelementptr inbounds [7 x i32], [7 x i32]* %minval, i64 0, i64 %idxprom26
  %14 = load i32, i32* %arrayidx27, align 4, !tbaa !2
  %conv28 = sext i32 %14 to i64
  store i64 %conv28, i64* %__UNIQUE_ID_min2_29, align 8, !tbaa !106
  %15 = load i64, i64* %__UNIQUE_ID_min1_28, align 8, !tbaa !106
  %16 = load i64, i64* %__UNIQUE_ID_min2_29, align 8, !tbaa !106
  %cmp32 = icmp ugt i64 %15, %16
  %17 = load i64, i64* %__UNIQUE_ID_min1_28, align 8
  %18 = load i64, i64* %__UNIQUE_ID_min2_29, align 8
  %cond37 = select i1 %cmp32, i64 %17, i64 %18
  %19 = bitcast i64* %__UNIQUE_ID_min2_29 to i8*
  %20 = bitcast i64* %__UNIQUE_ID_min1_28 to i8*
  store i64 %cond37, i64* %__UNIQUE_ID_min1_30, align 8, !tbaa !106
  %21 = bitcast i64* %__UNIQUE_ID_min2_31 to i8*
  %idxprom38 = sext i32 %conv3 to i64
  %arrayidx39 = getelementptr inbounds [7 x i32], [7 x i32]* %maxval, i64 0, i64 %idxprom38
  %22 = load i32, i32* %arrayidx39, align 4, !tbaa !2
  %conv40 = sext i32 %22 to i64
  store i64 %conv40, i64* %__UNIQUE_ID_min2_31, align 8, !tbaa !106
  %23 = load i64, i64* %__UNIQUE_ID_min1_30, align 8, !tbaa !106
  %24 = load i64, i64* %__UNIQUE_ID_min2_31, align 8, !tbaa !106
  %cmp44 = icmp ult i64 %23, %24
  %25 = load i64, i64* %__UNIQUE_ID_min1_30, align 8
  %26 = load i64, i64* %__UNIQUE_ID_min2_31, align 8
  %cond49 = select i1 %cmp44, i64 %25, i64 %26
  %27 = bitcast i64* %__UNIQUE_ID_min2_31 to i8*
  %28 = bitcast i64* %__UNIQUE_ID_min1_30 to i8*
  store i64 %cond49, i64* %val, align 8, !tbaa !106
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %29 = load i64, i64* %val, align 8, !tbaa !106
  %conv50 = trunc i64 %29 to i8
  %pwm51 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 71
  %idxprom52 = sext i32 %conv3 to i64
  %arrayidx53 = getelementptr inbounds [7 x [6 x i8]], [7 x [6 x i8]]* %pwm51, i64 0, i64 %idxprom52
  %idxprom54 = sext i32 %conv to i64
  %arrayidx55 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx53, i64 0, i64 %idxprom54
  store i8 %conv50, i8* %arrayidx55, align 1, !tbaa !59
  %REG_PWM = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 28
  %idxprom56 = sext i32 %conv3 to i64
  %arrayidx57 = getelementptr inbounds [7 x i16*], [7 x i16*]* %REG_PWM, i64 0, i64 %idxprom56
  %30 = load i16*, i16** %arrayidx57, align 8, !tbaa !6
  %idxprom58 = sext i32 %conv to i64
  %arrayidx59 = getelementptr inbounds i16, i16* %30, i64 %idxprom58
  %31 = load i16, i16* %arrayidx59, align 2, !tbaa !15
  %32 = load i64, i64* %val, align 8, !tbaa !106
  %conv60 = trunc i64 %32 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %31, i16 zeroext %conv60)
  %cmp62 = icmp eq i32 %conv3, 2
  br i1 %cmp62, label %if.then64, label %if.end81

if.then64:                                        ; preds = %if.end
  %REG_TEMP_SEL = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 38
  %33 = load i16*, i16** %REG_TEMP_SEL, align 8, !tbaa !107
  %idxprom65 = sext i32 %conv to i64
  %arrayidx66 = getelementptr inbounds i16, i16* %33, i64 %idxprom65
  %34 = load i16, i16* %arrayidx66, align 2, !tbaa !15
  %call67 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %34)
  %conv68 = trunc i16 %call67 to i8
  %conv69 = zext i8 %conv68 to i32
  %and = and i32 %conv69, 127
  %conv70 = trunc i32 %and to i8
  %35 = load i64, i64* %val, align 8, !tbaa !106
  %tobool71 = icmp ne i64 %35, 0
  %conv73 = zext i8 %conv70 to i32
  %or = or i32 %conv73, 128
  %conv74 = trunc i32 %or to i8
  %reg.0 = select i1 %tobool71, i8 %conv74, i8 %conv70
  %REG_TEMP_SEL76 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 38
  %36 = load i16*, i16** %REG_TEMP_SEL76, align 8, !tbaa !107
  %idxprom77 = sext i32 %conv to i64
  %arrayidx78 = getelementptr inbounds i16, i16* %36, i64 %idxprom77
  %37 = load i16, i16* %arrayidx78, align 2, !tbaa !15
  %conv79 = zext i8 %reg.0 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %37, i16 zeroext %conv79)
  br label %if.end81

if.end81:                                         ; preds = %if.then64, %if.end
  %update_lock82 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock82)
  br label %cleanup

cleanup:                                          ; preds = %if.end81, %if.then
  %retval.0 = phi i64 [ %conv25, %if.then ], [ %count, %if.end81 ]
  %38 = bitcast [7 x i32]* %maxval to i8*
  %39 = bitcast [7 x i32]* %minval to i8*
  %40 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev) #3 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy1 = alloca i64, align 8
  %__dummy22 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %1 = bitcast i64* %__dummy to i8*
  %2 = bitcast i64* %__dummy2 to i8*
  %3 = bitcast i64* %__dummy2 to i8*
  %4 = bitcast i64* %__dummy to i8*
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %5 = bitcast i64* %__dummy1 to i8*
  %6 = bitcast i64* %__dummy22 to i8*
  %7 = bitcast i64* %__dummy22 to i8*
  %8 = bitcast i64* %__dummy1 to i8*
  %last_updated = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 48
  %9 = load i64, i64* %last_updated, align 8, !tbaa !108
  %add = add i64 %9, 250
  %add8 = add i64 %add, 125
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !106
  %sub = sub i64 %add8, %10
  %cmp9 = icmp slt i64 %sub, 0
  br i1 %cmp9, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %valid = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 47
  %11 = load i8, i8* %valid, align 8, !tbaa !109, !range !66
  %tobool11 = trunc i8 %11 to i1
  br i1 %tobool11, label %if.end192, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  call void @nct6775_update_fan_div_common(%struct.nct6775_data* %0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %in_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 50
  %12 = load i8, i8* %in_num, align 1, !tbaa !110
  %conv12 = zext i8 %12 to i32
  %cmp13 = icmp slt i32 %i.0, %conv12
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %have_in = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 91
  %13 = load i16, i16* %have_in, align 2, !tbaa !111
  %conv15 = zext i16 %13 to i32
  %shl = shl i32 1, %i.0
  %and = and i32 %conv15, %shl
  %tobool16 = icmp ne i32 %and, 0
  br i1 %tobool16, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %REG_VIN = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 16
  %14 = load i16*, i16** %REG_VIN, align 8, !tbaa !112
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i16, i16* %14, i64 %idxprom
  %15 = load i16, i16* %arrayidx, align 2, !tbaa !15
  %call18 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %15)
  %conv19 = trunc i16 %call18 to i8
  %in = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 51
  %idxprom20 = sext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds [15 x [3 x i8]], [15 x [3 x i8]]* %in, i64 0, i64 %idxprom20
  %arrayidx22 = getelementptr inbounds [3 x i8], [3 x i8]* %arrayidx21, i64 0, i64 0
  store i8 %conv19, i8* %arrayidx22, align 1, !tbaa !59
  %REG_IN_MINMAX = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 17
  %arrayidx23 = getelementptr inbounds [2 x i16*], [2 x i16*]* %REG_IN_MINMAX, i64 0, i64 0
  %16 = load i16*, i16** %arrayidx23, align 8, !tbaa !6
  %idxprom24 = sext i32 %i.0 to i64
  %arrayidx25 = getelementptr inbounds i16, i16* %16, i64 %idxprom24
  %17 = load i16, i16* %arrayidx25, align 2, !tbaa !15
  %call26 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %17)
  %conv27 = trunc i16 %call26 to i8
  %in28 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 51
  %idxprom29 = sext i32 %i.0 to i64
  %arrayidx30 = getelementptr inbounds [15 x [3 x i8]], [15 x [3 x i8]]* %in28, i64 0, i64 %idxprom29
  %arrayidx31 = getelementptr inbounds [3 x i8], [3 x i8]* %arrayidx30, i64 0, i64 1
  store i8 %conv27, i8* %arrayidx31, align 1, !tbaa !59
  %REG_IN_MINMAX32 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 17
  %arrayidx33 = getelementptr inbounds [2 x i16*], [2 x i16*]* %REG_IN_MINMAX32, i64 0, i64 1
  %18 = load i16*, i16** %arrayidx33, align 8, !tbaa !6
  %idxprom34 = sext i32 %i.0 to i64
  %arrayidx35 = getelementptr inbounds i16, i16* %18, i64 %idxprom34
  %19 = load i16, i16* %arrayidx35, align 2, !tbaa !15
  %call36 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %19)
  %conv37 = trunc i16 %call36 to i8
  %in38 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 51
  %idxprom39 = sext i32 %i.0 to i64
  %arrayidx40 = getelementptr inbounds [15 x [3 x i8]], [15 x [3 x i8]]* %in38, i64 0, i64 %idxprom39
  %arrayidx41 = getelementptr inbounds [3 x i8], [3 x i8]* %arrayidx40, i64 0, i64 2
  store i8 %conv37, i8* %arrayidx41, align 1, !tbaa !59
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond42

for.cond42:                                       ; preds = %LeafBlock, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc85, %LeafBlock ]
  %conv43 = sext i32 %i.1 to i64
  %cmp44 = icmp ult i64 %conv43, 6
  br i1 %cmp44, label %for.body46, label %for.end86

for.body46:                                       ; preds = %for.cond42
  %has_fan = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 57
  %20 = load i8, i8* %has_fan, align 1, !tbaa !62
  %conv47 = zext i8 %20 to i32
  %shl48 = shl i32 1, %i.1
  %and49 = and i32 %conv47, %shl48
  %tobool50 = icmp ne i32 %and49, 0
  br i1 %tobool50, label %if.end52, label %LeafBlock

if.end52:                                         ; preds = %for.body46
  %REG_FAN = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 19
  %21 = load i16*, i16** %REG_FAN, align 8, !tbaa !113
  %idxprom53 = sext i32 %i.1 to i64
  %arrayidx54 = getelementptr inbounds i16, i16* %21, i64 %idxprom53
  %22 = load i16, i16* %arrayidx54, align 2, !tbaa !15
  %call55 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %22)
  %fan_from_reg = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 44
  %23 = load i32 (i16, i32)*, i32 (i16, i32)** %fan_from_reg, align 8, !tbaa !114
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 55
  %idxprom56 = sext i32 %i.1 to i64
  %arrayidx57 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 %idxprom56
  %24 = load i8, i8* %arrayidx57, align 1, !tbaa !59
  %conv58 = zext i8 %24 to i32
  %call59 = call i32 %23(i16 zeroext %call55, i32 %conv58)
  %rpm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 52
  %idxprom60 = sext i32 %i.1 to i64
  %arrayidx61 = getelementptr inbounds [6 x i32], [6 x i32]* %rpm, i64 0, i64 %idxprom60
  store i32 %call59, i32* %arrayidx61, align 4, !tbaa !2
  %has_fan_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 58
  %25 = load i8, i8* %has_fan_min, align 2, !tbaa !63
  %conv62 = zext i8 %25 to i32
  %shl63 = shl i32 1, %i.1
  %and64 = and i32 %conv62, %shl63
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %if.then66, label %if.end72

if.then66:                                        ; preds = %if.end52
  %REG_FAN_MIN = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 21
  %26 = load i16*, i16** %REG_FAN_MIN, align 8, !tbaa !67
  %idxprom67 = sext i32 %i.1 to i64
  %arrayidx68 = getelementptr inbounds i16, i16* %26, i64 %idxprom67
  %27 = load i16, i16* %arrayidx68, align 2, !tbaa !15
  %call69 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %27)
  %fan_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 53
  %idxprom70 = sext i32 %i.1 to i64
  %arrayidx71 = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min, i64 0, i64 %idxprom70
  store i16 %call69, i16* %arrayidx71, align 2, !tbaa !15
  br label %if.end72

if.end72:                                         ; preds = %if.then66, %if.end52
  %REG_FAN_PULSES = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 22
  %28 = load i16*, i16** %REG_FAN_PULSES, align 8, !tbaa !115
  %idxprom73 = sext i32 %i.1 to i64
  %arrayidx74 = getelementptr inbounds i16, i16* %28, i64 %idxprom73
  %29 = load i16, i16* %arrayidx74, align 2, !tbaa !15
  %call75 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %29)
  %conv76 = zext i16 %call75 to i32
  %FAN_PULSE_SHIFT = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 23
  %30 = load i16*, i16** %FAN_PULSE_SHIFT, align 8, !tbaa !116
  %idxprom77 = sext i32 %i.1 to i64
  %arrayidx78 = getelementptr inbounds i16, i16* %30, i64 %idxprom77
  %31 = load i16, i16* %arrayidx78, align 2, !tbaa !15
  %conv79 = zext i16 %31 to i32
  %shr = ashr i32 %conv76, %conv79
  %and80 = and i32 %shr, 3
  %conv81 = trunc i32 %and80 to i8
  %fan_pulses = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 54
  %idxprom82 = sext i32 %i.1 to i64
  %arrayidx83 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_pulses, i64 0, i64 %idxprom82
  store i8 %conv81, i8* %arrayidx83, align 1, !tbaa !59
  call void @nct6775_select_fan_div(%struct.device* %dev, %struct.nct6775_data* %0, i32 %i.1, i16 zeroext %call55)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end72, %for.body46
  %inc85 = add nsw i32 %i.1, 1
  br label %for.cond42

for.end86:                                        ; preds = %for.cond42
  call void @nct6775_update_pwm(%struct.device* %dev)
  call void @nct6775_update_pwm_limits(%struct.device* %dev)
  br label %for.cond87

for.cond87:                                       ; preds = %for.inc137, %for.end86
  %i.2 = phi i32 [ 0, %for.end86 ], [ %inc138, %for.inc137 ]
  %cmp88 = icmp slt i32 %i.2, 10
  br i1 %cmp88, label %for.body90, label %for.end139

for.body90:                                       ; preds = %for.cond87
  %have_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 89
  %32 = load i16, i16* %have_temp, align 2, !tbaa !53
  %conv91 = zext i16 %32 to i32
  %shl92 = shl i32 1, %i.2
  %and93 = and i32 %conv91, %shl92
  %tobool94 = icmp ne i32 %and93, 0
  br i1 %tobool94, label %if.end96, label %for.inc137

if.end96:                                         ; preds = %for.body90
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc119, %if.end96
  %j.0 = phi i32 [ 0, %if.end96 ], [ %inc120, %for.inc119 ]
  %conv98 = sext i32 %j.0 to i64
  %cmp99 = icmp ult i64 %conv98, 5
  br i1 %cmp99, label %for.body101, label %for.end121

for.body101:                                      ; preds = %for.cond97
  %reg_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 5
  %idxprom102 = sext i32 %j.0 to i64
  %arrayidx103 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %reg_temp, i64 0, i64 %idxprom102
  %idxprom104 = sext i32 %i.2 to i64
  %arrayidx105 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx103, i64 0, i64 %idxprom104
  %33 = load i16, i16* %arrayidx105, align 2, !tbaa !15
  %tobool106 = icmp ne i16 %33, 0
  br i1 %tobool106, label %if.then107, label %for.inc119

if.then107:                                       ; preds = %for.body101
  %reg_temp108 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 5
  %idxprom109 = sext i32 %j.0 to i64
  %arrayidx110 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %reg_temp108, i64 0, i64 %idxprom109
  %idxprom111 = sext i32 %i.2 to i64
  %arrayidx112 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx110, i64 0, i64 %idxprom111
  %34 = load i16, i16* %arrayidx112, align 2, !tbaa !15
  %call113 = call zeroext i16 @nct6775_read_temp(%struct.nct6775_data* %0, i16 zeroext %34)
  %temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 65
  %idxprom114 = sext i32 %j.0 to i64
  %arrayidx115 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %temp, i64 0, i64 %idxprom114
  %idxprom116 = sext i32 %i.2 to i64
  %arrayidx117 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx115, i64 0, i64 %idxprom116
  store i16 %call113, i16* %arrayidx117, align 2, !tbaa !15
  br label %for.inc119

for.inc119:                                       ; preds = %if.then107, %for.body101
  %inc120 = add nsw i32 %j.0, 1
  br label %for.cond97

for.end121:                                       ; preds = %for.cond97
  %cmp122 = icmp sge i32 %i.2, 6
  br i1 %cmp122, label %for.inc137, label %lor.lhs.false124

lor.lhs.false124:                                 ; preds = %for.end121
  %have_temp_fixed = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 90
  %35 = load i16, i16* %have_temp_fixed, align 8, !tbaa !57
  %conv125 = zext i16 %35 to i32
  %shl126 = shl i32 1, %i.2
  %and127 = and i32 %conv125, %shl126
  %tobool128 = icmp ne i32 %and127, 0
  br i1 %tobool128, label %if.end130, label %for.inc137

if.end130:                                        ; preds = %lor.lhs.false124
  %REG_TEMP_OFFSET = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 41
  %36 = load i16*, i16** %REG_TEMP_OFFSET, align 8, !tbaa !117
  %idxprom131 = sext i32 %i.2 to i64
  %arrayidx132 = getelementptr inbounds i16, i16* %36, i64 %idxprom131
  %37 = load i16, i16* %arrayidx132, align 2, !tbaa !15
  %call133 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %37)
  %conv134 = trunc i16 %call133 to i8
  %temp_offset = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 64
  %idxprom135 = sext i32 %i.2 to i64
  %arrayidx136 = getelementptr inbounds [6 x i8], [6 x i8]* %temp_offset, i64 0, i64 %idxprom135
  store i8 %conv134, i8* %arrayidx136, align 1, !tbaa !59
  br label %for.inc137

for.inc137:                                       ; preds = %if.end130, %lor.lhs.false124, %for.end121, %for.body90
  %inc138 = add nsw i32 %i.2, 1
  br label %for.cond87

for.end139:                                       ; preds = %for.cond87
  %alarms = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 66
  store i64 0, i64* %alarms, align 8, !tbaa !118
  br label %for.cond140

for.cond140:                                      ; preds = %LeafBlock2, %for.end139
  %i.3 = phi i32 [ 0, %for.end139 ], [ %inc162, %LeafBlock2 ]
  %cmp141 = icmp slt i32 %i.3, 7
  br i1 %cmp141, label %for.body143, label %for.end163

for.body143:                                      ; preds = %for.cond140
  %REG_ALARM = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 42
  %38 = load i16*, i16** %REG_ALARM, align 8, !tbaa !119
  %idxprom144 = sext i32 %i.3 to i64
  %arrayidx145 = getelementptr inbounds i16, i16* %38, i64 %idxprom144
  %39 = load i16, i16* %arrayidx145, align 2, !tbaa !15
  %tobool146 = icmp ne i16 %39, 0
  br i1 %tobool146, label %if.end148, label %LeafBlock2

if.end148:                                        ; preds = %for.body143
  %REG_ALARM149 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 42
  %40 = load i16*, i16** %REG_ALARM149, align 8, !tbaa !119
  %idxprom150 = sext i32 %i.3 to i64
  %arrayidx151 = getelementptr inbounds i16, i16* %40, i64 %idxprom150
  %41 = load i16, i16* %arrayidx151, align 2, !tbaa !15
  %call152 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %41)
  %conv153 = trunc i16 %call152 to i8
  %conv154 = zext i8 %conv153 to i64
  %shl155 = shl i32 %i.3, 3
  %sh_prom = zext i32 %shl155 to i64
  %shl156 = shl i64 %conv154, %sh_prom
  %alarms157 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 66
  %42 = load i64, i64* %alarms157, align 8, !tbaa !118
  %or = or i64 %42, %shl156
  store i64 %or, i64* %alarms157, align 8, !tbaa !118
  br label %LeafBlock2

LeafBlock2:                                       ; preds = %if.end148, %for.body143
  %inc162 = add nsw i32 %i.3, 1
  br label %for.cond140

for.end163:                                       ; preds = %for.cond140
  %beeps = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 67
  store i64 0, i64* %beeps, align 8, !tbaa !120
  br label %for.cond164

for.cond164:                                      ; preds = %LeafBlock5, %for.end163
  %i.4 = phi i32 [ 0, %for.end163 ], [ %inc188, %LeafBlock5 ]
  %cmp165 = icmp slt i32 %i.4, 5
  br i1 %cmp165, label %for.body167, label %for.end189

for.body167:                                      ; preds = %for.cond164
  %REG_BEEP = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 43
  %43 = load i16*, i16** %REG_BEEP, align 8, !tbaa !121
  %idxprom168 = sext i32 %i.4 to i64
  %arrayidx169 = getelementptr inbounds i16, i16* %43, i64 %idxprom168
  %44 = load i16, i16* %arrayidx169, align 2, !tbaa !15
  %tobool170 = icmp ne i16 %44, 0
  br i1 %tobool170, label %if.end172, label %LeafBlock5

if.end172:                                        ; preds = %for.body167
  %REG_BEEP173 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 43
  %45 = load i16*, i16** %REG_BEEP173, align 8, !tbaa !121
  %idxprom174 = sext i32 %i.4 to i64
  %arrayidx175 = getelementptr inbounds i16, i16* %45, i64 %idxprom174
  %46 = load i16, i16* %arrayidx175, align 2, !tbaa !15
  %call176 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %46)
  %conv177 = trunc i16 %call176 to i8
  %conv178 = zext i8 %conv177 to i64
  %shl179 = shl i32 %i.4, 3
  %sh_prom180 = zext i32 %shl179 to i64
  %shl181 = shl i64 %conv178, %sh_prom180
  %beeps182 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 67
  %47 = load i64, i64* %beeps182, align 8, !tbaa !120
  %or183 = or i64 %47, %shl181
  store i64 %or183, i64* %beeps182, align 8, !tbaa !120
  br label %LeafBlock5

LeafBlock5:                                       ; preds = %if.end172, %for.body167
  %inc188 = add nsw i32 %i.4, 1
  br label %for.cond164

for.end189:                                       ; preds = %for.cond164
  %48 = load volatile i64, i64* @jiffies, align 8, !tbaa !106
  %last_updated190 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 48
  store i64 %48, i64* %last_updated190, align 8, !tbaa !108
  %valid191 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 47
  store i8 1, i8* %valid191, align 8, !tbaa !109
  br label %if.end192

if.end192:                                        ; preds = %for.end189, %lor.lhs.false
  %update_lock193 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock193)
  ret %struct.nct6775_data* %0
}

declare i32 @sprintf(i8*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !98
  ret i8* %0
}

declare void @mutex_lock_nested(%struct.mutex*, i32) #2

; Function Attrs: nounwind uwtable
define internal void @nct6775_select_fan_div(%struct.device* %dev, %struct.nct6775_data* %data, i32 %nr, i16 zeroext %reg) #3 {
entry:
  %fan_div1 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %idxprom = sext i32 %nr to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div1, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %has_fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 59
  %1 = load i8, i8* %has_fan_div, align 1, !tbaa !65, !range !66
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %conv = zext i16 %reg to i32
  %cmp = icmp eq i32 %conv, 0
  %conv3 = zext i8 %0 to i32
  %cmp4 = icmp slt i32 %conv3, 7
  %or.cond = and i1 %cmp, %cmp4
  br i1 %or.cond, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %inc = add i8 %0, 1
  br label %if.end20

if.else:                                          ; preds = %if.end
  %conv7 = zext i16 %reg to i32
  %cmp8 = icmp ne i32 %conv7, 0
  %conv11 = zext i16 %reg to i32
  %cmp12 = icmp slt i32 %conv11, 48
  %or.cond1 = and i1 %cmp8, %cmp12
  %conv15 = zext i8 %0 to i32
  %cmp16 = icmp sgt i32 %conv15, 0
  %or.cond2 = and i1 %or.cond1, %cmp16
  %dec = add i8 %0, -1
  %fan_div.0 = select i1 %or.cond2, i8 %dec, i8 %0
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then6
  %fan_div.1 = phi i8 [ %inc, %if.then6 ], [ %fan_div.0, %if.else ]
  %conv21 = zext i8 %fan_div.1 to i32
  %fan_div22 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %idxprom23 = sext i32 %nr to i64
  %arrayidx24 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div22, i64 0, i64 %idxprom23
  %2 = load i8, i8* %arrayidx24, align 1, !tbaa !59
  %conv25 = zext i8 %2 to i32
  %cmp26 = icmp ne i32 %conv21, %conv25
  br i1 %cmp26, label %do.body29, label %cleanup.cont

do.body29:                                        ; preds = %if.end20
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @nct6775_select_fan_div.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool30 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool30, true
  %lnot31 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot31 to i32
  %conv32 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv32, i64 1)
  %tobool33 = icmp ne i64 %expval, 0
  br i1 %tobool33, label %if.then34, label %do.end41

if.then34:                                        ; preds = %do.body29
  %add = add nsw i32 %nr, 1
  %fan_div35 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %idxprom36 = sext i32 %nr to i64
  %arrayidx37 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div35, i64 0, i64 %idxprom36
  %3 = load i8, i8* %arrayidx37, align 1, !tbaa !59
  %call = call i32 @div_from_reg(i8 zeroext %3)
  %call38 = call i32 @div_from_reg(i8 zeroext %fan_div.1)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @nct6775_select_fan_div.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.60, i32 0, i32 0), i32 %add, i32 %call, i32 %call38)
  br label %do.end41

do.end41:                                         ; preds = %if.then34, %do.body29
  %has_fan_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 58
  %4 = load i8, i8* %has_fan_min, align 2, !tbaa !63
  %conv42 = zext i8 %4 to i32
  %shl = shl i32 1, %nr
  %and43 = and i32 %conv42, %shl
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then45, label %if.end98

if.then45:                                        ; preds = %do.end41
  %fan_min46 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 53
  %idxprom47 = sext i32 %nr to i64
  %arrayidx48 = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min46, i64 0, i64 %idxprom47
  %5 = load i16, i16* %arrayidx48, align 2, !tbaa !15
  %conv49 = zext i8 %fan_div.1 to i32
  %fan_div50 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %idxprom51 = sext i32 %nr to i64
  %arrayidx52 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div50, i64 0, i64 %idxprom51
  %6 = load i8, i8* %arrayidx52, align 1, !tbaa !59
  %conv53 = zext i8 %6 to i32
  %cmp54 = icmp sgt i32 %conv49, %conv53
  %conv57 = zext i16 %5 to i32
  %cmp58 = icmp ne i32 %conv57, 255
  br i1 %cmp54, label %if.then56, label %if.else68

if.then56:                                        ; preds = %if.then45
  %conv61 = zext i16 %5 to i32
  %cmp62 = icmp sgt i32 %conv61, 1
  %or.cond3 = and i1 %cmp58, %cmp62
  %conv65 = zext i16 %5 to i32
  %shr = ashr i32 %conv65, 1
  %conv66 = trunc i32 %shr to i16
  %fan_min.0 = select i1 %or.cond3, i16 %conv66, i16 %5
  br label %if.end82

if.else68:                                        ; preds = %if.then45
  br i1 %cmp58, label %if.then72, label %if.end82

if.then72:                                        ; preds = %if.else68
  %conv73 = zext i16 %5 to i32
  %shl74 = shl i32 %conv73, 1
  %conv75 = trunc i32 %shl74 to i16
  %conv76 = zext i16 %conv75 to i32
  %cmp77 = icmp sgt i32 %conv76, 254
  %.conv75 = select i1 %cmp77, i16 254, i16 %conv75
  br label %if.end82

if.end82:                                         ; preds = %if.then72, %if.else68, %if.then56
  %fan_min.3 = phi i16 [ %fan_min.0, %if.then56 ], [ %.conv75, %if.then72 ], [ %5, %if.else68 ]
  %conv83 = zext i16 %fan_min.3 to i32
  %fan_min84 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 53
  %idxprom85 = sext i32 %nr to i64
  %arrayidx86 = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min84, i64 0, i64 %idxprom85
  %7 = load i16, i16* %arrayidx86, align 2, !tbaa !15
  %conv87 = zext i16 %7 to i32
  %cmp88 = icmp ne i32 %conv83, %conv87
  br i1 %cmp88, label %if.then90, label %if.end98

if.then90:                                        ; preds = %if.end82
  %fan_min91 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 53
  %idxprom92 = sext i32 %nr to i64
  %arrayidx93 = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min91, i64 0, i64 %idxprom92
  store i16 %fan_min.3, i16* %arrayidx93, align 2, !tbaa !15
  %REG_FAN_MIN = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 21
  %8 = load i16*, i16** %REG_FAN_MIN, align 8, !tbaa !67
  %idxprom94 = sext i32 %nr to i64
  %arrayidx95 = getelementptr inbounds i16, i16* %8, i64 %idxprom94
  %9 = load i16, i16* %arrayidx95, align 2, !tbaa !15
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %9, i16 zeroext %fan_min.3)
  br label %if.end98

if.end98:                                         ; preds = %if.then90, %if.end82, %do.end41
  %fan_div99 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 55
  %idxprom100 = sext i32 %nr to i64
  %arrayidx101 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div99, i64 0, i64 %idxprom100
  store i8 %fan_div.1, i8* %arrayidx101, align 1, !tbaa !59
  call void @nct6775_write_fan_div_common(%struct.nct6775_data* %data, i32 %nr)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end98, %if.end20, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @nct6775_update_pwm(%struct.device* %dev) #3 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  br label %for.cond

for.cond:                                         ; preds = %for.inc173, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc174, %for.inc173 ]
  %pwm_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 68
  %1 = load i8, i8* %pwm_num, align 8, !tbaa !47
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end175

for.body:                                         ; preds = %for.cond
  %has_pwm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 56
  %2 = load i8, i8* %has_pwm, align 8, !tbaa !64
  %conv2 = zext i8 %2 to i32
  %shl = shl i32 1, %i.0
  %and = and i32 %conv2, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %for.inc173

if.end:                                           ; preds = %for.body
  %REG_PWM_MODE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 26
  %3 = load i8*, i8** %REG_PWM_MODE, align 8, !tbaa !122
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %3, i64 %idxprom
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv3 = zext i8 %4 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %REG_PWM_MODE5 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 26
  %5 = load i8*, i8** %REG_PWM_MODE5, align 8, !tbaa !122
  %idxprom6 = sext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds i8, i8* %5, i64 %idxprom6
  %6 = load i8, i8* %arrayidx7, align 1, !tbaa !59
  %conv8 = zext i8 %6 to i16
  %call9 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %conv8)
  %conv10 = zext i16 %call9 to i32
  %PWM_MODE_MASK = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 27
  %7 = load i8*, i8** %PWM_MODE_MASK, align 8, !tbaa !123
  %idxprom11 = sext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds i8, i8* %7, i64 %idxprom11
  %8 = load i8, i8* %arrayidx12, align 1, !tbaa !59
  %conv13 = zext i8 %8 to i32
  %and14 = and i32 %conv10, %conv13
  %tobool15 = icmp ne i32 %and14, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %9 = phi i1 [ false, %if.end ], [ %tobool15, %land.rhs ]
  %frombool = zext i1 %9 to i8
  %tobool16 = trunc i8 %frombool to i1
  %conv17 = zext i1 %tobool16 to i8
  %pwm_mode = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 69
  %idxprom18 = sext i32 %i.0 to i64
  %arrayidx19 = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_mode, i64 0, i64 %idxprom18
  store i8 %conv17, i8* %arrayidx19, align 1, !tbaa !59
  %REG_FAN_MODE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 20
  %10 = load i16*, i16** %REG_FAN_MODE, align 8, !tbaa !124
  %idxprom20 = sext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds i16, i16* %10, i64 %idxprom20
  %11 = load i16, i16* %arrayidx21, align 2, !tbaa !15
  %call22 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %11)
  %conv23 = zext i16 %call22 to i32
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc, %land.end
  %j.0 = phi i32 [ 0, %land.end ], [ %inc, %for.inc ]
  %conv25 = sext i32 %j.0 to i64
  %cmp26 = icmp ult i64 %conv25, 7
  br i1 %cmp26, label %for.body28, label %for.end

for.body28:                                       ; preds = %for.cond24
  %REG_PWM = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 28
  %idxprom29 = sext i32 %j.0 to i64
  %arrayidx30 = getelementptr inbounds [7 x i16*], [7 x i16*]* %REG_PWM, i64 0, i64 %idxprom29
  %12 = load i16*, i16** %arrayidx30, align 8, !tbaa !6
  %tobool31 = icmp ne i16* %12, null
  br i1 %tobool31, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body28
  %REG_PWM32 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 28
  %idxprom33 = sext i32 %j.0 to i64
  %arrayidx34 = getelementptr inbounds [7 x i16*], [7 x i16*]* %REG_PWM32, i64 0, i64 %idxprom33
  %13 = load i16*, i16** %arrayidx34, align 8, !tbaa !6
  %idxprom35 = sext i32 %i.0 to i64
  %arrayidx36 = getelementptr inbounds i16, i16* %13, i64 %idxprom35
  %14 = load i16, i16* %arrayidx36, align 2, !tbaa !15
  %conv37 = zext i16 %14 to i32
  %tobool38 = icmp ne i32 %conv37, 0
  br i1 %tobool38, label %if.then39, label %for.inc

if.then39:                                        ; preds = %land.lhs.true
  %REG_PWM40 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 28
  %idxprom41 = sext i32 %j.0 to i64
  %arrayidx42 = getelementptr inbounds [7 x i16*], [7 x i16*]* %REG_PWM40, i64 0, i64 %idxprom41
  %15 = load i16*, i16** %arrayidx42, align 8, !tbaa !6
  %idxprom43 = sext i32 %i.0 to i64
  %arrayidx44 = getelementptr inbounds i16, i16* %15, i64 %idxprom43
  %16 = load i16, i16* %arrayidx44, align 2, !tbaa !15
  %call45 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %16)
  %conv46 = trunc i16 %call45 to i8
  %pwm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 71
  %idxprom47 = sext i32 %j.0 to i64
  %arrayidx48 = getelementptr inbounds [7 x [6 x i8]], [7 x [6 x i8]]* %pwm, i64 0, i64 %idxprom47
  %idxprom49 = sext i32 %i.0 to i64
  %arrayidx50 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx48, i64 0, i64 %idxprom49
  store i8 %conv46, i8* %arrayidx50, align 1, !tbaa !59
  br label %for.inc

for.inc:                                          ; preds = %if.then39, %land.lhs.true, %for.body28
  %inc = add nsw i32 %j.0, 1
  br label %for.cond24

for.end:                                          ; preds = %for.cond24
  %pwm52 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 71
  %arrayidx53 = getelementptr inbounds [7 x [6 x i8]], [7 x [6 x i8]]* %pwm52, i64 0, i64 0
  %idxprom54 = sext i32 %i.0 to i64
  %arrayidx55 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx53, i64 0, i64 %idxprom54
  %17 = load i8, i8* %arrayidx55, align 1, !tbaa !59
  %conv56 = zext i8 %17 to i32
  %shr = ashr i32 %conv23, 4
  %and57 = and i32 %shr, 7
  %call58 = call i32 @reg_to_pwm_enable(i32 %conv56, i32 %and57)
  %pwm_enable = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 70
  %idxprom59 = sext i32 %i.0 to i64
  %arrayidx60 = getelementptr inbounds [6 x i32], [6 x i32]* %pwm_enable, i64 0, i64 %idxprom59
  store i32 %call58, i32* %arrayidx60, align 4, !tbaa !59
  %temp_tolerance = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 77
  %arrayidx61 = getelementptr inbounds [2 x [6 x i8]], [2 x [6 x i8]]* %temp_tolerance, i64 0, i64 0
  %idxprom62 = sext i32 %i.0 to i64
  %arrayidx63 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx61, i64 0, i64 %idxprom62
  %18 = load i8, i8* %arrayidx63, align 1, !tbaa !59
  %tobool64 = icmp ne i8 %18, 0
  br i1 %tobool64, label %lor.lhs.false, label %if.then70

lor.lhs.false:                                    ; preds = %for.end
  %pwm_enable65 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 70
  %idxprom66 = sext i32 %i.0 to i64
  %arrayidx67 = getelementptr inbounds [6 x i32], [6 x i32]* %pwm_enable65, i64 0, i64 %idxprom66
  %19 = load i32, i32* %arrayidx67, align 4, !tbaa !59
  %cmp68 = icmp ne i32 %19, 3
  br i1 %cmp68, label %if.then70, label %if.end77

if.then70:                                        ; preds = %lor.lhs.false, %for.end
  %and71 = and i32 %conv23, 15
  %conv72 = trunc i32 %and71 to i8
  %temp_tolerance73 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 77
  %arrayidx74 = getelementptr inbounds [2 x [6 x i8]], [2 x [6 x i8]]* %temp_tolerance73, i64 0, i64 0
  %idxprom75 = sext i32 %i.0 to i64
  %arrayidx76 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx74, i64 0, i64 %idxprom75
  store i8 %conv72, i8* %arrayidx76, align 1, !tbaa !59
  br label %if.end77

if.end77:                                         ; preds = %if.then70, %lor.lhs.false
  %target_speed_tolerance = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 75
  %idxprom78 = sext i32 %i.0 to i64
  %arrayidx79 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed_tolerance, i64 0, i64 %idxprom78
  %20 = load i32, i32* %arrayidx79, align 4, !tbaa !2
  %tobool80 = icmp ne i32 %20, 0
  br i1 %tobool80, label %lor.lhs.false81, label %if.then87

lor.lhs.false81:                                  ; preds = %if.end77
  %pwm_enable82 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 70
  %idxprom83 = sext i32 %i.0 to i64
  %arrayidx84 = getelementptr inbounds [6 x i32], [6 x i32]* %pwm_enable82, i64 0, i64 %idxprom83
  %21 = load i32, i32* %arrayidx84, align 4, !tbaa !59
  %cmp85 = icmp eq i32 %21, 3
  br i1 %cmp85, label %if.then87, label %if.end106

if.then87:                                        ; preds = %lor.lhs.false81, %if.end77
  %and88 = and i32 %conv23, 15
  %conv89 = trunc i32 %and88 to i8
  %REG_TOLERANCE_H = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 25
  %22 = load i16*, i16** %REG_TOLERANCE_H, align 8, !tbaa !125
  %tobool90 = icmp ne i16* %22, null
  br i1 %tobool90, label %if.then91, label %if.end101

if.then91:                                        ; preds = %if.then87
  %REG_TOLERANCE_H92 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 25
  %23 = load i16*, i16** %REG_TOLERANCE_H92, align 8, !tbaa !125
  %idxprom93 = sext i32 %i.0 to i64
  %arrayidx94 = getelementptr inbounds i16, i16* %23, i64 %idxprom93
  %24 = load i16, i16* %arrayidx94, align 2, !tbaa !15
  %call95 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %24)
  %conv96 = zext i16 %call95 to i32
  %and97 = and i32 %conv96, 112
  %shr98 = ashr i32 %and97, 1
  %conv99 = zext i8 %conv89 to i32
  %or = or i32 %conv99, %shr98
  %conv100 = trunc i32 %or to i8
  br label %if.end101

if.end101:                                        ; preds = %if.then91, %if.then87
  %t.0 = phi i8 [ %conv100, %if.then91 ], [ %conv89, %if.then87 ]
  %conv102 = zext i8 %t.0 to i32
  %target_speed_tolerance103 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 75
  %idxprom104 = sext i32 %i.0 to i64
  %arrayidx105 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed_tolerance103, i64 0, i64 %idxprom104
  store i32 %conv102, i32* %arrayidx105, align 4, !tbaa !2
  br label %if.end106

if.end106:                                        ; preds = %if.end101, %lor.lhs.false81
  %REG_CRITICAL_TEMP_TOLERANCE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 36
  %25 = load i16*, i16** %REG_CRITICAL_TEMP_TOLERANCE, align 8, !tbaa !126
  %idxprom107 = sext i32 %i.0 to i64
  %arrayidx108 = getelementptr inbounds i16, i16* %25, i64 %idxprom107
  %26 = load i16, i16* %arrayidx108, align 2, !tbaa !15
  %call109 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %26)
  %conv110 = trunc i16 %call109 to i8
  %temp_tolerance111 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 77
  %arrayidx112 = getelementptr inbounds [2 x [6 x i8]], [2 x [6 x i8]]* %temp_tolerance111, i64 0, i64 1
  %idxprom113 = sext i32 %i.0 to i64
  %arrayidx114 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx112, i64 0, i64 %idxprom113
  store i8 %conv110, i8* %arrayidx114, align 1, !tbaa !59
  %REG_TEMP_SEL = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 38
  %27 = load i16*, i16** %REG_TEMP_SEL, align 8, !tbaa !107
  %idxprom115 = sext i32 %i.0 to i64
  %arrayidx116 = getelementptr inbounds i16, i16* %27, i64 %idxprom115
  %28 = load i16, i16* %arrayidx116, align 2, !tbaa !15
  %call117 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %28)
  %conv118 = zext i16 %call117 to i32
  %and119 = and i32 %conv118, 31
  %conv120 = trunc i32 %and119 to i8
  %pwm_temp_sel = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 83
  %idxprom121 = sext i32 %i.0 to i64
  %arrayidx122 = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_temp_sel, i64 0, i64 %idxprom121
  store i8 %conv120, i8* %arrayidx122, align 1, !tbaa !59
  %and123 = and i32 %conv118, 128
  %tobool124 = icmp ne i32 %and123, 0
  br i1 %tobool124, label %if.then125, label %if.end130

if.then125:                                       ; preds = %if.end106
  %pwm126 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 71
  %arrayidx127 = getelementptr inbounds [7 x [6 x i8]], [7 x [6 x i8]]* %pwm126, i64 0, i64 2
  %idxprom128 = sext i32 %i.0 to i64
  %arrayidx129 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx127, i64 0, i64 %idxprom128
  store i8 0, i8* %arrayidx129, align 1, !tbaa !59
  br label %if.end130

if.end130:                                        ; preds = %if.then125, %if.end106
  %REG_WEIGHT_TEMP_SEL = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 39
  %29 = load i16*, i16** %REG_WEIGHT_TEMP_SEL, align 8, !tbaa !102
  %idxprom131 = sext i32 %i.0 to i64
  %arrayidx132 = getelementptr inbounds i16, i16* %29, i64 %idxprom131
  %30 = load i16, i16* %arrayidx132, align 2, !tbaa !15
  %tobool133 = icmp ne i16 %30, 0
  br i1 %tobool133, label %if.end135, label %for.inc173

if.end135:                                        ; preds = %if.end130
  %REG_WEIGHT_TEMP_SEL136 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 39
  %31 = load i16*, i16** %REG_WEIGHT_TEMP_SEL136, align 8, !tbaa !102
  %idxprom137 = sext i32 %i.0 to i64
  %arrayidx138 = getelementptr inbounds i16, i16* %31, i64 %idxprom137
  %32 = load i16, i16* %arrayidx138, align 2, !tbaa !15
  %call139 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %32)
  %conv140 = zext i16 %call139 to i32
  %and141 = and i32 %conv140, 31
  %conv142 = trunc i32 %and141 to i8
  %pwm_weight_temp_sel = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 84
  %idxprom143 = sext i32 %i.0 to i64
  %arrayidx144 = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_weight_temp_sel, i64 0, i64 %idxprom143
  store i8 %conv142, i8* %arrayidx144, align 1, !tbaa !59
  %cmp145 = icmp ne i32 %j.0, 1
  %and148 = and i32 %conv140, 128
  %tobool149 = icmp ne i32 %and148, 0
  %or.cond = or i1 %cmp145, %tobool149
  br i1 %or.cond, label %if.end154, label %if.then150

if.then150:                                       ; preds = %if.end135
  %pwm_weight_temp_sel151 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 84
  %idxprom152 = sext i32 %i.0 to i64
  %arrayidx153 = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_weight_temp_sel151, i64 0, i64 %idxprom152
  store i8 0, i8* %arrayidx153, align 1, !tbaa !59
  br label %if.end154

if.end154:                                        ; preds = %if.then150, %if.end135
  br label %for.cond155

for.cond155:                                      ; preds = %for.body159, %if.end154
  %j.1 = phi i32 [ 0, %if.end154 ], [ %inc171, %for.body159 ]
  %conv156 = sext i32 %j.1 to i64
  %cmp157 = icmp ult i64 %conv156, 3
  br i1 %cmp157, label %for.body159, label %for.inc173

for.body159:                                      ; preds = %for.cond155
  %REG_WEIGHT_TEMP = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 40
  %idxprom160 = sext i32 %j.1 to i64
  %arrayidx161 = getelementptr inbounds [3 x i16*], [3 x i16*]* %REG_WEIGHT_TEMP, i64 0, i64 %idxprom160
  %33 = load i16*, i16** %arrayidx161, align 8, !tbaa !6
  %idxprom162 = sext i32 %i.0 to i64
  %arrayidx163 = getelementptr inbounds i16, i16* %33, i64 %idxprom162
  %34 = load i16, i16* %arrayidx163, align 2, !tbaa !15
  %call164 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %34)
  %conv165 = trunc i16 %call164 to i8
  %weight_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 85
  %idxprom166 = sext i32 %j.1 to i64
  %arrayidx167 = getelementptr inbounds [3 x [6 x i8]], [3 x [6 x i8]]* %weight_temp, i64 0, i64 %idxprom166
  %idxprom168 = sext i32 %i.0 to i64
  %arrayidx169 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx167, i64 0, i64 %idxprom168
  store i8 %conv165, i8* %arrayidx169, align 1, !tbaa !59
  %inc171 = add nsw i32 %j.1, 1
  br label %for.cond155

for.inc173:                                       ; preds = %for.cond155, %if.end130, %for.body
  %inc174 = add nsw i32 %i.0, 1
  br label %for.cond

for.end175:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @nct6775_update_pwm_limits(%struct.device* %dev) #3 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  br label %for.cond

for.cond:                                         ; preds = %for.inc142, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc143, %for.inc142 ]
  %pwm_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 68
  %1 = load i8, i8* %pwm_num, align 8, !tbaa !47
  %conv = zext i8 %1 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %for.end144

for.body:                                         ; preds = %for.cond
  %has_pwm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 56
  %2 = load i8, i8* %has_pwm, align 8, !tbaa !64
  %conv2 = zext i8 %2 to i32
  %shl = shl i32 1, %i.0
  %and = and i32 %conv2, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %for.inc142

if.end:                                           ; preds = %for.body
  br label %for.cond3

for.cond3:                                        ; preds = %for.body7, %if.end
  %j.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body7 ]
  %conv4 = sext i32 %j.0 to i64
  %cmp5 = icmp ult i64 %conv4, 3
  br i1 %cmp5, label %for.body7, label %for.end

for.body7:                                        ; preds = %for.cond3
  %REG_FAN_TIME = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 24
  %idxprom = sext i32 %j.0 to i64
  %arrayidx = getelementptr inbounds [3 x i16*], [3 x i16*]* %REG_FAN_TIME, i64 0, i64 %idxprom
  %3 = load i16*, i16** %arrayidx, align 8, !tbaa !6
  %idxprom8 = sext i32 %i.0 to i64
  %arrayidx9 = getelementptr inbounds i16, i16* %3, i64 %idxprom8
  %4 = load i16, i16* %arrayidx9, align 2, !tbaa !15
  %call10 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %4)
  %conv11 = trunc i16 %call10 to i8
  %fan_time = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 79
  %idxprom12 = sext i32 %j.0 to i64
  %arrayidx13 = getelementptr inbounds [3 x [6 x i8]], [3 x [6 x i8]]* %fan_time, i64 0, i64 %idxprom12
  %idxprom14 = sext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx13, i64 0, i64 %idxprom14
  store i8 %conv11, i8* %arrayidx15, align 1, !tbaa !59
  %inc = add nsw i32 %j.0, 1
  br label %for.cond3

for.end:                                          ; preds = %for.cond3
  %REG_TARGET = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 18
  %5 = load i16*, i16** %REG_TARGET, align 8, !tbaa !127
  %idxprom16 = sext i32 %i.0 to i64
  %arrayidx17 = getelementptr inbounds i16, i16* %5, i64 %idxprom16
  %6 = load i16, i16* %arrayidx17, align 2, !tbaa !15
  %call18 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %6)
  %target_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 72
  %idxprom19 = sext i32 %i.0 to i64
  %arrayidx20 = getelementptr inbounds [6 x i8], [6 x i8]* %target_temp, i64 0, i64 %idxprom19
  %7 = load i8, i8* %arrayidx20, align 1, !tbaa !59
  %tobool21 = icmp ne i8 %7, 0
  br i1 %tobool21, label %lor.lhs.false, label %if.then26

lor.lhs.false:                                    ; preds = %for.end
  %pwm_enable = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 70
  %idxprom22 = sext i32 %i.0 to i64
  %arrayidx23 = getelementptr inbounds [6 x i32], [6 x i32]* %pwm_enable, i64 0, i64 %idxprom22
  %8 = load i32, i32* %arrayidx23, align 4, !tbaa !59
  %cmp24 = icmp eq i32 %8, 2
  br i1 %cmp24, label %if.then26, label %if.end34

if.then26:                                        ; preds = %lor.lhs.false, %for.end
  %conv27 = zext i16 %call18 to i32
  %target_temp_mask = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 73
  %9 = load i8, i8* %target_temp_mask, align 8, !tbaa !128
  %conv28 = zext i8 %9 to i32
  %and29 = and i32 %conv27, %conv28
  %conv30 = trunc i32 %and29 to i8
  %target_temp31 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 72
  %idxprom32 = sext i32 %i.0 to i64
  %arrayidx33 = getelementptr inbounds [6 x i8], [6 x i8]* %target_temp31, i64 0, i64 %idxprom32
  store i8 %conv30, i8* %arrayidx33, align 1, !tbaa !59
  br label %if.end34

if.end34:                                         ; preds = %if.then26, %lor.lhs.false
  %target_speed = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 74
  %idxprom35 = sext i32 %i.0 to i64
  %arrayidx36 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed, i64 0, i64 %idxprom35
  %10 = load i32, i32* %arrayidx36, align 4, !tbaa !2
  %tobool37 = icmp ne i32 %10, 0
  br i1 %tobool37, label %lor.lhs.false38, label %if.then44

lor.lhs.false38:                                  ; preds = %if.end34
  %pwm_enable39 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 70
  %idxprom40 = sext i32 %i.0 to i64
  %arrayidx41 = getelementptr inbounds [6 x i32], [6 x i32]* %pwm_enable39, i64 0, i64 %idxprom40
  %11 = load i32, i32* %arrayidx41, align 4, !tbaa !59
  %cmp42 = icmp eq i32 %11, 3
  br i1 %cmp42, label %if.then44, label %if.end61

if.then44:                                        ; preds = %lor.lhs.false38, %if.end34
  %REG_TOLERANCE_H = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 25
  %12 = load i16*, i16** %REG_TOLERANCE_H, align 8, !tbaa !125
  %tobool45 = icmp ne i16* %12, null
  br i1 %tobool45, label %if.then46, label %if.end56

if.then46:                                        ; preds = %if.then44
  %REG_TOLERANCE_H47 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 25
  %13 = load i16*, i16** %REG_TOLERANCE_H47, align 8, !tbaa !125
  %idxprom48 = sext i32 %i.0 to i64
  %arrayidx49 = getelementptr inbounds i16, i16* %13, i64 %idxprom48
  %14 = load i16, i16* %arrayidx49, align 2, !tbaa !15
  %call50 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %14)
  %conv51 = zext i16 %call50 to i32
  %and52 = and i32 %conv51, 15
  %shl53 = shl i32 %and52, 8
  %conv54 = zext i16 %call18 to i32
  %or = or i32 %conv54, %shl53
  %conv55 = trunc i32 %or to i16
  br label %if.end56

if.end56:                                         ; preds = %if.then46, %if.then44
  %reg_t.0 = phi i16 [ %conv55, %if.then46 ], [ %call18, %if.then44 ]
  %conv57 = zext i16 %reg_t.0 to i32
  %target_speed58 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 74
  %idxprom59 = sext i32 %i.0 to i64
  %arrayidx60 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed58, i64 0, i64 %idxprom59
  store i32 %conv57, i32* %arrayidx60, align 4, !tbaa !2
  br label %if.end61

if.end61:                                         ; preds = %if.end56, %lor.lhs.false38
  br label %for.cond62

for.cond62:                                       ; preds = %for.body65, %if.end61
  %j.1 = phi i32 [ 0, %if.end61 ], [ %inc88, %for.body65 ]
  %auto_pwm_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 80
  %15 = load i32, i32* %auto_pwm_num, align 4, !tbaa !103
  %cmp63 = icmp slt i32 %j.1, %15
  br i1 %cmp63, label %for.body65, label %for.end89

for.body65:                                       ; preds = %for.cond62
  %REG_AUTO_PWM = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 34
  %16 = load i16*, i16** %REG_AUTO_PWM, align 8, !tbaa !129
  %idxprom66 = sext i32 %i.0 to i64
  %arrayidx67 = getelementptr inbounds i16, i16* %16, i64 %idxprom66
  %17 = load i16, i16* %arrayidx67, align 2, !tbaa !15
  %conv68 = zext i16 %17 to i32
  %add = add nsw i32 %conv68, %j.1
  %conv69 = trunc i32 %add to i16
  %call70 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %conv69)
  %conv71 = trunc i16 %call70 to i8
  %auto_pwm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 81
  %idxprom72 = sext i32 %i.0 to i64
  %arrayidx73 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_pwm, i64 0, i64 %idxprom72
  %idxprom74 = sext i32 %j.1 to i64
  %arrayidx75 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx73, i64 0, i64 %idxprom74
  store i8 %conv71, i8* %arrayidx75, align 1, !tbaa !59
  %REG_AUTO_TEMP = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 33
  %18 = load i16*, i16** %REG_AUTO_TEMP, align 8, !tbaa !130
  %idxprom76 = sext i32 %i.0 to i64
  %arrayidx77 = getelementptr inbounds i16, i16* %18, i64 %idxprom76
  %19 = load i16, i16* %arrayidx77, align 2, !tbaa !15
  %conv78 = zext i16 %19 to i32
  %add79 = add nsw i32 %conv78, %j.1
  %conv80 = trunc i32 %add79 to i16
  %call81 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %conv80)
  %conv82 = trunc i16 %call81 to i8
  %auto_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 82
  %idxprom83 = sext i32 %i.0 to i64
  %arrayidx84 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_temp, i64 0, i64 %idxprom83
  %idxprom85 = sext i32 %j.1 to i64
  %arrayidx86 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx84, i64 0, i64 %idxprom85
  store i8 %conv82, i8* %arrayidx86, align 1, !tbaa !59
  %inc88 = add nsw i32 %j.1, 1
  br label %for.cond62

for.end89:                                        ; preds = %for.cond62
  %REG_CRITICAL_TEMP = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 35
  %20 = load i16*, i16** %REG_CRITICAL_TEMP, align 8, !tbaa !131
  %idxprom90 = sext i32 %i.0 to i64
  %arrayidx91 = getelementptr inbounds i16, i16* %20, i64 %idxprom90
  %21 = load i16, i16* %arrayidx91, align 2, !tbaa !15
  %call92 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %21)
  %conv93 = trunc i16 %call92 to i8
  %auto_temp94 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 82
  %idxprom95 = sext i32 %i.0 to i64
  %arrayidx96 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_temp94, i64 0, i64 %idxprom95
  %auto_pwm_num97 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 80
  %22 = load i32, i32* %auto_pwm_num97, align 4, !tbaa !103
  %idxprom98 = sext i32 %22 to i64
  %arrayidx99 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx96, i64 0, i64 %idxprom98
  store i8 %conv93, i8* %arrayidx99, align 1, !tbaa !59
  %kind = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 2
  %23 = load i32, i32* %kind, align 8, !tbaa !44
  %Pivot6 = icmp slt i32 %23, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %for.end89
  %Pivot4 = icmp slt i32 %23, 3
  br i1 %Pivot4, label %sw.bb114, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %.off = add i32 %23, -3
  %SwitchLeaf2 = icmp ule i32 %.off, 3
  br i1 %SwitchLeaf2, label %sw.bb121, label %for.inc142

NodeBlock:                                        ; preds = %for.end89
  %Pivot = icmp slt i32 %23, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %23, 0
  br i1 %SwitchLeaf, label %sw.bb121, label %for.inc142

sw.bb:                                            ; preds = %NodeBlock
  %idxprom100 = sext i32 %i.0 to i64
  %arrayidx101 = getelementptr inbounds [3 x i16], [3 x i16]* @NCT6775_REG_CRITICAL_ENAB, i64 0, i64 %idxprom100
  %24 = load i16, i16* %arrayidx101, align 2, !tbaa !15
  %call102 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %24)
  %conv103 = trunc i16 %call102 to i8
  %conv104 = zext i8 %conv103 to i32
  %and105 = and i32 %conv104, 2
  %tobool106 = icmp ne i32 %and105, 0
  %cond = select i1 %tobool106, i32 255, i32 0
  %conv107 = trunc i32 %cond to i8
  %auto_pwm108 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 81
  %idxprom109 = sext i32 %i.0 to i64
  %arrayidx110 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_pwm108, i64 0, i64 %idxprom109
  %auto_pwm_num111 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 80
  %25 = load i32, i32* %auto_pwm_num111, align 4, !tbaa !103
  %idxprom112 = sext i32 %25 to i64
  %arrayidx113 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx110, i64 0, i64 %idxprom112
  store i8 %conv107, i8* %arrayidx113, align 1, !tbaa !59
  br label %for.inc142

sw.bb114:                                         ; preds = %NodeBlock3
  %auto_pwm115 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 81
  %idxprom116 = sext i32 %i.0 to i64
  %arrayidx117 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_pwm115, i64 0, i64 %idxprom116
  %auto_pwm_num118 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 80
  %26 = load i32, i32* %auto_pwm_num118, align 4, !tbaa !103
  %idxprom119 = sext i32 %26 to i64
  %arrayidx120 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx117, i64 0, i64 %idxprom119
  store i8 -1, i8* %arrayidx120, align 1, !tbaa !59
  br label %for.inc142

sw.bb121:                                         ; preds = %LeafBlock, %LeafBlock1
  %REG_CRITICAL_PWM_ENABLE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 30
  %27 = load i16*, i16** %REG_CRITICAL_PWM_ENABLE, align 8, !tbaa !132
  %idxprom122 = sext i32 %i.0 to i64
  %arrayidx123 = getelementptr inbounds i16, i16* %27, i64 %idxprom122
  %28 = load i16, i16* %arrayidx123, align 2, !tbaa !15
  %call124 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %28)
  %conv125 = trunc i16 %call124 to i8
  %conv126 = zext i8 %conv125 to i32
  %CRITICAL_PWM_ENABLE_MASK = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 31
  %29 = load i8, i8* %CRITICAL_PWM_ENABLE_MASK, align 8, !tbaa !133
  %conv127 = zext i8 %29 to i32
  %and128 = and i32 %conv126, %conv127
  %tobool129 = icmp ne i32 %and128, 0
  br i1 %tobool129, label %if.then130, label %if.end135

if.then130:                                       ; preds = %sw.bb121
  %REG_CRITICAL_PWM = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 32
  %30 = load i16*, i16** %REG_CRITICAL_PWM, align 8, !tbaa !134
  %idxprom131 = sext i32 %i.0 to i64
  %arrayidx132 = getelementptr inbounds i16, i16* %30, i64 %idxprom131
  %31 = load i16, i16* %arrayidx132, align 2, !tbaa !15
  %call133 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %31)
  %conv134 = trunc i16 %call133 to i8
  br label %if.end135

if.end135:                                        ; preds = %if.then130, %sw.bb121
  %reg.0 = phi i8 [ %conv134, %if.then130 ], [ -1, %sw.bb121 ]
  %auto_pwm136 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 81
  %idxprom137 = sext i32 %i.0 to i64
  %arrayidx138 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_pwm136, i64 0, i64 %idxprom137
  %auto_pwm_num139 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 80
  %32 = load i32, i32* %auto_pwm_num139, align 4, !tbaa !103
  %idxprom140 = sext i32 %32 to i64
  %arrayidx141 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx138, i64 0, i64 %idxprom140
  store i8 %reg.0, i8* %arrayidx141, align 1, !tbaa !59
  br label %for.inc142

for.inc142:                                       ; preds = %if.end135, %sw.bb114, %sw.bb, %LeafBlock, %LeafBlock1, %for.body
  %inc143 = add nsw i32 %i.0, 1
  br label %for.cond

for.end144:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @nct6775_read_temp(%struct.nct6775_data* %data, i16 zeroext %reg) #3 {
entry:
  %call = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %reg)
  %call1 = call zeroext i1 @is_word_sized(%struct.nct6775_data* %data, i16 zeroext %reg)
  %conv = zext i16 %call to i32
  %shl = shl i32 %conv, 8
  %conv2 = trunc i32 %shl to i16
  %res.0 = select i1 %call1, i16 %call, i16 %conv2
  ret i16 %res.0
}

declare void @mutex_unlock(%struct.mutex*) #2

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

declare void @__dynamic_dev_dbg(%struct._ddebug*, %struct.device*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @div_from_reg(i8 zeroext %reg) #4 {
entry:
  %conv = zext i8 %reg to i32
  %shl = shl i32 1, %conv
  ret i32 %shl
}

; Function Attrs: nounwind uwtable
define internal i32 @reg_to_pwm_enable(i32 %pwm, i32 %mode) #3 {
entry:
  %cmp = icmp eq i32 %mode, 0
  %cmp1 = icmp eq i32 %pwm, 255
  %or.cond = and i1 %cmp, %cmp1
  %add = add nsw i32 %mode, 1
  %retval.0 = select i1 %or.cond, i32 0, i32 %add
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #4 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

declare i32 @kstrtoull(i8*, i32, i64*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_mode(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_mode(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !94
  %4 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %val, align 8, !tbaa !106
  %cmp2 = icmp ugt i64 %5, 1
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %REG_PWM_MODE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 26
  %6 = load i8*, i8** %REG_PWM_MODE, align 8, !tbaa !122
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds i8, i8* %6, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv6 = zext i8 %7 to i32
  %cmp7 = icmp eq i32 %conv6, 0
  br i1 %cmp7, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end5
  %8 = load i64, i64* %val, align 8, !tbaa !106
  %tobool = icmp ne i64 %8, 0
  %.count = select i1 %tobool, i64 -22, i64 %count
  br label %cleanup

if.end12:                                         ; preds = %if.end5
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %9 = load i64, i64* %val, align 8, !tbaa !106
  %conv13 = trunc i64 %9 to i8
  %pwm_mode = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 69
  %idxprom14 = sext i32 %3 to i64
  %arrayidx15 = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_mode, i64 0, i64 %idxprom14
  store i8 %conv13, i8* %arrayidx15, align 1, !tbaa !59
  %REG_PWM_MODE16 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 26
  %10 = load i8*, i8** %REG_PWM_MODE16, align 8, !tbaa !122
  %idxprom17 = sext i32 %3 to i64
  %arrayidx18 = getelementptr inbounds i8, i8* %10, i64 %idxprom17
  %11 = load i8, i8* %arrayidx18, align 1, !tbaa !59
  %conv19 = zext i8 %11 to i16
  %call20 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %conv19)
  %conv21 = trunc i16 %call20 to i8
  %PWM_MODE_MASK = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 27
  %12 = load i8*, i8** %PWM_MODE_MASK, align 8, !tbaa !123
  %idxprom22 = sext i32 %3 to i64
  %arrayidx23 = getelementptr inbounds i8, i8* %12, i64 %idxprom22
  %13 = load i8, i8* %arrayidx23, align 1, !tbaa !59
  %conv24 = zext i8 %13 to i32
  %neg = xor i32 %conv24, -1
  %conv25 = zext i8 %conv21 to i32
  %and = and i32 %conv25, %neg
  %conv26 = trunc i32 %and to i8
  %14 = load i64, i64* %val, align 8, !tbaa !106
  %tobool27 = icmp ne i64 %14, 0
  br i1 %tobool27, label %if.then28, label %if.end35

if.then28:                                        ; preds = %if.end12
  %PWM_MODE_MASK29 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 27
  %15 = load i8*, i8** %PWM_MODE_MASK29, align 8, !tbaa !123
  %idxprom30 = sext i32 %3 to i64
  %arrayidx31 = getelementptr inbounds i8, i8* %15, i64 %idxprom30
  %16 = load i8, i8* %arrayidx31, align 1, !tbaa !59
  %conv32 = zext i8 %16 to i32
  %conv33 = zext i8 %conv26 to i32
  %or = or i32 %conv33, %conv32
  %conv34 = trunc i32 %or to i8
  br label %if.end35

if.end35:                                         ; preds = %if.then28, %if.end12
  %reg.0 = phi i8 [ %conv34, %if.then28 ], [ %conv26, %if.end12 ]
  %REG_PWM_MODE36 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 26
  %17 = load i8*, i8** %REG_PWM_MODE36, align 8, !tbaa !122
  %idxprom37 = sext i32 %3 to i64
  %arrayidx38 = getelementptr inbounds i8, i8* %17, i64 %idxprom37
  %18 = load i8, i8* %arrayidx38, align 1, !tbaa !59
  %conv39 = zext i8 %18 to i16
  %conv40 = zext i8 %reg.0 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %conv39, i16 zeroext %conv40)
  %update_lock42 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock42)
  br label %cleanup

cleanup:                                          ; preds = %if.end35, %if.then9, %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end35 ], [ -22, %if.end ], [ %.count, %if.then9 ]
  %19 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_enable(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_enable(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !94
  %4 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %val, align 8, !tbaa !106
  %cmp2 = icmp ugt i64 %5, 5
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %6 = load i64, i64* %val, align 8, !tbaa !106
  %cmp6 = icmp eq i64 %6, 4
  br i1 %cmp6, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.end5
  %kind = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 2
  %7 = load i32, i32* %kind, align 8, !tbaa !44
  %cmp8 = icmp ne i32 %7, 1
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %land.lhs.true, %if.end5
  %8 = load i64, i64* %val, align 8, !tbaa !106
  %cmp12 = icmp eq i64 %8, 5
  br i1 %cmp12, label %land.lhs.true14, label %if.end17

land.lhs.true14:                                  ; preds = %if.end11
  %call15 = call i32 @check_trip_points(%struct.nct6775_data* %0, i32 %3)
  %tobool = icmp ne i32 %call15, 0
  br i1 %tobool, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true14
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end17:                                         ; preds = %land.lhs.true14, %if.end11
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %9 = load i64, i64* %val, align 8, !tbaa !106
  %conv18 = trunc i64 %9 to i32
  %pwm_enable = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 70
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %pwm_enable, i64 0, i64 %idxprom
  store i32 %conv18, i32* %arrayidx, align 4, !tbaa !59
  %10 = load i64, i64* %val, align 8, !tbaa !106
  %cmp19 = icmp eq i64 %10, 0
  br i1 %cmp19, label %if.then21, label %if.end29

if.then21:                                        ; preds = %if.end17
  %pwm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 71
  %arrayidx22 = getelementptr inbounds [7 x [6 x i8]], [7 x [6 x i8]]* %pwm, i64 0, i64 0
  %idxprom23 = sext i32 %3 to i64
  %arrayidx24 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx22, i64 0, i64 %idxprom23
  store i8 -1, i8* %arrayidx24, align 1, !tbaa !59
  %REG_PWM = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 28
  %arrayidx25 = getelementptr inbounds [7 x i16*], [7 x i16*]* %REG_PWM, i64 0, i64 0
  %11 = load i16*, i16** %arrayidx25, align 8, !tbaa !6
  %idxprom26 = sext i32 %3 to i64
  %arrayidx27 = getelementptr inbounds i16, i16* %11, i64 %idxprom26
  %12 = load i16, i16* %arrayidx27, align 2, !tbaa !15
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %12, i16 zeroext 255)
  br label %if.end29

if.end29:                                         ; preds = %if.then21, %if.end17
  call void @pwm_update_registers(%struct.nct6775_data* %0, i32 %3)
  %REG_FAN_MODE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 20
  %13 = load i16*, i16** %REG_FAN_MODE, align 8, !tbaa !124
  %idxprom30 = sext i32 %3 to i64
  %arrayidx31 = getelementptr inbounds i16, i16* %13, i64 %idxprom30
  %14 = load i16, i16* %arrayidx31, align 2, !tbaa !15
  %call32 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %14)
  %conv33 = zext i16 %call32 to i32
  %and = and i32 %conv33, 15
  %conv34 = trunc i32 %and to i16
  %15 = load i64, i64* %val, align 8, !tbaa !106
  %conv35 = trunc i64 %15 to i32
  %call36 = call i32 @pwm_enable_to_reg(i32 %conv35)
  %shl = shl i32 %call36, 4
  %conv37 = zext i16 %conv34 to i32
  %or = or i32 %conv37, %shl
  %conv38 = trunc i32 %or to i16
  %REG_FAN_MODE39 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 20
  %16 = load i16*, i16** %REG_FAN_MODE39, align 8, !tbaa !124
  %idxprom40 = sext i32 %3 to i64
  %arrayidx41 = getelementptr inbounds i16, i16* %16, i64 %idxprom40
  %17 = load i16, i16* %arrayidx41, align 2, !tbaa !15
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %17, i16 zeroext %conv38)
  %update_lock43 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock43)
  br label %cleanup

cleanup:                                          ; preds = %if.end29, %if.then16, %land.lhs.true, %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ -22, %if.then16 ], [ %count, %if.end29 ], [ -22, %if.end ], [ -22, %land.lhs.true ]
  %18 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @check_trip_points(%struct.nct6775_data* %data, i32 %nr) #3 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %auto_pwm_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 80
  %0 = load i32, i32* %auto_pwm_num, align 4, !tbaa !103
  %sub = sub nsw i32 %0, 1
  %cmp = icmp slt i32 %i.0, %sub
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %auto_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 82
  %idxprom = sext i32 %nr to i64
  %arrayidx = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_temp, i64 0, i64 %idxprom
  %idxprom1 = sext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx, i64 0, i64 %idxprom1
  %1 = load i8, i8* %arrayidx2, align 1, !tbaa !59
  %conv = zext i8 %1 to i32
  %auto_temp3 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 82
  %idxprom4 = sext i32 %nr to i64
  %arrayidx5 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_temp3, i64 0, i64 %idxprom4
  %add = add nsw i32 %i.0, 1
  %idxprom6 = sext i32 %add to i64
  %arrayidx7 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx5, i64 0, i64 %idxprom6
  %2 = load i8, i8* %arrayidx7, align 1, !tbaa !59
  %conv8 = zext i8 %2 to i32
  %cmp9 = icmp sgt i32 %conv, %conv8
  br i1 %cmp9, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc33, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc34, %for.inc33 ]
  %auto_pwm_num12 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 80
  %3 = load i32, i32* %auto_pwm_num12, align 4, !tbaa !103
  %sub13 = sub nsw i32 %3, 1
  %cmp14 = icmp slt i32 %i.1, %sub13
  %auto_pwm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 81
  %idxprom17 = sext i32 %nr to i64
  %arrayidx18 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_pwm, i64 0, i64 %idxprom17
  br i1 %cmp14, label %for.body16, label %for.end35

for.body16:                                       ; preds = %for.cond11
  %idxprom19 = sext i32 %i.1 to i64
  %arrayidx20 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx18, i64 0, i64 %idxprom19
  %4 = load i8, i8* %arrayidx20, align 1, !tbaa !59
  %conv21 = zext i8 %4 to i32
  %auto_pwm22 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 81
  %idxprom23 = sext i32 %nr to i64
  %arrayidx24 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_pwm22, i64 0, i64 %idxprom23
  %add25 = add nsw i32 %i.1, 1
  %idxprom26 = sext i32 %add25 to i64
  %arrayidx27 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx24, i64 0, i64 %idxprom26
  %5 = load i8, i8* %arrayidx27, align 1, !tbaa !59
  %conv28 = zext i8 %5 to i32
  %cmp29 = icmp sgt i32 %conv21, %conv28
  br i1 %cmp29, label %cleanup, label %for.inc33

for.inc33:                                        ; preds = %for.body16
  %inc34 = add nsw i32 %i.1, 1
  br label %for.cond11

for.end35:                                        ; preds = %for.cond11
  %auto_pwm_num39 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 80
  %6 = load i32, i32* %auto_pwm_num39, align 4, !tbaa !103
  %idxprom40 = sext i32 %6 to i64
  %arrayidx41 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx18, i64 0, i64 %idxprom40
  %7 = load i8, i8* %arrayidx41, align 1, !tbaa !59
  %tobool = icmp ne i8 %7, 0
  br i1 %tobool, label %if.then42, label %if.end79

if.then42:                                        ; preds = %for.end35
  %auto_temp43 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 82
  %idxprom44 = sext i32 %nr to i64
  %arrayidx45 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_temp43, i64 0, i64 %idxprom44
  %auto_pwm_num46 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 80
  %8 = load i32, i32* %auto_pwm_num46, align 4, !tbaa !103
  %sub47 = sub nsw i32 %8, 1
  %idxprom48 = sext i32 %sub47 to i64
  %arrayidx49 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx45, i64 0, i64 %idxprom48
  %9 = load i8, i8* %arrayidx49, align 1, !tbaa !59
  %conv50 = zext i8 %9 to i32
  %auto_temp51 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 82
  %idxprom52 = sext i32 %nr to i64
  %arrayidx53 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_temp51, i64 0, i64 %idxprom52
  %auto_pwm_num54 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 80
  %10 = load i32, i32* %auto_pwm_num54, align 4, !tbaa !103
  %idxprom55 = sext i32 %10 to i64
  %arrayidx56 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx53, i64 0, i64 %idxprom55
  %11 = load i8, i8* %arrayidx56, align 1, !tbaa !59
  %conv57 = zext i8 %11 to i32
  %cmp58 = icmp sgt i32 %conv50, %conv57
  br i1 %cmp58, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then42
  %auto_pwm60 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 81
  %idxprom61 = sext i32 %nr to i64
  %arrayidx62 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_pwm60, i64 0, i64 %idxprom61
  %auto_pwm_num63 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 80
  %12 = load i32, i32* %auto_pwm_num63, align 4, !tbaa !103
  %sub64 = sub nsw i32 %12, 1
  %idxprom65 = sext i32 %sub64 to i64
  %arrayidx66 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx62, i64 0, i64 %idxprom65
  %13 = load i8, i8* %arrayidx66, align 1, !tbaa !59
  %conv67 = zext i8 %13 to i32
  %auto_pwm68 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 81
  %idxprom69 = sext i32 %nr to i64
  %arrayidx70 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_pwm68, i64 0, i64 %idxprom69
  %auto_pwm_num71 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 80
  %14 = load i32, i32* %auto_pwm_num71, align 4, !tbaa !103
  %idxprom72 = sext i32 %14 to i64
  %arrayidx73 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx70, i64 0, i64 %idxprom72
  %15 = load i8, i8* %arrayidx73, align 1, !tbaa !59
  %conv74 = zext i8 %15 to i32
  %cmp75 = icmp sgt i32 %conv67, %conv74
  br i1 %cmp75, label %cleanup, label %if.end79

if.end79:                                         ; preds = %lor.lhs.false, %for.end35
  br label %cleanup

cleanup:                                          ; preds = %if.end79, %lor.lhs.false, %if.then42, %for.body16, %for.body
  %retval.0 = phi i32 [ 0, %if.end79 ], [ -22, %for.body ], [ -22, %for.body16 ], [ -22, %lor.lhs.false ], [ -22, %if.then42 ]
  ret i32 %retval.0
}

declare void @dev_err(%struct.device*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal void @pwm_update_registers(%struct.nct6775_data* %data, i32 %nr) #3 {
entry:
  %pwm_enable = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 70
  %idxprom = sext i32 %nr to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %pwm_enable, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !59
  %Pivot4 = icmp slt i32 %0, 2
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %0, 3
  br i1 %Pivot, label %sw.bb41, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %0, 3
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp ule i32 %0, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.bb1:                                           ; preds = %LeafBlock1
  %REG_FAN_MODE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 20
  %1 = load i16*, i16** %REG_FAN_MODE, align 8, !tbaa !124
  %idxprom2 = sext i32 %nr to i64
  %arrayidx3 = getelementptr inbounds i16, i16* %1, i64 %idxprom2
  %2 = load i16, i16* %arrayidx3, align 2, !tbaa !15
  %call = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %2)
  %conv = trunc i16 %call to i8
  %conv4 = zext i8 %conv to i32
  %tolerance_mask = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 78
  %3 = load i8, i8* %tolerance_mask, align 1, !tbaa !135
  %conv5 = zext i8 %3 to i32
  %neg = xor i32 %conv5, -1
  %and = and i32 %conv4, %neg
  %target_speed_tolerance = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 75
  %idxprom6 = sext i32 %nr to i64
  %arrayidx7 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed_tolerance, i64 0, i64 %idxprom6
  %4 = load i32, i32* %arrayidx7, align 4, !tbaa !2
  %tolerance_mask8 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 78
  %5 = load i8, i8* %tolerance_mask8, align 1, !tbaa !135
  %conv9 = zext i8 %5 to i32
  %and10 = and i32 %4, %conv9
  %or = or i32 %and, %and10
  %conv11 = trunc i32 %or to i8
  %REG_FAN_MODE12 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 20
  %6 = load i16*, i16** %REG_FAN_MODE12, align 8, !tbaa !124
  %idxprom13 = sext i32 %nr to i64
  %arrayidx14 = getelementptr inbounds i16, i16* %6, i64 %idxprom13
  %7 = load i16, i16* %arrayidx14, align 2, !tbaa !15
  %conv15 = zext i8 %conv11 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %7, i16 zeroext %conv15)
  %REG_TARGET = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 18
  %8 = load i16*, i16** %REG_TARGET, align 8, !tbaa !127
  %idxprom17 = sext i32 %nr to i64
  %arrayidx18 = getelementptr inbounds i16, i16* %8, i64 %idxprom17
  %9 = load i16, i16* %arrayidx18, align 2, !tbaa !15
  %target_speed = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 74
  %idxprom19 = sext i32 %nr to i64
  %arrayidx20 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed, i64 0, i64 %idxprom19
  %10 = load i32, i32* %arrayidx20, align 4, !tbaa !2
  %and21 = and i32 %10, 255
  %conv22 = trunc i32 %and21 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %9, i16 zeroext %conv22)
  %REG_TOLERANCE_H = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 25
  %11 = load i16*, i16** %REG_TOLERANCE_H, align 8, !tbaa !125
  %tobool = icmp ne i16* %11, null
  br i1 %tobool, label %if.then, label %sw.epilog

if.then:                                          ; preds = %sw.bb1
  %target_speed24 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 74
  %idxprom25 = sext i32 %nr to i64
  %arrayidx26 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed24, i64 0, i64 %idxprom25
  %12 = load i32, i32* %arrayidx26, align 4, !tbaa !2
  %shr = lshr i32 %12, 8
  %and27 = and i32 %shr, 15
  %conv28 = trunc i32 %and27 to i8
  %target_speed_tolerance29 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 75
  %idxprom30 = sext i32 %nr to i64
  %arrayidx31 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed_tolerance29, i64 0, i64 %idxprom30
  %13 = load i32, i32* %arrayidx31, align 4, !tbaa !2
  %and32 = and i32 %13, 56
  %shl = shl i32 %and32, 1
  %conv33 = zext i8 %conv28 to i32
  %or34 = or i32 %conv33, %shl
  %conv35 = trunc i32 %or34 to i8
  %REG_TOLERANCE_H36 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 25
  %14 = load i16*, i16** %REG_TOLERANCE_H36, align 8, !tbaa !125
  %idxprom37 = sext i32 %nr to i64
  %arrayidx38 = getelementptr inbounds i16, i16* %14, i64 %idxprom37
  %15 = load i16, i16* %arrayidx38, align 2, !tbaa !15
  %conv39 = zext i8 %conv35 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %15, i16 zeroext %conv39)
  br label %sw.epilog

sw.bb41:                                          ; preds = %NodeBlock
  %REG_TARGET42 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 18
  %16 = load i16*, i16** %REG_TARGET42, align 8, !tbaa !127
  %idxprom43 = sext i32 %nr to i64
  %arrayidx44 = getelementptr inbounds i16, i16* %16, i64 %idxprom43
  %17 = load i16, i16* %arrayidx44, align 2, !tbaa !15
  %target_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 72
  %idxprom45 = sext i32 %nr to i64
  %arrayidx46 = getelementptr inbounds [6 x i8], [6 x i8]* %target_temp, i64 0, i64 %idxprom45
  %18 = load i8, i8* %arrayidx46, align 1, !tbaa !59
  %conv47 = zext i8 %18 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %17, i16 zeroext %conv47)
  br label %sw.default

sw.default:                                       ; preds = %sw.bb41, %LeafBlock, %LeafBlock1
  %REG_FAN_MODE49 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 20
  %19 = load i16*, i16** %REG_FAN_MODE49, align 8, !tbaa !124
  %idxprom50 = sext i32 %nr to i64
  %arrayidx51 = getelementptr inbounds i16, i16* %19, i64 %idxprom50
  %20 = load i16, i16* %arrayidx51, align 2, !tbaa !15
  %call52 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %20)
  %conv53 = trunc i16 %call52 to i8
  %conv54 = zext i8 %conv53 to i32
  %tolerance_mask55 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 78
  %21 = load i8, i8* %tolerance_mask55, align 1, !tbaa !135
  %conv56 = zext i8 %21 to i32
  %neg57 = xor i32 %conv56, -1
  %and58 = and i32 %conv54, %neg57
  %temp_tolerance = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 77
  %arrayidx59 = getelementptr inbounds [2 x [6 x i8]], [2 x [6 x i8]]* %temp_tolerance, i64 0, i64 0
  %idxprom60 = sext i32 %nr to i64
  %arrayidx61 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx59, i64 0, i64 %idxprom60
  %22 = load i8, i8* %arrayidx61, align 1, !tbaa !59
  %conv62 = zext i8 %22 to i32
  %or63 = or i32 %and58, %conv62
  %conv64 = trunc i32 %or63 to i8
  %REG_FAN_MODE65 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 20
  %23 = load i16*, i16** %REG_FAN_MODE65, align 8, !tbaa !124
  %idxprom66 = sext i32 %nr to i64
  %arrayidx67 = getelementptr inbounds i16, i16* %23, i64 %idxprom66
  %24 = load i16, i16* %arrayidx67, align 2, !tbaa !15
  %conv68 = zext i8 %conv64 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %24, i16 zeroext %conv68)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.then, %sw.bb1, %LeafBlock
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @pwm_enable_to_reg(i32 %mode) #3 {
entry:
  %cmp = icmp eq i32 %mode, 0
  %sub = sub i32 %mode, 1
  %retval.0 = select i1 %cmp, i32 0, i32 %sub
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_temp_sel(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index1 = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index1, align 8, !tbaa !94
  %pwm_temp_sel = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 83
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_temp_sel, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv = zext i8 %3 to i32
  %call2 = call i64 @show_pwm_temp_sel_common(%struct.nct6775_data* %call, i32 %conv)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_temp_sel(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !94
  %3 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %4 = load i64, i64* %val, align 8, !tbaa !106
  %cmp2 = icmp eq i64 %4, 0
  %5 = load i64, i64* %val, align 8
  %cmp4 = icmp ugt i64 %5, 10
  %or.cond = or i1 %cmp2, %cmp4
  br i1 %or.cond, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end
  %have_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 89
  %6 = load i16, i16* %have_temp, align 2, !tbaa !53
  %conv8 = zext i16 %6 to i32
  %7 = load i64, i64* %val, align 8, !tbaa !106
  %sub = sub i64 %7, 1
  %sh_prom = trunc i64 %sub to i32
  %shl = shl i32 1, %sh_prom
  %and = and i32 %conv8, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false9, label %cleanup

lor.lhs.false9:                                   ; preds = %if.end7
  %temp_src = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 6
  %8 = load i64, i64* %val, align 8, !tbaa !106
  %sub10 = sub i64 %8, 1
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %temp_src, i64 0, i64 %sub10
  %9 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %tobool11 = icmp ne i8 %9, 0
  br i1 %tobool11, label %if.end13, label %cleanup

if.end13:                                         ; preds = %lor.lhs.false9
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %temp_src14 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 6
  %10 = load i64, i64* %val, align 8, !tbaa !106
  %sub15 = sub i64 %10, 1
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %temp_src14, i64 0, i64 %sub15
  %11 = load i8, i8* %arrayidx16, align 1, !tbaa !59
  %conv17 = zext i8 %11 to i32
  %conv18 = trunc i32 %conv17 to i8
  %pwm_temp_sel = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 83
  %idxprom = sext i32 %2 to i64
  %arrayidx19 = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_temp_sel, i64 0, i64 %idxprom
  store i8 %conv18, i8* %arrayidx19, align 1, !tbaa !59
  %REG_TEMP_SEL = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 38
  %12 = load i16*, i16** %REG_TEMP_SEL, align 8, !tbaa !107
  %idxprom20 = sext i32 %2 to i64
  %arrayidx21 = getelementptr inbounds i16, i16* %12, i64 %idxprom20
  %13 = load i16, i16* %arrayidx21, align 2, !tbaa !15
  %call22 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %call, i16 zeroext %13)
  %conv23 = zext i16 %call22 to i32
  %and24 = and i32 %conv23, 224
  %or = or i32 %and24, %conv17
  %REG_TEMP_SEL25 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 38
  %14 = load i16*, i16** %REG_TEMP_SEL25, align 8, !tbaa !107
  %idxprom26 = sext i32 %2 to i64
  %arrayidx27 = getelementptr inbounds i16, i16* %14, i64 %idxprom26
  %15 = load i16, i16* %arrayidx27, align 2, !tbaa !15
  %conv28 = trunc i32 %or to i16
  call void @nct6775_write_value(%struct.nct6775_data* %call, i16 zeroext %15, i16 zeroext %conv28)
  %update_lock30 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock30)
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %lor.lhs.false9, %if.end7, %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end13 ], [ -22, %if.end ], [ -22, %lor.lhs.false9 ], [ -22, %if.end7 ]
  %16 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_temp_sel_common(%struct.nct6775_data* %data, i32 %src) #3 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %have_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 89
  %0 = load i16, i16* %have_temp, align 2, !tbaa !53
  %conv = zext i16 %0 to i32
  %shl = shl i32 1, %i.0
  %and = and i32 %conv, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %temp_src = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 6
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %temp_src, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv1 = zext i8 %1 to i32
  %cmp2 = icmp eq i32 %src, %conv1
  br i1 %cmp2, label %if.then4, label %for.inc

if.then4:                                         ; preds = %if.end
  br label %for.end

for.inc:                                          ; preds = %if.end, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.then4, %for.cond
  %2 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv6 = sext i32 %2 to i64
  ret i64 %conv6
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_tolerance(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv8 = sext i32 %0 to i64
  ret i64 %conv8
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_tolerance(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %__UNIQUE_ID_min1_42 = alloca i64, align 8
  %__UNIQUE_ID_min1_40 = alloca i64, align 8
  %__UNIQUE_ID_min2_41 = alloca i64, align 8
  %__UNIQUE_ID_min2_43 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !84
  %conv = zext i8 %3 to i32
  %index2 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 1
  %4 = load i8, i8* %index2, align 8, !tbaa !85
  %conv3 = zext i8 %4 to i32
  %5 = bitcast i64* %val to i8*
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv6 = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %6 = bitcast i64* %__UNIQUE_ID_min1_42 to i8*
  %7 = bitcast i64* %__UNIQUE_ID_min1_40 to i8*
  %8 = load i64, i64* %val, align 8, !tbaa !106
  %div = sdiv i32 1000, 2
  %conv8 = sext i32 %div to i64
  %add = add i64 %8, %conv8
  %conv9 = sext i32 1000 to i64
  %div10 = udiv i64 %add, %conv9
  store i64 %div10, i64* %__UNIQUE_ID_min1_40, align 8, !tbaa !106
  %9 = bitcast i64* %__UNIQUE_ID_min2_41 to i8*
  store i64 0, i64* %__UNIQUE_ID_min2_41, align 8, !tbaa !106
  %10 = load i64, i64* %__UNIQUE_ID_min1_40, align 8, !tbaa !106
  %11 = load i64, i64* %__UNIQUE_ID_min2_41, align 8, !tbaa !106
  %cmp14 = icmp ugt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_40, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_41, align 8
  %cond = select i1 %cmp14, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_41 to i8*
  %15 = bitcast i64* %__UNIQUE_ID_min1_40 to i8*
  store i64 %cond, i64* %__UNIQUE_ID_min1_42, align 8, !tbaa !106
  %16 = bitcast i64* %__UNIQUE_ID_min2_43 to i8*
  %tolerance_mask = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 78
  %17 = load i8, i8* %tolerance_mask, align 1, !tbaa !135
  %conv16 = zext i8 %17 to i64
  store i64 %conv16, i64* %__UNIQUE_ID_min2_43, align 8, !tbaa !106
  %18 = load i64, i64* %__UNIQUE_ID_min1_42, align 8, !tbaa !106
  %19 = load i64, i64* %__UNIQUE_ID_min2_43, align 8, !tbaa !106
  %cmp20 = icmp ult i64 %18, %19
  %20 = load i64, i64* %__UNIQUE_ID_min1_42, align 8
  %21 = load i64, i64* %__UNIQUE_ID_min2_43, align 8
  %cond25 = select i1 %cmp20, i64 %20, i64 %21
  %22 = bitcast i64* %__UNIQUE_ID_min2_43 to i8*
  %23 = bitcast i64* %__UNIQUE_ID_min1_42 to i8*
  store i64 %cond25, i64* %val, align 8, !tbaa !106
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %24 = load i64, i64* %val, align 8, !tbaa !106
  %conv26 = trunc i64 %24 to i8
  %temp_tolerance = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 77
  %idxprom = sext i32 %conv3 to i64
  %arrayidx = getelementptr inbounds [2 x [6 x i8]], [2 x [6 x i8]]* %temp_tolerance, i64 0, i64 %idxprom
  %idxprom27 = sext i32 %conv to i64
  %arrayidx28 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx, i64 0, i64 %idxprom27
  store i8 %conv26, i8* %arrayidx28, align 1, !tbaa !59
  %tobool = icmp ne i32 %conv3, 0
  br i1 %tobool, label %if.then29, label %if.else

if.then29:                                        ; preds = %if.end
  call void @pwm_update_registers(%struct.nct6775_data* %0, i32 %conv)
  br label %if.end34

if.else:                                          ; preds = %if.end
  %REG_CRITICAL_TEMP_TOLERANCE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 36
  %25 = load i16*, i16** %REG_CRITICAL_TEMP_TOLERANCE, align 8, !tbaa !126
  %idxprom30 = sext i32 %conv to i64
  %arrayidx31 = getelementptr inbounds i16, i16* %25, i64 %idxprom30
  %26 = load i16, i16* %arrayidx31, align 2, !tbaa !15
  %27 = load i64, i64* %val, align 8, !tbaa !106
  %conv32 = trunc i64 %27 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %26, i16 zeroext %conv32)
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then29
  %update_lock35 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock35)
  br label %cleanup

cleanup:                                          ; preds = %if.end34, %if.then
  %retval.0 = phi i64 [ %conv6, %if.then ], [ %count, %if.end34 ]
  %28 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_target_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv2 = sext i32 %0 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @store_target_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %__UNIQUE_ID_min1_34 = alloca i64, align 8
  %__UNIQUE_ID_min1_32 = alloca i64, align 8
  %__UNIQUE_ID_min2_33 = alloca i64, align 8
  %__UNIQUE_ID_min2_35 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !94
  %4 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = bitcast i64* %__UNIQUE_ID_min1_34 to i8*
  %6 = bitcast i64* %__UNIQUE_ID_min1_32 to i8*
  %7 = load i64, i64* %val, align 8, !tbaa !106
  %div = sdiv i32 1000, 2
  %conv3 = sext i32 %div to i64
  %add = add i64 %7, %conv3
  %conv4 = sext i32 1000 to i64
  %div5 = udiv i64 %add, %conv4
  store i64 %div5, i64* %__UNIQUE_ID_min1_32, align 8, !tbaa !106
  %8 = bitcast i64* %__UNIQUE_ID_min2_33 to i8*
  store i64 0, i64* %__UNIQUE_ID_min2_33, align 8, !tbaa !106
  %9 = load i64, i64* %__UNIQUE_ID_min1_32, align 8, !tbaa !106
  %10 = load i64, i64* %__UNIQUE_ID_min2_33, align 8, !tbaa !106
  %cmp9 = icmp ugt i64 %9, %10
  %11 = load i64, i64* %__UNIQUE_ID_min1_32, align 8
  %12 = load i64, i64* %__UNIQUE_ID_min2_33, align 8
  %cond = select i1 %cmp9, i64 %11, i64 %12
  %13 = bitcast i64* %__UNIQUE_ID_min2_33 to i8*
  %14 = bitcast i64* %__UNIQUE_ID_min1_32 to i8*
  store i64 %cond, i64* %__UNIQUE_ID_min1_34, align 8, !tbaa !106
  %15 = bitcast i64* %__UNIQUE_ID_min2_35 to i8*
  %target_temp_mask = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 73
  %16 = load i8, i8* %target_temp_mask, align 8, !tbaa !128
  %conv11 = zext i8 %16 to i64
  store i64 %conv11, i64* %__UNIQUE_ID_min2_35, align 8, !tbaa !106
  %17 = load i64, i64* %__UNIQUE_ID_min1_34, align 8, !tbaa !106
  %18 = load i64, i64* %__UNIQUE_ID_min2_35, align 8, !tbaa !106
  %cmp15 = icmp ult i64 %17, %18
  %19 = load i64, i64* %__UNIQUE_ID_min1_34, align 8
  %20 = load i64, i64* %__UNIQUE_ID_min2_35, align 8
  %cond20 = select i1 %cmp15, i64 %19, i64 %20
  %21 = bitcast i64* %__UNIQUE_ID_min2_35 to i8*
  %22 = bitcast i64* %__UNIQUE_ID_min1_34 to i8*
  store i64 %cond20, i64* %val, align 8, !tbaa !106
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %23 = load i64, i64* %val, align 8, !tbaa !106
  %conv21 = trunc i64 %23 to i8
  %target_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 72
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %target_temp, i64 0, i64 %idxprom
  store i8 %conv21, i8* %arrayidx, align 1, !tbaa !59
  call void @pwm_update_registers(%struct.nct6775_data* %0, i32 %3)
  %update_lock22 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock22)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %24 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_target_speed(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !94
  %target_speed = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 74
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %conv = trunc i32 %3 to i16
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 55
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 %idxprom1
  %4 = load i8, i8* %arrayidx2, align 1, !tbaa !59
  %conv3 = zext i8 %4 to i32
  %call4 = call i32 @fan_from_reg16(i16 zeroext %conv, i32 %conv3)
  %5 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv6 = sext i32 %5 to i64
  ret i64 %conv6
}

; Function Attrs: nounwind uwtable
define internal i64 @store_target_speed(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %__UNIQUE_ID_min1_38 = alloca i64, align 8
  %__UNIQUE_ID_min1_36 = alloca i64, align 8
  %__UNIQUE_ID_min2_37 = alloca i64, align 8
  %__UNIQUE_ID_min2_39 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !94
  %4 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = bitcast i64* %__UNIQUE_ID_min1_38 to i8*
  %6 = bitcast i64* %__UNIQUE_ID_min1_36 to i8*
  %7 = load i64, i64* %val, align 8, !tbaa !106
  store i64 %7, i64* %__UNIQUE_ID_min1_36, align 8, !tbaa !106
  %8 = bitcast i64* %__UNIQUE_ID_min2_37 to i8*
  store i64 0, i64* %__UNIQUE_ID_min2_37, align 8, !tbaa !106
  %9 = load i64, i64* %__UNIQUE_ID_min1_36, align 8, !tbaa !106
  %10 = load i64, i64* %__UNIQUE_ID_min2_37, align 8, !tbaa !106
  %cmp5 = icmp ugt i64 %9, %10
  %11 = load i64, i64* %__UNIQUE_ID_min1_36, align 8
  %12 = load i64, i64* %__UNIQUE_ID_min2_37, align 8
  %cond = select i1 %cmp5, i64 %11, i64 %12
  %13 = bitcast i64* %__UNIQUE_ID_min2_37 to i8*
  %14 = bitcast i64* %__UNIQUE_ID_min1_36 to i8*
  store i64 %cond, i64* %__UNIQUE_ID_min1_38, align 8, !tbaa !106
  %15 = bitcast i64* %__UNIQUE_ID_min2_39 to i8*
  store i64 1350000, i64* %__UNIQUE_ID_min2_39, align 8, !tbaa !106
  %16 = load i64, i64* %__UNIQUE_ID_min1_38, align 8, !tbaa !106
  %17 = load i64, i64* %__UNIQUE_ID_min2_39, align 8, !tbaa !106
  %cmp10 = icmp ult i64 %16, %17
  %18 = load i64, i64* %__UNIQUE_ID_min1_38, align 8
  %19 = load i64, i64* %__UNIQUE_ID_min2_39, align 8
  %cond15 = select i1 %cmp10, i64 %18, i64 %19
  %20 = bitcast i64* %__UNIQUE_ID_min2_39 to i8*
  %21 = bitcast i64* %__UNIQUE_ID_min1_38 to i8*
  store i64 %cond15, i64* %val, align 8, !tbaa !106
  %22 = load i64, i64* %val, align 8, !tbaa !106
  %conv16 = trunc i64 %22 to i32
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 55
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 %idxprom
  %23 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv17 = zext i8 %23 to i32
  %call18 = call zeroext i16 @fan_to_reg(i32 %conv16, i32 %conv17)
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %conv19 = zext i16 %call18 to i32
  %target_speed = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 74
  %idxprom20 = sext i32 %3 to i64
  %arrayidx21 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed, i64 0, i64 %idxprom20
  store i32 %conv19, i32* %arrayidx21, align 4, !tbaa !2
  call void @pwm_update_registers(%struct.nct6775_data* %0, i32 %3)
  %update_lock22 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock22)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %24 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @fan_to_reg(i32 %fan, i32 %divreg) #3 {
entry:
  %tobool = icmp ne i32 %fan, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %div = udiv i32 1350000, %fan
  %shr = lshr i32 %div, %divreg
  %conv = trunc i32 %shr to i16
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i16 [ %conv, %if.end ], [ 0, %entry ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_speed_tolerance(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !94
  %target_speed = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 74
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %target_speed_tolerance = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 75
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed_tolerance, i64 0, i64 %idxprom1
  %4 = load i32, i32* %arrayidx2, align 4, !tbaa !2
  %sub = sub i32 %3, %4
  %target_speed3 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 74
  %idxprom4 = sext i32 %2 to i64
  %arrayidx5 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed3, i64 0, i64 %idxprom4
  %5 = load i32, i32* %arrayidx5, align 4, !tbaa !2
  %target_speed_tolerance6 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 75
  %idxprom7 = sext i32 %2 to i64
  %arrayidx8 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed_tolerance6, i64 0, i64 %idxprom7
  %6 = load i32, i32* %arrayidx8, align 4, !tbaa !2
  %add = add i32 %5, %6
  %cmp = icmp sle i32 %sub, 0
  %.sub = select i1 %cmp, i32 1, i32 %sub
  %cmp9 = icmp sgt i32 %add, 65535
  %high.0 = select i1 %cmp9, i32 65535, i32 %add
  %cmp12 = icmp slt i32 %high.0, %.sub
  %.sub.high.0 = select i1 %cmp12, i32 %.sub, i32 %high.0
  %conv = trunc i32 %.sub to i16
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 55
  %idxprom15 = sext i32 %2 to i64
  %arrayidx16 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 %idxprom15
  %7 = load i8, i8* %arrayidx16, align 1, !tbaa !59
  %conv17 = zext i8 %7 to i32
  %call18 = call i32 @fan_from_reg16(i16 zeroext %conv, i32 %conv17)
  %conv19 = trunc i32 %.sub.high.0 to i16
  %fan_div20 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 55
  %idxprom21 = sext i32 %2 to i64
  %arrayidx22 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div20, i64 0, i64 %idxprom21
  %8 = load i8, i8* %arrayidx22, align 1, !tbaa !59
  %conv23 = zext i8 %8 to i32
  %call24 = call i32 @fan_from_reg16(i16 zeroext %conv19, i32 %conv23)
  %9 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv27 = sext i32 %9 to i64
  ret i64 %conv27
}

; Function Attrs: nounwind uwtable
define internal i64 @store_speed_tolerance(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %__UNIQUE_ID_min1_46 = alloca i64, align 8
  %__UNIQUE_ID_min1_44 = alloca i64, align 8
  %__UNIQUE_ID_min2_45 = alloca i64, align 8
  %__UNIQUE_ID_min2_47 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !94
  %4 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %target_speed = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 74
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed, i64 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %conv2 = trunc i32 %5 to i16
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 55
  %idxprom3 = sext i32 %3 to i64
  %arrayidx4 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 %idxprom3
  %6 = load i8, i8* %arrayidx4, align 1, !tbaa !59
  %conv5 = zext i8 %6 to i32
  %call6 = call i32 @fan_from_reg16(i16 zeroext %conv2, i32 %conv5)
  %conv7 = zext i32 %call6 to i64
  %7 = load i64, i64* %val, align 8, !tbaa !106
  %add = add i64 %conv7, %7
  %conv8 = trunc i64 %add to i32
  %target_speed9 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 74
  %idxprom10 = sext i32 %3 to i64
  %arrayidx11 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed9, i64 0, i64 %idxprom10
  %8 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  %conv12 = trunc i32 %8 to i16
  %fan_div13 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 55
  %idxprom14 = sext i32 %3 to i64
  %arrayidx15 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div13, i64 0, i64 %idxprom14
  %9 = load i8, i8* %arrayidx15, align 1, !tbaa !59
  %conv16 = zext i8 %9 to i32
  %call17 = call i32 @fan_from_reg16(i16 zeroext %conv12, i32 %conv16)
  %conv18 = zext i32 %call17 to i64
  %10 = load i64, i64* %val, align 8, !tbaa !106
  %sub = sub i64 %conv18, %10
  %conv19 = trunc i64 %sub to i32
  %cmp20 = icmp sle i32 %conv19, 0
  %.conv19 = select i1 %cmp20, i32 1, i32 %conv19
  %cmp24 = icmp slt i32 %conv8, %.conv19
  %high.0 = select i1 %cmp24, i32 %.conv19, i32 %conv8
  %fan_div28 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 55
  %idxprom29 = sext i32 %3 to i64
  %arrayidx30 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div28, i64 0, i64 %idxprom29
  %11 = load i8, i8* %arrayidx30, align 1, !tbaa !59
  %conv31 = zext i8 %11 to i32
  %call32 = call zeroext i16 @fan_to_reg(i32 %.conv19, i32 %conv31)
  %conv33 = zext i16 %call32 to i32
  %fan_div34 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 55
  %idxprom35 = sext i32 %3 to i64
  %arrayidx36 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div34, i64 0, i64 %idxprom35
  %12 = load i8, i8* %arrayidx36, align 1, !tbaa !59
  %conv37 = zext i8 %12 to i32
  %call38 = call zeroext i16 @fan_to_reg(i32 %high.0, i32 %conv37)
  %conv39 = zext i16 %call38 to i32
  %sub40 = sub nsw i32 %conv33, %conv39
  %div = sdiv i32 %sub40, 2
  %conv41 = sext i32 %div to i64
  store i64 %conv41, i64* %val, align 8, !tbaa !106
  %13 = bitcast i64* %__UNIQUE_ID_min1_46 to i8*
  %14 = bitcast i64* %__UNIQUE_ID_min1_44 to i8*
  %15 = load i64, i64* %val, align 8, !tbaa !106
  store i64 %15, i64* %__UNIQUE_ID_min1_44, align 8, !tbaa !106
  %16 = bitcast i64* %__UNIQUE_ID_min2_45 to i8*
  store i64 0, i64* %__UNIQUE_ID_min2_45, align 8, !tbaa !106
  %17 = load i64, i64* %__UNIQUE_ID_min1_44, align 8, !tbaa !106
  %18 = load i64, i64* %__UNIQUE_ID_min2_45, align 8, !tbaa !106
  %cmp45 = icmp ugt i64 %17, %18
  %19 = load i64, i64* %__UNIQUE_ID_min1_44, align 8
  %20 = load i64, i64* %__UNIQUE_ID_min2_45, align 8
  %cond = select i1 %cmp45, i64 %19, i64 %20
  %21 = bitcast i64* %__UNIQUE_ID_min2_45 to i8*
  %22 = bitcast i64* %__UNIQUE_ID_min1_44 to i8*
  store i64 %cond, i64* %__UNIQUE_ID_min1_46, align 8, !tbaa !106
  %23 = bitcast i64* %__UNIQUE_ID_min2_47 to i8*
  %speed_tolerance_limit = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 76
  %24 = load i8, i8* %speed_tolerance_limit, align 4, !tbaa !136
  %conv47 = zext i8 %24 to i64
  store i64 %conv47, i64* %__UNIQUE_ID_min2_47, align 8, !tbaa !106
  %25 = load i64, i64* %__UNIQUE_ID_min1_46, align 8, !tbaa !106
  %26 = load i64, i64* %__UNIQUE_ID_min2_47, align 8, !tbaa !106
  %cmp51 = icmp ult i64 %25, %26
  %27 = load i64, i64* %__UNIQUE_ID_min1_46, align 8
  %28 = load i64, i64* %__UNIQUE_ID_min2_47, align 8
  %cond56 = select i1 %cmp51, i64 %27, i64 %28
  %29 = bitcast i64* %__UNIQUE_ID_min2_47 to i8*
  %30 = bitcast i64* %__UNIQUE_ID_min1_46 to i8*
  store i64 %cond56, i64* %val, align 8, !tbaa !106
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %31 = load i64, i64* %val, align 8, !tbaa !106
  %conv57 = trunc i64 %31 to i32
  %target_speed_tolerance = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 75
  %idxprom58 = sext i32 %3 to i64
  %arrayidx59 = getelementptr inbounds [6 x i32], [6 x i32]* %target_speed_tolerance, i64 0, i64 %idxprom58
  store i32 %conv57, i32* %arrayidx59, align 4, !tbaa !2
  call void @pwm_update_registers(%struct.nct6775_data* %0, i32 %3)
  %update_lock60 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock60)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %32 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_time(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 2
  %2 = load i8, i8* %nr1, align 1, !tbaa !84
  %conv = zext i8 %2 to i32
  %index2 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 1
  %3 = load i8, i8* %index2, align 8, !tbaa !85
  %conv3 = zext i8 %3 to i32
  %fan_time = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 79
  %idxprom = sext i32 %conv3 to i64
  %arrayidx = getelementptr inbounds [3 x [6 x i8]], [3 x [6 x i8]]* %fan_time, i64 0, i64 %idxprom
  %idxprom4 = sext i32 %conv to i64
  %arrayidx5 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx, i64 0, i64 %idxprom4
  %4 = load i8, i8* %arrayidx5, align 1, !tbaa !59
  %pwm_mode = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 69
  %idxprom6 = sext i32 %conv to i64
  %arrayidx7 = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_mode, i64 0, i64 %idxprom6
  %5 = load i8, i8* %arrayidx7, align 1, !tbaa !59
  call void @step_time_from_reg(i8 zeroext %4, i8 zeroext %5)
  %6 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv10 = sext i32 %6 to i64
  ret i64 %conv10
}

; Function Attrs: nounwind uwtable
define internal i64 @store_fan_time(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !84
  %conv = zext i8 %3 to i32
  %index2 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 1
  %4 = load i8, i8* %index2, align 8, !tbaa !85
  %conv3 = zext i8 %4 to i32
  %5 = bitcast i64* %val to i8*
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv6 = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %6 = load i64, i64* %val, align 8, !tbaa !106
  %conv7 = trunc i64 %6 to i32
  %pwm_mode = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 69
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_mode, i64 0, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %call8 = call zeroext i8 @step_time_to_reg(i32 %conv7, i8 zeroext %7)
  %conv9 = zext i8 %call8 to i64
  store i64 %conv9, i64* %val, align 8, !tbaa !106
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %8 = load i64, i64* %val, align 8, !tbaa !106
  %conv10 = trunc i64 %8 to i8
  %fan_time = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 79
  %idxprom11 = sext i32 %conv3 to i64
  %arrayidx12 = getelementptr inbounds [3 x [6 x i8]], [3 x [6 x i8]]* %fan_time, i64 0, i64 %idxprom11
  %idxprom13 = sext i32 %conv to i64
  %arrayidx14 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx12, i64 0, i64 %idxprom13
  store i8 %conv10, i8* %arrayidx14, align 1, !tbaa !59
  %REG_FAN_TIME = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 24
  %idxprom15 = sext i32 %conv3 to i64
  %arrayidx16 = getelementptr inbounds [3 x i16*], [3 x i16*]* %REG_FAN_TIME, i64 0, i64 %idxprom15
  %9 = load i16*, i16** %arrayidx16, align 8, !tbaa !6
  %idxprom17 = sext i32 %conv to i64
  %arrayidx18 = getelementptr inbounds i16, i16* %9, i64 %idxprom17
  %10 = load i16, i16* %arrayidx18, align 2, !tbaa !15
  %11 = load i64, i64* %val, align 8, !tbaa !106
  %conv19 = trunc i64 %11 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %10, i16 zeroext %conv19)
  %update_lock21 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock21)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv6, %if.then ], [ %count, %if.end ]
  %12 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @step_time_from_reg(i8 zeroext %reg, i8 zeroext %mode) #3 {
entry:
  %conv = zext i8 %mode to i32
  %tobool = icmp ne i32 %conv, 0
  %conv1 = zext i8 %reg to i32
  %.sink = select i1 %tobool, i32 400, i32 100
  %mul3 = mul nsw i32 %.sink, %conv1
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @step_time_to_reg(i32 %msec, i8 zeroext %mode) #3 {
entry:
  %__UNIQUE_ID_min1_18 = alloca i32, align 4
  %__UNIQUE_ID_min1_16 = alloca i32, align 4
  %__UNIQUE_ID_min2_17 = alloca i32, align 4
  %__UNIQUE_ID_min2_19 = alloca i32, align 4
  %0 = bitcast i32* %__UNIQUE_ID_min1_18 to i8*
  %1 = bitcast i32* %__UNIQUE_ID_min1_16 to i8*
  %conv = zext i8 %mode to i32
  %tobool = icmp ne i32 %conv, 0
  %.sink1 = select i1 %tobool, i32 200, i32 50
  %.sink = select i1 %tobool, i32 400, i32 100
  %add1 = add i32 %msec, %.sink1
  %div2 = udiv i32 %add1, %.sink
  store i32 %div2, i32* %__UNIQUE_ID_min1_16, align 4, !tbaa !2
  %2 = bitcast i32* %__UNIQUE_ID_min2_17 to i8*
  store i32 1, i32* %__UNIQUE_ID_min2_17, align 4, !tbaa !2
  %3 = load i32, i32* %__UNIQUE_ID_min1_16, align 4, !tbaa !2
  %4 = load i32, i32* %__UNIQUE_ID_min2_17, align 4, !tbaa !2
  %cmp4 = icmp ugt i32 %3, %4
  %5 = load i32, i32* %__UNIQUE_ID_min1_16, align 4
  %6 = load i32, i32* %__UNIQUE_ID_min2_17, align 4
  %cond9 = select i1 %cmp4, i32 %5, i32 %6
  %7 = bitcast i32* %__UNIQUE_ID_min2_17 to i8*
  %8 = bitcast i32* %__UNIQUE_ID_min1_16 to i8*
  store i32 %cond9, i32* %__UNIQUE_ID_min1_18, align 4, !tbaa !2
  %9 = bitcast i32* %__UNIQUE_ID_min2_19 to i8*
  store i32 255, i32* %__UNIQUE_ID_min2_19, align 4, !tbaa !2
  %10 = load i32, i32* %__UNIQUE_ID_min1_18, align 4, !tbaa !2
  %11 = load i32, i32* %__UNIQUE_ID_min2_19, align 4, !tbaa !2
  %cmp13 = icmp ult i32 %10, %11
  %12 = load i32, i32* %__UNIQUE_ID_min1_18, align 4
  %13 = load i32, i32* %__UNIQUE_ID_min2_19, align 4
  %cond18 = select i1 %cmp13, i32 %12, i32 %13
  %14 = bitcast i32* %__UNIQUE_ID_min2_19 to i8*
  %15 = bitcast i32* %__UNIQUE_ID_min1_18 to i8*
  %conv19 = trunc i32 %cond18 to i8
  ret i8 %conv19
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_weight_temp_sel(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index1 = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index1, align 8, !tbaa !94
  %pwm_weight_temp_sel = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 84
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_weight_temp_sel, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv = zext i8 %3 to i32
  %call2 = call i64 @show_pwm_temp_sel_common(%struct.nct6775_data* %call, i32 %conv)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_weight_temp_sel(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !94
  %3 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %4 = load i64, i64* %val, align 8, !tbaa !106
  %cmp2 = icmp ugt i64 %4, 10
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %5 = load i64, i64* %val, align 8, !tbaa !106
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.end5
  %have_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 89
  %6 = load i16, i16* %have_temp, align 2, !tbaa !53
  %conv6 = zext i16 %6 to i32
  %7 = load i64, i64* %val, align 8, !tbaa !106
  %sub = sub i64 %7, 1
  %sh_prom = trunc i64 %sub to i32
  %shl = shl i32 1, %sh_prom
  %and = and i32 %conv6, %shl
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %land.lhs.true
  %temp_src = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 6
  %8 = load i64, i64* %val, align 8, !tbaa !106
  %sub8 = sub i64 %8, 1
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %temp_src, i64 0, i64 %sub8
  %9 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %tobool9 = icmp ne i8 %9, 0
  br i1 %tobool9, label %if.end11, label %cleanup

if.end11:                                         ; preds = %lor.lhs.false, %if.end5
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %10 = load i64, i64* %val, align 8, !tbaa !106
  %tobool12 = icmp ne i64 %10, 0
  br i1 %tobool12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end11
  %temp_src14 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 6
  %11 = load i64, i64* %val, align 8, !tbaa !106
  %sub15 = sub i64 %11, 1
  %arrayidx16 = getelementptr inbounds [10 x i8], [10 x i8]* %temp_src14, i64 0, i64 %sub15
  %12 = load i8, i8* %arrayidx16, align 1, !tbaa !59
  %conv17 = zext i8 %12 to i32
  %conv18 = trunc i32 %conv17 to i8
  %pwm_weight_temp_sel = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 84
  %idxprom = sext i32 %2 to i64
  %arrayidx19 = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_weight_temp_sel, i64 0, i64 %idxprom
  store i8 %conv18, i8* %arrayidx19, align 1, !tbaa !59
  %REG_WEIGHT_TEMP_SEL = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 39
  %13 = load i16*, i16** %REG_WEIGHT_TEMP_SEL, align 8, !tbaa !102
  %idxprom20 = sext i32 %2 to i64
  %arrayidx21 = getelementptr inbounds i16, i16* %13, i64 %idxprom20
  %14 = load i16, i16* %arrayidx21, align 2, !tbaa !15
  %call22 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %call, i16 zeroext %14)
  %conv23 = zext i16 %call22 to i32
  %and24 = and i32 %conv23, 224
  %or = or i32 %conv17, 128
  %or25 = or i32 %and24, %or
  %REG_WEIGHT_TEMP_SEL26 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 39
  %15 = load i16*, i16** %REG_WEIGHT_TEMP_SEL26, align 8, !tbaa !102
  %idxprom27 = sext i32 %2 to i64
  %arrayidx28 = getelementptr inbounds i16, i16* %15, i64 %idxprom27
  %16 = load i16, i16* %arrayidx28, align 2, !tbaa !15
  %conv29 = trunc i32 %or25 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %call, i16 zeroext %16, i16 zeroext %conv29)
  br label %if.end45

if.else:                                          ; preds = %if.end11
  %pwm_weight_temp_sel31 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 84
  %idxprom32 = sext i32 %2 to i64
  %arrayidx33 = getelementptr inbounds [6 x i8], [6 x i8]* %pwm_weight_temp_sel31, i64 0, i64 %idxprom32
  store i8 0, i8* %arrayidx33, align 1, !tbaa !59
  %REG_WEIGHT_TEMP_SEL34 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 39
  %17 = load i16*, i16** %REG_WEIGHT_TEMP_SEL34, align 8, !tbaa !102
  %idxprom35 = sext i32 %2 to i64
  %arrayidx36 = getelementptr inbounds i16, i16* %17, i64 %idxprom35
  %18 = load i16, i16* %arrayidx36, align 2, !tbaa !15
  %call37 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %call, i16 zeroext %18)
  %conv38 = zext i16 %call37 to i32
  %and39 = and i32 %conv38, 127
  %REG_WEIGHT_TEMP_SEL40 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 39
  %19 = load i16*, i16** %REG_WEIGHT_TEMP_SEL40, align 8, !tbaa !102
  %idxprom41 = sext i32 %2 to i64
  %arrayidx42 = getelementptr inbounds i16, i16* %19, i64 %idxprom41
  %20 = load i16, i16* %arrayidx42, align 2, !tbaa !15
  %conv43 = trunc i32 %and39 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %call, i16 zeroext %20, i16 zeroext %conv43)
  br label %if.end45

if.end45:                                         ; preds = %if.else, %if.then13
  %update_lock46 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock46)
  br label %cleanup

cleanup:                                          ; preds = %if.end45, %lor.lhs.false, %land.lhs.true, %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end45 ], [ -22, %if.end ], [ -22, %lor.lhs.false ], [ -22, %land.lhs.true ]
  %21 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_weight_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv8 = sext i32 %0 to i64
  ret i64 %conv8
}

; Function Attrs: nounwind uwtable
define internal i64 @store_weight_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %__UNIQUE_ID_min1_50 = alloca i64, align 8
  %__UNIQUE_ID_min1_48 = alloca i64, align 8
  %__UNIQUE_ID_min2_49 = alloca i64, align 8
  %__UNIQUE_ID_min2_51 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !84
  %conv = zext i8 %3 to i32
  %index2 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 1
  %4 = load i8, i8* %index2, align 8, !tbaa !85
  %conv3 = zext i8 %4 to i32
  %5 = bitcast i64* %val to i8*
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv6 = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %6 = bitcast i64* %__UNIQUE_ID_min1_50 to i8*
  %7 = bitcast i64* %__UNIQUE_ID_min1_48 to i8*
  %8 = load i64, i64* %val, align 8, !tbaa !106
  %div = sdiv i32 1000, 2
  %conv8 = sext i32 %div to i64
  %add = add i64 %8, %conv8
  %conv9 = sext i32 1000 to i64
  %div10 = udiv i64 %add, %conv9
  store i64 %div10, i64* %__UNIQUE_ID_min1_48, align 8, !tbaa !106
  %9 = bitcast i64* %__UNIQUE_ID_min2_49 to i8*
  store i64 0, i64* %__UNIQUE_ID_min2_49, align 8, !tbaa !106
  %10 = load i64, i64* %__UNIQUE_ID_min1_48, align 8, !tbaa !106
  %11 = load i64, i64* %__UNIQUE_ID_min2_49, align 8, !tbaa !106
  %cmp14 = icmp ugt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_48, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_49, align 8
  %cond = select i1 %cmp14, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_49 to i8*
  %15 = bitcast i64* %__UNIQUE_ID_min1_48 to i8*
  store i64 %cond, i64* %__UNIQUE_ID_min1_50, align 8, !tbaa !106
  %16 = bitcast i64* %__UNIQUE_ID_min2_51 to i8*
  store i64 255, i64* %__UNIQUE_ID_min2_51, align 8, !tbaa !106
  %17 = load i64, i64* %__UNIQUE_ID_min1_50, align 8, !tbaa !106
  %18 = load i64, i64* %__UNIQUE_ID_min2_51, align 8, !tbaa !106
  %cmp19 = icmp ult i64 %17, %18
  %19 = load i64, i64* %__UNIQUE_ID_min1_50, align 8
  %20 = load i64, i64* %__UNIQUE_ID_min2_51, align 8
  %cond24 = select i1 %cmp19, i64 %19, i64 %20
  %21 = bitcast i64* %__UNIQUE_ID_min2_51 to i8*
  %22 = bitcast i64* %__UNIQUE_ID_min1_50 to i8*
  store i64 %cond24, i64* %val, align 8, !tbaa !106
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %23 = load i64, i64* %val, align 8, !tbaa !106
  %conv25 = trunc i64 %23 to i8
  %weight_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 85
  %idxprom = sext i32 %conv3 to i64
  %arrayidx = getelementptr inbounds [3 x [6 x i8]], [3 x [6 x i8]]* %weight_temp, i64 0, i64 %idxprom
  %idxprom26 = sext i32 %conv to i64
  %arrayidx27 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx, i64 0, i64 %idxprom26
  store i8 %conv25, i8* %arrayidx27, align 1, !tbaa !59
  %REG_WEIGHT_TEMP = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 40
  %idxprom28 = sext i32 %conv3 to i64
  %arrayidx29 = getelementptr inbounds [3 x i16*], [3 x i16*]* %REG_WEIGHT_TEMP, i64 0, i64 %idxprom28
  %24 = load i16*, i16** %arrayidx29, align 8, !tbaa !6
  %idxprom30 = sext i32 %conv to i64
  %arrayidx31 = getelementptr inbounds i16, i16* %24, i64 %idxprom30
  %25 = load i16, i16* %arrayidx31, align 2, !tbaa !15
  %26 = load i64, i64* %val, align 8, !tbaa !106
  %conv32 = trunc i64 %26 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %25, i16 zeroext %conv32)
  %update_lock34 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock34)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv6, %if.then ], [ %count, %if.end ]
  %27 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_auto_pwm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv4 = sext i32 %0 to i64
  ret i64 %conv4
}

; Function Attrs: nounwind uwtable
define internal i64 @store_auto_pwm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !84
  %conv = zext i8 %3 to i32
  %index = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 1
  %4 = load i8, i8* %index, align 8, !tbaa !85
  %conv2 = zext i8 %4 to i32
  %5 = bitcast i64* %val to i8*
  %call3 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv5 = sext i32 %call3 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %6 = load i64, i64* %val, align 8, !tbaa !106
  %cmp6 = icmp ugt i64 %6, 255
  br i1 %cmp6, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end
  %auto_pwm_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 80
  %7 = load i32, i32* %auto_pwm_num, align 4, !tbaa !103
  %cmp10 = icmp eq i32 %conv2, %7
  br i1 %cmp10, label %if.then12, label %if.end24

if.then12:                                        ; preds = %if.end9
  %kind = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 2
  %8 = load i32, i32* %kind, align 8, !tbaa !44
  %cmp13 = icmp eq i32 %8, 1
  %9 = load i64, i64* %val, align 8
  %tobool = icmp ne i64 %9, 0
  %or.cond = or i1 %cmp13, %tobool
  br i1 %or.cond, label %if.end16, label %cleanup

if.end16:                                         ; preds = %if.then12
  %kind17 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 2
  %10 = load i32, i32* %kind17, align 8, !tbaa !44
  %cmp18 = icmp ne i32 %10, 3
  %11 = load i64, i64* %val, align 8
  %tobool21 = icmp ne i64 %11, 0
  %or.cond7 = and i1 %cmp18, %tobool21
  br i1 %or.cond7, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end16
  store i64 255, i64* %val, align 8, !tbaa !106
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %if.end16, %if.end9
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %12 = load i64, i64* %val, align 8, !tbaa !106
  %conv25 = trunc i64 %12 to i8
  %auto_pwm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 81
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_pwm, i64 0, i64 %idxprom
  %idxprom26 = sext i32 %conv2 to i64
  %arrayidx27 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx, i64 0, i64 %idxprom26
  store i8 %conv25, i8* %arrayidx27, align 1, !tbaa !59
  %auto_pwm_num28 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 80
  %13 = load i32, i32* %auto_pwm_num28, align 4, !tbaa !103
  %cmp29 = icmp slt i32 %conv2, %13
  br i1 %cmp29, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.end24
  %REG_AUTO_PWM = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 34
  %14 = load i16*, i16** %REG_AUTO_PWM, align 8, !tbaa !129
  %idxprom32 = sext i32 %conv to i64
  %arrayidx33 = getelementptr inbounds i16, i16* %14, i64 %idxprom32
  %15 = load i16, i16* %arrayidx33, align 2, !tbaa !15
  %conv34 = zext i16 %15 to i32
  %add = add nsw i32 %conv34, %conv2
  %conv35 = trunc i32 %add to i16
  %auto_pwm36 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 81
  %idxprom37 = sext i32 %conv to i64
  %arrayidx38 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_pwm36, i64 0, i64 %idxprom37
  %idxprom39 = sext i32 %conv2 to i64
  %arrayidx40 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx38, i64 0, i64 %idxprom39
  %16 = load i8, i8* %arrayidx40, align 1, !tbaa !59
  %conv41 = zext i8 %16 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %conv35, i16 zeroext %conv41)
  br label %if.end88

if.else:                                          ; preds = %if.end24
  %kind43 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 2
  %17 = load i32, i32* %kind43, align 8, !tbaa !44
  %Pivot6 = icmp slt i32 %17, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %if.else
  %Pivot4 = icmp sge i32 %17, 3
  %.off = add i32 %17, -3
  %SwitchLeaf2 = icmp ule i32 %.off, 3
  %or.cond8 = and i1 %Pivot4, %SwitchLeaf2
  br i1 %or.cond8, label %sw.bb60, label %if.end88

NodeBlock:                                        ; preds = %if.else
  %Pivot = icmp slt i32 %17, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %17, 0
  br i1 %SwitchLeaf, label %sw.bb60, label %if.end88

sw.bb:                                            ; preds = %NodeBlock
  %idxprom44 = sext i32 %conv to i64
  %arrayidx45 = getelementptr inbounds [3 x i16], [3 x i16]* @NCT6775_REG_CRITICAL_ENAB, i64 0, i64 %idxprom44
  %18 = load i16, i16* %arrayidx45, align 2, !tbaa !15
  %call46 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %18)
  %conv47 = trunc i16 %call46 to i8
  %19 = load i64, i64* %val, align 8, !tbaa !106
  %tobool48 = icmp ne i64 %19, 0
  %conv50 = zext i8 %conv47 to i32
  %and = and i32 %conv50, -3
  %or = or i32 %conv50, 2
  %and.sink = select i1 %tobool48, i32 %or, i32 %and
  %conv54 = trunc i32 %and.sink to i8
  %idxprom56 = sext i32 %conv to i64
  %arrayidx57 = getelementptr inbounds [3 x i16], [3 x i16]* @NCT6775_REG_CRITICAL_ENAB, i64 0, i64 %idxprom56
  %20 = load i16, i16* %arrayidx57, align 2, !tbaa !15
  %conv58 = zext i8 %conv54 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %20, i16 zeroext %conv58)
  br label %if.end88

sw.bb60:                                          ; preds = %LeafBlock, %NodeBlock3
  %REG_CRITICAL_PWM = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 32
  %21 = load i16*, i16** %REG_CRITICAL_PWM, align 8, !tbaa !134
  %idxprom61 = sext i32 %conv to i64
  %arrayidx62 = getelementptr inbounds i16, i16* %21, i64 %idxprom61
  %22 = load i16, i16* %arrayidx62, align 2, !tbaa !15
  %23 = load i64, i64* %val, align 8, !tbaa !106
  %conv63 = trunc i64 %23 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %22, i16 zeroext %conv63)
  %REG_CRITICAL_PWM_ENABLE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 30
  %24 = load i16*, i16** %REG_CRITICAL_PWM_ENABLE, align 8, !tbaa !132
  %idxprom65 = sext i32 %conv to i64
  %arrayidx66 = getelementptr inbounds i16, i16* %24, i64 %idxprom65
  %25 = load i16, i16* %arrayidx66, align 2, !tbaa !15
  %call67 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %25)
  %conv68 = trunc i16 %call67 to i8
  %26 = load i64, i64* %val, align 8, !tbaa !106
  %cmp69 = icmp eq i64 %26, 255
  %CRITICAL_PWM_ENABLE_MASK = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 31
  %27 = load i8, i8* %CRITICAL_PWM_ENABLE_MASK, align 8, !tbaa !133
  %conv72 = zext i8 %27 to i32
  br i1 %cmp69, label %if.then71, label %if.else76

if.then71:                                        ; preds = %sw.bb60
  %neg = xor i32 %conv72, -1
  %conv73 = zext i8 %conv68 to i32
  %and74 = and i32 %conv73, %neg
  br label %if.end82

if.else76:                                        ; preds = %sw.bb60
  %conv79 = zext i8 %conv68 to i32
  %or80 = or i32 %conv79, %conv72
  br label %if.end82

if.end82:                                         ; preds = %if.else76, %if.then71
  %or80.sink = phi i32 [ %or80, %if.else76 ], [ %and74, %if.then71 ]
  %conv81 = trunc i32 %or80.sink to i8
  %REG_CRITICAL_PWM_ENABLE83 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 30
  %28 = load i16*, i16** %REG_CRITICAL_PWM_ENABLE83, align 8, !tbaa !132
  %idxprom84 = sext i32 %conv to i64
  %arrayidx85 = getelementptr inbounds i16, i16* %28, i64 %idxprom84
  %29 = load i16, i16* %arrayidx85, align 2, !tbaa !15
  %conv86 = zext i8 %conv81 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %29, i16 zeroext %conv86)
  br label %if.end88

if.end88:                                         ; preds = %if.end82, %sw.bb, %LeafBlock, %NodeBlock3, %if.then31
  %update_lock89 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock89)
  br label %cleanup

cleanup:                                          ; preds = %if.end88, %if.then12, %if.end, %if.then
  %retval.0 = phi i64 [ %conv5, %if.then ], [ %count, %if.end88 ], [ -22, %if.end ], [ -22, %if.then12 ]
  %30 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_auto_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv7 = sext i32 %0 to i64
  ret i64 %conv7
}

; Function Attrs: nounwind uwtable
define internal i64 @store_auto_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !84
  %conv = zext i8 %3 to i32
  %index = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 1
  %4 = load i8, i8* %index, align 8, !tbaa !85
  %conv2 = zext i8 %4 to i32
  %5 = bitcast i64* %val to i8*
  %call3 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv4 = sext i32 %call3 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %6 = load i64, i64* %val, align 8, !tbaa !106
  %cmp = icmp ugt i64 %6, 255000
  br i1 %cmp, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %7 = load i64, i64* %val, align 8, !tbaa !106
  %div = sdiv i32 1000, 2
  %conv9 = sext i32 %div to i64
  %add = add i64 %7, %conv9
  %conv10 = sext i32 1000 to i64
  %div11 = udiv i64 %add, %conv10
  %conv12 = trunc i64 %div11 to i8
  %auto_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 82
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_temp, i64 0, i64 %idxprom
  %idxprom13 = sext i32 %conv2 to i64
  %arrayidx14 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx, i64 0, i64 %idxprom13
  store i8 %conv12, i8* %arrayidx14, align 1, !tbaa !59
  %auto_pwm_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 80
  %8 = load i32, i32* %auto_pwm_num, align 4, !tbaa !103
  %cmp15 = icmp slt i32 %conv2, %8
  br i1 %cmp15, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end7
  %REG_AUTO_TEMP = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 33
  %9 = load i16*, i16** %REG_AUTO_TEMP, align 8, !tbaa !130
  %idxprom18 = sext i32 %conv to i64
  %arrayidx19 = getelementptr inbounds i16, i16* %9, i64 %idxprom18
  %10 = load i16, i16* %arrayidx19, align 2, !tbaa !15
  %conv20 = zext i16 %10 to i32
  %add21 = add nsw i32 %conv20, %conv2
  %conv22 = trunc i32 %add21 to i16
  %auto_temp23 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 82
  %idxprom24 = sext i32 %conv to i64
  %arrayidx25 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_temp23, i64 0, i64 %idxprom24
  %idxprom26 = sext i32 %conv2 to i64
  %arrayidx27 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx25, i64 0, i64 %idxprom26
  %11 = load i8, i8* %arrayidx27, align 1, !tbaa !59
  %conv28 = zext i8 %11 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %conv22, i16 zeroext %conv28)
  br label %if.end39

if.else:                                          ; preds = %if.end7
  %REG_CRITICAL_TEMP = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 35
  %12 = load i16*, i16** %REG_CRITICAL_TEMP, align 8, !tbaa !131
  %idxprom30 = sext i32 %conv to i64
  %arrayidx31 = getelementptr inbounds i16, i16* %12, i64 %idxprom30
  %13 = load i16, i16* %arrayidx31, align 2, !tbaa !15
  %auto_temp32 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 82
  %idxprom33 = sext i32 %conv to i64
  %arrayidx34 = getelementptr inbounds [6 x [7 x i8]], [6 x [7 x i8]]* %auto_temp32, i64 0, i64 %idxprom33
  %idxprom35 = sext i32 %conv2 to i64
  %arrayidx36 = getelementptr inbounds [7 x i8], [7 x i8]* %arrayidx34, i64 0, i64 %idxprom35
  %14 = load i8, i8* %arrayidx36, align 1, !tbaa !59
  %conv37 = zext i8 %14 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %13, i16 zeroext %conv37)
  br label %if.end39

if.end39:                                         ; preds = %if.else, %if.then17
  %update_lock40 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock40)
  br label %cleanup

cleanup:                                          ; preds = %if.end39, %if.end, %if.then
  %retval.0 = phi i64 [ %conv4, %if.then ], [ %count, %if.end39 ], [ -22, %if.end ]
  %15 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @nct6775_in_is_visible(%struct.kobject* %kobj, %struct.attribute* %attr, i32 %index) #3 {
entry:
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %call = call i8* @dev_get_drvdata(%struct.device* %1)
  %2 = bitcast i8* %call to %struct.nct6775_data*
  %div = sdiv i32 %index, 5
  %have_in = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 91
  %3 = load i16, i16* %have_in, align 2, !tbaa !111
  %conv = zext i16 %3 to i32
  %shl = shl i32 1, %div
  %and = and i32 %conv, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 1
  %4 = load i16, i16* %mode, align 8, !tbaa !104
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i16 [ %4, %if.end ], [ 0, %entry ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_in_reg(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %index1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 1
  %2 = load i8, i8* %index1, align 8, !tbaa !85
  %conv = zext i8 %2 to i32
  %nr2 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 2
  %3 = load i8, i8* %nr2, align 1, !tbaa !84
  %conv3 = zext i8 %3 to i32
  %in = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 51
  %idxprom = sext i32 %conv3 to i64
  %arrayidx = getelementptr inbounds [15 x [3 x i8]], [15 x [3 x i8]]* %in, i64 0, i64 %idxprom
  %idxprom4 = sext i32 %conv to i64
  %arrayidx5 = getelementptr inbounds [3 x i8], [3 x i8]* %arrayidx, i64 0, i64 %idxprom4
  %4 = load i8, i8* %arrayidx5, align 1, !tbaa !59
  %conv6 = trunc i32 %conv3 to i8
  call void @in_from_reg(i8 zeroext %4, i8 zeroext %conv6)
  %5 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv9 = sext i32 %5 to i64
  ret i64 %conv9
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @in_from_reg(i8 zeroext %reg, i8 zeroext %nr) #4 {
entry:
  %conv = zext i8 %reg to i32
  %idxprom = zext i8 %nr to i64
  %arrayidx = getelementptr inbounds [15 x i16], [15 x i16]* @scale_in, i64 0, i64 %idxprom
  %0 = load i16, i16* %arrayidx, align 2, !tbaa !15
  %conv1 = zext i16 %0 to i32
  %mul = mul nsw i32 %conv, %conv1
  %cmp = icmp sgt i32 %mul, 0
  %conv2 = zext i1 %cmp to i32
  %cmp3 = icmp sgt i32 100, 0
  %conv4 = zext i1 %cmp3 to i32
  %cmp5 = icmp eq i32 %conv2, %conv4
  %div = sdiv i32 100, 2
  %sub = sub nsw i32 %mul, %div
  %add = add nsw i32 %mul, %div
  %sub.sink = select i1 %cmp5, i32 %add, i32 %sub
  %div9 = sdiv i32 %sub.sink, 100
  %conv10 = sext i32 %div9 to i64
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_alarm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv3 = sext i32 %0 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @show_beep(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv3 = sext i32 %0 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @store_beep(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %2 = bitcast i8* %call to %struct.nct6775_data*
  %BEEP_BITS = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 15
  %3 = load i8*, i8** %BEEP_BITS, align 8, !tbaa !137
  %index = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 1
  %4 = load i8, i8* %index, align 8, !tbaa !85
  %idxprom = zext i8 %4 to i64
  %arrayidx = getelementptr inbounds i8, i8* %3, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv = sext i8 %5 to i32
  %shr = ashr i32 %conv, 3
  %6 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv3 = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %7 = load i64, i64* %val, align 8, !tbaa !106
  %cmp4 = icmp ugt i64 %7, 1
  br i1 %cmp4, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %8 = load i64, i64* %val, align 8, !tbaa !106
  %tobool = icmp ne i64 %8, 0
  %sh_prom = zext i32 %conv to i64
  %shl = shl i64 1, %sh_prom
  br i1 %tobool, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end7
  %beeps = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 67
  %9 = load i64, i64* %beeps, align 8, !tbaa !120
  %or = or i64 %9, %shl
  store i64 %or, i64* %beeps, align 8, !tbaa !120
  br label %if.end12

if.else:                                          ; preds = %if.end7
  %neg = xor i64 %shl, -1
  %beeps11 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 67
  %10 = load i64, i64* %beeps11, align 8, !tbaa !120
  %and = and i64 %10, %neg
  store i64 %and, i64* %beeps11, align 8, !tbaa !120
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then8
  %REG_BEEP = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 43
  %11 = load i16*, i16** %REG_BEEP, align 8, !tbaa !121
  %idxprom13 = sext i32 %shr to i64
  %arrayidx14 = getelementptr inbounds i16, i16* %11, i64 %idxprom13
  %12 = load i16, i16* %arrayidx14, align 2, !tbaa !15
  %beeps15 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 67
  %13 = load i64, i64* %beeps15, align 8, !tbaa !120
  %shl16 = shl i32 %shr, 3
  %sh_prom17 = zext i32 %shl16 to i64
  %shr18 = lshr i64 %13, %sh_prom17
  %and19 = and i64 %shr18, 255
  %conv20 = trunc i64 %and19 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %2, i16 zeroext %12, i16 zeroext %conv20)
  %update_lock22 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock22)
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.end, %if.then
  %retval.0 = phi i64 [ %conv3, %if.then ], [ %count, %if.end12 ], [ -22, %if.end ]
  %14 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @store_in_reg(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %index1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 1
  %3 = load i8, i8* %index1, align 8, !tbaa !85
  %conv = zext i8 %3 to i32
  %nr2 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 2
  %4 = load i8, i8* %nr2, align 1, !tbaa !84
  %conv3 = zext i8 %4 to i32
  %5 = bitcast i64* %val to i8*
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv6 = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %6 = load i64, i64* %val, align 8, !tbaa !106
  %conv7 = trunc i64 %6 to i32
  %conv8 = trunc i32 %conv3 to i8
  %call9 = call zeroext i8 @in_to_reg(i32 %conv7, i8 zeroext %conv8)
  %in = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 51
  %idxprom = sext i32 %conv3 to i64
  %arrayidx = getelementptr inbounds [15 x [3 x i8]], [15 x [3 x i8]]* %in, i64 0, i64 %idxprom
  %idxprom10 = sext i32 %conv to i64
  %arrayidx11 = getelementptr inbounds [3 x i8], [3 x i8]* %arrayidx, i64 0, i64 %idxprom10
  store i8 %call9, i8* %arrayidx11, align 1, !tbaa !59
  %REG_IN_MINMAX = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 17
  %sub = sub nsw i32 %conv, 1
  %idxprom12 = sext i32 %sub to i64
  %arrayidx13 = getelementptr inbounds [2 x i16*], [2 x i16*]* %REG_IN_MINMAX, i64 0, i64 %idxprom12
  %7 = load i16*, i16** %arrayidx13, align 8, !tbaa !6
  %idxprom14 = sext i32 %conv3 to i64
  %arrayidx15 = getelementptr inbounds i16, i16* %7, i64 %idxprom14
  %8 = load i16, i16* %arrayidx15, align 2, !tbaa !15
  %in16 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 51
  %idxprom17 = sext i32 %conv3 to i64
  %arrayidx18 = getelementptr inbounds [15 x [3 x i8]], [15 x [3 x i8]]* %in16, i64 0, i64 %idxprom17
  %idxprom19 = sext i32 %conv to i64
  %arrayidx20 = getelementptr inbounds [3 x i8], [3 x i8]* %arrayidx18, i64 0, i64 %idxprom19
  %9 = load i8, i8* %arrayidx20, align 1, !tbaa !59
  %conv21 = zext i8 %9 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %8, i16 zeroext %conv21)
  %update_lock23 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock23)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv6, %if.then ], [ %count, %if.end ]
  %10 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @in_to_reg(i32 %val, i8 zeroext %nr) #4 {
entry:
  %__UNIQUE_ID_min1_22 = alloca i32, align 4
  %__UNIQUE_ID_min1_20 = alloca i32, align 4
  %__UNIQUE_ID_min2_21 = alloca i32, align 4
  %__UNIQUE_ID_min2_23 = alloca i32, align 4
  %0 = bitcast i32* %__UNIQUE_ID_min1_22 to i8*
  %1 = bitcast i32* %__UNIQUE_ID_min1_20 to i8*
  %mul = mul i32 %val, 100
  %idxprom = zext i8 %nr to i64
  %arrayidx = getelementptr inbounds [15 x i16], [15 x i16]* @scale_in, i64 0, i64 %idxprom
  %2 = load i16, i16* %arrayidx, align 2, !tbaa !15
  %conv = zext i16 %2 to i32
  %div = sdiv i32 %conv, 2
  %add = add i32 %mul, %div
  %conv1 = zext i16 %2 to i32
  %div2 = udiv i32 %add, %conv1
  store i32 %div2, i32* %__UNIQUE_ID_min1_20, align 4, !tbaa !2
  %3 = bitcast i32* %__UNIQUE_ID_min2_21 to i8*
  store i32 0, i32* %__UNIQUE_ID_min2_21, align 4, !tbaa !2
  %4 = load i32, i32* %__UNIQUE_ID_min1_20, align 4, !tbaa !2
  %5 = load i32, i32* %__UNIQUE_ID_min2_21, align 4, !tbaa !2
  %cmp5 = icmp ugt i32 %4, %5
  %6 = load i32, i32* %__UNIQUE_ID_min1_20, align 4
  %7 = load i32, i32* %__UNIQUE_ID_min2_21, align 4
  %cond = select i1 %cmp5, i32 %6, i32 %7
  %8 = bitcast i32* %__UNIQUE_ID_min2_21 to i8*
  %9 = bitcast i32* %__UNIQUE_ID_min1_20 to i8*
  store i32 %cond, i32* %__UNIQUE_ID_min1_22, align 4, !tbaa !2
  %10 = bitcast i32* %__UNIQUE_ID_min2_23 to i8*
  store i32 255, i32* %__UNIQUE_ID_min2_23, align 4, !tbaa !2
  %11 = load i32, i32* %__UNIQUE_ID_min1_22, align 4, !tbaa !2
  %12 = load i32, i32* %__UNIQUE_ID_min2_23, align 4, !tbaa !2
  %cmp10 = icmp ult i32 %11, %12
  %13 = load i32, i32* %__UNIQUE_ID_min1_22, align 4
  %14 = load i32, i32* %__UNIQUE_ID_min2_23, align 4
  %cond15 = select i1 %cmp10, i32 %13, i32 %14
  %15 = bitcast i32* %__UNIQUE_ID_min2_23 to i8*
  %16 = bitcast i32* %__UNIQUE_ID_min1_22 to i8*
  %conv16 = trunc i32 %cond15 to i8
  ret i8 %conv16
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @nct6775_fan_is_visible(%struct.kobject* %kobj, %struct.attribute* %attr, i32 %index) #3 {
entry:
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %call = call i8* @dev_get_drvdata(%struct.device* %1)
  %2 = bitcast i8* %call to %struct.nct6775_data*
  %div = sdiv i32 %index, 6
  %rem = srem i32 %index, 6
  %has_fan = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 57
  %3 = load i8, i8* %has_fan, align 1, !tbaa !62
  %conv = zext i8 %3 to i32
  %shl = shl i32 1, %div
  %and = and i32 %conv, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  switch i32 %rem, label %if.end33 [
    i32 1, label %land.lhs.true
    i32 2, label %land.lhs.true9
    i32 4, label %land.lhs.true20
    i32 5, label %land.lhs.true29
  ]

land.lhs.true:                                    ; preds = %if.end
  %ALARM_BITS = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 14
  %4 = load i8*, i8** %ALARM_BITS, align 8, !tbaa !138
  %add = add nsw i32 16, %div
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv2 = sext i8 %5 to i32
  %cmp3 = icmp eq i32 %conv2, -1
  br i1 %cmp3, label %cleanup, label %if.end6

if.end6:                                          ; preds = %land.lhs.true
  switch i32 %rem, label %if.end33 [
    i32 2, label %land.lhs.true9
    i32 4, label %land.lhs.true20
    i32 5, label %land.lhs.true29
  ]

land.lhs.true9:                                   ; preds = %if.end6, %if.end
  %BEEP_BITS = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 15
  %6 = load i8*, i8** %BEEP_BITS, align 8, !tbaa !137
  %add10 = add nsw i32 16, %div
  %idxprom11 = sext i32 %add10 to i64
  %arrayidx12 = getelementptr inbounds i8, i8* %6, i64 %idxprom11
  %7 = load i8, i8* %arrayidx12, align 1, !tbaa !59
  %conv13 = sext i8 %7 to i32
  %cmp14 = icmp eq i32 %conv13, -1
  br i1 %cmp14, label %cleanup, label %if.end17

if.end17:                                         ; preds = %land.lhs.true9
  switch i32 %rem, label %if.end33 [
    i32 4, label %land.lhs.true20
    i32 5, label %land.lhs.true29
  ]

land.lhs.true20:                                  ; preds = %if.end17, %if.end6, %if.end
  %has_fan_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 58
  %8 = load i8, i8* %has_fan_min, align 2, !tbaa !63
  %conv21 = zext i8 %8 to i32
  %shl22 = shl i32 1, %div
  %and23 = and i32 %conv21, %shl22
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.end26, label %cleanup

if.end26:                                         ; preds = %land.lhs.true20
  %cmp27 = icmp eq i32 %rem, 5
  br i1 %cmp27, label %land.lhs.true29, label %if.end33

land.lhs.true29:                                  ; preds = %if.end26, %if.end17, %if.end6, %if.end
  %kind = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 2
  %9 = load i32, i32* %kind, align 8, !tbaa !44
  %cmp30 = icmp ne i32 %9, 1
  br i1 %cmp30, label %cleanup, label %if.end33

if.end33:                                         ; preds = %land.lhs.true29, %if.end26, %if.end17, %if.end6, %if.end
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 1
  %10 = load i16, i16* %mode, align 8, !tbaa !104
  br label %cleanup

cleanup:                                          ; preds = %if.end33, %land.lhs.true29, %land.lhs.true20, %land.lhs.true9, %land.lhs.true, %entry
  %retval.0 = phi i16 [ %10, %if.end33 ], [ 0, %entry ], [ 0, %land.lhs.true ], [ 0, %land.lhs.true9 ], [ 0, %land.lhs.true20 ], [ 0, %land.lhs.true29 ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_pulses(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv2 = sext i32 %0 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @store_fan_pulses(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !94
  %4 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %val, align 8, !tbaa !106
  %cmp2 = icmp ugt i64 %5, 4
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %6 = load i64, i64* %val, align 8, !tbaa !106
  %and = and i64 %6, 3
  %conv6 = trunc i64 %and to i8
  %fan_pulses = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 54
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %fan_pulses, i64 0, i64 %idxprom
  store i8 %conv6, i8* %arrayidx, align 1, !tbaa !59
  %REG_FAN_PULSES = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 22
  %7 = load i16*, i16** %REG_FAN_PULSES, align 8, !tbaa !115
  %idxprom7 = sext i32 %3 to i64
  %arrayidx8 = getelementptr inbounds i16, i16* %7, i64 %idxprom7
  %8 = load i16, i16* %arrayidx8, align 2, !tbaa !15
  %call9 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %0, i16 zeroext %8)
  %conv10 = trunc i16 %call9 to i8
  %FAN_PULSE_SHIFT = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 23
  %9 = load i16*, i16** %FAN_PULSE_SHIFT, align 8, !tbaa !116
  %idxprom11 = sext i32 %3 to i64
  %arrayidx12 = getelementptr inbounds i16, i16* %9, i64 %idxprom11
  %10 = load i16, i16* %arrayidx12, align 2, !tbaa !15
  %conv13 = zext i16 %10 to i32
  %shl = shl i32 3, %conv13
  %neg = xor i32 %shl, -1
  %conv14 = zext i8 %conv10 to i32
  %and15 = and i32 %conv14, %neg
  %conv16 = trunc i32 %and15 to i8
  %11 = load i64, i64* %val, align 8, !tbaa !106
  %and17 = and i64 %11, 3
  %FAN_PULSE_SHIFT18 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 23
  %12 = load i16*, i16** %FAN_PULSE_SHIFT18, align 8, !tbaa !116
  %idxprom19 = sext i32 %3 to i64
  %arrayidx20 = getelementptr inbounds i16, i16* %12, i64 %idxprom19
  %13 = load i16, i16* %arrayidx20, align 2, !tbaa !15
  %conv21 = zext i16 %13 to i32
  %sh_prom = zext i32 %conv21 to i64
  %shl22 = shl i64 %and17, %sh_prom
  %conv23 = zext i8 %conv16 to i64
  %or = or i64 %conv23, %shl22
  %conv24 = trunc i64 %or to i8
  %REG_FAN_PULSES25 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 22
  %14 = load i16*, i16** %REG_FAN_PULSES25, align 8, !tbaa !115
  %idxprom26 = sext i32 %3 to i64
  %arrayidx27 = getelementptr inbounds i16, i16* %14, i64 %idxprom26
  %15 = load i16, i16* %arrayidx27, align 2, !tbaa !15
  %conv28 = zext i8 %conv24 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %15, i16 zeroext %conv28)
  %update_lock30 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock30)
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end5 ], [ -22, %if.end ]
  %16 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !94
  %fan_from_reg_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 45
  %3 = load i32 (i16, i32)*, i32 (i16, i32)** %fan_from_reg_min, align 8, !tbaa !139
  %fan_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 53
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min, i64 0, i64 %idxprom
  %4 = load i16, i16* %arrayidx, align 2, !tbaa !15
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 55
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 %idxprom1
  %5 = load i8, i8* %arrayidx2, align 1, !tbaa !59
  %conv = zext i8 %5 to i32
  %call3 = call i32 %3(i16 zeroext %4, i32 %conv)
  %6 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv5 = sext i32 %6 to i64
  ret i64 %conv5
}

; Function Attrs: nounwind uwtable
define internal i64 @store_fan_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !94
  %4 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %has_fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 59
  %5 = load i8, i8* %has_fan_div, align 1, !tbaa !65, !range !66
  %tobool = trunc i8 %5 to i1
  %6 = load i64, i64* %val, align 8, !tbaa !106
  %tobool13 = icmp ne i64 %6, 0
  br i1 %tobool, label %if.end12, label %if.then2

if.then2:                                         ; preds = %if.end
  br i1 %tobool13, label %if.else, label %if.then4

if.then4:                                         ; preds = %if.then2
  store i64 65311, i64* %val, align 8, !tbaa !106
  br label %if.end10

if.else:                                          ; preds = %if.then2
  %7 = load i64, i64* %val, align 8, !tbaa !106
  %cmp5 = icmp ugt i64 %7, 1350000
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.else
  store i64 135000, i64* %val, align 8, !tbaa !106
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.else
  %8 = load i64, i64* %val, align 8, !tbaa !106
  %div = udiv i64 1350000, %8
  store i64 %div, i64* %val, align 8, !tbaa !106
  %9 = load i64, i64* %val, align 8, !tbaa !106
  %and = and i64 %9, 31
  %10 = load i64, i64* %val, align 8, !tbaa !106
  %shl = shl i64 %10, 3
  %and9 = and i64 %shl, 65280
  %or = or i64 %and, %and9
  store i64 %or, i64* %val, align 8, !tbaa !106
  br label %if.end10

if.end10:                                         ; preds = %if.end8, %if.then4
  %11 = load i64, i64* %val, align 8, !tbaa !106
  %conv11 = trunc i64 %11 to i16
  %fan_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 53
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min, i64 0, i64 %idxprom
  store i16 %conv11, i16* %arrayidx, align 2, !tbaa !15
  br label %write_min

if.end12:                                         ; preds = %if.end
  br i1 %tobool13, label %if.end20, label %if.then14

if.then14:                                        ; preds = %if.end12
  %fan_min15 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 53
  %idxprom16 = sext i32 %3 to i64
  %arrayidx17 = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min15, i64 0, i64 %idxprom16
  store i16 255, i16* %arrayidx17, align 2, !tbaa !15
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 55
  %idxprom18 = sext i32 %3 to i64
  %arrayidx19 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 %idxprom18
  %12 = load i8, i8* %arrayidx19, align 1, !tbaa !59
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  br label %write_div

if.end20:                                         ; preds = %if.end12
  %13 = load i64, i64* %val, align 8, !tbaa !106
  %div21 = udiv i64 1350000, %13
  %conv22 = trunc i64 %div21 to i32
  %cmp23 = icmp uge i32 %conv22, 32640
  br i1 %cmp23, label %if.then25, label %if.else31

if.then25:                                        ; preds = %if.end20
  %fan_min26 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 53
  %idxprom27 = sext i32 %3 to i64
  %arrayidx28 = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min26, i64 0, i64 %idxprom27
  store i16 254, i16* %arrayidx28, align 2, !tbaa !15
  %fan_from_reg_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 45
  %14 = load i32 (i16, i32)*, i32 (i16, i32)** %fan_from_reg_min, align 8, !tbaa !139
  %call30 = call i32 %14(i16 zeroext 254, i32 7)
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %write_div

if.else31:                                        ; preds = %if.end20
  %tobool32 = icmp ne i32 %conv22, 0
  br i1 %tobool32, label %if.else40, label %if.then33

if.then33:                                        ; preds = %if.else31
  %fan_min34 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 53
  %idxprom35 = sext i32 %3 to i64
  %arrayidx36 = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min34, i64 0, i64 %idxprom35
  store i16 1, i16* %arrayidx36, align 2, !tbaa !15
  %fan_from_reg_min38 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 45
  %15 = load i32 (i16, i32)*, i32 (i16, i32)** %fan_from_reg_min38, align 8, !tbaa !139
  %call39 = call i32 %15(i16 zeroext 1, i32 0)
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* null, i8* null)
  br label %write_div

if.else40:                                        ; preds = %if.else31
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else40
  %reg.0 = phi i32 [ %conv22, %if.else40 ], [ %shr, %while.body ]
  %new_div.0 = phi i8 [ 0, %if.else40 ], [ %inc, %while.body ]
  %cmp41 = icmp ugt i32 %reg.0, 192
  %conv43 = zext i8 %new_div.0 to i32
  %cmp44 = icmp slt i32 %conv43, 7
  %16 = select i1 %cmp41, i1 %cmp44, i1 false
  br i1 %16, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %shr = lshr i32 %reg.0, 1
  %inc = add i8 %new_div.0, 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %conv46 = trunc i32 %reg.0 to i16
  %fan_min47 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 53
  %idxprom48 = sext i32 %3 to i64
  %arrayidx49 = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min47, i64 0, i64 %idxprom48
  store i16 %conv46, i16* %arrayidx49, align 2, !tbaa !15
  br label %write_div

write_div:                                        ; preds = %while.end, %if.then33, %if.then25, %if.then14
  %new_div.3 = phi i8 [ %12, %if.then14 ], [ 7, %if.then25 ], [ %new_div.0, %while.end ], [ 0, %if.then33 ]
  %conv52 = zext i8 %new_div.3 to i32
  %fan_div53 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 55
  %idxprom54 = sext i32 %3 to i64
  %arrayidx55 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div53, i64 0, i64 %idxprom54
  %17 = load i8, i8* %arrayidx55, align 1, !tbaa !59
  %conv56 = zext i8 %17 to i32
  %cmp57 = icmp ne i32 %conv52, %conv56
  br i1 %cmp57, label %do.body60, label %write_min

do.body60:                                        ; preds = %write_div
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @store_fan_min.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and61 = and i32 %bf.clear, 1
  %tobool62 = icmp ne i32 %and61, 0
  %lnot = xor i1 %tobool62, true
  %lnot63 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot63 to i32
  %conv64 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv64, i64 1)
  %tobool65 = icmp ne i64 %expval, 0
  br i1 %tobool65, label %if.then66, label %do.end75

if.then66:                                        ; preds = %do.body60
  %add67 = add nsw i32 %3, 1
  %fan_div68 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 55
  %idxprom69 = sext i32 %3 to i64
  %arrayidx70 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div68, i64 0, i64 %idxprom69
  %18 = load i8, i8* %arrayidx70, align 1, !tbaa !59
  %call71 = call i32 @div_from_reg(i8 zeroext %18)
  %call72 = call i32 @div_from_reg(i8 zeroext %new_div.3)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @store_fan_min.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.144, i32 0, i32 0), i32 %add67, i32 %call71, i32 %call72)
  br label %do.end75

do.end75:                                         ; preds = %if.then66, %do.body60
  %fan_div76 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 55
  %idxprom77 = sext i32 %3 to i64
  %arrayidx78 = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div76, i64 0, i64 %idxprom77
  store i8 %new_div.3, i8* %arrayidx78, align 1, !tbaa !59
  call void @nct6775_write_fan_div_common(%struct.nct6775_data* %0, i32 %3)
  %19 = load volatile i64, i64* @jiffies, align 8, !tbaa !106
  %last_updated = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 48
  store i64 %19, i64* %last_updated, align 8, !tbaa !108
  br label %write_min

write_min:                                        ; preds = %do.end75, %write_div, %if.end10
  %REG_FAN_MIN = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 21
  %20 = load i16*, i16** %REG_FAN_MIN, align 8, !tbaa !67
  %idxprom80 = sext i32 %3 to i64
  %arrayidx81 = getelementptr inbounds i16, i16* %20, i64 %idxprom80
  %21 = load i16, i16* %arrayidx81, align 2, !tbaa !15
  %fan_min82 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 53
  %idxprom83 = sext i32 %3 to i64
  %arrayidx84 = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min82, i64 0, i64 %idxprom83
  %22 = load i16, i16* %arrayidx84, align 2, !tbaa !15
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %21, i16 zeroext %22)
  %update_lock86 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock86)
  br label %cleanup

cleanup:                                          ; preds = %write_min, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %write_min ]
  %23 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

declare void @dev_warn(%struct.device*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_div(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !94
  %fan_div = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 55
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %fan_div, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %call1 = call i32 @div_from_reg(i8 zeroext %3)
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %4 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @nct6775_temp_is_visible(%struct.kobject* %kobj, %struct.attribute* %attr, i32 %index) #3 {
entry:
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %call = call i8* @dev_get_drvdata(%struct.device* %1)
  %2 = bitcast i8* %call to %struct.nct6775_data*
  %div = sdiv i32 %index, 10
  %rem = srem i32 %index, 10
  %have_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 89
  %3 = load i16, i16* %have_temp, align 2, !tbaa !53
  %conv = zext i16 %3 to i32
  %shl = shl i32 1, %div
  %and = and i32 %conv, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  switch i32 %rem, label %if.end53 [
    i32 2, label %land.lhs.true
    i32 3, label %land.lhs.true10
    i32 4, label %land.lhs.true19
    i32 5, label %land.lhs.true26
    i32 6, label %land.lhs.true36
    i32 7, label %land.lhs.true46
  ]

land.lhs.true:                                    ; preds = %if.end
  %num_temp_alarms = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 60
  %4 = load i8, i8* %num_temp_alarms, align 4, !tbaa !140
  %conv2 = zext i8 %4 to i32
  %call3 = call i32 @find_temp_source(%struct.nct6775_data* %2, i32 %div, i32 %conv2)
  %cmp4 = icmp slt i32 %call3, 0
  br i1 %cmp4, label %cleanup, label %if.end7

if.end7:                                          ; preds = %land.lhs.true
  switch i32 %rem, label %if.end53 [
    i32 3, label %land.lhs.true10
    i32 4, label %land.lhs.true19
    i32 5, label %land.lhs.true26
    i32 6, label %land.lhs.true36
    i32 7, label %land.lhs.true46
  ]

land.lhs.true10:                                  ; preds = %if.end7, %if.end
  %num_temp_beeps = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 61
  %5 = load i8, i8* %num_temp_beeps, align 1, !tbaa !141
  %conv11 = zext i8 %5 to i32
  %call12 = call i32 @find_temp_source(%struct.nct6775_data* %2, i32 %div, i32 %conv11)
  %cmp13 = icmp slt i32 %call12, 0
  br i1 %cmp13, label %cleanup, label %if.end16

if.end16:                                         ; preds = %land.lhs.true10
  switch i32 %rem, label %if.end53 [
    i32 4, label %land.lhs.true19
    i32 5, label %land.lhs.true26
    i32 6, label %land.lhs.true36
    i32 7, label %land.lhs.true46
  ]

land.lhs.true19:                                  ; preds = %if.end16, %if.end7, %if.end
  %reg_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 5
  %arrayidx = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %reg_temp, i64 0, i64 1
  %idxprom = sext i32 %div to i64
  %arrayidx20 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx, i64 0, i64 %idxprom
  %6 = load i16, i16* %arrayidx20, align 2, !tbaa !15
  %tobool21 = icmp ne i16 %6, 0
  br i1 %tobool21, label %if.end23, label %cleanup

if.end23:                                         ; preds = %land.lhs.true19
  switch i32 %rem, label %if.end53 [
    i32 5, label %land.lhs.true26
    i32 6, label %land.lhs.true36
    i32 7, label %land.lhs.true46
  ]

land.lhs.true26:                                  ; preds = %if.end23, %if.end16, %if.end7, %if.end
  %reg_temp27 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 5
  %arrayidx28 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %reg_temp27, i64 0, i64 2
  %idxprom29 = sext i32 %div to i64
  %arrayidx30 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx28, i64 0, i64 %idxprom29
  %7 = load i16, i16* %arrayidx30, align 2, !tbaa !15
  %tobool31 = icmp ne i16 %7, 0
  br i1 %tobool31, label %if.end33, label %cleanup

if.end33:                                         ; preds = %land.lhs.true26
  switch i32 %rem, label %if.end53 [
    i32 6, label %land.lhs.true36
    i32 7, label %land.lhs.true46
  ]

land.lhs.true36:                                  ; preds = %if.end33, %if.end23, %if.end16, %if.end7, %if.end
  %reg_temp37 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 5
  %arrayidx38 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %reg_temp37, i64 0, i64 3
  %idxprom39 = sext i32 %div to i64
  %arrayidx40 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx38, i64 0, i64 %idxprom39
  %8 = load i16, i16* %arrayidx40, align 2, !tbaa !15
  %tobool41 = icmp ne i16 %8, 0
  br i1 %tobool41, label %if.end43, label %cleanup

if.end43:                                         ; preds = %land.lhs.true36
  %cmp44 = icmp eq i32 %rem, 7
  br i1 %cmp44, label %land.lhs.true46, label %if.end53

land.lhs.true46:                                  ; preds = %if.end43, %if.end33, %if.end23, %if.end16, %if.end7, %if.end
  %reg_temp47 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 5
  %arrayidx48 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %reg_temp47, i64 0, i64 4
  %idxprom49 = sext i32 %div to i64
  %arrayidx50 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx48, i64 0, i64 %idxprom49
  %9 = load i16, i16* %arrayidx50, align 2, !tbaa !15
  %tobool51 = icmp ne i16 %9, 0
  br i1 %tobool51, label %if.end53, label %cleanup

if.end53:                                         ; preds = %land.lhs.true46, %if.end43, %if.end33, %if.end23, %if.end16, %if.end7, %if.end
  %cmp54 = icmp sgt i32 %rem, 7
  br i1 %cmp54, label %land.lhs.true56, label %if.end62

land.lhs.true56:                                  ; preds = %if.end53
  %have_temp_fixed = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 90
  %10 = load i16, i16* %have_temp_fixed, align 8, !tbaa !57
  %conv57 = zext i16 %10 to i32
  %shl58 = shl i32 1, %div
  %and59 = and i32 %conv57, %shl58
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %if.end62, label %cleanup

if.end62:                                         ; preds = %land.lhs.true56, %if.end53
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 1
  %11 = load i16, i16* %mode, align 8, !tbaa !104
  br label %cleanup

cleanup:                                          ; preds = %if.end62, %land.lhs.true56, %land.lhs.true46, %land.lhs.true36, %land.lhs.true26, %land.lhs.true19, %land.lhs.true10, %land.lhs.true, %entry
  %retval.0 = phi i16 [ %11, %if.end62 ], [ 0, %entry ], [ 0, %land.lhs.true ], [ 0, %land.lhs.true10 ], [ 0, %land.lhs.true19 ], [ 0, %land.lhs.true26 ], [ 0, %land.lhs.true36 ], [ 0, %land.lhs.true46 ], [ 0, %land.lhs.true56 ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 2
  %2 = load i8, i8* %nr1, align 1, !tbaa !84
  %conv = zext i8 %2 to i32
  %index2 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 1
  %3 = load i8, i8* %index2, align 8, !tbaa !85
  %conv3 = zext i8 %3 to i32
  %temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 65
  %idxprom = sext i32 %conv3 to i64
  %arrayidx = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %temp, i64 0, i64 %idxprom
  %idxprom4 = sext i32 %conv to i64
  %arrayidx5 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx, i64 0, i64 %idxprom4
  %4 = load i16, i16* %arrayidx5, align 2, !tbaa !15
  call void @LM75_TEMP_FROM_REG(i16 zeroext %4)
  %5 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv8 = sext i32 %5 to i64
  ret i64 %conv8
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @LM75_TEMP_FROM_REG(i16 zeroext %reg) #4 {
entry:
  %conv = sext i16 %reg to i32
  %div = sdiv i32 %conv, 128
  %mul = mul nsw i32 %div, 500
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_label(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv = sext i32 %0 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_alarm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !94
  %num_temp_alarms = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 60
  %3 = load i8, i8* %num_temp_alarms, align 4, !tbaa !140
  %conv = zext i8 %3 to i32
  %call1 = call i32 @find_temp_source(%struct.nct6775_data* %call, i32 %2, i32 %conv)
  %cmp = icmp sge i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv6 = sext i32 %4 to i64
  ret i64 %conv6
}

; Function Attrs: nounwind uwtable
define internal i32 @find_temp_source(%struct.nct6775_data* %data, i32 %index, i32 %count) #3 {
entry:
  %temp_src = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 6
  %idxprom = sext i32 %index to i64
  %arrayidx = getelementptr inbounds [10 x i8], [10 x i8]* %temp_src, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv = zext i8 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %nr.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %nr.0.retval.0, %for.inc ]
  %cmp = icmp slt i32 %nr.0, %count
  br i1 %cmp, label %for.body, label %cleanup7

for.body:                                         ; preds = %for.cond
  %REG_TEMP_SOURCE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %data, i32 0, i32 37
  %1 = load i16*, i16** %REG_TEMP_SOURCE, align 8, !tbaa !51
  %idxprom2 = sext i32 %nr.0 to i64
  %arrayidx3 = getelementptr inbounds i16, i16* %1, i64 %idxprom2
  %2 = load i16, i16* %arrayidx3, align 2, !tbaa !15
  %call = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %data, i16 zeroext %2)
  %conv4 = zext i16 %call to i32
  %and = and i32 %conv4, 31
  %cmp5 = icmp eq i32 %and, %conv
  %. = select i1 %cmp5, i32 1, i32 0
  %nr.0.retval.0 = select i1 %cmp5, i32 %nr.0, i32 %retval.0
  %SwitchLeaf = icmp eq i32 %., 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup7

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %nr.0, 1
  br label %for.cond

cleanup7:                                         ; preds = %for.body, %for.cond
  %retval.2 = phi i32 [ -19, %for.cond ], [ %nr.0.retval.0, %for.body ]
  ret i32 %retval.2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_beep(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !94
  %num_temp_beeps = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 61
  %3 = load i8, i8* %num_temp_beeps, align 1, !tbaa !141
  %conv = zext i8 %3 to i32
  %call1 = call i32 @find_temp_source(%struct.nct6775_data* %call, i32 %2, i32 %conv)
  %cmp = icmp sge i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv6 = sext i32 %4 to i64
  ret i64 %conv6
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_beep(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %2 = bitcast i8* %call to %struct.nct6775_data*
  %3 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %4 = load i64, i64* %val, align 8, !tbaa !106
  %cmp2 = icmp ugt i64 %4, 1
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %index = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 1
  %5 = load i8, i8* %index, align 8, !tbaa !85
  %conv6 = zext i8 %5 to i32
  %num_temp_beeps = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 61
  %6 = load i8, i8* %num_temp_beeps, align 1, !tbaa !141
  %conv7 = zext i8 %6 to i32
  %call8 = call i32 @find_temp_source(%struct.nct6775_data* %2, i32 %conv6, i32 %conv7)
  %cmp9 = icmp slt i32 %call8, 0
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end5
  %conv12 = sext i32 %call8 to i64
  br label %cleanup

if.end13:                                         ; preds = %if.end5
  %BEEP_BITS = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 15
  %7 = load i8*, i8** %BEEP_BITS, align 8, !tbaa !137
  %add = add nsw i32 %call8, 24
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr inbounds i8, i8* %7, i64 %idxprom
  %8 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv14 = sext i8 %8 to i32
  %shr = ashr i32 %conv14, 3
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %9 = load i64, i64* %val, align 8, !tbaa !106
  %tobool = icmp ne i64 %9, 0
  %sh_prom = zext i32 %conv14 to i64
  %shl = shl i64 1, %sh_prom
  br i1 %tobool, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end13
  %beeps = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 67
  %10 = load i64, i64* %beeps, align 8, !tbaa !120
  %or = or i64 %10, %shl
  store i64 %or, i64* %beeps, align 8, !tbaa !120
  br label %if.end19

if.else:                                          ; preds = %if.end13
  %neg = xor i64 %shl, -1
  %beeps18 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 67
  %11 = load i64, i64* %beeps18, align 8, !tbaa !120
  %and = and i64 %11, %neg
  store i64 %and, i64* %beeps18, align 8, !tbaa !120
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then15
  %REG_BEEP = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 43
  %12 = load i16*, i16** %REG_BEEP, align 8, !tbaa !121
  %idxprom20 = sext i32 %shr to i64
  %arrayidx21 = getelementptr inbounds i16, i16* %12, i64 %idxprom20
  %13 = load i16, i16* %arrayidx21, align 2, !tbaa !15
  %beeps22 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 67
  %14 = load i64, i64* %beeps22, align 8, !tbaa !120
  %shl23 = shl i32 %shr, 3
  %sh_prom24 = zext i32 %shl23 to i64
  %shr25 = lshr i64 %14, %sh_prom24
  %and26 = and i64 %shr25, 255
  %conv27 = trunc i64 %and26 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %2, i16 zeroext %13, i16 zeroext %conv27)
  %update_lock29 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock29)
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then11, %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %conv12, %if.then11 ], [ %count, %if.end19 ], [ -22, %if.end ]
  %15 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !84
  %conv = zext i8 %3 to i32
  %index2 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %2, i32 0, i32 1
  %4 = load i8, i8* %index2, align 8, !tbaa !85
  %conv3 = zext i8 %4 to i32
  %5 = bitcast i64* %val to i8*
  %call4 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv6 = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %6 = load i64, i64* %val, align 8, !tbaa !106
  %call7 = call zeroext i16 @LM75_TEMP_TO_REG(i64 %6)
  %temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 65
  %idxprom = sext i32 %conv3 to i64
  %arrayidx = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %temp, i64 0, i64 %idxprom
  %idxprom8 = sext i32 %conv to i64
  %arrayidx9 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx, i64 0, i64 %idxprom8
  store i16 %call7, i16* %arrayidx9, align 2, !tbaa !15
  %reg_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 5
  %idxprom10 = sext i32 %conv3 to i64
  %arrayidx11 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %reg_temp, i64 0, i64 %idxprom10
  %idxprom12 = sext i32 %conv to i64
  %arrayidx13 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx11, i64 0, i64 %idxprom12
  %7 = load i16, i16* %arrayidx13, align 2, !tbaa !15
  %temp14 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 65
  %idxprom15 = sext i32 %conv3 to i64
  %arrayidx16 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %temp14, i64 0, i64 %idxprom15
  %idxprom17 = sext i32 %conv to i64
  %arrayidx18 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx16, i64 0, i64 %idxprom17
  %8 = load i16, i16* %arrayidx18, align 2, !tbaa !15
  call void @nct6775_write_temp(%struct.nct6775_data* %0, i16 zeroext %7, i16 zeroext %8)
  %update_lock20 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock20)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv6, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtol(i8* %s, i32 %base, i64* %res) #4 {
entry:
  %call = call i32 @kstrtoll(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @LM75_TEMP_TO_REG(i64 %temp) #4 {
entry:
  %__UNIQUE_ID_min1_10 = alloca i64, align 8
  %__UNIQUE_ID_min1_8 = alloca i64, align 8
  %__UNIQUE_ID_min2_9 = alloca i64, align 8
  %__UNIQUE_ID_min2_11 = alloca i64, align 8
  %0 = bitcast i64* %__UNIQUE_ID_min1_10 to i8*
  %1 = bitcast i64* %__UNIQUE_ID_min1_8 to i8*
  store i64 %temp, i64* %__UNIQUE_ID_min1_8, align 8, !tbaa !106
  %2 = bitcast i64* %__UNIQUE_ID_min2_9 to i8*
  store i64 -55000, i64* %__UNIQUE_ID_min2_9, align 8, !tbaa !106
  %3 = load i64, i64* %__UNIQUE_ID_min1_8, align 8, !tbaa !106
  %4 = load i64, i64* %__UNIQUE_ID_min2_9, align 8, !tbaa !106
  %cmp1 = icmp sgt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_8, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_9, align 8
  %cond = select i1 %cmp1, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_9 to i8*
  %8 = bitcast i64* %__UNIQUE_ID_min1_8 to i8*
  store i64 %cond, i64* %__UNIQUE_ID_min1_10, align 8, !tbaa !106
  %9 = bitcast i64* %__UNIQUE_ID_min2_11 to i8*
  store i64 125000, i64* %__UNIQUE_ID_min2_11, align 8, !tbaa !106
  %10 = load i64, i64* %__UNIQUE_ID_min1_10, align 8, !tbaa !106
  %11 = load i64, i64* %__UNIQUE_ID_min2_11, align 8, !tbaa !106
  %cmp6 = icmp slt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_10, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_11, align 8
  %cond11 = select i1 %cmp6, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_11 to i8*
  %15 = bitcast i64* %__UNIQUE_ID_min1_10 to i8*
  %conv12 = trunc i64 %cond11 to i32
  %cmp13 = icmp slt i32 %conv12, 0
  %cond15 = select i1 %cmp13, i32 -250, i32 250
  %add = add nsw i32 %conv12, %cond15
  %div = sdiv i32 %add, 500
  %shl = shl i32 %div, 7
  %conv16 = trunc i32 %shl to i16
  ret i16 %conv16
}

; Function Attrs: nounwind uwtable
define internal void @nct6775_write_temp(%struct.nct6775_data* %data, i16 zeroext %reg, i16 zeroext %value) #3 {
entry:
  %call = call zeroext i1 @is_word_sized(%struct.nct6775_data* %data, i16 zeroext %reg)
  %conv = zext i16 %value to i32
  %shr = ashr i32 %conv, 8
  %conv1 = trunc i32 %shr to i16
  %value.addr.0 = select i1 %call, i16 %value, i16 %conv1
  call void @nct6775_write_value(%struct.nct6775_data* %data, i16 zeroext %reg, i16 zeroext %value.addr.0)
  ret void
}

declare i32 @kstrtoll(i8*, i32, i64*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_offset(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv2 = sext i32 %0 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_offset(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %__UNIQUE_ID_min1_26 = alloca i64, align 8
  %__UNIQUE_ID_min1_24 = alloca i64, align 8
  %__UNIQUE_ID_min2_25 = alloca i64, align 8
  %__UNIQUE_ID_min2_27 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !94
  %4 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = bitcast i64* %__UNIQUE_ID_min1_26 to i8*
  %6 = bitcast i64* %__UNIQUE_ID_min1_24 to i8*
  %7 = load i64, i64* %val, align 8, !tbaa !106
  %cmp3 = icmp sgt i64 %7, 0
  %conv4 = zext i1 %cmp3 to i32
  %cmp5 = icmp sgt i32 1000, 0
  %conv6 = zext i1 %cmp5 to i32
  %cmp7 = icmp eq i32 %conv4, %conv6
  %div = sdiv i32 1000, 2
  %conv9 = sext i32 %div to i64
  %sub = sub nsw i64 %7, %conv9
  %add = add nsw i64 %7, %conv9
  %sub.sink = select i1 %cmp7, i64 %add, i64 %sub
  %conv14 = sext i32 1000 to i64
  %div15 = sdiv i64 %sub.sink, %conv14
  store i64 %div15, i64* %__UNIQUE_ID_min1_24, align 8, !tbaa !106
  %8 = bitcast i64* %__UNIQUE_ID_min2_25 to i8*
  store i64 -128, i64* %__UNIQUE_ID_min2_25, align 8, !tbaa !106
  %9 = load i64, i64* %__UNIQUE_ID_min1_24, align 8, !tbaa !106
  %10 = load i64, i64* %__UNIQUE_ID_min2_25, align 8, !tbaa !106
  %cmp19 = icmp sgt i64 %9, %10
  %11 = load i64, i64* %__UNIQUE_ID_min1_24, align 8
  %12 = load i64, i64* %__UNIQUE_ID_min2_25, align 8
  %cond24 = select i1 %cmp19, i64 %11, i64 %12
  %13 = bitcast i64* %__UNIQUE_ID_min2_25 to i8*
  %14 = bitcast i64* %__UNIQUE_ID_min1_24 to i8*
  store i64 %cond24, i64* %__UNIQUE_ID_min1_26, align 8, !tbaa !106
  %15 = bitcast i64* %__UNIQUE_ID_min2_27 to i8*
  store i64 127, i64* %__UNIQUE_ID_min2_27, align 8, !tbaa !106
  %16 = load i64, i64* %__UNIQUE_ID_min1_26, align 8, !tbaa !106
  %17 = load i64, i64* %__UNIQUE_ID_min2_27, align 8, !tbaa !106
  %cmp28 = icmp slt i64 %16, %17
  %18 = load i64, i64* %__UNIQUE_ID_min1_26, align 8
  %19 = load i64, i64* %__UNIQUE_ID_min2_27, align 8
  %cond33 = select i1 %cmp28, i64 %18, i64 %19
  %20 = bitcast i64* %__UNIQUE_ID_min2_27 to i8*
  %21 = bitcast i64* %__UNIQUE_ID_min1_26 to i8*
  store i64 %cond33, i64* %val, align 8, !tbaa !106
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %22 = load i64, i64* %val, align 8, !tbaa !106
  %conv34 = trunc i64 %22 to i8
  %temp_offset = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 64
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %temp_offset, i64 0, i64 %idxprom
  store i8 %conv34, i8* %arrayidx, align 1, !tbaa !59
  %REG_TEMP_OFFSET = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 41
  %23 = load i16*, i16** %REG_TEMP_OFFSET, align 8, !tbaa !117
  %idxprom35 = sext i32 %3 to i64
  %arrayidx36 = getelementptr inbounds i16, i16* %23, i64 %idxprom35
  %24 = load i16, i16* %arrayidx36, align 2, !tbaa !15
  %25 = load i64, i64* %val, align 8, !tbaa !106
  %conv37 = trunc i64 %25 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %24, i16 zeroext %conv37)
  %update_lock39 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock39)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %26 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_type(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv2 = sext i32 %0 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_type(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !94
  %3 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %4 = load i64, i64* %val, align 8, !tbaa !106
  %cmp2 = icmp ne i64 %4, 1
  %5 = load i64, i64* %val, align 8
  %cmp4 = icmp ne i64 %5, 3
  %or.cond = and i1 %cmp2, %cmp4
  %6 = load i64, i64* %val, align 8
  %cmp7 = icmp ne i64 %6, 4
  %or.cond5 = and i1 %or.cond, %cmp7
  br i1 %or.cond5, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %7 = load i64, i64* %val, align 8, !tbaa !106
  %conv11 = trunc i64 %7 to i8
  %temp_type = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 63
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %temp_type, i64 0, i64 %idxprom
  store i8 %conv11, i8* %arrayidx, align 1, !tbaa !59
  %shl = shl i32 2, %2
  %conv12 = trunc i32 %shl to i8
  %DIODE_MASK = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 13
  %8 = load i8, i8* %DIODE_MASK, align 2, !tbaa !58
  %conv13 = zext i8 %8 to i32
  %shl14 = shl i32 %conv13, %2
  %conv15 = trunc i32 %shl14 to i8
  %REG_VBAT = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 11
  %9 = load i16, i16* %REG_VBAT, align 2, !tbaa !54
  %call16 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %call, i16 zeroext %9)
  %conv17 = zext i16 %call16 to i32
  %conv18 = zext i8 %conv12 to i32
  %neg = xor i32 %conv18, -1
  %and = and i32 %conv17, %neg
  %conv19 = trunc i32 %and to i8
  %REG_DIODE = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 12
  %10 = load i16, i16* %REG_DIODE, align 8, !tbaa !55
  %call20 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %call, i16 zeroext %10)
  %conv21 = zext i16 %call20 to i32
  %conv22 = zext i8 %conv15 to i32
  %neg23 = xor i32 %conv22, -1
  %and24 = and i32 %conv21, %neg23
  %conv25 = trunc i32 %and24 to i8
  %11 = load i64, i64* %val, align 8, !tbaa !106
  %Pivot4 = icmp slt i64 %11, 3
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end10
  %Pivot = icmp slt i64 %11, 4
  br i1 %Pivot, label %sw.bb33, label %sw.epilog

LeafBlock:                                        ; preds = %if.end10
  %SwitchLeaf = icmp eq i64 %11, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %conv26 = zext i8 %conv12 to i32
  %conv27 = zext i8 %conv19 to i32
  %or = or i32 %conv27, %conv26
  %conv28 = trunc i32 %or to i8
  %conv29 = zext i8 %conv15 to i32
  %conv30 = zext i8 %conv25 to i32
  %or31 = or i32 %conv30, %conv29
  %conv32 = trunc i32 %or31 to i8
  br label %sw.epilog

sw.bb33:                                          ; preds = %NodeBlock
  %conv34 = zext i8 %conv15 to i32
  %conv35 = zext i8 %conv19 to i32
  %or36 = or i32 %conv35, %conv34
  %conv37 = trunc i32 %or36 to i8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb33, %sw.bb, %LeafBlock, %NodeBlock
  %vbat.0 = phi i8 [ %conv28, %sw.bb ], [ %conv37, %sw.bb33 ], [ %conv19, %LeafBlock ], [ %conv19, %NodeBlock ]
  %diode.0 = phi i8 [ %conv32, %sw.bb ], [ %conv25, %sw.bb33 ], [ %conv25, %LeafBlock ], [ %conv25, %NodeBlock ]
  %REG_VBAT38 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 11
  %12 = load i16, i16* %REG_VBAT38, align 2, !tbaa !54
  %conv39 = zext i8 %vbat.0 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %call, i16 zeroext %12, i16 zeroext %conv39)
  %REG_DIODE41 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 12
  %13 = load i16, i16* %REG_DIODE41, align 8, !tbaa !55
  %conv42 = zext i8 %diode.0 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %call, i16 zeroext %13, i16 zeroext %conv42)
  %update_lock44 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock44)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %sw.epilog ], [ -22, %if.end ]
  %14 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @nct6775_other_is_visible(%struct.kobject* %kobj, %struct.attribute* %attr, i32 %index) #3 {
entry:
  %0 = bitcast %struct.kobject* %kobj to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -16
  %1 = bitcast i8* %add.ptr to %struct.device*
  %call = call i8* @dev_get_drvdata(%struct.device* %1)
  %2 = bitcast i8* %call to %struct.nct6775_data*
  switch i32 %index, label %if.end24 [
    i32 0, label %land.lhs.true
    i32 1, label %if.then3
    i32 2, label %if.then3
    i32 3, label %if.then14
    i32 4, label %if.then14
  ]

land.lhs.true:                                    ; preds = %entry
  %have_vid = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 88
  %3 = load i8, i8* %have_vid, align 4, !tbaa !142, !range !66
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %land.lhs.true
  switch i32 %index, label %if.end24 [
    i32 1, label %if.then3
    i32 2, label %if.then3
    i32 3, label %if.then14
    i32 4, label %if.then14
  ]

if.then3:                                         ; preds = %if.end, %if.end, %entry, %entry
  %ALARM_BITS = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 14
  %4 = load i8*, i8** %ALARM_BITS, align 8, !tbaa !138
  %add = add nsw i32 30, %index
  %sub = sub nsw i32 %add, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv = sext i8 %5 to i32
  %cmp4 = icmp slt i32 %conv, 0
  br i1 %cmp4, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.then3
  %index.off = add i32 %index, -3
  %switch = icmp ult i32 %index.off, 2
  br i1 %switch, label %if.then14, label %if.end24

if.then14:                                        ; preds = %if.end8, %if.end, %if.end, %entry, %entry
  %BEEP_BITS = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %2, i32 0, i32 15
  %6 = load i8*, i8** %BEEP_BITS, align 8, !tbaa !137
  %add15 = add nsw i32 30, %index
  %sub16 = sub nsw i32 %add15, 3
  %idxprom17 = sext i32 %sub16 to i64
  %arrayidx18 = getelementptr inbounds i8, i8* %6, i64 %idxprom17
  %7 = load i8, i8* %arrayidx18, align 1, !tbaa !59
  %conv19 = sext i8 %7 to i32
  %cmp20 = icmp slt i32 %conv19, 0
  br i1 %cmp20, label %cleanup, label %if.end24

if.end24:                                         ; preds = %if.then14, %if.end8, %if.end, %entry
  %mode = getelementptr inbounds %struct.attribute, %struct.attribute* %attr, i32 0, i32 1
  %8 = load i16, i16* %mode, align 8, !tbaa !104
  br label %cleanup

cleanup:                                          ; preds = %if.end24, %if.then14, %if.then3, %land.lhs.true
  %retval.0 = phi i16 [ %8, %if.end24 ], [ 0, %land.lhs.true ], [ 0, %if.then3 ], [ 0, %if.then14 ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @cpu0_vid_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #3 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %vid = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 86
  %1 = load i8, i8* %vid, align 2, !tbaa !143
  %conv = zext i8 %1 to i32
  %vrm = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 87
  %2 = load i8, i8* %vrm, align 1, !tbaa !144
  %call1 = call i32 @vid_from_reg(i32 %conv, i8 zeroext %2)
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %conv3 = sext i32 %3 to i64
  ret i64 %conv3
}

declare i32 @vid_from_reg(i32, i8 zeroext) #2

; Function Attrs: nounwind uwtable
define internal i64 @clear_caseopen(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #3 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %1 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !94
  %sub = sub nsw i32 %3, 30
  %4 = bitcast i64* %val to i8*
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  %5 = load i64, i64* %val, align 8
  %cmp = icmp ne i64 %5, 0
  %or.cond = or i1 %tobool, %cmp
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %sioreg = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 1
  %6 = load i32, i32* %sioreg, align 4, !tbaa !60
  %call2 = call i32 @superio_enter(i32 %6)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %conv = sext i32 %call2 to i64
  br label %error

if.end5:                                          ; preds = %if.end
  %sioreg6 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 1
  %7 = load i32, i32* %sioreg6, align 4, !tbaa !60
  call void @superio_select(i32 %7, i32 10)
  %sioreg7 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 1
  %8 = load i32, i32* %sioreg7, align 4, !tbaa !60
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* @NCT6775_REG_CR_CASEOPEN_CLR, i64 0, i64 %idxprom
  %9 = load i8, i8* %arrayidx, align 1, !tbaa !59
  %conv8 = zext i8 %9 to i32
  %call9 = call i32 @superio_inb(i32 %8, i32 %conv8)
  %conv10 = trunc i32 %call9 to i8
  %idxprom11 = sext i32 %sub to i64
  %arrayidx12 = getelementptr inbounds [2 x i8], [2 x i8]* @NCT6775_CR_CASEOPEN_CLR_MASK, i64 0, i64 %idxprom11
  %10 = load i8, i8* %arrayidx12, align 1, !tbaa !59
  %conv13 = zext i8 %10 to i32
  %conv14 = zext i8 %conv10 to i32
  %or = or i32 %conv14, %conv13
  %conv15 = trunc i32 %or to i8
  %sioreg16 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 1
  %11 = load i32, i32* %sioreg16, align 4, !tbaa !60
  %idxprom17 = sext i32 %sub to i64
  %arrayidx18 = getelementptr inbounds [2 x i8], [2 x i8]* @NCT6775_REG_CR_CASEOPEN_CLR, i64 0, i64 %idxprom17
  %12 = load i8, i8* %arrayidx18, align 1, !tbaa !59
  %conv19 = zext i8 %12 to i32
  %conv20 = zext i8 %conv15 to i32
  call void @superio_outb(i32 %11, i32 %conv19, i32 %conv20)
  %idxprom21 = sext i32 %sub to i64
  %arrayidx22 = getelementptr inbounds [2 x i8], [2 x i8]* @NCT6775_CR_CASEOPEN_CLR_MASK, i64 0, i64 %idxprom21
  %13 = load i8, i8* %arrayidx22, align 1, !tbaa !59
  %conv23 = zext i8 %13 to i32
  %neg = xor i32 %conv23, -1
  %conv24 = zext i8 %conv15 to i32
  %and = and i32 %conv24, %neg
  %conv25 = trunc i32 %and to i8
  %sioreg26 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 1
  %14 = load i32, i32* %sioreg26, align 4, !tbaa !60
  %idxprom27 = sext i32 %sub to i64
  %arrayidx28 = getelementptr inbounds [2 x i8], [2 x i8]* @NCT6775_REG_CR_CASEOPEN_CLR, i64 0, i64 %idxprom27
  %15 = load i8, i8* %arrayidx28, align 1, !tbaa !59
  %conv29 = zext i8 %15 to i32
  %conv30 = zext i8 %conv25 to i32
  call void @superio_outb(i32 %14, i32 %conv29, i32 %conv30)
  %sioreg31 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 1
  %16 = load i32, i32* %sioreg31, align 4, !tbaa !60
  call void @superio_exit(i32 %16)
  %valid = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 47
  store i8 0, i8* %valid, align 8, !tbaa !109
  br label %error

error:                                            ; preds = %if.end5, %if.then4
  %count.addr.0 = phi i64 [ %conv, %if.then4 ], [ %count, %if.end5 ]
  %update_lock32 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock32)
  br label %cleanup

cleanup:                                          ; preds = %error, %entry
  %retval.0 = phi i64 [ %count.addr.0, %error ], [ -22, %entry ]
  %17 = bitcast i64* %val to i8*
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @nct6775_suspend(%struct.device* %dev) #3 {
entry:
  %call = call %struct.nct6775_data* @nct6775_update_device(%struct.device* %dev)
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %REG_VBAT = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 11
  %0 = load i16, i16* %REG_VBAT, align 2, !tbaa !54
  %call1 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %call, i16 zeroext %0)
  %conv = trunc i16 %call1 to i8
  %vbat = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 92
  store i8 %conv, i8* %vbat, align 4, !tbaa !145
  %kind = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 2
  %1 = load i32, i32* %kind, align 8, !tbaa !44
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %call, i16 zeroext 1286)
  %conv4 = trunc i16 %call3 to i8
  %fandiv1 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 93
  store i8 %conv4, i8* %fandiv1, align 1, !tbaa !146
  %call5 = call zeroext i16 @nct6775_read_value(%struct.nct6775_data* %call, i16 zeroext 1287)
  %conv6 = trunc i16 %call5 to i8
  %fandiv2 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 94
  store i8 %conv6, i8* %fandiv2, align 2, !tbaa !147
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %update_lock7 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %call, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @nct6775_resume(%struct.device* %dev) #3 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.nct6775_data*
  %sioreg1 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 1
  %1 = load i32, i32* %sioreg1, align 4, !tbaa !60
  %update_lock = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %bank = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 49
  store i8 -1, i8* %bank, align 8, !tbaa !99
  %call2 = call i32 @superio_enter(i32 %1)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %abort, label %if.end

if.end:                                           ; preds = %entry
  call void @superio_select(i32 %1, i32 11)
  %call3 = call i32 @superio_inb(i32 %1, i32 48)
  %conv = trunc i32 %call3 to i8
  %conv4 = zext i8 %conv to i32
  %sio_reg_enable = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 95
  %2 = load i8, i8* %sio_reg_enable, align 1, !tbaa !61
  %conv5 = zext i8 %2 to i32
  %cmp = icmp ne i32 %conv4, %conv5
  br i1 %cmp, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end
  %sio_reg_enable8 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 95
  %3 = load i8, i8* %sio_reg_enable8, align 1, !tbaa !61
  %conv9 = zext i8 %3 to i32
  call void @superio_outb(i32 %1, i32 48, i32 %conv9)
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end
  %kind = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 2
  %4 = load i32, i32* %kind, align 8, !tbaa !44
  %cmp11 = icmp eq i32 %4, 4
  br i1 %cmp11, label %if.then20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end10
  %kind13 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 2
  %5 = load i32, i32* %kind13, align 8, !tbaa !44
  %cmp14 = icmp eq i32 %5, 5
  br i1 %cmp14, label %if.then20, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %lor.lhs.false
  %kind17 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 2
  %6 = load i32, i32* %kind17, align 8, !tbaa !44
  %cmp18 = icmp eq i32 %6, 6
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false16, %lor.lhs.false, %if.end10
  call void @nct6791_enable_io_mapping(i32 %1)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %lor.lhs.false16
  call void @superio_exit(i32 %1)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end21
  %i.0 = phi i32 [ 0, %if.end21 ], [ %inc, %for.inc ]
  %in_num = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 50
  %7 = load i8, i8* %in_num, align 1, !tbaa !110
  %conv22 = zext i8 %7 to i32
  %cmp23 = icmp slt i32 %i.0, %conv22
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %have_in = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 91
  %8 = load i16, i16* %have_in, align 2, !tbaa !111
  %conv25 = zext i16 %8 to i32
  %shl = shl i32 1, %i.0
  %and = and i32 %conv25, %shl
  %tobool26 = icmp ne i32 %and, 0
  br i1 %tobool26, label %if.end28, label %for.inc

if.end28:                                         ; preds = %for.body
  %REG_IN_MINMAX = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 17
  %arrayidx = getelementptr inbounds [2 x i16*], [2 x i16*]* %REG_IN_MINMAX, i64 0, i64 0
  %9 = load i16*, i16** %arrayidx, align 8, !tbaa !6
  %idxprom = sext i32 %i.0 to i64
  %arrayidx29 = getelementptr inbounds i16, i16* %9, i64 %idxprom
  %10 = load i16, i16* %arrayidx29, align 2, !tbaa !15
  %in = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 51
  %idxprom30 = sext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds [15 x [3 x i8]], [15 x [3 x i8]]* %in, i64 0, i64 %idxprom30
  %arrayidx32 = getelementptr inbounds [3 x i8], [3 x i8]* %arrayidx31, i64 0, i64 1
  %11 = load i8, i8* %arrayidx32, align 1, !tbaa !59
  %conv33 = zext i8 %11 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %10, i16 zeroext %conv33)
  %REG_IN_MINMAX35 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 17
  %arrayidx36 = getelementptr inbounds [2 x i16*], [2 x i16*]* %REG_IN_MINMAX35, i64 0, i64 1
  %12 = load i16*, i16** %arrayidx36, align 8, !tbaa !6
  %idxprom37 = sext i32 %i.0 to i64
  %arrayidx38 = getelementptr inbounds i16, i16* %12, i64 %idxprom37
  %13 = load i16, i16* %arrayidx38, align 2, !tbaa !15
  %in39 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 51
  %idxprom40 = sext i32 %i.0 to i64
  %arrayidx41 = getelementptr inbounds [15 x [3 x i8]], [15 x [3 x i8]]* %in39, i64 0, i64 %idxprom40
  %arrayidx42 = getelementptr inbounds [3 x i8], [3 x i8]* %arrayidx41, i64 0, i64 2
  %14 = load i8, i8* %arrayidx42, align 1, !tbaa !59
  %conv43 = zext i8 %14 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %13, i16 zeroext %conv43)
  br label %for.inc

for.inc:                                          ; preds = %if.end28, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc61, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc62, %for.inc61 ]
  %conv46 = sext i32 %i.1 to i64
  %cmp47 = icmp ult i64 %conv46, 6
  br i1 %cmp47, label %for.body49, label %for.end63

for.body49:                                       ; preds = %for.cond45
  %has_fan_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 58
  %15 = load i8, i8* %has_fan_min, align 2, !tbaa !63
  %conv50 = zext i8 %15 to i32
  %shl51 = shl i32 1, %i.1
  %and52 = and i32 %conv50, %shl51
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %if.end55, label %for.inc61

if.end55:                                         ; preds = %for.body49
  %REG_FAN_MIN = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 21
  %16 = load i16*, i16** %REG_FAN_MIN, align 8, !tbaa !67
  %idxprom56 = sext i32 %i.1 to i64
  %arrayidx57 = getelementptr inbounds i16, i16* %16, i64 %idxprom56
  %17 = load i16, i16* %arrayidx57, align 2, !tbaa !15
  %fan_min = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 53
  %idxprom58 = sext i32 %i.1 to i64
  %arrayidx59 = getelementptr inbounds [6 x i16], [6 x i16]* %fan_min, i64 0, i64 %idxprom58
  %18 = load i16, i16* %arrayidx59, align 2, !tbaa !15
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %17, i16 zeroext %18)
  br label %for.inc61

for.inc61:                                        ; preds = %if.end55, %for.body49
  %inc62 = add nsw i32 %i.1, 1
  br label %for.cond45

for.end63:                                        ; preds = %for.cond45
  br label %for.cond64

for.cond64:                                       ; preds = %for.inc99, %for.end63
  %i.2 = phi i32 [ 0, %for.end63 ], [ %inc100, %for.inc99 ]
  %cmp65 = icmp slt i32 %i.2, 10
  br i1 %cmp65, label %for.body67, label %for.end101

for.body67:                                       ; preds = %for.cond64
  %have_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 89
  %19 = load i16, i16* %have_temp, align 2, !tbaa !53
  %conv68 = zext i16 %19 to i32
  %shl69 = shl i32 1, %i.2
  %and70 = and i32 %conv68, %shl69
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %if.end73, label %for.inc99

if.end73:                                         ; preds = %for.body67
  br label %for.cond74

for.cond74:                                       ; preds = %for.inc96, %if.end73
  %j.0 = phi i32 [ 1, %if.end73 ], [ %inc97, %for.inc96 ]
  %conv75 = sext i32 %j.0 to i64
  %cmp76 = icmp ult i64 %conv75, 5
  br i1 %cmp76, label %for.body78, label %for.inc99

for.body78:                                       ; preds = %for.cond74
  %reg_temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 5
  %idxprom79 = sext i32 %j.0 to i64
  %arrayidx80 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %reg_temp, i64 0, i64 %idxprom79
  %idxprom81 = sext i32 %i.2 to i64
  %arrayidx82 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx80, i64 0, i64 %idxprom81
  %20 = load i16, i16* %arrayidx82, align 2, !tbaa !15
  %tobool83 = icmp ne i16 %20, 0
  br i1 %tobool83, label %if.then84, label %for.inc96

if.then84:                                        ; preds = %for.body78
  %reg_temp85 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 5
  %idxprom86 = sext i32 %j.0 to i64
  %arrayidx87 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %reg_temp85, i64 0, i64 %idxprom86
  %idxprom88 = sext i32 %i.2 to i64
  %arrayidx89 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx87, i64 0, i64 %idxprom88
  %21 = load i16, i16* %arrayidx89, align 2, !tbaa !15
  %temp = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 65
  %idxprom90 = sext i32 %j.0 to i64
  %arrayidx91 = getelementptr inbounds [5 x [10 x i16]], [5 x [10 x i16]]* %temp, i64 0, i64 %idxprom90
  %idxprom92 = sext i32 %i.2 to i64
  %arrayidx93 = getelementptr inbounds [10 x i16], [10 x i16]* %arrayidx91, i64 0, i64 %idxprom92
  %22 = load i16, i16* %arrayidx93, align 2, !tbaa !15
  call void @nct6775_write_temp(%struct.nct6775_data* %0, i16 zeroext %21, i16 zeroext %22)
  br label %for.inc96

for.inc96:                                        ; preds = %if.then84, %for.body78
  %inc97 = add nsw i32 %j.0, 1
  br label %for.cond74

for.inc99:                                        ; preds = %for.cond74, %for.body67
  %inc100 = add nsw i32 %i.2, 1
  br label %for.cond64

for.end101:                                       ; preds = %for.cond64
  %REG_VBAT = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 11
  %23 = load i16, i16* %REG_VBAT, align 2, !tbaa !54
  %vbat = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 92
  %24 = load i8, i8* %vbat, align 4, !tbaa !145
  %conv102 = zext i8 %24 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext %23, i16 zeroext %conv102)
  %kind104 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 2
  %25 = load i32, i32* %kind104, align 8, !tbaa !44
  %cmp105 = icmp eq i32 %25, 1
  br i1 %cmp105, label %if.then107, label %abort

if.then107:                                       ; preds = %for.end101
  %fandiv1 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 93
  %26 = load i8, i8* %fandiv1, align 1, !tbaa !146
  %conv108 = zext i8 %26 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext 1286, i16 zeroext %conv108)
  %fandiv2 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 94
  %27 = load i8, i8* %fandiv2, align 2, !tbaa !147
  %conv110 = zext i8 %27 to i16
  call void @nct6775_write_value(%struct.nct6775_data* %0, i16 zeroext 1287, i16 zeroext %conv110)
  br label %abort

abort:                                            ; preds = %if.then107, %for.end101, %entry
  %valid = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 47
  store i8 0, i8* %valid, align 8, !tbaa !109
  %update_lock113 = getelementptr inbounds %struct.nct6775_data, %struct.nct6775_data* %0, i32 0, i32 46
  call void @mutex_unlock(%struct.mutex* %update_lock113)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal void @nct6791_enable_io_mapping(i32 %sioaddr) #3 {
entry:
  %call = call i32 @superio_inb(i32 %sioaddr, i32 40)
  %and = and i32 %call, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = call i32 (i8*, ...) @printk(i8* null)
  %and2 = and i32 %call, -17
  call void @superio_outb(i32 %sioaddr, i32 40, i32 %and2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @printk(i8*, ...) #2

declare void @__dynamic_pr_debug(%struct._ddebug*, i8*, ...) #2

declare void @simpll__inlineasm_0(i8, i32)

declare i8 @simpll__inlineasm_1(i32)

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone }
attributes #6 = { nounwind }
attributes #7 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !7, i64 0}
!7 = !{!"any pointer", !4, i64 0}
!8 = !{!9, !7, i64 16}
!9 = !{!"resource", !10, i64 0, !10, i64 8, !7, i64 16, !11, i64 24, !11, i64 32, !7, i64 40, !7, i64 48, !7, i64 56}
!10 = !{!"long long", !4, i64 0}
!11 = !{!"long", !4, i64 0}
!12 = !{!9, !10, i64 0}
!13 = !{!9, !10, i64 8}
!14 = !{!9, !11, i64 24}
!15 = !{!16, !16, i64 0}
!16 = !{!"short", !4, i64 0}
!17 = !{!18, !4, i64 4}
!18 = !{!"nct6775_sio_data", !3, i64 0, !4, i64 4}
!19 = !{!18, !3, i64 0}
!20 = !{!21, !7, i64 472}
!21 = !{!"device", !7, i64 0, !7, i64 8, !22, i64 16, !7, i64 280, !7, i64 288, !33, i64 296, !7, i64 456, !7, i64 464, !7, i64 472, !7, i64 480, !36, i64 488, !37, i64 528, !7, i64 1104, !7, i64 1112, !7, i64 1120, !23, i64 1128, !3, i64 1144, !7, i64 1152, !7, i64 1160, !10, i64 1168, !11, i64 1176, !7, i64 1184, !23, i64 1192, !7, i64 1208, !7, i64 1216, !42, i64 1224, !7, i64 1232, !7, i64 1240, !3, i64 1248, !3, i64 1252, !34, i64 1256, !23, i64 1328, !43, i64 1344, !7, i64 1376, !7, i64 1384, !7, i64 1392, !7, i64 1400, !7, i64 1408, !39, i64 1416, !39, i64 1416}
!22 = !{!"kobject", !7, i64 0, !23, i64 8, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !24, i64 56, !27, i64 64, !3, i64 256, !3, i64 256, !3, i64 256, !3, i64 256, !3, i64 256}
!23 = !{!"list_head", !7, i64 0, !7, i64 8}
!24 = !{!"kref", !25, i64 0}
!25 = !{!"refcount_struct", !26, i64 0}
!26 = !{!"", !3, i64 0}
!27 = !{!"delayed_work", !28, i64 0, !31, i64 80, !7, i64 176, !3, i64 184}
!28 = !{!"work_struct", !29, i64 0, !23, i64 8, !7, i64 24, !30, i64 32}
!29 = !{!"", !11, i64 0}
!30 = !{!"lockdep_map", !7, i64 0, !4, i64 8, !7, i64 24, !3, i64 32, !11, i64 40}
!31 = !{!"timer_list", !32, i64 0, !11, i64 16, !7, i64 24, !11, i64 32, !3, i64 40, !30, i64 48}
!32 = !{!"hlist_node", !7, i64 0, !7, i64 8}
!33 = !{!"mutex", !29, i64 0, !34, i64 8, !35, i64 80, !23, i64 88, !7, i64 104, !30, i64 112}
!34 = !{!"spinlock", !4, i64 0}
!35 = !{!"optimistic_spin_queue", !26, i64 0}
!36 = !{!"dev_links_info", !23, i64 0, !23, i64 16, !4, i64 32}
!37 = !{!"dev_pm_info", !38, i64 0, !3, i64 4, !3, i64 4, !39, i64 4, !39, i64 4, !39, i64 4, !39, i64 4, !39, i64 4, !39, i64 4, !39, i64 5, !34, i64 8, !23, i64 80, !40, i64 96, !7, i64 192, !39, i64 200, !39, i64 200, !39, i64 200, !31, i64 208, !11, i64 304, !28, i64 312, !41, i64 392, !7, i64 480, !26, i64 488, !26, i64 492, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !3, i64 496, !39, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 497, !3, i64 500, !4, i64 504, !4, i64 508, !3, i64 512, !3, i64 516, !11, i64 520, !11, i64 528, !11, i64 536, !11, i64 544, !7, i64 552, !7, i64 560, !7, i64 568}
!38 = !{!"pm_message", !3, i64 0}
!39 = !{!"_Bool", !4, i64 0}
!40 = !{!"completion", !3, i64 0, !41, i64 8}
!41 = !{!"__wait_queue_head", !34, i64 0, !23, i64 72}
!42 = !{!"dev_archdata", !7, i64 0}
!43 = !{!"klist_node", !7, i64 0, !23, i64 8, !24, i64 24}
!44 = !{!45, !4, i64 8}
!45 = !{!"nct6775_data", !3, i64 0, !3, i64 4, !4, i64 8, !7, i64 16, !4, i64 24, !4, i64 72, !4, i64 172, !4, i64 182, !7, i64 208, !3, i64 216, !16, i64 220, !16, i64 222, !16, i64 224, !4, i64 226, !7, i64 232, !7, i64 240, !7, i64 248, !4, i64 256, !7, i64 272, !7, i64 280, !7, i64 288, !7, i64 296, !7, i64 304, !7, i64 312, !4, i64 320, !7, i64 344, !7, i64 352, !7, i64 360, !4, i64 368, !7, i64 424, !7, i64 432, !4, i64 440, !7, i64 448, !7, i64 456, !7, i64 464, !7, i64 472, !7, i64 480, !7, i64 488, !7, i64 496, !7, i64 504, !4, i64 512, !7, i64 536, !7, i64 544, !7, i64 552, !7, i64 560, !7, i64 568, !33, i64 576, !39, i64 736, !11, i64 744, !4, i64 752, !4, i64 753, !4, i64 754, !4, i64 800, !4, i64 824, !4, i64 836, !4, i64 842, !4, i64 848, !4, i64 849, !4, i64 850, !39, i64 851, !4, i64 852, !4, i64 853, !4, i64 854, !4, i64 855, !4, i64 861, !4, i64 868, !10, i64 968, !10, i64 976, !4, i64 984, !4, i64 985, !4, i64 992, !4, i64 1016, !4, i64 1058, !4, i64 1064, !4, i64 1068, !4, i64 1092, !4, i64 1116, !4, i64 1117, !4, i64 1129, !4, i64 1130, !3, i64 1148, !4, i64 1152, !4, i64 1194, !4, i64 1236, !4, i64 1242, !4, i64 1248, !4, i64 1266, !4, i64 1267, !39, i64 1268, !16, i64 1270, !16, i64 1272, !16, i64 1274, !4, i64 1276, !4, i64 1277, !4, i64 1278, !4, i64 1279}
!46 = !{!45, !3, i64 0}
!47 = !{!45, !4, i64 984}
!48 = !{!45, !3, i64 216}
!49 = !{!45, !7, i64 208}
!50 = !{i32 633744}
!51 = !{!45, !7, i64 488}
!52 = !{!45, !16, i64 220}
!53 = !{!45, !16, i64 1270}
!54 = !{!45, !16, i64 222}
!55 = !{!45, !16, i64 224}
!56 = !{!45, !4, i64 854}
!57 = !{!45, !16, i64 1272}
!58 = !{!45, !4, i64 226}
!59 = !{!4, !4, i64 0}
!60 = !{!45, !3, i64 4}
!61 = !{!45, !4, i64 1279}
!62 = !{!45, !4, i64 849}
!63 = !{!45, !4, i64 850}
!64 = !{!45, !4, i64 848}
!65 = !{!45, !39, i64 851}
!66 = !{i8 0, i8 2}
!67 = !{!45, !7, i64 296}
!68 = !{!69, !7, i64 0}
!69 = !{!"sensor_template_group", !7, i64 0, !7, i64 8, !3, i64 16}
!70 = !{!71, !7, i64 24}
!71 = !{!"attribute_group", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32}
!72 = !{!69, !7, i64 8}
!73 = !{!71, !7, i64 8}
!74 = !{!75, !7, i64 0}
!75 = !{!"sensor_device_template", !76, i64 0, !4, i64 48, !39, i64 52}
!76 = !{!"device_attribute", !77, i64 0, !7, i64 32, !7, i64 40}
!77 = !{!"attribute", !7, i64 0, !16, i64 8, !39, i64 10, !7, i64 16, !78, i64 24}
!78 = !{!"lock_class_key", !4, i64 0}
!79 = !{!69, !3, i64 16}
!80 = !{!75, !39, i64 52}
!81 = !{!77, !7, i64 16}
!82 = !{!83, !7, i64 0}
!83 = !{!"sensor_device_attribute_2", !76, i64 0, !4, i64 48, !4, i64 49}
!84 = !{!83, !4, i64 49}
!85 = !{!83, !4, i64 48}
!86 = !{!75, !16, i64 8}
!87 = !{!83, !16, i64 8}
!88 = !{!75, !7, i64 32}
!89 = !{!83, !7, i64 32}
!90 = !{!75, !7, i64 40}
!91 = !{!83, !7, i64 40}
!92 = !{!93, !7, i64 0}
!93 = !{!"sensor_device_attribute", !76, i64 0, !3, i64 48}
!94 = !{!93, !3, i64 48}
!95 = !{!93, !16, i64 8}
!96 = !{!93, !7, i64 32}
!97 = !{!93, !7, i64 40}
!98 = !{!21, !7, i64 480}
!99 = !{!45, !4, i64 752}
!100 = !{!101, !7, i64 192}
!101 = !{!"pv_cpu_ops", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !7, i64 128, !7, i64 136, !7, i64 144, !7, i64 152, !7, i64 160, !7, i64 168, !7, i64 176, !7, i64 184, !7, i64 192, !7, i64 200, !7, i64 208, !7, i64 216, !7, i64 224, !7, i64 232, !7, i64 240, !7, i64 248, !7, i64 256, !7, i64 264, !7, i64 272, !7, i64 280}
!102 = !{!45, !7, i64 504}
!103 = !{!45, !3, i64 1148}
!104 = !{!77, !16, i64 8}
!105 = !{!45, !7, i64 424}
!106 = !{!11, !11, i64 0}
!107 = !{!45, !7, i64 496}
!108 = !{!45, !11, i64 744}
!109 = !{!45, !39, i64 736}
!110 = !{!45, !4, i64 753}
!111 = !{!45, !16, i64 1274}
!112 = !{!45, !7, i64 248}
!113 = !{!45, !7, i64 280}
!114 = !{!45, !7, i64 560}
!115 = !{!45, !7, i64 304}
!116 = !{!45, !7, i64 312}
!117 = !{!45, !7, i64 536}
!118 = !{!45, !10, i64 968}
!119 = !{!45, !7, i64 544}
!120 = !{!45, !10, i64 976}
!121 = !{!45, !7, i64 552}
!122 = !{!45, !7, i64 352}
!123 = !{!45, !7, i64 360}
!124 = !{!45, !7, i64 288}
!125 = !{!45, !7, i64 344}
!126 = !{!45, !7, i64 480}
!127 = !{!45, !7, i64 272}
!128 = !{!45, !4, i64 1064}
!129 = !{!45, !7, i64 464}
!130 = !{!45, !7, i64 456}
!131 = !{!45, !7, i64 472}
!132 = !{!45, !7, i64 432}
!133 = !{!45, !4, i64 440}
!134 = !{!45, !7, i64 448}
!135 = !{!45, !4, i64 1129}
!136 = !{!45, !4, i64 1116}
!137 = !{!45, !7, i64 240}
!138 = !{!45, !7, i64 232}
!139 = !{!45, !7, i64 568}
!140 = !{!45, !4, i64 852}
!141 = !{!45, !4, i64 853}
!142 = !{!45, !39, i64 1268}
!143 = !{!45, !4, i64 1266}
!144 = !{!45, !4, i64 1267}
!145 = !{!45, !4, i64 1276}
!146 = !{!45, !4, i64 1277}
!147 = !{!45, !4, i64 1278}
