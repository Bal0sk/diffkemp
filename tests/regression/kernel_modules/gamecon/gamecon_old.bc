; ModuleID = 'drivers/input/joystick/gamecon.bc'
source_filename = "drivers/input/joystick/gamecon.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon }
%union.anon = type { i8* }
%struct.kparam_array = type { i32, i32, i32*, %struct.kernel_param_ops*, i8* }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.task_struct = type opaque
%struct.cpumask = type { [64 x i64] }
%struct.gc_config = type { [6 x i32], i32 }
%struct.gc = type { %struct.pardevice*, [5 x %struct.gc_pad], %struct.timer_list, [10 x i32], i32, %struct.mutex }
%struct.pardevice = type { i8*, %struct.parport*, i32, i32 (i8*)*, void (i8*)*, i8*, void (i8*)*, i32, %struct.pardevice*, %struct.pardevice*, %struct.parport_state*, %struct.__wait_queue_head, i64, i64, i64, i64, %struct.pardevice*, %struct.pardevice*, i8* }
%struct.parport = type { i64, i64, i32, i8*, i32, i32, i32, i32, i32, %struct.device*, %struct.parport*, %struct.pardevice*, %struct.pardevice*, i32, i32, %struct.pardevice*, %struct.pardevice*, %struct.list_head, i32, i8*, [5 x %struct.parport_device_info], %struct.ieee1284_info, %struct.parport_operations*, i8*, i32, %struct.spinlock, %struct.spinlock, %struct.rwlock_t, i32, %struct.atomic_t, i64, %struct.pardevice*, %struct.list_head, [3 x %struct.parport*] }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%union.ktime = type { i64 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.atomic64_t = type { i64 }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%union.anon.2 = type { %struct.list_head }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.12, %struct.list_head, %struct.hlist_node }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.page = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.5, i32 }
%union.anon.5 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i32 }
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%union.anon.12 = type { %struct.list_head }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.7, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.8, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.11, i32, i32, %struct.hlist_head, %struct.atomic_t, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.7 = type { i32 }
%struct.timespec = type { i64, i64 }
%union.anon.8 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.9 }
%struct.files_struct = type opaque
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.9 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.rb_root = type { %struct.rb_node* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.6, i32 }
%union.anon.6 = type { i8* }
%struct.swap_info_struct = type opaque
%union.anon.11 = type { %struct.pipe_inode_info* }
%struct.pipe_inode_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type opaque
%struct.vm_area_struct = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.cred = type opaque
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.parport_device_info = type { i32, i8*, i8*, i8*, i8*, i8* }
%struct.ieee1284_info = type { i32, i32, %struct.semaphore }
%struct.semaphore = type { %struct.raw_spinlock, i32, %struct.list_head }
%struct.parport_operations = type { void (%struct.parport*, i8)*, i8 (%struct.parport*)*, void (%struct.parport*, i8)*, i8 (%struct.parport*)*, i8 (%struct.parport*, i8, i8)*, i8 (%struct.parport*)*, void (%struct.parport*)*, void (%struct.parport*)*, void (%struct.parport*)*, void (%struct.parport*)*, void (%struct.pardevice*, %struct.parport_state*)*, void (%struct.parport*, %struct.parport_state*)*, void (%struct.parport*, %struct.parport_state*)*, i64 (%struct.parport*, i8*, i64, i32)*, i64 (%struct.parport*, i8*, i64, i32)*, i64 (%struct.parport*, i8*, i64, i32)*, i64 (%struct.parport*, i8*, i64, i32)*, i64 (%struct.parport*, i8*, i64, i32)*, i64 (%struct.parport*, i8*, i64, i32)*, i64 (%struct.parport*, i8*, i64, i32)*, i64 (%struct.parport*, i8*, i64, i32)*, i64 (%struct.parport*, i8*, i64, i32)*, i64 (%struct.parport*, i8*, i64, i32)*, %struct.module* }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.rwlock_t = type { %union.arch_rwlock_t, i32, i32, i8*, %struct.lockdep_map }
%union.arch_rwlock_t = type { i64 }
%struct.atomic_t = type { i32 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.parport_state = type { %union.anon.14 }
%union.anon.14 = type { i8*, [8 x i8] }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.gc_pad = type { %struct.input_dev*, i32, [32 x i8] }
%struct.input_dev = type { i8*, i8*, i8*, %struct.input_id, [1 x i64], [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i32, i32, i32, i8*, i32 (%struct.input_dev*, %struct.input_keymap_entry*, i32*)*, i32 (%struct.input_dev*, %struct.input_keymap_entry*)*, %struct.ff_device*, i32, %struct.timer_list, [2 x i32], %struct.input_mt*, %struct.input_absinfo*, [12 x i64], [1 x i64], [1 x i64], [1 x i64], i32 (%struct.input_dev*)*, void (%struct.input_dev*)*, i32 (%struct.input_dev*, %struct.file*)*, i32 (%struct.input_dev*, i32, i32, i32)*, %struct.input_handle*, %struct.spinlock, %struct.mutex, i32, i8, %struct.device, %struct.list_head, %struct.list_head, i32, i32, %struct.input_value*, i8 }
%struct.input_id = type { i16, i16, i16, i16 }
%struct.input_keymap_entry = type { i8, i8, i16, i32, [32 x i8] }
%struct.ff_device = type { i32 (%struct.input_dev*, %struct.ff_effect*, %struct.ff_effect*)*, i32 (%struct.input_dev*, i32)*, i32 (%struct.input_dev*, i32, i32)*, void (%struct.input_dev*, i16)*, void (%struct.input_dev*, i16)*, void (%struct.ff_device*)*, i8*, [2 x i64], %struct.mutex, i32, %struct.ff_effect*, [0 x %struct.file*] }
%struct.ff_effect = type { i16, i16, i16, %struct.ff_trigger, %struct.ff_replay, %union.anon.15 }
%struct.ff_trigger = type { i16, i16 }
%struct.ff_replay = type { i16, i16 }
%union.anon.15 = type { %struct.ff_periodic_effect }
%struct.ff_periodic_effect = type { i16, i16, i16, i16, i16, %struct.ff_envelope, i32, i16* }
%struct.ff_envelope = type { i16, i16, i16, i16 }
%struct.input_mt = type opaque
%struct.input_absinfo = type { i32, i32, i32, i32, i32, i32 }
%struct.input_handle = type { i8*, i32, i8*, %struct.input_dev*, %struct.input_handler*, %struct.list_head, %struct.list_head }
%struct.input_handler = type { i8*, void (%struct.input_handle*, i32, i32, i32)*, void (%struct.input_handle*, %struct.input_value*, i32)*, i1 (%struct.input_handle*, i32, i32, i32)*, i1 (%struct.input_handler*, %struct.input_dev*)*, i32 (%struct.input_handler*, %struct.input_dev*, %struct.input_device_id*)*, void (%struct.input_handle*)*, void (%struct.input_handle*)*, i8, i32, i8*, %struct.input_device_id*, %struct.list_head, %struct.list_head }
%struct.input_device_id = type { i64, i16, i16, i16, i16, [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i64 }
%struct.input_value = type { i16, i16, i32 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.pv_irq_ops = type { %struct.paravirt_callee_save, %struct.paravirt_callee_save, %struct.paravirt_callee_save, %struct.paravirt_callee_save, void ()*, void ()*, void ()* }
%struct.paravirt_callee_save = type { i8* }
%struct.gc_subdev = type { i32 }
%struct.ff_rumble_effect = type { i16, i16 }

@__UNIQUE_ID_author44 = internal constant [39 x i8] c"author=Vojtech Pavlik <vojtech@ucw.cz>\00", section ".modinfo", align 1
@__UNIQUE_ID_description45 = internal constant [60 x i8] c"description=NES, SNES, N64, MultiSystem, PSX gamepad driver\00", section ".modinfo", align 1
@__UNIQUE_ID_license46 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__param_str_map = internal constant [4 x i8] c"map\00", align 1
@param_array_ops = external global %struct.kernel_param_ops, align 8
@__param_arr_map = internal constant %struct.kparam_array { i32 6, i32 4, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([3 x %struct.gc_config]* @gc_cfg to i8*), i64 24) to i32*), %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([3 x %struct.gc_config]* @gc_cfg to i8*) }, align 8
@__param_map = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @__param_str_map, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_map } }, section "__param", align 8
@__UNIQUE_ID_maptype58 = internal constant [26 x i8] c"parmtype=map:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_map59 = internal constant [76 x i8] c"parm=map:Describes first set of devices (<parport#>,<pad1>,<pad2>,..<pad5>)\00", section ".modinfo", align 1
@__param_str_map2 = internal constant [5 x i8] c"map2\00", align 1
@__param_arr_map2 = internal constant %struct.kparam_array { i32 6, i32 4, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([3 x %struct.gc_config]* @gc_cfg to i8*), i64 52) to i32*), %struct.kernel_param_ops* @param_ops_int, i8* getelementptr (i8, i8* bitcast ([3 x %struct.gc_config]* @gc_cfg to i8*), i64 28) }, align 8
@__param_map2 = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @__param_str_map2, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_map2 } }, section "__param", align 8
@__UNIQUE_ID_map2type60 = internal constant [27 x i8] c"parmtype=map2:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_map261 = internal constant [42 x i8] c"parm=map2:Describes second set of devices\00", section ".modinfo", align 1
@__param_str_map3 = internal constant [5 x i8] c"map3\00", align 1
@__param_arr_map3 = internal constant %struct.kparam_array { i32 6, i32 4, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([3 x %struct.gc_config]* @gc_cfg to i8*), i64 80) to i32*), %struct.kernel_param_ops* @param_ops_int, i8* getelementptr (i8, i8* bitcast ([3 x %struct.gc_config]* @gc_cfg to i8*), i64 56) }, align 8
@__param_map3 = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @__param_str_map3, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_map3 } }, section "__param", align 8
@__UNIQUE_ID_map3type62 = internal constant [27 x i8] c"parmtype=map3:array of int\00", section ".modinfo", align 1
@__UNIQUE_ID_map363 = internal constant [41 x i8] c"parm=map3:Describes third set of devices\00", section ".modinfo", align 1
@__param_str_psx_delay = internal constant [10 x i8] c"psx_delay\00", align 1
@param_ops_uint = external global %struct.kernel_param_ops, align 8
@gc_psx_delay = internal global i32 25, align 4
@__param_psx_delay = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_psx_delay, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_uint, i16 0, i16 -1, %union.anon { i8* bitcast (i32* @gc_psx_delay to i8*) } }, section "__param", align 8
@__UNIQUE_ID_psx_delaytype548 = internal constant [24 x i8] c"parmtype=psx_delay:uint\00", section ".modinfo", align 1
@__UNIQUE_ID_psx_delay549 = internal constant [64 x i8] c"parm=psx_delay:Delay when accessing Sony PSX controller (usecs)\00", section ".modinfo", align 1
@smp_ops = external global %struct.smp_ops, align 8
@gc_cfg = internal global [3 x %struct.gc_config] zeroinitializer, section ".init.data", align 16
@param_ops_int = external global %struct.kernel_param_ops, align 8
@.str = private unnamed_addr constant [50 x i8] c"\013gamecon: at least one device must be specified\0A\00", align 1
@gc_base = internal global [3 x %struct.gc*] zeroinitializer, align 16
@.str.1 = private unnamed_addr constant [31 x i8] c"\013gamecon: no such parport %d\0A\00", align 1
@.str.2 = private unnamed_addr constant [8 x i8] c"gamecon\00", align 1
@.str.3 = private unnamed_addr constant [48 x i8] c"\013gamecon: parport busy already - lp.o loaded?\0A\00", align 1
@.str.4 = private unnamed_addr constant [30 x i8] c"\013gamecon: Not enough memory\0A\00", align 1
@gc_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.5 = private unnamed_addr constant [11 x i8] c"&gc->mutex\00", align 1
@gc_probe.__key.6 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.7 = private unnamed_addr constant [15 x i8] c"((&gc->timer))\00", align 1
@.str.8 = private unnamed_addr constant [39 x i8] c"\013gamecon: No valid devices specified\0A\00", align 1
@jiffies = external global i64, align 8
@gc_status_bit = internal constant [5 x i32] [i32 64, i32 128, i32 32, i32 16, i32 8], align 16
@gc_n64_btn = internal constant [10 x i16] [i16 304, i16 305, i16 306, i16 307, i16 308, i16 309, i16 310, i16 311, i16 288, i16 315], align 16
@gc_n64_bytes = internal constant [10 x i8] c"\00\01\0D\0F\0E\0C\0A\0B\02\03", align 1
@pv_irq_ops = external global %struct.pv_irq_ops, align 8
@.str.9 = private unnamed_addr constant [60 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/paravirt.h\00", align 1
@gc_snes_btn = internal constant [8 x i16] [i16 304, i16 305, i16 314, i16 315, i16 307, i16 308, i16 310, i16 311], align 16
@gc_nes_bytes = internal constant [4 x i8] c"\00\01\02\03", align 1
@gc_snes_bytes = internal constant [8 x i8] c"\08\00\02\03\09\01\0A\0B", align 1
@gc_psx_ddr_btn = internal constant [4 x i16] [i16 256, i16 257, i16 258, i16 259], align 2
@gc_psx_abs = internal constant [6 x i16] [i16 0, i16 1, i16 3, i16 4, i16 16, i16 17], align 2
@gc_psx_btn = internal constant [12 x i16] [i16 310, i16 311, i16 312, i16 313, i16 304, i16 305, i16 307, i16 308, i16 315, i16 314, i16 317, i16 318], align 16
@.str.10 = private unnamed_addr constant [32 x i8] c"\013gamecon: Pad type %d unknown\0A\00", align 1
@.str.11 = private unnamed_addr constant [47 x i8] c"\013gamecon: Not enough memory for input device\0A\00", align 1
@.str.12 = private unnamed_addr constant [11 x i8] c"%s/input%d\00", align 1
@gc_names = internal global [10 x i8*] [i8* null, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.21, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.22, i32 0, i32 0)], align 16
@.str.13 = private unnamed_addr constant [56 x i8] c"\014gamecon: Failed to initiate rumble for N64 device %d\0A\00", align 1
@.str.14 = private unnamed_addr constant [9 x i8] c"SNES pad\00", align 1
@.str.15 = private unnamed_addr constant [8 x i8] c"NES pad\00", align 1
@.str.16 = private unnamed_addr constant [13 x i8] c"NES FourPort\00", align 1
@.str.17 = private unnamed_addr constant [21 x i8] c"Multisystem joystick\00", align 1
@.str.18 = private unnamed_addr constant [30 x i8] c"Multisystem 2-button joystick\00", align 1
@.str.19 = private unnamed_addr constant [15 x i8] c"N64 controller\00", align 1
@.str.20 = private unnamed_addr constant [15 x i8] c"PSX controller\00", align 1
@.str.21 = private unnamed_addr constant [19 x i8] c"PSX DDR controller\00", align 1
@.str.22 = private unnamed_addr constant [11 x i8] c"SNES mouse\00", align 1
@llvm.used = appending global [15 x i8*] [i8* getelementptr inbounds ([39 x i8], [39 x i8]* @__UNIQUE_ID_author44, i32 0, i32 0), i8* getelementptr inbounds ([60 x i8], [60 x i8]* @__UNIQUE_ID_description45, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license46, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_map to i8*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__UNIQUE_ID_maptype58, i32 0, i32 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @__UNIQUE_ID_map59, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_map2 to i8*), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__UNIQUE_ID_map2type60, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @__UNIQUE_ID_map261, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_map3 to i8*), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__UNIQUE_ID_map3type62, i32 0, i32 0), i8* getelementptr inbounds ([41 x i8], [41 x i8]* @__UNIQUE_ID_map363, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_psx_delay to i8*), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__UNIQUE_ID_psx_delaytype548, i32 0, i32 0), i8* getelementptr inbounds ([64 x i8], [64 x i8]* @__UNIQUE_ID_psx_delay549, i32 0, i32 0)], section "llvm.metadata"

@init_module = alias i32 (), i32 ()* @gc_init
@cleanup_module = alias void (), void ()* @gc_exit

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @gc_init() #1 section ".init.text" {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %have_dev.0 = phi i32 [ 0, %entry ], [ %have_dev.1, %for.inc ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.gc_config], [3 x %struct.gc_config]* @gc_cfg, i64 0, i64 %idxprom
  %nargs = getelementptr inbounds %struct.gc_config, %struct.gc_config* %arrayidx, i32 0, i32 1
  %0 = load i32, i32* %nargs, align 4, !tbaa !12
  %cmp1 = icmp eq i32 %0, 0
  br i1 %cmp1, label %for.inc, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %idxprom2 = sext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds [3 x %struct.gc_config], [3 x %struct.gc_config]* @gc_cfg, i64 0, i64 %idxprom2
  %args = getelementptr inbounds %struct.gc_config, %struct.gc_config* %arrayidx3, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [6 x i32], [6 x i32]* %args, i64 0, i64 0
  %1 = load i32, i32* %arrayidx4, align 4, !tbaa !15
  %cmp5 = icmp slt i32 %1, 0
  br i1 %cmp5, label %for.inc, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %idxprom6 = sext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [3 x %struct.gc_config], [3 x %struct.gc_config]* @gc_cfg, i64 0, i64 %idxprom6
  %nargs8 = getelementptr inbounds %struct.gc_config, %struct.gc_config* %arrayidx7, i32 0, i32 1
  %2 = load i32, i32* %nargs8, align 4, !tbaa !12
  %cmp9 = icmp ult i32 %2, 2
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str, i32 0, i32 0))
  br label %for.end

if.end11:                                         ; preds = %if.end
  %idxprom12 = sext i32 %i.0 to i64
  %arrayidx13 = getelementptr inbounds [3 x %struct.gc_config], [3 x %struct.gc_config]* @gc_cfg, i64 0, i64 %idxprom12
  %args14 = getelementptr inbounds %struct.gc_config, %struct.gc_config* %arrayidx13, i32 0, i32 0
  %arrayidx15 = getelementptr inbounds [6 x i32], [6 x i32]* %args14, i64 0, i64 0
  %3 = load i32, i32* %arrayidx15, align 4, !tbaa !15
  %idxprom16 = sext i32 %i.0 to i64
  %arrayidx17 = getelementptr inbounds [3 x %struct.gc_config], [3 x %struct.gc_config]* @gc_cfg, i64 0, i64 %idxprom16
  %args18 = getelementptr inbounds %struct.gc_config, %struct.gc_config* %arrayidx17, i32 0, i32 0
  %arraydecay = getelementptr inbounds [6 x i32], [6 x i32]* %args18, i32 0, i32 0
  %add.ptr = getelementptr inbounds i32, i32* %arraydecay, i64 1
  %idxprom19 = sext i32 %i.0 to i64
  %arrayidx20 = getelementptr inbounds [3 x %struct.gc_config], [3 x %struct.gc_config]* @gc_cfg, i64 0, i64 %idxprom19
  %nargs21 = getelementptr inbounds %struct.gc_config, %struct.gc_config* %arrayidx20, i32 0, i32 1
  %4 = load i32, i32* %nargs21, align 4, !tbaa !12
  %sub = sub i32 %4, 1
  %call22 = call %struct.gc* @gc_probe(i32 %3, i32* %add.ptr, i32 %sub)
  %idxprom23 = sext i32 %i.0 to i64
  %arrayidx24 = getelementptr inbounds [3 x %struct.gc*], [3 x %struct.gc*]* @gc_base, i64 0, i64 %idxprom23
  store %struct.gc* %call22, %struct.gc** %arrayidx24, align 8, !tbaa !16
  %idxprom25 = sext i32 %i.0 to i64
  %arrayidx26 = getelementptr inbounds [3 x %struct.gc*], [3 x %struct.gc*]* @gc_base, i64 0, i64 %idxprom25
  %5 = load %struct.gc*, %struct.gc** %arrayidx26, align 8, !tbaa !16
  %6 = bitcast %struct.gc* %5 to i8*
  %call27 = call i64 @IS_ERR(i8* %6)
  %tobool = icmp ne i64 %call27, 0
  br i1 %tobool, label %if.then28, label %for.inc

if.then28:                                        ; preds = %if.end11
  %idxprom29 = sext i32 %i.0 to i64
  %arrayidx30 = getelementptr inbounds [3 x %struct.gc*], [3 x %struct.gc*]* @gc_base, i64 0, i64 %idxprom29
  %7 = load %struct.gc*, %struct.gc** %arrayidx30, align 8, !tbaa !16
  %8 = bitcast %struct.gc* %7 to i8*
  %call31 = call i64 @PTR_ERR(i8* %8)
  %conv = trunc i64 %call31 to i32
  br label %for.end

for.inc:                                          ; preds = %if.end11, %for.body, %lor.lhs.false
  %have_dev.1 = phi i32 [ %have_dev.0, %lor.lhs.false ], [ %have_dev.0, %for.body ], [ 1, %if.end11 ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then28, %if.then10
  %err.0 = phi i32 [ -22, %if.then10 ], [ %conv, %if.then28 ], [ 0, %for.cond ]
  %tobool33 = icmp ne i32 %err.0, 0
  br i1 %tobool33, label %if.then34, label %if.end44

if.then34:                                        ; preds = %for.end
  br label %while.cond

while.cond:                                       ; preds = %if.end43, %if.then34
  %i.1 = phi i32 [ %i.0, %if.then34 ], [ %dec, %if.end43 ]
  %dec = add nsw i32 %i.1, -1
  %cmp35 = icmp sge i32 %dec, 0
  br i1 %cmp35, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %idxprom37 = sext i32 %dec to i64
  %arrayidx38 = getelementptr inbounds [3 x %struct.gc*], [3 x %struct.gc*]* @gc_base, i64 0, i64 %idxprom37
  %9 = load %struct.gc*, %struct.gc** %arrayidx38, align 8, !tbaa !16
  %tobool39 = icmp ne %struct.gc* %9, null
  br i1 %tobool39, label %if.then40, label %if.end43

if.then40:                                        ; preds = %while.body
  %idxprom41 = sext i32 %dec to i64
  %arrayidx42 = getelementptr inbounds [3 x %struct.gc*], [3 x %struct.gc*]* @gc_base, i64 0, i64 %idxprom41
  %10 = load %struct.gc*, %struct.gc** %arrayidx42, align 8, !tbaa !16
  call void @gc_remove(%struct.gc* %10)
  br label %if.end43

if.end43:                                         ; preds = %if.then40, %while.body
  br label %while.cond

if.end44:                                         ; preds = %for.end
  %tobool45 = icmp ne i32 %have_dev.0, 0
  %11 = zext i1 %tobool45 to i64
  %cond = select i1 %tobool45, i32 0, i32 -19
  br label %cleanup

cleanup:                                          ; preds = %while.cond, %if.end44
  %retval.0 = phi i32 [ %cond, %if.end44 ], [ %err.0, %while.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @gc_exit() #1 section ".exit.text" {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.gc*], [3 x %struct.gc*]* @gc_base, i64 0, i64 %idxprom
  %0 = load %struct.gc*, %struct.gc** %arrayidx, align 8, !tbaa !16
  %tobool = icmp ne %struct.gc* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %idxprom1 = sext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds [3 x %struct.gc*], [3 x %struct.gc*]* @gc_base, i64 0, i64 %idxprom1
  %1 = load %struct.gc*, %struct.gc** %arrayidx2, align 8, !tbaa !16
  call void @gc_remove(%struct.gc* %1)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

declare i32 @printk(i8*, ...) #3

; Function Attrs: nounwind uwtable
define internal %struct.gc* @gc_probe(i32 %parport, i32* %pads, i32 %n_pads) #1 section ".init.text" {
entry:
  %call = call %struct.parport* @parport_find_number(i32 %parport)
  %tobool = icmp ne %struct.parport* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.1, i32 0, i32 0), i32 %parport)
  br label %err_out

if.end:                                           ; preds = %entry
  %call2 = call %struct.pardevice* @parport_register_device(%struct.parport* %call, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i32 (i8*)* null, void (i8*)* null, void (i8*)* null, i32 2, i8* null)
  %tobool3 = icmp ne %struct.pardevice* %call2, null
  br i1 %tobool3, label %if.end6, label %if.then4

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.3, i32 0, i32 0))
  br label %err_put_pp

if.end6:                                          ; preds = %if.end
  %call7 = call i8* @kzalloc(i64 592, i32 208)
  %0 = bitcast i8* %call7 to %struct.gc*
  %tobool8 = icmp ne %struct.gc* %0, null
  br i1 %tobool8, label %do.body, label %if.then9

if.then9:                                         ; preds = %if.end6
  %call10 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.4, i32 0, i32 0))
  br label %err_unreg_pardev

do.body:                                          ; preds = %if.end6
  %mutex = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 5
  call void @__mutex_init(%struct.mutex* %mutex, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.5, i32 0, i32 0), %struct.lock_class_key* @gc_probe.__key)
  %pd12 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 0
  store %struct.pardevice* %call2, %struct.pardevice** %pd12, align 8, !tbaa !17
  %timer = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 2
  call void @init_timer_key(%struct.timer_list* %timer, i32 0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.7, i32 0, i32 0), %struct.lock_class_key* @gc_probe.__key.6)
  %timer17 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 2
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer17, i32 0, i32 3
  store void (i64)* @gc_timer, void (i64)** %function, align 8, !tbaa !26
  %1 = ptrtoint %struct.gc* %0 to i64
  %timer18 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 2
  %data = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer18, i32 0, i32 4
  store i64 %1, i64* %data, align 8, !tbaa !27
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %i.0 = phi i32 [ 0, %do.body ], [ %inc31, %for.inc ]
  %count.0 = phi i32 [ 0, %do.body ], [ %count.1, %for.inc ]
  %cmp = icmp slt i32 %i.0, %n_pads
  %cmp21 = icmp slt i32 %i.0, 5
  %cmp21. = select i1 %cmp, i1 %cmp21, i1 false
  br i1 %cmp21., label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i32, i32* %pads, i64 %idxprom
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !15
  %tobool22 = icmp ne i32 %2, 0
  br i1 %tobool22, label %if.end24, label %for.inc

if.end24:                                         ; preds = %for.body
  %idxprom25 = sext i32 %i.0 to i64
  %arrayidx26 = getelementptr inbounds i32, i32* %pads, i64 %idxprom25
  %3 = load i32, i32* %arrayidx26, align 4, !tbaa !15
  %call27 = call i32 @gc_setup_pad(%struct.gc* %0, i32 %i.0, i32 %3)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %err_unreg_devs, label %if.end30

if.end30:                                         ; preds = %if.end24
  %inc = add nsw i32 %count.0, 1
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end30
  %count.1 = phi i32 [ %inc, %if.end30 ], [ %count.0, %for.body ]
  %inc31 = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp32 = icmp eq i32 %count.0, 0
  br i1 %cmp32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %for.end
  %call34 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.8, i32 0, i32 0))
  br label %err_free_gc

if.end35:                                         ; preds = %for.end
  call void @parport_put_port(%struct.parport* %call)
  br label %cleanup

err_unreg_devs:                                   ; preds = %if.end24
  br label %while.cond

while.cond:                                       ; preds = %if.end46, %err_unreg_devs
  %i.1 = phi i32 [ %i.0, %err_unreg_devs ], [ %dec, %if.end46 ]
  %dec = add nsw i32 %i.1, -1
  %cmp36 = icmp sge i32 %dec, 0
  br i1 %cmp36, label %while.body, label %err_free_gc

while.body:                                       ; preds = %while.cond
  %pads37 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 1
  %idxprom38 = sext i32 %dec to i64
  %arrayidx39 = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads37, i64 0, i64 %idxprom38
  %dev = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx39, i32 0, i32 0
  %4 = load %struct.input_dev*, %struct.input_dev** %dev, align 8, !tbaa !28
  %tobool40 = icmp ne %struct.input_dev* %4, null
  br i1 %tobool40, label %if.then41, label %if.end46

if.then41:                                        ; preds = %while.body
  %pads42 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 1
  %idxprom43 = sext i32 %dec to i64
  %arrayidx44 = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads42, i64 0, i64 %idxprom43
  %dev45 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx44, i32 0, i32 0
  %5 = load %struct.input_dev*, %struct.input_dev** %dev45, align 8, !tbaa !28
  call void @input_unregister_device(%struct.input_dev* %5)
  br label %if.end46

if.end46:                                         ; preds = %if.then41, %while.body
  br label %while.cond

err_free_gc:                                      ; preds = %while.cond, %if.then33
  %err.0 = phi i32 [ -22, %if.then33 ], [ %call27, %while.cond ]
  %6 = bitcast %struct.gc* %0 to i8*
  call void @kfree(i8* %6)
  br label %err_unreg_pardev

err_unreg_pardev:                                 ; preds = %err_free_gc, %if.then9
  %err.1 = phi i32 [ %err.0, %err_free_gc ], [ -12, %if.then9 ]
  call void @parport_unregister_device(%struct.pardevice* %call2)
  br label %err_put_pp

err_put_pp:                                       ; preds = %err_unreg_pardev, %if.then4
  %err.2 = phi i32 [ %err.1, %err_unreg_pardev ], [ -16, %if.then4 ]
  call void @parport_put_port(%struct.parport* %call)
  br label %err_out

err_out:                                          ; preds = %err_put_pp, %if.then
  %err.3 = phi i32 [ %err.2, %err_put_pp ], [ -22, %if.then ]
  %conv = sext i32 %err.3 to i64
  %call47 = call i8* @ERR_PTR(i64 %conv)
  %7 = bitcast i8* %call47 to %struct.gc*
  br label %cleanup

cleanup:                                          ; preds = %err_out, %if.end35
  %retval.0 = phi %struct.gc* [ %7, %err_out ], [ %0, %if.end35 ]
  ret %struct.gc* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal void @gc_remove(%struct.gc* %gc) #4 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pads = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 1
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads, i64 0, i64 %idxprom
  %dev = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 0
  %0 = load %struct.input_dev*, %struct.input_dev** %dev, align 8, !tbaa !28
  %tobool = icmp ne %struct.input_dev* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %pads1 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 1
  %idxprom2 = sext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads1, i64 0, i64 %idxprom2
  %dev4 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx3, i32 0, i32 0
  %1 = load %struct.input_dev*, %struct.input_dev** %dev4, align 8, !tbaa !28
  call void @input_unregister_device(%struct.input_dev* %1)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %2 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  call void @parport_unregister_device(%struct.pardevice* %2)
  %3 = bitcast %struct.gc* %gc to i8*
  call void @kfree(i8* %3)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

declare %struct.parport* @parport_find_number(i32) #3

declare %struct.pardevice* @parport_register_device(%struct.parport*, i8*, i32 (i8*)*, void (i8*)*, void (i8*)*, i32, i8*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #3

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #3

; Function Attrs: nounwind uwtable
define internal void @gc_timer(i64 %private) #4 {
entry:
  %0 = inttoptr i64 %private to i8*
  %1 = bitcast i8* %0 to %struct.gc*
  %pad_count = getelementptr inbounds %struct.gc, %struct.gc* %1, i32 0, i32 3
  %arrayidx = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count, i64 0, i64 6
  %2 = load i32, i32* %arrayidx, align 8, !tbaa !15
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @gc_n64_process_packet(%struct.gc* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %pad_count1 = getelementptr inbounds %struct.gc, %struct.gc* %1, i32 0, i32 3
  %arrayidx2 = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count1, i64 0, i64 2
  %3 = load i32, i32* %arrayidx2, align 8, !tbaa !15
  %tobool3 = icmp ne i32 %3, 0
  br i1 %tobool3, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %pad_count4 = getelementptr inbounds %struct.gc, %struct.gc* %1, i32 0, i32 3
  %arrayidx5 = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count4, i64 0, i64 1
  %4 = load i32, i32* %arrayidx5, align 4, !tbaa !15
  %tobool6 = icmp ne i32 %4, 0
  br i1 %tobool6, label %if.then11, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %pad_count8 = getelementptr inbounds %struct.gc, %struct.gc* %1, i32 0, i32 3
  %arrayidx9 = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count8, i64 0, i64 9
  %5 = load i32, i32* %arrayidx9, align 4, !tbaa !15
  %tobool10 = icmp ne i32 %5, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.lhs.false7, %lor.lhs.false, %if.end
  call void @gc_nes_process_packet(%struct.gc* %1)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %lor.lhs.false7
  %pad_count13 = getelementptr inbounds %struct.gc, %struct.gc* %1, i32 0, i32 3
  %arrayidx14 = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count13, i64 0, i64 4
  %6 = load i32, i32* %arrayidx14, align 8, !tbaa !15
  %tobool15 = icmp ne i32 %6, 0
  br i1 %tobool15, label %if.then20, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %if.end12
  %pad_count17 = getelementptr inbounds %struct.gc, %struct.gc* %1, i32 0, i32 3
  %arrayidx18 = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count17, i64 0, i64 5
  %7 = load i32, i32* %arrayidx18, align 4, !tbaa !15
  %tobool19 = icmp ne i32 %7, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false16, %if.end12
  call void @gc_multi_process_packet(%struct.gc* %1)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %lor.lhs.false16
  %pad_count22 = getelementptr inbounds %struct.gc, %struct.gc* %1, i32 0, i32 3
  %arrayidx23 = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count22, i64 0, i64 7
  %8 = load i32, i32* %arrayidx23, align 4, !tbaa !15
  %tobool24 = icmp ne i32 %8, 0
  br i1 %tobool24, label %if.then29, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %if.end21
  %pad_count26 = getelementptr inbounds %struct.gc, %struct.gc* %1, i32 0, i32 3
  %arrayidx27 = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count26, i64 0, i64 8
  %9 = load i32, i32* %arrayidx27, align 8, !tbaa !15
  %tobool28 = icmp ne i32 %9, 0
  br i1 %tobool28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %lor.lhs.false25, %if.end21
  call void @gc_psx_process_packet(%struct.gc* %1)
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %lor.lhs.false25
  %timer = getelementptr inbounds %struct.gc, %struct.gc* %1, i32 0, i32 2
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !30
  %add = add i64 %10, 2
  %call = call i32 @mod_timer(%struct.timer_list* %timer, i64 %add)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @gc_setup_pad(%struct.gc* %gc, i32 %idx, i32 %pad_type) #1 section ".init.text" {
entry:
  %pads = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 1
  %idxprom = sext i32 %idx to i64
  %arrayidx = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads, i64 0, i64 %idxprom
  %cmp = icmp slt i32 %pad_type, 1
  %cmp1 = icmp sge i32 %pad_type, 10
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.10, i32 0, i32 0), i32 %pad_type)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call %struct.input_dev* @input_allocate_device()
  %dev = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 0
  store %struct.input_dev* %call2, %struct.input_dev** %dev, align 8, !tbaa !28
  %tobool = icmp ne %struct.input_dev* %call2, null
  br i1 %tobool, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %call4 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.11, i32 0, i32 0))
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %type = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 1
  store i32 %pad_type, i32* %type, align 8, !tbaa !31
  %phys = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 2
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %phys, i32 0, i32 0
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %0 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  %port = getelementptr inbounds %struct.pardevice, %struct.pardevice* %0, i32 0, i32 1
  %1 = load %struct.parport*, %struct.parport** %port, align 8, !tbaa !32
  %name = getelementptr inbounds %struct.parport, %struct.parport* %1, i32 0, i32 3
  %2 = load i8*, i8** %name, align 8, !tbaa !35
  %call6 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 32, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.12, i32 0, i32 0), i8* %2, i32 %idx)
  %idxprom7 = sext i32 %pad_type to i64
  %arrayidx8 = getelementptr inbounds [10 x i8*], [10 x i8*]* @gc_names, i64 0, i64 %idxprom7
  %3 = load i8*, i8** %arrayidx8, align 8, !tbaa !16
  %name9 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 0
  store i8* %3, i8** %name9, align 8, !tbaa !42
  %phys10 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 2
  %arraydecay11 = getelementptr inbounds [32 x i8], [32 x i8]* %phys10, i32 0, i32 0
  %phys12 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 1
  store i8* %arraydecay11, i8** %phys12, align 8, !tbaa !59
  %id = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 3
  %bustype = getelementptr inbounds %struct.input_id, %struct.input_id* %id, i32 0, i32 0
  store i16 21, i16* %bustype, align 8, !tbaa !60
  %id13 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 3
  %vendor = getelementptr inbounds %struct.input_id, %struct.input_id* %id13, i32 0, i32 1
  store i16 1, i16* %vendor, align 2, !tbaa !61
  %conv = trunc i32 %pad_type to i16
  %id14 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 3
  %product = getelementptr inbounds %struct.input_id, %struct.input_id* %id14, i32 0, i32 2
  store i16 %conv, i16* %product, align 4, !tbaa !62
  %id15 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 3
  %version = getelementptr inbounds %struct.input_id, %struct.input_id* %id15, i32 0, i32 3
  store i16 256, i16* %version, align 2, !tbaa !63
  %4 = bitcast %struct.gc* %gc to i8*
  call void @input_set_drvdata(%struct.input_dev* %call2, i8* %4)
  %open = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 30
  store i32 (%struct.input_dev*)* @gc_open, i32 (%struct.input_dev*)** %open, align 8, !tbaa !64
  %close = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 31
  store void (%struct.input_dev*)* @gc_close, void (%struct.input_dev*)** %close, align 8, !tbaa !65
  %cmp16 = icmp ne i32 %pad_type, 9
  %evbit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 5
  %arrayidx19 = getelementptr inbounds [1 x i64], [1 x i64]* %evbit, i64 0, i64 0
  br i1 %cmp16, label %if.then18, label %if.else

if.then18:                                        ; preds = %if.end5
  store i64 10, i64* %arrayidx19, align 8, !tbaa !30
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then18
  %i.0 = phi i32 [ 0, %if.then18 ], [ %inc, %for.body ]
  %cmp20 = icmp slt i32 %i.0, 2
  br i1 %cmp20, label %for.body, label %if.end24

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 0, %i.0
  call void @input_set_abs_params(%struct.input_dev* %call2, i32 %add, i32 -1, i32 1, i32 0, i32 0)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %if.end5
  store i64 6, i64* %arrayidx19, align 8, !tbaa !30
  br label %if.end24

if.end24:                                         ; preds = %for.cond, %if.else
  %pad_count = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 3
  %idxprom25 = sext i32 %pad_type to i64
  %arrayidx26 = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count, i64 0, i64 %idxprom25
  %5 = load i32, i32* %arrayidx26, align 4, !tbaa !15
  %inc27 = add nsw i32 %5, 1
  store i32 %inc27, i32* %arrayidx26, align 4, !tbaa !15
  %Pivot16 = icmp slt i32 %pad_type, 6
  br i1 %Pivot16, label %NodeBlock5, label %NodeBlock13

NodeBlock13:                                      ; preds = %if.end24
  %Pivot14 = icmp slt i32 %pad_type, 8
  br i1 %Pivot14, label %NodeBlock7, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %pad_type, 9
  br i1 %Pivot12, label %sw.bb116, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock11
  %SwitchLeaf10 = icmp eq i32 %pad_type, 9
  br i1 %SwitchLeaf10, label %sw.bb53, label %sw.epilog

NodeBlock7:                                       ; preds = %NodeBlock13
  %Pivot8 = icmp slt i32 %pad_type, 7
  br i1 %Pivot8, label %sw.bb, label %sw.bb93

NodeBlock5:                                       ; preds = %if.end24
  %Pivot6 = icmp slt i32 %pad_type, 4
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %pad_type, 5
  br i1 %Pivot4, label %sw.bb90, label %sw.bb87

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %pad_type, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %pad_type, 2
  br i1 %SwitchLeaf2, label %sw.bb74, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %pad_type, 1
  br i1 %SwitchLeaf, label %sw.bb61, label %sw.epilog

sw.bb:                                            ; preds = %NodeBlock7
  br label %for.cond28

for.cond28:                                       ; preds = %for.body31, %sw.bb
  %i.1 = phi i32 [ 0, %sw.bb ], [ %inc37, %for.body31 ]
  %cmp29 = icmp slt i32 %i.1, 10
  br i1 %cmp29, label %for.body31, label %for.end38

for.body31:                                       ; preds = %for.cond28
  %idxprom32 = sext i32 %i.1 to i64
  %arrayidx33 = getelementptr inbounds [10 x i16], [10 x i16]* @gc_n64_btn, i64 0, i64 %idxprom32
  %6 = load i16, i16* %arrayidx33, align 2, !tbaa !66
  %conv34 = sext i16 %6 to i32
  %keybit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 6
  %arraydecay35 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit, i32 0, i32 0
  call void @__set_bit(i32 %conv34, i64* %arraydecay35)
  %inc37 = add nsw i32 %i.1, 1
  br label %for.cond28

for.end38:                                        ; preds = %for.cond28
  br label %for.cond39

for.cond39:                                       ; preds = %for.body42, %for.end38
  %i.2 = phi i32 [ 0, %for.end38 ], [ %inc46, %for.body42 ]
  %cmp40 = icmp slt i32 %i.2, 2
  br i1 %cmp40, label %for.body42, label %for.end47

for.body42:                                       ; preds = %for.cond39
  %add43 = add nsw i32 0, %i.2
  call void @input_set_abs_params(%struct.input_dev* %call2, i32 %add43, i32 -127, i32 126, i32 0, i32 2)
  %add44 = add nsw i32 16, %i.2
  call void @input_set_abs_params(%struct.input_dev* %call2, i32 %add44, i32 -1, i32 1, i32 0, i32 0)
  %inc46 = add nsw i32 %i.2, 1
  br label %for.cond39

for.end47:                                        ; preds = %for.cond39
  %call48 = call i32 @gc_n64_init_ff(%struct.input_dev* %call2, i32 %idx)
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.then50, label %sw.epilog

if.then50:                                        ; preds = %for.end47
  %call51 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.13, i32 0, i32 0), i32 %idx)
  br label %err_free_dev

sw.bb53:                                          ; preds = %LeafBlock9
  %keybit54 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 6
  %arraydecay55 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit54, i32 0, i32 0
  call void @__set_bit(i32 272, i64* %arraydecay55)
  %keybit56 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 6
  %arraydecay57 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit56, i32 0, i32 0
  call void @__set_bit(i32 273, i64* %arraydecay57)
  %relbit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 7
  %arraydecay58 = getelementptr inbounds [1 x i64], [1 x i64]* %relbit, i32 0, i32 0
  call void @__set_bit(i32 0, i64* %arraydecay58)
  %relbit59 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 7
  %arraydecay60 = getelementptr inbounds [1 x i64], [1 x i64]* %relbit59, i32 0, i32 0
  call void @__set_bit(i32 1, i64* %arraydecay60)
  br label %sw.epilog

sw.bb61:                                          ; preds = %LeafBlock
  br label %for.cond62

for.cond62:                                       ; preds = %for.body65, %sw.bb61
  %i.3 = phi i32 [ 4, %sw.bb61 ], [ %inc72, %for.body65 ]
  %cmp63 = icmp slt i32 %i.3, 8
  br i1 %cmp63, label %for.body65, label %sw.bb74

for.body65:                                       ; preds = %for.cond62
  %idxprom66 = sext i32 %i.3 to i64
  %arrayidx67 = getelementptr inbounds [8 x i16], [8 x i16]* @gc_snes_btn, i64 0, i64 %idxprom66
  %7 = load i16, i16* %arrayidx67, align 2, !tbaa !66
  %conv68 = sext i16 %7 to i32
  %keybit69 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 6
  %arraydecay70 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit69, i32 0, i32 0
  call void @__set_bit(i32 %conv68, i64* %arraydecay70)
  %inc72 = add nsw i32 %i.3, 1
  br label %for.cond62

sw.bb74:                                          ; preds = %for.cond62, %LeafBlock1
  br label %for.cond75

for.cond75:                                       ; preds = %for.body78, %sw.bb74
  %i.4 = phi i32 [ 0, %sw.bb74 ], [ %inc85, %for.body78 ]
  %cmp76 = icmp slt i32 %i.4, 4
  br i1 %cmp76, label %for.body78, label %sw.epilog

for.body78:                                       ; preds = %for.cond75
  %idxprom79 = sext i32 %i.4 to i64
  %arrayidx80 = getelementptr inbounds [8 x i16], [8 x i16]* @gc_snes_btn, i64 0, i64 %idxprom79
  %8 = load i16, i16* %arrayidx80, align 2, !tbaa !66
  %conv81 = sext i16 %8 to i32
  %keybit82 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 6
  %arraydecay83 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit82, i32 0, i32 0
  call void @__set_bit(i32 %conv81, i64* %arraydecay83)
  %inc85 = add nsw i32 %i.4, 1
  br label %for.cond75

sw.bb87:                                          ; preds = %NodeBlock3
  %keybit88 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 6
  %arraydecay89 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit88, i32 0, i32 0
  call void @__set_bit(i32 289, i64* %arraydecay89)
  br label %sw.bb90

sw.bb90:                                          ; preds = %NodeBlock3, %sw.bb87
  %keybit91 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 6
  %arraydecay92 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit91, i32 0, i32 0
  call void @__set_bit(i32 288, i64* %arraydecay92)
  br label %sw.epilog

sw.bb93:                                          ; preds = %NodeBlock7
  br label %for.cond94

for.cond94:                                       ; preds = %for.body97, %sw.bb93
  %i.5 = phi i32 [ 0, %sw.bb93 ], [ %inc102, %for.body97 ]
  %cmp95 = icmp slt i32 %i.5, 6
  br i1 %cmp95, label %for.body97, label %for.end103

for.body97:                                       ; preds = %for.cond94
  %idxprom98 = sext i32 %i.5 to i64
  %arrayidx99 = getelementptr inbounds [6 x i16], [6 x i16]* @gc_psx_abs, i64 0, i64 %idxprom98
  %9 = load i16, i16* %arrayidx99, align 2, !tbaa !66
  %conv100 = sext i16 %9 to i32
  call void @input_set_abs_params(%struct.input_dev* %call2, i32 %conv100, i32 4, i32 252, i32 0, i32 2)
  %inc102 = add nsw i32 %i.5, 1
  br label %for.cond94

for.end103:                                       ; preds = %for.cond94
  br label %for.cond104

for.cond104:                                      ; preds = %for.body107, %for.end103
  %i.6 = phi i32 [ 0, %for.end103 ], [ %inc114, %for.body107 ]
  %cmp105 = icmp slt i32 %i.6, 12
  br i1 %cmp105, label %for.body107, label %sw.epilog

for.body107:                                      ; preds = %for.cond104
  %idxprom108 = sext i32 %i.6 to i64
  %arrayidx109 = getelementptr inbounds [12 x i16], [12 x i16]* @gc_psx_btn, i64 0, i64 %idxprom108
  %10 = load i16, i16* %arrayidx109, align 2, !tbaa !66
  %conv110 = sext i16 %10 to i32
  %keybit111 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 6
  %arraydecay112 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit111, i32 0, i32 0
  call void @__set_bit(i32 %conv110, i64* %arraydecay112)
  %inc114 = add nsw i32 %i.6, 1
  br label %for.cond104

sw.bb116:                                         ; preds = %NodeBlock11
  br label %for.cond117

for.cond117:                                      ; preds = %for.body120, %sw.bb116
  %i.7 = phi i32 [ 0, %sw.bb116 ], [ %inc127, %for.body120 ]
  %cmp118 = icmp slt i32 %i.7, 4
  br i1 %cmp118, label %for.body120, label %for.end128

for.body120:                                      ; preds = %for.cond117
  %idxprom121 = sext i32 %i.7 to i64
  %arrayidx122 = getelementptr inbounds [4 x i16], [4 x i16]* @gc_psx_ddr_btn, i64 0, i64 %idxprom121
  %11 = load i16, i16* %arrayidx122, align 2, !tbaa !66
  %conv123 = sext i16 %11 to i32
  %keybit124 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 6
  %arraydecay125 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit124, i32 0, i32 0
  call void @__set_bit(i32 %conv123, i64* %arraydecay125)
  %inc127 = add nsw i32 %i.7, 1
  br label %for.cond117

for.end128:                                       ; preds = %for.cond117
  br label %for.cond129

for.cond129:                                      ; preds = %for.body132, %for.end128
  %i.8 = phi i32 [ 0, %for.end128 ], [ %inc139, %for.body132 ]
  %cmp130 = icmp slt i32 %i.8, 12
  br i1 %cmp130, label %for.body132, label %sw.epilog

for.body132:                                      ; preds = %for.cond129
  %idxprom133 = sext i32 %i.8 to i64
  %arrayidx134 = getelementptr inbounds [12 x i16], [12 x i16]* @gc_psx_btn, i64 0, i64 %idxprom133
  %12 = load i16, i16* %arrayidx134, align 2, !tbaa !66
  %conv135 = sext i16 %12 to i32
  %keybit136 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %call2, i32 0, i32 6
  %arraydecay137 = getelementptr inbounds [12 x i64], [12 x i64]* %keybit136, i32 0, i32 0
  call void @__set_bit(i32 %conv135, i64* %arraydecay137)
  %inc139 = add nsw i32 %i.8, 1
  br label %for.cond129

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock9, %for.cond129, %for.cond104, %for.cond75, %for.end47, %sw.bb90, %sw.bb53
  %dev141 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 0
  %13 = load %struct.input_dev*, %struct.input_dev** %dev141, align 8, !tbaa !28
  %call142 = call i32 @input_register_device(%struct.input_dev* %13)
  %tobool143 = icmp ne i32 %call142, 0
  br i1 %tobool143, label %err_free_dev, label %cleanup

err_free_dev:                                     ; preds = %sw.epilog, %if.then50
  %err.0 = phi i32 [ %call48, %if.then50 ], [ %call142, %sw.epilog ]
  %dev146 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 0
  %14 = load %struct.input_dev*, %struct.input_dev** %dev146, align 8, !tbaa !28
  call void @input_free_device(%struct.input_dev* %14)
  %dev147 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 0
  store %struct.input_dev* null, %struct.input_dev** %dev147, align 8, !tbaa !28
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %err_free_dev, %if.then3, %if.then
  %retval.0 = phi i32 [ -22, %if.then ], [ %err.0, %err_free_dev ], [ -12, %if.then3 ], [ 0, %sw.epilog ]
  ret i32 %retval.0
}

declare void @parport_put_port(%struct.parport*) #3

declare void @input_unregister_device(%struct.input_dev*) #3

declare void @kfree(i8*) #3

declare void @parport_unregister_device(%struct.pardevice*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR(i64 %error) #0 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #5 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare i8* @__kmalloc(i64, i32) #3

; Function Attrs: nounwind uwtable
define internal void @gc_n64_process_packet(%struct.gc* %gc) #4 {
entry:
  %data = alloca [32 x i8], align 16
  %0 = bitcast [32 x i8]* %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %0) #7
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %data, i32 0, i32 0
  call void @gc_n64_read_packet(%struct.gc* %gc, i8* %arraydecay)
  br label %for.cond

for.cond:                                         ; preds = %for.inc82, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc83, %for.inc82 ]
  %cmp = icmp slt i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end84

for.body:                                         ; preds = %for.cond
  %pads = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 1
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads, i64 0, i64 %idxprom
  %type = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 1
  %1 = load i32, i32* %type, align 8, !tbaa !31
  %cmp1 = icmp ne i32 %1, 6
  br i1 %cmp1, label %for.inc82, label %if.end

if.end:                                           ; preds = %for.body
  %pads2 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 1
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads2, i64 0, i64 %idxprom3
  %dev5 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx4, i32 0, i32 0
  %2 = load %struct.input_dev*, %struct.input_dev** %dev5, align 8, !tbaa !28
  %idxprom6 = sext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [5 x i32], [5 x i32]* @gc_status_bit, i64 0, i64 %idxprom6
  %3 = load i32, i32* %arrayidx7, align 4, !tbaa !15
  %arrayidx8 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 8
  %4 = load i8, i8* %arrayidx8, align 8, !tbaa !67
  %conv = zext i8 %4 to i32
  %arrayidx9 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 9
  %5 = load i8, i8* %arrayidx9, align 1, !tbaa !67
  %conv10 = zext i8 %5 to i32
  %or = or i32 %conv, %conv10
  %neg = xor i32 %or, -1
  %and = and i32 %3, %neg
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then11, label %for.inc82

if.then11:                                        ; preds = %if.end
  br label %for.cond12

for.cond12:                                       ; preds = %for.inc, %if.then11
  %j.0 = phi i32 [ 0, %if.then11 ], [ %inc, %for.inc ]
  %x.0 = phi i8 [ 0, %if.then11 ], [ %x.1, %for.inc ]
  %y.0 = phi i8 [ 0, %if.then11 ], [ %y.1, %for.inc ]
  %cmp13 = icmp slt i32 %j.0, 8
  br i1 %cmp13, label %for.body15, label %for.end

for.body15:                                       ; preds = %for.cond12
  %sub = sub nsw i32 23, %j.0
  %idxprom16 = sext i32 %sub to i64
  %arrayidx17 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 %idxprom16
  %6 = load i8, i8* %arrayidx17, align 1, !tbaa !67
  %conv18 = zext i8 %6 to i32
  %and19 = and i32 %conv18, %3
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end25

if.then21:                                        ; preds = %for.body15
  %shl = shl i32 1, %j.0
  %conv22 = sext i8 %x.0 to i32
  %or23 = or i32 %conv22, %shl
  %conv24 = trunc i32 %or23 to i8
  br label %if.end25

if.end25:                                         ; preds = %if.then21, %for.body15
  %x.1 = phi i8 [ %conv24, %if.then21 ], [ %x.0, %for.body15 ]
  %sub26 = sub nsw i32 31, %j.0
  %idxprom27 = sext i32 %sub26 to i64
  %arrayidx28 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 %idxprom27
  %7 = load i8, i8* %arrayidx28, align 1, !tbaa !67
  %conv29 = zext i8 %7 to i32
  %and30 = and i32 %conv29, %3
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.then32, label %for.inc

if.then32:                                        ; preds = %if.end25
  %shl33 = shl i32 1, %j.0
  %conv34 = sext i8 %y.0 to i32
  %or35 = or i32 %conv34, %shl33
  %conv36 = trunc i32 %or35 to i8
  br label %for.inc

for.inc:                                          ; preds = %if.end25, %if.then32
  %y.1 = phi i8 [ %conv36, %if.then32 ], [ %y.0, %if.end25 ]
  %inc = add nsw i32 %j.0, 1
  br label %for.cond12

for.end:                                          ; preds = %for.cond12
  %conv38 = sext i8 %x.0 to i32
  call void @input_report_abs(%struct.input_dev* %2, i32 0, i32 %conv38)
  %conv39 = sext i8 %y.0 to i32
  %sub40 = sub nsw i32 0, %conv39
  call void @input_report_abs(%struct.input_dev* %2, i32 1, i32 %sub40)
  %arrayidx41 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 6
  %8 = load i8, i8* %arrayidx41, align 2, !tbaa !67
  %conv42 = zext i8 %8 to i32
  %and43 = and i32 %3, %conv42
  %tobool44 = icmp ne i32 %and43, 0
  %lnot = xor i1 %tobool44, true
  %lnot.ext = zext i1 %lnot to i32
  %arrayidx45 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 7
  %9 = load i8, i8* %arrayidx45, align 1, !tbaa !67
  %conv46 = zext i8 %9 to i32
  %and47 = and i32 %3, %conv46
  %tobool48 = icmp ne i32 %and47, 0
  %lnot49 = xor i1 %tobool48, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %sub51 = sub nsw i32 %lnot.ext, %lnot.ext50
  call void @input_report_abs(%struct.input_dev* %2, i32 16, i32 %sub51)
  %arrayidx52 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 4
  %10 = load i8, i8* %arrayidx52, align 4, !tbaa !67
  %conv53 = zext i8 %10 to i32
  %and54 = and i32 %3, %conv53
  %tobool55 = icmp ne i32 %and54, 0
  %lnot56 = xor i1 %tobool55, true
  %lnot.ext57 = zext i1 %lnot56 to i32
  %arrayidx58 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 5
  %11 = load i8, i8* %arrayidx58, align 1, !tbaa !67
  %conv59 = zext i8 %11 to i32
  %and60 = and i32 %3, %conv59
  %tobool61 = icmp ne i32 %and60, 0
  %lnot62 = xor i1 %tobool61, true
  %lnot.ext63 = zext i1 %lnot62 to i32
  %sub64 = sub nsw i32 %lnot.ext57, %lnot.ext63
  call void @input_report_abs(%struct.input_dev* %2, i32 17, i32 %sub64)
  br label %for.cond65

for.cond65:                                       ; preds = %for.body68, %for.end
  %j.1 = phi i32 [ 0, %for.end ], [ %inc79, %for.body68 ]
  %cmp66 = icmp slt i32 %j.1, 10
  br i1 %cmp66, label %for.body68, label %for.end80

for.body68:                                       ; preds = %for.cond65
  %idxprom69 = sext i32 %j.1 to i64
  %arrayidx70 = getelementptr inbounds [10 x i16], [10 x i16]* @gc_n64_btn, i64 0, i64 %idxprom69
  %12 = load i16, i16* %arrayidx70, align 2, !tbaa !66
  %conv71 = sext i16 %12 to i32
  %idxprom72 = sext i32 %j.1 to i64
  %arrayidx73 = getelementptr inbounds [10 x i8], [10 x i8]* @gc_n64_bytes, i64 0, i64 %idxprom72
  %13 = load i8, i8* %arrayidx73, align 1, !tbaa !67
  %idxprom74 = zext i8 %13 to i64
  %arrayidx75 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 %idxprom74
  %14 = load i8, i8* %arrayidx75, align 1, !tbaa !67
  %conv76 = zext i8 %14 to i32
  %and77 = and i32 %3, %conv76
  call void @input_report_key(%struct.input_dev* %2, i32 %conv71, i32 %and77)
  %inc79 = add nsw i32 %j.1, 1
  br label %for.cond65

for.end80:                                        ; preds = %for.cond65
  call void @input_sync(%struct.input_dev* %2)
  br label %for.inc82

for.inc82:                                        ; preds = %if.end, %for.end80, %for.body
  %inc83 = add nsw i32 %i.0, 1
  br label %for.cond

for.end84:                                        ; preds = %for.cond
  %15 = bitcast [32 x i8]* %data to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %15) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gc_nes_process_packet(%struct.gc* %gc) #4 {
entry:
  %data = alloca [32 x i8], align 16
  %0 = bitcast [32 x i8]* %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %0) #7
  %pad_count = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 3
  %arrayidx = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count, i64 0, i64 9
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !15
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %pad_count1 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 3
  %arrayidx2 = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count1, i64 0, i64 1
  %2 = load i32, i32* %arrayidx2, align 4, !tbaa !15
  %tobool3 = icmp ne i32 %2, 0
  %3 = zext i1 %tobool3 to i64
  %cond = select i1 %tobool3, i32 12, i32 8
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.false
  %cond4 = phi i32 [ %cond, %cond.false ], [ 32, %entry ]
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %data, i32 0, i32 0
  call void @gc_nes_read_packet(%struct.gc* %gc, i32 %cond4, i8* %arraydecay)
  br label %for.cond

for.cond:                                         ; preds = %for.inc169, %cond.end
  %i.0 = phi i32 [ 0, %cond.end ], [ %inc170, %for.inc169 ]
  %cmp = icmp slt i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end171

for.body:                                         ; preds = %for.cond
  %pads = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 1
  %idxprom = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads, i64 0, i64 %idxprom
  %dev6 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx5, i32 0, i32 0
  %4 = load %struct.input_dev*, %struct.input_dev** %dev6, align 8, !tbaa !28
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds [5 x i32], [5 x i32]* @gc_status_bit, i64 0, i64 %idxprom7
  %5 = load i32, i32* %arrayidx8, align 4, !tbaa !15
  %type = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx5, i32 0, i32 1
  %6 = load i32, i32* %type, align 8, !tbaa !31
  %Pivot6 = icmp slt i32 %6, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %for.body
  %Pivot = icmp slt i32 %6, 9
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %6, 9
  br i1 %SwitchLeaf4, label %sw.bb86, label %for.inc169

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %6, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %for.inc169

LeafBlock:                                        ; preds = %for.body
  %SwitchLeaf = icmp eq i32 %6, 1
  br i1 %SwitchLeaf, label %sw.bb43, label %for.inc169

sw.bb:                                            ; preds = %LeafBlock1
  %arrayidx9 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 6
  %7 = load i8, i8* %arrayidx9, align 2, !tbaa !67
  %conv = zext i8 %7 to i32
  %and = and i32 %5, %conv
  %tobool10 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool10, true
  %lnot.ext = zext i1 %lnot to i32
  %arrayidx11 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 7
  %8 = load i8, i8* %arrayidx11, align 1, !tbaa !67
  %conv12 = zext i8 %8 to i32
  %and13 = and i32 %5, %conv12
  %tobool14 = icmp ne i32 %and13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %sub = sub nsw i32 %lnot.ext, %lnot.ext16
  call void @input_report_abs(%struct.input_dev* %4, i32 0, i32 %sub)
  %arrayidx17 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 4
  %9 = load i8, i8* %arrayidx17, align 4, !tbaa !67
  %conv18 = zext i8 %9 to i32
  %and19 = and i32 %5, %conv18
  %tobool20 = icmp ne i32 %and19, 0
  %lnot21 = xor i1 %tobool20, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %arrayidx23 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 5
  %10 = load i8, i8* %arrayidx23, align 1, !tbaa !67
  %conv24 = zext i8 %10 to i32
  %and25 = and i32 %5, %conv24
  %tobool26 = icmp ne i32 %and25, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %sub29 = sub nsw i32 %lnot.ext22, %lnot.ext28
  call void @input_report_abs(%struct.input_dev* %4, i32 1, i32 %sub29)
  br label %for.cond30

for.cond30:                                       ; preds = %for.body33, %sw.bb
  %j.0 = phi i32 [ 0, %sw.bb ], [ %inc, %for.body33 ]
  %cmp31 = icmp slt i32 %j.0, 4
  br i1 %cmp31, label %for.body33, label %for.end

for.body33:                                       ; preds = %for.cond30
  %idxprom34 = sext i32 %j.0 to i64
  %arrayidx35 = getelementptr inbounds [8 x i16], [8 x i16]* @gc_snes_btn, i64 0, i64 %idxprom34
  %11 = load i16, i16* %arrayidx35, align 2, !tbaa !66
  %conv36 = sext i16 %11 to i32
  %idxprom37 = sext i32 %j.0 to i64
  %arrayidx38 = getelementptr inbounds [4 x i8], [4 x i8]* @gc_nes_bytes, i64 0, i64 %idxprom37
  %12 = load i8, i8* %arrayidx38, align 1, !tbaa !67
  %idxprom39 = zext i8 %12 to i64
  %arrayidx40 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 %idxprom39
  %13 = load i8, i8* %arrayidx40, align 1, !tbaa !67
  %conv41 = zext i8 %13 to i32
  %and42 = and i32 %5, %conv41
  call void @input_report_key(%struct.input_dev* %4, i32 %conv36, i32 %and42)
  %inc = add nsw i32 %j.0, 1
  br label %for.cond30

for.end:                                          ; preds = %for.cond30
  call void @input_sync(%struct.input_dev* %4)
  br label %for.inc169

sw.bb43:                                          ; preds = %LeafBlock
  %arrayidx44 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 6
  %14 = load i8, i8* %arrayidx44, align 2, !tbaa !67
  %conv45 = zext i8 %14 to i32
  %and46 = and i32 %5, %conv45
  %tobool47 = icmp ne i32 %and46, 0
  %lnot48 = xor i1 %tobool47, true
  %lnot.ext49 = zext i1 %lnot48 to i32
  %arrayidx50 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 7
  %15 = load i8, i8* %arrayidx50, align 1, !tbaa !67
  %conv51 = zext i8 %15 to i32
  %and52 = and i32 %5, %conv51
  %tobool53 = icmp ne i32 %and52, 0
  %lnot54 = xor i1 %tobool53, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %sub56 = sub nsw i32 %lnot.ext49, %lnot.ext55
  call void @input_report_abs(%struct.input_dev* %4, i32 0, i32 %sub56)
  %arrayidx57 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 4
  %16 = load i8, i8* %arrayidx57, align 4, !tbaa !67
  %conv58 = zext i8 %16 to i32
  %and59 = and i32 %5, %conv58
  %tobool60 = icmp ne i32 %and59, 0
  %lnot61 = xor i1 %tobool60, true
  %lnot.ext62 = zext i1 %lnot61 to i32
  %arrayidx63 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 5
  %17 = load i8, i8* %arrayidx63, align 1, !tbaa !67
  %conv64 = zext i8 %17 to i32
  %and65 = and i32 %5, %conv64
  %tobool66 = icmp ne i32 %and65, 0
  %lnot67 = xor i1 %tobool66, true
  %lnot.ext68 = zext i1 %lnot67 to i32
  %sub69 = sub nsw i32 %lnot.ext62, %lnot.ext68
  call void @input_report_abs(%struct.input_dev* %4, i32 1, i32 %sub69)
  br label %for.cond70

for.cond70:                                       ; preds = %for.body73, %sw.bb43
  %j.1 = phi i32 [ 0, %sw.bb43 ], [ %inc84, %for.body73 ]
  %cmp71 = icmp slt i32 %j.1, 8
  br i1 %cmp71, label %for.body73, label %for.end85

for.body73:                                       ; preds = %for.cond70
  %idxprom74 = sext i32 %j.1 to i64
  %arrayidx75 = getelementptr inbounds [8 x i16], [8 x i16]* @gc_snes_btn, i64 0, i64 %idxprom74
  %18 = load i16, i16* %arrayidx75, align 2, !tbaa !66
  %conv76 = sext i16 %18 to i32
  %idxprom77 = sext i32 %j.1 to i64
  %arrayidx78 = getelementptr inbounds [8 x i8], [8 x i8]* @gc_snes_bytes, i64 0, i64 %idxprom77
  %19 = load i8, i8* %arrayidx78, align 1, !tbaa !67
  %idxprom79 = zext i8 %19 to i64
  %arrayidx80 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 %idxprom79
  %20 = load i8, i8* %arrayidx80, align 1, !tbaa !67
  %conv81 = zext i8 %20 to i32
  %and82 = and i32 %5, %conv81
  call void @input_report_key(%struct.input_dev* %4, i32 %conv76, i32 %and82)
  %inc84 = add nsw i32 %j.1, 1
  br label %for.cond70

for.end85:                                        ; preds = %for.cond70
  call void @input_sync(%struct.input_dev* %4)
  br label %for.inc169

sw.bb86:                                          ; preds = %LeafBlock3
  %arrayidx87 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 12
  %21 = load i8, i8* %arrayidx87, align 4, !tbaa !67
  %conv88 = zext i8 %21 to i32
  %and89 = and i32 %5, %conv88
  %tobool90 = icmp ne i32 %and89, 0
  br i1 %tobool90, label %for.inc169, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.bb86
  %arrayidx91 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 13
  %22 = load i8, i8* %arrayidx91, align 1, !tbaa !67
  %conv92 = zext i8 %22 to i32
  %and93 = and i32 %5, %conv92
  %tobool94 = icmp ne i32 %and93, 0
  br i1 %tobool94, label %for.inc169, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %land.lhs.true
  %arrayidx96 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 14
  %23 = load i8, i8* %arrayidx96, align 2, !tbaa !67
  %conv97 = zext i8 %23 to i32
  %and98 = and i32 %5, %conv97
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %for.inc169, label %land.lhs.true100

land.lhs.true100:                                 ; preds = %land.lhs.true95
  %arrayidx101 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 15
  %24 = load i8, i8* %arrayidx101, align 1, !tbaa !67
  %conv102 = zext i8 %24 to i32
  %and103 = and i32 %5, %conv102
  %tobool104 = icmp ne i32 %and103, 0
  br i1 %tobool104, label %if.then, label %for.inc169

if.then:                                          ; preds = %land.lhs.true100
  %arrayidx105 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 9
  %25 = load i8, i8* %arrayidx105, align 1, !tbaa !67
  %conv106 = zext i8 %25 to i32
  %and107 = and i32 %5, %conv106
  call void @input_report_key(%struct.input_dev* %4, i32 272, i32 %and107)
  %arrayidx108 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 8
  %26 = load i8, i8* %arrayidx108, align 8, !tbaa !67
  %conv109 = zext i8 %26 to i32
  %and110 = and i32 %5, %conv109
  call void @input_report_key(%struct.input_dev* %4, i32 273, i32 %and110)
  br label %for.cond111

for.cond111:                                      ; preds = %for.body114, %if.then
  %j.2 = phi i32 [ 0, %if.then ], [ %inc140, %for.body114 ]
  %x_rel.0 = phi i8 [ 0, %if.then ], [ %x_rel.1, %for.body114 ]
  %y_rel.0 = phi i8 [ 0, %if.then ], [ %y_rel.1, %for.body114 ]
  %cmp112 = icmp slt i32 %j.2, 7
  br i1 %cmp112, label %for.body114, label %for.end141

for.body114:                                      ; preds = %for.cond111
  %conv115 = sext i8 %x_rel.0 to i32
  %shl = shl i32 %conv115, 1
  %conv116 = trunc i32 %shl to i8
  %add = add nsw i32 25, %j.2
  %idxprom117 = sext i32 %add to i64
  %arrayidx118 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 %idxprom117
  %27 = load i8, i8* %arrayidx118, align 1, !tbaa !67
  %conv119 = zext i8 %27 to i32
  %and120 = and i32 %conv119, %5
  %tobool121 = icmp ne i32 %and120, 0
  %conv123 = sext i8 %conv116 to i32
  %or = or i32 %conv123, 1
  %conv124 = trunc i32 %or to i8
  %x_rel.1 = select i1 %tobool121, i8 %conv124, i8 %conv116
  %conv125 = sext i8 %y_rel.0 to i32
  %shl126 = shl i32 %conv125, 1
  %conv127 = trunc i32 %shl126 to i8
  %add128 = add nsw i32 17, %j.2
  %idxprom129 = sext i32 %add128 to i64
  %arrayidx130 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 %idxprom129
  %28 = load i8, i8* %arrayidx130, align 1, !tbaa !67
  %conv131 = zext i8 %28 to i32
  %and132 = and i32 %conv131, %5
  %tobool133 = icmp ne i32 %and132, 0
  %conv135 = sext i8 %conv127 to i32
  %or136 = or i32 %conv135, 1
  %conv137 = trunc i32 %or136 to i8
  %y_rel.1 = select i1 %tobool133, i8 %conv137, i8 %conv127
  %inc140 = add nsw i32 %j.2, 1
  br label %for.cond111

for.end141:                                       ; preds = %for.cond111
  %tobool142 = icmp ne i8 %x_rel.0, 0
  br i1 %tobool142, label %if.then143, label %if.end154

if.then143:                                       ; preds = %for.end141
  %arrayidx144 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 24
  %29 = load i8, i8* %arrayidx144, align 8, !tbaa !67
  %conv145 = zext i8 %29 to i32
  %and146 = and i32 %conv145, %5
  %tobool147 = icmp ne i32 %and146, 0
  %conv149 = sext i8 %x_rel.0 to i32
  %sub150 = sub nsw i32 0, %conv149
  %conv151 = trunc i32 %sub150 to i8
  %x_rel.2 = select i1 %tobool147, i8 %conv151, i8 %x_rel.0
  %conv153 = sext i8 %x_rel.2 to i32
  call void @input_report_rel(%struct.input_dev* %4, i32 0, i32 %conv153)
  br label %if.end154

if.end154:                                        ; preds = %if.then143, %for.end141
  %tobool155 = icmp ne i8 %y_rel.0, 0
  br i1 %tobool155, label %if.then156, label %if.end167

if.then156:                                       ; preds = %if.end154
  %arrayidx157 = getelementptr inbounds [32 x i8], [32 x i8]* %data, i64 0, i64 16
  %30 = load i8, i8* %arrayidx157, align 16, !tbaa !67
  %conv158 = zext i8 %30 to i32
  %and159 = and i32 %conv158, %5
  %tobool160 = icmp ne i32 %and159, 0
  %conv162 = sext i8 %y_rel.0 to i32
  %sub163 = sub nsw i32 0, %conv162
  %conv164 = trunc i32 %sub163 to i8
  %y_rel.2 = select i1 %tobool160, i8 %conv164, i8 %y_rel.0
  %conv166 = sext i8 %y_rel.2 to i32
  call void @input_report_rel(%struct.input_dev* %4, i32 1, i32 %conv166)
  br label %if.end167

if.end167:                                        ; preds = %if.then156, %if.end154
  call void @input_sync(%struct.input_dev* %4)
  br label %for.inc169

for.inc169:                                       ; preds = %for.end, %for.end85, %if.end167, %land.lhs.true100, %land.lhs.true95, %land.lhs.true, %sw.bb86, %LeafBlock, %LeafBlock1, %LeafBlock3
  %inc170 = add nsw i32 %i.0, 1
  br label %for.cond

for.end171:                                       ; preds = %for.cond
  %31 = bitcast [32 x i8]* %data to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %31) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gc_multi_process_packet(%struct.gc* %gc) #4 {
entry:
  %data = alloca [6 x i8], align 1
  %0 = bitcast [6 x i8]* %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 6, i8* %0) #7
  %pad_count = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 3
  %arrayidx = getelementptr inbounds [10 x i32], [10 x i32]* %pad_count, i64 0, i64 5
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !15
  %tobool = icmp ne i32 %1, 0
  %2 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 6, i32 5
  %arraydecay = getelementptr inbounds [6 x i8], [6 x i8]* %data, i32 0, i32 0
  call void @gc_multi_read_packet(%struct.gc* %gc, i32 %cond, i8* %arraydecay)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pads = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 1
  %idxprom = sext i32 %i.0 to i64
  %arrayidx1 = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads, i64 0, i64 %idxprom
  %dev2 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx1, i32 0, i32 0
  %3 = load %struct.input_dev*, %struct.input_dev** %dev2, align 8, !tbaa !28
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [5 x i32], [5 x i32]* @gc_status_bit, i64 0, i64 %idxprom3
  %4 = load i32, i32* %arrayidx4, align 4, !tbaa !15
  %type = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx1, i32 0, i32 1
  %5 = load i32, i32* %type, align 8, !tbaa !31
  %Pivot = icmp slt i32 %5, 5
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %for.body
  %SwitchLeaf2 = icmp eq i32 %5, 5
  br i1 %SwitchLeaf2, label %sw.bb, label %for.inc

LeafBlock:                                        ; preds = %for.body
  %SwitchLeaf = icmp eq i32 %5, 4
  br i1 %SwitchLeaf, label %sw.bb6, label %for.inc

sw.bb:                                            ; preds = %LeafBlock1
  %arrayidx5 = getelementptr inbounds [6 x i8], [6 x i8]* %data, i64 0, i64 5
  %6 = load i8, i8* %arrayidx5, align 1, !tbaa !67
  %conv = zext i8 %6 to i32
  %and = and i32 %4, %conv
  call void @input_report_key(%struct.input_dev* %3, i32 289, i32 %and)
  br label %sw.bb6

sw.bb6:                                           ; preds = %LeafBlock, %sw.bb
  %arrayidx7 = getelementptr inbounds [6 x i8], [6 x i8]* %data, i64 0, i64 2
  %7 = load i8, i8* %arrayidx7, align 1, !tbaa !67
  %conv8 = zext i8 %7 to i32
  %and9 = and i32 %4, %conv8
  %tobool10 = icmp ne i32 %and9, 0
  %lnot = xor i1 %tobool10, true
  %lnot.ext = zext i1 %lnot to i32
  %arrayidx11 = getelementptr inbounds [6 x i8], [6 x i8]* %data, i64 0, i64 3
  %8 = load i8, i8* %arrayidx11, align 1, !tbaa !67
  %conv12 = zext i8 %8 to i32
  %and13 = and i32 %4, %conv12
  %tobool14 = icmp ne i32 %and13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %sub = sub nsw i32 %lnot.ext, %lnot.ext16
  call void @input_report_abs(%struct.input_dev* %3, i32 0, i32 %sub)
  %arrayidx17 = getelementptr inbounds [6 x i8], [6 x i8]* %data, i64 0, i64 0
  %9 = load i8, i8* %arrayidx17, align 1, !tbaa !67
  %conv18 = zext i8 %9 to i32
  %and19 = and i32 %4, %conv18
  %tobool20 = icmp ne i32 %and19, 0
  %lnot21 = xor i1 %tobool20, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %arrayidx23 = getelementptr inbounds [6 x i8], [6 x i8]* %data, i64 0, i64 1
  %10 = load i8, i8* %arrayidx23, align 1, !tbaa !67
  %conv24 = zext i8 %10 to i32
  %and25 = and i32 %4, %conv24
  %tobool26 = icmp ne i32 %and25, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %sub29 = sub nsw i32 %lnot.ext22, %lnot.ext28
  call void @input_report_abs(%struct.input_dev* %3, i32 1, i32 %sub29)
  %arrayidx30 = getelementptr inbounds [6 x i8], [6 x i8]* %data, i64 0, i64 4
  %11 = load i8, i8* %arrayidx30, align 1, !tbaa !67
  %conv31 = zext i8 %11 to i32
  %and32 = and i32 %4, %conv31
  call void @input_report_key(%struct.input_dev* %3, i32 288, i32 %and32)
  call void @input_sync(%struct.input_dev* %3)
  br label %for.inc

for.inc:                                          ; preds = %sw.bb6, %LeafBlock, %LeafBlock1
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = bitcast [6 x i8]* %data to i8*
  call void @llvm.lifetime.end.p0i8(i64 6, i8* %12) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gc_psx_process_packet(%struct.gc* %gc) #4 {
entry:
  %data = alloca [5 x [6 x i8]], align 16
  %id = alloca [5 x i8], align 1
  %0 = bitcast [5 x [6 x i8]]* %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 30, i8* %0) #7
  %1 = bitcast [5 x i8]* %id to i8*
  call void @llvm.lifetime.start.p0i8(i64 5, i8* %1) #7
  %arraydecay = getelementptr inbounds [5 x [6 x i8]], [5 x [6 x i8]]* %data, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [5 x i8], [5 x i8]* %id, i32 0, i32 0
  call void @gc_psx_read_packet(%struct.gc* %gc, [6 x i8]* %arraydecay, i8* %arraydecay1)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pads = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 1
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads, i64 0, i64 %idxprom
  %type = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 1
  %2 = load i32, i32* %type, align 8, !tbaa !31
  %cmp2 = icmp eq i32 %2, 7
  br i1 %cmp2, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %type3 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 1
  %3 = load i32, i32* %type3, align 8, !tbaa !31
  %cmp4 = icmp eq i32 %3, 8
  br i1 %cmp4, label %if.then, label %for.inc

if.then:                                          ; preds = %lor.lhs.false, %for.body
  %idxprom5 = sext i32 %i.0 to i64
  %arrayidx6 = getelementptr inbounds [5 x i8], [5 x i8]* %id, i64 0, i64 %idxprom5
  %4 = load i8, i8* %arrayidx6, align 1, !tbaa !67
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds [5 x [6 x i8]], [5 x [6 x i8]]* %data, i64 0, i64 %idxprom7
  %arraydecay9 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx8, i32 0, i32 0
  call void @gc_psx_report_one(%struct.gc_pad* %arrayidx, i8 zeroext %4, i8* %arraydecay9)
  br label %for.inc

for.inc:                                          ; preds = %lor.lhs.false, %if.then
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %5 = bitcast [5 x i8]* %id to i8*
  call void @llvm.lifetime.end.p0i8(i64 5, i8* %5) #7
  %6 = bitcast [5 x [6 x i8]]* %data to i8*
  call void @llvm.lifetime.end.p0i8(i64 30, i8* %6) #7
  ret void
}

declare i32 @mod_timer(%struct.timer_list*, i64) #3

; Function Attrs: nounwind uwtable
define internal void @gc_n64_read_packet(%struct.gc* %gc, i8* %data) #4 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy5 = alloca i64, align 8
  %__dummy26 = alloca i64, align 8
  %__dummy13 = alloca i64, align 8
  %__dummy214 = alloca i64, align 8
  %__dummy21 = alloca i64, align 8
  %__dummy222 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %call = call i64 @arch_local_irq_save()
  call void @trace_hardirqs_off()
  call void @gc_n64_send_command(%struct.gc* %gc, i64 3507556625, i8 zeroext 29)
  call void @gc_n64_send_stop_bit(%struct.gc* %gc, i8 zeroext 29)
  %4 = bitcast i64* %__dummy5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy26 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %cmp7 = icmp eq i64* %__dummy5, %__dummy26
  %conv8 = zext i1 %cmp7 to i32
  %6 = bitcast i64* %__dummy26 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  %7 = bitcast i64* %__dummy5 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %call11 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %do.body12, label %if.else

do.body12:                                        ; preds = %entry
  %8 = bitcast i64* %__dummy13 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #7
  %9 = bitcast i64* %__dummy214 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #7
  %cmp15 = icmp eq i64* %__dummy13, %__dummy214
  %conv16 = zext i1 %cmp15 to i32
  %10 = bitcast i64* %__dummy214 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #7
  %11 = bitcast i64* %__dummy13 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #7
  call void @arch_local_irq_restore(i64 %call)
  call void @trace_hardirqs_off()
  br label %do.end29

if.else:                                          ; preds = %entry
  call void @trace_hardirqs_on()
  %12 = bitcast i64* %__dummy21 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %12) #7
  %13 = bitcast i64* %__dummy222 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %13) #7
  %cmp23 = icmp eq i64* %__dummy21, %__dummy222
  %conv24 = zext i1 %cmp23 to i32
  %14 = bitcast i64* %__dummy222 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #7
  %15 = bitcast i64* %__dummy21 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #7
  call void @arch_local_irq_restore(i64 %call)
  br label %do.end29

do.end29:                                         ; preds = %if.else, %do.body12
  call void @__const_udelay(i64 571235)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %do.end29
  %i.0 = phi i32 [ 0, %do.end29 ], [ %inc, %for.body ]
  %cmp30 = icmp slt i32 %i.0, 32
  br i1 %cmp30, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %16 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  %port = getelementptr inbounds %struct.pardevice, %struct.pardevice* %16, i32 0, i32 1
  %17 = load %struct.parport*, %struct.parport** %port, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.parport, %struct.parport* %17, i32 0, i32 22
  %18 = load %struct.parport_operations*, %struct.parport_operations** %ops, align 8, !tbaa !68
  %write_data = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %18, i32 0, i32 0
  %19 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data, align 8, !tbaa !69
  %pd32 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %20 = load %struct.pardevice*, %struct.pardevice** %pd32, align 8, !tbaa !17
  %port33 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %20, i32 0, i32 1
  %21 = load %struct.parport*, %struct.parport** %port33, align 8, !tbaa !32
  call void %19(%struct.parport* %21, i8 zeroext -3)
  call void @__const_udelay(i64 8590)
  %pd34 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %22 = load %struct.pardevice*, %struct.pardevice** %pd34, align 8, !tbaa !17
  %port35 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %22, i32 0, i32 1
  %23 = load %struct.parport*, %struct.parport** %port35, align 8, !tbaa !32
  %ops36 = getelementptr inbounds %struct.parport, %struct.parport* %23, i32 0, i32 22
  %24 = load %struct.parport_operations*, %struct.parport_operations** %ops36, align 8, !tbaa !68
  %read_status = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %24, i32 0, i32 5
  %25 = load i8 (%struct.parport*)*, i8 (%struct.parport*)** %read_status, align 8, !tbaa !71
  %pd37 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %26 = load %struct.pardevice*, %struct.pardevice** %pd37, align 8, !tbaa !17
  %port38 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %26, i32 0, i32 1
  %27 = load %struct.parport*, %struct.parport** %port38, align 8, !tbaa !32
  %call39 = call zeroext i8 %25(%struct.parport* %27)
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 %idxprom
  store i8 %call39, i8* %arrayidx, align 1, !tbaa !67
  %pd40 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %28 = load %struct.pardevice*, %struct.pardevice** %pd40, align 8, !tbaa !17
  %port41 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %28, i32 0, i32 1
  %29 = load %struct.parport*, %struct.parport** %port41, align 8, !tbaa !32
  %ops42 = getelementptr inbounds %struct.parport, %struct.parport* %29, i32 0, i32 22
  %30 = load %struct.parport_operations*, %struct.parport_operations** %ops42, align 8, !tbaa !68
  %write_data43 = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %30, i32 0, i32 0
  %31 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data43, align 8, !tbaa !69
  %pd44 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %32 = load %struct.pardevice*, %struct.pardevice** %pd44, align 8, !tbaa !17
  %port45 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %32, i32 0, i32 1
  %33 = load %struct.parport*, %struct.parport** %port45, align 8, !tbaa !32
  call void %31(%struct.parport* %33, i8 zeroext -1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_abs(%struct.input_dev* %dev, i32 %code, i32 %value) #0 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 3, i32 %code, i32 %value)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_key(%struct.input_dev* %dev, i32 %code, i32 %value) #0 {
entry:
  %tobool = icmp ne i32 %value, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  call void @input_event(%struct.input_dev* %dev, i32 1, i32 %code, i32 %lnot.ext)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_sync(%struct.input_dev* %dev) #0 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 0, i32 0, i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_irq_save() #0 {
entry:
  %call = call i64 @arch_local_save_flags()
  call void @arch_local_irq_disable()
  ret i64 %call
}

declare void @trace_hardirqs_off() #3

; Function Attrs: nounwind uwtable
define internal void @gc_n64_send_command(%struct.gc* %gc, i64 %cmd, i8 zeroext %target) #4 {
entry:
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %0 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  %port1 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %0, i32 0, i32 1
  %1 = load %struct.parport*, %struct.parport** %port1, align 8, !tbaa !32
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %sh_prom = zext i32 %i.0 to i64
  %shr = lshr i64 %cmd, %sh_prom
  %and = and i64 %shr, 1
  %tobool = icmp ne i64 %and, 0
  %conv = zext i8 %target to i32
  %cond = select i1 %tobool, i32 %conv, i32 0
  %conv2 = trunc i32 %cond to i8
  %ops = getelementptr inbounds %struct.parport, %struct.parport* %1, i32 0, i32 22
  %2 = load %struct.parport_operations*, %struct.parport_operations** %ops, align 8, !tbaa !68
  %write_data = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %2, i32 0, i32 0
  %3 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data, align 8, !tbaa !69
  %conv3 = zext i8 %conv2 to i32
  %or = or i32 226, %conv3
  %conv4 = trunc i32 %or to i8
  call void %3(%struct.parport* %1, i8 zeroext %conv4)
  call void @__const_udelay(i64 12885)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gc_n64_send_stop_bit(%struct.gc* %gc, i8 zeroext %target) #4 {
entry:
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %0 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  %port1 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %0, i32 0, i32 1
  %1 = load %struct.parport*, %struct.parport** %port1, align 8, !tbaa !32
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %shr = ashr i32 29, %i.0
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  %conv = zext i8 %target to i32
  %cond = select i1 %tobool, i32 %conv, i32 0
  %conv2 = trunc i32 %cond to i8
  %ops = getelementptr inbounds %struct.parport, %struct.parport* %1, i32 0, i32 22
  %2 = load %struct.parport_operations*, %struct.parport_operations** %ops, align 8, !tbaa !68
  %write_data = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %2, i32 0, i32 0
  %3 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data, align 8, !tbaa !69
  %conv3 = zext i8 %conv2 to i32
  %or = or i32 226, %conv3
  %conv4 = trunc i32 %or to i8
  call void %3(%struct.parport* %1, i8 zeroext %conv4)
  call void @__const_udelay(i64 12885)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags(i64 %flags) #0 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_restore(i64 %f) #0 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 1, i32 0), align 8, !tbaa !72
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.9, i32 0, i32 0), i32 829, i64 12) #7, !srcloc !75
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,{di},~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 45, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 1, i32 0), i32 1, i64 %f) #7, !srcloc !76
  ret void
}

declare void @trace_hardirqs_on() #3

declare void @__const_udelay(i64) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags() #0 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !77
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.9, i32 0, i32 0), i32 824, i64 12) #7, !srcloc !78
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 44, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1) #7, !srcloc !79
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_disable() #0 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 2, i32 0), align 8, !tbaa !80
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.9, i32 0, i32 0), i32 834, i64 12) #7, !srcloc !81
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 46, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 2, i32 0), i32 1) #7, !srcloc !82
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #6

declare void @input_event(%struct.input_dev*, i32, i32, i32) #3

; Function Attrs: nounwind uwtable
define internal void @gc_nes_read_packet(%struct.gc* %gc, i32 %length, i8* %data) #4 {
entry:
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %0 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  %port = getelementptr inbounds %struct.pardevice, %struct.pardevice* %0, i32 0, i32 1
  %1 = load %struct.parport*, %struct.parport** %port, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.parport, %struct.parport* %1, i32 0, i32 22
  %2 = load %struct.parport_operations*, %struct.parport_operations** %ops, align 8, !tbaa !68
  %write_data = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %2, i32 0, i32 0
  %3 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data, align 8, !tbaa !69
  %pd1 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %4 = load %struct.pardevice*, %struct.pardevice** %pd1, align 8, !tbaa !17
  %port2 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %4, i32 0, i32 1
  %5 = load %struct.parport*, %struct.parport** %port2, align 8, !tbaa !32
  call void %3(%struct.parport* %5, i8 zeroext -1)
  call void @__const_udelay(i64 51540)
  %pd3 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %6 = load %struct.pardevice*, %struct.pardevice** %pd3, align 8, !tbaa !17
  %port4 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %6, i32 0, i32 1
  %7 = load %struct.parport*, %struct.parport** %port4, align 8, !tbaa !32
  %ops5 = getelementptr inbounds %struct.parport, %struct.parport* %7, i32 0, i32 22
  %8 = load %struct.parport_operations*, %struct.parport_operations** %ops5, align 8, !tbaa !68
  %write_data6 = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %8, i32 0, i32 0
  %9 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data6, align 8, !tbaa !69
  %pd7 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %10 = load %struct.pardevice*, %struct.pardevice** %pd7, align 8, !tbaa !17
  %port8 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %10, i32 0, i32 1
  %11 = load %struct.parport*, %struct.parport** %port8, align 8, !tbaa !32
  call void %9(%struct.parport* %11, i8 zeroext -3)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, %length
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @__const_udelay(i64 25770)
  %pd9 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %12 = load %struct.pardevice*, %struct.pardevice** %pd9, align 8, !tbaa !17
  %port10 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %12, i32 0, i32 1
  %13 = load %struct.parport*, %struct.parport** %port10, align 8, !tbaa !32
  %ops11 = getelementptr inbounds %struct.parport, %struct.parport* %13, i32 0, i32 22
  %14 = load %struct.parport_operations*, %struct.parport_operations** %ops11, align 8, !tbaa !68
  %write_data12 = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %14, i32 0, i32 0
  %15 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data12, align 8, !tbaa !69
  %pd13 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %16 = load %struct.pardevice*, %struct.pardevice** %pd13, align 8, !tbaa !17
  %port14 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %16, i32 0, i32 1
  %17 = load %struct.parport*, %struct.parport** %port14, align 8, !tbaa !32
  call void %15(%struct.parport* %17, i8 zeroext -4)
  %pd15 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %18 = load %struct.pardevice*, %struct.pardevice** %pd15, align 8, !tbaa !17
  %port16 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %18, i32 0, i32 1
  %19 = load %struct.parport*, %struct.parport** %port16, align 8, !tbaa !32
  %ops17 = getelementptr inbounds %struct.parport, %struct.parport* %19, i32 0, i32 22
  %20 = load %struct.parport_operations*, %struct.parport_operations** %ops17, align 8, !tbaa !68
  %read_status = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %20, i32 0, i32 5
  %21 = load i8 (%struct.parport*)*, i8 (%struct.parport*)** %read_status, align 8, !tbaa !71
  %pd18 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %22 = load %struct.pardevice*, %struct.pardevice** %pd18, align 8, !tbaa !17
  %port19 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %22, i32 0, i32 1
  %23 = load %struct.parport*, %struct.parport** %port19, align 8, !tbaa !32
  %call = call zeroext i8 %21(%struct.parport* %23)
  %conv = zext i8 %call to i32
  %xor = xor i32 %conv, 127
  %conv20 = trunc i32 %xor to i8
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 %idxprom
  store i8 %conv20, i8* %arrayidx, align 1, !tbaa !67
  call void @__const_udelay(i64 25770)
  %pd21 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %24 = load %struct.pardevice*, %struct.pardevice** %pd21, align 8, !tbaa !17
  %port22 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %24, i32 0, i32 1
  %25 = load %struct.parport*, %struct.parport** %port22, align 8, !tbaa !32
  %ops23 = getelementptr inbounds %struct.parport, %struct.parport* %25, i32 0, i32 22
  %26 = load %struct.parport_operations*, %struct.parport_operations** %ops23, align 8, !tbaa !68
  %write_data24 = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %26, i32 0, i32 0
  %27 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data24, align 8, !tbaa !69
  %pd25 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %28 = load %struct.pardevice*, %struct.pardevice** %pd25, align 8, !tbaa !17
  %port26 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %28, i32 0, i32 1
  %29 = load %struct.parport*, %struct.parport** %port26, align 8, !tbaa !32
  call void %27(%struct.parport* %29, i8 zeroext -3)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_rel(%struct.input_dev* %dev, i32 %code, i32 %value) #0 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 2, i32 %code, i32 %value)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gc_multi_read_packet(%struct.gc* %gc, i32 %length, i8* %data) #4 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, %length
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %0 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  %port = getelementptr inbounds %struct.pardevice, %struct.pardevice* %0, i32 0, i32 1
  %1 = load %struct.parport*, %struct.parport** %port, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.parport, %struct.parport* %1, i32 0, i32 22
  %2 = load %struct.parport_operations*, %struct.parport_operations** %ops, align 8, !tbaa !68
  %write_data = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %2, i32 0, i32 0
  %3 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data, align 8, !tbaa !69
  %pd1 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %4 = load %struct.pardevice*, %struct.pardevice** %pd1, align 8, !tbaa !17
  %port2 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %4, i32 0, i32 1
  %5 = load %struct.parport*, %struct.parport** %port2, align 8, !tbaa !32
  %shl = shl i32 1, %i.0
  %neg = xor i32 %shl, -1
  %conv = trunc i32 %neg to i8
  call void %3(%struct.parport* %5, i8 zeroext %conv)
  %pd3 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %6 = load %struct.pardevice*, %struct.pardevice** %pd3, align 8, !tbaa !17
  %port4 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %6, i32 0, i32 1
  %7 = load %struct.parport*, %struct.parport** %port4, align 8, !tbaa !32
  %ops5 = getelementptr inbounds %struct.parport, %struct.parport* %7, i32 0, i32 22
  %8 = load %struct.parport_operations*, %struct.parport_operations** %ops5, align 8, !tbaa !68
  %read_status = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %8, i32 0, i32 5
  %9 = load i8 (%struct.parport*)*, i8 (%struct.parport*)** %read_status, align 8, !tbaa !71
  %pd6 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %10 = load %struct.pardevice*, %struct.pardevice** %pd6, align 8, !tbaa !17
  %port7 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %10, i32 0, i32 1
  %11 = load %struct.parport*, %struct.parport** %port7, align 8, !tbaa !32
  %call = call zeroext i8 %9(%struct.parport* %11)
  %conv8 = zext i8 %call to i32
  %xor = xor i32 %conv8, 127
  %conv9 = trunc i32 %xor to i8
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 %idxprom
  store i8 %conv9, i8* %arrayidx, align 1, !tbaa !67
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gc_psx_read_packet(%struct.gc* %gc, [6 x i8]* %data, i8* %id) #4 {
entry:
  %data2 = alloca [5 x i8], align 1
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy62 = alloca i64, align 8
  %__dummy263 = alloca i64, align 8
  %__dummy71 = alloca i64, align 8
  %__dummy272 = alloca i64, align 8
  %__dummy79 = alloca i64, align 8
  %__dummy280 = alloca i64, align 8
  %0 = bitcast [5 x i8]* %data2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 5, i8* %0) #7
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %1 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  %port = getelementptr inbounds %struct.pardevice, %struct.pardevice* %1, i32 0, i32 1
  %2 = load %struct.parport*, %struct.parport** %port, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.parport, %struct.parport* %2, i32 0, i32 22
  %3 = load %struct.parport_operations*, %struct.parport_operations** %ops, align 8, !tbaa !68
  %write_data = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %3, i32 0, i32 0
  %4 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data, align 8, !tbaa !69
  %pd1 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %5 = load %struct.pardevice*, %struct.pardevice** %pd1, align 8, !tbaa !17
  %port2 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %5, i32 0, i32 1
  %6 = load %struct.parport*, %struct.parport** %port2, align 8, !tbaa !32
  call void %4(%struct.parport* %6, i8 zeroext -2)
  %7 = load i32, i32* @gc_psx_delay, align 4, !tbaa !15
  %conv = sext i32 %7 to i64
  call void @__udelay(i64 %conv)
  %pd3 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %8 = load %struct.pardevice*, %struct.pardevice** %pd3, align 8, !tbaa !17
  %port4 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %8, i32 0, i32 1
  %9 = load %struct.parport*, %struct.parport** %port4, align 8, !tbaa !32
  %ops5 = getelementptr inbounds %struct.parport, %struct.parport* %9, i32 0, i32 22
  %10 = load %struct.parport_operations*, %struct.parport_operations** %ops5, align 8, !tbaa !68
  %write_data6 = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %10, i32 0, i32 0
  %11 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data6, align 8, !tbaa !69
  %pd7 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %12 = load %struct.pardevice*, %struct.pardevice** %pd7, align 8, !tbaa !17
  %port8 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %12, i32 0, i32 1
  %13 = load %struct.parport*, %struct.parport** %port8, align 8, !tbaa !32
  call void %11(%struct.parport* %13, i8 zeroext -4)
  %14 = load i32, i32* @gc_psx_delay, align 4, !tbaa !15
  %conv9 = sext i32 %14 to i64
  call void @__udelay(i64 %conv9)
  %15 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %15) #7
  %16 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv11 = zext i1 %cmp to i32
  %17 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #7
  %18 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #7
  %call = call i64 @arch_local_irq_save()
  call void @trace_hardirqs_off()
  %arraydecay = getelementptr inbounds [5 x i8], [5 x i8]* %data2, i32 0, i32 0
  call void @gc_psx_command(%struct.gc* %gc, i32 1, i8* %arraydecay)
  call void @gc_psx_command(%struct.gc* %gc, i32 66, i8* %id)
  %arraydecay14 = getelementptr inbounds [5 x i8], [5 x i8]* %data2, i32 0, i32 0
  call void @gc_psx_command(%struct.gc* %gc, i32 0, i8* %arraydecay14)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %max_len.0 = phi i32 [ 0, %entry ], [ %max_len.1, %for.inc ]
  %cmp15 = icmp slt i32 %i.0, 5
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pads = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 1
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads, i64 0, i64 %idxprom
  %type = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 1
  %19 = load i32, i32* %type, align 8, !tbaa !31
  %cmp17 = icmp eq i32 %19, 7
  br i1 %cmp17, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %type19 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 1
  %20 = load i32, i32* %type19, align 8, !tbaa !31
  %cmp20 = icmp eq i32 %20, 8
  br i1 %cmp20, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %lor.lhs.false, %for.body
  %idxprom22 = sext i32 %i.0 to i64
  %arrayidx23 = getelementptr inbounds i8, i8* %id, i64 %idxprom22
  %21 = load i8, i8* %arrayidx23, align 1, !tbaa !67
  %conv24 = zext i8 %21 to i32
  %and = and i32 %conv24, 15
  %shl = shl i32 %and, 1
  %cmp25 = icmp sgt i32 %shl, %max_len.0
  br i1 %cmp25, label %land.lhs.true27, label %for.inc

land.lhs.true27:                                  ; preds = %land.lhs.true
  %idxprom28 = sext i32 %i.0 to i64
  %arrayidx29 = getelementptr inbounds i8, i8* %id, i64 %idxprom28
  %22 = load i8, i8* %arrayidx29, align 1, !tbaa !67
  %conv30 = zext i8 %22 to i32
  %and31 = and i32 %conv30, 15
  %shl32 = shl i32 %and31, 1
  %cmp33 = icmp sle i32 %shl32, 6
  br i1 %cmp33, label %if.then, label %for.inc

if.then:                                          ; preds = %land.lhs.true27
  %idxprom35 = sext i32 %i.0 to i64
  %arrayidx36 = getelementptr inbounds i8, i8* %id, i64 %idxprom35
  %23 = load i8, i8* %arrayidx36, align 1, !tbaa !67
  %conv37 = zext i8 %23 to i32
  %and38 = and i32 %conv37, 15
  %shl39 = shl i32 %and38, 1
  br label %for.inc

for.inc:                                          ; preds = %lor.lhs.false, %land.lhs.true, %land.lhs.true27, %if.then
  %max_len.1 = phi i32 [ %shl39, %if.then ], [ %max_len.0, %land.lhs.true27 ], [ %max_len.0, %land.lhs.true ], [ %max_len.0, %lor.lhs.false ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc58, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc59, %for.inc58 ]
  %cmp41 = icmp slt i32 %i.1, %max_len.0
  br i1 %cmp41, label %for.body43, label %do.body61

for.body43:                                       ; preds = %for.cond40
  %arraydecay44 = getelementptr inbounds [5 x i8], [5 x i8]* %data2, i32 0, i32 0
  call void @gc_psx_command(%struct.gc* %gc, i32 0, i8* %arraydecay44)
  br label %for.cond45

for.cond45:                                       ; preds = %for.body48, %for.body43
  %j.0 = phi i32 [ 0, %for.body43 ], [ %inc56, %for.body48 ]
  %cmp46 = icmp slt i32 %j.0, 5
  br i1 %cmp46, label %for.body48, label %for.inc58

for.body48:                                       ; preds = %for.cond45
  %idxprom49 = sext i32 %j.0 to i64
  %arrayidx50 = getelementptr inbounds [5 x i8], [5 x i8]* %data2, i64 0, i64 %idxprom49
  %24 = load i8, i8* %arrayidx50, align 1, !tbaa !67
  %idxprom51 = sext i32 %j.0 to i64
  %arrayidx52 = getelementptr inbounds [6 x i8], [6 x i8]* %data, i64 %idxprom51
  %idxprom53 = sext i32 %i.1 to i64
  %arrayidx54 = getelementptr inbounds [6 x i8], [6 x i8]* %arrayidx52, i64 0, i64 %idxprom53
  store i8 %24, i8* %arrayidx54, align 1, !tbaa !67
  %inc56 = add nsw i32 %j.0, 1
  br label %for.cond45

for.inc58:                                        ; preds = %for.cond45
  %inc59 = add nsw i32 %i.1, 1
  br label %for.cond40

do.body61:                                        ; preds = %for.cond40
  %25 = bitcast i64* %__dummy62 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %25) #7
  %26 = bitcast i64* %__dummy263 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %26) #7
  %cmp64 = icmp eq i64* %__dummy62, %__dummy263
  %conv65 = zext i1 %cmp64 to i32
  %27 = bitcast i64* %__dummy263 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %27) #7
  %28 = bitcast i64* %__dummy62 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #7
  %call68 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call68, 0
  br i1 %tobool, label %do.body70, label %if.else

do.body70:                                        ; preds = %do.body61
  %29 = bitcast i64* %__dummy71 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %29) #7
  %30 = bitcast i64* %__dummy272 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %30) #7
  %cmp73 = icmp eq i64* %__dummy71, %__dummy272
  %conv74 = zext i1 %cmp73 to i32
  %31 = bitcast i64* %__dummy272 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #7
  %32 = bitcast i64* %__dummy71 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %32) #7
  call void @arch_local_irq_restore(i64 %call)
  call void @trace_hardirqs_off()
  br label %do.end88

if.else:                                          ; preds = %do.body61
  call void @trace_hardirqs_on()
  %33 = bitcast i64* %__dummy79 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %33) #7
  %34 = bitcast i64* %__dummy280 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %34) #7
  %cmp81 = icmp eq i64* %__dummy79, %__dummy280
  %conv82 = zext i1 %cmp81 to i32
  %35 = bitcast i64* %__dummy280 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %35) #7
  %36 = bitcast i64* %__dummy79 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %36) #7
  call void @arch_local_irq_restore(i64 %call)
  br label %do.end88

do.end88:                                         ; preds = %if.else, %do.body70
  %pd89 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %37 = load %struct.pardevice*, %struct.pardevice** %pd89, align 8, !tbaa !17
  %port90 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %37, i32 0, i32 1
  %38 = load %struct.parport*, %struct.parport** %port90, align 8, !tbaa !32
  %ops91 = getelementptr inbounds %struct.parport, %struct.parport* %38, i32 0, i32 22
  %39 = load %struct.parport_operations*, %struct.parport_operations** %ops91, align 8, !tbaa !68
  %write_data92 = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %39, i32 0, i32 0
  %40 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data92, align 8, !tbaa !69
  %pd93 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %41 = load %struct.pardevice*, %struct.pardevice** %pd93, align 8, !tbaa !17
  %port94 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %41, i32 0, i32 1
  %42 = load %struct.parport*, %struct.parport** %port94, align 8, !tbaa !32
  call void %40(%struct.parport* %42, i8 zeroext -2)
  br label %for.cond95

for.cond95:                                       ; preds = %for.body98, %do.end88
  %i.2 = phi i32 [ 0, %do.end88 ], [ %inc106, %for.body98 ]
  %cmp96 = icmp slt i32 %i.2, 5
  br i1 %cmp96, label %for.body98, label %for.end107

for.body98:                                       ; preds = %for.cond95
  %idxprom99 = sext i32 %i.2 to i64
  %arrayidx100 = getelementptr inbounds i8, i8* %id, i64 %idxprom99
  %43 = load i8, i8* %arrayidx100, align 1, !tbaa !67
  %conv101 = zext i8 %43 to i32
  %shr = ashr i32 %conv101, 4
  %conv102 = trunc i32 %shr to i8
  %idxprom103 = sext i32 %i.2 to i64
  %arrayidx104 = getelementptr inbounds i8, i8* %id, i64 %idxprom103
  store i8 %conv102, i8* %arrayidx104, align 1, !tbaa !67
  %inc106 = add nsw i32 %i.2, 1
  br label %for.cond95

for.end107:                                       ; preds = %for.cond95
  %44 = bitcast [5 x i8]* %data2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 5, i8* %44) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gc_psx_report_one(%struct.gc_pad* %pad, i8 zeroext %psx_type, i8* %data) #4 {
entry:
  %dev1 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %pad, i32 0, i32 0
  %0 = load %struct.input_dev*, %struct.input_dev** %dev1, align 8, !tbaa !28
  %conv = zext i8 %psx_type to i32
  %Pivot8 = icmp slt i32 %conv, 5
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %entry
  %Pivot6 = icmp slt i32 %conv, 7
  br i1 %Pivot6, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %conv, 7
  br i1 %SwitchLeaf4, label %sw.bb, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock5
  %SwitchLeaf2 = icmp eq i32 %conv, 5
  br i1 %SwitchLeaf2, label %sw.bb7, label %sw.epilog

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %conv, 4
  br i1 %Pivot, label %LeafBlock, label %sw.bb83

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb7, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock3
  %arrayidx = getelementptr inbounds i8, i8* %data, i64 0
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !67
  %conv2 = zext i8 %1 to i32
  %neg = xor i32 %conv2, -1
  %and = and i32 %neg, 4
  call void @input_report_key(%struct.input_dev* %0, i32 317, i32 %and)
  %arrayidx3 = getelementptr inbounds i8, i8* %data, i64 0
  %2 = load i8, i8* %arrayidx3, align 1, !tbaa !67
  %conv4 = zext i8 %2 to i32
  %neg5 = xor i32 %conv4, -1
  %and6 = and i32 %neg5, 2
  call void @input_report_key(%struct.input_dev* %0, i32 318, i32 %and6)
  br label %sw.bb7

sw.bb7:                                           ; preds = %LeafBlock1, %LeafBlock, %sw.bb
  %type = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %pad, i32 0, i32 1
  %3 = load i32, i32* %type, align 8, !tbaa !31
  %cmp = icmp eq i32 %3, 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb7
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %cmp9 = icmp slt i32 %i.0, 4
  br i1 %cmp9, label %for.body, label %if.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx11 = getelementptr inbounds [4 x i16], [4 x i16]* @gc_psx_ddr_btn, i64 0, i64 %idxprom
  %4 = load i16, i16* %arrayidx11, align 2, !tbaa !66
  %conv12 = sext i16 %4 to i32
  %arrayidx13 = getelementptr inbounds i8, i8* %data, i64 0
  %5 = load i8, i8* %arrayidx13, align 1, !tbaa !67
  %conv14 = zext i8 %5 to i32
  %neg15 = xor i32 %conv14, -1
  %shl = shl i32 16, %i.0
  %and16 = and i32 %neg15, %shl
  call void @input_report_key(%struct.input_dev* %0, i32 %conv12, i32 %and16)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %sw.bb7
  br label %for.cond17

for.cond17:                                       ; preds = %for.body20, %if.else
  %i.1 = phi i32 [ 0, %if.else ], [ %inc29, %for.body20 ]
  %cmp18 = icmp slt i32 %i.1, 4
  br i1 %cmp18, label %for.body20, label %for.end30

for.body20:                                       ; preds = %for.cond17
  %add = add nsw i32 %i.1, 2
  %idxprom21 = sext i32 %add to i64
  %arrayidx22 = getelementptr inbounds [6 x i16], [6 x i16]* @gc_psx_abs, i64 0, i64 %idxprom21
  %6 = load i16, i16* %arrayidx22, align 2, !tbaa !66
  %conv23 = sext i16 %6 to i32
  %add24 = add nsw i32 %i.1, 2
  %idxprom25 = sext i32 %add24 to i64
  %arrayidx26 = getelementptr inbounds i8, i8* %data, i64 %idxprom25
  %7 = load i8, i8* %arrayidx26, align 1, !tbaa !67
  %conv27 = zext i8 %7 to i32
  call void @input_report_abs(%struct.input_dev* %0, i32 %conv23, i32 %conv27)
  %inc29 = add nsw i32 %i.1, 1
  br label %for.cond17

for.end30:                                        ; preds = %for.cond17
  %arrayidx31 = getelementptr inbounds i8, i8* %data, i64 0
  %8 = load i8, i8* %arrayidx31, align 1, !tbaa !67
  %conv32 = zext i8 %8 to i32
  %and33 = and i32 %conv32, 128
  %tobool = icmp ne i32 %and33, 0
  %lnot = xor i1 %tobool, true
  %lnot34 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot34 to i32
  %mul = mul nsw i32 %lnot.ext, 128
  %arrayidx35 = getelementptr inbounds i8, i8* %data, i64 0
  %9 = load i8, i8* %arrayidx35, align 1, !tbaa !67
  %conv36 = zext i8 %9 to i32
  %and37 = and i32 %conv36, 32
  %tobool38 = icmp ne i32 %and37, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %mul41 = mul nsw i32 %lnot.ext40, 127
  %add42 = add nsw i32 %mul, %mul41
  call void @input_report_abs(%struct.input_dev* %0, i32 0, i32 %add42)
  %arrayidx43 = getelementptr inbounds i8, i8* %data, i64 0
  %10 = load i8, i8* %arrayidx43, align 1, !tbaa !67
  %conv44 = zext i8 %10 to i32
  %and45 = and i32 %conv44, 16
  %tobool46 = icmp ne i32 %and45, 0
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %mul51 = mul nsw i32 %lnot.ext50, 128
  %arrayidx52 = getelementptr inbounds i8, i8* %data, i64 0
  %11 = load i8, i8* %arrayidx52, align 1, !tbaa !67
  %conv53 = zext i8 %11 to i32
  %and54 = and i32 %conv53, 64
  %tobool55 = icmp ne i32 %and54, 0
  %lnot56 = xor i1 %tobool55, true
  %lnot.ext57 = zext i1 %lnot56 to i32
  %mul58 = mul nsw i32 %lnot.ext57, 127
  %add59 = add nsw i32 %mul51, %mul58
  call void @input_report_abs(%struct.input_dev* %0, i32 1, i32 %add59)
  br label %if.end

if.end:                                           ; preds = %for.cond, %for.end30
  br label %for.cond60

for.cond60:                                       ; preds = %for.body63, %if.end
  %i.2 = phi i32 [ 0, %if.end ], [ %inc73, %for.body63 ]
  %cmp61 = icmp slt i32 %i.2, 8
  br i1 %cmp61, label %for.body63, label %for.end74

for.body63:                                       ; preds = %for.cond60
  %idxprom64 = sext i32 %i.2 to i64
  %arrayidx65 = getelementptr inbounds [12 x i16], [12 x i16]* @gc_psx_btn, i64 0, i64 %idxprom64
  %12 = load i16, i16* %arrayidx65, align 2, !tbaa !66
  %conv66 = sext i16 %12 to i32
  %arrayidx67 = getelementptr inbounds i8, i8* %data, i64 1
  %13 = load i8, i8* %arrayidx67, align 1, !tbaa !67
  %conv68 = zext i8 %13 to i32
  %neg69 = xor i32 %conv68, -1
  %shl70 = shl i32 1, %i.2
  %and71 = and i32 %neg69, %shl70
  call void @input_report_key(%struct.input_dev* %0, i32 %conv66, i32 %and71)
  %inc73 = add nsw i32 %i.2, 1
  br label %for.cond60

for.end74:                                        ; preds = %for.cond60
  %arrayidx75 = getelementptr inbounds i8, i8* %data, i64 0
  %14 = load i8, i8* %arrayidx75, align 1, !tbaa !67
  %conv76 = zext i8 %14 to i32
  %neg77 = xor i32 %conv76, -1
  %and78 = and i32 %neg77, 8
  call void @input_report_key(%struct.input_dev* %0, i32 315, i32 %and78)
  %arrayidx79 = getelementptr inbounds i8, i8* %data, i64 0
  %15 = load i8, i8* %arrayidx79, align 1, !tbaa !67
  %conv80 = zext i8 %15 to i32
  %neg81 = xor i32 %conv80, -1
  %and82 = and i32 %neg81, 1
  call void @input_report_key(%struct.input_dev* %0, i32 314, i32 %and82)
  call void @input_sync(%struct.input_dev* %0)
  br label %sw.epilog

sw.bb83:                                          ; preds = %NodeBlock
  %type84 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %pad, i32 0, i32 1
  %16 = load i32, i32* %type84, align 8, !tbaa !31
  %cmp85 = icmp eq i32 %16, 8
  br i1 %cmp85, label %if.then87, label %if.else103

if.then87:                                        ; preds = %sw.bb83
  br label %for.cond88

for.cond88:                                       ; preds = %for.body91, %if.then87
  %i.3 = phi i32 [ 0, %if.then87 ], [ %inc101, %for.body91 ]
  %cmp89 = icmp slt i32 %i.3, 4
  br i1 %cmp89, label %for.body91, label %if.end138

for.body91:                                       ; preds = %for.cond88
  %idxprom92 = sext i32 %i.3 to i64
  %arrayidx93 = getelementptr inbounds [4 x i16], [4 x i16]* @gc_psx_ddr_btn, i64 0, i64 %idxprom92
  %17 = load i16, i16* %arrayidx93, align 2, !tbaa !66
  %conv94 = sext i16 %17 to i32
  %arrayidx95 = getelementptr inbounds i8, i8* %data, i64 0
  %18 = load i8, i8* %arrayidx95, align 1, !tbaa !67
  %conv96 = zext i8 %18 to i32
  %neg97 = xor i32 %conv96, -1
  %shl98 = shl i32 16, %i.3
  %and99 = and i32 %neg97, %shl98
  call void @input_report_key(%struct.input_dev* %0, i32 %conv94, i32 %and99)
  %inc101 = add nsw i32 %i.3, 1
  br label %for.cond88

if.else103:                                       ; preds = %sw.bb83
  %arrayidx104 = getelementptr inbounds i8, i8* %data, i64 0
  %19 = load i8, i8* %arrayidx104, align 1, !tbaa !67
  %conv105 = zext i8 %19 to i32
  %and106 = and i32 %conv105, 128
  %tobool107 = icmp ne i32 %and106, 0
  %lnot108 = xor i1 %tobool107, true
  %lnot110 = xor i1 %lnot108, true
  %lnot.ext111 = zext i1 %lnot110 to i32
  %mul112 = mul nsw i32 %lnot.ext111, 128
  %arrayidx113 = getelementptr inbounds i8, i8* %data, i64 0
  %20 = load i8, i8* %arrayidx113, align 1, !tbaa !67
  %conv114 = zext i8 %20 to i32
  %and115 = and i32 %conv114, 32
  %tobool116 = icmp ne i32 %and115, 0
  %lnot117 = xor i1 %tobool116, true
  %lnot.ext118 = zext i1 %lnot117 to i32
  %mul119 = mul nsw i32 %lnot.ext118, 127
  %add120 = add nsw i32 %mul112, %mul119
  call void @input_report_abs(%struct.input_dev* %0, i32 0, i32 %add120)
  %arrayidx121 = getelementptr inbounds i8, i8* %data, i64 0
  %21 = load i8, i8* %arrayidx121, align 1, !tbaa !67
  %conv122 = zext i8 %21 to i32
  %and123 = and i32 %conv122, 16
  %tobool124 = icmp ne i32 %and123, 0
  %lnot125 = xor i1 %tobool124, true
  %lnot127 = xor i1 %lnot125, true
  %lnot.ext128 = zext i1 %lnot127 to i32
  %mul129 = mul nsw i32 %lnot.ext128, 128
  %arrayidx130 = getelementptr inbounds i8, i8* %data, i64 0
  %22 = load i8, i8* %arrayidx130, align 1, !tbaa !67
  %conv131 = zext i8 %22 to i32
  %and132 = and i32 %conv131, 64
  %tobool133 = icmp ne i32 %and132, 0
  %lnot134 = xor i1 %tobool133, true
  %lnot.ext135 = zext i1 %lnot134 to i32
  %mul136 = mul nsw i32 %lnot.ext135, 127
  %add137 = add nsw i32 %mul129, %mul136
  call void @input_report_abs(%struct.input_dev* %0, i32 1, i32 %add137)
  br label %if.end138

if.end138:                                        ; preds = %for.cond88, %if.else103
  br label %for.cond139

for.cond139:                                      ; preds = %for.body142, %if.end138
  %i.4 = phi i32 [ 0, %if.end138 ], [ %inc152, %for.body142 ]
  %cmp140 = icmp slt i32 %i.4, 8
  br i1 %cmp140, label %for.body142, label %for.end153

for.body142:                                      ; preds = %for.cond139
  %idxprom143 = sext i32 %i.4 to i64
  %arrayidx144 = getelementptr inbounds [12 x i16], [12 x i16]* @gc_psx_btn, i64 0, i64 %idxprom143
  %23 = load i16, i16* %arrayidx144, align 2, !tbaa !66
  %conv145 = sext i16 %23 to i32
  %arrayidx146 = getelementptr inbounds i8, i8* %data, i64 1
  %24 = load i8, i8* %arrayidx146, align 1, !tbaa !67
  %conv147 = zext i8 %24 to i32
  %neg148 = xor i32 %conv147, -1
  %shl149 = shl i32 1, %i.4
  %and150 = and i32 %neg148, %shl149
  call void @input_report_key(%struct.input_dev* %0, i32 %conv145, i32 %and150)
  %inc152 = add nsw i32 %i.4, 1
  br label %for.cond139

for.end153:                                       ; preds = %for.cond139
  %arrayidx154 = getelementptr inbounds i8, i8* %data, i64 0
  %25 = load i8, i8* %arrayidx154, align 1, !tbaa !67
  %conv155 = zext i8 %25 to i32
  %neg156 = xor i32 %conv155, -1
  %and157 = and i32 %neg156, 8
  call void @input_report_key(%struct.input_dev* %0, i32 315, i32 %and157)
  %arrayidx158 = getelementptr inbounds i8, i8* %data, i64 0
  %26 = load i8, i8* %arrayidx158, align 1, !tbaa !67
  %conv159 = zext i8 %26 to i32
  %neg160 = xor i32 %conv159, -1
  %and161 = and i32 %neg160, 1
  call void @input_report_key(%struct.input_dev* %0, i32 314, i32 %and161)
  call void @input_sync(%struct.input_dev* %0)
  br label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock, %for.end153, %for.end74
  ret void
}

declare void @__udelay(i64) #3

; Function Attrs: nounwind uwtable
define internal void @gc_psx_command(%struct.gc* %gc, i32 %b, i8* %data) #4 {
entry:
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %0 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  %port1 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %0, i32 0, i32 1
  %1 = load %struct.parport*, %struct.parport** %port1, align 8, !tbaa !32
  call void @llvm.memset.p0i8.i64(i8* %data, i8 0, i64 5, i32 1, i1 false)
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc35, %for.end ]
  %b.addr.0 = phi i32 [ %b, %entry ], [ %shr, %for.end ]
  %cmp = icmp slt i32 %i.0, 8
  br i1 %cmp, label %for.body, label %for.end36

for.body:                                         ; preds = %for.cond
  %and = and i32 %b.addr.0, 1
  %tobool = icmp ne i32 %and, 0
  %2 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %ops = getelementptr inbounds %struct.parport, %struct.parport* %1, i32 0, i32 22
  %3 = load %struct.parport_operations*, %struct.parport_operations** %ops, align 8, !tbaa !68
  %write_data = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %3, i32 0, i32 0
  %4 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data, align 8, !tbaa !69
  %or = or i32 %cond, 248
  %conv = trunc i32 %or to i8
  call void %4(%struct.parport* %1, i8 zeroext %conv)
  %5 = load i32, i32* @gc_psx_delay, align 4, !tbaa !15
  %conv2 = sext i32 %5 to i64
  call void @__udelay(i64 %conv2)
  %ops3 = getelementptr inbounds %struct.parport, %struct.parport* %1, i32 0, i32 22
  %6 = load %struct.parport_operations*, %struct.parport_operations** %ops3, align 8, !tbaa !68
  %read_status = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %6, i32 0, i32 5
  %7 = load i8 (%struct.parport*)*, i8 (%struct.parport*)** %read_status, align 8, !tbaa !71
  %call = call zeroext i8 %7(%struct.parport* %1)
  %conv4 = zext i8 %call to i32
  %xor = xor i32 %conv4, 128
  br label %for.cond5

for.cond5:                                        ; preds = %for.inc, %for.body
  %j.0 = phi i32 [ 0, %for.body ], [ %inc, %for.inc ]
  %cmp6 = icmp slt i32 %j.0, 5
  br i1 %cmp6, label %for.body8, label %for.end

for.body8:                                        ; preds = %for.cond5
  %pads = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 1
  %idxprom = sext i32 %j.0 to i64
  %arrayidx = getelementptr inbounds [5 x %struct.gc_pad], [5 x %struct.gc_pad]* %pads, i64 0, i64 %idxprom
  %type = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 1
  %8 = load i32, i32* %type, align 8, !tbaa !31
  %cmp9 = icmp eq i32 %8, 7
  br i1 %cmp9, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body8
  %type11 = getelementptr inbounds %struct.gc_pad, %struct.gc_pad* %arrayidx, i32 0, i32 1
  %9 = load i32, i32* %type11, align 8, !tbaa !31
  %cmp12 = icmp eq i32 %9, 8
  br i1 %cmp12, label %if.then, label %for.inc

if.then:                                          ; preds = %lor.lhs.false, %for.body8
  %idxprom14 = sext i32 %j.0 to i64
  %arrayidx15 = getelementptr inbounds [5 x i32], [5 x i32]* @gc_status_bit, i64 0, i64 %idxprom14
  %10 = load i32, i32* %arrayidx15, align 4, !tbaa !15
  %and16 = and i32 %xor, %10
  %tobool17 = icmp ne i32 %and16, 0
  %shl = shl i32 1, %i.0
  %cond18 = select i1 %tobool17, i32 %shl, i32 0
  %idxprom19 = sext i32 %j.0 to i64
  %arrayidx20 = getelementptr inbounds i8, i8* %data, i64 %idxprom19
  %11 = load i8, i8* %arrayidx20, align 1, !tbaa !67
  %conv21 = zext i8 %11 to i32
  %or22 = or i32 %conv21, %cond18
  %conv23 = trunc i32 %or22 to i8
  store i8 %conv23, i8* %arrayidx20, align 1, !tbaa !67
  br label %for.inc

for.inc:                                          ; preds = %lor.lhs.false, %if.then
  %inc = add nsw i32 %j.0, 1
  br label %for.cond5

for.end:                                          ; preds = %for.cond5
  %pd24 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %12 = load %struct.pardevice*, %struct.pardevice** %pd24, align 8, !tbaa !17
  %port25 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %12, i32 0, i32 1
  %13 = load %struct.parport*, %struct.parport** %port25, align 8, !tbaa !32
  %ops26 = getelementptr inbounds %struct.parport, %struct.parport* %13, i32 0, i32 22
  %14 = load %struct.parport_operations*, %struct.parport_operations** %ops26, align 8, !tbaa !68
  %write_data27 = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %14, i32 0, i32 0
  %15 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_data27, align 8, !tbaa !69
  %pd28 = getelementptr inbounds %struct.gc, %struct.gc* %gc, i32 0, i32 0
  %16 = load %struct.pardevice*, %struct.pardevice** %pd28, align 8, !tbaa !17
  %port29 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %16, i32 0, i32 1
  %17 = load %struct.parport*, %struct.parport** %port29, align 8, !tbaa !32
  %or30 = or i32 %cond, 4
  %or31 = or i32 %or30, 248
  %conv32 = trunc i32 %or31 to i8
  call void %15(%struct.parport* %17, i8 zeroext %conv32)
  %18 = load i32, i32* @gc_psx_delay, align 4, !tbaa !15
  %conv33 = sext i32 %18 to i64
  call void @__udelay(i64 %conv33)
  %inc35 = add nsw i32 %i.0, 1
  %shr = ashr i32 %b.addr.0, 1
  br label %for.cond

for.end36:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

declare %struct.input_dev* @input_allocate_device() #3

declare i32 @snprintf(i8*, i64, i8*, ...) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_set_drvdata(%struct.input_dev* %dev, i8* %data) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %dev, i32 0, i32 39
  %call = call i32 @dev_set_drvdata(%struct.device* %dev1, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @gc_open(%struct.input_dev* %dev) #4 {
entry:
  %call = call i8* @input_get_drvdata(%struct.input_dev* %dev)
  %0 = bitcast i8* %call to %struct.gc*
  %mutex = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 5
  %call1 = call i32 @mutex_lock_interruptible_nested(%struct.mutex* %mutex, i32 0)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %used = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 4
  %1 = load i32, i32* %used, align 8, !tbaa !83
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* %used, align 8, !tbaa !83
  %tobool2 = icmp ne i32 %1, 0
  br i1 %tobool2, label %if.end9, label %if.then3

if.then3:                                         ; preds = %if.end
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 0
  %2 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  %call4 = call i32 @parport_claim(%struct.pardevice* %2)
  %pd5 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 0
  %3 = load %struct.pardevice*, %struct.pardevice** %pd5, align 8, !tbaa !17
  %port = getelementptr inbounds %struct.pardevice, %struct.pardevice* %3, i32 0, i32 1
  %4 = load %struct.parport*, %struct.parport** %port, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.parport, %struct.parport* %4, i32 0, i32 22
  %5 = load %struct.parport_operations*, %struct.parport_operations** %ops, align 8, !tbaa !68
  %write_control = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %5, i32 0, i32 2
  %6 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_control, align 8, !tbaa !84
  %pd6 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 0
  %7 = load %struct.pardevice*, %struct.pardevice** %pd6, align 8, !tbaa !17
  %port7 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %7, i32 0, i32 1
  %8 = load %struct.parport*, %struct.parport** %port7, align 8, !tbaa !32
  call void %6(%struct.parport* %8, i8 zeroext 4)
  %timer = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 2
  %9 = load volatile i64, i64* @jiffies, align 8, !tbaa !30
  %add = add i64 %9, 2
  %call8 = call i32 @mod_timer(%struct.timer_list* %timer, i64 %add)
  br label %if.end9

if.end9:                                          ; preds = %if.then3, %if.end
  %mutex10 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex10)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end9
  %retval.0 = phi i32 [ 0, %if.end9 ], [ %call1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @gc_close(%struct.input_dev* %dev) #4 {
entry:
  %call = call i8* @input_get_drvdata(%struct.input_dev* %dev)
  %0 = bitcast i8* %call to %struct.gc*
  %mutex = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 5
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  %used = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 4
  %1 = load i32, i32* %used, align 8, !tbaa !83
  %dec = add nsw i32 %1, -1
  store i32 %dec, i32* %used, align 8, !tbaa !83
  %tobool = icmp ne i32 %dec, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %timer = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 2
  %call1 = call i32 @del_timer_sync(%struct.timer_list* %timer)
  %pd = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 0
  %2 = load %struct.pardevice*, %struct.pardevice** %pd, align 8, !tbaa !17
  %port = getelementptr inbounds %struct.pardevice, %struct.pardevice* %2, i32 0, i32 1
  %3 = load %struct.parport*, %struct.parport** %port, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.parport, %struct.parport* %3, i32 0, i32 22
  %4 = load %struct.parport_operations*, %struct.parport_operations** %ops, align 8, !tbaa !68
  %write_control = getelementptr inbounds %struct.parport_operations, %struct.parport_operations* %4, i32 0, i32 2
  %5 = load void (%struct.parport*, i8)*, void (%struct.parport*, i8)** %write_control, align 8, !tbaa !84
  %pd2 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 0
  %6 = load %struct.pardevice*, %struct.pardevice** %pd2, align 8, !tbaa !17
  %port3 = getelementptr inbounds %struct.pardevice, %struct.pardevice* %6, i32 0, i32 1
  %7 = load %struct.parport*, %struct.parport** %port3, align 8, !tbaa !32
  call void %5(%struct.parport* %7, i8 zeroext 0)
  %pd4 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 0
  %8 = load %struct.pardevice*, %struct.pardevice** %pd4, align 8, !tbaa !17
  call void @parport_release(%struct.pardevice* %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mutex5 = getelementptr inbounds %struct.gc, %struct.gc* %0, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex5)
  ret void
}

declare void @input_set_abs_params(%struct.input_dev*, i32, i32, i32, i32, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @__set_bit(i32 %nr, i64* %addr) #0 {
entry:
  call void asm sideeffect "bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !85
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @gc_n64_init_ff(%struct.input_dev* %dev, i32 %i) #1 section ".init.text" {
entry:
  %call = call i8* @kmalloc(i64 4, i32 208)
  %0 = bitcast i8* %call to %struct.gc_subdev*
  %tobool = icmp ne %struct.gc_subdev* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %idx = getelementptr inbounds %struct.gc_subdev, %struct.gc_subdev* %0, i32 0, i32 0
  store i32 %i, i32* %idx, align 4, !tbaa !86
  call void @input_set_capability(%struct.input_dev* %dev, i32 21, i32 80)
  %1 = bitcast %struct.gc_subdev* %0 to i8*
  %call1 = call i32 @input_ff_create_memless(%struct.input_dev* %dev, i8* %1, i32 (%struct.input_dev*, i8*, %struct.ff_effect*)* @gc_n64_play_effect)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %cleanup

if.then3:                                         ; preds = %if.end
  %2 = bitcast %struct.gc_subdev* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.then3
  %retval.0 = phi i32 [ %call1, %if.then3 ], [ -12, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare i32 @input_register_device(%struct.input_dev*) #3

declare void @input_free_device(%struct.input_dev*) #3

declare i32 @dev_set_drvdata(%struct.device*, i8*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @input_get_drvdata(%struct.input_dev* %dev) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %dev, i32 0, i32 39
  %call = call i8* @dev_get_drvdata(%struct.device* %dev1)
  ret i8* %call
}

declare i32 @mutex_lock_interruptible_nested(%struct.mutex*, i32) #3

declare i32 @parport_claim(%struct.pardevice*) #3

declare void @mutex_unlock(%struct.mutex*) #3

declare i8* @dev_get_drvdata(%struct.device*) #3

declare void @mutex_lock_nested(%struct.mutex*, i32) #3

declare i32 @del_timer_sync(%struct.timer_list*) #3

declare void @parport_release(%struct.pardevice*) #3

declare void @input_set_capability(%struct.input_dev*, i32, i32) #3

declare i32 @input_ff_create_memless(%struct.input_dev*, i8*, i32 (%struct.input_dev*, i8*, %struct.ff_effect*)*) #3

; Function Attrs: nounwind uwtable
define internal i32 @gc_n64_play_effect(%struct.input_dev* %dev, i8* %data, %struct.ff_effect* %effect) #4 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy25 = alloca i64, align 8
  %__dummy226 = alloca i64, align 8
  %__dummy35 = alloca i64, align 8
  %__dummy236 = alloca i64, align 8
  %__dummy43 = alloca i64, align 8
  %__dummy244 = alloca i64, align 8
  %call = call i8* @input_get_drvdata(%struct.input_dev* %dev)
  %0 = bitcast i8* %call to %struct.gc*
  %1 = bitcast i8* %data to %struct.gc_subdev*
  %idx = getelementptr inbounds %struct.gc_subdev, %struct.gc_subdev* %1, i32 0, i32 0
  %2 = load i32, i32* %idx, align 4, !tbaa !86
  %shl = shl i32 1, %2
  %conv = trunc i32 %shl to i8
  %type = getelementptr inbounds %struct.ff_effect, %struct.ff_effect* %effect, i32 0, i32 0
  %3 = load i16, i16* %type, align 8, !tbaa !88
  %conv1 = zext i16 %3 to i32
  %cmp = icmp eq i32 %conv1, 80
  br i1 %cmp, label %if.then, label %if.end52

if.then:                                          ; preds = %entry
  %u = getelementptr inbounds %struct.ff_effect, %struct.ff_effect* %effect, i32 0, i32 5
  %rumble3 = bitcast %union.anon.15* %u to %struct.ff_rumble_effect*
  %strong_magnitude = getelementptr inbounds %struct.ff_rumble_effect, %struct.ff_rumble_effect* %rumble3, i32 0, i32 0
  %4 = load i16, i16* %strong_magnitude, align 2, !tbaa !92
  %conv4 = zext i16 %4 to i32
  %tobool = icmp ne i32 %conv4, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then
  %weak_magnitude = getelementptr inbounds %struct.ff_rumble_effect, %struct.ff_rumble_effect* %rumble3, i32 0, i32 1
  %5 = load i16, i16* %weak_magnitude, align 2, !tbaa !94
  %conv5 = zext i16 %5 to i32
  %tobool6 = icmp ne i32 %conv5, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then
  %6 = phi i1 [ true, %if.then ], [ %tobool6, %lor.rhs ]
  %7 = zext i1 %6 to i64
  %cond = select i1 %6, i64 3507556625, i64 286331153
  %conv7 = trunc i64 %cond to i32
  %8 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #7
  %9 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #7
  %cmp9 = icmp eq i64* %__dummy, %__dummy2
  %conv10 = zext i1 %cmp9 to i32
  %10 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #7
  %11 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #7
  %call11 = call i64 @arch_local_irq_save()
  call void @trace_hardirqs_off()
  call void @gc_n64_send_command(%struct.gc* %0, i64 3708883217, i8 zeroext %conv)
  call void @gc_n64_send_command(%struct.gc* %0, i64 286331165, i8 zeroext %conv)
  call void @gc_n64_send_command(%struct.gc* %0, i64 3507556625, i8 zeroext %conv)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %lor.end
  %i.0 = phi i32 [ 0, %lor.end ], [ %inc, %for.body ]
  %cmp14 = icmp slt i32 %i.0, 32
  br i1 %cmp14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @gc_n64_send_command(%struct.gc* %0, i64 286331165, i8 zeroext %conv)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @gc_n64_send_stop_bit(%struct.gc* %0, i8 zeroext %conv)
  call void @__const_udelay(i64 571235)
  call void @gc_n64_send_command(%struct.gc* %0, i64 3708883217, i8 zeroext %conv)
  call void @gc_n64_send_command(%struct.gc* %0, i64 286331357, i8 zeroext %conv)
  call void @gc_n64_send_command(%struct.gc* %0, i64 3709718801, i8 zeroext %conv)
  br label %for.cond16

for.cond16:                                       ; preds = %for.body19, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc22, %for.body19 ]
  %cmp17 = icmp slt i32 %i.1, 32
  br i1 %cmp17, label %for.body19, label %for.end23

for.body19:                                       ; preds = %for.cond16
  %conv20 = zext i32 %conv7 to i64
  call void @gc_n64_send_command(%struct.gc* %0, i64 %conv20, i8 zeroext %conv)
  %inc22 = add nsw i32 %i.1, 1
  br label %for.cond16

for.end23:                                        ; preds = %for.cond16
  call void @gc_n64_send_stop_bit(%struct.gc* %0, i8 zeroext %conv)
  %12 = bitcast i64* %__dummy25 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %12) #7
  %13 = bitcast i64* %__dummy226 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %13) #7
  %cmp27 = icmp eq i64* %__dummy25, %__dummy226
  %conv28 = zext i1 %cmp27 to i32
  %14 = bitcast i64* %__dummy226 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #7
  %15 = bitcast i64* %__dummy25 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #7
  %call31 = call i32 @arch_irqs_disabled_flags(i64 %call11)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %do.body34, label %if.else

do.body34:                                        ; preds = %for.end23
  %16 = bitcast i64* %__dummy35 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #7
  %17 = bitcast i64* %__dummy236 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %17) #7
  %cmp37 = icmp eq i64* %__dummy35, %__dummy236
  %conv38 = zext i1 %cmp37 to i32
  %18 = bitcast i64* %__dummy236 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #7
  %19 = bitcast i64* %__dummy35 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %19) #7
  call void @arch_local_irq_restore(i64 %call11)
  call void @trace_hardirqs_off()
  br label %if.end52

if.else:                                          ; preds = %for.end23
  call void @trace_hardirqs_on()
  %20 = bitcast i64* %__dummy43 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %20) #7
  %21 = bitcast i64* %__dummy244 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %21) #7
  %cmp45 = icmp eq i64* %__dummy43, %__dummy244
  %conv46 = zext i1 %cmp45 to i32
  %22 = bitcast i64* %__dummy244 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %22) #7
  %23 = bitcast i64* %__dummy43 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #7
  call void @arch_local_irq_restore(i64 %call11)
  br label %if.end52

if.end52:                                         ; preds = %do.body34, %if.else, %entry
  ret i32 0
}

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readnone }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !14, i64 24}
!13 = !{!"gc_config", !5, i64 0, !14, i64 24}
!14 = !{!"int", !5, i64 0}
!15 = !{!14, !14, i64 0}
!16 = !{!4, !4, i64 0}
!17 = !{!18, !4, i64 0}
!18 = !{!"gc", !4, i64 0, !5, i64 8, !19, i64 248, !5, i64 376, !14, i64 416, !23, i64 424}
!19 = !{!"timer_list", !20, i64 0, !21, i64 16, !4, i64 24, !4, i64 32, !21, i64 40, !14, i64 48, !14, i64 52, !4, i64 56, !5, i64 64, !22, i64 80}
!20 = !{!"list_head", !4, i64 0, !4, i64 8}
!21 = !{!"long", !5, i64 0}
!22 = !{!"lockdep_map", !4, i64 0, !5, i64 8, !4, i64 24, !14, i64 32, !21, i64 40}
!23 = !{!"mutex", !24, i64 0, !25, i64 8, !20, i64 80, !4, i64 96, !4, i64 104, !4, i64 112, !22, i64 120}
!24 = !{!"", !14, i64 0}
!25 = !{!"spinlock", !5, i64 0}
!26 = !{!19, !4, i64 32}
!27 = !{!19, !21, i64 40}
!28 = !{!29, !4, i64 0}
!29 = !{!"gc_pad", !4, i64 0, !5, i64 8, !5, i64 12}
!30 = !{!21, !21, i64 0}
!31 = !{!29, !5, i64 8}
!32 = !{!33, !4, i64 8}
!33 = !{!"pardevice", !4, i64 0, !4, i64 8, !14, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !14, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !34, i64 88, !21, i64 176, !21, i64 184, !21, i64 192, !21, i64 200, !4, i64 208, !4, i64 216, !4, i64 224}
!34 = !{!"__wait_queue_head", !25, i64 0, !20, i64 72}
!35 = !{!36, !4, i64 24}
!36 = !{!"parport", !21, i64 0, !21, i64 8, !14, i64 16, !4, i64 24, !14, i64 32, !14, i64 36, !14, i64 40, !14, i64 44, !14, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !14, i64 88, !14, i64 92, !4, i64 96, !4, i64 104, !20, i64 112, !14, i64 128, !4, i64 136, !5, i64 144, !37, i64 384, !4, i64 488, !4, i64 496, !14, i64 504, !25, i64 512, !25, i64 584, !41, i64 656, !14, i64 728, !24, i64 732, !21, i64 736, !4, i64 744, !20, i64 752, !5, i64 768}
!37 = !{!"ieee1284_info", !14, i64 0, !5, i64 4, !38, i64 8}
!38 = !{!"semaphore", !39, i64 0, !14, i64 72, !20, i64 80}
!39 = !{!"raw_spinlock", !40, i64 0, !14, i64 4, !14, i64 8, !4, i64 16, !22, i64 24}
!40 = !{!"arch_spinlock", !5, i64 0}
!41 = !{!"", !5, i64 0, !14, i64 8, !14, i64 12, !4, i64 16, !22, i64 24}
!42 = !{!43, !4, i64 0}
!43 = !{!"input_dev", !4, i64 0, !4, i64 8, !4, i64 16, !44, i64 24, !5, i64 32, !5, i64 40, !5, i64 48, !5, i64 144, !5, i64 152, !5, i64 160, !5, i64 168, !5, i64 176, !5, i64 184, !5, i64 200, !14, i64 208, !14, i64 212, !14, i64 216, !4, i64 224, !4, i64 232, !4, i64 240, !4, i64 248, !14, i64 256, !19, i64 264, !5, i64 392, !4, i64 400, !4, i64 408, !5, i64 416, !5, i64 512, !5, i64 520, !5, i64 528, !4, i64 536, !4, i64 544, !4, i64 552, !4, i64 560, !4, i64 568, !25, i64 576, !23, i64 648, !14, i64 816, !46, i64 820, !47, i64 824, !20, i64 1960, !20, i64 1976, !14, i64 1992, !14, i64 1996, !4, i64 2000, !46, i64 2008}
!44 = !{!"input_id", !45, i64 0, !45, i64 2, !45, i64 4, !45, i64 6}
!45 = !{!"short", !5, i64 0}
!46 = !{!"_Bool", !5, i64 0}
!47 = !{!"device", !4, i64 0, !4, i64 8, !48, i64 16, !4, i64 80, !4, i64 88, !23, i64 96, !4, i64 264, !4, i64 272, !4, i64 280, !50, i64 288, !4, i64 880, !14, i64 888, !4, i64 896, !55, i64 904, !4, i64 912, !20, i64 920, !4, i64 936, !56, i64 944, !4, i64 960, !57, i64 968, !14, i64 976, !14, i64 980, !25, i64 984, !20, i64 1056, !58, i64 1072, !4, i64 1104, !4, i64 1112, !4, i64 1120, !4, i64 1128}
!48 = !{!"kobject", !4, i64 0, !20, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !49, i64 56, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60}
!49 = !{!"kref", !24, i64 0}
!50 = !{!"dev_pm_info", !51, i64 0, !14, i64 4, !14, i64 4, !46, i64 4, !46, i64 4, !46, i64 4, !46, i64 4, !25, i64 8, !20, i64 80, !52, i64 96, !4, i64 192, !46, i64 200, !46, i64 200, !19, i64 208, !21, i64 336, !53, i64 344, !34, i64 424, !24, i64 512, !24, i64 516, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 521, !14, i64 521, !14, i64 521, !14, i64 521, !14, i64 521, !5, i64 524, !5, i64 528, !14, i64 532, !14, i64 536, !21, i64 544, !21, i64 552, !21, i64 560, !21, i64 568, !4, i64 576, !4, i64 584}
!51 = !{!"pm_message", !14, i64 0}
!52 = !{!"completion", !14, i64 0, !34, i64 8}
!53 = !{!"work_struct", !54, i64 0, !20, i64 8, !4, i64 24, !22, i64 32}
!54 = !{!"", !21, i64 0}
!55 = !{!"long long", !5, i64 0}
!56 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!57 = !{!"acpi_dev_node", !4, i64 0}
!58 = !{!"klist_node", !4, i64 0, !20, i64 8, !49, i64 24}
!59 = !{!43, !4, i64 8}
!60 = !{!43, !45, i64 24}
!61 = !{!43, !45, i64 26}
!62 = !{!43, !45, i64 28}
!63 = !{!43, !45, i64 30}
!64 = !{!43, !4, i64 536}
!65 = !{!43, !4, i64 544}
!66 = !{!45, !45, i64 0}
!67 = !{!5, !5, i64 0}
!68 = !{!36, !4, i64 488}
!69 = !{!70, !4, i64 0}
!70 = !{!"parport_operations", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184}
!71 = !{!70, !4, i64 40}
!72 = !{!73, !4, i64 8}
!73 = !{!"pv_irq_ops", !74, i64 0, !74, i64 8, !74, i64 16, !74, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!74 = !{!"paravirt_callee_save", !4, i64 0}
!75 = !{i32 -2146262489, i32 -2146262464, i32 -2146262194, i32 -2146262397, i32 -2146262366, i32 -2146262336}
!76 = !{i32 -2146262953, i32 -2146261942, i32 -2146261920, i32 -2146261907, i32 -2146261584, i32 -2146261517, i32 -2146261815, i32 -2146261788, i32 -2146261760, i32 -2146261730}
!77 = !{!73, !4, i64 0}
!78 = !{i32 -2146266066, i32 -2146266041, i32 -2146265771, i32 -2146265974, i32 -2146265943, i32 -2146265913}
!79 = !{i32 -2146266486, i32 -2146264508, i32 -2146264486, i32 -2146264473, i32 -2146264150, i32 -2146264083, i32 -2146264381, i32 -2146264354, i32 -2146264326, i32 -2146264296}
!80 = !{!73, !4, i64 16}
!81 = !{i32 -2146259938, i32 -2146259913, i32 -2146259643, i32 -2146259846, i32 -2146259815, i32 -2146259785}
!82 = !{i32 -2146260386, i32 -2146259391, i32 -2146259369, i32 -2146259356, i32 -2146259033, i32 -2146258966, i32 -2146259264, i32 -2146259237, i32 -2146259209, i32 -2146259179}
!83 = !{!18, !14, i64 416}
!84 = !{!70, !4, i64 16}
!85 = !{i32 339145}
!86 = !{!87, !14, i64 0}
!87 = !{!"gc_subdev", !14, i64 0}
!88 = !{!89, !45, i64 0}
!89 = !{!"ff_effect", !45, i64 0, !45, i64 2, !45, i64 4, !90, i64 6, !91, i64 10, !5, i64 16}
!90 = !{!"ff_trigger", !45, i64 0, !45, i64 2}
!91 = !{!"ff_replay", !45, i64 0, !45, i64 2}
!92 = !{!93, !45, i64 0}
!93 = !{!"ff_rumble_effect", !45, i64 0, !45, i64 2}
!94 = !{!93, !45, i64 2}
