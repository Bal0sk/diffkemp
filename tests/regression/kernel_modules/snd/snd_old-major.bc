; ModuleID = 'tests/regression/kernel_modules/snd/snd_old-major.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_symbol = type { i64, i8* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.46 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.46 = type { i8* }
%struct.mutex = type { %union.anon.1, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%union.anon.1 = type { i32 }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.arch_spinlock = type { %union.anon.1 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.task_struct = type { i64, i8*, %union.anon.1, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, %struct.load_weight, %struct.load_weight, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %union.anon.39, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %union.anon.1, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %union.anon.1, %union.anon.1, i64, i64, %struct.memcg_batch_info, i32, %union.anon.1, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgprot*, %union.anon.1, %union.anon.1, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.mm_rss_stat = type { [3 x %struct.pgprot] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %union.anon.1, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file = type { %union.anon.39, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.pgprot, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %union.anon.1, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.39, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %struct.pgprot, i8* }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %union.anon.1, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.pgprot, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.load_weight*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.arch_spinlock, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.arch_spinlock, void ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %union.anon.1, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.1, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.pgprot }
%struct.shrink_control = type { i32, i64 }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.1, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.36, i64, %union.anon.1, %union.anon.1, %union.anon.1, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.38, i32, i32, %struct.hlist_head, %union.anon.1, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.load_weight*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.36 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.pid = type { %union.anon.1, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type { i8*, i64 }
%struct.read_descriptor_t = type { i64, i64, %union.anon.46, i32 }
%struct.swap_info_struct = type opaque
%union.anon.38 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %struct.pgprot, i32, i32, i8*, %struct.lockdep_map }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.3, %union.anon.39, %struct.pgprot, i64 }
%struct.anon.3 = type { %struct.pgprot, %struct.pgprot }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %union.anon.1, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.load_weight = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %union.anon.1, %union.anon.1, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %union.anon.1, i32, %union.anon.14, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %struct.pgprot, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.39, %struct.pgprot }
%union.anon.14 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%struct.user_struct = type { %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %struct.pgprot, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.pgprot }
%struct.user_namespace = type opaque
%struct.group_info = type { %union.anon.1, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.18 }
%union.anon.18 = type { %struct.exception_table_entry }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.21, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.24 }
%union.anon.21 = type { %struct.load_weight }
%union.anon.24 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %union.anon.1, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net* }
%struct.uts_namespace = type { %struct.arch_spinlock, %struct.new_utsname, %struct.user_namespace*, i32 }
%struct.new_utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.signal_struct = type { %union.anon.1, %union.anon.1, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %struct.pgprot, [2 x %struct.if_dqinfo], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.load_weight], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %struct.pgprot, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %struct.pgprot }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %struct.pgprot, i64 ()*, %struct.pgprot, %struct.pgprot }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %struct.pgprot, i32, i32, i64, i64, i64, %struct.pgprot, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %union.anon.1, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%union.anon.39 = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.26 }
%union.anon.26 = type { %struct.anon.30, [80 x i8] }
%struct.anon.30 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %union.anon.1, i32, i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.load_weight, %struct.load_weight, i64, i64, i32, i32, %struct.load_weight, %struct.load_weight, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.snd_minor = type { i32, i32, i32, %struct.file_operations*, i8*, %struct.device*, %struct.snd_card* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.shrink_control*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %union.anon.46, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %union.anon.1, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %union.anon.1, %union.anon.1, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.work_struct = type { %struct.pgprot, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i8*, i64, %struct.sigset_t*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.sigset_t*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.sigset_t*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_node = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.arch_spinlock }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.snd_card = type { i32, [16 x i8], [16 x i8], [32 x i8], [80 x i8], [80 x i8], [128 x i8], %struct.module*, i8*, void (%struct.snd_card*)*, %struct.list_head, i32, %struct.rw_semaphore, %struct.rwlock_t, i32, i32, %struct.list_head, %struct.list_head, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.proc_dir_entry*, %struct.list_head, %struct.snd_shutdown_f_ops*, %struct.spinlock, i32, i32, %struct.__wait_queue_head, %union.anon.1, %struct.device*, %struct.device*, i32, %struct.mutex, %struct.__wait_queue_head, %struct.snd_mixer_oss*, i32 }
%struct.snd_info_entry = type { i8*, i16, i64, i16, %union.anon.47, %struct.snd_info_entry*, %struct.snd_card*, %struct.module*, i8*, void (%struct.snd_info_entry*)*, %struct.proc_dir_entry*, %struct.mutex, %struct.list_head, %struct.list_head }
%union.anon.47 = type { %struct.snd_info_entry_text }
%struct.snd_info_entry_text = type { void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* }
%struct.snd_info_buffer = type { i8*, i32, i32, i32, i32, i32 }
%struct.proc_dir_entry = type opaque
%struct.snd_shutdown_f_ops = type opaque
%struct.snd_mixer_oss = type opaque
%struct.kparam_array = type { i32, i32, i32*, %struct.kernel_param_ops*, i8* }
%struct.snd_device_ops = type { i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)* }
%struct.snd_device = type { %struct.list_head, %struct.snd_card*, i32, i32, i8*, %struct.snd_device_ops* }
%struct.snd_kcontrol_new = type { i32, i32, i32, i8*, i32, i32, i32, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, %union.anon.58, i64 }
%struct.snd_kcontrol = type { %struct.list_head, %struct.snd_ctl_elem_id, i32, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, %union.anon.58, i64, i8*, void (%struct.snd_kcontrol*)*, [0 x %struct.snd_kcontrol_volatile] }
%struct.snd_ctl_elem_id = type { i32, i32, i32, i32, [44 x i8], i32 }
%struct.snd_kcontrol_volatile = type { %struct.snd_ctl_file*, i32 }
%struct.snd_ctl_file = type { %struct.list_head, %struct.snd_card*, %struct.pid*, i32, i32, %struct.__wait_queue_head, %struct.spinlock, %struct.fasync_struct*, i32, %struct.list_head }
%struct.snd_ctl_elem_info = type { %struct.snd_ctl_elem_id, i32, i32, i32, i32, %union.anon.48, %union.anon.52, [56 x i8] }
%union.anon.48 = type { %struct.anon.51, [40 x i8] }
%struct.anon.51 = type { i32, i32, [64 x i8], i64, i32 }
%union.anon.52 = type { i16* }
%struct.snd_ctl_elem_value = type { %struct.snd_ctl_elem_id, i8, %union.anon.53, %struct.load_weight, [112 x i8] }
%union.anon.53 = type { %union.anon.54 }
%union.anon.54 = type { [128 x i64] }
%union.anon.58 = type { i32 (%struct.snd_kcontrol*, i32, i32, i32*)* }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.snd_monitor_file = type { %struct.file*, %struct.file_operations*, %struct.list_head, %struct.list_head }
%struct.snd_info_private_data = type { %struct.snd_info_buffer*, %struct.snd_info_buffer*, %struct.snd_info_entry*, i8* }
%struct.snd_info_entry_ops = type { i32 (%struct.snd_info_entry*, i16, i8**)*, i32 (%struct.snd_info_entry*, i16, i8*)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)*, i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)* }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.snd_kctl_ioctl = type { %struct.list_head, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* }
%struct.snd_kctl_event = type { %struct.list_head, %struct.snd_ctl_elem_id, i32 }
%struct.snd_ctl_event = type { i32, %union.anon.60 }
%union.anon.60 = type { %struct.anon.61 }
%struct.anon.61 = type { i32, %struct.snd_ctl_elem_id }
%struct.snd_ctl_elem_list = type { i32, i32, i32, i32, %struct.snd_ctl_elem_id*, [50 x i8] }
%struct.snd_ctl_tlv = type { i32, i32, [0 x i32] }
%struct.snd_ctl_elem_list32 = type { i32, i32, i32, i32, i32, [50 x i8] }
%struct.snd_ctl_elem_info32 = type { %struct.snd_ctl_elem_id, i32, i32, i32, i32, %union.anon.48, [64 x i8] }
%struct.snd_ctl_elem_value32 = type { %struct.snd_ctl_elem_id, i32, %union.anon.70, [128 x i8] }
%union.anon.70 = type { [128 x i32] }
%struct.anon.67 = type { i32, i32, i32 }
%struct.user_element = type { %struct.snd_ctl_elem_info, i8*, i64, i8*, i64, i8* }
%union.anon.57 = type { i8*, [504 x i8] }
%struct.snd_ctl_card_info = type { i32, i32, [16 x i8], [16 x i8], [32 x i8], [80 x i8], [16 x i8], [80 x i8], [128 x i8] }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.pgprot, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.map_segment = type opaque
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.62 }
%union.anon.62 = type { %struct.anon.63 }
%struct.anon.63 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, [6 x i8], %struct.pci_driver*, i64, %struct.shrink_control, i32, i8, i16, i8, i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, [3 x i8], i16, [2 x i8], %union.anon.1, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], %struct.list_head, %struct.kset*, %struct.pci_vpd*, %union.anon.35, %struct.pci_ats*, i64, i64 }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.__wait_queue_head }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)* }
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.35 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_ats = type opaque
%struct.snd_pci_quirk = type { i16, i16, i16, i32, i8* }
%struct.va_format = type { i8*, [1 x %struct.__va_list_tag]* }
%struct.link_master = type { %struct.list_head, %struct.link_ctl_info, i32, [4 x i32], void (i8*, i32)*, i8* }
%struct.link_ctl_info = type { i32, i32, i32, i32 }
%struct.link_slave = type { %struct.list_head, %struct.link_master*, %struct.link_ctl_info, [2 x i32], i32, %struct.snd_kcontrol*, %struct.snd_kcontrol }
%struct.snd_jack = type { %struct.input_dev*, i32, i32, i8*, [100 x i8], [6 x i32], i8*, void (%struct.snd_jack*)* }
%struct.input_dev = type { i8*, i8*, i8*, %struct.input_id, [1 x i64], [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i32, i32, i32, i8*, i32 (%struct.input_dev*, %struct.input_keymap_entry*, i32*)*, i32 (%struct.input_dev*, %struct.input_keymap_entry*)*, %struct.ff_device*, i32, %struct.timer_list, [2 x i32], %struct.input_mt*, %struct.input_absinfo*, [12 x i64], [1 x i64], [1 x i64], [1 x i64], i32 (%struct.input_dev*)*, void (%struct.input_dev*)*, i32 (%struct.input_dev*, %struct.file*)*, i32 (%struct.input_dev*, i32, i32, i32)*, %struct.input_handle*, %struct.spinlock, %struct.mutex, i32, i8, %struct.device, %struct.list_head, %struct.list_head, i32, i32, %struct.input_value*, i8 }
%struct.input_id = type { i16, i16, i16, i16 }
%struct.input_keymap_entry = type { i8, i8, i16, i32, [32 x i8] }
%struct.ff_device = type { i32 (%struct.input_dev*, %struct.ff_effect*, %struct.ff_effect*)*, i32 (%struct.input_dev*, i32)*, i32 (%struct.input_dev*, i32, i32)*, void (%struct.input_dev*, i16)*, void (%struct.input_dev*, i16)*, void (%struct.ff_device*)*, i8*, [2 x i64], %struct.mutex, i32, %struct.ff_effect*, [0 x %struct.file*] }
%struct.ff_effect = type { i16, i16, i16, %struct.ff_trigger, %struct.ff_trigger, %union.anon.47.2337 }
%struct.ff_trigger = type { i16, i16 }
%union.anon.47.2337 = type { %struct.ff_periodic_effect }
%struct.ff_periodic_effect = type { i16, i16, i16, i16, i16, %struct.input_id, i32, i16* }
%struct.input_mt = type opaque
%struct.input_absinfo = type { i32, i32, i32, i32, i32, i32 }
%struct.input_handle = type { i8*, i32, i8*, %struct.input_dev*, %struct.input_handler*, %struct.list_head, %struct.list_head }
%struct.input_handler = type { i8*, void (%struct.input_handle*, i32, i32, i32)*, void (%struct.input_handle*, %struct.input_value*, i32)*, i1 (%struct.input_handle*, i32, i32, i32)*, i1 (%struct.input_handler*, %struct.input_dev*)*, i32 (%struct.input_handler*, %struct.input_dev*, %struct.input_device_id*)*, void (%struct.input_handle*)*, void (%struct.input_handle*)*, i8, i32, i8*, %struct.input_device_id*, %struct.list_head, %struct.list_head }
%struct.input_device_id = type { i64, i16, i16, i16, i16, [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i64 }
%struct.input_value = type { i16, i16, i32 }

@snd_major = common global i32 0, align 4
@snd_ecards_limit = common global i32 0, align 4
@llvm.used = appending global [165 x i8*] [i8* bitcast (i64* @__kcrctab_snd_major to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_major to i8*), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__UNIQUE_ID_author41, i32 0, i32 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @__UNIQUE_ID_description42, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license43, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_major to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_majortype44, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__UNIQUE_ID_major45, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_cards_limit to i8*), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__UNIQUE_ID_cards_limittype46, i32 0, i32 0), i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__UNIQUE_ID_cards_limit47, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__UNIQUE_ID_alias48, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_snd_ecards_limit to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ecards_limit to i8*), i8* bitcast (i64* @__kcrctab_snd_request_card to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_request_card to i8*), i8* bitcast (i64* @__kcrctab_snd_lookup_minor_data to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_lookup_minor_data to i8*), i8* bitcast (i64* @__kcrctab_snd_register_device_for_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_register_device_for_dev to i8*), i8* bitcast (i64* @__kcrctab_snd_unregister_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_unregister_device to i8*), i8* bitcast (i64* @__kcrctab_snd_add_device_sysfs_file to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_add_device_sysfs_file to i8*), i8* bitcast (i64* @__kcrctab_snd_cards to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_cards to i8*), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_slots to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_slotstype56, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @__UNIQUE_ID_slots57, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_snd_mixer_oss_notify_callback to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_mixer_oss_notify_callback to i8*), i8* bitcast (i64* @__kcrctab_snd_card_create to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_create to i8*), i8* bitcast (i64* @__kcrctab_snd_card_disconnect to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_disconnect to i8*), i8* bitcast (i64* @__kcrctab_snd_card_unref to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_unref to i8*), i8* bitcast (i64* @__kcrctab_snd_card_free_when_closed to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_free_when_closed to i8*), i8* bitcast (i64* @__kcrctab_snd_card_free to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_free to i8*), i8* bitcast (i64* @__kcrctab_snd_card_set_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_set_id to i8*), i8* bitcast (i64* @__kcrctab_snd_card_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_register to i8*), i8* bitcast (i64* @__kcrctab_snd_component_add to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_component_add to i8*), i8* bitcast (i64* @__kcrctab_snd_card_file_add to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_file_add to i8*), i8* bitcast (i64* @__kcrctab_snd_card_file_remove to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_file_remove to i8*), i8* bitcast (i64* @__kcrctab_snd_power_wait to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_power_wait to i8*), i8* bitcast (i64* @__kcrctab_copy_to_user_fromio to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_copy_to_user_fromio to i8*), i8* bitcast (i64* @__kcrctab_copy_from_user_toio to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_copy_from_user_toio to i8*), i8* bitcast (i64* @__kcrctab_snd_iprintf to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_iprintf to i8*), i8* bitcast (i64* @__kcrctab_snd_seq_root to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_seq_root to i8*), i8* bitcast (i64* @__kcrctab_snd_info_get_line to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_get_line to i8*), i8* bitcast (i64* @__kcrctab_snd_info_get_str to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_get_str to i8*), i8* bitcast (i64* @__kcrctab_snd_info_create_module_entry to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_create_module_entry to i8*), i8* bitcast (i64* @__kcrctab_snd_info_create_card_entry to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_create_card_entry to i8*), i8* bitcast (i64* @__kcrctab_snd_card_proc_new to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_proc_new to i8*), i8* bitcast (i64* @__kcrctab_snd_info_free_entry to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_free_entry to i8*), i8* bitcast (i64* @__kcrctab_snd_info_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_register to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_notify to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_notify to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_new1 to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_new1 to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_free_one to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_free_one to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_add to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_add to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_replace to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_replace to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_remove to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_remove to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_remove_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_remove_id to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_activate_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_activate_id to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_rename_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_rename_id to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_find_numid to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_find_numid to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_find_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_find_id to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_register_ioctl to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_register_ioctl to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_register_ioctl_compat to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_register_ioctl_compat to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_unregister_ioctl to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_unregister_ioctl to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_unregister_ioctl_compat to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_unregister_ioctl_compat to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_boolean_mono_info to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_boolean_mono_info to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_boolean_stereo_info to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_boolean_stereo_info to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_enum_info to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_enum_info to i8*), i8* bitcast (%struct.kernel_param* @__param_debug to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_debugtype39, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__UNIQUE_ID_debug40, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_release_and_free_resource to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_release_and_free_resource to i8*), i8* bitcast (i64* @__kcrctab___snd_printk to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab___snd_printk to i8*), i8* bitcast (i64* @__kcrctab_snd_pci_quirk_lookup_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_pci_quirk_lookup_id to i8*), i8* bitcast (i64* @__kcrctab_snd_pci_quirk_lookup to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_pci_quirk_lookup to i8*), i8* bitcast (i64* @__kcrctab_snd_device_new to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_device_new to i8*), i8* bitcast (i64* @__kcrctab_snd_device_free to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_device_free to i8*), i8* bitcast (i64* @__kcrctab_snd_device_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_device_register to i8*), i8* bitcast (i64* @__kcrctab_snd_dma_program to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_dma_program to i8*), i8* bitcast (i64* @__kcrctab_snd_dma_disable to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_dma_disable to i8*), i8* bitcast (i64* @__kcrctab_snd_dma_pointer to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_dma_pointer to i8*), i8* bitcast (i64* @__kcrctab_snd_lookup_oss_minor_data to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_lookup_oss_minor_data to i8*), i8* bitcast (i64* @__kcrctab_snd_register_oss_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_register_oss_device to i8*), i8* bitcast (i64* @__kcrctab_snd_unregister_oss_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_unregister_oss_device to i8*), i8* bitcast (i64* @__kcrctab_snd_oss_info_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_oss_info_register to i8*), i8* bitcast (i64* @__kcrctab__snd_ctl_add_slave to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab__snd_ctl_add_slave to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_make_virtual_master to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_make_virtual_master to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_add_vmaster_hook to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_add_vmaster_hook to i8*), i8* bitcast (i64* @__kcrctab_snd_ctl_sync_vmaster_hook to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_sync_vmaster_hook to i8*), i8* bitcast (i64* @__kcrctab_snd_kctl_jack_new to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_kctl_jack_new to i8*), i8* bitcast (i64* @__kcrctab_snd_kctl_jack_report to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_kctl_jack_report to i8*), i8* bitcast (i64* @__kcrctab_snd_jack_new to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_jack_new to i8*), i8* bitcast (i64* @__kcrctab_snd_jack_set_parent to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_jack_set_parent to i8*), i8* bitcast (i64* @__kcrctab_snd_jack_set_key to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_jack_set_key to i8*), i8* bitcast (i64* @__kcrctab_snd_jack_report to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_jack_report to i8*), i8* getelementptr inbounds ([56 x i8], [56 x i8]* @__UNIQUE_ID_author245, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @__UNIQUE_ID_description246, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license247, i32 0, i32 0)], section "llvm.metadata"
@__kcrctab_snd_major = internal constant i64 ptrtoint (i8** @__crc_snd_major to i64), section "___kcrctab+snd_major", align 8
@__ksymtab_snd_major = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @snd_major to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_snd_major, i32 0, i32 0) }, section "___ksymtab+snd_major", align 8
@__UNIQUE_ID_author41 = internal constant [40 x i8] c"author=Jaroslav Kysela <perex@perex.cz>\00", section ".modinfo", align 1
@__UNIQUE_ID_description42 = internal constant [69 x i8] c"description=Advanced Linux Sound Architecture driver for soundcards.\00", section ".modinfo", align 1
@__UNIQUE_ID_license43 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__param_major = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_major, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.46 { i8* bitcast (i32* @major to i8*) } }, section "__param", align 8
@__UNIQUE_ID_majortype44 = internal constant [19 x i8] c"parmtype=major:int\00", section ".modinfo", align 1
@__UNIQUE_ID_major45 = internal constant [37 x i8] c"parm=major:Major # for sound driver.\00", section ".modinfo", align 1
@__param_cards_limit = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_cards_limit, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.46 { i8* bitcast (i32* @cards_limit to i8*) } }, section "__param", align 8
@__UNIQUE_ID_cards_limittype46 = internal constant [25 x i8] c"parmtype=cards_limit:int\00", section ".modinfo", align 1
@__UNIQUE_ID_cards_limit47 = internal constant [52 x i8] c"parm=cards_limit:Count of auto-loadable soundcards.\00", section ".modinfo", align 1
@__UNIQUE_ID_alias48 = internal constant [23 x i8] c"alias=char-major-116-*\00", section ".modinfo", align 1
@__kcrctab_snd_ecards_limit = internal constant i64 ptrtoint (i8** @__crc_snd_ecards_limit to i64), section "___kcrctab+snd_ecards_limit", align 8
@__ksymtab_snd_ecards_limit = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @snd_ecards_limit to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_ecards_limit, i32 0, i32 0) }, section "___ksymtab+snd_ecards_limit", align 8
@__kcrctab_snd_request_card = internal constant i64 ptrtoint (i8** @__crc_snd_request_card to i64), section "___kcrctab+snd_request_card", align 8
@__ksymtab_snd_request_card = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i32)* @snd_request_card to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_request_card, i32 0, i32 0) }, section "___ksymtab+snd_request_card", align 8
@__kcrctab_snd_lookup_minor_data = internal constant i64 ptrtoint (i8** @__crc_snd_lookup_minor_data to i64), section "___kcrctab+snd_lookup_minor_data", align 8
@__ksymtab_snd_lookup_minor_data = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (i32, i32)* @snd_lookup_minor_data to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_lookup_minor_data, i32 0, i32 0) }, section "___ksymtab+snd_lookup_minor_data", align 8
@__kcrctab_snd_register_device_for_dev = internal constant i64 ptrtoint (i8** @__crc_snd_register_device_for_dev to i64), section "___kcrctab+snd_register_device_for_dev", align 8
@__ksymtab_snd_register_device_for_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32, %struct.file_operations*, i8*, i8*, %struct.device*)* @snd_register_device_for_dev to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_snd_register_device_for_dev, i32 0, i32 0) }, section "___ksymtab+snd_register_device_for_dev", align 8
@__kcrctab_snd_unregister_device = internal constant i64 ptrtoint (i8** @__crc_snd_unregister_device to i64), section "___kcrctab+snd_unregister_device", align 8
@__ksymtab_snd_unregister_device = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32)* @snd_unregister_device to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_unregister_device, i32 0, i32 0) }, section "___ksymtab+snd_unregister_device", align 8
@__kcrctab_snd_add_device_sysfs_file = internal constant i64 ptrtoint (i8** @__crc_snd_add_device_sysfs_file to i64), section "___kcrctab+snd_add_device_sysfs_file", align 8
@__ksymtab_snd_add_device_sysfs_file = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32, %struct.device_attribute*)* @snd_add_device_sysfs_file to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_add_device_sysfs_file, i32 0, i32 0) }, section "___ksymtab+snd_add_device_sysfs_file", align 8
@__kstrtab_snd_add_device_sysfs_file = internal constant [26 x i8] c"snd_add_device_sysfs_file\00", section "__ksymtab_strings", align 1
@sound_mutex = internal global %struct.mutex { %union.anon.1 { i32 1 }, %struct.spinlock { %union.anon.0 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.4, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @sound_mutex to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @sound_mutex to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @sound_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.5, i32 0, i32 0), i32 0, i64 0 } }, align 8
@snd_minors = internal global [256 x %struct.snd_minor*] zeroinitializer, align 16
@.str.4 = private unnamed_addr constant [22 x i8] c"sound_mutex.wait_lock\00", align 1
@.str.5 = private unnamed_addr constant [12 x i8] c"sound_mutex\00", align 1
@__crc_snd_add_device_sysfs_file = extern_weak global i8*, align 8
@__kstrtab_snd_unregister_device = internal constant [22 x i8] c"snd_unregister_device\00", section "__ksymtab_strings", align 1
@sound_class = external global %struct.class*, align 8
@major = internal global i32 116, align 4
@__crc_snd_unregister_device = extern_weak global i8*, align 8
@__kstrtab_snd_register_device_for_dev = internal constant [28 x i8] c"snd_register_device_for_dev\00", section "__ksymtab_strings", align 1
@.str.1 = private unnamed_addr constant [19 x i8] c"sound/core/sound.c\00", align 1
@.str.2 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@__crc_snd_register_device_for_dev = extern_weak global i8*, align 8
@__kstrtab_snd_lookup_minor_data = internal constant [22 x i8] c"snd_lookup_minor_data\00", section "__ksymtab_strings", align 1
@__crc_snd_lookup_minor_data = extern_weak global i8*, align 8
@__kstrtab_snd_request_card = internal constant [17 x i8] c"snd_request_card\00", section "__ksymtab_strings", align 1
@cards_limit = internal global i32 1, align 4
@.str = private unnamed_addr constant [12 x i8] c"snd-card-%i\00", align 1
@__crc_snd_request_card = extern_weak global i8*, align 8
@__kstrtab_snd_ecards_limit = internal constant [17 x i8] c"snd_ecards_limit\00", section "__ksymtab_strings", align 1
@__crc_snd_ecards_limit = extern_weak global i8*, align 8
@__param_str_cards_limit = internal constant [12 x i8] c"cards_limit\00", align 1
@param_ops_int = external global %struct.kernel_param_ops, align 8
@__param_str_major = internal constant [6 x i8] c"major\00", align 1
@__kstrtab_snd_major = internal constant [10 x i8] c"snd_major\00", section "__ksymtab_strings", align 1
@__crc_snd_major = extern_weak global i8*, align 8
@__this_module = external global %struct.module, align 8
@snd_minor_info_entry = internal global %struct.snd_info_entry* null, align 8
@.str.6 = private unnamed_addr constant [20 x i8] c"%3i: [%2i-%2i]: %s\0A\00", align 1
@.str.7 = private unnamed_addr constant [19 x i8] c"%3i: [%2i]   : %s\0A\00", align 1
@.str.8 = private unnamed_addr constant [18 x i8] c"%3i:        : %s\0A\00", align 1
@.str.15 = private unnamed_addr constant [6 x i8] c"timer\00", align 1
@.str.9 = private unnamed_addr constant [8 x i8] c"control\00", align 1
@.str.12 = private unnamed_addr constant [23 x i8] c"digital audio playback\00", align 1
@.str.13 = private unnamed_addr constant [22 x i8] c"digital audio capture\00", align 1
@.str.17 = private unnamed_addr constant [5 x i8] c"alsa\00", align 1
@snd_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @noop_llseek, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @snd_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.18 = private unnamed_addr constant [52 x i8] c"\013unable to register native major device number %d\0A\00", align 1
@.str.19 = private unnamed_addr constant [8 x i8] c"snd-seq\00", align 1
@.str.20 = private unnamed_addr constant [10 x i8] c"snd-timer\00", align 1
@snd_cards = common global [32 x %struct.snd_card*] zeroinitializer, align 16
@snd_mixer_oss_notify_callback = common global i32 (%struct.snd_card*, i32)* null, align 8
@__kcrctab_snd_cards = internal constant i64 ptrtoint (i8** @__crc_snd_cards to i64), section "___kcrctab+snd_cards", align 8
@__ksymtab_snd_cards = internal constant %struct.kernel_symbol { i64 ptrtoint ([32 x %struct.snd_card*]* @snd_cards to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_snd_cards, i32 0, i32 0) }, section "___ksymtab+snd_cards", align 8
@__param_slots = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_slots, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 292, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_slots } }, section "__param", align 8
@__UNIQUE_ID_slotstype56 = internal constant [30 x i8] c"parmtype=slots:array of charp\00", section ".modinfo", align 1
@__UNIQUE_ID_slots57 = internal constant [47 x i8] c"parm=slots:Module names assigned to the slots.\00", section ".modinfo", align 1
@__kcrctab_snd_mixer_oss_notify_callback = internal constant i64 ptrtoint (i8** @__crc_snd_mixer_oss_notify_callback to i64), section "___kcrctab+snd_mixer_oss_notify_callback", align 8
@__ksymtab_snd_mixer_oss_notify_callback = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback to i64), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__kstrtab_snd_mixer_oss_notify_callback, i32 0, i32 0) }, section "___ksymtab+snd_mixer_oss_notify_callback", align 8
@__kcrctab_snd_card_create = internal constant i64 ptrtoint (i8** @__crc_snd_card_create to i64), section "___kcrctab+snd_card_create", align 8
@__ksymtab_snd_card_create = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, i8*, %struct.module*, i32, %struct.snd_card**)* @snd_card_create to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_card_create, i32 0, i32 0) }, section "___ksymtab+snd_card_create", align 8
@__kcrctab_snd_card_disconnect = internal constant i64 ptrtoint (i8** @__crc_snd_card_disconnect to i64), section "___kcrctab+snd_card_disconnect", align 8
@__ksymtab_snd_card_disconnect = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*)* @snd_card_disconnect to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_card_disconnect, i32 0, i32 0) }, section "___ksymtab+snd_card_disconnect", align 8
@__kcrctab_snd_card_unref = internal constant i64 ptrtoint (i8** @__crc_snd_card_unref to i64), section "___kcrctab+snd_card_unref", align 8
@__ksymtab_snd_card_unref = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_card*)* @snd_card_unref to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_snd_card_unref, i32 0, i32 0) }, section "___ksymtab+snd_card_unref", align 8
@__kcrctab_snd_card_free_when_closed = internal constant i64 ptrtoint (i8** @__crc_snd_card_free_when_closed to i64), section "___kcrctab+snd_card_free_when_closed", align 8
@__ksymtab_snd_card_free_when_closed = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*)* @snd_card_free_when_closed to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_card_free_when_closed, i32 0, i32 0) }, section "___ksymtab+snd_card_free_when_closed", align 8
@__kcrctab_snd_card_free = internal constant i64 ptrtoint (i8** @__crc_snd_card_free to i64), section "___kcrctab+snd_card_free", align 8
@__ksymtab_snd_card_free = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*)* @snd_card_free to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_snd_card_free, i32 0, i32 0) }, section "___ksymtab+snd_card_free", align 8
@__kcrctab_snd_card_set_id = internal constant i64 ptrtoint (i8** @__crc_snd_card_set_id to i64), section "___kcrctab+snd_card_set_id", align 8
@__ksymtab_snd_card_set_id = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_card*, i8*)* @snd_card_set_id to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_card_set_id, i32 0, i32 0) }, section "___ksymtab+snd_card_set_id", align 8
@__kcrctab_snd_card_register = internal constant i64 ptrtoint (i8** @__crc_snd_card_register to i64), section "___kcrctab+snd_card_register", align 8
@__ksymtab_snd_card_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*)* @snd_card_register to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_card_register, i32 0, i32 0) }, section "___ksymtab+snd_card_register", align 8
@__kcrctab_snd_component_add = internal constant i64 ptrtoint (i8** @__crc_snd_component_add to i64), section "___kcrctab+snd_component_add", align 8
@__ksymtab_snd_component_add = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i8*)* @snd_component_add to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_component_add, i32 0, i32 0) }, section "___ksymtab+snd_component_add", align 8
@__kcrctab_snd_card_file_add = internal constant i64 ptrtoint (i8** @__crc_snd_card_file_add to i64), section "___kcrctab+snd_card_file_add", align 8
@__ksymtab_snd_card_file_add = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.file*)* @snd_card_file_add to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_card_file_add, i32 0, i32 0) }, section "___ksymtab+snd_card_file_add", align 8
@__kcrctab_snd_card_file_remove = internal constant i64 ptrtoint (i8** @__crc_snd_card_file_remove to i64), section "___kcrctab+snd_card_file_remove", align 8
@__ksymtab_snd_card_file_remove = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.file*)* @snd_card_file_remove to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_snd_card_file_remove, i32 0, i32 0) }, section "___ksymtab+snd_card_file_remove", align 8
@__kcrctab_snd_power_wait = internal constant i64 ptrtoint (i8** @__crc_snd_power_wait to i64), section "___kcrctab+snd_power_wait", align 8
@__ksymtab_snd_power_wait = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i32)* @snd_power_wait to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_snd_power_wait, i32 0, i32 0) }, section "___ksymtab+snd_power_wait", align 8
@__kstrtab_snd_power_wait = internal constant [15 x i8] c"snd_power_wait\00", section "__ksymtab_strings", align 1
@current_task = external global %struct.task_struct*, align 8
@__crc_snd_power_wait = extern_weak global i8*, align 8
@__kstrtab_snd_card_file_remove = internal constant [21 x i8] c"snd_card_file_remove\00", section "__ksymtab_strings", align 1
@shutdown_lock = internal global %struct.spinlock { %union.anon.0 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.26, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@.str.21 = private unnamed_addr constant [18 x i8] c"sound/core/init.c\00", align 1
@.str.23 = private unnamed_addr constant [38 x i8] c"\013ALSA card file remove problem (%p)\0A\00", align 1
@.str.28 = private unnamed_addr constant [36 x i8] c"\013unable to free all devices (pre)\0A\00", align 1
@.str.29 = private unnamed_addr constant [39 x i8] c"\013unable to free all devices (normal)\0A\00", align 1
@.str.30 = private unnamed_addr constant [37 x i8] c"\013unable to free all devices (post)\0A\00", align 1
@.str.31 = private unnamed_addr constant [28 x i8] c"\014unable to free card info\0A\00", align 1
@.str.26 = private unnamed_addr constant [14 x i8] c"shutdown_lock\00", align 1
@__crc_snd_card_file_remove = extern_weak global i8*, align 8
@__kstrtab_snd_card_file_add = internal constant [18 x i8] c"snd_card_file_add\00", section "__ksymtab_strings", align 1
@__crc_snd_card_file_add = extern_weak global i8*, align 8
@__kstrtab_snd_component_add = internal constant [18 x i8] c"snd_component_add\00", section "__ksymtab_strings", align 1
@.str.22 = private unnamed_addr constant [2 x i8] c" \00", align 1
@__crc_snd_component_add = extern_weak global i8*, align 8
@__kstrtab_snd_card_register = internal constant [18 x i8] c"snd_card_register\00", section "__ksymtab_strings", align 1
@snd_card_mutex = internal global %struct.mutex { %union.anon.1 { i32 1 }, %struct.spinlock { %union.anon.0 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.24, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @snd_card_mutex to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @snd_card_mutex to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @snd_card_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.25, i32 0, i32 0), i32 0, i64 0 } }, align 8
@card_id_attrs = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.37, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @card_id_show_attr, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @card_id_store_attr }, align 8
@card_number_attrs = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.40, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @card_number_show_attr, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.40 = private unnamed_addr constant [7 x i8] c"number\00", align 1
@.str.41 = private unnamed_addr constant [4 x i8] c"%i\0A\00", align 1
@.str.37 = private unnamed_addr constant [3 x i8] c"id\00", align 1
@_ctype = external constant [0 x i8], align 1
@.str.39 = private unnamed_addr constant [7 x i8] c"(null)\00", align 1
@.str.17.27 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.36 = private unnamed_addr constant [28 x i8] c"unable to create card info\0A\00", align 1
@.str.38 = private unnamed_addr constant [29 x i8] c"unable to create card entry\0A\00", align 1
@.str.33 = private unnamed_addr constant [8 x i8] c"Default\00", align 1
@.str.34 = private unnamed_addr constant [3 x i8] c"_1\00", align 1
@.str.35 = private unnamed_addr constant [30 x i8] c"\013unable to set card id (%s)\0A\00", align 1
@.str.24 = private unnamed_addr constant [25 x i8] c"snd_card_mutex.wait_lock\00", align 1
@.str.25 = private unnamed_addr constant [15 x i8] c"snd_card_mutex\00", align 1
@__crc_snd_card_register = extern_weak global i8*, align 8
@__kstrtab_snd_card_set_id = internal constant [16 x i8] c"snd_card_set_id\00", section "__ksymtab_strings", align 1
@__crc_snd_card_set_id = extern_weak global i8*, align 8
@__kstrtab_snd_card_free = internal constant [14 x i8] c"snd_card_free\00", section "__ksymtab_strings", align 1
@snd_cards_lock = internal global i32 0, align 4
@shutdown_files = internal global %struct.list_head { %struct.list_head* @shutdown_files, %struct.list_head* @shutdown_files }, align 8
@snd_shutdown_f_ops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @snd_disconnect_llseek, i64 (%struct.file*, i8*, i64, i64*)* @snd_disconnect_read, i64 (%struct.file*, i8*, i64, i64*)* @snd_disconnect_write, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @snd_disconnect_poll, i64 (%struct.file*, i32, i64)* @snd_disconnect_ioctl, i64 (%struct.file*, i32, i64)* @snd_disconnect_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* @snd_disconnect_mmap, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @snd_disconnect_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* @snd_disconnect_fasync, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.15.28 = private unnamed_addr constant [51 x i8] c"\013not all devices for card %i can be disconnected\0A\00", align 1
@.str.27 = private unnamed_addr constant [19 x i8] c"%s(%p, %p) failed!\00", align 1
@__func__.snd_disconnect_release = private unnamed_addr constant [23 x i8] c"snd_disconnect_release\00", align 1
@__crc_snd_card_free = extern_weak global i8*, align 8
@__kstrtab_snd_card_free_when_closed = internal constant [26 x i8] c"snd_card_free_when_closed\00", section "__ksymtab_strings", align 1
@__crc_snd_card_free_when_closed = extern_weak global i8*, align 8
@__kstrtab_snd_card_unref = internal constant [15 x i8] c"snd_card_unref\00", section "__ksymtab_strings", align 1
@__crc_snd_card_unref = extern_weak global i8*, align 8
@__kstrtab_snd_card_disconnect = internal constant [20 x i8] c"snd_card_disconnect\00", section "__ksymtab_strings", align 1
@__crc_snd_card_disconnect = extern_weak global i8*, align 8
@__kstrtab_snd_card_create = internal constant [16 x i8] c"snd_card_create\00", section "__ksymtab_strings", align 1
@slots = internal global [32 x i8*] zeroinitializer, align 16
@.str.1.29 = private unnamed_addr constant [61 x i8] c"\013cannot find the slot for index %d (range 0-%i), error: %d\0A\00", align 1
@.str.2.30 = private unnamed_addr constant [22 x i8] c"&card->controls_rwsem\00", align 1
@snd_card_create.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.4.31 = private unnamed_addr constant [24 x i8] c"&card->ctl_files_rwlock\00", align 1
@snd_card_create.__key.3 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.6.32 = private unnamed_addr constant [28 x i8] c"&(&card->files_lock)->rlock\00", align 1
@snd_card_create.__key.5 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.8.33 = private unnamed_addr constant [22 x i8] c"&card->shutdown_sleep\00", align 1
@snd_card_create.__key.7 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.10.34 = private unnamed_addr constant [18 x i8] c"&card->power_lock\00", align 1
@snd_card_create.__key.9 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.12.35 = private unnamed_addr constant [19 x i8] c"&card->power_sleep\00", align 1
@snd_card_create.__key.11 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.13.36 = private unnamed_addr constant [37 x i8] c"\013unable to register control minors\0A\00", align 1
@.str.14.37 = private unnamed_addr constant [30 x i8] c"\013unable to create card info\0A\00", align 1
@__crc_snd_card_create = extern_weak global i8*, align 8
@__kstrtab_snd_mixer_oss_notify_callback = internal constant [30 x i8] c"snd_mixer_oss_notify_callback\00", section "__ksymtab_strings", align 1
@__crc_snd_mixer_oss_notify_callback = extern_weak global i8*, align 8
@__param_str_slots = internal constant [6 x i8] c"slots\00", align 1
@param_array_ops = external global %struct.kernel_param_ops, align 8
@__param_arr_slots = internal constant %struct.kparam_array { i32 32, i32 8, i32* null, %struct.kernel_param_ops* @param_ops_charp, i8* bitcast ([32 x i8*]* @slots to i8*) }, align 8
@param_ops_charp = external global %struct.kernel_param_ops, align 8
@__kstrtab_snd_cards = internal constant [10 x i8] c"snd_cards\00", section "__ksymtab_strings", align 1
@__crc_snd_cards = extern_weak global i8*, align 8
@.str.18.40 = private unnamed_addr constant [23 x i8] c"--- no soundcards ---\0A\00", align 1
@snd_card_info_entry = internal global %struct.snd_info_entry* null, align 8
@.str.20.42 = private unnamed_addr constant [8 x i8] c"modules\00", align 1
@snd_card_module_info_entry = internal global %struct.snd_info_entry* null, align 8
@.str.44 = private unnamed_addr constant [8 x i8] c"%2i %s\0A\00", align 1
@.str.42 = private unnamed_addr constant [22 x i8] c"%2i [%-15s]: %s - %s\0A\00", align 1
@.str.43 = private unnamed_addr constant [26 x i8] c"                      %s\0A\00", align 1
@__kcrctab_copy_to_user_fromio = internal constant i64 ptrtoint (i8** @__crc_copy_to_user_fromio to i64), section "___kcrctab+copy_to_user_fromio", align 8
@__ksymtab_copy_to_user_fromio = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i8*, i8*, i64)* @copy_to_user_fromio to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_copy_to_user_fromio, i32 0, i32 0) }, section "___ksymtab+copy_to_user_fromio", align 8
@__kcrctab_copy_from_user_toio = internal constant i64 ptrtoint (i8** @__crc_copy_from_user_toio to i64), section "___kcrctab+copy_from_user_toio", align 8
@__ksymtab_copy_from_user_toio = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i8*, i8*, i64)* @copy_from_user_toio to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_copy_from_user_toio, i32 0, i32 0) }, section "___ksymtab+copy_from_user_toio", align 8
@__kstrtab_copy_from_user_toio = internal constant [20 x i8] c"copy_from_user_toio\00", section "__ksymtab_strings", align 1
@__crc_copy_from_user_toio = extern_weak global i8*, align 8
@__kstrtab_copy_to_user_fromio = internal constant [20 x i8] c"copy_to_user_fromio\00", section "__ksymtab_strings", align 1
@__crc_copy_to_user_fromio = extern_weak global i8*, align 8
@snd_seq_root = common global %struct.snd_info_entry* null, align 8
@snd_oss_root = common global %struct.snd_info_entry* null, align 8
@__kcrctab_snd_iprintf = internal constant i64 ptrtoint (i8** @__crc_snd_iprintf to i64), section "___kcrctab+snd_iprintf", align 8
@__ksymtab_snd_iprintf = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_info_buffer*, i8*, ...)* @snd_iprintf to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_snd_iprintf, i32 0, i32 0) }, section "___ksymtab+snd_iprintf", align 8
@__kcrctab_snd_seq_root = internal constant i64 ptrtoint (i8** @__crc_snd_seq_root to i64), section "___kcrctab+snd_seq_root", align 8
@__ksymtab_snd_seq_root = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_info_entry** @snd_seq_root to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_snd_seq_root, i32 0, i32 0) }, section "___ksymtab+snd_seq_root", align 8
@__kcrctab_snd_info_get_line = internal constant i64 ptrtoint (i8** @__crc_snd_info_get_line to i64), section "___kcrctab+snd_info_get_line", align 8
@__ksymtab_snd_info_get_line = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_info_buffer*, i8*, i32)* @snd_info_get_line to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_info_get_line, i32 0, i32 0) }, section "___ksymtab+snd_info_get_line", align 8
@__kcrctab_snd_info_get_str = internal constant i64 ptrtoint (i8** @__crc_snd_info_get_str to i64), section "___kcrctab+snd_info_get_str", align 8
@__ksymtab_snd_info_get_str = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (i8*, i8*, i32)* @snd_info_get_str to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_info_get_str, i32 0, i32 0) }, section "___ksymtab+snd_info_get_str", align 8
@__kcrctab_snd_info_create_module_entry = internal constant i64 ptrtoint (i8** @__crc_snd_info_create_module_entry to i64), section "___kcrctab+snd_info_create_module_entry", align 8
@__ksymtab_snd_info_create_module_entry = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_info_entry* (%struct.module*, i8*, %struct.snd_info_entry*)* @snd_info_create_module_entry to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_snd_info_create_module_entry, i32 0, i32 0) }, section "___ksymtab+snd_info_create_module_entry", align 8
@__kcrctab_snd_info_create_card_entry = internal constant i64 ptrtoint (i8** @__crc_snd_info_create_card_entry to i64), section "___kcrctab+snd_info_create_card_entry", align 8
@__ksymtab_snd_info_create_card_entry = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_info_entry* (%struct.snd_card*, i8*, %struct.snd_info_entry*)* @snd_info_create_card_entry to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_snd_info_create_card_entry, i32 0, i32 0) }, section "___ksymtab+snd_info_create_card_entry", align 8
@__kcrctab_snd_card_proc_new = internal constant i64 ptrtoint (i8** @__crc_snd_card_proc_new to i64), section "___kcrctab+snd_card_proc_new", align 8
@__ksymtab_snd_card_proc_new = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i8*, %struct.snd_info_entry**)* @snd_card_proc_new to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_card_proc_new, i32 0, i32 0) }, section "___ksymtab+snd_card_proc_new", align 8
@__kcrctab_snd_info_free_entry = internal constant i64 ptrtoint (i8** @__crc_snd_info_free_entry to i64), section "___kcrctab+snd_info_free_entry", align 8
@__ksymtab_snd_info_free_entry = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_info_entry*)* @snd_info_free_entry to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_info_free_entry, i32 0, i32 0) }, section "___ksymtab+snd_info_free_entry", align 8
@__kcrctab_snd_info_register = internal constant i64 ptrtoint (i8** @__crc_snd_info_register to i64), section "___kcrctab+snd_info_register", align 8
@__ksymtab_snd_info_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_info_entry*)* @snd_info_register to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_info_register, i32 0, i32 0) }, section "___ksymtab+snd_info_register", align 8
@__kstrtab_snd_info_register = internal constant [18 x i8] c"snd_info_register\00", section "__ksymtab_strings", align 1
@.str.12.50 = private unnamed_addr constant [18 x i8] c"sound/core/info.c\00", align 1
@snd_proc_root = internal global %struct.proc_dir_entry* null, align 8
@info_mutex = internal global %struct.mutex { %union.anon.1 { i32 1 }, %struct.spinlock { %union.anon.0 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.15.58, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @info_mutex to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @info_mutex to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @info_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.16.59, i32 0, i32 0), i32 0, i64 0 } }, align 8
@snd_info_entry_operations = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @snd_info_entry_llseek, i64 (%struct.file*, i8*, i64, i64*)* @snd_info_entry_read, i64 (%struct.file*, i8*, i64, i64*)* @snd_info_entry_write, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @snd_info_entry_poll, i64 (%struct.file*, i32, i64)* @snd_info_entry_ioctl, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* @snd_info_entry_mmap, i32 (%struct.inode*, %struct.file*)* @snd_info_entry_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @snd_info_entry_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.20.51 = private unnamed_addr constant [31 x i8] c"\014data write error to %s (%i)\0A\00", align 1
@.str.15.58 = private unnamed_addr constant [21 x i8] c"info_mutex.wait_lock\00", align 1
@.str.16.59 = private unnamed_addr constant [11 x i8] c"info_mutex\00", align 1
@__crc_snd_info_register = extern_weak global i8*, align 8
@__kstrtab_snd_info_free_entry = internal constant [20 x i8] c"snd_info_free_entry\00", section "__ksymtab_strings", align 1
@__crc_snd_info_free_entry = extern_weak global i8*, align 8
@__kstrtab_snd_card_proc_new = internal constant [18 x i8] c"snd_card_proc_new\00", section "__ksymtab_strings", align 1
@snd_card_proc_new.ops = internal global %struct.snd_device_ops { i32 (%struct.snd_device*)* @snd_info_dev_free_entry, i32 (%struct.snd_device*)* @snd_info_dev_register_entry, i32 (%struct.snd_device*)* null }, align 8
@.str.17.66 = private unnamed_addr constant [15 x i8] c"&entry->access\00", align 1
@snd_info_create_entry.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@__crc_snd_card_proc_new = extern_weak global i8*, align 8
@__kstrtab_snd_info_create_card_entry = internal constant [27 x i8] c"snd_info_create_card_entry\00", section "__ksymtab_strings", align 1
@__crc_snd_info_create_card_entry = extern_weak global i8*, align 8
@__kstrtab_snd_info_create_module_entry = internal constant [29 x i8] c"snd_info_create_module_entry\00", section "__ksymtab_strings", align 1
@__crc_snd_info_create_module_entry = extern_weak global i8*, align 8
@__kstrtab_snd_info_get_str = internal constant [17 x i8] c"snd_info_get_str\00", section "__ksymtab_strings", align 1
@__crc_snd_info_get_str = extern_weak global i8*, align 8
@__kstrtab_snd_info_get_line = internal constant [18 x i8] c"snd_info_get_line\00", section "__ksymtab_strings", align 1
@__crc_snd_info_get_line = extern_weak global i8*, align 8
@__kstrtab_snd_seq_root = internal constant [13 x i8] c"snd_seq_root\00", section "__ksymtab_strings", align 1
@__crc_snd_seq_root = extern_weak global i8*, align 8
@__kstrtab_snd_iprintf = internal constant [12 x i8] c"snd_iprintf\00", section "__ksymtab_strings", align 1
@__crc_snd_iprintf = extern_weak global i8*, align 8
@snd_info_check_reserved_words.reserved = internal global [12 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.74, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1.75, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2.76, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3.77, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.175, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.79, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6.80, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.7.81, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.8.82, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9.83, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10.84, i32 0, i32 0), i8* null], align 16
@.str.11.73 = private unnamed_addr constant [5 x i8] c"card\00", align 1
@.str.74 = private unnamed_addr constant [8 x i8] c"version\00", align 1
@.str.1.75 = private unnamed_addr constant [8 x i8] c"meminfo\00", align 1
@.str.2.76 = private unnamed_addr constant [9 x i8] c"memdebug\00", align 1
@.str.3.77 = private unnamed_addr constant [7 x i8] c"detect\00", align 1
@.str.5.79 = private unnamed_addr constant [4 x i8] c"oss\00", align 1
@.str.6.80 = private unnamed_addr constant [6 x i8] c"cards\00", align 1
@.str.7.81 = private unnamed_addr constant [7 x i8] c"timers\00", align 1
@.str.8.82 = private unnamed_addr constant [6 x i8] c"synth\00", align 1
@.str.9.83 = private unnamed_addr constant [4 x i8] c"pcm\00", align 1
@.str.10.84 = private unnamed_addr constant [4 x i8] c"seq\00", align 1
@.str.13.87 = private unnamed_addr constant [7 x i8] c"asound\00", align 1
@snd_info_version_entry = internal global %struct.snd_info_entry* null, align 8
@.str.21.88 = private unnamed_addr constant [55 x i8] c"Advanced Linux Sound Architecture Driver Version k%s.\0A\00", align 1
@init_uts_ns = external global %struct.uts_namespace, align 8
@.str.14.93 = private unnamed_addr constant [7 x i8] c"card%i\00", align 1
@__kcrctab_snd_ctl_notify = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_notify to i64), section "___kcrctab+snd_ctl_notify", align 8
@__ksymtab_snd_ctl_notify = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_card*, i32, %struct.snd_ctl_elem_id*)* @snd_ctl_notify to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_snd_ctl_notify, i32 0, i32 0) }, section "___ksymtab+snd_ctl_notify", align 8
@__kcrctab_snd_ctl_new1 = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_new1 to i64), section "___kcrctab+snd_ctl_new1", align 8
@__ksymtab_snd_ctl_new1 = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_kcontrol* (%struct.snd_kcontrol_new*, i8*)* @snd_ctl_new1 to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_snd_ctl_new1, i32 0, i32 0) }, section "___ksymtab+snd_ctl_new1", align 8
@__kcrctab_snd_ctl_free_one = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_free_one to i64), section "___kcrctab+snd_ctl_free_one", align 8
@__ksymtab_snd_ctl_free_one = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_kcontrol*)* @snd_ctl_free_one to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_ctl_free_one, i32 0, i32 0) }, section "___ksymtab+snd_ctl_free_one", align 8
@__kcrctab_snd_ctl_add = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_add to i64), section "___kcrctab+snd_ctl_add", align 8
@__ksymtab_snd_ctl_add = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_kcontrol*)* @snd_ctl_add to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_snd_ctl_add, i32 0, i32 0) }, section "___ksymtab+snd_ctl_add", align 8
@__kcrctab_snd_ctl_replace = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_replace to i64), section "___kcrctab+snd_ctl_replace", align 8
@__ksymtab_snd_ctl_replace = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_kcontrol*, i1)* @snd_ctl_replace to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_ctl_replace, i32 0, i32 0) }, section "___ksymtab+snd_ctl_replace", align 8
@__kcrctab_snd_ctl_remove = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_remove to i64), section "___kcrctab+snd_ctl_remove", align 8
@__ksymtab_snd_ctl_remove = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_kcontrol*)* @snd_ctl_remove to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_snd_ctl_remove, i32 0, i32 0) }, section "___ksymtab+snd_ctl_remove", align 8
@__kcrctab_snd_ctl_remove_id = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_remove_id to i64), section "___kcrctab+snd_ctl_remove_id", align 8
@__ksymtab_snd_ctl_remove_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_ctl_elem_id*)* @snd_ctl_remove_id to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_ctl_remove_id, i32 0, i32 0) }, section "___ksymtab+snd_ctl_remove_id", align 8
@__kcrctab_snd_ctl_activate_id = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_activate_id to i64), section "___kcrctab_gpl+snd_ctl_activate_id", align 8
@__ksymtab_snd_ctl_activate_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_ctl_elem_id*, i32)* @snd_ctl_activate_id to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_ctl_activate_id, i32 0, i32 0) }, section "___ksymtab_gpl+snd_ctl_activate_id", align 8
@__kcrctab_snd_ctl_rename_id = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_rename_id to i64), section "___kcrctab+snd_ctl_rename_id", align 8
@__ksymtab_snd_ctl_rename_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_ctl_elem_id*, %struct.snd_ctl_elem_id*)* @snd_ctl_rename_id to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_ctl_rename_id, i32 0, i32 0) }, section "___ksymtab+snd_ctl_rename_id", align 8
@__kcrctab_snd_ctl_find_numid = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_find_numid to i64), section "___kcrctab+snd_ctl_find_numid", align 8
@__ksymtab_snd_ctl_find_numid = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_kcontrol* (%struct.snd_card*, i32)* @snd_ctl_find_numid to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_snd_ctl_find_numid, i32 0, i32 0) }, section "___ksymtab+snd_ctl_find_numid", align 8
@__kcrctab_snd_ctl_find_id = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_find_id to i64), section "___kcrctab+snd_ctl_find_id", align 8
@__ksymtab_snd_ctl_find_id = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_kcontrol* (%struct.snd_card*, %struct.snd_ctl_elem_id*)* @snd_ctl_find_id to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_ctl_find_id, i32 0, i32 0) }, section "___ksymtab+snd_ctl_find_id", align 8
@__kcrctab_snd_ctl_register_ioctl = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_register_ioctl to i64), section "___kcrctab+snd_ctl_register_ioctl", align 8
@__ksymtab_snd_ctl_register_ioctl = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*)* @snd_ctl_register_ioctl to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_snd_ctl_register_ioctl, i32 0, i32 0) }, section "___ksymtab+snd_ctl_register_ioctl", align 8
@__kcrctab_snd_ctl_register_ioctl_compat = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_register_ioctl_compat to i64), section "___kcrctab+snd_ctl_register_ioctl_compat", align 8
@__ksymtab_snd_ctl_register_ioctl_compat = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*)* @snd_ctl_register_ioctl_compat to i64), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__kstrtab_snd_ctl_register_ioctl_compat, i32 0, i32 0) }, section "___ksymtab+snd_ctl_register_ioctl_compat", align 8
@__kcrctab_snd_ctl_unregister_ioctl = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_unregister_ioctl to i64), section "___kcrctab+snd_ctl_unregister_ioctl", align 8
@__ksymtab_snd_ctl_unregister_ioctl = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*)* @snd_ctl_unregister_ioctl to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_snd_ctl_unregister_ioctl, i32 0, i32 0) }, section "___ksymtab+snd_ctl_unregister_ioctl", align 8
@__kcrctab_snd_ctl_unregister_ioctl_compat = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_unregister_ioctl_compat to i64), section "___kcrctab+snd_ctl_unregister_ioctl_compat", align 8
@__ksymtab_snd_ctl_unregister_ioctl_compat = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*)* @snd_ctl_unregister_ioctl_compat to i64), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__kstrtab_snd_ctl_unregister_ioctl_compat, i32 0, i32 0) }, section "___ksymtab+snd_ctl_unregister_ioctl_compat", align 8
@__kcrctab_snd_ctl_boolean_mono_info = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_boolean_mono_info to i64), section "___kcrctab+snd_ctl_boolean_mono_info", align 8
@__ksymtab_snd_ctl_boolean_mono_info = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @snd_ctl_boolean_mono_info to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_ctl_boolean_mono_info, i32 0, i32 0) }, section "___ksymtab+snd_ctl_boolean_mono_info", align 8
@__kcrctab_snd_ctl_boolean_stereo_info = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_boolean_stereo_info to i64), section "___kcrctab+snd_ctl_boolean_stereo_info", align 8
@__ksymtab_snd_ctl_boolean_stereo_info = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @snd_ctl_boolean_stereo_info to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_snd_ctl_boolean_stereo_info, i32 0, i32 0) }, section "___ksymtab+snd_ctl_boolean_stereo_info", align 8
@__kcrctab_snd_ctl_enum_info = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_enum_info to i64), section "___kcrctab+snd_ctl_enum_info", align 8
@__ksymtab_snd_ctl_enum_info = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_ctl_elem_info*, i32, i32, i8**)* @snd_ctl_enum_info to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_ctl_enum_info, i32 0, i32 0) }, section "___ksymtab+snd_ctl_enum_info", align 8
@__kstrtab_snd_ctl_enum_info = internal constant [18 x i8] c"snd_ctl_enum_info\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_enum_info = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_boolean_stereo_info = internal constant [28 x i8] c"snd_ctl_boolean_stereo_info\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_boolean_stereo_info = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_boolean_mono_info = internal constant [26 x i8] c"snd_ctl_boolean_mono_info\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_boolean_mono_info = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_unregister_ioctl_compat = internal constant [32 x i8] c"snd_ctl_unregister_ioctl_compat\00", section "__ksymtab_strings", align 1
@snd_control_compat_ioctls = internal global %struct.list_head { %struct.list_head* @snd_control_compat_ioctls, %struct.list_head* @snd_control_compat_ioctls }, align 8
@.str.103 = private unnamed_addr constant [21 x i8] c"sound/core/control.c\00", align 1
@snd_ioctl_rwsem = internal global %struct.rw_semaphore { i64 0, %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6.105, i32 0, i32 0), i32 0, i64 0 } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @snd_ioctl_rwsem to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @snd_ioctl_rwsem to i8*), i64 80) to %struct.list_head*) }, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.7.106, i32 0, i32 0), i32 0, i64 0 } }, align 8
@.str.6.105 = private unnamed_addr constant [26 x i8] c"snd_ioctl_rwsem.wait_lock\00", align 1
@.str.7.106 = private unnamed_addr constant [16 x i8] c"snd_ioctl_rwsem\00", align 1
@__crc_snd_ctl_unregister_ioctl_compat = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_unregister_ioctl = internal constant [25 x i8] c"snd_ctl_unregister_ioctl\00", section "__ksymtab_strings", align 1
@snd_control_ioctls = internal global %struct.list_head { %struct.list_head* @snd_control_ioctls, %struct.list_head* @snd_control_ioctls }, align 8
@__crc_snd_ctl_unregister_ioctl = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_register_ioctl_compat = internal constant [30 x i8] c"snd_ctl_register_ioctl_compat\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_register_ioctl_compat = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_register_ioctl = internal constant [23 x i8] c"snd_ctl_register_ioctl\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_register_ioctl = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_find_id = internal constant [16 x i8] c"snd_ctl_find_id\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_find_id = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_find_numid = internal constant [19 x i8] c"snd_ctl_find_numid\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_find_numid = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_rename_id = internal constant [18 x i8] c"snd_ctl_rename_id\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_rename_id = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_activate_id = internal constant [20 x i8] c"snd_ctl_activate_id\00", section "__ksymtab_strings", align 1
@.str.1.111 = private unnamed_addr constant [41 x i8] c"\013No memory available to allocate event\0A\00", align 1
@__crc_snd_ctl_activate_id = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_remove_id = internal constant [18 x i8] c"snd_ctl_remove_id\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_remove_id = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_remove = internal constant [15 x i8] c"snd_ctl_remove\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_remove = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_replace = internal constant [16 x i8] c"snd_ctl_replace\00", section "__ksymtab_strings", align 1
@.str.5.112 = private unnamed_addr constant [40 x i8] c"\013unable to allocate new control numid\0A\00", align 1
@__crc_snd_ctl_replace = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_add = internal constant [12 x i8] c"snd_ctl_add\00", section "__ksymtab_strings", align 1
@.str.3.113 = private unnamed_addr constant [45 x i8] c"\013control %i:%i:%i:%s:%i is already present\0A\00", align 1
@__crc_snd_ctl_add = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_free_one = internal constant [17 x i8] c"snd_ctl_free_one\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_free_one = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_new1 = internal constant [13 x i8] c"snd_ctl_new1\00", section "__ksymtab_strings", align 1
@.str.2.114 = private unnamed_addr constant [39 x i8] c"\014Control name '%s' truncated to '%s'\0A\00", align 1
@.str.4.115 = private unnamed_addr constant [36 x i8] c"\013Cannot allocate control instance\0A\00", align 1
@__crc_snd_ctl_new1 = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_notify = internal constant [15 x i8] c"snd_ctl_notify\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_notify = extern_weak global i8*, align 8
@snd_ctl_create.ops = internal global %struct.snd_device_ops { i32 (%struct.snd_device*)* @snd_ctl_dev_free, i32 (%struct.snd_device*)* @snd_ctl_dev_register, i32 (%struct.snd_device*)* @snd_ctl_dev_disconnect }, align 8
@.str.9.118 = private unnamed_addr constant [11 x i8] c"controlC%i\00", align 1
@snd_ctl_f_ops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* @snd_ctl_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @snd_ctl_poll, i64 (%struct.file*, i32, i64)* @snd_ctl_ioctl, i64 (%struct.file*, i32, i64)* @snd_ctl_ioctl_compat, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @snd_ctl_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @snd_ctl_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* @snd_ctl_fasync, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.15.121 = private unnamed_addr constant [19 x i8] c"&ctl->change_sleep\00", align 1
@snd_ctl_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.17.122 = private unnamed_addr constant [26 x i8] c"&(&ctl->read_lock)->rlock\00", align 1
@snd_ctl_open.__key.16 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.13.125 = private unnamed_addr constant [28 x i8] c"sound/core/control_compat.c\00", align 1
@.str.11.130 = private unnamed_addr constant [62 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/uaccess_64.h\00", align 1
@.str.12.131 = private unnamed_addr constant [27 x i8] c"Buffer overflow detected!\0A\00", align 1
@.str.14.134 = private unnamed_addr constant [47 x i8] c"\013snd_ioctl32_ctl_elem_value: unknown type %d\0A\00", align 1
@.str.10.135 = private unnamed_addr constant [22 x i8] c"unknown ioctl = 0x%x\0A\00", align 1
@__param_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_debug, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 420, i16 -1, %union.anon.46 { i8* bitcast (i32* @debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_debugtype39 = internal constant [19 x i8] c"parmtype=debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_debug40 = internal constant [37 x i8] c"parm=debug:Debug level (0 = disable)\00", section ".modinfo", align 1
@__kcrctab_release_and_free_resource = internal constant i64 ptrtoint (i8** @__crc_release_and_free_resource to i64), section "___kcrctab+release_and_free_resource", align 8
@__ksymtab_release_and_free_resource = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.resource*)* @release_and_free_resource to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_release_and_free_resource, i32 0, i32 0) }, section "___ksymtab+release_and_free_resource", align 8
@__kcrctab___snd_printk = internal constant i64 ptrtoint (i8** @__crc___snd_printk to i64), section "___kcrctab_gpl+__snd_printk", align 8
@__ksymtab___snd_printk = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i32, i8*, i32, i8*, ...)* @__snd_printk to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab___snd_printk, i32 0, i32 0) }, section "___ksymtab_gpl+__snd_printk", align 8
@__kcrctab_snd_pci_quirk_lookup_id = internal constant i64 ptrtoint (i8** @__crc_snd_pci_quirk_lookup_id to i64), section "___kcrctab+snd_pci_quirk_lookup_id", align 8
@__ksymtab_snd_pci_quirk_lookup_id = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_pci_quirk* (i16, i16, %struct.snd_pci_quirk*)* @snd_pci_quirk_lookup_id to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_snd_pci_quirk_lookup_id, i32 0, i32 0) }, section "___ksymtab+snd_pci_quirk_lookup_id", align 8
@__kcrctab_snd_pci_quirk_lookup = internal constant i64 ptrtoint (i8** @__crc_snd_pci_quirk_lookup to i64), section "___kcrctab+snd_pci_quirk_lookup", align 8
@__ksymtab_snd_pci_quirk_lookup = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_pci_quirk* (%struct.pci_dev*, %struct.snd_pci_quirk*)* @snd_pci_quirk_lookup to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_snd_pci_quirk_lookup, i32 0, i32 0) }, section "___ksymtab+snd_pci_quirk_lookup", align 8
@__kstrtab_snd_pci_quirk_lookup = internal constant [21 x i8] c"snd_pci_quirk_lookup\00", section "__ksymtab_strings", align 1
@__crc_snd_pci_quirk_lookup = extern_weak global i8*, align 8
@__kstrtab_snd_pci_quirk_lookup_id = internal constant [24 x i8] c"snd_pci_quirk_lookup_id\00", section "__ksymtab_strings", align 1
@__crc_snd_pci_quirk_lookup_id = extern_weak global i8*, align 8
@__kstrtab___snd_printk = internal constant [13 x i8] c"__snd_printk\00", section "__ksymtab_strings", align 1
@__snd_printk.verbose_fmt = private unnamed_addr constant [17 x i8] c"\01dALSA %s:%d %pV\00", align 16
@debug = internal global i32 2, align 4
@.str.140 = private unnamed_addr constant [3 x i8] c"\017\00", align 1
@__crc___snd_printk = extern_weak global i8*, align 8
@__kstrtab_release_and_free_resource = internal constant [26 x i8] c"release_and_free_resource\00", section "__ksymtab_strings", align 1
@__crc_release_and_free_resource = extern_weak global i8*, align 8
@__param_str_debug = internal constant [6 x i8] c"debug\00", align 1
@__kcrctab_snd_device_new = internal constant i64 ptrtoint (i8** @__crc_snd_device_new to i64), section "___kcrctab+snd_device_new", align 8
@__ksymtab_snd_device_new = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i32, i8*, %struct.snd_device_ops*)* @snd_device_new to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_snd_device_new, i32 0, i32 0) }, section "___ksymtab+snd_device_new", align 8
@__kcrctab_snd_device_free = internal constant i64 ptrtoint (i8** @__crc_snd_device_free to i64), section "___kcrctab+snd_device_free", align 8
@__ksymtab_snd_device_free = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i8*)* @snd_device_free to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_device_free, i32 0, i32 0) }, section "___ksymtab+snd_device_free", align 8
@__kcrctab_snd_device_register = internal constant i64 ptrtoint (i8** @__crc_snd_device_register to i64), section "___kcrctab+snd_device_register", align 8
@__ksymtab_snd_device_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i8*)* @snd_device_register to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_device_register, i32 0, i32 0) }, section "___ksymtab+snd_device_register", align 8
@__kstrtab_snd_device_register = internal constant [20 x i8] c"snd_device_register\00", section "__ksymtab_strings", align 1
@.str.142 = private unnamed_addr constant [20 x i8] c"sound/core/device.c\00", align 1
@.str.6.143 = private unnamed_addr constant [26 x i8] c"snd_device_register busy\0A\00", align 1
@.str.7.144 = private unnamed_addr constant [6 x i8] c"BUG?\0A\00", align 1
@__crc_snd_device_register = extern_weak global i8*, align 8
@__kstrtab_snd_device_free = internal constant [16 x i8] c"snd_device_free\00", section "__ksymtab_strings", align 1
@.str.2.145 = private unnamed_addr constant [29 x i8] c"\013device disconnect failure\0A\00", align 1
@.str.3.146 = private unnamed_addr constant [23 x i8] c"\013device free failure\0A\00", align 1
@.str.4.147 = private unnamed_addr constant [38 x i8] c"device free %p (from %pF), not found\0A\00", align 1
@__crc_snd_device_free = extern_weak global i8*, align 8
@__kstrtab_snd_device_new = internal constant [15 x i8] c"snd_device_new\00", section "__ksymtab_strings", align 1
@.str.1.151 = private unnamed_addr constant [26 x i8] c"\013Cannot allocate device\0A\00", align 1
@__crc_snd_device_new = extern_weak global i8*, align 8
@.str.5.154 = private unnamed_addr constant [44 x i8] c"device disconnect %p (from %pF), not found\0A\00", align 1
@__kcrctab_snd_dma_program = internal constant i64 ptrtoint (i8** @__crc_snd_dma_program to i64), section "___kcrctab+snd_dma_program", align 8
@__ksymtab_snd_dma_program = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i64, i64, i32, i16)* @snd_dma_program to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_dma_program, i32 0, i32 0) }, section "___ksymtab+snd_dma_program", align 8
@__kcrctab_snd_dma_disable = internal constant i64 ptrtoint (i8** @__crc_snd_dma_disable to i64), section "___kcrctab+snd_dma_disable", align 8
@__ksymtab_snd_dma_disable = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i64)* @snd_dma_disable to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_dma_disable, i32 0, i32 0) }, section "___ksymtab+snd_dma_disable", align 8
@__kcrctab_snd_dma_pointer = internal constant i64 ptrtoint (i8** @__crc_snd_dma_pointer to i64), section "___kcrctab+snd_dma_pointer", align 8
@__ksymtab_snd_dma_pointer = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i64, i32)* @snd_dma_pointer to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_dma_pointer, i32 0, i32 0) }, section "___ksymtab+snd_dma_pointer", align 8
@__kstrtab_snd_dma_pointer = internal constant [16 x i8] c"snd_dma_pointer\00", section "__ksymtab_strings", align 1
@isa_dma_bridge_buggy = external global i32, align 4
@.str.162 = private unnamed_addr constant [20 x i8] c"sound/core/isadma.c\00", align 1
@.str.1.163 = private unnamed_addr constant [68 x i8] c"\013pointer (0x%x) for DMA #%ld is greater than transfer size (0x%x)\0A\00", align 1
@dma_spin_lock = external global %struct.spinlock, align 8
@__crc_snd_dma_pointer = extern_weak global i8*, align 8
@__kstrtab_snd_dma_disable = internal constant [16 x i8] c"snd_dma_disable\00", section "__ksymtab_strings", align 1
@__crc_snd_dma_disable = extern_weak global i8*, align 8
@__kstrtab_snd_dma_program = internal constant [16 x i8] c"snd_dma_program\00", section "__ksymtab_strings", align 1
@__crc_snd_dma_program = extern_weak global i8*, align 8
@__kcrctab_snd_lookup_oss_minor_data = internal constant i64 ptrtoint (i8** @__crc_snd_lookup_oss_minor_data to i64), section "___kcrctab+snd_lookup_oss_minor_data", align 8
@__ksymtab_snd_lookup_oss_minor_data = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (i32, i32)* @snd_lookup_oss_minor_data to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_lookup_oss_minor_data, i32 0, i32 0) }, section "___ksymtab+snd_lookup_oss_minor_data", align 8
@__kcrctab_snd_register_oss_device = internal constant i64 ptrtoint (i8** @__crc_snd_register_oss_device to i64), section "___kcrctab+snd_register_oss_device", align 8
@__ksymtab_snd_register_oss_device = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32, %struct.file_operations*, i8*, i8*)* @snd_register_oss_device to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_snd_register_oss_device, i32 0, i32 0) }, section "___ksymtab+snd_register_oss_device", align 8
@__kcrctab_snd_unregister_oss_device = internal constant i64 ptrtoint (i8** @__crc_snd_unregister_oss_device to i64), section "___kcrctab+snd_unregister_oss_device", align 8
@__ksymtab_snd_unregister_oss_device = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32)* @snd_unregister_oss_device to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_unregister_oss_device, i32 0, i32 0) }, section "___ksymtab+snd_unregister_oss_device", align 8
@__kstrtab_snd_unregister_oss_device = internal constant [26 x i8] c"snd_unregister_oss_device\00", section "__ksymtab_strings", align 1
@sound_oss_mutex = internal global %struct.mutex { %union.anon.1 { i32 1 }, %struct.spinlock { %union.anon.0 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1.167, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @sound_oss_mutex to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @sound_oss_mutex to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @sound_oss_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2.168, i32 0, i32 0), i32 0, i64 0 } }, align 8
@snd_oss_minors = internal global [256 x %struct.snd_minor*] zeroinitializer, align 16
@.str.1.167 = private unnamed_addr constant [26 x i8] c"sound_oss_mutex.wait_lock\00", align 1
@.str.2.168 = private unnamed_addr constant [16 x i8] c"sound_oss_mutex\00", align 1
@.str.3.169 = private unnamed_addr constant [23 x i8] c"sound/core/sound_oss.c\00", align 1
@__crc_snd_unregister_oss_device = extern_weak global i8*, align 8
@__kstrtab_snd_register_oss_device = internal constant [24 x i8] c"snd_register_oss_device\00", section "__ksymtab_strings", align 1
@__crc_snd_register_oss_device = extern_weak global i8*, align 8
@__kstrtab_snd_lookup_oss_minor_data = internal constant [26 x i8] c"snd_lookup_oss_minor_data\00", section "__ksymtab_strings", align 1
@__crc_snd_lookup_oss_minor_data = extern_weak global i8*, align 8
@.str.175 = private unnamed_addr constant [8 x i8] c"devices\00", align 1
@snd_minor_info_oss_entry = internal global %struct.snd_info_entry* null, align 8
@.str.4.176 = private unnamed_addr constant [19 x i8] c"%3i: [%i-%2i]: %s\0A\00", align 1
@.str.5.177 = private unnamed_addr constant [17 x i8] c"%3i:       : %s\0A\00", align 1
@.str.7.178 = private unnamed_addr constant [10 x i8] c"sequencer\00", align 1
@.str.8.179 = private unnamed_addr constant [14 x i8] c"digital audio\00", align 1
@.str.11.180 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.6.181 = private unnamed_addr constant [6 x i8] c"mixer\00", align 1
@.str.9.182 = private unnamed_addr constant [9 x i8] c"raw midi\00", align 1
@.str.10.183 = private unnamed_addr constant [19 x i8] c"hardware dependent\00", align 1
@__kcrctab_snd_oss_info_register = internal constant i64 ptrtoint (i8** @__crc_snd_oss_info_register to i64), section "___kcrctab+snd_oss_info_register", align 8
@__ksymtab_snd_oss_info_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, i32, i8*)* @snd_oss_info_register to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_oss_info_register, i32 0, i32 0) }, section "___ksymtab+snd_oss_info_register", align 8
@__kstrtab_snd_oss_info_register = internal constant [22 x i8] c"snd_oss_info_register\00", section "__ksymtab_strings", align 1
@.str.187 = private unnamed_addr constant [22 x i8] c"sound/core/info_oss.c\00", align 1
@strings = internal global %struct.mutex { %union.anon.1 { i32 1 }, %struct.spinlock { %union.anon.0 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.2.188, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @strings to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @strings to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @strings to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.3.189, i32 0, i32 0), i32 0, i64 0 } }, align 8
@snd_sndstat_strings = internal global [32 x [6 x i8*]] zeroinitializer, align 16
@.str.2.188 = private unnamed_addr constant [18 x i8] c"strings.wait_lock\00", align 1
@.str.3.189 = private unnamed_addr constant [8 x i8] c"strings\00", align 1
@__crc_snd_oss_info_register = extern_weak global i8*, align 8
@.str.1.192 = private unnamed_addr constant [8 x i8] c"sndstat\00", align 1
@snd_sndstat_proc_entry = internal global %struct.snd_info_entry* null, align 8
@.str.4.193 = private unnamed_addr constant [50 x i8] c"Sound Driver:3.8.1a-980706 (ALSA emulation code)\0A\00", align 1
@.str.5.195 = private unnamed_addr constant [24 x i8] c"Kernel: %s %s %s %s %s\0A\00", align 1
@.str.6.196 = private unnamed_addr constant [19 x i8] c"Config options: 0\0A\00", align 1
@.str.7.197 = private unnamed_addr constant [22 x i8] c"\0AInstalled drivers: \0A\00", align 1
@.str.8.198 = private unnamed_addr constant [25 x i8] c"Type 10: ALSA emulation\0A\00", align 1
@.str.9.199 = private unnamed_addr constant [16 x i8] c"\0ACard config: \0A\00", align 1
@.str.10.200 = private unnamed_addr constant [14 x i8] c"Audio devices\00", align 1
@.str.11.201 = private unnamed_addr constant [14 x i8] c"Synth devices\00", align 1
@.str.12.202 = private unnamed_addr constant [13 x i8] c"Midi devices\00", align 1
@.str.13.203 = private unnamed_addr constant [7 x i8] c"Timers\00", align 1
@.str.14.204 = private unnamed_addr constant [7 x i8] c"Mixers\00", align 1
@.str.15.205 = private unnamed_addr constant [5 x i8] c"\0A%s:\00", align 1
@.str.16.206 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.17.207 = private unnamed_addr constant [8 x i8] c"%i: %s\0A\00", align 1
@.str.18.208 = private unnamed_addr constant [24 x i8] c" NOT ENABLED IN CONFIG\0A\00", align 1
@__kcrctab__snd_ctl_add_slave = internal constant i64 ptrtoint (i8** @__crc__snd_ctl_add_slave to i64), section "___kcrctab+_snd_ctl_add_slave", align 8
@__ksymtab__snd_ctl_add_slave = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_kcontrol*, %struct.snd_kcontrol*, i32)* @_snd_ctl_add_slave to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab__snd_ctl_add_slave, i32 0, i32 0) }, section "___ksymtab+_snd_ctl_add_slave", align 8
@__kcrctab_snd_ctl_make_virtual_master = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_make_virtual_master to i64), section "___kcrctab+snd_ctl_make_virtual_master", align 8
@__ksymtab_snd_ctl_make_virtual_master = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_kcontrol* (i8*, i32*)* @snd_ctl_make_virtual_master to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_snd_ctl_make_virtual_master, i32 0, i32 0) }, section "___ksymtab+snd_ctl_make_virtual_master", align 8
@__kcrctab_snd_ctl_add_vmaster_hook = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_add_vmaster_hook to i64), section "___kcrctab_gpl+snd_ctl_add_vmaster_hook", align 8
@__ksymtab_snd_ctl_add_vmaster_hook = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_kcontrol*, void (i8*, i32)*, i8*)* @snd_ctl_add_vmaster_hook to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_snd_ctl_add_vmaster_hook, i32 0, i32 0) }, section "___ksymtab_gpl+snd_ctl_add_vmaster_hook", align 8
@__kcrctab_snd_ctl_sync_vmaster_hook = internal constant i64 ptrtoint (i8** @__crc_snd_ctl_sync_vmaster_hook to i64), section "___kcrctab_gpl+snd_ctl_sync_vmaster_hook", align 8
@__ksymtab_snd_ctl_sync_vmaster_hook = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_kcontrol*)* @snd_ctl_sync_vmaster_hook to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_ctl_sync_vmaster_hook, i32 0, i32 0) }, section "___ksymtab_gpl+snd_ctl_sync_vmaster_hook", align 8
@__kstrtab_snd_ctl_sync_vmaster_hook = internal constant [26 x i8] c"snd_ctl_sync_vmaster_hook\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_sync_vmaster_hook = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_add_vmaster_hook = internal constant [25 x i8] c"snd_ctl_add_vmaster_hook\00", section "__ksymtab_strings", align 1
@__crc_snd_ctl_add_vmaster_hook = extern_weak global i8*, align 8
@__kstrtab_snd_ctl_make_virtual_master = internal constant [28 x i8] c"snd_ctl_make_virtual_master\00", section "__ksymtab_strings", align 1
@.str.215 = private unnamed_addr constant [21 x i8] c"sound/core/vmaster.c\00", align 1
@.str.1.216 = private unnamed_addr constant [25 x i8] c"\013invalid slave element\0A\00", align 1
@__crc_snd_ctl_make_virtual_master = extern_weak global i8*, align 8
@__kstrtab__snd_ctl_add_slave = internal constant [19 x i8] c"_snd_ctl_add_slave\00", section "__ksymtab_strings", align 1
@__crc__snd_ctl_add_slave = extern_weak global i8*, align 8
@__kcrctab_snd_kctl_jack_new = internal constant i64 ptrtoint (i8** @__crc_snd_kctl_jack_new to i64), section "___kcrctab_gpl+snd_kctl_jack_new", align 8
@__ksymtab_snd_kctl_jack_new = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_kcontrol* (i8*, i32, i8*)* @snd_kctl_jack_new to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_kctl_jack_new, i32 0, i32 0) }, section "___ksymtab_gpl+snd_kctl_jack_new", align 8
@__kcrctab_snd_kctl_jack_report = internal constant i64 ptrtoint (i8** @__crc_snd_kctl_jack_report to i64), section "___kcrctab_gpl+snd_kctl_jack_report", align 8
@__ksymtab_snd_kctl_jack_report = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_card*, %struct.snd_kcontrol*, i1)* @snd_kctl_jack_report to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_snd_kctl_jack_report, i32 0, i32 0) }, section "___ksymtab_gpl+snd_kctl_jack_report", align 8
@__kstrtab_snd_kctl_jack_report = internal constant [21 x i8] c"snd_kctl_jack_report\00", section "__ksymtab_strings", align 1
@__crc_snd_kctl_jack_report = extern_weak global i8*, align 8
@__kstrtab_snd_kctl_jack_new = internal constant [18 x i8] c"snd_kctl_jack_new\00", section "__ksymtab_strings", align 1
@jack_detect_kctl = internal global %struct.snd_kcontrol_new { i32 0, i32 0, i32 0, i8* null, i32 0, i32 1, i32 0, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @snd_ctl_boolean_mono_info, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @jack_detect_kctl_get, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* null, %union.anon.58 zeroinitializer, i64 0 }, align 8
@.str.219 = private unnamed_addr constant [8 x i8] c"%s Jack\00", align 1
@__crc_snd_kctl_jack_new = extern_weak global i8*, align 8
@__kcrctab_snd_jack_new = internal constant i64 ptrtoint (i8** @__crc_snd_jack_new to i64), section "___kcrctab+snd_jack_new", align 8
@__ksymtab_snd_jack_new = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i8*, i32, %struct.snd_jack**)* @snd_jack_new to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_snd_jack_new, i32 0, i32 0) }, section "___ksymtab+snd_jack_new", align 8
@__kcrctab_snd_jack_set_parent = internal constant i64 ptrtoint (i8** @__crc_snd_jack_set_parent to i64), section "___kcrctab+snd_jack_set_parent", align 8
@__ksymtab_snd_jack_set_parent = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_jack*, %struct.device*)* @snd_jack_set_parent to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_jack_set_parent, i32 0, i32 0) }, section "___ksymtab+snd_jack_set_parent", align 8
@__kcrctab_snd_jack_set_key = internal constant i64 ptrtoint (i8** @__crc_snd_jack_set_key to i64), section "___kcrctab+snd_jack_set_key", align 8
@__ksymtab_snd_jack_set_key = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_jack*, i32, i32)* @snd_jack_set_key to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_jack_set_key, i32 0, i32 0) }, section "___ksymtab+snd_jack_set_key", align 8
@__kcrctab_snd_jack_report = internal constant i64 ptrtoint (i8** @__crc_snd_jack_report to i64), section "___kcrctab+snd_jack_report", align 8
@__ksymtab_snd_jack_report = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_jack*, i32)* @snd_jack_report to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_jack_report, i32 0, i32 0) }, section "___ksymtab+snd_jack_report", align 8
@__UNIQUE_ID_author245 = internal constant [56 x i8] c"author=Mark Brown <broonie@opensource.wolfsonmicro.com>\00", section ".modinfo", align 1
@__UNIQUE_ID_description246 = internal constant [44 x i8] c"description=Jack detection support for ALSA\00", section ".modinfo", align 1
@__UNIQUE_ID_license247 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__kstrtab_snd_jack_report = internal constant [16 x i8] c"snd_jack_report\00", section "__ksymtab_strings", align 1
@jack_switch_types = internal global [6 x i32] [i32 2, i32 4, i32 6, i32 7, i32 8, i32 13], align 16
@__crc_snd_jack_report = extern_weak global i8*, align 8
@__kstrtab_snd_jack_set_key = internal constant [17 x i8] c"snd_jack_set_key\00", section "__ksymtab_strings", align 1
@.str.1.221 = private unnamed_addr constant [18 x i8] c"sound/core/jack.c\00", align 1
@__crc_snd_jack_set_key = extern_weak global i8*, align 8
@__kstrtab_snd_jack_set_parent = internal constant [20 x i8] c"snd_jack_set_parent\00", section "__ksymtab_strings", align 1
@__crc_snd_jack_set_parent = extern_weak global i8*, align 8
@__kstrtab_snd_jack_new = internal constant [13 x i8] c"snd_jack_new\00", section "__ksymtab_strings", align 1
@.str.223 = private unnamed_addr constant [5 x i8] c"ALSA\00", align 1
@snd_jack_new.ops = internal global %struct.snd_device_ops { i32 (%struct.snd_device*)* @snd_jack_dev_free, i32 (%struct.snd_device*)* @snd_jack_dev_register, i32 (%struct.snd_device*)* null }, align 8
@.str.2.224 = private unnamed_addr constant [6 x i8] c"%s %s\00", align 1
@__crc_snd_jack_new = extern_weak global i8*, align 8

@init_module = alias i32 (), i32 ()* @alsa_sound_init
@cleanup_module = alias void (), void ()* @alsa_sound_exit

; Function Attrs: nounwind uwtable
define i32 @snd_add_device_sysfs_file(i32 %type, %struct.snd_card* %card, i32 %dev, %struct.device_attribute* %attr) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  %call = call i32 @find_snd_minor(i32 %type, %struct.snd_card* %card, i32 %dev)
  %cmp = icmp sge i32 %call, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %dev1 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 5
  %1 = load %struct.device*, %struct.device** %dev1, align 8, !tbaa !6
  %cmp2 = icmp ne %struct.device* %1, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call3 = call i32 @device_create_file(%struct.device* %1, %struct.device_attribute* %attr)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %ret.0 = phi i32 [ %call3, %if.then ], [ -22, %land.lhs.true ], [ -22, %entry ]
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  ret i32 %ret.0
}

declare void @mutex_lock_nested(%struct.mutex*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @find_snd_minor(i32 %type, %struct.snd_card* %card, i32 %dev) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %0 = load i32, i32* %number, align 8, !tbaa !9
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i32 [ %0, %cond.true ], [ -1, %entry ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %minor.0 = phi i32 [ 0, %cond.end ], [ %inc, %for.inc ]
  %conv = sext i32 %minor.0 to i64
  %cmp = icmp ult i64 %conv, 256
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %1 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %cmp2 = icmp ne %struct.snd_minor* %1, null
  br i1 %cmp2, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %type4 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 0
  %2 = load i32, i32* %type4, align 8, !tbaa !22
  %cmp5 = icmp eq i32 %2, %type
  br i1 %cmp5, label %land.lhs.true7, label %for.inc

land.lhs.true7:                                   ; preds = %land.lhs.true
  %card8 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 1
  %3 = load i32, i32* %card8, align 4, !tbaa !23
  %cmp9 = icmp eq i32 %3, %cond
  br i1 %cmp9, label %land.lhs.true11, label %for.inc

land.lhs.true11:                                  ; preds = %land.lhs.true7
  %device = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 2
  %4 = load i32, i32* %device, align 8, !tbaa !24
  %cmp12 = icmp eq i32 %4, %dev
  br i1 %cmp12, label %cleanup, label %for.inc

for.inc:                                          ; preds = %land.lhs.true11, %land.lhs.true7, %land.lhs.true, %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

cleanup:                                          ; preds = %land.lhs.true11, %for.cond
  %retval.0 = phi i32 [ %minor.0, %land.lhs.true11 ], [ -1, %for.cond ]
  ret i32 %retval.0
}

declare i32 @device_create_file(%struct.device*, %struct.device_attribute*) #1

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_unregister_device(i32 %type, %struct.snd_card* %card, i32 %dev) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  %call = call i32 @find_snd_minor(i32 %type, %struct.snd_card* %card, i32 %dev)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

if.end:                                           ; preds = %entry
  %0 = load %struct.class*, %struct.class** @sound_class, align 8, !tbaa !2
  %1 = load i32, i32* @major, align 4, !tbaa !25
  %shl = shl i32 %1, 20
  %or = or i32 %shl, %call
  call void @device_destroy(%struct.class* %0, i32 %or)
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %2 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %3 = bitcast %struct.snd_minor* %2 to i8*
  call void @kfree(i8* %3)
  %idxprom1 = sext i32 %call to i64
  %arrayidx2 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom1
  store %struct.snd_minor* null, %struct.snd_minor** %arrayidx2, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ -22, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare void @device_destroy(%struct.class*, i32) #1

declare void @kfree(i8*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_register_device_for_dev(i32 %type, %struct.snd_card* %card, i32 %dev, %struct.file_operations* %f_ops, i8* %private_data, i8* %name, %struct.device* %device) #0 {
entry:
  br label %if.end18

if.end18:                                         ; preds = %entry
  %call.i = call i8* @__kmalloc(i64 48, i32 208) #8
  %0 = bitcast i8* %call.i to %struct.snd_minor*
  br label %cond.end

cond.end:                                         ; preds = %if.end18
  switch i32 %type, label %if.end3.i [
    i32 1, label %snd_find_free_minor.exit
    i32 2, label %if.then2.i
  ]

if.then2.i:                                       ; preds = %cond.end
  br label %snd_find_free_minor.exit

if.end3.i:                                        ; preds = %cond.end
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.inc.i, %if.end3.i
  %minor.0.i = phi i32 [ 0, %if.end3.i ], [ %inc.i, %for.inc.i ]
  %conv.i = sext i32 %minor.0.i to i64
  %cmp4.i = icmp ult i64 %conv.i, 256
  br i1 %cmp4.i, label %for.body.i, label %snd_find_free_minor.exit

for.body.i:                                       ; preds = %for.cond.i
  %and.i = and i32 %minor.0.i, 31
  %cmp6.i = icmp eq i32 %and.i, 0
  br i1 %cmp6.i, label %for.inc.i, label %if.end9.i

if.end9.i:                                        ; preds = %for.body.i
  switch i32 %minor.0.i, label %if.end15.i [
    i32 1, label %for.inc.i
    i32 33, label %for.inc.i
  ]

if.end15.i:                                       ; preds = %if.end9.i
  %idxprom.i = sext i32 %minor.0.i to i64
  %arrayidx.i = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom.i
  %1 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx.i, align 8, !tbaa !2
  %tobool.i = icmp ne %struct.snd_minor* %1, null
  br i1 %tobool.i, label %for.inc.i, label %snd_find_free_minor.exit

for.inc.i:                                        ; preds = %if.end15.i, %if.end9.i, %if.end9.i, %for.body.i
  %inc.i = add nsw i32 %minor.0.i, 1
  br label %for.cond.i

snd_find_free_minor.exit:                         ; preds = %if.end15.i, %for.cond.i, %if.then2.i, %cond.end
  %retval.0.i = phi i32 [ 33, %if.then2.i ], [ 1, %cond.end ], [ %minor.0.i, %if.end15.i ], [ -16, %for.cond.i ]
  br label %if.end32

if.end32:                                         ; preds = %snd_find_free_minor.exit
  %2 = load %struct.class*, %struct.class** @sound_class, align 8, !tbaa !2
  %3 = load i32, i32* @major, align 4, !tbaa !25
  %shl = shl i32 %3, 20
  %or = or i32 %shl, %retval.0.i
  %call33 = call %struct.device* (%struct.class*, %struct.device*, i32, i8*, i8*, ...) @device_create(%struct.class* %2, %struct.device* %device, i32 %or, i8* %private_data, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i32 0, i32 0), i8* %name)
  %dev34 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 5
  store %struct.device* %call33, %struct.device** %dev34, align 8, !tbaa !6
  br label %cleanup

cleanup:                                          ; preds = %if.end32
  ret i32 0
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #2

declare void @warn_slowpath_null(i8*, i32) #1

declare %struct.device* @device_create(%struct.class*, %struct.device*, i32, i8*, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @IS_ERR() #3 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @PTR_ERR() #3 {
entry:
  ret void
}

declare i8* @__kmalloc(i64, i32) #1

; Function Attrs: nounwind uwtable
define i8* @snd_lookup_minor_data(i32 %minor, i32 %type) #0 {
entry:
  %conv = zext i32 %minor to i64
  %cmp = icmp uge i64 %conv, 256
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  %idxprom = zext i32 %minor to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end
  %type2 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %1 = load i32, i32* %type2, align 8, !tbaa !22
  %cmp3 = icmp eq i32 %1, %type
  br i1 %cmp3, label %if.then5, label %if.end13

if.then5:                                         ; preds = %land.lhs.true
  %private_data6 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 4
  %2 = load i8*, i8** %private_data6, align 8, !tbaa !26
  %tobool7 = icmp ne i8* %2, null
  br i1 %tobool7, label %land.lhs.true8, label %if.end13

land.lhs.true8:                                   ; preds = %if.then5
  %card_ptr = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  %3 = load %struct.snd_card*, %struct.snd_card** %card_ptr, align 8, !tbaa !27
  %tobool9 = icmp ne %struct.snd_card* %3, null
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %land.lhs.true8
  %card_ptr11 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  %4 = load %struct.snd_card*, %struct.snd_card** %card_ptr11, align 8, !tbaa !27
  %refcount = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 27
  call void @atomic_inc(%union.anon.1* %refcount)
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %land.lhs.true8, %if.then5, %land.lhs.true, %if.end
  %private_data.0 = phi i8* [ %2, %if.then10 ], [ %2, %land.lhs.true8 ], [ %2, %if.then5 ], [ null, %land.lhs.true ], [ null, %if.end ]
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %entry
  %retval.0 = phi i8* [ %private_data.0, %if.end13 ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc(%union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !28
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_request_card(i32 %card) #0 {
entry:
  %call = call i32 @snd_card_locked(i32 %card)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp = icmp slt i32 %card, 0
  %0 = load i32, i32* @cards_limit, align 4
  %cmp1 = icmp sge i32 %card, %0
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %call4 = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0), i32 %card)
  br label %return

return:                                           ; preds = %if.end3, %if.end, %entry
  ret void
}

declare i32 @__request_module(i1 zeroext, i8*, ...) #1

; Function Attrs: nounwind uwtable
define i32 @snd_minor_info_init() #4 section ".init.text" {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.175, i32 0, i32 0), %struct.snd_info_entry* null)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.47* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_minor_info_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !29
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.then
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.then, %entry
  %entry1.1 = phi %struct.snd_info_entry* [ %call, %entry ], [ null, %if.then3 ], [ %call, %if.then ]
  store %struct.snd_info_entry* %entry1.1, %struct.snd_info_entry** @snd_minor_info_entry, align 8, !tbaa !2
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @snd_minor_info_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %minor.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %minor.0, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %card = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  %1 = load i32, i32* %card, align 4, !tbaa !23
  %cmp2 = icmp sge i32 %1, 0
  br i1 %cmp2, label %if.then3, label %if.else14

if.then3:                                         ; preds = %if.end
  %device = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 2
  %2 = load i32, i32* %device, align 8, !tbaa !24
  %cmp4 = icmp sge i32 %2, 0
  %card6 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  %3 = load i32, i32* %card6, align 4, !tbaa !23
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then3
  %device7 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 2
  %4 = load i32, i32* %device7, align 8, !tbaa !24
  %type = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %5 = load i32, i32* %type, align 8, !tbaa !22
  %call = call i8* @snd_device_type_name(i32 %5)
  %call8 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.6, i32 0, i32 0), i32 %minor.0, i32 %3, i32 %4, i8* %call)
  br label %for.inc

if.else:                                          ; preds = %if.then3
  %type10 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %6 = load i32, i32* %type10, align 8, !tbaa !22
  %call11 = call i8* @snd_device_type_name(i32 %6)
  %call12 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.7, i32 0, i32 0), i32 %minor.0, i32 %3, i8* %call11)
  br label %for.inc

if.else14:                                        ; preds = %if.end
  %type15 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %7 = load i32, i32* %type15, align 8, !tbaa !22
  %call16 = call i8* @snd_device_type_name(i32 %7)
  %call17 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8, i32 0, i32 0), i32 %minor.0, i8* %call16)
  br label %for.inc

for.inc:                                          ; preds = %if.else14, %if.else, %if.then5, %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @snd_device_type_name(i32 %type) #0 {
entry:
  %Pivot12 = icmp slt i32 %type, 3
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %type, 5
  br i1 %Pivot10, label %NodeBlock3, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %type, 6
  br i1 %Pivot8, label %return, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %type, 6
  br i1 %SwitchLeaf6, label %return, label %sw.default

NodeBlock3:                                       ; preds = %NodeBlock9
  %Pivot4 = icmp slt i32 %type, 4
  %. = select i1 %Pivot4, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.10.183, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.182, i32 0, i32 0)
  br label %return

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %type, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %type, 2
  %.13 = select i1 %Pivot, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7.178, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15, i32 0, i32 0)
  br label %return

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %type, 0
  br i1 %SwitchLeaf, label %return, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock5
  br label %return

return:                                           ; preds = %sw.default, %LeafBlock, %NodeBlock, %NodeBlock3, %LeafBlock5, %NodeBlock7
  %retval.0 = phi i8* [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11.180, i32 0, i32 0), %sw.default ], [ %., %NodeBlock3 ], [ %.13, %NodeBlock ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.9, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([23 x i8], [23 x i8]* @.str.12, i32 0, i32 0), %NodeBlock7 ], [ getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13, i32 0, i32 0), %LeafBlock5 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_minor_info_done() #4 section ".exit.text" {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_minor_info_entry, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @alsa_sound_init() #4 section ".init.text" {
entry:
  %0 = load i32, i32* @major, align 4, !tbaa !25
  store i32 %0, i32* @snd_major, align 4, !tbaa !25
  %1 = load i32, i32* @cards_limit, align 4, !tbaa !25
  store i32 %1, i32* @snd_ecards_limit, align 4, !tbaa !25
  %2 = load i32, i32* @major, align 4, !tbaa !25
  %call = call i32 @register_chrdev(i32 %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.17, i32 0, i32 0), %struct.file_operations* @snd_fops)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* @major, align 4, !tbaa !25
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.1, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.18, i32 0, i32 0), i32 %3)
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @snd_info_init()
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %4 = load i32, i32* @major, align 4, !tbaa !25
  call void @unregister_chrdev(i32 %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.17, i32 0, i32 0))
  br label %return

if.end3:                                          ; preds = %if.end
  %call4 = call i32 @snd_info_minor_register()
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %retval.0 = phi i32 [ -5, %if.then ], [ -12, %if.then2 ], [ 0, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @register_chrdev(i32 %major, i8* %name, %struct.file_operations* %fops) #3 {
entry:
  %call = call i32 @__register_chrdev(i32 %major, i32 0, i32 256, i8* %name, %struct.file_operations* %fops)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
declare void @unregister_chrdev(i32, i8*) #3

declare void @__unregister_chrdev(i32, i32, i32, i8*) #1

declare i32 @__register_chrdev(i32, i32, i32, i8*, %struct.file_operations*) #1

declare i64 @noop_llseek(%struct.file*, i64, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i32 @iminor(%struct.inode* %inode)
  %conv = zext i32 %call to i64
  %cmp = icmp uge i64 %conv, 256
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  %idxprom = zext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %cmp2 = icmp eq %struct.snd_minor* %0, null
  br i1 %cmp2, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %call5 = call %struct.snd_minor* @autoload_device(i32 %call)
  %tobool = icmp ne %struct.snd_minor* %call5, null
  br i1 %tobool, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.then4
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

if.end8:                                          ; preds = %if.then4, %if.end
  %mptr.0 = phi %struct.snd_minor* [ %0, %if.end ], [ %call5, %if.then4 ]
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %1 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8, !tbaa !30
  %f_ops = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %mptr.0, i32 0, i32 3
  %2 = load %struct.file_operations*, %struct.file_operations** %f_ops, align 8, !tbaa !37
  %tobool9 = icmp ne %struct.file_operations* %2, null
  br i1 %tobool9, label %land.lhs.true, label %cond.end

land.lhs.true:                                    ; preds = %if.end8
  %f_ops10 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %mptr.0, i32 0, i32 3
  %3 = load %struct.file_operations*, %struct.file_operations** %f_ops10, align 8, !tbaa !37
  %owner = getelementptr inbounds %struct.file_operations, %struct.file_operations* %3, i32 0, i32 0
  %4 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !38
  %call11 = call zeroext i1 @try_module_get(%struct.module* %4)
  br i1 %call11, label %cond.true, label %cond.end

cond.true:                                        ; preds = %land.lhs.true
  %f_ops13 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %mptr.0, i32 0, i32 3
  %5 = load %struct.file_operations*, %struct.file_operations** %f_ops13, align 8, !tbaa !37
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %land.lhs.true, %if.end8
  %cond = phi %struct.file_operations* [ %5, %cond.true ], [ null, %land.lhs.true ], [ null, %if.end8 ]
  %f_op14 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  store %struct.file_operations* %cond, %struct.file_operations** %f_op14, align 8, !tbaa !30
  %f_op15 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %6 = load %struct.file_operations*, %struct.file_operations** %f_op15, align 8, !tbaa !30
  %cmp16 = icmp eq %struct.file_operations* %6, null
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %cond.end
  %f_op19 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  store %struct.file_operations* %1, %struct.file_operations** %f_op19, align 8, !tbaa !30
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %cond.end
  %err.0 = phi i32 [ -19, %if.then18 ], [ 0, %cond.end ]
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  %cmp21 = icmp slt i32 %err.0, 0
  br i1 %cmp21, label %cleanup, label %if.end24

if.end24:                                         ; preds = %if.end20
  %f_op25 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %7 = load %struct.file_operations*, %struct.file_operations** %f_op25, align 8, !tbaa !30
  %open = getelementptr inbounds %struct.file_operations, %struct.file_operations* %7, i32 0, i32 11
  %8 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %open, align 8, !tbaa !40
  %tobool26 = icmp ne i32 (%struct.inode*, %struct.file*)* %8, null
  br i1 %tobool26, label %if.then27, label %do.body51

if.then27:                                        ; preds = %if.end24
  %f_op28 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %9 = load %struct.file_operations*, %struct.file_operations** %f_op28, align 8, !tbaa !30
  %open29 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %9, i32 0, i32 11
  %10 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %open29, align 8, !tbaa !40
  %call30 = call i32 %10(%struct.inode* %inode, %struct.file* %file)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %do.body, label %do.body51

do.body:                                          ; preds = %if.then27
  %f_op33 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %11 = load %struct.file_operations*, %struct.file_operations** %f_op33, align 8, !tbaa !30
  %tobool34 = icmp ne %struct.file_operations* %11, null
  br i1 %tobool34, label %if.then35, label %do.end

if.then35:                                        ; preds = %do.body
  %f_op36 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %12 = load %struct.file_operations*, %struct.file_operations** %f_op36, align 8, !tbaa !30
  %owner37 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %12, i32 0, i32 0
  %13 = load %struct.module*, %struct.module** %owner37, align 8, !tbaa !38
  call void @module_put(%struct.module* %13)
  br label %do.end

do.end:                                           ; preds = %if.then35, %do.body
  %tobool39 = icmp ne %struct.file_operations* %1, null
  br i1 %tobool39, label %land.lhs.true40, label %cond.false45

land.lhs.true40:                                  ; preds = %do.end
  %owner41 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %1, i32 0, i32 0
  %14 = load %struct.module*, %struct.module** %owner41, align 8, !tbaa !38
  %call42 = call zeroext i1 @try_module_get(%struct.module* %14)
  br i1 %call42, label %cond.end46, label %cond.false45

cond.false45:                                     ; preds = %land.lhs.true40, %do.end
  br label %cond.end46

cond.end46:                                       ; preds = %cond.false45, %land.lhs.true40
  %cond47 = phi %struct.file_operations* [ null, %cond.false45 ], [ %1, %land.lhs.true40 ]
  %f_op48 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  store %struct.file_operations* %cond47, %struct.file_operations** %f_op48, align 8, !tbaa !30
  br label %do.body51

do.body51:                                        ; preds = %cond.end46, %if.then27, %if.end24
  %err.1 = phi i32 [ %err.0, %if.end24 ], [ %call30, %cond.end46 ], [ %call30, %if.then27 ]
  %tobool52 = icmp ne %struct.file_operations* %1, null
  br i1 %tobool52, label %if.then53, label %cleanup

if.then53:                                        ; preds = %do.body51
  %owner54 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %1, i32 0, i32 0
  %15 = load %struct.module*, %struct.module** %owner54, align 8, !tbaa !38
  call void @module_put(%struct.module* %15)
  br label %cleanup

cleanup:                                          ; preds = %if.then53, %do.body51, %if.end20, %if.then6, %entry
  %retval.0 = phi i32 [ -19, %if.then6 ], [ -19, %entry ], [ %err.0, %if.end20 ], [ %err.1, %if.then53 ], [ %err.1, %do.body51 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @iminor(%struct.inode* %inode) #3 {
entry:
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %0 = load i32, i32* %i_rdev, align 4, !tbaa !41
  %and = and i32 %0, 1048575
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal %struct.snd_minor* @autoload_device(i32 %minor) #0 {
entry:
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  %and = and i32 %minor, 31
  switch i32 %and, label %if.end6 [
    i32 0, label %if.then
    i32 1, label %if.then4
  ]

if.then:                                          ; preds = %entry
  %shr = lshr i32 %minor, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %0 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %cmp1 = icmp eq %struct.snd_card* %0, null
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.then
  call void @snd_request_card(i32 %shr)
  br label %if.end6

if.then4:                                         ; preds = %entry
  call void @snd_request_other(i32 %minor)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.then2, %if.then, %entry
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  %idxprom7 = zext i32 %minor to i64
  %arrayidx8 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom7
  %1 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx8, align 8, !tbaa !2
  ret %struct.snd_minor* %1
}

declare zeroext i1 @try_module_get(%struct.module*) #1

declare void @module_put(%struct.module*) #1

; Function Attrs: nounwind uwtable
define internal void @snd_request_other(i32 %minor) #0 {
entry:
  %Pivot = icmp slt i32 %minor, 33
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %minor, 33
  br i1 %SwitchLeaf2, label %sw.epilog, label %cleanup.cont

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %minor, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %cleanup.cont

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %str.0 = phi i8* [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.19, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.20, i32 0, i32 0), %LeafBlock1 ]
  %call = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* %str.0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %sw.epilog, %LeafBlock, %LeafBlock1
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @alsa_sound_exit() #4 section ".exit.text" {
entry:
  %0 = load i32, i32* @major, align 4, !tbaa !25
  call void @unregister_chrdev(i32 %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.17, i32 0, i32 0))
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_power_wait(%struct.snd_card* %card, i32 %power_state) #0 {
entry:
  %wait = alloca %struct.__wait_queue, align 8
  %__ret = alloca i64, align 8
  %call = call i32 @snd_power_get_state(%struct.snd_card* %card)
  %cmp = icmp eq i32 %call, %power_state
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !50
  call void @init_waitqueue_entry(%struct.__wait_queue* %wait, %struct.task_struct* %0)
  %power_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 32
  call void @add_wait_queue(%struct.__wait_queue_head* %power_sleep, %struct.__wait_queue* %wait)
  br label %while.cond

while.cond:                                       ; preds = %do.body, %if.end
  %shutdown = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 24
  %1 = load i32, i32* %shutdown, align 8, !tbaa !51
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %while.end, label %if.end3

if.end3:                                          ; preds = %while.cond
  %call4 = call i32 @snd_power_get_state(%struct.snd_card* %card)
  %cmp5 = icmp eq i32 %call4, %power_state
  br i1 %cmp5, label %while.end, label %do.body

do.body:                                          ; preds = %if.end3
  store volatile i64 2, i64* %__ret, align 8, !tbaa !52
  %2 = load volatile i64, i64* %__ret, align 8, !tbaa !52
  %3 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !50
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %3, i32 0, i32 0
  %4 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state, i64 %2, i64* %state) #8, !srcloc !53
  store volatile i64 %4, i64* %__ret, align 8, !tbaa !52
  %5 = load volatile i64, i64* %__ret, align 8, !tbaa !52
  call void @snd_power_unlock(%struct.snd_card* %card)
  %call9 = call i64 @schedule_timeout(i64 7500)
  call void @snd_power_lock(%struct.snd_card* %card)
  br label %while.cond

while.end:                                        ; preds = %if.end3, %while.cond
  %result.0 = phi i32 [ -19, %while.cond ], [ 0, %if.end3 ]
  %power_sleep10 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 32
  call void @remove_wait_queue(%struct.__wait_queue_head* %power_sleep10, %struct.__wait_queue* %wait)
  br label %cleanup

cleanup:                                          ; preds = %while.end, %entry
  %retval.0 = phi i32 [ %result.0, %while.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #5

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @snd_power_get_state(%struct.snd_card* %card) #3 {
entry:
  %power_state = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 30
  %0 = load i32, i32* %power_state, align 8, !tbaa !54
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_waitqueue_entry(%struct.__wait_queue* %q, %struct.task_struct* %p) #3 {
entry:
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !55
  %0 = bitcast %struct.task_struct* %p to i8*
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 1
  store i8* %0, i8** %private, align 8, !tbaa !57
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !58
  ret void
}

declare void @add_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #5

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_power_unlock(%struct.snd_card* %card) #3 {
entry:
  %power_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 31
  call void @mutex_unlock(%struct.mutex* %power_lock)
  ret void
}

declare i64 @schedule_timeout(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_power_lock(%struct.snd_card* %card) #3 {
entry:
  %power_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 31
  call void @mutex_lock_nested(%struct.mutex* %power_lock, i32 0)
  ret void
}

declare void @remove_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

declare i32 @default_wake_function(%struct.__wait_queue*, i32, i32, i8*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_card_file_remove(%struct.snd_card* %card, %struct.file* %file) #0 {
entry:
  %files_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  call void @spin_lock(%struct.spinlock* %files_lock)
  %files_list = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list13.sink = phi %struct.list_head* [ %list4, %for.inc ], [ %files_list, %entry ]
  %next14 = getelementptr inbounds %struct.list_head, %struct.list_head* %list13.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next14, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %1, i64 -32
  %2 = bitcast i8* %add.ptr16 to %struct.snd_monitor_file*
  %list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 3
  %files_list1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %cmp = icmp ne %struct.list_head* %list, %files_list1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %file2 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 0
  %3 = load %struct.file*, %struct.file** %file2, align 8, !tbaa !59
  %cmp3 = icmp eq %struct.file* %3, %file
  %list4 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 3
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_del(%struct.list_head* %list4)
  call void @spin_lock(%struct.spinlock* @shutdown_lock)
  %shutdown_list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 2
  call void @list_del(%struct.list_head* %shutdown_list)
  call void @spin_unlock(%struct.spinlock* @shutdown_lock)
  %disconnected_f_op = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 1
  %4 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op, align 8, !tbaa !61
  %tobool = icmp ne %struct.file_operations* %4, null
  br i1 %tobool, label %do.body, label %for.end

do.body:                                          ; preds = %if.then
  %disconnected_f_op6 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 1
  %5 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op6, align 8, !tbaa !61
  %tobool7 = icmp ne %struct.file_operations* %5, null
  br i1 %tobool7, label %if.then8, label %for.end

if.then8:                                         ; preds = %do.body
  %disconnected_f_op9 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 1
  %6 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op9, align 8, !tbaa !61
  %owner = getelementptr inbounds %struct.file_operations, %struct.file_operations* %6, i32 0, i32 0
  %7 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !38
  call void @module_put(%struct.module* %7)
  br label %for.end

for.inc:                                          ; preds = %for.body
  br label %for.cond

for.end:                                          ; preds = %if.then8, %do.body, %if.then, %for.cond
  %found.0 = phi %struct.snd_monitor_file* [ %2, %do.body ], [ %2, %if.then8 ], [ %2, %if.then ], [ null, %for.cond ]
  %files_lock17 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  call void @spin_unlock(%struct.spinlock* %files_lock17)
  %tobool18 = icmp ne %struct.snd_monitor_file* %found.0, null
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %for.end
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.23, i32 0, i32 0), %struct.file* %file)
  br label %cleanup

if.end20:                                         ; preds = %for.end
  %8 = bitcast %struct.snd_monitor_file* %found.0 to i8*
  call void @kfree(i8* %8)
  call void @snd_card_unref(%struct.snd_card* %card)
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %if.then19
  %retval.0 = phi i32 [ 0, %if.end20 ], [ -2, %if.then19 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @list_del(%struct.list_head*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_card_unref(%struct.snd_card* %card) #0 {
entry:
  %refcount = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  %call = call i32 @atomic_dec_and_test(%union.anon.1* %refcount)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %shutdown_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @__wake_up(%struct.__wait_queue_head* %shutdown_sleep, i32 3, i32 1, i8* null)
  %free_on_last_close = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 25
  %0 = load i32, i32* %free_on_last_close, align 4, !tbaa !62
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.then
  call void @snd_card_do_free(%struct.snd_card* %card)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test(%union.anon.1* %v) #3 {
entry:
  %c = alloca i8, align 1
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #8, !srcloc !63
  %0 = load i8, i8* %c, align 1, !tbaa !29
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @snd_card_do_free(%struct.snd_card* %card) #0 {
entry:
  %0 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %tobool = icmp ne i32 (%struct.snd_card*, i32)* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %call = call i32 %1(%struct.snd_card* %card, i32 2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call1 = call i32 @snd_device_free_all(%struct.snd_card* %card, i32 0)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.28, i32 0, i32 0))
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %call4 = call i32 @snd_device_free_all(%struct.snd_card* %card, i32 1)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.29, i32 0, i32 0))
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end3
  %call8 = call i32 @snd_device_free_all(%struct.snd_card* %card, i32 2)
  %cmp9 = icmp slt i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.30, i32 0, i32 0))
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end7
  %private_free = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 9
  %2 = load void (%struct.snd_card*)*, void (%struct.snd_card*)** %private_free, align 8, !tbaa !64
  %tobool12 = icmp ne void (%struct.snd_card*)* %2, null
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  %private_free14 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 9
  %3 = load void (%struct.snd_card*)*, void (%struct.snd_card*)** %private_free14, align 8, !tbaa !64
  call void %3(%struct.snd_card* %card)
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end11
  %proc_id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 19
  %4 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_id, align 8, !tbaa !65
  call void @snd_info_free_entry(%struct.snd_info_entry* %4)
  %call16 = call i32 @snd_info_card_free(%struct.snd_card* %card)
  %cmp17 = icmp slt i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.31, i32 0, i32 0))
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end15
  %5 = bitcast %struct.snd_card* %card to i8*
  call void @kfree(i8* %5)
  ret void
}

declare void @_raw_spin_unlock(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @_raw_spin_lock(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define i32 @snd_card_file_add(%struct.snd_card* %card, %struct.file* %file) #0 {
entry:
  %call.i = call i8* @__kmalloc(i64 48, i32 208) #8
  %0 = bitcast i8* %call.i to %struct.snd_monitor_file*
  %cmp = icmp eq %struct.snd_monitor_file* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %file1 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %0, i32 0, i32 0
  store %struct.file* %file, %struct.file** %file1, align 8, !tbaa !59
  %disconnected_f_op = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %0, i32 0, i32 1
  store %struct.file_operations* null, %struct.file_operations** %disconnected_f_op, align 8, !tbaa !61
  %shutdown_list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %0, i32 0, i32 2
  call void @INIT_LIST_HEAD(%struct.list_head* %shutdown_list)
  %files_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  call void @spin_lock(%struct.spinlock* %files_lock)
  %shutdown = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 24
  %1 = load i32, i32* %shutdown, align 8, !tbaa !51
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %files_lock3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  call void @spin_unlock(%struct.spinlock* %files_lock3)
  %2 = bitcast %struct.snd_monitor_file* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %0, i32 0, i32 3
  %files_list = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  call void @list_add(%struct.list_head* %list, %struct.list_head* %files_list)
  %refcount = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  call void @atomic_inc.23(%union.anon.1* %refcount)
  %files_lock5 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  call void @spin_unlock(%struct.spinlock* %files_lock5)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.then2, %entry
  %retval.0 = phi i32 [ -19, %if.then2 ], [ 0, %if.end4 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !66
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !67
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !66
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.23(%union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !68
  ret void
}

declare void @__list_add(%struct.list_head*, %struct.list_head*, %struct.list_head*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_component_add(%struct.snd_card* %card, i8* %component) #0 {
entry:
  %call = call i64 @strlen(i8* %component)
  %conv = trunc i64 %call to i32
  %components = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 6
  %arraydecay = getelementptr inbounds [128 x i8], [128 x i8]* %components, i32 0, i32 0
  %call1 = call i8* @strstr(i8* %arraydecay, i8* %component)
  %cmp = icmp ne i8* %call1, null
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds i8, i8* %call1, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !29
  %conv3 = sext i8 %0 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %idxprom6 = sext i32 %conv to i64
  %arrayidx7 = getelementptr inbounds i8, i8* %call1, i64 %idxprom6
  %1 = load i8, i8* %arrayidx7, align 1, !tbaa !29
  %conv8 = sext i8 %1 to i32
  %cmp9 = icmp eq i32 %conv8, 32
  br i1 %cmp9, label %cleanup, label %if.end12

if.end12:                                         ; preds = %lor.lhs.false, %entry
  %components13 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 6
  %arraydecay14 = getelementptr inbounds [128 x i8], [128 x i8]* %components13, i32 0, i32 0
  %call15 = call i64 @strlen(i8* %arraydecay14)
  %add = add i64 %call15, 1
  %conv16 = sext i32 %conv to i64
  %add17 = add i64 %add, %conv16
  %add18 = add i64 %add17, 1
  %cmp19 = icmp ugt i64 %add18, 128
  br i1 %cmp19, label %if.then21, label %if.end34

if.then21:                                        ; preds = %if.end12
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot22 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot22 to i32
  %conv23 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool24 = icmp ne i64 %expval, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.then21
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 866, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7.144, i32 0, i32 0))
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %if.then21
  br label %cleanup

if.end34:                                         ; preds = %if.end12
  %components35 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 6
  %arrayidx36 = getelementptr inbounds [128 x i8], [128 x i8]* %components35, i64 0, i64 0
  %2 = load i8, i8* %arrayidx36, align 4, !tbaa !29
  %conv37 = sext i8 %2 to i32
  %cmp38 = icmp ne i32 %conv37, 0
  br i1 %cmp38, label %if.then40, label %if.end44

if.then40:                                        ; preds = %if.end34
  %components41 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 6
  %arraydecay42 = getelementptr inbounds [128 x i8], [128 x i8]* %components41, i32 0, i32 0
  %call43 = call i8* @strcat(i8* %arraydecay42, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.22, i32 0, i32 0))
  br label %if.end44

if.end44:                                         ; preds = %if.then40, %if.end34
  %components45 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 6
  %arraydecay46 = getelementptr inbounds [128 x i8], [128 x i8]* %components45, i32 0, i32 0
  %call47 = call i8* @strcat(i8* %arraydecay46, i8* %component)
  br label %cleanup

cleanup:                                          ; preds = %if.end44, %if.end26, %lor.lhs.false, %if.then
  %retval.0 = phi i32 [ -12, %if.end26 ], [ 0, %if.end44 ], [ 1, %lor.lhs.false ], [ 1, %if.then ]
  ret i32 %retval.0
}

declare i64 @strlen(i8*) #1

declare i8* @strstr(i8*, i8*) #1

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #1

declare i8* @strcat(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_card_register(%struct.snd_card* %card) #0 {
entry:
  %tmpid = alloca [16 x i8], align 16
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 686)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %0 = load %struct.device*, %struct.device** %card_dev, align 8, !tbaa !69
  %tobool19 = icmp ne %struct.device* %0, null
  br i1 %tobool19, label %if.end28, label %if.then20

if.then20:                                        ; preds = %if.end18
  %1 = load %struct.class*, %struct.class** @sound_class, align 8, !tbaa !2
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 28
  %2 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !70
  %3 = bitcast %struct.snd_card* %card to i8*
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %4 = load i32, i32* %number, align 8, !tbaa !9
  %call = call %struct.device* (%struct.class*, %struct.device*, i32, i8*, i8*, ...) @device_create(%struct.class* %1, %struct.device* %2, i32 0, i8* %3, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.14.93, i32 0, i32 0), i32 %4)
  %card_dev21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  store %struct.device* %call, %struct.device** %card_dev21, align 8, !tbaa !69
  %card_dev22 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %5 = load %struct.device*, %struct.device** %card_dev22, align 8, !tbaa !69
  %6 = bitcast %struct.device* %5 to i8*
  %call23 = call i64 @IS_ERR.26(i8* %6)
  %tobool24 = icmp ne i64 %call23, 0
  br i1 %tobool24, label %if.then25, label %if.end28

if.then25:                                        ; preds = %if.then20
  %card_dev26 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  store %struct.device* null, %struct.device** %card_dev26, align 8, !tbaa !69
  br label %if.end28

if.end28:                                         ; preds = %if.then25, %if.then20, %if.end18
  %call29 = call i32 @snd_device_register_all(%struct.snd_card* %card)
  %cmp = icmp slt i32 %call29, 0
  br i1 %cmp, label %cleanup, label %if.end32

if.end32:                                         ; preds = %if.end28
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %number33 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %7 = load i32, i32* %number33, align 8, !tbaa !9
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %8 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %tobool34 = icmp ne %struct.snd_card* %8, null
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end32
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  br label %cleanup

if.end36:                                         ; preds = %if.end32
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %9 = load i8, i8* %arraydecay, align 4, !tbaa !29
  %tobool37 = icmp ne i8 %9, 0
  br i1 %tobool37, label %if.then38, label %if.else53

if.then38:                                        ; preds = %if.end36
  %cmp39 = icmp uge i64 16, 64
  %arraydecay42 = getelementptr inbounds [16 x i8], [16 x i8]* %tmpid, i32 0, i32 0
  %id43 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay44 = getelementptr inbounds [16 x i8], [16 x i8]* %id43, i32 0, i32 0
  br i1 %cmp39, label %if.then41, label %if.else

if.then41:                                        ; preds = %if.then38
  %call45 = call i8* @__memcpy(i8* %arraydecay42, i8* %arraydecay44, i64 16)
  br label %if.end49

if.else:                                          ; preds = %if.then38
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay42, i8* %arraydecay44, i64 16, i32 4, i1 false)
  br label %if.end49

if.end49:                                         ; preds = %if.else, %if.then41
  %arraydecay51 = getelementptr inbounds [16 x i8], [16 x i8]* %tmpid, i32 0, i32 0
  %arraydecay52 = getelementptr inbounds [16 x i8], [16 x i8]* %tmpid, i32 0, i32 0
  call void @snd_card_set_id_no_lock(%struct.snd_card* %card, i8* %arraydecay51, i8* %arraydecay52)
  br label %if.end61

if.else53:                                        ; preds = %if.end36
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 3
  %arraydecay54 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  %10 = load i8, i8* %arraydecay54, align 4, !tbaa !29
  %conv55 = sext i8 %10 to i32
  %tobool56 = icmp ne i32 %conv55, 0
  %shortname57 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 3
  %arraydecay58 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname57, i32 0, i32 0
  %longname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 4
  %arraydecay59 = getelementptr inbounds [80 x i8], [80 x i8]* %longname, i32 0, i32 0
  %cond = select i1 %tobool56, i8* %arraydecay58, i8* %arraydecay59
  %call60 = call i8* @retrieve_id_from_card_name(i8* %cond)
  call void @snd_card_set_id_no_lock(%struct.snd_card* %card, i8* %cond, i8* %call60)
  br label %if.end61

if.end61:                                         ; preds = %if.else53, %if.end49
  %number62 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %11 = load i32, i32* %number62, align 8, !tbaa !9
  %idxprom63 = sext i32 %11 to i64
  %arrayidx64 = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom63
  store %struct.snd_card* %card, %struct.snd_card** %arrayidx64, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  call void @init_info_for_card(%struct.snd_card* %card)
  %12 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %tobool66 = icmp ne i32 (%struct.snd_card*, i32)* %12, null
  br i1 %tobool66, label %if.then67, label %if.end69

if.then67:                                        ; preds = %if.end61
  %13 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %call68 = call i32 %13(%struct.snd_card* %card, i32 0)
  br label %if.end69

if.end69:                                         ; preds = %if.then67, %if.end61
  %card_dev70 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %14 = load %struct.device*, %struct.device** %card_dev70, align 8, !tbaa !69
  %tobool71 = icmp ne %struct.device* %14, null
  br i1 %tobool71, label %if.then72, label %if.end85

if.then72:                                        ; preds = %if.end69
  %card_dev73 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %15 = load %struct.device*, %struct.device** %card_dev73, align 8, !tbaa !69
  %call74 = call i32 @device_create_file(%struct.device* %15, %struct.device_attribute* @card_id_attrs)
  %cmp75 = icmp slt i32 %call74, 0
  br i1 %cmp75, label %cleanup, label %if.end78

if.end78:                                         ; preds = %if.then72
  %card_dev79 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %16 = load %struct.device*, %struct.device** %card_dev79, align 8, !tbaa !69
  %call80 = call i32 @device_create_file(%struct.device* %16, %struct.device_attribute* @card_number_attrs)
  %cmp81 = icmp slt i32 %call80, 0
  br i1 %cmp81, label %cleanup, label %if.end85

if.end85:                                         ; preds = %if.end78, %if.end69
  br label %cleanup

cleanup:                                          ; preds = %if.end85, %if.end78, %if.then72, %if.then35, %if.end28, %if.end
  %retval.0 = phi i32 [ 0, %if.then35 ], [ 0, %if.end85 ], [ -22, %if.end ], [ %call29, %if.end28 ], [ %call74, %if.then72 ], [ %call80, %if.end78 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.26(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

declare i8* @__memcpy(i8*, i8*, i64) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #5

; Function Attrs: nounwind uwtable
define internal void @snd_card_set_id_no_lock(%struct.snd_card* %card, i8* %src, i8* %nid) #0 {
entry:
  call void @copy_valid_id_string(%struct.snd_card* %card, i8* %src, i8* %nid)
  %id1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id1, i32 0, i32 0
  br label %again

again:                                            ; preds = %if.then33, %entry
  %is_default.0 = phi i8 [ 0, %entry ], [ %is_default.1, %if.then33 ]
  %0 = load i8, i8* %arraydecay, align 1, !tbaa !29
  %tobool = icmp ne i8 %0, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %again
  %call = call i32 @strncmp(i8* %arraydecay, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11.73, i32 0, i32 0), i64 4)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %again
  %call3 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.33, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %is_default.1 = phi i8 [ %is_default.0, %lor.lhs.false ], [ 1, %if.then ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %loops.0 = phi i32 [ 0, %if.end ], [ %inc31, %for.inc ]
  %with_suffix.0 = phi i8 [ 0, %if.end ], [ %with_suffix.1, %for.inc ]
  %cmp = icmp slt i32 %loops.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call4 = call zeroext i1 @card_id_ok(%struct.snd_card* %card, i8* %arraydecay)
  br i1 %call4, label %cleanup.cont, label %if.end6

if.end6:                                          ; preds = %for.body
  %call7 = call i64 @strlen(i8* %arraydecay)
  %conv = trunc i64 %call7 to i32
  %tobool8 = trunc i8 %with_suffix.0 to i1
  br i1 %tobool8, label %if.else, label %if.then9

if.then9:                                         ; preds = %if.end6
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 %idx.ext
  %conv10 = sext i32 %conv to i64
  %cmp11 = icmp ugt i64 %conv10, 13
  %add.ptr14 = getelementptr inbounds i8, i8* %arraydecay, i64 16
  %add.ptr15 = getelementptr inbounds i8, i8* %add.ptr14, i64 -3
  %spos.0 = select i1 %cmp11, i8* %add.ptr15, i8* %add.ptr
  %call17 = call i8* @strcpy(i8* %spos.0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.34, i32 0, i32 0))
  br label %for.inc

if.else:                                          ; preds = %if.end6
  %sub = sub nsw i32 %conv, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds i8, i8* %arraydecay, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !29
  %conv18 = sext i8 %1 to i32
  %cmp19 = icmp ne i32 %conv18, 57
  %sub22 = sub nsw i32 %conv, 1
  %idxprom23 = sext i32 %sub22 to i64
  %arrayidx24 = getelementptr inbounds i8, i8* %arraydecay, i64 %idxprom23
  br i1 %cmp19, label %if.then21, label %if.end29

if.then21:                                        ; preds = %if.else
  %2 = load i8, i8* %arrayidx24, align 1, !tbaa !29
  %inc = add i8 %2, 1
  br label %if.end29

if.end29:                                         ; preds = %if.then21, %if.else
  %.sink = phi i8 [ %inc, %if.then21 ], [ 65, %if.else ]
  store i8 %.sink, i8* %arrayidx24, align 1, !tbaa !29
  br label %for.inc

for.inc:                                          ; preds = %if.end29, %if.then9
  %with_suffix.1 = phi i8 [ %with_suffix.0, %if.end29 ], [ 1, %if.then9 ]
  %inc31 = add nsw i32 %loops.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool32 = trunc i8 %is_default.1 to i1
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %for.end
  store i8 0, i8* %arraydecay, align 1, !tbaa !29
  br label %again

if.end34:                                         ; preds = %for.end
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.35, i32 0, i32 0), i8* %arraydecay)
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %3 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !71
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 0
  %4 = load i8*, i8** %name, align 8, !tbaa !72
  %tobool35 = icmp ne i8* %4, null
  br i1 %tobool35, label %if.then36, label %cleanup.cont

if.then36:                                        ; preds = %if.end34
  %id37 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay38 = getelementptr inbounds [16 x i8], [16 x i8]* %id37, i32 0, i32 0
  %proc_root39 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %5 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root39, align 8, !tbaa !71
  %name40 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %5, i32 0, i32 0
  %6 = load i8*, i8** %name40, align 8, !tbaa !72
  %call41 = call i8* @strcpy(i8* %arraydecay38, i8* %6)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then36, %if.end34, %for.body
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @retrieve_id_from_card_name(i8* %name) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %spos.0 = phi i8* [ %name, %entry ], [ %spos.1, %if.end ]
  %name.addr.0 = phi i8* [ %name, %entry ], [ %incdec.ptr, %if.end ]
  %0 = load i8, i8* %name.addr.0, align 1, !tbaa !29
  %tobool = icmp ne i8 %0, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i8, i8* %name.addr.0, align 1, !tbaa !29
  %conv = zext i8 %1 to i32
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !29
  %conv1 = zext i8 %2 to i32
  %and = and i32 %conv1, 32
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %arrayidx3 = getelementptr inbounds i8, i8* %name.addr.0, i64 1
  %3 = load i8, i8* %arrayidx3, align 1, !tbaa !29
  %conv4 = zext i8 %3 to i32
  %idxprom5 = sext i32 %conv4 to i64
  %arrayidx6 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom5
  %4 = load i8, i8* %arrayidx6, align 1, !tbaa !29
  %conv7 = zext i8 %4 to i32
  %and8 = and i32 %conv7, 7
  %cmp9 = icmp ne i32 %and8, 0
  %add.ptr = getelementptr inbounds i8, i8* %name.addr.0, i64 1
  %add.ptr.spos.0 = select i1 %cmp9, i8* %add.ptr, i8* %spos.0
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %while.body
  %spos.1 = phi i8* [ %spos.0, %while.body ], [ %add.ptr.spos.0, %land.lhs.true ]
  %incdec.ptr = getelementptr inbounds i8, i8* %name.addr.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret i8* %spos.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_info_for_card(%struct.snd_card* %card) #3 {
entry:
  %call = call i32 @snd_info_card_register(%struct.snd_card* %card)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 1, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.36, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !71
  %call2 = call %struct.snd_info_entry* @snd_info_create_card_entry(%struct.snd_card* %card, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.37, i32 0, i32 0), %struct.snd_info_entry* %0)
  %cmp3 = icmp eq %struct.snd_info_entry* %call2, null
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 1, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.38, i32 0, i32 0))
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call2, i32 0, i32 4
  %text = bitcast %union.anon.47* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_card_id_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !29
  %call6 = call i32 @snd_info_register(%struct.snd_info_entry* %call2)
  %cmp7 = icmp slt i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  call void @snd_info_free_entry(%struct.snd_info_entry* %call2)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end5
  %entry1.0 = phi %struct.snd_info_entry* [ null, %if.then8 ], [ %call2, %if.end5 ]
  %proc_id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 19
  store %struct.snd_info_entry* %entry1.0, %struct.snd_info_entry** %proc_id, align 8, !tbaa !65
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %if.then4, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @card_number_show_attr(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.snd_card*
  %tobool = icmp ne %struct.snd_card* %0, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 0
  %1 = load i32, i32* %number, align 8, !tbaa !9
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i32 [ %1, %cond.true ], [ -1, %entry ]
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.41, i32 0, i32 0), i32 %cond)
  %conv = sext i32 %call1 to i64
  ret i64 %conv
}

declare i8* @dev_get_drvdata(%struct.device*) #1

declare i32 @snprintf(i8*, i64, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i64 @card_id_show_attr(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.snd_card*
  %tobool = icmp ne %struct.snd_card* %0, null
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %cond = select i1 %tobool, i8* %arraydecay, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.39, i32 0, i32 0)
  %call1 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17.27, i32 0, i32 0), i8* %cond)
  %conv = sext i32 %call1 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @card_id_store_attr(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %buf1 = alloca [16 x i8], align 16
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.snd_card*
  %cmp = icmp ugt i64 %count, 15
  %.count = select i1 %cmp, i64 15, i64 %count
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %idx.0 = phi i64 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp1 = icmp ult i64 %idx.0, %.count
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 %idx.0
  %1 = load i8, i8* %arrayidx, align 1, !tbaa !29
  %conv = sext i8 %1 to i32
  %conv2 = trunc i32 %conv to i8
  %conv3 = zext i8 %conv2 to i32
  %idxprom = sext i32 %conv3 to i64
  %arrayidx4 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx4, align 1, !tbaa !29
  %conv5 = zext i8 %2 to i32
  %and = and i32 %conv5, 7
  %cmp6 = icmp eq i32 %and, 0
  br i1 %cmp6, label %switch.early.test, label %for.inc

switch.early.test:                                ; preds = %for.body
  switch i32 %conv, label %cleanup [
    i32 95, label %for.inc
    i32 45, label %for.inc
  ]

for.inc:                                          ; preds = %switch.early.test, %switch.early.test, %for.body
  %inc = add i64 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buf1, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %buf, i64 %.count, i32 1, i1 false)
  %arrayidx13 = getelementptr inbounds [16 x i8], [16 x i8]* %buf1, i64 0, i64 %.count
  store i8 0, i8* %arrayidx13, align 1, !tbaa !29
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %arraydecay14 = getelementptr inbounds [16 x i8], [16 x i8]* %buf1, i32 0, i32 0
  %call15 = call zeroext i1 @card_id_ok(%struct.snd_card* null, i8* %arraydecay14)
  br i1 %call15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %for.end
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  br label %cleanup

if.end17:                                         ; preds = %for.end
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 1
  %arraydecay18 = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buf1, i32 0, i32 0
  %call20 = call i8* @strcpy(i8* %arraydecay18, i8* %arraydecay19)
  call void @snd_info_card_id_change(%struct.snd_card* %0)
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %if.then16, %switch.early.test
  %retval.0 = phi i64 [ %count, %if.end17 ], [ -17, %if.then16 ], [ -22, %switch.early.test ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @card_id_ok(%struct.snd_card* %card, i8* %id) #0 {
entry:
  %call = call i32 @snd_info_check_reserved_words(i8* %id)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %0 = load i32, i32* @snd_ecards_limit, align 4, !tbaa !25
  %cmp = icmp slt i32 %i.0, %0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %1 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %tobool1 = icmp ne %struct.snd_card* %1, null
  br i1 %tobool1, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %idxprom2 = sext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom2
  %2 = load %struct.snd_card*, %struct.snd_card** %arrayidx3, align 8, !tbaa !2
  %cmp4 = icmp ne %struct.snd_card* %2, %card
  br i1 %cmp4, label %land.lhs.true5, label %for.inc

land.lhs.true5:                                   ; preds = %land.lhs.true
  %idxprom6 = sext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom6
  %3 = load %struct.snd_card*, %struct.snd_card** %arrayidx7, align 8, !tbaa !2
  %id8 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id8, i32 0, i32 0
  %call9 = call i32 @strcmp(i8* %arraydecay, i8* %id)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %for.inc, label %cleanup

for.inc:                                          ; preds = %land.lhs.true5, %land.lhs.true, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %land.lhs.true5, %for.cond, %entry
  %retval.0 = phi i1 [ false, %entry ], [ false, %land.lhs.true5 ], [ true, %for.cond ]
  ret i1 %retval.0
}

declare i8* @strcpy(i8*, i8*) #1

declare i32 @strcmp(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @snd_card_id_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  %card = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 6
  %0 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !74
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %call = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17.27, i32 0, i32 0), i8* %arraydecay)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @copy_valid_id_string(%struct.snd_card* %card, i8* %src, i8* %nid) #0 {
entry:
  %id1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id1, i32 0, i32 0
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %nid.addr.0 = phi i8* [ %nid, %entry ], [ %incdec.ptr, %while.body ]
  %0 = load i8, i8* %nid.addr.0, align 1, !tbaa !29
  %conv = sext i8 %0 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %while.cond
  %1 = load i8, i8* %nid.addr.0, align 1, !tbaa !29
  %conv2 = zext i8 %1 to i32
  %idxprom = sext i32 %conv2 to i64
  %arrayidx = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !29
  %conv3 = zext i8 %2 to i32
  %and = and i32 %conv3, 7
  %cmp = icmp ne i32 %and, 0
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %incdec.ptr = getelementptr inbounds i8, i8* %nid.addr.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %land.rhs, %while.cond
  %3 = load i8, i8* %nid.addr.0, align 1, !tbaa !29
  %conv5 = zext i8 %3 to i32
  %idxprom6 = sext i32 %conv5 to i64
  %arrayidx7 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom6
  %4 = load i8, i8* %arrayidx7, align 1, !tbaa !29
  %conv8 = zext i8 %4 to i32
  %and9 = and i32 %conv8, 4
  %cmp10 = icmp ne i32 %and9, 0
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %5 = load i8, i8* %src, align 1, !tbaa !29
  %conv12 = zext i8 %5 to i32
  %idxprom13 = sext i32 %conv12 to i64
  %arrayidx14 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom13
  %6 = load i8, i8* %arrayidx14, align 1, !tbaa !29
  %conv15 = zext i8 %6 to i32
  %and16 = and i32 %conv15, 3
  %cmp17 = icmp ne i32 %and16, 0
  br i1 %cmp17, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then
  %7 = load i8, i8* %src, align 1, !tbaa !29
  %conv19 = sext i8 %7 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.then
  %cond = phi i32 [ %conv19, %cond.true ], [ 68, %if.then ]
  %conv20 = trunc i32 %cond to i8
  %incdec.ptr21 = getelementptr inbounds i8, i8* %arraydecay, i32 1
  store i8 %conv20, i8* %arraydecay, align 1, !tbaa !29
  br label %if.end

if.end:                                           ; preds = %cond.end, %while.end
  %id.0 = phi i8* [ %incdec.ptr21, %cond.end ], [ %arraydecay, %while.end ]
  br label %while.cond22

while.cond22:                                     ; preds = %if.end41, %if.end
  %nid.addr.1 = phi i8* [ %nid.addr.0, %if.end ], [ %incdec.ptr42, %if.end41 ]
  %id.1 = phi i8* [ %id.0, %if.end ], [ %id.2, %if.end41 ]
  %8 = load i8, i8* %nid.addr.1, align 1, !tbaa !29
  %conv23 = sext i8 %8 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  %id26 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay27 = getelementptr inbounds [16 x i8], [16 x i8]* %id26, i32 0, i32 0
  %sub.ptr.lhs.cast = ptrtoint i8* %id.1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %arraydecay27 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp28 = icmp ult i64 %sub.ptr.sub, 15
  %9 = select i1 %tobool24, i1 %cmp28, i1 false
  br i1 %9, label %while.body31, label %while.end43

while.body31:                                     ; preds = %while.cond22
  %10 = load i8, i8* %nid.addr.1, align 1, !tbaa !29
  %conv32 = zext i8 %10 to i32
  %idxprom33 = sext i32 %conv32 to i64
  %arrayidx34 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom33
  %11 = load i8, i8* %arrayidx34, align 1, !tbaa !29
  %conv35 = zext i8 %11 to i32
  %and36 = and i32 %conv35, 7
  %cmp37 = icmp ne i32 %and36, 0
  br i1 %cmp37, label %if.then39, label %if.end41

if.then39:                                        ; preds = %while.body31
  %12 = load i8, i8* %nid.addr.1, align 1, !tbaa !29
  %incdec.ptr40 = getelementptr inbounds i8, i8* %id.1, i32 1
  store i8 %12, i8* %id.1, align 1, !tbaa !29
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %while.body31
  %id.2 = phi i8* [ %incdec.ptr40, %if.then39 ], [ %id.1, %while.body31 ]
  %incdec.ptr42 = getelementptr inbounds i8, i8* %nid.addr.1, i32 1
  br label %while.cond22

while.end43:                                      ; preds = %while.cond22
  store i8 0, i8* %id.1, align 1, !tbaa !29
  ret void
}

declare i32 @strncmp(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define void @snd_card_set_id(%struct.snd_card* %card, i8* %nid) #0 {
entry:
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arrayidx = getelementptr inbounds [16 x i8], [16 x i8]* %id, i64 0, i64 0
  %0 = load i8, i8* %arrayidx, align 4, !tbaa !29
  %conv = sext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  call void @snd_card_set_id_no_lock(%struct.snd_card* %card, i8* %nid, i8* %nid)
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_free(%struct.snd_card* %card) #0 {
entry:
  %__wait = alloca %struct.__wait_queue, align 8
  %call = call i32 @snd_card_disconnect(%struct.snd_card* %card)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %do.body

do.body:                                          ; preds = %entry
  %refcount = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  %call1 = call i32 @atomic_read(%union.anon.1* %refcount)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %do.body5, label %do.end16

do.body5:                                         ; preds = %do.body
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !55
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !50
  %1 = bitcast %struct.task_struct* %0 to i8*
  store i8* %1, i8** %private, align 8, !tbaa !57
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !58
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list7 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list7, %struct.list_head** %next, align 8, !tbaa !66
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list8 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list8, %struct.list_head** %prev, align 8, !tbaa !67
  br label %for.cond

for.cond:                                         ; preds = %if.end13, %do.body5
  %shutdown_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @prepare_to_wait(%struct.__wait_queue_head* %shutdown_sleep, %struct.__wait_queue* %__wait, i32 2)
  %refcount9 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  %call10 = call i32 @atomic_read(%union.anon.1* %refcount9)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end13, label %for.end

if.end13:                                         ; preds = %for.cond
  call void @schedule()
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %shutdown_sleep14 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @finish_wait(%struct.__wait_queue_head* %shutdown_sleep14, %struct.__wait_queue* %__wait)
  br label %do.end16

do.end16:                                         ; preds = %for.end, %do.body
  call void @snd_card_do_free(%struct.snd_card* %card)
  br label %cleanup

cleanup:                                          ; preds = %do.end16, %entry
  %retval.0 = phi i32 [ 0, %do.end16 ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_disconnect(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %files_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  call void @spin_lock(%struct.spinlock* %files_lock)
  %shutdown = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 24
  %0 = load i32, i32* %shutdown, align 8, !tbaa !51
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %files_lock3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  call void @spin_unlock(%struct.spinlock* %files_lock3)
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %shutdown5 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 24
  store i32 1, i32* %shutdown5, align 8, !tbaa !51
  %files_lock6 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  call void @spin_unlock(%struct.spinlock* %files_lock6)
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number, align 8, !tbaa !9
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  store %struct.snd_card* null, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %number7 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %2 = load i32, i32* %number7, align 8, !tbaa !9
  %shl = shl i32 1, %2
  %neg = xor i32 %shl, -1
  %3 = load i32, i32* @snd_cards_lock, align 4, !tbaa !25
  %and = and i32 %3, %neg
  store i32 %and, i32* @snd_cards_lock, align 4, !tbaa !25
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %files_lock8 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  call void @spin_lock(%struct.spinlock* %files_lock8)
  %files_list = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %list20.sink = phi %struct.list_head* [ %list20, %for.inc ], [ %files_list, %if.end4 ]
  %next21 = getelementptr inbounds %struct.list_head, %struct.list_head* %list20.sink, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next21, align 8, !tbaa !2
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr23 = getelementptr inbounds i8, i8* %5, i64 -32
  %6 = bitcast i8* %add.ptr23 to %struct.snd_monitor_file*
  %list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %6, i32 0, i32 3
  %files_list9 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %cmp = icmp ne %struct.list_head* %list, %files_list9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %file = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %6, i32 0, i32 0
  %7 = load %struct.file*, %struct.file** %file, align 8, !tbaa !59
  %f_op = getelementptr inbounds %struct.file, %struct.file* %7, i32 0, i32 3
  %8 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8, !tbaa !30
  %disconnected_f_op = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %6, i32 0, i32 1
  store %struct.file_operations* %8, %struct.file_operations** %disconnected_f_op, align 8, !tbaa !61
  call void @spin_lock(%struct.spinlock* @shutdown_lock)
  %shutdown_list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %6, i32 0, i32 2
  call void @list_add(%struct.list_head* %shutdown_list, %struct.list_head* @shutdown_files)
  call void @spin_unlock(%struct.spinlock* @shutdown_lock)
  %file10 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %6, i32 0, i32 0
  %9 = load %struct.file*, %struct.file** %file10, align 8, !tbaa !59
  %f_op11 = getelementptr inbounds %struct.file, %struct.file* %9, i32 0, i32 3
  store %struct.file_operations* @snd_shutdown_f_ops, %struct.file_operations** %f_op11, align 8, !tbaa !30
  %file12 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %6, i32 0, i32 0
  %10 = load %struct.file*, %struct.file** %file12, align 8, !tbaa !59
  %f_op13 = getelementptr inbounds %struct.file, %struct.file* %10, i32 0, i32 3
  %11 = load %struct.file_operations*, %struct.file_operations** %f_op13, align 8, !tbaa !30
  %tobool14 = icmp ne %struct.file_operations* %11, null
  br i1 %tobool14, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %file15 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %6, i32 0, i32 0
  %12 = load %struct.file*, %struct.file** %file15, align 8, !tbaa !59
  %f_op16 = getelementptr inbounds %struct.file, %struct.file* %12, i32 0, i32 3
  %13 = load %struct.file_operations*, %struct.file_operations** %f_op16, align 8, !tbaa !30
  %owner = getelementptr inbounds %struct.file_operations, %struct.file_operations* %13, i32 0, i32 0
  %14 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !38
  %call = call zeroext i1 @try_module_get(%struct.module* %14)
  br i1 %call, label %cond.true, label %for.inc

cond.true:                                        ; preds = %land.lhs.true
  br label %for.inc

for.inc:                                          ; preds = %cond.true, %land.lhs.true, %for.body
  %list20 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %6, i32 0, i32 3
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %files_lock24 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  call void @spin_unlock(%struct.spinlock* %files_lock24)
  %15 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %tobool25 = icmp ne i32 (%struct.snd_card*, i32)* %15, null
  br i1 %tobool25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %for.end
  %16 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %call27 = call i32 %16(%struct.snd_card* %card, i32 1)
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %for.end
  %call29 = call i32 @snd_device_disconnect_all(%struct.snd_card* %card)
  %cmp30 = icmp slt i32 %call29, 0
  br i1 %cmp30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end28
  %number32 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %17 = load i32, i32* %number32, align 8, !tbaa !9
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.15.28, i32 0, i32 0), i32 %17)
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end28
  call void @snd_info_card_disconnect(%struct.snd_card* %card)
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %18 = load %struct.device*, %struct.device** %card_dev, align 8, !tbaa !69
  %tobool34 = icmp ne %struct.device* %18, null
  br i1 %tobool34, label %if.then35, label %if.end38

if.then35:                                        ; preds = %if.end33
  %card_dev36 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %19 = load %struct.device*, %struct.device** %card_dev36, align 8, !tbaa !69
  call void @device_unregister(%struct.device* %19)
  %card_dev37 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  store %struct.device* null, %struct.device** %card_dev37, align 8, !tbaa !69
  br label %if.end38

if.end38:                                         ; preds = %if.then35, %if.end33
  %power_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 32
  call void @__wake_up(%struct.__wait_queue_head* %power_sleep, i32 3, i32 1, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.end38, %if.then2, %entry
  %retval.0 = phi i32 [ 0, %if.then2 ], [ 0, %if.end38 ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read(%union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !25
  ret i32 %0
}

declare i32 @autoremove_wake_function(%struct.__wait_queue*, i32, i32, i8*) #1

declare void @prepare_to_wait(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #1

declare void @schedule() #1

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

declare void @device_unregister(%struct.device*) #1

; Function Attrs: nounwind uwtable
define internal i64 @snd_disconnect_llseek(%struct.file* %file, i64 %offset, i32 %orig) #0 {
entry:
  ret i64 -19
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_disconnect_read(%struct.file* %file, i8* %buf, i64 %count, i64* %offset) #0 {
entry:
  ret i64 -19
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_disconnect_write(%struct.file* %file, i8* %buf, i64 %count, i64* %offset) #0 {
entry:
  ret i64 -19
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_disconnect_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  ret i32 40
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_disconnect_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  ret i64 -19
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_disconnect_mmap(%struct.file* %file, %struct.vm_area_struct* %vma) #0 {
entry:
  ret i32 -19
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_disconnect_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  call void @spin_lock(%struct.spinlock* @shutdown_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @shutdown_files, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %1, i64 -16
  %2 = bitcast i8* %add.ptr7 to %struct.snd_monitor_file*
  %shutdown_list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 2
  %cmp = icmp ne %struct.list_head* %shutdown_list, @shutdown_files
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %file1 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 0
  %3 = load %struct.file*, %struct.file** %file1, align 8, !tbaa !59
  %cmp2 = icmp eq %struct.file* %3, %file
  %shutdown_list3 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 2
  br i1 %cmp2, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_del_init(%struct.list_head* %shutdown_list3)
  br label %for.end

for.inc:                                          ; preds = %for.body
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %shutdown_list3, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %df.0 = phi %struct.snd_monitor_file* [ %2, %if.then ], [ null, %for.cond ]
  call void @spin_unlock(%struct.spinlock* @shutdown_lock)
  %tobool = icmp ne %struct.snd_monitor_file* %df.0, null
  %lnot = xor i1 %tobool, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %if.end19

if.then10:                                        ; preds = %for.end
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %4 = load i32, i32* %f_flags, align 8, !tbaa !75
  %and = and i32 %4, 8192
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.then10
  %disconnected_f_op = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %df.0, i32 0, i32 1
  %5 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op, align 8, !tbaa !61
  %fasync = getelementptr inbounds %struct.file_operations, %struct.file_operations* %5, i32 0, i32 16
  %6 = load i32 (i32, %struct.file*, i32)*, i32 (i32, %struct.file*, i32)** %fasync, align 8, !tbaa !76
  %tobool12 = icmp ne i32 (i32, %struct.file*, i32)* %6, null
  br i1 %tobool12, label %if.then13, label %if.end16

if.then13:                                        ; preds = %land.lhs.true
  %disconnected_f_op14 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %df.0, i32 0, i32 1
  %7 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op14, align 8, !tbaa !61
  %fasync15 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %7, i32 0, i32 16
  %8 = load i32 (i32, %struct.file*, i32)*, i32 (i32, %struct.file*, i32)** %fasync15, align 8, !tbaa !76
  %call = call i32 %8(i32 -1, %struct.file* %file, i32 0)
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %land.lhs.true, %if.then10
  %disconnected_f_op17 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %df.0, i32 0, i32 1
  %9 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op17, align 8, !tbaa !61
  %release = getelementptr inbounds %struct.file_operations, %struct.file_operations* %9, i32 0, i32 13
  %10 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %release, align 8, !tbaa !77
  %call18 = call i32 %10(%struct.inode* %inode, %struct.file* %file)
  ret i32 %call18

if.end19:                                         ; preds = %for.end
  call void (i8*, ...) @panic(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.snd_disconnect_release, i32 0, i32 0), %struct.inode* %inode, %struct.file* %file) #9
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_disconnect_fasync(i32 %fd, %struct.file* %file, i32 %on) #0 {
entry:
  ret i32 -19
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #3 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: noreturn
declare void @panic(i8*, ...) #6

declare void @__list_del_entry(%struct.list_head*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_card_free_when_closed(%struct.snd_card* %card) #0 {
entry:
  %refcount = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  call void @atomic_inc.23(%union.anon.1* %refcount)
  %call = call i32 @snd_card_disconnect(%struct.snd_card* %card)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %refcount1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  call void @atomic_dec(%union.anon.1* %refcount1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %free_on_last_close = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 25
  store i32 1, i32* %free_on_last_close, align 4, !tbaa !62
  %refcount2 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  %call3 = call i32 @atomic_dec_and_test(%union.anon.1* %refcount2)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %if.end
  call void @snd_card_do_free(%struct.snd_card* %card)
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %if.then5 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_dec(%union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !78
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_create(i32 %idx, i8* %xid, %struct.module* %module, i32 %extra_size, %struct.snd_card** %card_ret) #0 {
entry:
  %tobool = icmp ne %struct.snd_card** %card_ret, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 156)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  store %struct.snd_card* null, %struct.snd_card** %card_ret, align 8, !tbaa !2
  %cmp = icmp slt i32 %extra_size, 0
  %.extra_size = select i1 %cmp, i32 0, i32 %extra_size
  %conv22 = sext i32 %.extra_size to i64
  %add = add i64 1184, %conv22
  %call = call i8* @kzalloc(i64 %add, i32 208)
  %0 = bitcast i8* %call to %struct.snd_card*
  %tobool23 = icmp ne %struct.snd_card* %0, null
  br i1 %tobool23, label %if.end25, label %cleanup

if.end25:                                         ; preds = %if.end18
  %tobool26 = icmp ne i8* %xid, null
  br i1 %tobool26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %if.end25
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %call28 = call i64 @strlcpy(i8* %arraydecay, i8* %xid, i64 16)
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %if.end25
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %cmp30 = icmp slt i32 %idx, 0
  br i1 %cmp30, label %if.then32, label %if.end43

if.then32:                                        ; preds = %if.end29
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then32
  %idx2.0 = phi i32 [ 0, %if.then32 ], [ %inc, %for.inc ]
  %cmp33 = icmp slt i32 %idx2.0, 32
  br i1 %cmp33, label %for.body, label %if.end43

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* @snd_cards_lock, align 4, !tbaa !25
  %neg = xor i32 %1, -1
  %and = and i32 %neg, %idx
  %shl = shl i32 1, %idx2.0
  %and35 = and i32 %and, %shl
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.then37, label %for.inc

if.then37:                                        ; preds = %for.body
  %call38 = call i32 @module_slot_match(%struct.module* %module, i32 %idx2.0)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.end43, label %for.inc

for.inc:                                          ; preds = %if.then37, %for.body
  %inc = add nsw i32 %idx2.0, 1
  br label %for.cond

if.end43:                                         ; preds = %if.then37, %for.cond, %if.end29
  %idx.addr.1 = phi i32 [ %idx, %if.end29 ], [ %idx2.0, %if.then37 ], [ %idx, %for.cond ]
  %cmp44 = icmp slt i32 %idx.addr.1, 0
  br i1 %cmp44, label %if.then46, label %if.end67

if.then46:                                        ; preds = %if.end43
  br label %for.cond47

for.cond47:                                       ; preds = %for.inc64, %if.then46
  %idx2.1 = phi i32 [ 0, %if.then46 ], [ %inc65, %for.inc64 ]
  %cmp48 = icmp slt i32 %idx2.1, 32
  br i1 %cmp48, label %for.body50, label %if.end67

for.body50:                                       ; preds = %for.cond47
  %2 = load i32, i32* @snd_cards_lock, align 4, !tbaa !25
  %neg51 = xor i32 %2, -1
  %and52 = and i32 %neg51, %idx.addr.1
  %shl53 = shl i32 1, %idx2.1
  %and54 = and i32 %and52, %shl53
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.then56, label %for.inc64

if.then56:                                        ; preds = %for.body50
  %idxprom = sext i32 %idx2.1 to i64
  %arrayidx = getelementptr inbounds [32 x i8*], [32 x i8*]* @slots, i64 0, i64 %idxprom
  %3 = load i8*, i8** %arrayidx, align 8, !tbaa !2
  %tobool57 = icmp ne i8* %3, null
  br i1 %tobool57, label %lor.lhs.false, label %if.end67

lor.lhs.false:                                    ; preds = %if.then56
  %idxprom58 = sext i32 %idx2.1 to i64
  %arrayidx59 = getelementptr inbounds [32 x i8*], [32 x i8*]* @slots, i64 0, i64 %idxprom58
  %4 = load i8*, i8** %arrayidx59, align 8, !tbaa !2
  %5 = load i8, i8* %4, align 1, !tbaa !29
  %tobool60 = icmp ne i8 %5, 0
  br i1 %tobool60, label %for.inc64, label %if.end67

for.inc64:                                        ; preds = %lor.lhs.false, %for.body50
  %inc65 = add nsw i32 %idx2.1, 1
  br label %for.cond47

if.end67:                                         ; preds = %lor.lhs.false, %if.then56, %for.cond47, %if.end43
  %idx.addr.3 = phi i32 [ %idx.addr.1, %if.end43 ], [ %idx2.1, %lor.lhs.false ], [ %idx2.1, %if.then56 ], [ %idx.addr.1, %for.cond47 ]
  %cmp68 = icmp slt i32 %idx.addr.3, 0
  br i1 %cmp68, label %if.end85, label %if.else

if.else:                                          ; preds = %if.end67
  %6 = load i32, i32* @snd_ecards_limit, align 4, !tbaa !25
  %cmp71 = icmp slt i32 %idx.addr.3, %6
  br i1 %cmp71, label %if.then73, label %if.else79

if.then73:                                        ; preds = %if.else
  %7 = load i32, i32* @snd_cards_lock, align 4, !tbaa !25
  %shl74 = shl i32 1, %idx.addr.3
  %and75 = and i32 %7, %shl74
  %tobool76 = icmp ne i32 %and75, 0
  %. = select i1 %tobool76, i32 -16, i32 0
  br label %if.end85

if.else79:                                        ; preds = %if.else
  %cmp80 = icmp sge i32 %idx.addr.3, 32
  %.1 = select i1 %cmp80, i32 -19, i32 0
  br label %if.end85

if.end85:                                         ; preds = %if.else79, %if.then73, %if.end67
  %err.3 = phi i32 [ -19, %if.end67 ], [ %., %if.then73 ], [ %.1, %if.else79 ]
  %cmp86 = icmp slt i32 %err.3, 0
  br i1 %cmp86, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.end85
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %8 = load i32, i32* @snd_ecards_limit, align 4, !tbaa !25
  %sub = sub nsw i32 %8, 1
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.1.29, i32 0, i32 0), i32 %idx.addr.3, i32 %sub, i32 %err.3)
  br label %__error

if.end89:                                         ; preds = %if.end85
  %shl90 = shl i32 1, %idx.addr.3
  %9 = load i32, i32* @snd_cards_lock, align 4, !tbaa !25
  %or = or i32 %9, %shl90
  store i32 %or, i32* @snd_cards_lock, align 4, !tbaa !25
  %10 = load i32, i32* @snd_ecards_limit, align 4, !tbaa !25
  %cmp91 = icmp sge i32 %idx.addr.3, %10
  br i1 %cmp91, label %if.then93, label %if.end95

if.then93:                                        ; preds = %if.end89
  %add94 = add nsw i32 %idx.addr.3, 1
  store i32 %add94, i32* @snd_ecards_limit, align 4, !tbaa !25
  br label %if.end95

if.end95:                                         ; preds = %if.then93, %if.end89
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 0
  store i32 %idx.addr.3, i32* %number, align 8, !tbaa !9
  %module96 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 7
  store %struct.module* %module, %struct.module** %module96, align 8, !tbaa !79
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 10
  call void @INIT_LIST_HEAD(%struct.list_head* %devices)
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @__init_rwsem(%struct.rw_semaphore* %controls_rwsem, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.2.30, i32 0, i32 0), %struct.lock_class_key* @snd_card_create.__key)
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 13
  call void @__rwlock_init(%struct.rwlock_t* %ctl_files_rwlock, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.4.31, i32 0, i32 0), %struct.lock_class_key* @snd_card_create.__key.3)
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 16
  call void @INIT_LIST_HEAD(%struct.list_head* %controls)
  %ctl_files = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 17
  call void @INIT_LIST_HEAD(%struct.list_head* %ctl_files)
  %files_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 23
  call void @spinlock_check()
  %files_lock103 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 23
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %files_lock103, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %11 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.6.32, i32 0, i32 0), %struct.lock_class_key* @snd_card_create.__key.5)
  %files_list = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 21
  call void @INIT_LIST_HEAD(%struct.list_head* %files_list)
  %shutdown_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 26
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %shutdown_sleep, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8.33, i32 0, i32 0), %struct.lock_class_key* @snd_card_create.__key.7)
  %refcount = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 27
  call void @atomic_set(%union.anon.1* %refcount, i32 0)
  %power_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 31
  call void @__mutex_init(%struct.mutex* %power_lock, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.10.34, i32 0, i32 0), %struct.lock_class_key* @snd_card_create.__key.9)
  %power_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 32
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %power_sleep, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.12.35, i32 0, i32 0), %struct.lock_class_key* @snd_card_create.__key.11)
  %call117 = call i32 @snd_ctl_create(%struct.snd_card* %0)
  %cmp118 = icmp slt i32 %call117, 0
  br i1 %cmp118, label %if.then120, label %if.end121

if.then120:                                       ; preds = %if.end95
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.13.36, i32 0, i32 0))
  br label %__error

if.end121:                                        ; preds = %if.end95
  %call122 = call i32 @snd_info_card_create(%struct.snd_card* %0)
  %cmp123 = icmp slt i32 %call122, 0
  br i1 %cmp123, label %if.then125, label %if.end126

if.then125:                                       ; preds = %if.end121
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.21, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.14.37, i32 0, i32 0))
  %call131 = call i32 @snd_device_free_all(%struct.snd_card* %0, i32 0)
  br label %__error

if.end126:                                        ; preds = %if.end121
  %cmp127 = icmp sgt i32 %.extra_size, 0
  br i1 %cmp127, label %if.then129, label %if.end130

if.then129:                                       ; preds = %if.end126
  %12 = bitcast %struct.snd_card* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %12, i64 1184
  %private_data = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 8
  store i8* %add.ptr, i8** %private_data, align 8, !tbaa !80
  br label %if.end130

if.end130:                                        ; preds = %if.then129, %if.end126
  store %struct.snd_card* %0, %struct.snd_card** %card_ret, align 8, !tbaa !2
  br label %cleanup

__error:                                          ; preds = %if.then125, %if.then120, %if.then88
  %err.4 = phi i32 [ %err.3, %if.then88 ], [ %call117, %if.then120 ], [ %call122, %if.then125 ]
  %13 = bitcast %struct.snd_card* %0 to i8*
  call void @kfree(i8* %13)
  br label %cleanup

cleanup:                                          ; preds = %__error, %if.end130, %if.end18, %if.end
  %retval.0 = phi i32 [ %err.4, %__error ], [ 0, %if.end130 ], [ -22, %if.end ], [ -12, %if.end18 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

declare i64 @strlcpy(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @module_slot_match(%struct.module* %module, i32 %idx) #0 {
entry:
  %tobool = icmp ne %struct.module* %module, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup34

lor.lhs.false:                                    ; preds = %entry
  %name = getelementptr inbounds %struct.module, %struct.module* %module, i32 0, i32 2
  %arraydecay = getelementptr inbounds [56 x i8], [56 x i8]* %name, i32 0, i32 0
  %tobool1 = icmp ne i8* %arraydecay, null
  br i1 %tobool1, label %lor.lhs.false2, label %cleanup34

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %idxprom = sext i32 %idx to i64
  %arrayidx = getelementptr inbounds [32 x i8*], [32 x i8*]* @slots, i64 0, i64 %idxprom
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !2
  %tobool3 = icmp ne i8* %0, null
  br i1 %tobool3, label %if.end, label %cleanup34

if.end:                                           ; preds = %lor.lhs.false2
  %name4 = getelementptr inbounds %struct.module, %struct.module* %module, i32 0, i32 2
  %arraydecay5 = getelementptr inbounds [56 x i8], [56 x i8]* %name4, i32 0, i32 0
  %idxprom6 = sext i32 %idx to i64
  %arrayidx7 = getelementptr inbounds [32 x i8*], [32 x i8*]* @slots, i64 0, i64 %idxprom6
  %1 = load i8*, i8** %arrayidx7, align 8, !tbaa !2
  %2 = load i8, i8* %1, align 1, !tbaa !29
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 33
  %incdec.ptr = getelementptr inbounds i8, i8* %1, i32 1
  %incdec.ptr. = select i1 %cmp, i8* %incdec.ptr, i8* %1
  %. = select i1 %cmp, i32 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.end
  %s2.1 = phi i8* [ %incdec.ptr., %if.end ], [ %incdec.ptr12, %cleanup.cont ]
  %s1.0 = phi i8* [ %arraydecay5, %if.end ], [ %incdec.ptr11, %cleanup.cont ]
  %retval.0 = phi i32 [ undef, %if.end ], [ %retval.1, %cleanup.cont ]
  %incdec.ptr11 = getelementptr inbounds i8, i8* %s1.0, i32 1
  %3 = load i8, i8* %s1.0, align 1, !tbaa !29
  %incdec.ptr12 = getelementptr inbounds i8, i8* %s2.1, i32 1
  %4 = load i8, i8* %s2.1, align 1, !tbaa !29
  %conv13 = sext i8 %3 to i32
  %cmp14 = icmp eq i32 %conv13, 45
  %.3 = select i1 %cmp14, i8 95, i8 %3
  %conv18 = sext i8 %4 to i32
  %cmp19 = icmp eq i32 %conv18, 45
  %c2.0 = select i1 %cmp19, i8 95, i8 %4
  %conv23 = sext i8 %.3 to i32
  %conv24 = sext i8 %c2.0 to i32
  %cmp25 = icmp ne i32 %conv23, %conv24
  br i1 %cmp25, label %if.then27, label %if.end29

if.then27:                                        ; preds = %for.cond
  %tobool28 = icmp ne i32 %., 0
  %lnot = xor i1 %tobool28, true
  %lnot.ext = zext i1 %lnot to i32
  br label %NodeBlock

if.end29:                                         ; preds = %for.cond
  %tobool30 = icmp ne i8 %.3, 0
  %.4 = select i1 %tobool30, i32 0, i32 2
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end29, %if.then27
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then27 ], [ %.4, %if.end29 ]
  %retval.1 = phi i32 [ %lnot.ext, %if.then27 ], [ %retval.0, %if.end29 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %cleanup34, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %cleanup.cont, label %NewDefault

cleanup.cont:                                     ; preds = %LeafBlock
  br label %for.cond

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %cleanup34

cleanup34:                                        ; preds = %NewDefault, %LeafBlock1, %lor.lhs.false2, %lor.lhs.false, %entry
  %retval.2 = phi i32 [ %retval.1, %NewDefault ], [ 0, %lor.lhs.false2 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ %., %LeafBlock1 ]
  ret i32 %retval.2
}

declare void @__init_rwsem(%struct.rw_semaphore*, i8*, %struct.lock_class_key*) #1

declare void @__rwlock_init(%struct.rwlock_t*, i8*, %struct.lock_class_key*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @spinlock_check() #3 {
entry:
  ret void
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #1

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_set(%union.anon.1* %v, i32 %i) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  store i32 %i, i32* %counter, align 4, !tbaa !81
  ret void
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_card_locked(i32 %card) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %0 = load i32, i32* @snd_cards_lock, align 4, !tbaa !25
  %shl = shl i32 1, %card
  %and = and i32 %0, %shl
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define void @snd_card_info_read_oss(%struct.snd_info_buffer* %buffer) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %idx.0 = phi i32 [ 0, %entry ], [ %inc2, %if.end ]
  %count.0 = phi i32 [ 0, %entry ], [ %count.1, %if.end ]
  %cmp = icmp slt i32 %idx.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %0 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %cmp1 = icmp ne %struct.snd_card* %0, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %inc = add nsw i32 %count.0, 1
  %longname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 4
  %arraydecay = getelementptr inbounds [80 x i8], [80 x i8]* %longname, i32 0, i32 0
  %call = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17.27, i32 0, i32 0), i8* %arraydecay)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %count.1 = phi i32 [ %inc, %if.then ], [ %count.0, %for.body ]
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %inc2 = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool = icmp ne i32 %count.0, 0
  br i1 %tobool, label %if.end5, label %if.then3

if.then3:                                         ; preds = %for.end
  %call4 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.18.40, i32 0, i32 0))
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_info_init() #4 section ".init.text" {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6.80, i32 0, i32 0), %struct.snd_info_entry* null)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.47* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_card_info_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !29
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %cleanup

if.end4:                                          ; preds = %if.end
  store %struct.snd_info_entry* %call, %struct.snd_info_entry** @snd_card_info_entry, align 8, !tbaa !2
  %call5 = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.20.42, i32 0, i32 0), %struct.snd_info_entry* null)
  %tobool6 = icmp ne %struct.snd_info_entry* %call5, null
  br i1 %tobool6, label %if.then7, label %cleanup

if.then7:                                         ; preds = %if.end4
  %c8 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call5, i32 0, i32 4
  %text9 = bitcast %union.anon.47* %c8 to %struct.snd_info_entry_text*
  %read10 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text9, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_card_module_info_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read10, align 8, !tbaa !29
  %call11 = call i32 @snd_info_register(%struct.snd_info_entry* %call5)
  %cmp12 = icmp slt i32 %call11, 0
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.then7
  call void @snd_info_free_entry(%struct.snd_info_entry* %call5)
  br label %cleanup

if.else:                                          ; preds = %if.then7
  store %struct.snd_info_entry* %call5, %struct.snd_info_entry** @snd_card_module_info_entry, align 8, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then13, %if.end4, %if.then3, %entry
  %retval.0 = phi i32 [ -12, %if.then3 ], [ -12, %entry ], [ 0, %if.then13 ], [ 0, %if.else ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_card_info_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %idx.0 = phi i32 [ 0, %entry ], [ %inc7, %if.end ]
  %count.0 = phi i32 [ 0, %entry ], [ %count.1, %if.end ]
  %cmp = icmp slt i32 %idx.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %0 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %cmp2 = icmp ne %struct.snd_card* %0, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %inc = add nsw i32 %count.0, 1
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %driver = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 2
  %arraydecay3 = getelementptr inbounds [16 x i8], [16 x i8]* %driver, i32 0, i32 0
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 3
  %arraydecay4 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  %call = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.42, i32 0, i32 0), i32 %idx.0, i8* %arraydecay, i8* %arraydecay3, i8* %arraydecay4)
  %longname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 4
  %arraydecay5 = getelementptr inbounds [80 x i8], [80 x i8]* %longname, i32 0, i32 0
  %call6 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.43, i32 0, i32 0), i8* %arraydecay5)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %count.1 = phi i32 [ %inc, %if.then ], [ %count.0, %for.body ]
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %inc7 = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool = icmp ne i32 %count.0, 0
  br i1 %tobool, label %if.end10, label %if.then8

if.then8:                                         ; preds = %for.end
  %call9 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.18.40, i32 0, i32 0))
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snd_card_module_info_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %idx.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %cmp = icmp slt i32 %idx.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %0 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %cmp2 = icmp ne %struct.snd_card* %0, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 7
  %1 = load %struct.module*, %struct.module** %module, align 8, !tbaa !79
  %name = getelementptr inbounds %struct.module, %struct.module* %1, i32 0, i32 2
  %arraydecay = getelementptr inbounds [56 x i8], [56 x i8]* %name, i32 0, i32 0
  %call = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.44, i32 0, i32 0), i32 %idx.0, i8* %arraydecay)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_info_done() #4 section ".exit.text" {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_card_info_entry, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_card_module_info_entry, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @copy_from_user_toio(i8* %dst, i8* %src, i64 %count) #0 {
entry:
  %buf = alloca [256 x i8], align 16
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %entry
  %count.addr.0 = phi i64 [ %count, %entry ], [ %count.addr.1, %cleanup.cont ]
  %src.addr.0 = phi i8* [ %src, %entry ], [ %src.addr.1, %cleanup.cont ]
  %dst.addr.0 = phi i8* [ %dst, %entry ], [ %dst.addr.1, %cleanup.cont ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %cleanup.cont ]
  %tobool = icmp ne i64 %count.addr.0, 0
  br i1 %tobool, label %while.body, label %cleanup6

while.body:                                       ; preds = %while.cond
  %cmp = icmp ugt i64 %count.addr.0, 256
  %.count.addr.0 = select i1 %cmp, i64 256, i64 %count.addr.0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %buf, i32 0, i32 0
  %call = call i64 @copy_from_user(i8* %arraydecay, i8* %src.addr.0, i64 %.count.addr.0)
  %tobool1 = icmp ne i64 %call, 0
  br i1 %tobool1, label %LeafBlock, label %if.end3

if.end3:                                          ; preds = %while.body
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %buf, i32 0, i32 0
  call void @memcpy_toio(i8* %dst.addr.0, i8* %arraydecay4, i64 %.count.addr.0)
  %sub = sub i64 %count.addr.0, %.count.addr.0
  %add.ptr = getelementptr i8, i8* %dst.addr.0, i64 %.count.addr.0
  %add.ptr5 = getelementptr i8, i8* %src.addr.0, i64 %.count.addr.0
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end3, %while.body
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end3 ], [ 1, %while.body ]
  %count.addr.1 = phi i64 [ %sub, %if.end3 ], [ %count.addr.0, %while.body ]
  %src.addr.1 = phi i8* [ %add.ptr5, %if.end3 ], [ %src.addr.0, %while.body ]
  %dst.addr.1 = phi i8* [ %add.ptr, %if.end3 ], [ %dst.addr.0, %while.body ]
  %retval.1 = phi i32 [ %retval.0, %if.end3 ], [ -14, %while.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %cleanup.cont, label %cleanup6

cleanup.cont:                                     ; preds = %LeafBlock
  br label %while.cond

cleanup6:                                         ; preds = %LeafBlock, %while.cond
  %retval.2 = phi i32 [ 0, %while.cond ], [ %retval.1, %LeafBlock ]
  ret i32 %retval.2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #3 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.11.130, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.12.131, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @memcpy_toio(i8* %dst, i8* %src, i64 %count) #3 {
entry:
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %count, i32 1, i1 false)
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #7

declare void @might_fault() #1

declare i64 @_copy_from_user(i8*, i8*, i32) #1

; Function Attrs: nounwind uwtable
define i32 @copy_to_user_fromio(i8* %dst, i8* %src, i64 %count) #0 {
entry:
  %buf = alloca [256 x i8], align 16
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %entry
  %count.addr.0 = phi i64 [ %count, %entry ], [ %count.addr.1, %cleanup.cont ]
  %src.addr.0 = phi i8* [ %src, %entry ], [ %src.addr.1, %cleanup.cont ]
  %dst.addr.0 = phi i8* [ %dst, %entry ], [ %dst.addr.1, %cleanup.cont ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %cleanup.cont ]
  %tobool = icmp ne i64 %count.addr.0, 0
  br i1 %tobool, label %while.body, label %cleanup6

while.body:                                       ; preds = %while.cond
  %cmp = icmp ugt i64 %count.addr.0, 256
  %.count.addr.0 = select i1 %cmp, i64 256, i64 %count.addr.0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %buf, i32 0, i32 0
  call void @memcpy_fromio(i8* %arraydecay, i8* %src.addr.0, i64 %.count.addr.0)
  %arraydecay1 = getelementptr inbounds [256 x i8], [256 x i8]* %buf, i32 0, i32 0
  %conv = trunc i64 %.count.addr.0 to i32
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %dst.addr.0, i8* %arraydecay1, i32 %conv) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool2 = icmp ne i32 %conv.i, 0
  br i1 %tobool2, label %LeafBlock, label %if.end4

if.end4:                                          ; preds = %while.body
  %sub = sub i64 %count.addr.0, %.count.addr.0
  %add.ptr = getelementptr i8, i8* %dst.addr.0, i64 %.count.addr.0
  %add.ptr5 = getelementptr i8, i8* %src.addr.0, i64 %.count.addr.0
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end4, %while.body
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end4 ], [ 1, %while.body ]
  %count.addr.1 = phi i64 [ %sub, %if.end4 ], [ %count.addr.0, %while.body ]
  %src.addr.1 = phi i8* [ %add.ptr5, %if.end4 ], [ %src.addr.0, %while.body ]
  %dst.addr.1 = phi i8* [ %add.ptr, %if.end4 ], [ %dst.addr.0, %while.body ]
  %retval.1 = phi i32 [ %retval.0, %if.end4 ], [ -14, %while.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %cleanup.cont, label %cleanup6

cleanup.cont:                                     ; preds = %LeafBlock
  br label %while.cond

cleanup6:                                         ; preds = %LeafBlock, %while.cond
  %retval.2 = phi i32 [ 0, %while.cond ], [ %retval.1, %LeafBlock ]
  ret i32 %retval.2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @memcpy_fromio(i8* %dst, i8* %src, i64 %count) #3 {
entry:
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %count, i32 1, i1 false)
  ret void
}

declare i64 @_copy_to_user(i8*, i8*, i32) #1

; Function Attrs: nounwind uwtable
define i32 @snd_info_register(%struct.snd_info_entry* %entry1) #0 {
entry:
  %tobool = icmp ne %struct.snd_info_entry* %entry1, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12.50, i32 0, i32 0), i32 942)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %parent = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent, align 8, !tbaa !82
  %cmp = icmp eq %struct.snd_info_entry* %0, null
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end19
  %parent21 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent21, align 8, !tbaa !82
  %p22 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %1, i32 0, i32 10
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end19
  %p22.sink = phi %struct.proc_dir_entry** [ %p22, %cond.false ], [ @snd_proc_root, %if.end19 ]
  %2 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p22.sink, align 8, !tbaa !2
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 1
  %3 = load i16, i16* %mode, align 8, !tbaa !83
  %conv23 = zext i16 %3 to i32
  %and = and i32 %conv23, 61440
  %cmp24 = icmp eq i32 %and, 16384
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 0
  %4 = load i8*, i8** %name, align 8, !tbaa !72
  %mode27 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 1
  %5 = load i16, i16* %mode27, align 8, !tbaa !83
  br i1 %cmp24, label %if.then26, label %if.else

if.then26:                                        ; preds = %cond.end
  %call = call %struct.proc_dir_entry* @proc_mkdir_mode(i8* %4, i16 zeroext %5, %struct.proc_dir_entry* %2)
  %tobool28 = icmp ne %struct.proc_dir_entry* %call, null
  br i1 %tobool28, label %if.end37, label %if.then29

if.then29:                                        ; preds = %if.then26
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

if.else:                                          ; preds = %cond.end
  %6 = bitcast %struct.snd_info_entry* %entry1 to i8*
  %call33 = call %struct.proc_dir_entry* @proc_create_data(i8* %4, i16 zeroext %5, %struct.proc_dir_entry* %2, %struct.file_operations* @snd_info_entry_operations, i8* %6)
  %tobool34 = icmp ne %struct.proc_dir_entry* %call33, null
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.else
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

if.end36:                                         ; preds = %if.else
  %size = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 2
  %7 = load i64, i64* %size, align 8, !tbaa !84
  call void @proc_set_size(%struct.proc_dir_entry* %call33, i64 %7)
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then26
  %p.0 = phi %struct.proc_dir_entry* [ %call33, %if.end36 ], [ %call, %if.then26 ]
  %p38 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  store %struct.proc_dir_entry* %p.0, %struct.proc_dir_entry** %p38, align 8, !tbaa !85
  %parent39 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %8 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent39, align 8, !tbaa !82
  %tobool40 = icmp ne %struct.snd_info_entry* %8, null
  br i1 %tobool40, label %if.then41, label %if.end43

if.then41:                                        ; preds = %if.end37
  %list = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 13
  %parent42 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %9 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent42, align 8, !tbaa !82
  %children = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %9, i32 0, i32 12
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %children)
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %if.end37
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end43, %if.then35, %if.then29, %if.end
  %retval.0 = phi i32 [ 0, %if.end43 ], [ -12, %if.then29 ], [ -12, %if.then35 ], [ -6, %if.end ]
  ret i32 %retval.0
}

declare %struct.proc_dir_entry* @proc_mkdir_mode(i8*, i16 zeroext, %struct.proc_dir_entry*) #1

declare %struct.proc_dir_entry* @proc_create_data(i8*, i16 zeroext, %struct.proc_dir_entry*, %struct.file_operations*, i8*) #1

declare void @proc_set_size(%struct.proc_dir_entry*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !67
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_llseek(%struct.file* %file, i64 %offset, i32 %orig) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !87
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_lock_nested(%struct.mutex* %access, i32 0)
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %3 = load i16, i16* %content, align 8, !tbaa !89
  %conv = zext i16 %3 to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.47* %c to %struct.snd_info_entry_ops**
  %4 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !29
  %llseek = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %4, i32 0, i32 4
  %5 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)** %llseek, align 8, !tbaa !90
  %tobool = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)* %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %c4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops5 = bitcast %union.anon.47* %c4 to %struct.snd_info_entry_ops**
  %6 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops5, align 8, !tbaa !29
  %llseek6 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %6, i32 0, i32 4
  %7 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)** %llseek6, align 8, !tbaa !90
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %8 = load i8*, i8** %file_private_data, align 8, !tbaa !92
  %call = call i64 %7(%struct.snd_info_entry* %2, i8* %8, %struct.file* %file, i64 %offset, i32 %orig)
  br label %out

if.end:                                           ; preds = %land.lhs.true, %entry
  %content7 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %9 = load i16, i16* %content7, align 8, !tbaa !89
  %conv8 = zext i16 %9 to i32
  %cmp9 = icmp eq i32 %conv8, 1
  br i1 %cmp9, label %if.then11, label %NodeBlock3

if.then11:                                        ; preds = %if.end
  %size12 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 2
  %10 = load i64, i64* %size12, align 8, !tbaa !84
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %if.then11, %if.end
  %size.0 = phi i64 [ %10, %if.then11 ], [ 0, %if.end ]
  %Pivot4 = icmp slt i32 %orig, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %orig, 2
  br i1 %Pivot, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %orig, 2
  %tobool15 = icmp ne i64 %size.0, 0
  %or.cond5 = and i1 %SwitchLeaf2, %tobool15
  br i1 %or.cond5, label %if.end17, label %out

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %orig, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %out

sw.bb:                                            ; preds = %NodeBlock
  %f_pos = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %11 = load i64, i64* %f_pos, align 8, !tbaa !93
  %add = add nsw i64 %offset, %11
  br label %sw.epilog

if.end17:                                         ; preds = %LeafBlock1
  %add18 = add nsw i64 %offset, %size.0
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end17, %sw.bb, %LeafBlock
  %offset.addr.0 = phi i64 [ %offset, %LeafBlock ], [ %add, %sw.bb ], [ %add18, %if.end17 ]
  %cmp19 = icmp slt i64 %offset.addr.0, 0
  br i1 %cmp19, label %out, label %if.end22

if.end22:                                         ; preds = %sw.epilog
  %tobool23 = icmp ne i64 %size.0, 0
  %cmp25 = icmp sgt i64 %offset.addr.0, %size.0
  %or.cond = and i1 %tobool23, %cmp25
  %offset.addr.1 = select i1 %or.cond, i64 %size.0, i64 %offset.addr.0
  %f_pos29 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  store i64 %offset.addr.1, i64* %f_pos29, align 8, !tbaa !93
  br label %out

out:                                              ; preds = %if.end22, %sw.epilog, %LeafBlock, %LeafBlock1, %if.then
  %ret.0 = phi i64 [ -22, %if.then ], [ %offset.addr.1, %if.end22 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %sw.epilog ]
  %access30 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access30)
  ret i64 %ret.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_read(%struct.file* %file, i8* %buffer, i64 %count, i64* %offset) #0 {
entry:
  %_min1 = alloca i64, align 8
  %_min2 = alloca i64, align 8
  %_min166 = alloca i64, align 8
  %_min267 = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %tobool = icmp ne %struct.snd_info_private_data* %1, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12.50, i32 0, i32 0), i32 211)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %2 = load i64, i64* %offset, align 8, !tbaa !94
  %cmp = icmp slt i64 %2, 0
  %cmp21 = icmp ne i64 %2, %2
  %or.cond = or i1 %cmp, %cmp21
  %cmp24 = icmp slt i64 %count, 0
  %or.cond3 = or i1 %or.cond, %cmp24
  %add = add i64 %2, %count
  %cmp28 = icmp ult i64 %add, %2
  %or.cond4 = or i1 %or.cond3, %cmp28
  br i1 %or.cond4, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.end19
  %entry32 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %3 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry32, align 8, !tbaa !87
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 3
  %4 = load i16, i16* %content, align 8, !tbaa !89
  %conv33 = zext i16 %4 to i32
  %Pivot = icmp slt i32 %conv33, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end31
  %SwitchLeaf2 = icmp eq i32 %conv33, 1
  br i1 %SwitchLeaf2, label %sw.bb56, label %sw.epilog

LeafBlock:                                        ; preds = %if.end31
  %SwitchLeaf = icmp eq i32 %conv33, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %rbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 0
  %5 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer, align 8, !tbaa !95
  %cmp34 = icmp eq %struct.snd_info_buffer* %5, null
  br i1 %cmp34, label %cleanup, label %if.end37

if.end37:                                         ; preds = %sw.bb
  %size38 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 2
  %6 = load i32, i32* %size38, align 4, !tbaa !96
  %conv39 = zext i32 %6 to i64
  %cmp40 = icmp sge i64 %2, %conv39
  br i1 %cmp40, label %cleanup, label %if.end43

if.end43:                                         ; preds = %if.end37
  %size44 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 2
  %7 = load i32, i32* %size44, align 4, !tbaa !96
  %conv45 = zext i32 %7 to i64
  %sub = sub nsw i64 %conv45, %2
  store i64 %count, i64* %_min1, align 8, !tbaa !52
  store i64 %sub, i64* %_min2, align 8, !tbaa !52
  %8 = load i64, i64* %_min1, align 8, !tbaa !52
  %9 = load i64, i64* %_min2, align 8, !tbaa !52
  %cmp49 = icmp ult i64 %8, %9
  %10 = load i64, i64* %_min1, align 8
  %11 = load i64, i64* %_min2, align 8
  %cond = select i1 %cmp49, i64 %10, i64 %11
  %buffer51 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 0
  %12 = load i8*, i8** %buffer51, align 8, !tbaa !98
  %add.ptr = getelementptr inbounds i8, i8* %12, i64 %2
  %conv52 = trunc i64 %cond to i32
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %buffer, i8* %add.ptr, i32 %conv52) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool53 = icmp ne i32 %conv.i, 0
  br i1 %tobool53, label %cleanup, label %sw.epilog

sw.bb56:                                          ; preds = %LeafBlock1
  %size57 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 2
  %13 = load i64, i64* %size57, align 8, !tbaa !84
  %cmp58 = icmp sge i64 %2, %13
  br i1 %cmp58, label %cleanup, label %if.end61

if.end61:                                         ; preds = %sw.bb56
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %ops = bitcast %union.anon.47* %c to %struct.snd_info_entry_ops**
  %14 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !29
  %read = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %14, i32 0, i32 2
  %15 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read, align 8, !tbaa !99
  %tobool62 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %15, null
  br i1 %tobool62, label %if.then63, label %sw.epilog

if.then63:                                        ; preds = %if.end61
  %size64 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 2
  %16 = load i64, i64* %size64, align 8, !tbaa !84
  %sub65 = sub nsw i64 %16, %2
  store i64 %count, i64* %_min166, align 8, !tbaa !52
  store i64 %sub65, i64* %_min267, align 8, !tbaa !52
  %17 = load i64, i64* %_min166, align 8, !tbaa !52
  %18 = load i64, i64* %_min267, align 8, !tbaa !52
  %cmp71 = icmp ult i64 %17, %18
  %19 = load i64, i64* %_min166, align 8
  %20 = load i64, i64* %_min267, align 8
  %cond76 = select i1 %cmp71, i64 %19, i64 %20
  %c77 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %ops78 = bitcast %union.anon.47* %c77 to %struct.snd_info_entry_ops**
  %21 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops78, align 8, !tbaa !29
  %read79 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %21, i32 0, i32 2
  %22 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read79, align 8, !tbaa !99
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %23 = load i8*, i8** %file_private_data, align 8, !tbaa !92
  %call80 = call i64 %22(%struct.snd_info_entry* %3, i8* %23, %struct.file* %file, i8* %buffer, i64 %cond76, i64 %2)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then63, %if.end61, %if.end43, %LeafBlock, %LeafBlock1
  %size.1 = phi i64 [ %cond, %if.end43 ], [ %call80, %if.then63 ], [ 0, %if.end61 ], [ 0, %LeafBlock1 ], [ 0, %LeafBlock ]
  %cmp82 = icmp sgt i64 %size.1, 0
  br i1 %cmp82, label %if.then84, label %cleanup

if.then84:                                        ; preds = %sw.epilog
  %add85 = add i64 %2, %size.1
  store i64 %add85, i64* %offset, align 8, !tbaa !94
  br label %cleanup

cleanup:                                          ; preds = %if.then84, %sw.epilog, %sw.bb56, %if.end43, %if.end37, %sw.bb, %if.end19, %if.end
  %retval.0 = phi i64 [ -6, %if.end ], [ -5, %if.end19 ], [ -5, %sw.bb ], [ 0, %if.end37 ], [ -14, %if.end43 ], [ 0, %sw.bb56 ], [ %size.1, %if.then84 ], [ %size.1, %sw.epilog ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_write(%struct.file* %file, i8* %buffer, i64 %count, i64* %offset) #0 {
entry:
  %_min1 = alloca i64, align 8
  %_min2 = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %tobool = icmp ne %struct.snd_info_private_data* %1, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12.50, i32 0, i32 0), i32 258)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %entry20 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry20, align 8, !tbaa !87
  %3 = load i64, i64* %offset, align 8, !tbaa !94
  %cmp = icmp slt i64 %3, 0
  %cmp22 = icmp ne i64 %3, %3
  %or.cond = or i1 %cmp, %cmp22
  %cmp25 = icmp slt i64 %count, 0
  %or.cond3 = or i1 %or.cond, %cmp25
  %add = add i64 %3, %count
  %cmp29 = icmp ult i64 %add, %3
  %or.cond5 = or i1 %or.cond3, %cmp29
  br i1 %or.cond5, label %cleanup, label %if.end32

if.end32:                                         ; preds = %if.end19
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %4 = load i16, i16* %content, align 8, !tbaa !89
  %conv33 = zext i16 %4 to i32
  %Pivot = icmp slt i32 %conv33, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end32
  %SwitchLeaf2 = icmp eq i32 %conv33, 1
  br i1 %SwitchLeaf2, label %sw.bb60, label %sw.epilog

LeafBlock:                                        ; preds = %if.end32
  %SwitchLeaf = icmp eq i32 %conv33, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %wbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 1
  %5 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer, align 8, !tbaa !100
  %cmp34 = icmp eq %struct.snd_info_buffer* %5, null
  br i1 %cmp34, label %cleanup, label %if.end37

if.end37:                                         ; preds = %sw.bb
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_lock_nested(%struct.mutex* %access, i32 0)
  %add38 = add i64 %3, %count
  %len = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 3
  %6 = load i32, i32* %len, align 8, !tbaa !101
  %conv39 = zext i32 %6 to i64
  %cmp40 = icmp uge i64 %add38, %conv39
  br i1 %cmp40, label %if.then42, label %if.end49

if.then42:                                        ; preds = %if.end37
  %add43 = add i64 %3, %count
  %conv44 = trunc i64 %add43 to i32
  %call = call i32 @resize_info_buffer(%struct.snd_info_buffer* %5, i32 %conv44)
  %tobool45 = icmp ne i32 %call, 0
  br i1 %tobool45, label %if.then46, label %if.end49

if.then46:                                        ; preds = %if.then42
  %access47 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access47)
  br label %cleanup

if.end49:                                         ; preds = %if.then42, %if.end37
  %buffer50 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 0
  %7 = load i8*, i8** %buffer50, align 8, !tbaa !98
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %3
  %call51 = call i64 @copy_from_user.54(i8* %add.ptr, i8* %buffer, i64 %count)
  %tobool52 = icmp ne i64 %call51, 0
  br i1 %tobool52, label %if.then53, label %if.end55

if.then53:                                        ; preds = %if.end49
  %access54 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access54)
  br label %cleanup

if.end55:                                         ; preds = %if.end49
  %add56 = add i64 %3, %count
  %conv57 = trunc i64 %add56 to i32
  %size58 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 2
  store i32 %conv57, i32* %size58, align 4, !tbaa !96
  %access59 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access59)
  br label %sw.epilog

sw.bb60:                                          ; preds = %LeafBlock1
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.47* %c to %struct.snd_info_entry_ops**
  %8 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !29
  %write = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %8, i32 0, i32 3
  %9 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write, align 8, !tbaa !102
  %tobool61 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %9, null
  %cmp62 = icmp ugt i64 %count, 0
  %or.cond4 = and i1 %tobool61, %cmp62
  br i1 %or.cond4, label %if.then64, label %sw.epilog

if.then64:                                        ; preds = %sw.bb60
  %size65 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 2
  %10 = load i64, i64* %size65, align 8, !tbaa !84
  %sub = sub nsw i64 %10, %3
  store i64 %count, i64* %_min1, align 8, !tbaa !52
  store i64 %sub, i64* %_min2, align 8, !tbaa !52
  %11 = load i64, i64* %_min1, align 8, !tbaa !52
  %12 = load i64, i64* %_min2, align 8, !tbaa !52
  %cmp69 = icmp ult i64 %11, %12
  %13 = load i64, i64* %_min1, align 8
  %14 = load i64, i64* %_min2, align 8
  %cond = select i1 %cmp69, i64 %13, i64 %14
  %c71 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops72 = bitcast %union.anon.47* %c71 to %struct.snd_info_entry_ops**
  %15 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops72, align 8, !tbaa !29
  %write73 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %15, i32 0, i32 3
  %16 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write73, align 8, !tbaa !102
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %17 = load i8*, i8** %file_private_data, align 8, !tbaa !92
  %call74 = call i64 %16(%struct.snd_info_entry* %2, i8* %17, %struct.file* %file, i8* %buffer, i64 %cond, i64 %3)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then64, %sw.bb60, %if.end55, %LeafBlock, %LeafBlock1
  %size.1 = phi i64 [ %count, %if.end55 ], [ %call74, %if.then64 ], [ 0, %sw.bb60 ], [ 0, %LeafBlock1 ], [ 0, %LeafBlock ]
  %cmp76 = icmp sgt i64 %size.1, 0
  br i1 %cmp76, label %if.then78, label %cleanup

if.then78:                                        ; preds = %sw.epilog
  %add79 = add nsw i64 %3, %size.1
  store i64 %add79, i64* %offset, align 8, !tbaa !94
  br label %cleanup

cleanup:                                          ; preds = %if.then78, %sw.epilog, %if.then53, %if.then46, %sw.bb, %if.end19, %if.end
  %retval.0 = phi i64 [ -12, %if.then46 ], [ -14, %if.then53 ], [ -6, %if.end ], [ -5, %if.end19 ], [ -5, %sw.bb ], [ %size.1, %if.then78 ], [ %size.1, %sw.epilog ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %cmp = icmp eq %struct.snd_info_private_data* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !87
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %3 = load i16, i16* %content, align 8, !tbaa !89
  %conv = zext i16 %3 to i32
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %if.end
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.47* %c to %struct.snd_info_entry_ops**
  %4 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !29
  %poll = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %4, i32 0, i32 5
  %5 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)** %poll, align 8, !tbaa !103
  %tobool = icmp ne i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)* %5, null
  %c4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops5 = bitcast %union.anon.47* %c4 to %struct.snd_info_entry_ops**
  %6 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops5, align 8, !tbaa !29
  br i1 %tobool, label %if.then3, label %if.end7

if.then3:                                         ; preds = %sw.bb
  %poll6 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %6, i32 0, i32 5
  %7 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)** %poll6, align 8, !tbaa !103
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %8 = load i8*, i8** %file_private_data, align 8, !tbaa !92
  %call = call i32 %7(%struct.snd_info_entry* %2, i8* %8, %struct.file* %file, %struct.poll_table_struct* %wait)
  br label %cleanup

if.end7:                                          ; preds = %sw.bb
  %read = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %6, i32 0, i32 2
  %9 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read, align 8, !tbaa !99
  %tobool10 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %9, null
  %or = or i32 0, 65
  %or. = select i1 %tobool10, i32 %or, i32 0
  %c13 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops14 = bitcast %union.anon.47* %c13 to %struct.snd_info_entry_ops**
  %10 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops14, align 8, !tbaa !29
  %write = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %10, i32 0, i32 3
  %11 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write, align 8, !tbaa !102
  %tobool15 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %11, null
  %or17 = or i32 %or., 260
  %mask.1 = select i1 %tobool15, i32 %or17, i32 %or.
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.then3, %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.then3 ], [ 0, %entry ], [ %mask.1, %if.end7 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %cmp = icmp eq %struct.snd_info_private_data* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !87
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %3 = load i16, i16* %content, align 8, !tbaa !89
  %conv = zext i16 %3 to i32
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %if.end
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.47* %c to %struct.snd_info_entry_ops**
  %4 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !29
  %ioctl = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %4, i32 0, i32 6
  %5 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)** %ioctl, align 8, !tbaa !104
  %tobool = icmp ne i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)* %5, null
  br i1 %tobool, label %if.then3, label %cleanup

if.then3:                                         ; preds = %sw.bb
  %c4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops5 = bitcast %union.anon.47* %c4 to %struct.snd_info_entry_ops**
  %6 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops5, align 8, !tbaa !29
  %ioctl6 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %6, i32 0, i32 6
  %7 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)** %ioctl6, align 8, !tbaa !104
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %8 = load i8*, i8** %file_private_data, align 8, !tbaa !92
  %call = call i32 %7(%struct.snd_info_entry* %2, i8* %8, %struct.file* %file, i32 %cmd, i64 %arg)
  %conv7 = sext i32 %call to i64
  br label %cleanup

cleanup:                                          ; preds = %if.then3, %sw.bb, %if.end, %entry
  %retval.0 = phi i64 [ %conv7, %if.then3 ], [ 0, %entry ], [ -25, %if.end ], [ -25, %sw.bb ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_mmap(%struct.file* %file, %struct.vm_area_struct* %vma) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %file)
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %cmp = icmp eq %struct.snd_info_private_data* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !87
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %3 = load i16, i16* %content, align 8, !tbaa !89
  %conv = zext i16 %3 to i32
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %if.end
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.47* %c to %struct.snd_info_entry_ops**
  %4 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !29
  %mmap = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %4, i32 0, i32 7
  %5 = load i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)** %mmap, align 8, !tbaa !105
  %tobool = icmp ne i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)* %5, null
  br i1 %tobool, label %if.then3, label %cleanup

if.then3:                                         ; preds = %sw.bb
  %c4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops5 = bitcast %union.anon.47* %c4 to %struct.snd_info_entry_ops**
  %6 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops5, align 8, !tbaa !29
  %mmap6 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %6, i32 0, i32 7
  %7 = load i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)** %mmap6, align 8, !tbaa !105
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %8 = load i8*, i8** %file_private_data, align 8, !tbaa !92
  %call7 = call i32 %7(%struct.snd_info_entry* %2, i8* %8, %struct.inode* %call, %struct.file* %file, %struct.vm_area_struct* %vma)
  br label %cleanup

cleanup:                                          ; preds = %if.then3, %sw.bb, %if.end, %entry
  %retval.0 = phi i32 [ %call7, %if.then3 ], [ 0, %entry ], [ -6, %if.end ], [ -6, %sw.bb ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %0 = bitcast i8* %call to %struct.snd_info_entry*
  %cmp = icmp eq %struct.snd_info_entry* %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %p = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 10
  %1 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p, align 8, !tbaa !85
  %tobool = icmp ne %struct.proc_dir_entry* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %module = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 7
  %2 = load %struct.module*, %struct.module** %module, align 8, !tbaa !106
  %call2 = call zeroext i1 @try_module_get(%struct.module* %2)
  br i1 %call2, label %if.end4, label %__error1

if.end4:                                          ; preds = %if.end
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %3 = load i32, i32* %f_flags, align 8, !tbaa !75
  %and = and i32 %3, 3
  switch i32 %and, label %if.end33 [
    i32 0, label %if.then8
    i32 2, label %if.then8
    i32 1, label %if.then21
  ]

if.then8:                                         ; preds = %if.end4, %if.end4
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  %4 = load i16, i16* %content, align 8, !tbaa !89
  %conv = zext i16 %4 to i32
  %cmp9 = icmp eq i32 %conv, 1
  br i1 %cmp9, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.then8
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops = bitcast %union.anon.47* %c to %struct.snd_info_entry_ops**
  %5 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !29
  %read = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %5, i32 0, i32 2
  %6 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read, align 8, !tbaa !99
  %cmp11 = icmp eq i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %6, null
  br i1 %cmp11, label %__error, label %if.end15

if.end15:                                         ; preds = %land.lhs.true, %if.then8
  %and.off = add i32 %and, -1
  %switch = icmp ult i32 %and.off, 2
  br i1 %switch, label %if.then21, label %if.end33

if.then21:                                        ; preds = %if.end15, %if.end4
  %content22 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  %7 = load i16, i16* %content22, align 8, !tbaa !89
  %conv23 = zext i16 %7 to i32
  %cmp24 = icmp eq i32 %conv23, 1
  br i1 %cmp24, label %land.lhs.true26, label %if.end33

land.lhs.true26:                                  ; preds = %if.then21
  %c27 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops28 = bitcast %union.anon.47* %c27 to %struct.snd_info_entry_ops**
  %8 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops28, align 8, !tbaa !29
  %write = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %8, i32 0, i32 3
  %9 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write, align 8, !tbaa !102
  %cmp29 = icmp eq i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %9, null
  br i1 %cmp29, label %__error, label %if.end33

if.end33:                                         ; preds = %land.lhs.true26, %if.then21, %if.end15, %if.end4
  %call34 = call i8* @kzalloc.52(i64 32, i32 208)
  %10 = bitcast i8* %call34 to %struct.snd_info_private_data*
  %cmp35 = icmp eq %struct.snd_info_private_data* %10, null
  br i1 %cmp35, label %__error, label %if.end38

if.end38:                                         ; preds = %if.end33
  %entry39 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 2
  store %struct.snd_info_entry* %0, %struct.snd_info_entry** %entry39, align 8, !tbaa !87
  %content40 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  %11 = load i16, i16* %content40, align 8, !tbaa !89
  %conv41 = zext i16 %11 to i32
  %Pivot = icmp slt i32 %conv41, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end38
  %SwitchLeaf2 = icmp eq i32 %conv41, 1
  br i1 %SwitchLeaf2, label %sw.bb85, label %sw.epilog

LeafBlock:                                        ; preds = %if.end38
  %SwitchLeaf = icmp eq i32 %conv41, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  switch i32 %and, label %sw.epilog [
    i32 0, label %if.then47
    i32 2, label %if.then47
    i32 1, label %if.then68
  ]

if.then47:                                        ; preds = %sw.bb, %sw.bb
  %call48 = call i8* @kzalloc.52(i64 32, i32 208)
  %12 = bitcast i8* %call48 to %struct.snd_info_buffer*
  %cmp49 = icmp eq %struct.snd_info_buffer* %12, null
  br i1 %cmp49, label %__nomem, label %if.end52

if.end52:                                         ; preds = %if.then47
  %rbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  store %struct.snd_info_buffer* %12, %struct.snd_info_buffer** %rbuffer, align 8, !tbaa !95
  %len = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %12, i32 0, i32 3
  store i32 4096, i32* %len, align 8, !tbaa !101
  %len53 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %12, i32 0, i32 3
  %13 = load i32, i32* %len53, align 8, !tbaa !101
  %conv54 = zext i32 %13 to i64
  %call55 = call i8* @kzalloc.52(i64 %conv54, i32 208)
  %buffer56 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %12, i32 0, i32 0
  store i8* %call55, i8** %buffer56, align 8, !tbaa !98
  %buffer57 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %12, i32 0, i32 0
  %14 = load i8*, i8** %buffer57, align 8, !tbaa !98
  %cmp58 = icmp eq i8* %14, null
  br i1 %cmp58, label %__nomem, label %if.end62

if.end62:                                         ; preds = %if.end52
  %and.off3 = add i32 %and, -1
  %switch4 = icmp ult i32 %and.off3, 2
  br i1 %switch4, label %if.then68, label %sw.epilog

if.then68:                                        ; preds = %if.end62, %sw.bb
  %call69 = call i8* @kzalloc.52(i64 32, i32 208)
  %15 = bitcast i8* %call69 to %struct.snd_info_buffer*
  %cmp70 = icmp eq %struct.snd_info_buffer* %15, null
  br i1 %cmp70, label %__nomem, label %if.end73

if.end73:                                         ; preds = %if.then68
  %wbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 1
  store %struct.snd_info_buffer* %15, %struct.snd_info_buffer** %wbuffer, align 8, !tbaa !100
  %len74 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %15, i32 0, i32 3
  store i32 4096, i32* %len74, align 8, !tbaa !101
  %len75 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %15, i32 0, i32 3
  %16 = load i32, i32* %len75, align 8, !tbaa !101
  %conv76 = zext i32 %16 to i64
  %call.i = call i8* @__kmalloc(i64 %conv76, i32 208) #8
  %buffer78 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %15, i32 0, i32 0
  store i8* %call.i, i8** %buffer78, align 8, !tbaa !98
  %buffer79 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %15, i32 0, i32 0
  %17 = load i8*, i8** %buffer79, align 8, !tbaa !98
  %cmp80 = icmp eq i8* %17, null
  br i1 %cmp80, label %__nomem, label %sw.epilog

sw.bb85:                                          ; preds = %LeafBlock1
  %c86 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops87 = bitcast %union.anon.47* %c86 to %struct.snd_info_entry_ops**
  %18 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops87, align 8, !tbaa !29
  %open = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %18, i32 0, i32 0
  %19 = load i32 (%struct.snd_info_entry*, i16, i8**)*, i32 (%struct.snd_info_entry*, i16, i8**)** %open, align 8, !tbaa !107
  %tobool88 = icmp ne i32 (%struct.snd_info_entry*, i16, i8**)* %19, null
  br i1 %tobool88, label %if.then89, label %sw.epilog

if.then89:                                        ; preds = %sw.bb85
  %c90 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops91 = bitcast %union.anon.47* %c90 to %struct.snd_info_entry_ops**
  %20 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops91, align 8, !tbaa !29
  %open92 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %20, i32 0, i32 0
  %21 = load i32 (%struct.snd_info_entry*, i16, i8**)*, i32 (%struct.snd_info_entry*, i16, i8**)** %open92, align 8, !tbaa !107
  %conv93 = trunc i32 %and to i16
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 3
  %call94 = call i32 %21(%struct.snd_info_entry* %0, i16 zeroext %conv93, i8** %file_private_data)
  %cmp95 = icmp slt i32 %call94, 0
  br i1 %cmp95, label %if.then97, label %sw.epilog

if.then97:                                        ; preds = %if.then89
  %22 = bitcast %struct.snd_info_private_data* %10 to i8*
  call void @kfree(i8* %22)
  br label %__error

sw.epilog:                                        ; preds = %if.then89, %sw.bb85, %if.end73, %if.end62, %sw.bb, %LeafBlock, %LeafBlock1
  %23 = bitcast %struct.snd_info_private_data* %10 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %23, i8** %private_data, align 8, !tbaa !86
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  %content100 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  %24 = load i16, i16* %content100, align 8, !tbaa !89
  %conv101 = zext i16 %24 to i32
  %cmp102 = icmp eq i32 %conv101, 0
  br i1 %cmp102, label %land.lhs.true104, label %cleanup

land.lhs.true104:                                 ; preds = %sw.epilog
  switch i32 %and, label %cleanup [
    i32 0, label %if.then110
    i32 2, label %if.then110
  ]

if.then110:                                       ; preds = %land.lhs.true104, %land.lhs.true104
  %c111 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %text = bitcast %union.anon.47* %c111 to %struct.snd_info_entry_text*
  %read112 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  %25 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read112, align 8, !tbaa !29
  %tobool113 = icmp ne void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %25, null
  br i1 %tobool113, label %if.then114, label %cleanup

if.then114:                                       ; preds = %if.then110
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 11
  call void @mutex_lock_nested(%struct.mutex* %access, i32 0)
  %c115 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %text116 = bitcast %union.anon.47* %c115 to %struct.snd_info_entry_text*
  %read117 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text116, i32 0, i32 0
  %26 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read117, align 8, !tbaa !29
  %rbuffer118 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  %27 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer118, align 8, !tbaa !95
  call void %26(%struct.snd_info_entry* %0, %struct.snd_info_buffer* %27)
  %access119 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access119)
  br label %cleanup

__nomem:                                          ; preds = %if.end73, %if.then68, %if.end52, %if.then47
  %rbuffer122 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  %28 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer122, align 8, !tbaa !95
  %tobool123 = icmp ne %struct.snd_info_buffer* %28, null
  br i1 %tobool123, label %if.then124, label %if.end128

if.then124:                                       ; preds = %__nomem
  %rbuffer125 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  %29 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer125, align 8, !tbaa !95
  %buffer126 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %29, i32 0, i32 0
  %30 = load i8*, i8** %buffer126, align 8, !tbaa !98
  call void @kfree(i8* %30)
  %rbuffer127 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  %31 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer127, align 8, !tbaa !95
  %32 = bitcast %struct.snd_info_buffer* %31 to i8*
  call void @kfree(i8* %32)
  br label %if.end128

if.end128:                                        ; preds = %if.then124, %__nomem
  %wbuffer129 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 1
  %33 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer129, align 8, !tbaa !100
  %tobool130 = icmp ne %struct.snd_info_buffer* %33, null
  br i1 %tobool130, label %if.then131, label %if.end135

if.then131:                                       ; preds = %if.end128
  %wbuffer132 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 1
  %34 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer132, align 8, !tbaa !100
  %buffer133 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %34, i32 0, i32 0
  %35 = load i8*, i8** %buffer133, align 8, !tbaa !98
  call void @kfree(i8* %35)
  %wbuffer134 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 1
  %36 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer134, align 8, !tbaa !100
  %37 = bitcast %struct.snd_info_buffer* %36 to i8*
  call void @kfree(i8* %37)
  br label %if.end135

if.end135:                                        ; preds = %if.then131, %if.end128
  %38 = bitcast %struct.snd_info_private_data* %10 to i8*
  call void @kfree(i8* %38)
  br label %__error

__error:                                          ; preds = %if.end135, %if.then97, %if.end33, %land.lhs.true26, %land.lhs.true
  %err.0 = phi i32 [ -12, %if.end135 ], [ %call94, %if.then97 ], [ -19, %land.lhs.true ], [ -19, %land.lhs.true26 ], [ -12, %if.end33 ]
  %module136 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 7
  %39 = load %struct.module*, %struct.module** %module136, align 8, !tbaa !106
  call void @module_put(%struct.module* %39)
  br label %__error1

__error1:                                         ; preds = %__error, %if.end
  %err.1 = phi i32 [ %err.0, %__error ], [ -14, %if.end ]
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

cleanup:                                          ; preds = %__error1, %if.then114, %if.then110, %land.lhs.true104, %sw.epilog, %if.then
  %retval.0 = phi i32 [ -19, %if.then ], [ %err.1, %__error1 ], [ 0, %if.then110 ], [ 0, %if.then114 ], [ 0, %land.lhs.true104 ], [ 0, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %0 = load i32, i32* %f_flags, align 8, !tbaa !75
  %and = and i32 %0, 3
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8, !tbaa !86
  %2 = bitcast i8* %1 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 2
  %3 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !87
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 3
  %4 = load i16, i16* %content, align 8, !tbaa !89
  %conv = zext i16 %4 to i32
  %Pivot = icmp slt i32 %conv, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf2, label %sw.bb24, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %conv, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %rbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 0
  %5 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer, align 8, !tbaa !95
  %tobool = icmp ne %struct.snd_info_buffer* %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %rbuffer3 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 0
  %6 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer3, align 8, !tbaa !95
  %buffer = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %6, i32 0, i32 0
  %7 = load i8*, i8** %buffer, align 8, !tbaa !98
  call void @kfree(i8* %7)
  %rbuffer4 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 0
  %8 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer4, align 8, !tbaa !95
  %9 = bitcast %struct.snd_info_buffer* %8 to i8*
  call void @kfree(i8* %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %wbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %10 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer, align 8, !tbaa !100
  %tobool5 = icmp ne %struct.snd_info_buffer* %10, null
  br i1 %tobool5, label %if.then6, label %sw.epilog

if.then6:                                         ; preds = %if.end
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %text = bitcast %union.anon.47* %c to %struct.snd_info_entry_text*
  %write = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 1
  %11 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %write, align 8, !tbaa !29
  %tobool7 = icmp ne void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %11, null
  br i1 %tobool7, label %if.then8, label %if.end19

if.then8:                                         ; preds = %if.then6
  %c9 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %text10 = bitcast %union.anon.47* %c9 to %struct.snd_info_entry_text*
  %write11 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text10, i32 0, i32 1
  %12 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %write11, align 8, !tbaa !29
  %wbuffer12 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %13 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer12, align 8, !tbaa !100
  call void %12(%struct.snd_info_entry* %3, %struct.snd_info_buffer* %13)
  %wbuffer13 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %14 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer13, align 8, !tbaa !100
  %error = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %14, i32 0, i32 5
  %15 = load i32, i32* %error, align 8, !tbaa !108
  %tobool14 = icmp ne i32 %15, 0
  br i1 %tobool14, label %if.then15, label %if.end19

if.then15:                                        ; preds = %if.then8
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 0
  %16 = load i8*, i8** %name, align 8, !tbaa !72
  %wbuffer16 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %17 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer16, align 8, !tbaa !100
  %error17 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %17, i32 0, i32 5
  %18 = load i32, i32* %error17, align 8, !tbaa !108
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12.50, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.20.51, i32 0, i32 0), i8* %16, i32 %18)
  br label %if.end19

if.end19:                                         ; preds = %if.then15, %if.then8, %if.then6
  %wbuffer20 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %19 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer20, align 8, !tbaa !100
  %buffer21 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %19, i32 0, i32 0
  %20 = load i8*, i8** %buffer21, align 8, !tbaa !98
  call void @kfree(i8* %20)
  %wbuffer22 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %21 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer22, align 8, !tbaa !100
  %22 = bitcast %struct.snd_info_buffer* %21 to i8*
  call void @kfree(i8* %22)
  br label %sw.epilog

sw.bb24:                                          ; preds = %LeafBlock1
  %c25 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %ops = bitcast %union.anon.47* %c25 to %struct.snd_info_entry_ops**
  %23 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !29
  %release = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %23, i32 0, i32 1
  %24 = load i32 (%struct.snd_info_entry*, i16, i8*)*, i32 (%struct.snd_info_entry*, i16, i8*)** %release, align 8, !tbaa !109
  %tobool26 = icmp ne i32 (%struct.snd_info_entry*, i16, i8*)* %24, null
  br i1 %tobool26, label %if.then27, label %sw.epilog

if.then27:                                        ; preds = %sw.bb24
  %c28 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %ops29 = bitcast %union.anon.47* %c28 to %struct.snd_info_entry_ops**
  %25 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops29, align 8, !tbaa !29
  %release30 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %25, i32 0, i32 1
  %26 = load i32 (%struct.snd_info_entry*, i16, i8*)*, i32 (%struct.snd_info_entry*, i16, i8*)** %release30, align 8, !tbaa !109
  %conv31 = trunc i32 %and to i16
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 3
  %27 = load i8*, i8** %file_private_data, align 8, !tbaa !92
  %call = call i32 %26(%struct.snd_info_entry* %3, i16 zeroext %conv31, i8* %27)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then27, %sw.bb24, %if.end19, %if.end, %LeafBlock, %LeafBlock1
  %module = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 7
  %28 = load %struct.module*, %struct.module** %module, align 8, !tbaa !106
  call void @module_put(%struct.module* %28)
  %29 = bitcast %struct.snd_info_private_data* %2 to i8*
  call void @kfree(i8* %29)
  ret i32 0
}

declare i8* @PDE_DATA(%struct.inode*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.52(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #3 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !110
  ret %struct.inode* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @resize_info_buffer(%struct.snd_info_buffer* %buffer, i32 %nsize) #0 {
entry:
  %add = add i32 %nsize, 4095
  %and = and i32 %add, -4096
  %buffer1 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %0 = load i8*, i8** %buffer1, align 8, !tbaa !98
  %conv = zext i32 %and to i64
  %call = call i8* @krealloc(i8* %0, i64 %conv, i32 32976)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %buffer2 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  store i8* %call, i8** %buffer2, align 8, !tbaa !98
  %len = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 3
  store i32 %and, i32* %len, align 8, !tbaa !101
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user.54(i8* %to, i8* %from, i64 %n) #3 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.11.130, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.12.131, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

declare i8* @krealloc(i8*, i64, i32) #1

; Function Attrs: nounwind uwtable
define void @snd_info_free_entry(%struct.snd_info_entry* %entry1) #0 {
entry:
  %cmp = icmp eq %struct.snd_info_entry* %entry1, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %p = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p, align 8, !tbaa !85
  %tobool = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  call void @snd_info_disconnect(%struct.snd_info_entry* %entry1)
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 0
  %1 = load i8*, i8** %name, align 8, !tbaa !72
  call void @kfree(i8* %1)
  %private_free = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 9
  %2 = load void (%struct.snd_info_entry*)*, void (%struct.snd_info_entry*)** %private_free, align 8, !tbaa !111
  %tobool4 = icmp ne void (%struct.snd_info_entry*)* %2, null
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  %private_free6 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 9
  %3 = load void (%struct.snd_info_entry*)*, void (%struct.snd_info_entry*)** %private_free6, align 8, !tbaa !111
  call void %3(%struct.snd_info_entry* %entry1)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  %4 = bitcast %struct.snd_info_entry* %entry1 to i8*
  call void @kfree(i8* %4)
  br label %return

return:                                           ; preds = %if.end7, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snd_info_disconnect(%struct.snd_info_entry* %entry1) #0 {
entry:
  %children = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %children, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !66
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.list_head* [ %1, %for.body ], [ %0, %entry ]
  %p.0 = phi %struct.list_head* [ %0, %entry ], [ %1, %for.body ]
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next4, align 8, !tbaa !66
  %children3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %p.0, %children3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = bitcast %struct.list_head* %p.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -280
  %3 = bitcast i8* %add.ptr to %struct.snd_info_entry*
  call void @snd_info_disconnect(%struct.snd_info_entry* %3)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %p5 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %4 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p5, align 8, !tbaa !85
  %tobool = icmp ne %struct.proc_dir_entry* %4, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %for.end
  %list = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 13
  call void @list_del_init.62(%struct.list_head* %list)
  %parent = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %5 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent, align 8, !tbaa !82
  %cmp6 = icmp eq %struct.snd_info_entry* %5, null
  br i1 %cmp6, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end
  %parent7 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %6 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent7, align 8, !tbaa !82
  %p8 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %6, i32 0, i32 10
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end
  %p8.sink = phi %struct.proc_dir_entry** [ %p8, %cond.false ], [ @snd_proc_root, %if.end ]
  %7 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p8.sink, align 8, !tbaa !2
  %tobool9 = icmp ne %struct.proc_dir_entry* %7, null
  %lnot = xor i1 %tobool9, true
  %lnot10 = xor i1 %lnot, true
  %lnot11 = xor i1 %lnot10, true
  %lnot.ext = zext i1 %lnot11 to i32
  %tobool12 = icmp ne i32 %lnot.ext, 0
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext16 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool17 = icmp ne i64 %expval, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %cond.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12.50, i32 0, i32 0), i32 844)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %cond.end
  %p28 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %8 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p28, align 8, !tbaa !85
  call void @proc_remove(%struct.proc_dir_entry* %8)
  %p29 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %p29, align 8, !tbaa !85
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end19, %for.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init.62(%struct.list_head* %entry1) #3 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.63(%struct.list_head* %entry1)
  ret void
}

declare void @proc_remove(%struct.proc_dir_entry*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.63(%struct.list_head* %list) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !66
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !67
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_proc_new(%struct.snd_card* %card, i8* %name, %struct.snd_info_entry** %entryp) #0 {
entry:
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !71
  %call = call %struct.snd_info_entry* @snd_info_create_card_entry(%struct.snd_card* %card, i8* %name, %struct.snd_info_entry* %0)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.snd_info_entry* %call to i8*
  %call2 = call i32 @snd_device_new(%struct.snd_card* %card, i32 4102, i8* %1, %struct.snd_device_ops* @snd_card_proc_new.ops)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %tobool5 = icmp ne %struct.snd_info_entry** %entryp, null
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %if.end4
  store %struct.snd_info_entry* %call, %struct.snd_info_entry** %entryp, align 8, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %if.end4, %if.then3, %entry
  %retval.0 = phi i32 [ %call2, %if.then3 ], [ -12, %entry ], [ 0, %if.then6 ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.snd_info_entry* @snd_info_create_card_entry(%struct.snd_card* %card, i8* %name, %struct.snd_info_entry* %parent) #0 {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_entry(i8* %name)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 7
  %0 = load %struct.module*, %struct.module** %module, align 8, !tbaa !79
  %module2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 7
  store %struct.module* %0, %struct.module** %module2, align 8, !tbaa !106
  %card3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 6
  store %struct.snd_card* %card, %struct.snd_card** %card3, align 8, !tbaa !74
  %parent4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 5
  store %struct.snd_info_entry* %parent, %struct.snd_info_entry** %parent4, align 8, !tbaa !82
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.snd_info_entry* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_dev_free_entry(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !112
  %1 = bitcast i8* %0 to %struct.snd_info_entry*
  call void @snd_info_free_entry(%struct.snd_info_entry* %1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_dev_register_entry(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !112
  %1 = bitcast i8* %0 to %struct.snd_info_entry*
  %call = call i32 @snd_info_register(%struct.snd_info_entry* %1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal %struct.snd_info_entry* @snd_info_create_entry(i8* %name) #0 {
entry:
  %call = call i8* @kzalloc.52(i64 296, i32 208)
  %0 = bitcast i8* %call to %struct.snd_info_entry*
  %cmp = icmp eq %struct.snd_info_entry* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i8* @kstrdup(i8* %name, i32 208)
  %name3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 0
  store i8* %call2, i8** %name3, align 8, !tbaa !72
  %name4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 0
  %1 = load i8*, i8** %name4, align 8, !tbaa !72
  %cmp5 = icmp eq i8* %1, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %2 = bitcast %struct.snd_info_entry* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 1
  store i16 -32476, i16* %mode, align 8, !tbaa !83
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  store i16 0, i16* %content, align 8, !tbaa !89
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 11
  call void @__mutex_init(%struct.mutex* %access, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.17.66, i32 0, i32 0), %struct.lock_class_key* @snd_info_create_entry.__key)
  %children = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 12
  call void @INIT_LIST_HEAD.63(%struct.list_head* %children)
  %list = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 13
  call void @INIT_LIST_HEAD.63(%struct.list_head* %list)
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.then6, %entry
  %retval.0 = phi %struct.snd_info_entry* [ null, %if.then6 ], [ %0, %if.end7 ], [ null, %entry ]
  ret %struct.snd_info_entry* %retval.0
}

declare i8* @kstrdup(i8*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* %module, i8* %name, %struct.snd_info_entry* %parent) #0 {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_entry(i8* %name)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %module2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 7
  store %struct.module* %module, %struct.module** %module2, align 8, !tbaa !106
  %parent3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 5
  store %struct.snd_info_entry* %parent, %struct.snd_info_entry** %parent3, align 8, !tbaa !82
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.snd_info_entry* %call
}

; Function Attrs: nounwind uwtable
define i8* @snd_info_get_str(i8* %dest, i8* %src, i32 %len) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %src.addr.0 = phi i8* [ %src, %entry ], [ %incdec.ptr, %while.body ]
  %0 = load i8, i8* %src.addr.0, align 1, !tbaa !29
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 32
  br i1 %cmp, label %while.body, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %1 = load i8, i8* %src.addr.0, align 1, !tbaa !29
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 9
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %lor.rhs, %while.cond
  %incdec.ptr = getelementptr inbounds i8, i8* %src.addr.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %lor.rhs
  %2 = load i8, i8* %src.addr.0, align 1, !tbaa !29
  %conv5 = sext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv5, 34
  br i1 %cmp6, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.end
  %3 = load i8, i8* %src.addr.0, align 1, !tbaa !29
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 39
  br i1 %cmp9, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %while.end
  %incdec.ptr11 = getelementptr inbounds i8, i8* %src.addr.0, i32 1
  %4 = load i8, i8* %src.addr.0, align 1, !tbaa !29
  %conv12 = sext i8 %4 to i32
  br label %while.cond13

while.cond13:                                     ; preds = %while.body20, %if.then
  %len.addr.0 = phi i32 [ %len, %if.then ], [ %dec, %while.body20 ]
  %src.addr.1 = phi i8* [ %incdec.ptr11, %if.then ], [ %incdec.ptr21, %while.body20 ]
  %dest.addr.0 = phi i8* [ %dest, %if.then ], [ %incdec.ptr22, %while.body20 ]
  %dec = add nsw i32 %len.addr.0, -1
  %cmp14 = icmp sgt i32 %dec, 0
  br i1 %cmp14, label %land.lhs.true, label %while.end23

land.lhs.true:                                    ; preds = %while.cond13
  %5 = load i8, i8* %src.addr.1, align 1, !tbaa !29
  %conv16 = sext i8 %5 to i32
  %tobool = icmp ne i32 %conv16, 0
  br i1 %tobool, label %land.rhs, label %while.end23

land.rhs:                                         ; preds = %land.lhs.true
  %6 = load i8, i8* %src.addr.1, align 1, !tbaa !29
  %conv17 = sext i8 %6 to i32
  %cmp18 = icmp ne i32 %conv17, %conv12
  br i1 %cmp18, label %while.body20, label %while.end23

while.body20:                                     ; preds = %land.rhs
  %incdec.ptr21 = getelementptr inbounds i8, i8* %src.addr.1, i32 1
  %7 = load i8, i8* %src.addr.1, align 1, !tbaa !29
  %incdec.ptr22 = getelementptr inbounds i8, i8* %dest.addr.0, i32 1
  store i8 %7, i8* %dest.addr.0, align 1, !tbaa !29
  br label %while.cond13

while.end23:                                      ; preds = %land.rhs, %land.lhs.true, %while.cond13
  %8 = load i8, i8* %src.addr.1, align 1, !tbaa !29
  %conv24 = sext i8 %8 to i32
  %cmp25 = icmp eq i32 %conv24, %conv12
  %incdec.ptr28 = getelementptr inbounds i8, i8* %src.addr.1, i32 1
  %incdec.ptr28.src.addr.1 = select i1 %cmp25, i8* %incdec.ptr28, i8* %src.addr.1
  br label %if.end49

if.else:                                          ; preds = %lor.lhs.false
  br label %while.cond29

while.cond29:                                     ; preds = %while.body45, %if.else
  %len.addr.1 = phi i32 [ %len, %if.else ], [ %dec30, %while.body45 ]
  %src.addr.3 = phi i8* [ %src.addr.0, %if.else ], [ %incdec.ptr46, %while.body45 ]
  %dest.addr.1 = phi i8* [ %dest, %if.else ], [ %incdec.ptr47, %while.body45 ]
  %dec30 = add nsw i32 %len.addr.1, -1
  %cmp31 = icmp sgt i32 %dec30, 0
  br i1 %cmp31, label %land.lhs.true33, label %if.end49

land.lhs.true33:                                  ; preds = %while.cond29
  %9 = load i8, i8* %src.addr.3, align 1, !tbaa !29
  %conv34 = sext i8 %9 to i32
  %tobool35 = icmp ne i32 %conv34, 0
  br i1 %tobool35, label %land.lhs.true36, label %if.end49

land.lhs.true36:                                  ; preds = %land.lhs.true33
  %10 = load i8, i8* %src.addr.3, align 1, !tbaa !29
  %conv37 = sext i8 %10 to i32
  %cmp38 = icmp ne i32 %conv37, 32
  br i1 %cmp38, label %land.rhs40, label %if.end49

land.rhs40:                                       ; preds = %land.lhs.true36
  %11 = load i8, i8* %src.addr.3, align 1, !tbaa !29
  %conv41 = sext i8 %11 to i32
  %cmp42 = icmp ne i32 %conv41, 9
  br i1 %cmp42, label %while.body45, label %if.end49

while.body45:                                     ; preds = %land.rhs40
  %incdec.ptr46 = getelementptr inbounds i8, i8* %src.addr.3, i32 1
  %12 = load i8, i8* %src.addr.3, align 1, !tbaa !29
  %incdec.ptr47 = getelementptr inbounds i8, i8* %dest.addr.1, i32 1
  store i8 %12, i8* %dest.addr.1, align 1, !tbaa !29
  br label %while.cond29

if.end49:                                         ; preds = %land.rhs40, %land.lhs.true36, %land.lhs.true33, %while.cond29, %while.end23
  %src.addr.4 = phi i8* [ %incdec.ptr28.src.addr.1, %while.end23 ], [ %src.addr.3, %while.cond29 ], [ %src.addr.3, %land.lhs.true33 ], [ %src.addr.3, %land.lhs.true36 ], [ %src.addr.3, %land.rhs40 ]
  %dest.addr.2 = phi i8* [ %dest.addr.0, %while.end23 ], [ %dest.addr.1, %while.cond29 ], [ %dest.addr.1, %land.lhs.true33 ], [ %dest.addr.1, %land.lhs.true36 ], [ %dest.addr.1, %land.rhs40 ]
  store i8 0, i8* %dest.addr.2, align 1, !tbaa !29
  br label %while.cond50

while.cond50:                                     ; preds = %while.body59, %if.end49
  %src.addr.5 = phi i8* [ %src.addr.4, %if.end49 ], [ %incdec.ptr60, %while.body59 ]
  %13 = load i8, i8* %src.addr.5, align 1, !tbaa !29
  %conv51 = sext i8 %13 to i32
  %cmp52 = icmp eq i32 %conv51, 32
  br i1 %cmp52, label %while.body59, label %lor.rhs54

lor.rhs54:                                        ; preds = %while.cond50
  %14 = load i8, i8* %src.addr.5, align 1, !tbaa !29
  %conv55 = sext i8 %14 to i32
  %cmp56 = icmp eq i32 %conv55, 9
  br i1 %cmp56, label %while.body59, label %while.end61

while.body59:                                     ; preds = %lor.rhs54, %while.cond50
  %incdec.ptr60 = getelementptr inbounds i8, i8* %src.addr.5, i32 1
  br label %while.cond50

while.end61:                                      ; preds = %lor.rhs54
  ret i8* %src.addr.5
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_get_line(%struct.snd_info_buffer* %buffer, i8* %line, i32 %len) #0 {
entry:
  %tobool = icmp ne %struct.snd_info_buffer* %buffer, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %buffer1 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %0 = load i8*, i8** %buffer1, align 8, !tbaa !98
  %tobool2 = icmp ne i8* %0, null
  %lnot = xor i1 %tobool2, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %1 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot3 = xor i1 %1, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool5 = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12.50, i32 0, i32 0), i32 692)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool11 = icmp ne i32 %lnot.ext, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  %cmp = icmp sle i32 %len, 0
  %or.cond = or i1 %tobool18, %cmp
  br i1 %or.cond, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %stop = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  %2 = load i32, i32* %stop, align 4, !tbaa !114
  %tobool22 = icmp ne i32 %2, 0
  br i1 %tobool22, label %cleanup, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %lor.lhs.false
  %error = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 5
  %3 = load i32, i32* %error, align 8, !tbaa !108
  %tobool24 = icmp ne i32 %3, 0
  br i1 %tobool24, label %cleanup, label %if.end26

if.end26:                                         ; preds = %lor.lhs.false23
  br label %while.cond

while.cond:                                       ; preds = %if.end46, %if.end26
  %len.addr.0 = phi i32 [ %len, %if.end26 ], [ %len.addr.1, %if.end46 ]
  %line.addr.0 = phi i8* [ %line, %if.end26 ], [ %line.addr.1, %if.end46 ]
  %stop27 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  %4 = load i32, i32* %stop27, align 4, !tbaa !114
  %tobool28 = icmp ne i32 %4, 0
  %lnot29 = xor i1 %tobool28, true
  br i1 %lnot29, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %buffer31 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %5 = load i8*, i8** %buffer31, align 8, !tbaa !98
  %curr = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 1
  %6 = load i32, i32* %curr, align 8, !tbaa !115
  %inc = add i32 %6, 1
  store i32 %inc, i32* %curr, align 8, !tbaa !115
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr inbounds i8, i8* %5, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !29
  %conv32 = sext i8 %7 to i32
  %curr33 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 1
  %8 = load i32, i32* %curr33, align 8, !tbaa !115
  %size = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 2
  %9 = load i32, i32* %size, align 4, !tbaa !96
  %cmp34 = icmp uge i32 %8, %9
  br i1 %cmp34, label %if.then36, label %if.end38

if.then36:                                        ; preds = %while.body
  %stop37 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  store i32 1, i32* %stop37, align 4, !tbaa !114
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %while.body
  %cmp39 = icmp eq i32 %conv32, 10
  br i1 %cmp39, label %while.end, label %if.end42

if.end42:                                         ; preds = %if.end38
  %tobool43 = icmp ne i32 %len.addr.0, 0
  br i1 %tobool43, label %if.then44, label %if.end46

if.then44:                                        ; preds = %if.end42
  %dec = add nsw i32 %len.addr.0, -1
  %conv45 = trunc i32 %conv32 to i8
  %incdec.ptr = getelementptr inbounds i8, i8* %line.addr.0, i32 1
  store i8 %conv45, i8* %line.addr.0, align 1, !tbaa !29
  br label %if.end46

if.end46:                                         ; preds = %if.then44, %if.end42
  %len.addr.1 = phi i32 [ %dec, %if.then44 ], [ %len.addr.0, %if.end42 ]
  %line.addr.1 = phi i8* [ %incdec.ptr, %if.then44 ], [ %line.addr.0, %if.end42 ]
  br label %while.cond

while.end:                                        ; preds = %if.end38, %while.cond
  store i8 0, i8* %line.addr.0, align 1, !tbaa !29
  br label %cleanup

cleanup:                                          ; preds = %while.end, %lor.lhs.false23, %lor.lhs.false, %if.end
  %retval.0 = phi i32 [ 0, %while.end ], [ 1, %if.end ], [ 1, %lor.lhs.false23 ], [ 1, %lor.lhs.false ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* %fmt, ...) #0 {
entry:
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  call void @__might_sleep(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12.50, i32 0, i32 0), i32 116, i32 0)
  %stop = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  %0 = load i32, i32* %stop, align 4, !tbaa !114
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cleanup37, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %error = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 5
  %1 = load i32, i32* %error, align 8, !tbaa !108
  %tobool4 = icmp ne i32 %1, 0
  br i1 %tobool4, label %cleanup37, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %len5 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 3
  %2 = load i32, i32* %len5, align 8, !tbaa !101
  %size = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 2
  %3 = load i32, i32* %size, align 4, !tbaa !96
  %sub = sub i32 %2, %3
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay6 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay6)
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.end
  %len.0 = phi i32 [ %sub, %if.end ], [ %len.1, %cleanup.cont ]
  %err.0 = phi i32 [ 0, %if.end ], [ %err.1, %cleanup.cont ]
  %arraydecay7 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %ap, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %4 = bitcast %struct.__va_list_tag* %arraydecay7 to i8*
  %5 = bitcast %struct.__va_list_tag* %arraydecay8 to i8*
  call void @llvm.va_copy(i8* %4, i8* %5)
  %buffer9 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %6 = load i8*, i8** %buffer9, align 8, !tbaa !98
  %curr = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 1
  %7 = load i32, i32* %curr, align 8, !tbaa !115
  %idx.ext = zext i32 %7 to i64
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 %idx.ext
  %conv = sext i32 %len.0 to i64
  %arraydecay10 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %ap, i32 0, i32 0
  %call = call i32 @vsnprintf(i8* %add.ptr, i64 %conv, i8* %fmt, %struct.__va_list_tag* %arraydecay10)
  %arraydecay11 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %ap, i32 0, i32 0
  %arraydecay1112 = bitcast %struct.__va_list_tag* %arraydecay11 to i8*
  call void @llvm.va_end(i8* %arraydecay1112)
  %cmp = icmp slt i32 %call, %len.0
  br i1 %cmp, label %cleanup, label %if.end15

if.end15:                                         ; preds = %for.cond
  %len16 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 3
  %8 = load i32, i32* %len16, align 8, !tbaa !101
  %conv17 = zext i32 %8 to i64
  %add = add i64 %conv17, 4096
  %conv18 = trunc i64 %add to i32
  %call19 = call i32 @resize_info_buffer(%struct.snd_info_buffer* %buffer, i32 %conv18)
  %cmp20 = icmp slt i32 %call19, 0
  br i1 %cmp20, label %cleanup, label %if.end23

if.end23:                                         ; preds = %if.end15
  %len24 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 3
  %9 = load i32, i32* %len24, align 8, !tbaa !101
  %size25 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 2
  %10 = load i32, i32* %size25, align 4, !tbaa !96
  %sub26 = sub i32 %9, %10
  br label %cleanup

cleanup:                                          ; preds = %if.end23, %if.end15, %for.cond
  %len.1 = phi i32 [ %sub26, %if.end23 ], [ %len.0, %for.cond ], [ %len.0, %if.end15 ]
  %err.1 = phi i32 [ %call19, %if.end23 ], [ %err.0, %for.cond ], [ %call19, %if.end15 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end23 ], [ 6, %for.cond ], [ 6, %if.end15 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 6
  br i1 %SwitchLeaf, label %for.end, label %cleanup.cont

cleanup.cont:                                     ; preds = %cleanup
  br label %for.cond

for.end:                                          ; preds = %cleanup
  %arraydecay27 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay2728 = bitcast %struct.__va_list_tag* %arraydecay27 to i8*
  call void @llvm.va_end(i8* %arraydecay2728)
  %cmp29 = icmp slt i32 %err.1, 0
  br i1 %cmp29, label %cleanup37, label %if.end32

if.end32:                                         ; preds = %for.end
  %curr33 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 1
  %11 = load i32, i32* %curr33, align 8, !tbaa !115
  %add34 = add i32 %11, %call
  store i32 %add34, i32* %curr33, align 8, !tbaa !115
  %size35 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 2
  %12 = load i32, i32* %size35, align 4, !tbaa !96
  %add36 = add i32 %12, %call
  store i32 %add36, i32* %size35, align 4, !tbaa !96
  br label %cleanup37

cleanup37:                                        ; preds = %if.end32, %for.end, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ %call, %if.end32 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ %err.1, %for.end ]
  ret i32 %retval.0
}

declare void @__might_sleep(i8*, i32, i32) #1

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #8

; Function Attrs: nounwind
declare void @llvm.va_copy(i8*, i8*) #8

declare i32 @vsnprintf(i8*, i64, i8*, %struct.__va_list_tag*) #1

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #8

; Function Attrs: nounwind uwtable
define i32 @snd_info_check_reserved_words(i8* %str) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %xstr.0 = phi i8** [ getelementptr inbounds ([12 x i8*], [12 x i8*]* @snd_info_check_reserved_words.reserved, i32 0, i32 0), %entry ], [ %incdec.ptr, %if.end ]
  %0 = load i8*, i8** %xstr.0, align 8, !tbaa !2
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i8*, i8** %xstr.0, align 8, !tbaa !2
  %call = call i32 @strcmp(i8* %1, i8* %str)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.end, label %cleanup

if.end:                                           ; preds = %while.body
  %incdec.ptr = getelementptr inbounds i8*, i8** %xstr.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %call2 = call i32 @strncmp(i8* %str, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11.73, i32 0, i32 0), i64 4)
  %tobool3 = icmp ne i32 %call2, 0
  %. = select i1 %tobool3, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %while.end, %while.body
  %retval.0 = phi i32 [ 0, %while.body ], [ %., %while.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_init() #4 section ".init.text" {
entry:
  %call = call %struct.proc_dir_entry* @proc_mkdir(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13.87, i32 0, i32 0), %struct.proc_dir_entry* null)
  %cmp = icmp eq %struct.proc_dir_entry* %call, null
  br i1 %cmp, label %cleanup27, label %if.end

if.end:                                           ; preds = %entry
  store %struct.proc_dir_entry* %call, %struct.proc_dir_entry** @snd_proc_root, align 8, !tbaa !2
  %call2 = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.79, i32 0, i32 0), %struct.snd_info_entry* null)
  %cmp3 = icmp eq %struct.snd_info_entry* %call2, null
  br i1 %cmp3, label %LeafBlock, label %if.end5

if.end5:                                          ; preds = %if.end
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call2, i32 0, i32 1
  store i16 16749, i16* %mode, align 8, !tbaa !83
  %call6 = call i32 @snd_info_register(%struct.snd_info_entry* %call2)
  %cmp7 = icmp slt i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  call void @snd_info_free_entry(%struct.snd_info_entry* %call2)
  br label %LeafBlock

if.end9:                                          ; preds = %if.end5
  store %struct.snd_info_entry* %call2, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end9, %if.then8, %if.end
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then8 ], [ 0, %if.end9 ], [ 1, %if.end ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %cleanup.cont, label %cleanup27

cleanup.cont:                                     ; preds = %LeafBlock
  %call11 = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10.84, i32 0, i32 0), %struct.snd_info_entry* null)
  %cmp12 = icmp eq %struct.snd_info_entry* %call11, null
  br i1 %cmp12, label %LeafBlock2, label %if.end14

if.end14:                                         ; preds = %cleanup.cont
  %mode15 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call11, i32 0, i32 1
  store i16 16749, i16* %mode15, align 8, !tbaa !83
  %call16 = call i32 @snd_info_register(%struct.snd_info_entry* %call11)
  %cmp17 = icmp slt i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  call void @snd_info_free_entry(%struct.snd_info_entry* %call11)
  br label %LeafBlock2

if.end19:                                         ; preds = %if.end14
  store %struct.snd_info_entry* %call11, %struct.snd_info_entry** @snd_seq_root, align 8, !tbaa !2
  br label %LeafBlock2

LeafBlock2:                                       ; preds = %if.end19, %if.then18, %cleanup.cont
  %cleanup.dest.slot.1 = phi i32 [ 1, %if.then18 ], [ 0, %if.end19 ], [ 1, %cleanup.cont ]
  %SwitchLeaf3 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf3, label %cleanup.cont22, label %cleanup27

cleanup.cont22:                                   ; preds = %LeafBlock2
  call void @snd_info_version_init()
  %call24 = call i32 @snd_minor_info_init()
  %call25 = call i32 @snd_minor_info_oss_init()
  %call26 = call i32 @snd_card_info_init()
  br label %cleanup27

cleanup27:                                        ; preds = %cleanup.cont22, %LeafBlock2, %LeafBlock, %entry
  %retval.2 = phi i32 [ 0, %cleanup.cont22 ], [ -12, %entry ], [ -12, %LeafBlock ], [ -12, %LeafBlock2 ]
  ret i32 %retval.2
}

declare %struct.proc_dir_entry* @proc_mkdir(i8*, %struct.proc_dir_entry*) #1

; Function Attrs: nounwind uwtable
define internal void @snd_info_version_init() #4 section ".init.text" {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.74, i32 0, i32 0), %struct.snd_info_entry* null)
  %cmp = icmp eq %struct.snd_info_entry* %call, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.47* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_info_version_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !29
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  %cmp3 = icmp slt i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %cleanup

if.end5:                                          ; preds = %if.end
  store %struct.snd_info_entry* %call, %struct.snd_info_entry** @snd_info_version_entry, align 8, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.then4, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snd_info_version_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  %call = call %struct.new_utsname* @init_utsname()
  %release = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call, i32 0, i32 2
  %arraydecay = getelementptr inbounds [65 x i8], [65 x i8]* %release, i32 0, i32 0
  %call2 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.21.88, i32 0, i32 0), i8* %arraydecay)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.new_utsname* @init_utsname() #3 {
entry:
  ret %struct.new_utsname* getelementptr inbounds (%struct.uts_namespace, %struct.uts_namespace* @init_uts_ns, i32 0, i32 1)
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_done() #4 section ".exit.text" {
entry:
  %call = call i32 @snd_card_info_done()
  %call1 = call i32 @snd_minor_info_oss_done()
  %call2 = call i32 @snd_minor_info_done()
  call void @snd_info_version_done()
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** @snd_proc_root, align 8, !tbaa !2
  %tobool = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_seq_root, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %1)
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %2)
  %3 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** @snd_proc_root, align 8, !tbaa !2
  call void @proc_remove(%struct.proc_dir_entry* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @snd_info_version_done() #4 section ".exit.text" {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_info_version_entry, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_card_create(%struct.snd_card* %card) #0 {
entry:
  %str = alloca [8 x i8], align 1
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12.50, i32 0, i32 0), i32 595)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %0 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 7
  %1 = load %struct.module*, %struct.module** %module, align 8, !tbaa !79
  %arraydecay20 = getelementptr inbounds [8 x i8], [8 x i8]* %str, i32 0, i32 0
  %call21 = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* %1, i8* %arraydecay20, %struct.snd_info_entry* null)
  %cmp = icmp eq %struct.snd_info_entry* %call21, null
  br i1 %cmp, label %cleanup, label %if.end24

if.end24:                                         ; preds = %if.end19
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call21, i32 0, i32 1
  store i16 16749, i16* %mode, align 8, !tbaa !83
  %call25 = call i32 @snd_info_register(%struct.snd_info_entry* %call21)
  %cmp26 = icmp slt i32 %call25, 0
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end24
  call void @snd_info_free_entry(%struct.snd_info_entry* %call21)
  br label %cleanup

if.end29:                                         ; preds = %if.end24
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  store %struct.snd_info_entry* %call21, %struct.snd_info_entry** %proc_root, align 8, !tbaa !71
  br label %cleanup

cleanup:                                          ; preds = %if.end29, %if.then28, %if.end19, %if.end
  %retval.0 = phi i32 [ -12, %if.then28 ], [ 0, %if.end29 ], [ -6, %if.end ], [ -12, %if.end19 ]
  ret i32 %retval.0
}

declare i32 @sprintf(i8*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define i32 @snd_info_card_register(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12.50, i32 0, i32 0), i32 618)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !71
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 0
  %1 = load i8*, i8** %name, align 8, !tbaa !72
  %call = call i32 @strcmp(i8* %arraydecay, i8* %1)
  %tobool19 = icmp ne i32 %call, 0
  br i1 %tobool19, label %if.end21, label %cleanup

if.end21:                                         ; preds = %if.end18
  %id22 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay23 = getelementptr inbounds [16 x i8], [16 x i8]* %id22, i32 0, i32 0
  %2 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** @snd_proc_root, align 8, !tbaa !2
  %proc_root24 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %3 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root24, align 8, !tbaa !71
  %name25 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 0
  %4 = load i8*, i8** %name25, align 8, !tbaa !72
  %call26 = call %struct.proc_dir_entry* @proc_symlink(i8* %arraydecay23, %struct.proc_dir_entry* %2, i8* %4)
  %cmp = icmp eq %struct.proc_dir_entry* %call26, null
  br i1 %cmp, label %cleanup, label %if.end29

if.end29:                                         ; preds = %if.end21
  %proc_root_link = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  store %struct.proc_dir_entry* %call26, %struct.proc_dir_entry** %proc_root_link, align 8, !tbaa !116
  br label %cleanup

cleanup:                                          ; preds = %if.end29, %if.end21, %if.end18, %if.end
  %retval.0 = phi i32 [ 0, %if.end29 ], [ -6, %if.end ], [ 0, %if.end18 ], [ -12, %if.end21 ]
  ret i32 %retval.0
}

declare %struct.proc_dir_entry* @proc_symlink(i8*, %struct.proc_dir_entry*, i8*) #1

; Function Attrs: nounwind uwtable
define void @snd_info_card_id_change(%struct.snd_card* %card) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  %proc_root_link = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_root_link, align 8, !tbaa !116
  %tobool = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %proc_root_link1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  %1 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_root_link1, align 8, !tbaa !116
  call void @proc_remove(%struct.proc_dir_entry* %1)
  %proc_root_link2 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %proc_root_link2, align 8, !tbaa !116
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !71
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 0
  %3 = load i8*, i8** %name, align 8, !tbaa !72
  %call = call i32 @strcmp(i8* %arraydecay, i8* %3)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.then4, label %if.end11

if.then4:                                         ; preds = %if.end
  %id5 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay6 = getelementptr inbounds [16 x i8], [16 x i8]* %id5, i32 0, i32 0
  %4 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** @snd_proc_root, align 8, !tbaa !2
  %proc_root7 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %5 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root7, align 8, !tbaa !71
  %name8 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %5, i32 0, i32 0
  %6 = load i8*, i8** %name8, align 8, !tbaa !72
  %call9 = call %struct.proc_dir_entry* @proc_symlink(i8* %arraydecay6, %struct.proc_dir_entry* %4, i8* %6)
  %proc_root_link10 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  store %struct.proc_dir_entry* %call9, %struct.proc_dir_entry** %proc_root_link10, align 8, !tbaa !116
  br label %if.end11

if.end11:                                         ; preds = %if.then4, %if.end
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_info_card_disconnect(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  %proc_root_link = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_root_link, align 8, !tbaa !116
  call void @proc_remove(%struct.proc_dir_entry* %0)
  %proc_root_link1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %proc_root_link1, align 8, !tbaa !116
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !71
  %tobool2 = icmp ne %struct.snd_info_entry* %1, null
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %proc_root4 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root4, align 8, !tbaa !71
  call void @snd_info_disconnect(%struct.snd_info_entry* %2)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %return

return:                                           ; preds = %if.end5, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_card_free(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !71
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  %proc_root1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  store %struct.snd_info_entry* null, %struct.snd_info_entry** %proc_root1, align 8, !tbaa !71
  br label %return

return:                                           ; preds = %if.end, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_enum_info(%struct.snd_ctl_elem_info* %info, i32 %channels, i32 %items, i8** %names) #0 {
entry:
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 1
  store i32 3, i32* %type, align 8, !tbaa !117
  %count = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  store i32 %channels, i32* %count, align 8, !tbaa !120
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated = bitcast %union.anon.48* %value to %struct.anon.51*
  %items1 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated, i32 0, i32 0
  store i32 %items, i32* %items1, align 8, !tbaa !29
  %value2 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated3 = bitcast %union.anon.48* %value2 to %struct.anon.51*
  %item = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated3, i32 0, i32 1
  %0 = load i32, i32* %item, align 4, !tbaa !29
  %cmp = icmp uge i32 %0, %items
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sub = sub i32 %items, 1
  %value4 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated5 = bitcast %union.anon.48* %value4 to %struct.anon.51*
  %item6 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated5, i32 0, i32 1
  store i32 %sub, i32* %item6, align 4, !tbaa !29
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %value7 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated8 = bitcast %union.anon.48* %value7 to %struct.anon.51*
  %name = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated8, i32 0, i32 2
  %arraydecay = getelementptr inbounds [64 x i8], [64 x i8]* %name, i32 0, i32 0
  %value9 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated10 = bitcast %union.anon.48* %value9 to %struct.anon.51*
  %item11 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated10, i32 0, i32 1
  %1 = load i32, i32* %item11, align 4, !tbaa !29
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %names, i64 %idxprom
  %2 = load i8*, i8** %arrayidx, align 8, !tbaa !2
  %call = call i64 @strlcpy(i8* %arraydecay, i8* %2, i64 64)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_boolean_stereo_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 1
  store i32 1, i32* %type, align 8, !tbaa !117
  %count = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 3
  store i32 2, i32* %count, align 8, !tbaa !120
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer = bitcast %union.anon.48* %value to %struct.task_cputime*
  %min = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer, i32 0, i32 0
  store i64 0, i64* %min, align 8, !tbaa !29
  %value1 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer2 = bitcast %union.anon.48* %value1 to %struct.task_cputime*
  %max = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer2, i32 0, i32 1
  store i64 1, i64* %max, align 8, !tbaa !29
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_boolean_mono_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 1
  store i32 1, i32* %type, align 8, !tbaa !117
  %count = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 3
  store i32 1, i32* %count, align 8, !tbaa !120
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer = bitcast %union.anon.48* %value to %struct.task_cputime*
  %min = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer, i32 0, i32 0
  store i64 0, i64* %min, align 8, !tbaa !29
  %value1 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer2 = bitcast %union.anon.48* %value1 to %struct.task_cputime*
  %max = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer2, i32 0, i32 1
  store i64 1, i64* %max, align 8, !tbaa !29
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_unregister_ioctl_compat(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn) #0 {
entry:
  %call = call i32 @_snd_ctl_unregister_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* @snd_control_compat_ioctls)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @_snd_ctl_unregister_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* %lists) #0 {
entry:
  %tobool = icmp ne i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 1530)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  call void @down_write(%struct.rw_semaphore* @snd_ioctl_rwsem)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end18
  %list27.sink = phi %struct.list_head* [ %list24, %for.inc ], [ %lists, %if.end18 ]
  %next28 = getelementptr inbounds %struct.list_head, %struct.list_head* %list27.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next28, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr30 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr30 to %struct.snd_kctl_ioctl*
  %list = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %2, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, %lists
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %fioctl = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %2, i32 0, i32 1
  %3 = load i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)** %fioctl, align 8, !tbaa !121
  %cmp21 = icmp eq i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %3, %fcn
  %list24 = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %2, i32 0, i32 0
  br i1 %cmp21, label %if.then23, label %for.inc

if.then23:                                        ; preds = %for.body
  call void @list_del(%struct.list_head* %list24)
  call void @up_write(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %4 = bitcast %struct.snd_kctl_ioctl* %2 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @up_write(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %tobool32 = icmp ne i32 1, 0
  %lnot33 = xor i1 %tobool32, true
  %lnot35 = xor i1 %lnot33, true
  %lnot.ext36 = zext i1 %lnot35 to i32
  %conv37 = sext i32 %lnot.ext36 to i64
  %expval38 = call i64 @llvm.expect.i64(i64 %conv37, i64 0)
  %tobool39 = icmp ne i64 %expval38, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %for.end
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 1542, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7.144, i32 0, i32 0))
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %for.end
  br label %cleanup

cleanup:                                          ; preds = %if.end41, %if.then23, %if.end
  %retval.0 = phi i32 [ 0, %if.then23 ], [ -22, %if.end41 ], [ -22, %if.end ]
  ret i32 %retval.0
}

declare void @down_write(%struct.rw_semaphore*) #1

declare void @up_write(%struct.rw_semaphore*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_unregister_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn) #0 {
entry:
  %call = call i32 @_snd_ctl_unregister_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* @snd_control_ioctls)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_register_ioctl_compat(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn) #0 {
entry:
  %call = call i32 @_snd_ctl_register_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* @snd_control_compat_ioctls)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @_snd_ctl_register_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* %lists) #0 {
entry:
  %call = call i8* @kzalloc.107(i64 24, i32 208)
  %0 = bitcast i8* %call to %struct.snd_kctl_ioctl*
  %cmp = icmp eq %struct.snd_kctl_ioctl* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %fioctl = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %0, i32 0, i32 1
  store i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)** %fioctl, align 8, !tbaa !121
  call void @down_write(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %list = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %0, i32 0, i32 0
  call void @list_add_tail.108(%struct.list_head* %list, %struct.list_head* %lists)
  call void @up_write(%struct.rw_semaphore* @snd_ioctl_rwsem)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.107(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.108(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !67
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_register_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn) #0 {
entry:
  %call = call i32 @_snd_ctl_register_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* @snd_control_ioctls)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne %struct.snd_ctl_elem_id* %id, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 659)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %1 = load i32, i32* %numid, align 4, !tbaa !123
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end19
  %numid22 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %2 = load i32, i32* %numid22, align 4, !tbaa !123
  %call = call %struct.snd_kcontrol* @snd_ctl_find_numid(%struct.snd_card* %card, i32 %2)
  br label %cleanup

if.end23:                                         ; preds = %if.end19
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end23
  %list67.sink = phi %struct.list_head* [ %list67, %for.inc ], [ %controls, %if.end23 ]
  %next68 = getelementptr inbounds %struct.list_head, %struct.list_head* %list67.sink, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next68, align 8, !tbaa !2
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr70 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr70 to %struct.snd_kcontrol*
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 0
  %controls25 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  %cmp26 = icmp ne %struct.list_head* %list, %controls25
  br i1 %cmp26, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %id28 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %iface = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id28, i32 0, i32 1
  %6 = load i32, i32* %iface, align 4, !tbaa !124
  %iface29 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 1
  %7 = load i32, i32* %iface29, align 4, !tbaa !126
  %cmp30 = icmp ne i32 %6, %7
  br i1 %cmp30, label %for.inc, label %if.end33

if.end33:                                         ; preds = %for.body
  %id34 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %device = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id34, i32 0, i32 2
  %8 = load i32, i32* %device, align 8, !tbaa !127
  %device35 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 2
  %9 = load i32, i32* %device35, align 4, !tbaa !128
  %cmp36 = icmp ne i32 %8, %9
  br i1 %cmp36, label %for.inc, label %if.end39

if.end39:                                         ; preds = %if.end33
  %id40 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %subdevice = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id40, i32 0, i32 3
  %10 = load i32, i32* %subdevice, align 4, !tbaa !129
  %subdevice41 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 3
  %11 = load i32, i32* %subdevice41, align 4, !tbaa !130
  %cmp42 = icmp ne i32 %10, %11
  br i1 %cmp42, label %for.inc, label %if.end45

if.end45:                                         ; preds = %if.end39
  %id46 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %name = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id46, i32 0, i32 4
  %arraydecay = getelementptr inbounds [44 x i8], [44 x i8]* %name, i32 0, i32 0
  %name47 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 4
  %arraydecay48 = getelementptr inbounds [44 x i8], [44 x i8]* %name47, i32 0, i32 0
  %call49 = call i32 @strncmp(i8* %arraydecay, i8* %arraydecay48, i64 44)
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %for.inc, label %if.end52

if.end52:                                         ; preds = %if.end45
  %id53 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id53, i32 0, i32 5
  %12 = load i32, i32* %index, align 4, !tbaa !131
  %index54 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %13 = load i32, i32* %index54, align 4, !tbaa !132
  %cmp55 = icmp ugt i32 %12, %13
  br i1 %cmp55, label %for.inc, label %if.end58

if.end58:                                         ; preds = %if.end52
  %id59 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %index60 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id59, i32 0, i32 5
  %14 = load i32, i32* %index60, align 4, !tbaa !131
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 2
  %15 = load i32, i32* %count, align 8, !tbaa !133
  %add = add i32 %14, %15
  %index61 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %16 = load i32, i32* %index61, align 4, !tbaa !132
  %cmp62 = icmp ule i32 %add, %16
  br i1 %cmp62, label %for.inc, label %cleanup

for.inc:                                          ; preds = %if.end58, %if.end52, %if.end45, %if.end39, %if.end33, %for.body
  %list67 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %if.end58, %for.cond, %if.then21, %if.end
  %retval.0 = phi %struct.snd_kcontrol* [ %call, %if.then21 ], [ null, %if.end ], [ %5, %if.end58 ], [ null, %for.cond ]
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.snd_kcontrol* @snd_ctl_find_numid(%struct.snd_card* %card, i32 %numid) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne i32 %numid, 0
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 630)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %list33.sink = phi %struct.list_head* [ %list33, %for.inc ], [ %controls, %if.end19 ]
  %next34 = getelementptr inbounds %struct.list_head, %struct.list_head* %list33.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next34, align 8, !tbaa !2
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr36 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr36 to %struct.snd_kcontrol*
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 0
  %controls21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  %cmp = icmp ne %struct.list_head* %list, %controls21
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 1
  %numid23 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %4 = load i32, i32* %numid23, align 8, !tbaa !134
  %cmp24 = icmp ule i32 %4, %numid
  br i1 %cmp24, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %id26 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 1
  %numid27 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id26, i32 0, i32 0
  %5 = load i32, i32* %numid27, align 8, !tbaa !134
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 2
  %6 = load i32, i32* %count, align 8, !tbaa !133
  %add = add i32 %5, %6
  %cmp28 = icmp ugt i32 %add, %numid
  br i1 %cmp28, label %cleanup, label %for.inc

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %list33 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %land.lhs.true, %for.cond, %if.end
  %retval.0 = phi %struct.snd_kcontrol* [ null, %if.end ], [ %3, %land.lhs.true ], [ null, %for.cond ]
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_rename_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %src_id, %struct.snd_ctl_elem_id* %dst_id) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %src_id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %controls_rwsem1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 1
  %0 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %1 = bitcast %struct.snd_ctl_elem_id* %dst_id to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 64, i32 4, i1 false), !tbaa.struct !135
  %last_numid = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %2 = load i32, i32* %last_numid, align 8, !tbaa !136
  %add = add i32 %2, 1
  %id2 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 1
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id2, i32 0, i32 0
  store i32 %add, i32* %numid, align 8, !tbaa !134
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 2
  %3 = load i32, i32* %count, align 8, !tbaa !133
  %last_numid3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %4 = load i32, i32* %last_numid3, align 8, !tbaa !136
  %add4 = add i32 %4, %3
  store i32 %add4, i32* %last_numid3, align 8, !tbaa !136
  %controls_rwsem5 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem5)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ -2, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_activate_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id, i32 %active) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %unlock, label %if.end

if.end:                                           ; preds = %entry
  %id1 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 1
  %call2 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_id* %id1)
  %vd3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom = zext i32 %call2 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd3, i64 0, i64 %idxprom
  %tobool = icmp ne i32 %active, 0
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %0 = load i32, i32* %access, align 8, !tbaa !137
  %and = and i32 %0, 256
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  br i1 %tobool5, label %if.end7, label %unlock

if.end7:                                          ; preds = %if.then4
  %access8 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %1 = load i32, i32* %access8, align 8, !tbaa !137
  %and9 = and i32 %1, -257
  store i32 %and9, i32* %access8, align 8, !tbaa !137
  br label %unlock

if.else:                                          ; preds = %if.end
  br i1 %tobool5, label %unlock, label %if.end14

if.end14:                                         ; preds = %if.else
  %access15 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %2 = load i32, i32* %access15, align 8, !tbaa !137
  %or = or i32 %2, 256
  store i32 %or, i32* %access15, align 8, !tbaa !137
  br label %unlock

unlock:                                           ; preds = %if.end14, %if.else, %if.end7, %if.then4, %entry
  %ret.0 = phi i32 [ -2, %entry ], [ 0, %if.then4 ], [ 0, %if.else ], [ 1, %if.end14 ], [ 1, %if.end7 ]
  %controls_rwsem17 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem17)
  %cmp18 = icmp sgt i32 %ret.0, 0
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %unlock
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 2, %struct.snd_ctl_elem_id* %id)
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %unlock
  ret i32 %ret.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %kctl, %struct.snd_ctl_elem_id* %id) #3 {
entry:
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %0 = load i32, i32* %numid, align 4, !tbaa !123
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i32 @snd_ctl_get_ioffnum(%struct.snd_kcontrol* %kctl, %struct.snd_ctl_elem_id* %id)
  br label %return

if.else:                                          ; preds = %entry
  %call1 = call i32 @snd_ctl_get_ioffidx(%struct.snd_kcontrol* %kctl, %struct.snd_ctl_elem_id* %id)
  br label %return

return:                                           ; preds = %if.else, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @snd_ctl_notify(%struct.snd_card* %card, i32 %mask, %struct.snd_ctl_elem_id* %id) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne %struct.snd_ctl_elem_id* %id, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 151)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup.cont, label %if.end19

if.end19:                                         ; preds = %if.end
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  call void @_raw_read_lock(%struct.rwlock_t* %ctl_files_rwlock)
  %mixer_oss_change_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 34
  %1 = load i32, i32* %mixer_oss_change_count, align 8, !tbaa !139
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* %mixer_oss_change_count, align 8, !tbaa !139
  %ctl_files = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 17
  br label %for.cond

for.cond:                                         ; preds = %for.inc64, %if.end19
  %list66.sink = phi %struct.list_head* [ %list66, %for.inc64 ], [ %ctl_files, %if.end19 ]
  %next67 = getelementptr inbounds %struct.list_head, %struct.list_head* %list66.sink, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next67, align 8, !tbaa !2
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr69 = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr69 to %struct.snd_ctl_file*
  %list = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 0
  %ctl_files21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 17
  %cmp = icmp ne %struct.list_head* %list, %ctl_files21
  br i1 %cmp, label %for.body, label %for.end70

for.body:                                         ; preds = %for.cond
  %subscribed = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 8
  %5 = load i32, i32* %subscribed, align 8, !tbaa !140
  %tobool23 = icmp ne i32 %5, 0
  br i1 %tobool23, label %do.body26, label %for.inc64

do.body26:                                        ; preds = %for.body
  %read_lock = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 6
  %call = call %struct.raw_spinlock* @spinlock_check.110(%struct.spinlock* %read_lock)
  %call30 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %events = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 9
  br label %for.cond37

for.cond37:                                       ; preds = %for.inc, %do.body26
  %list51.sink = phi %struct.list_head* [ %list51, %for.inc ], [ %events, %do.body26 ]
  %next52 = getelementptr inbounds %struct.list_head, %struct.list_head* %list51.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next52, align 8, !tbaa !2
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr54 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr54 to %struct.snd_kctl_event*
  %list38 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %8, i32 0, i32 0
  %events39 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 9
  %cmp40 = icmp ne %struct.list_head* %list38, %events39
  br i1 %cmp40, label %for.body42, label %for.end

for.body42:                                       ; preds = %for.cond37
  %id43 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %8, i32 0, i32 1
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id43, i32 0, i32 0
  %9 = load i32, i32* %numid, align 8, !tbaa !142
  %numid44 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %10 = load i32, i32* %numid44, align 4, !tbaa !123
  %cmp45 = icmp eq i32 %9, %10
  br i1 %cmp45, label %if.then47, label %for.inc

if.then47:                                        ; preds = %for.body42
  %mask48 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %8, i32 0, i32 2
  %11 = load i32, i32* %mask48, align 8, !tbaa !144
  %or = or i32 %11, %mask
  store i32 %or, i32* %mask48, align 8, !tbaa !144
  br label %_found

for.inc:                                          ; preds = %for.body42
  %list51 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %8, i32 0, i32 0
  br label %for.cond37

for.end:                                          ; preds = %for.cond37
  %call55 = call i8* @kzalloc.107(i64 88, i32 32)
  %12 = bitcast i8* %call55 to %struct.snd_kctl_event*
  %tobool56 = icmp ne %struct.snd_kctl_event* %12, null
  br i1 %tobool56, label %if.then57, label %if.else

if.then57:                                        ; preds = %for.end
  %id58 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %12, i32 0, i32 1
  %13 = bitcast %struct.snd_ctl_elem_id* %id58 to i8*
  %14 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 64, i32 4, i1 false), !tbaa.struct !135
  %mask59 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %12, i32 0, i32 2
  store i32 %mask, i32* %mask59, align 8, !tbaa !144
  %list60 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %12, i32 0, i32 0
  %events61 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 9
  call void @list_add_tail.108(%struct.list_head* %list60, %struct.list_head* %events61)
  br label %_found

if.else:                                          ; preds = %for.end
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.1.111, i32 0, i32 0))
  br label %_found

_found:                                           ; preds = %if.else, %if.then57, %if.then47
  %change_sleep = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 5
  call void @__wake_up(%struct.__wait_queue_head* %change_sleep, i32 3, i32 1, i8* null)
  %read_lock63 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 6
  call void @spin_unlock_irqrestore(%struct.spinlock* %read_lock63, i64 %call30)
  %fasync = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 7
  call void @kill_fasync(%struct.fasync_struct** %fasync, i32 29, i32 131073)
  br label %for.inc64

for.inc64:                                        ; preds = %_found, %for.body
  %list66 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 0
  br label %for.cond

for.end70:                                        ; preds = %for.cond
  %ctl_files_rwlock71 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  call void @_raw_read_unlock(%struct.rwlock_t* %ctl_files_rwlock71)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end70, %if.end
  ret void
}

declare void @_raw_read_lock(%struct.rwlock_t*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.110(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @kill_fasync(%struct.fasync_struct**, i32, i32) #1

declare void @_raw_read_unlock(%struct.rwlock_t*) #1 section ".spinlock.text"

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @snd_ctl_get_ioffnum(%struct.snd_kcontrol* %kctl, %struct.snd_ctl_elem_id* %id) #3 {
entry:
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %0 = load i32, i32* %numid, align 4, !tbaa !123
  %id1 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %numid2 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id1, i32 0, i32 0
  %1 = load i32, i32* %numid2, align 8, !tbaa !134
  %sub = sub i32 %0, %1
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @snd_ctl_get_ioffidx(%struct.snd_kcontrol* %kctl, %struct.snd_ctl_elem_id* %id) #3 {
entry:
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %0 = load i32, i32* %index, align 4, !tbaa !132
  %id1 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %index2 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id1, i32 0, i32 5
  %1 = load i32, i32* %index2, align 4, !tbaa !131
  %sub = sub i32 %0, %1
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_remove_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %controls_rwsem1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call i32 @snd_ctl_remove(%struct.snd_card* %card, %struct.snd_kcontrol* %call)
  %controls_rwsem3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem3)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ -2, %if.then ], [ %call2, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_remove(%struct.snd_card* %card, %struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne %struct.snd_kcontrol* %kcontrol, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 454)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %1 = load i32, i32* %count, align 8, !tbaa !133
  %controls_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  %2 = load i32, i32* %controls_count, align 8, !tbaa !145
  %sub = sub i32 %2, %1
  store i32 %sub, i32* %controls_count, align 8, !tbaa !145
  %id20 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %3 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %4 = bitcast %struct.snd_ctl_elem_id* %id20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 64, i32 4, i1 false), !tbaa.struct !135
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end19
  %idx.0 = phi i32 [ 0, %if.end19 ], [ %inc, %for.body ]
  %count21 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %5 = load i32, i32* %count21, align 8, !tbaa !133
  %cmp = icmp ult i32 %idx.0, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 -1, %struct.snd_ctl_elem_id* %id)
  %inc = add i32 %idx.0, 1
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %6 = load i32, i32* %index, align 4, !tbaa !132
  %inc23 = add i32 %6, 1
  store i32 %inc23, i32* %index, align 4, !tbaa !132
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %7 = load i32, i32* %numid, align 4, !tbaa !123
  %inc24 = add i32 %7, 1
  store i32 %inc24, i32* %numid, align 4, !tbaa !123
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @snd_ctl_free_one(%struct.snd_kcontrol* %kcontrol)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end
  %retval.0 = phi i32 [ 0, %for.end ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @snd_ctl_free_one(%struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %tobool = icmp ne %struct.snd_kcontrol* %kcontrol, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 9
  %0 = load void (%struct.snd_kcontrol*)*, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !146
  %tobool1 = icmp ne void (%struct.snd_kcontrol*)* %0, null
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %private_free3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 9
  %1 = load void (%struct.snd_kcontrol*)*, void (%struct.snd_kcontrol*)** %private_free3, align 8, !tbaa !146
  call void %1(%struct.snd_kcontrol* %kcontrol)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %2 = bitcast %struct.snd_kcontrol* %kcontrol to i8*
  call void @kfree(i8* %2)
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_replace(%struct.snd_card* %card, %struct.snd_kcontrol* %kcontrol, i1 zeroext %add_on_replace) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %frombool = zext i1 %add_on_replace to i8
  %tobool = icmp ne %struct.snd_kcontrol* %kcontrol, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %tobool1 = icmp ne %struct.snd_card* %card, null
  br i1 %tobool1, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end
  %info = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 3
  %0 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !147
  %tobool2 = icmp ne i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* %0, null
  %lnot = xor i1 %tobool2, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end
  %1 = phi i1 [ true, %if.end ], [ %lnot, %lor.rhs ]
  %lnot3 = xor i1 %1, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool5 = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 398)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %lor.end
  %tobool13 = icmp ne i32 %lnot.ext, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %error, label %if.end22

if.end22:                                         ; preds = %if.end12
  %id23 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %2 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %3 = bitcast %struct.snd_ctl_elem_id* %id23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 64, i32 4, i1 false), !tbaa.struct !135
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %tobool24 = icmp ne %struct.snd_kcontrol* %call, null
  br i1 %tobool24, label %if.end30, label %if.then25

if.then25:                                        ; preds = %if.end22
  %tobool26 = trunc i8 %frombool to i1
  br i1 %tobool26, label %add, label %if.end28

if.end28:                                         ; preds = %if.then25
  %controls_rwsem29 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem29)
  br label %error

if.end30:                                         ; preds = %if.end22
  %call31 = call i32 @snd_ctl_remove(%struct.snd_card* %card, %struct.snd_kcontrol* %call)
  %cmp = icmp slt i32 %call31, 0
  br i1 %cmp, label %if.then33, label %add

if.then33:                                        ; preds = %if.end30
  %controls_rwsem34 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem34)
  br label %error

add:                                              ; preds = %if.end30, %if.then25
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %4 = load i32, i32* %count, align 8, !tbaa !133
  %call36 = call i32 @snd_ctl_find_hole(%struct.snd_card* %card, i32 %4)
  %cmp37 = icmp slt i32 %call36, 0
  br i1 %cmp37, label %if.then39, label %if.end41

if.then39:                                        ; preds = %add
  %controls_rwsem40 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem40)
  br label %error

if.end41:                                         ; preds = %add
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 0
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  call void @list_add_tail.108(%struct.list_head* %list, %struct.list_head* %controls)
  %count42 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %5 = load i32, i32* %count42, align 8, !tbaa !133
  %controls_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  %6 = load i32, i32* %controls_count, align 8, !tbaa !145
  %add43 = add i32 %6, %5
  store i32 %add43, i32* %controls_count, align 8, !tbaa !145
  %last_numid = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %7 = load i32, i32* %last_numid, align 8, !tbaa !136
  %add44 = add i32 %7, 1
  %id45 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id45, i32 0, i32 0
  store i32 %add44, i32* %numid, align 8, !tbaa !134
  %count46 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %8 = load i32, i32* %count46, align 8, !tbaa !133
  %last_numid47 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %9 = load i32, i32* %last_numid47, align 8, !tbaa !136
  %add48 = add i32 %9, %8
  store i32 %add48, i32* %last_numid47, align 8, !tbaa !136
  %controls_rwsem49 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem49)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end41
  %idx.0 = phi i32 [ 0, %if.end41 ], [ %inc, %for.body ]
  %count50 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %10 = load i32, i32* %count50, align 8, !tbaa !133
  %cmp51 = icmp ult i32 %idx.0, %10
  br i1 %cmp51, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 4, %struct.snd_ctl_elem_id* %id)
  %inc = add i32 %idx.0, 1
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %11 = load i32, i32* %index, align 4, !tbaa !132
  %inc53 = add i32 %11, 1
  store i32 %inc53, i32* %index, align 4, !tbaa !132
  %numid54 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %12 = load i32, i32* %numid54, align 4, !tbaa !123
  %inc55 = add i32 %12, 1
  store i32 %inc55, i32* %numid54, align 4, !tbaa !123
  br label %for.cond

error:                                            ; preds = %if.then39, %if.then33, %if.end28, %if.end12
  %ret.0 = phi i32 [ %call31, %if.then33 ], [ -12, %if.then39 ], [ -22, %if.end28 ], [ -22, %if.end12 ]
  call void @snd_ctl_free_one(%struct.snd_kcontrol* %kcontrol)
  br label %cleanup

cleanup:                                          ; preds = %error, %for.cond, %entry
  %retval.0 = phi i32 [ %ret.0, %error ], [ -22, %entry ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_find_hole(%struct.snd_card* %card, i32 %count) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %iter.0 = phi i32 [ 100000, %entry ], [ %dec, %if.end ]
  %call = call zeroext i1 @snd_ctl_remove_numid_conflict(%struct.snd_card* %card, i32 %count)
  br i1 %call, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %dec = add i32 %iter.0, -1
  %cmp = icmp eq i32 %dec, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.5.112, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %while.body
  br label %while.cond

cleanup:                                          ; preds = %if.then, %while.cond
  %retval.0 = phi i32 [ -12, %if.then ], [ 0, %while.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @snd_ctl_remove_numid_conflict(%struct.snd_card* %card, i32 %count) #0 {
entry:
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list17.sink = phi %struct.list_head* [ %list17, %for.inc ], [ %controls, %entry ]
  %next18 = getelementptr inbounds %struct.list_head, %struct.list_head* %list17.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next18, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr20 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr20 to %struct.snd_kcontrol*
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %2, i32 0, i32 0
  %controls1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  %cmp = icmp ne %struct.list_head* %list, %controls1
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %2, i32 0, i32 1
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %3 = load i32, i32* %numid, align 8, !tbaa !134
  %last_numid = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %4 = load i32, i32* %last_numid, align 8, !tbaa !136
  %add = add i32 %4, 1
  %add2 = add i32 %add, %count
  %cmp3 = icmp ult i32 %3, %add2
  br i1 %cmp3, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %id4 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %2, i32 0, i32 1
  %numid5 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id4, i32 0, i32 0
  %5 = load i32, i32* %numid5, align 8, !tbaa !134
  %count6 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %2, i32 0, i32 2
  %6 = load i32, i32* %count6, align 8, !tbaa !133
  %add7 = add i32 %5, %6
  %last_numid8 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %7 = load i32, i32* %last_numid8, align 8, !tbaa !136
  %add9 = add i32 %7, 1
  %cmp10 = icmp ugt i32 %add7, %add9
  br i1 %cmp10, label %if.then, label %for.inc

if.then:                                          ; preds = %land.lhs.true
  %id11 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %2, i32 0, i32 1
  %numid12 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id11, i32 0, i32 0
  %8 = load i32, i32* %numid12, align 8, !tbaa !134
  %count13 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %2, i32 0, i32 2
  %9 = load i32, i32* %count13, align 8, !tbaa !133
  %add14 = add i32 %8, %9
  %sub = sub i32 %add14, 1
  %last_numid15 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  store i32 %sub, i32* %last_numid15, align 8, !tbaa !136
  br label %cleanup

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %list17 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %2, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond
  %retval.0 = phi i1 [ true, %if.then ], [ false, %for.cond ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_add(%struct.snd_card* %card, %struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %tobool = icmp ne %struct.snd_kcontrol* %kcontrol, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %tobool1 = icmp ne %struct.snd_card* %card, null
  br i1 %tobool1, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end
  %info = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 3
  %0 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !147
  %tobool2 = icmp ne i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* %0, null
  %lnot = xor i1 %tobool2, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end
  %1 = phi i1 [ true, %if.end ], [ %lnot, %lor.rhs ]
  %lnot3 = xor i1 %1, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool5 = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 338)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %lor.end
  %tobool13 = icmp ne i32 %lnot.ext, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %error, label %if.end22

if.end22:                                         ; preds = %if.end12
  %id23 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %2 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %3 = bitcast %struct.snd_ctl_elem_id* %id23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 64, i32 4, i1 false), !tbaa.struct !135
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %tobool24 = icmp ne %struct.snd_kcontrol* %call, null
  br i1 %tobool24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end22
  %controls_rwsem26 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem26)
  %iface = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 1
  %4 = load i32, i32* %iface, align 4, !tbaa !126
  %device = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 2
  %5 = load i32, i32* %device, align 4, !tbaa !128
  %subdevice = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 3
  %6 = load i32, i32* %subdevice, align 4, !tbaa !130
  %name = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 4
  %arraydecay = getelementptr inbounds [44 x i8], [44 x i8]* %name, i32 0, i32 0
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %7 = load i32, i32* %index, align 4, !tbaa !132
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.3.113, i32 0, i32 0), i32 %4, i32 %5, i32 %6, i8* %arraydecay, i32 %7)
  br label %error

if.end27:                                         ; preds = %if.end22
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %8 = load i32, i32* %count, align 8, !tbaa !133
  %call28 = call i32 @snd_ctl_find_hole(%struct.snd_card* %card, i32 %8)
  %cmp = icmp slt i32 %call28, 0
  br i1 %cmp, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end27
  %controls_rwsem31 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem31)
  br label %error

if.end32:                                         ; preds = %if.end27
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 0
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  call void @list_add_tail.108(%struct.list_head* %list, %struct.list_head* %controls)
  %count33 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %9 = load i32, i32* %count33, align 8, !tbaa !133
  %controls_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  %10 = load i32, i32* %controls_count, align 8, !tbaa !145
  %add = add i32 %10, %9
  store i32 %add, i32* %controls_count, align 8, !tbaa !145
  %last_numid = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %11 = load i32, i32* %last_numid, align 8, !tbaa !136
  %add34 = add i32 %11, 1
  %id35 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id35, i32 0, i32 0
  store i32 %add34, i32* %numid, align 8, !tbaa !134
  %count36 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %12 = load i32, i32* %count36, align 8, !tbaa !133
  %last_numid37 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %13 = load i32, i32* %last_numid37, align 8, !tbaa !136
  %add38 = add i32 %13, %12
  store i32 %add38, i32* %last_numid37, align 8, !tbaa !136
  %controls_rwsem39 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem39)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end32
  %idx.0 = phi i32 [ 0, %if.end32 ], [ %inc, %for.body ]
  %count40 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %14 = load i32, i32* %count40, align 8, !tbaa !133
  %cmp41 = icmp ult i32 %idx.0, %14
  br i1 %cmp41, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 4, %struct.snd_ctl_elem_id* %id)
  %inc = add i32 %idx.0, 1
  %index43 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %15 = load i32, i32* %index43, align 4, !tbaa !132
  %inc44 = add i32 %15, 1
  store i32 %inc44, i32* %index43, align 4, !tbaa !132
  %numid45 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %16 = load i32, i32* %numid45, align 4, !tbaa !123
  %inc46 = add i32 %16, 1
  store i32 %inc46, i32* %numid45, align 4, !tbaa !123
  br label %for.cond

error:                                            ; preds = %if.then30, %if.then25, %if.end12
  %err.0 = phi i32 [ -16, %if.then25 ], [ -12, %if.then30 ], [ -22, %if.end12 ]
  call void @snd_ctl_free_one(%struct.snd_kcontrol* %kcontrol)
  br label %cleanup

cleanup:                                          ; preds = %error, %for.cond, %entry
  %retval.0 = phi i32 [ %err.0, %error ], [ -22, %entry ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.snd_kcontrol* @snd_ctl_new1(%struct.snd_kcontrol_new* %ncontrol, i8* %private_data) #0 {
entry:
  %kctl = alloca %struct.snd_kcontrol, align 8
  %tobool = icmp ne %struct.snd_kcontrol_new* %ncontrol, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %info = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 7
  %0 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !148
  %tobool1 = icmp ne i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* %0, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %1 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %1, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 235)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %2 = bitcast %struct.snd_kcontrol* %kctl to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 144, i32 8, i1 false)
  %iface = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 0
  %3 = load i32, i32* %iface, align 8, !tbaa !150
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %iface20 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 1
  store i32 %3, i32* %iface20, align 4, !tbaa !124
  %device = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 1
  %4 = load i32, i32* %device, align 4, !tbaa !151
  %id21 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %device22 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id21, i32 0, i32 2
  store i32 %4, i32* %device22, align 8, !tbaa !127
  %subdevice = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 2
  %5 = load i32, i32* %subdevice, align 8, !tbaa !152
  %id23 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %subdevice24 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id23, i32 0, i32 3
  store i32 %5, i32* %subdevice24, align 4, !tbaa !129
  %name = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 3
  %6 = load i8*, i8** %name, align 8, !tbaa !153
  %tobool25 = icmp ne i8* %6, null
  br i1 %tobool25, label %if.then26, label %if.end42

if.then26:                                        ; preds = %if.end19
  %id27 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %name28 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id27, i32 0, i32 4
  %arraydecay = getelementptr inbounds [44 x i8], [44 x i8]* %name28, i32 0, i32 0
  %name29 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 3
  %7 = load i8*, i8** %name29, align 8, !tbaa !153
  %call = call i64 @strlcpy(i8* %arraydecay, i8* %7, i64 44)
  %name30 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 3
  %8 = load i8*, i8** %name30, align 8, !tbaa !153
  %id31 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %name32 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id31, i32 0, i32 4
  %arraydecay33 = getelementptr inbounds [44 x i8], [44 x i8]* %name32, i32 0, i32 0
  %call34 = call i32 @strcmp(i8* %8, i8* %arraydecay33)
  %cmp = icmp ne i32 %call34, 0
  br i1 %cmp, label %if.then36, label %if.end42

if.then36:                                        ; preds = %if.then26
  %name37 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 3
  %9 = load i8*, i8** %name37, align 8, !tbaa !153
  %id38 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %name39 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id38, i32 0, i32 4
  %arraydecay40 = getelementptr inbounds [44 x i8], [44 x i8]* %name39, i32 0, i32 0
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.2.114, i32 0, i32 0), i8* %9, i8* %arraydecay40)
  br label %if.end42

if.end42:                                         ; preds = %if.then36, %if.then26, %if.end19
  %index = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 4
  %10 = load i32, i32* %index, align 8, !tbaa !154
  %id43 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %index44 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id43, i32 0, i32 5
  store i32 %10, i32* %index44, align 4, !tbaa !131
  %count = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 6
  %11 = load i32, i32* %count, align 8, !tbaa !155
  %tobool45 = icmp ne i32 %11, 0
  br i1 %tobool45, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end42
  %count46 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 6
  %12 = load i32, i32* %count46, align 8, !tbaa !155
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end42
  %cond = phi i32 [ %12, %cond.true ], [ 1, %if.end42 ]
  %count47 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 2
  store i32 %cond, i32* %count47, align 8, !tbaa !133
  %access48 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 5
  %13 = load i32, i32* %access48, align 4, !tbaa !156
  %cmp49 = icmp eq i32 %13, 0
  br i1 %cmp49, label %cond.end54, label %cond.false52

cond.false52:                                     ; preds = %cond.end
  %access53 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 5
  %14 = load i32, i32* %access53, align 4, !tbaa !156
  %and = and i32 %14, 268435831
  br label %cond.end54

cond.end54:                                       ; preds = %cond.false52, %cond.end
  %cond55 = phi i32 [ %and, %cond.false52 ], [ 3, %cond.end ]
  %info56 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 7
  %15 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info56, align 8, !tbaa !148
  %info57 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 3
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* %15, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info57, align 8, !tbaa !147
  %get = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 8
  %16 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !157
  %get58 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 4
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* %16, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get58, align 8, !tbaa !158
  %put = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 9
  %17 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !159
  %put59 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 5
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* %17, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put59, align 8, !tbaa !160
  %tlv = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 10
  %p = bitcast %union.anon.58* %tlv to i32**
  %18 = load i32*, i32** %p, align 8, !tbaa !29
  %tlv60 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 6
  %p61 = bitcast %union.anon.58* %tlv60 to i32**
  store i32* %18, i32** %p61, align 8, !tbaa !29
  %private_value = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 11
  %19 = load i64, i64* %private_value, align 8, !tbaa !161
  %private_value62 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 7
  store i64 %19, i64* %private_value62, align 8, !tbaa !162
  %private_data63 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 8
  store i8* %private_data, i8** %private_data63, align 8, !tbaa !163
  %call64 = call %struct.snd_kcontrol* @snd_ctl_new(%struct.snd_kcontrol* %kctl, i32 %cond55)
  br label %cleanup

cleanup:                                          ; preds = %cond.end54, %if.end
  %retval.0 = phi %struct.snd_kcontrol* [ %call64, %cond.end54 ], [ null, %if.end ]
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #5

; Function Attrs: nounwind uwtable
define internal %struct.snd_kcontrol* @snd_ctl_new(%struct.snd_kcontrol* %control, i32 %access) #0 {
entry:
  %tobool = icmp ne %struct.snd_kcontrol* %control, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %control, i32 0, i32 2
  %0 = load i32, i32* %count, align 8, !tbaa !133
  %tobool1 = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %1 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %1, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 201)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %count20 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %control, i32 0, i32 2
  %2 = load i32, i32* %count20, align 8, !tbaa !133
  %cmp = icmp ugt i32 %2, 1028
  br i1 %cmp, label %cleanup, label %if.end23

if.end23:                                         ; preds = %if.end19
  %count24 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %control, i32 0, i32 2
  %3 = load i32, i32* %count24, align 8, !tbaa !133
  %conv25 = zext i32 %3 to i64
  %mul = mul i64 16, %conv25
  %add = add i64 144, %mul
  %call = call i8* @kzalloc.107(i64 %add, i32 208)
  %4 = bitcast i8* %call to %struct.snd_kcontrol*
  %cmp26 = icmp eq %struct.snd_kcontrol* %4, null
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end23
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.4.115, i32 0, i32 0))
  br label %cleanup

if.end29:                                         ; preds = %if.end23
  %5 = bitcast %struct.snd_kcontrol* %4 to i8*
  %6 = bitcast %struct.snd_kcontrol* %control to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 144, i32 8, i1 false), !tbaa.struct !164
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end29
  %idx.0 = phi i32 [ 0, %if.end29 ], [ %inc, %for.body ]
  %count30 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %4, i32 0, i32 2
  %7 = load i32, i32* %count30, align 8, !tbaa !133
  %cmp31 = icmp ult i32 %idx.0, %7
  br i1 %cmp31, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %4, i32 0, i32 10
  %idxprom = zext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i64 0, i64 %idxprom
  %access33 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  store i32 %access, i32* %access33, align 8, !tbaa !137
  %inc = add i32 %idx.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.then28, %if.end19, %if.end
  %retval.0 = phi %struct.snd_kcontrol* [ null, %if.then28 ], [ null, %if.end ], [ null, %if.end19 ], [ %4, %for.cond ]
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_create(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 1674)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %return, label %if.end18

if.end18:                                         ; preds = %if.end
  %0 = bitcast %struct.snd_card* %card to i8*
  %call = call i32 @snd_device_new(%struct.snd_card* %card, i32 1, i8* %0, %struct.snd_device_ops* @snd_ctl_create.ops)
  br label %return

return:                                           ; preds = %if.end18, %if.end
  %retval.0 = phi i32 [ %call, %if.end18 ], [ -6, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_dev_free(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !112
  %1 = bitcast i8* %0 to %struct.snd_card*
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 16
  %call = call i32 @list_empty(%struct.list_head* %controls)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %controls1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 16
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %controls1, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !165
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.snd_kcontrol*
  %call2 = call i32 @snd_ctl_remove(%struct.snd_card* %1, %struct.snd_kcontrol* %4)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %controls_rwsem3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem3)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_dev_register(%struct.snd_device* %device) #0 {
entry:
  %name = alloca [16 x i8], align 16
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !112
  %1 = bitcast i8* %0 to %struct.snd_card*
  %tobool = icmp ne %struct.snd_card* %1, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 1605)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 0
  %2 = load i32, i32* %number, align 8, !tbaa !9
  %cmp = icmp slt i32 %2, 0
  %cmp21 = icmp sge i32 %2, 32
  %.cmp21 = select i1 %cmp, i1 true, i1 %cmp21
  %lnot23 = xor i1 %.cmp21, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end18
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 1608)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.end18
  %tobool38 = icmp ne i32 %lnot.ext26, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %tobool45 = icmp ne i64 %expval44, 0
  br i1 %tobool45, label %cleanup, label %if.end47

if.end47:                                         ; preds = %if.end36
  %3 = call i32 (i8*, i8*, ...) @sprintf(i8* null, i8* null)
  %4 = bitcast %struct.snd_card* %1 to i8*
  %arraydecay48 = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0
  %call49 = call i32 @snd_register_device(i32 0, %struct.snd_card* %1, i8* %4, i8* %arraydecay48)
  %cmp50 = icmp slt i32 %call49, 0
  %call49. = select i1 %cmp50, i32 %call49, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end47, %if.end36, %if.end
  %retval.0 = phi i32 [ -6, %if.end ], [ -6, %if.end36 ], [ %call49., %if.end47 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_dev_disconnect(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !112
  %1 = bitcast i8* %0 to %struct.snd_card*
  %tobool = icmp ne %struct.snd_card* %1, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 1626)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 0
  %2 = load i32, i32* %number, align 8, !tbaa !9
  %cmp = icmp slt i32 %2, 0
  %cmp21 = icmp sge i32 %2, 32
  %.cmp21 = select i1 %cmp, i1 true, i1 %cmp21
  %lnot23 = xor i1 %.cmp21, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end18
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 1629)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.end18
  %tobool38 = icmp ne i32 %lnot.ext26, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %tobool45 = icmp ne i64 %expval44, 0
  br i1 %tobool45, label %cleanup, label %if.end47

if.end47:                                         ; preds = %if.end36
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 13
  call void @_raw_read_lock(%struct.rwlock_t* %ctl_files_rwlock)
  %ctl_files = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 17
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end47
  %list53.sink = phi %struct.list_head* [ %list53, %for.body ], [ %ctl_files, %if.end47 ]
  %next54 = getelementptr inbounds %struct.list_head, %struct.list_head* %list53.sink, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next54, align 8, !tbaa !2
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr56 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr56 to %struct.snd_ctl_file*
  %list = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 0
  %ctl_files49 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 17
  %cmp50 = icmp ne %struct.list_head* %list, %ctl_files49
  br i1 %cmp50, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %change_sleep = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 5
  call void @__wake_up(%struct.__wait_queue_head* %change_sleep, i32 3, i32 1, i8* null)
  %fasync = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 7
  call void @kill_fasync(%struct.fasync_struct** %fasync, i32 29, i32 131076)
  %list53 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %ctl_files_rwlock57 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 13
  call void @_raw_read_unlock(%struct.rwlock_t* %ctl_files_rwlock57)
  %call = call i32 @snd_unregister_device(i32 0, %struct.snd_card* %1, i32 -1)
  %cmp58 = icmp slt i32 %call, 0
  %call. = select i1 %cmp58, i32 %call, i32 0
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end36, %if.end
  %retval.0 = phi i32 [ -6, %if.end ], [ -6, %if.end36 ], [ %call., %for.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @snd_register_device(i32 %type, %struct.snd_card* %card, i8* %private_data, i8* %name) #3 {
entry:
  %call = call %struct.device* @snd_card_get_device_link(%struct.snd_card* %card)
  %call1 = call i32 @snd_register_device_for_dev(i32 %type, %struct.snd_card* undef, i32 undef, %struct.file_operations* undef, i8* %private_data, i8* %name, %struct.device* %call)
  ret i32 %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.device* @snd_card_get_device_link(%struct.snd_card* %card) #3 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %0 = load %struct.device*, %struct.device** %card_dev, align 8, !tbaa !69
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi %struct.device* [ %0, %cond.true ], [ null, %entry ]
  ret %struct.device* %cond
}

declare i64 @no_llseek(%struct.file*, i64, i32) #1

; Function Attrs: nounwind uwtable
define internal i64 @snd_ctl_read(%struct.file* %file, i8* %buffer, i64 %count, i64* %offset) #0 {
entry:
  %ev = alloca %struct.snd_ctl_event, align 4
  %wait = alloca %struct.__wait_queue, align 8
  %__ret = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_ctl_file*
  %tobool = icmp ne %struct.snd_ctl_file* %1, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %card = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %2 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !166
  %tobool1 = icmp ne %struct.snd_card* %2, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %3, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 1421)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup74, label %if.end19

if.end19:                                         ; preds = %if.end
  %subscribed = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 8
  %4 = load i32, i32* %subscribed, align 8, !tbaa !140
  %tobool20 = icmp ne i32 %4, 0
  br i1 %tobool20, label %if.end22, label %cleanup74

if.end22:                                         ; preds = %if.end19
  %cmp = icmp ult i64 %count, 72
  br i1 %cmp, label %cleanup74, label %if.end25

if.end25:                                         ; preds = %if.end22
  %read_lock = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 6
  call void @spin_lock_irq(%struct.spinlock* %read_lock)
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont68, %if.end25
  %err.0 = phi i32 [ 0, %if.end25 ], [ %err.3, %cleanup.cont68 ]
  %result.0 = phi i64 [ 0, %if.end25 ], [ %result.1, %cleanup.cont68 ]
  %count.addr.0 = phi i64 [ %count, %if.end25 ], [ %count.addr.1, %cleanup.cont68 ]
  %buffer.addr.0 = phi i8* [ %buffer, %if.end25 ], [ %buffer.addr.1, %cleanup.cont68 ]
  %retval.0 = phi i64 [ undef, %if.end25 ], [ %retval.3, %cleanup.cont68 ]
  %cmp26 = icmp uge i64 %count.addr.0, 72
  br i1 %cmp26, label %while.body, label %__end_lock

while.body:                                       ; preds = %while.cond
  br label %while.cond28

while.cond28:                                     ; preds = %cleanup.cont, %while.body
  %err.1 = phi i32 [ %err.0, %while.body ], [ %err.2, %cleanup.cont ]
  %retval.1 = phi i64 [ %retval.0, %while.body ], [ %retval.2, %cleanup.cont ]
  %events = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 9
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool29 = icmp ne i32 %call, 0
  br i1 %tobool29, label %while.body30, label %while.end

while.body30:                                     ; preds = %while.cond28
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %5 = load i32, i32* %f_flags, align 8, !tbaa !75
  %and = and i32 %5, 2048
  %cmp31 = icmp ne i32 %and, 0
  %cmp33 = icmp sgt i64 %result.0, 0
  %or.cond = or i1 %cmp31, %cmp33
  br i1 %or.cond, label %cleanup, label %if.end36

if.end36:                                         ; preds = %while.body30
  %6 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !167
  call void @init_waitqueue_entry.136(%struct.__wait_queue* %wait, %struct.task_struct* %6)
  %change_sleep = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 5
  call void @add_wait_queue(%struct.__wait_queue_head* %change_sleep, %struct.__wait_queue* %wait)
  store volatile i64 1, i64* %__ret, align 8, !tbaa !52
  %7 = load volatile i64, i64* %__ret, align 8, !tbaa !52
  %8 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !167
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %8, i32 0, i32 0
  %9 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state, i64 %7, i64* %state) #8, !srcloc !168
  store volatile i64 %9, i64* %__ret, align 8, !tbaa !52
  %10 = load volatile i64, i64* %__ret, align 8, !tbaa !52
  %read_lock40 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 6
  call void @spin_unlock_irq(%struct.spinlock* %read_lock40)
  call void @schedule()
  %change_sleep41 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 5
  call void @remove_wait_queue(%struct.__wait_queue_head* %change_sleep41, %struct.__wait_queue* %wait)
  %card42 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %11 = load %struct.snd_card*, %struct.snd_card** %card42, align 8, !tbaa !166
  %shutdown = getelementptr inbounds %struct.snd_card, %struct.snd_card* %11, i32 0, i32 24
  %12 = load i32, i32* %shutdown, align 8, !tbaa !51
  %tobool43 = icmp ne i32 %12, 0
  br i1 %tobool43, label %cleanup, label %if.end45

if.end45:                                         ; preds = %if.end36
  %13 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !167
  %call47 = call i32 @signal_pending(%struct.task_struct* %13)
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %cleanup, label %if.end50

if.end50:                                         ; preds = %if.end45
  %read_lock51 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 6
  call void @spin_lock_irq(%struct.spinlock* %read_lock51)
  br label %cleanup

cleanup:                                          ; preds = %if.end50, %if.end45, %if.end36, %while.body30
  %err.2 = phi i32 [ %err.1, %if.end50 ], [ -11, %while.body30 ], [ %err.1, %if.end36 ], [ %err.1, %if.end45 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end50 ], [ 6, %while.body30 ], [ 1, %if.end36 ], [ 1, %if.end45 ]
  %retval.2 = phi i64 [ %retval.1, %if.end50 ], [ %retval.1, %while.body30 ], [ -19, %if.end36 ], [ -512, %if.end45 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %cleanup.cont, label %cleanup65

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond28

while.end:                                        ; preds = %while.cond28
  %events52 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 9
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %events52, i32 0, i32 0
  %14 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !169
  %15 = bitcast %struct.list_head* %14 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %15, i64 0
  %16 = bitcast i8* %add.ptr to %struct.snd_kctl_event*
  %type = getelementptr inbounds %struct.snd_ctl_event, %struct.snd_ctl_event* %ev, i32 0, i32 0
  store i32 0, i32* %type, align 4, !tbaa !170
  %mask = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %16, i32 0, i32 2
  %17 = load i32, i32* %mask, align 8, !tbaa !144
  %data = getelementptr inbounds %struct.snd_ctl_event, %struct.snd_ctl_event* %ev, i32 0, i32 1
  %elem = bitcast %union.anon.60* %data to %struct.anon.61*
  %mask54 = getelementptr inbounds %struct.anon.61, %struct.anon.61* %elem, i32 0, i32 0
  store i32 %17, i32* %mask54, align 4, !tbaa !29
  %data55 = getelementptr inbounds %struct.snd_ctl_event, %struct.snd_ctl_event* %ev, i32 0, i32 1
  %elem56 = bitcast %union.anon.60* %data55 to %struct.anon.61*
  %id = getelementptr inbounds %struct.anon.61, %struct.anon.61* %elem56, i32 0, i32 1
  %id57 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %16, i32 0, i32 1
  %18 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %19 = bitcast %struct.snd_ctl_elem_id* %id57 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 64, i32 4, i1 false), !tbaa.struct !135
  %list = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %16, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  %read_lock58 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 6
  call void @spin_unlock_irq(%struct.spinlock* %read_lock58)
  %20 = bitcast %struct.snd_kctl_event* %16 to i8*
  call void @kfree(i8* %20)
  %21 = bitcast %struct.snd_ctl_event* %ev to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %buffer.addr.0, i8* %21, i32 72) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool60 = icmp ne i32 %conv.i, 0
  br i1 %tobool60, label %cleanup65, label %if.end62

if.end62:                                         ; preds = %while.end
  %read_lock63 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 6
  call void @spin_lock_irq(%struct.spinlock* %read_lock63)
  %add.ptr64 = getelementptr inbounds i8, i8* %buffer.addr.0, i64 72
  %sub = sub i64 %count.addr.0, 72
  %add = add i64 %result.0, 72
  br label %cleanup65

cleanup65:                                        ; preds = %if.end62, %while.end, %cleanup
  %err.3 = phi i32 [ %err.1, %if.end62 ], [ -14, %while.end ], [ %err.2, %cleanup ]
  %result.1 = phi i64 [ %add, %if.end62 ], [ %result.0, %while.end ], [ %result.0, %cleanup ]
  %count.addr.1 = phi i64 [ %sub, %if.end62 ], [ %count.addr.0, %while.end ], [ %count.addr.0, %cleanup ]
  %buffer.addr.1 = phi i8* [ %add.ptr64, %if.end62 ], [ %buffer.addr.0, %while.end ], [ %buffer.addr.0, %cleanup ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end62 ], [ 9, %while.end ], [ %cleanup.dest.slot.0, %cleanup ]
  %retval.3 = phi i64 [ %retval.1, %if.end62 ], [ %retval.1, %while.end ], [ %retval.2, %cleanup ]
  %Pivot9 = icmp slt i32 %cleanup.dest.slot.1, 6
  br i1 %Pivot9, label %LeafBlock2, label %NodeBlock

NodeBlock:                                        ; preds = %cleanup65
  %Pivot = icmp slt i32 %cleanup.dest.slot.1, 9
  br i1 %Pivot, label %LeafBlock4, label %LeafBlock6

LeafBlock6:                                       ; preds = %NodeBlock
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.1, 9
  br i1 %SwitchLeaf7, label %__end, label %cleanup74

LeafBlock4:                                       ; preds = %NodeBlock
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 6
  br i1 %SwitchLeaf5, label %__end_lock, label %cleanup74

LeafBlock2:                                       ; preds = %cleanup65
  %SwitchLeaf3 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf3, label %cleanup.cont68, label %cleanup74

cleanup.cont68:                                   ; preds = %LeafBlock2
  br label %while.cond

__end_lock:                                       ; preds = %LeafBlock4, %while.cond
  %err.4 = phi i32 [ %err.3, %LeafBlock4 ], [ %err.0, %while.cond ]
  %result.2 = phi i64 [ %result.1, %LeafBlock4 ], [ %result.0, %while.cond ]
  %read_lock70 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 6
  call void @spin_unlock_irq(%struct.spinlock* %read_lock70)
  br label %__end

__end:                                            ; preds = %__end_lock, %LeafBlock6
  %err.5 = phi i32 [ %err.4, %__end_lock ], [ %err.3, %LeafBlock6 ]
  %result.3 = phi i64 [ %result.2, %__end_lock ], [ %result.1, %LeafBlock6 ]
  %cmp71 = icmp sgt i64 %result.3, 0
  %conv73 = sext i32 %err.5 to i64
  %cond = select i1 %cmp71, i64 %result.3, i64 %conv73
  br label %cleanup74

cleanup74:                                        ; preds = %__end, %LeafBlock2, %LeafBlock4, %LeafBlock6, %if.end22, %if.end19, %if.end
  %retval.4 = phi i64 [ -6, %if.end ], [ -77, %if.end19 ], [ -22, %if.end22 ], [ %cond, %__end ], [ %retval.3, %LeafBlock2 ], [ %retval.3, %LeafBlock6 ], [ %retval.3, %LeafBlock4 ]
  ret i64 %retval.4
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_ctl_file*
  %subscribed = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 8
  %2 = load i32, i32* %subscribed, align 8, !tbaa !140
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %change_sleep = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 5
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* %change_sleep, %struct.poll_table_struct* %wait)
  %events = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 9
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool1 = icmp ne i32 %call, 0
  %or = or i32 0, 65
  %.or = select i1 %tobool1, i32 0, i32 %or
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %.or, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_ctl_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %0 = inttoptr i64 %arg to i8*
  %1 = bitcast i8* %0 to i32*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %2 = load i8*, i8** %private_data, align 8, !tbaa !86
  %3 = bitcast i8* %2 to %struct.snd_ctl_file*
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %3, i32 0, i32 1
  %4 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !166
  %tobool = icmp ne %struct.snd_card* %4, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 1358)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %NodeBlock51

NodeBlock51:                                      ; preds = %if.end
  %Pivot52 = icmp slt i32 %cmd, -1069525735
  br i1 %Pivot52, label %NodeBlock21, label %NodeBlock49

NodeBlock49:                                      ; preds = %NodeBlock51
  %Pivot50 = icmp slt i32 %cmd, -1055894248
  br i1 %Pivot50, label %NodeBlock33, label %NodeBlock47

NodeBlock47:                                      ; preds = %NodeBlock49
  %Pivot48 = icmp slt i32 %cmd, -993503981
  br i1 %Pivot48, label %NodeBlock37, label %NodeBlock45

NodeBlock45:                                      ; preds = %NodeBlock47
  %Pivot46 = icmp slt i32 %cmd, 1077957908
  br i1 %Pivot46, label %LeafBlock39, label %NodeBlock43

NodeBlock43:                                      ; preds = %NodeBlock45
  %Pivot44 = icmp slt i32 %cmd, 1077957909
  br i1 %Pivot44, label %sw.bb37, label %LeafBlock41

LeafBlock41:                                      ; preds = %NodeBlock43
  %SwitchLeaf42 = icmp eq i32 %cmd, 1077957909
  br i1 %SwitchLeaf42, label %sw.bb40, label %sw.epilog

LeafBlock39:                                      ; preds = %NodeBlock45
  %SwitchLeaf40 = icmp eq i32 %cmd, -993503981
  br i1 %SwitchLeaf40, label %sw.bb34, label %sw.epilog

NodeBlock37:                                      ; preds = %NodeBlock47
  %Pivot38 = icmp slt i32 %cmd, -993503982
  br i1 %Pivot38, label %LeafBlock35, label %sw.bb31

LeafBlock35:                                      ; preds = %NodeBlock37
  %SwitchLeaf36 = icmp eq i32 %cmd, -1055894248
  br i1 %SwitchLeaf36, label %sw.bb46, label %sw.epilog

NodeBlock33:                                      ; preds = %NodeBlock49
  %Pivot34 = icmp slt i32 %cmd, -1055894255
  br i1 %Pivot34, label %NodeBlock27, label %NodeBlock31

NodeBlock31:                                      ; preds = %NodeBlock33
  %Pivot32 = icmp slt i32 %cmd, -1055894249
  br i1 %Pivot32, label %LeafBlock29, label %sw.bb43

LeafBlock29:                                      ; preds = %NodeBlock31
  %SwitchLeaf30 = icmp eq i32 %cmd, -1055894255
  br i1 %SwitchLeaf30, label %sw.bb28, label %sw.epilog

NodeBlock27:                                      ; preds = %NodeBlock33
  %Pivot28 = icmp slt i32 %cmd, -1068477168
  br i1 %Pivot28, label %LeafBlock23, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %cmd, -1068477168
  br i1 %SwitchLeaf26, label %sw.bb25, label %sw.epilog

LeafBlock23:                                      ; preds = %NodeBlock27
  %SwitchLeaf24 = icmp eq i32 %cmd, -1069525735
  br i1 %SwitchLeaf24, label %sw.bb49, label %sw.epilog

NodeBlock21:                                      ; preds = %NodeBlock51
  %Pivot22 = icmp slt i32 %cmd, -1073457712
  br i1 %Pivot22, label %NodeBlock9, label %NodeBlock19

NodeBlock19:                                      ; preds = %NodeBlock21
  %Pivot20 = icmp slt i32 %cmd, -1073195749
  br i1 %Pivot20, label %NodeBlock13, label %NodeBlock17

NodeBlock17:                                      ; preds = %NodeBlock19
  %Pivot18 = icmp slt i32 %cmd, -1073195748
  br i1 %Pivot18, label %sw.bb58, label %LeafBlock15

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %cmd, -1073195748
  br i1 %SwitchLeaf16, label %sw.bb61, label %sw.epilog

NodeBlock13:                                      ; preds = %NodeBlock19
  %Pivot14 = icmp slt i32 %cmd, -1073195750
  br i1 %Pivot14, label %LeafBlock11, label %sw.bb55

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %cmd, -1073457712
  br i1 %SwitchLeaf12, label %cleanup, label %sw.epilog

NodeBlock9:                                       ; preds = %NodeBlock21
  %Pivot10 = icmp slt i32 %cmd, -2122820351
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %cmd, -1073457898
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %cmd, -1073457898
  br i1 %SwitchLeaf6, label %sw.bb52, label %sw.epilog

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %cmd, -2122820351
  br i1 %SwitchLeaf4, label %sw.bb23, label %sw.epilog

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %cmd, -2147199535
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, -2147199535
  br i1 %SwitchLeaf2, label %sw.bb65, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, -2147199744
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @might_fault()
  %5 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 131079, i32* %1) #8, !srcloc !172
  %tobool21 = icmp ne i32 %5, 0
  %cond = select i1 %tobool21, i32 -14, i32 0
  %conv22 = sext i32 %cond to i64
  br label %cleanup

sw.bb23:                                          ; preds = %LeafBlock3
  %call = call i32 @snd_ctl_card_info(%struct.snd_card* %4, i8* %0)
  %conv24 = sext i32 %call to i64
  br label %cleanup

sw.bb25:                                          ; preds = %LeafBlock25
  %6 = bitcast i8* %0 to %struct.snd_ctl_elem_list*
  %call26 = call i32 @snd_ctl_elem_list(%struct.snd_card* %4, %struct.snd_ctl_elem_list* %6)
  %conv27 = sext i32 %call26 to i64
  br label %cleanup

sw.bb28:                                          ; preds = %LeafBlock29
  %7 = bitcast i8* %0 to %struct.snd_ctl_elem_info*
  %call29 = call i32 @snd_ctl_elem_info_user(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_info* %7)
  %conv30 = sext i32 %call29 to i64
  br label %cleanup

sw.bb31:                                          ; preds = %NodeBlock37
  %8 = bitcast i8* %0 to %struct.snd_ctl_elem_value*
  %call32 = call i32 @snd_ctl_elem_read_user(%struct.snd_card* %4, %struct.snd_ctl_elem_value* %8)
  %conv33 = sext i32 %call32 to i64
  br label %cleanup

sw.bb34:                                          ; preds = %LeafBlock39
  %9 = bitcast i8* %0 to %struct.snd_ctl_elem_value*
  %call35 = call i32 @snd_ctl_elem_write_user(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_value* %9)
  %conv36 = sext i32 %call35 to i64
  br label %cleanup

sw.bb37:                                          ; preds = %NodeBlock43
  %10 = bitcast i8* %0 to %struct.snd_ctl_elem_id*
  %call38 = call i32 @snd_ctl_elem_lock(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_id* %10)
  %conv39 = sext i32 %call38 to i64
  br label %cleanup

sw.bb40:                                          ; preds = %LeafBlock41
  %11 = bitcast i8* %0 to %struct.snd_ctl_elem_id*
  %call41 = call i32 @snd_ctl_elem_unlock(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_id* %11)
  %conv42 = sext i32 %call41 to i64
  br label %cleanup

sw.bb43:                                          ; preds = %NodeBlock31
  %12 = bitcast i8* %0 to %struct.snd_ctl_elem_info*
  %call44 = call i32 @snd_ctl_elem_add_user(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_info* %12, i32 0)
  %conv45 = sext i32 %call44 to i64
  br label %cleanup

sw.bb46:                                          ; preds = %LeafBlock35
  %13 = bitcast i8* %0 to %struct.snd_ctl_elem_info*
  %call47 = call i32 @snd_ctl_elem_add_user(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_info* %13, i32 1)
  %conv48 = sext i32 %call47 to i64
  br label %cleanup

sw.bb49:                                          ; preds = %LeafBlock23
  %14 = bitcast i8* %0 to %struct.snd_ctl_elem_id*
  %call50 = call i32 @snd_ctl_elem_remove(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_id* %14)
  %conv51 = sext i32 %call50 to i64
  br label %cleanup

sw.bb52:                                          ; preds = %LeafBlock5
  %call53 = call i32 @snd_ctl_subscribe_events(%struct.snd_ctl_file* %3, i32* %1)
  %conv54 = sext i32 %call53 to i64
  br label %cleanup

sw.bb55:                                          ; preds = %NodeBlock13
  %15 = bitcast i8* %0 to %struct.snd_ctl_tlv*
  %call56 = call i32 @snd_ctl_tlv_ioctl(%struct.snd_ctl_file* %3, %struct.snd_ctl_tlv* %15, i32 0)
  %conv57 = sext i32 %call56 to i64
  br label %cleanup

sw.bb58:                                          ; preds = %NodeBlock17
  %16 = bitcast i8* %0 to %struct.snd_ctl_tlv*
  %call59 = call i32 @snd_ctl_tlv_ioctl(%struct.snd_ctl_file* %3, %struct.snd_ctl_tlv* %16, i32 1)
  %conv60 = sext i32 %call59 to i64
  br label %cleanup

sw.bb61:                                          ; preds = %LeafBlock15
  %17 = bitcast i8* %0 to %struct.snd_ctl_tlv*
  %call62 = call i32 @snd_ctl_tlv_ioctl(%struct.snd_ctl_file* %3, %struct.snd_ctl_tlv* %17, i32 -1)
  %conv63 = sext i32 %call62 to i64
  br label %cleanup

sw.bb65:                                          ; preds = %LeafBlock1
  call void @might_fault()
  %power_state = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 30
  %18 = load i32, i32* %power_state, align 8, !tbaa !54
  %19 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %18, i32* %1) #8, !srcloc !173
  %tobool69 = icmp ne i32 %19, 0
  %cond70 = select i1 %tobool69, i32 -14, i32 0
  %conv71 = sext i32 %cond70 to i64
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock11, %LeafBlock15, %LeafBlock23, %LeafBlock25, %LeafBlock29, %LeafBlock35, %LeafBlock39, %LeafBlock41
  call void @down_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @snd_control_ioctls, i32 0, i32 0), %sw.epilog ]
  %20 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !2
  %21 = bitcast %struct.list_head* %20 to i8*
  %add.ptr83 = getelementptr inbounds i8, i8* %21, i64 0
  %22 = bitcast i8* %add.ptr83 to %struct.snd_kctl_ioctl*
  %list = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %22, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @snd_control_ioctls
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %fioctl = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %22, i32 0, i32 1
  %23 = load i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)** %fioctl, align 8, !tbaa !121
  %call74 = call i32 %23(%struct.snd_card* %4, %struct.snd_ctl_file* %3, i32 %cmd, i64 %arg)
  %cmp75 = icmp ne i32 %call74, -515
  br i1 %cmp75, label %if.then77, label %for.inc

if.then77:                                        ; preds = %for.body
  call void @up_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %conv78 = sext i32 %call74 to i64
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %list81 = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %22, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list81, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @up_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 2, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.10.135, i32 0, i32 0), i32 %cmd)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then77, %sw.bb65, %sw.bb61, %sw.bb58, %sw.bb55, %sw.bb52, %sw.bb49, %sw.bb46, %sw.bb43, %sw.bb40, %sw.bb37, %sw.bb34, %sw.bb31, %sw.bb28, %sw.bb25, %sw.bb23, %sw.bb, %LeafBlock11, %if.end
  %retval.0 = phi i64 [ %conv22, %sw.bb ], [ %conv78, %if.then77 ], [ -25, %for.end ], [ %conv71, %sw.bb65 ], [ %conv24, %sw.bb23 ], [ %conv54, %sw.bb52 ], [ %conv57, %sw.bb55 ], [ %conv60, %sw.bb58 ], [ %conv63, %sw.bb61 ], [ %conv51, %sw.bb49 ], [ %conv27, %sw.bb25 ], [ %conv30, %sw.bb28 ], [ %conv45, %sw.bb43 ], [ %conv48, %sw.bb46 ], [ %conv33, %sw.bb31 ], [ %conv36, %sw.bb34 ], [ %conv39, %sw.bb37 ], [ %conv42, %sw.bb40 ], [ -6, %if.end ], [ -92, %LeafBlock11 ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @snd_ctl_ioctl_compat(%struct.file* %file, i32 %cmd, i64 %arg) #3 {
entry:
  %conv = trunc i64 %arg to i32
  %call = call i8* @compat_ptr(i32 %conv)
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_ctl_file*
  %tobool = icmp ne %struct.snd_ctl_file* %1, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %card = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %2 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !166
  %tobool1 = icmp ne %struct.snd_card* %2, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %3, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.13.125, i32 0, i32 0), i32 406)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool11 = icmp ne i32 %lnot.ext, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %cleanup, label %NodeBlock46

NodeBlock46:                                      ; preds = %if.end
  %Pivot47 = icmp slt i32 %cmd, -1069001456
  br i1 %Pivot47, label %NodeBlock21, label %NodeBlock44

NodeBlock44:                                      ; preds = %NodeBlock46
  %Pivot45 = icmp slt i32 %cmd, -1055894248
  br i1 %Pivot45, label %NodeBlock29, label %NodeBlock42

NodeBlock42:                                      ; preds = %NodeBlock44
  %Pivot43 = icmp slt i32 %cmd, -1027320557
  br i1 %Pivot43, label %NodeBlock33, label %NodeBlock40

NodeBlock40:                                      ; preds = %NodeBlock42
  %Pivot41 = icmp slt i32 %cmd, 1077957908
  br i1 %Pivot41, label %LeafBlock35, label %LeafBlock37

LeafBlock37:                                      ; preds = %NodeBlock40
  %.off38 = add i32 %cmd, -1077957908
  %SwitchLeaf39 = icmp ule i32 %.off38, 1
  br i1 %SwitchLeaf39, label %sw.bb, label %sw.epilog

LeafBlock35:                                      ; preds = %NodeBlock40
  %SwitchLeaf36 = icmp eq i32 %cmd, -1027320557
  br i1 %SwitchLeaf36, label %sw.bb33, label %sw.epilog

NodeBlock33:                                      ; preds = %NodeBlock42
  %Pivot34 = icmp slt i32 %cmd, -1027320558
  br i1 %Pivot34, label %LeafBlock31, label %sw.bb29

LeafBlock31:                                      ; preds = %NodeBlock33
  %SwitchLeaf32 = icmp eq i32 %cmd, -1055894248
  br i1 %SwitchLeaf32, label %sw.bb39, label %sw.epilog

NodeBlock29:                                      ; preds = %NodeBlock44
  %Pivot30 = icmp slt i32 %cmd, -1055894255
  br i1 %Pivot30, label %LeafBlock23, label %NodeBlock27

NodeBlock27:                                      ; preds = %NodeBlock29
  %Pivot28 = icmp slt i32 %cmd, -1055894249
  br i1 %Pivot28, label %LeafBlock25, label %sw.bb36

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %cmd, -1055894255
  br i1 %SwitchLeaf26, label %sw.bb26, label %sw.epilog

LeafBlock23:                                      ; preds = %NodeBlock29
  %SwitchLeaf24 = icmp eq i32 %cmd, -1069001456
  br i1 %SwitchLeaf24, label %sw.bb22, label %sw.epilog

NodeBlock21:                                      ; preds = %NodeBlock46
  %Pivot22 = icmp slt i32 %cmd, -1073457898
  br i1 %Pivot22, label %NodeBlock5, label %NodeBlock19

NodeBlock19:                                      ; preds = %NodeBlock21
  %Pivot20 = icmp slt i32 %cmd, -1073195750
  br i1 %Pivot20, label %NodeBlock11, label %NodeBlock17

NodeBlock17:                                      ; preds = %NodeBlock19
  %Pivot18 = icmp slt i32 %cmd, -1069525735
  br i1 %Pivot18, label %LeafBlock13, label %LeafBlock15

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %cmd, -1069525735
  br i1 %SwitchLeaf16, label %sw.bb, label %sw.epilog

LeafBlock13:                                      ; preds = %NodeBlock17
  %.off = add i32 %cmd, 1073195750
  %SwitchLeaf14 = icmp ule i32 %.off, 2
  br i1 %SwitchLeaf14, label %sw.bb, label %sw.epilog

NodeBlock11:                                      ; preds = %NodeBlock19
  %Pivot12 = icmp slt i32 %cmd, -1073457712
  br i1 %Pivot12, label %LeafBlock7, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock11
  %SwitchLeaf10 = icmp eq i32 %cmd, -1073457712
  br i1 %SwitchLeaf10, label %sw.bb, label %sw.epilog

LeafBlock7:                                       ; preds = %NodeBlock11
  %SwitchLeaf8 = icmp eq i32 %cmd, -1073457898
  br i1 %SwitchLeaf8, label %sw.bb, label %sw.epilog

NodeBlock5:                                       ; preds = %NodeBlock21
  %Pivot6 = icmp slt i32 %cmd, -2147199535
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %cmd, -2122820351
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %cmd, -2122820351
  br i1 %SwitchLeaf4, label %sw.bb, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, -2147199535
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %cmd, -2147199744
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock13, %LeafBlock15, %LeafBlock37
  %4 = ptrtoint i8* %call to i64
  %call21 = call i64 @snd_ctl_ioctl(%struct.file* %file, i32 %cmd, i64 %4)
  br label %cleanup

sw.bb22:                                          ; preds = %LeafBlock23
  %card23 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %5 = load %struct.snd_card*, %struct.snd_card** %card23, align 8, !tbaa !166
  %6 = bitcast i8* %call to %struct.snd_ctl_elem_list32*
  %call24 = call i32 @snd_ctl_elem_list_compat(%struct.snd_card* %5, %struct.snd_ctl_elem_list32* %6)
  %conv25 = sext i32 %call24 to i64
  br label %cleanup

sw.bb26:                                          ; preds = %LeafBlock25
  %7 = bitcast i8* %call to %struct.snd_ctl_elem_info32*
  %call27 = call i32 @snd_ctl_elem_info_compat(%struct.snd_ctl_file* %1, %struct.snd_ctl_elem_info32* %7)
  %conv28 = sext i32 %call27 to i64
  br label %cleanup

sw.bb29:                                          ; preds = %NodeBlock33
  %card30 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %8 = load %struct.snd_card*, %struct.snd_card** %card30, align 8, !tbaa !166
  %9 = bitcast i8* %call to %struct.snd_ctl_elem_value32*
  %call31 = call i32 @snd_ctl_elem_read_user_compat(%struct.snd_card* %8, %struct.snd_ctl_elem_value32* %9)
  %conv32 = sext i32 %call31 to i64
  br label %cleanup

sw.bb33:                                          ; preds = %LeafBlock35
  %10 = bitcast i8* %call to %struct.snd_ctl_elem_value32*
  %call34 = call i32 @snd_ctl_elem_write_user_compat(%struct.snd_ctl_file* %1, %struct.snd_ctl_elem_value32* %10)
  %conv35 = sext i32 %call34 to i64
  br label %cleanup

sw.bb36:                                          ; preds = %NodeBlock27
  %11 = bitcast i8* %call to %struct.snd_ctl_elem_info32*
  %call37 = call i32 @snd_ctl_elem_add_compat(%struct.snd_ctl_file* %1, %struct.snd_ctl_elem_info32* %11, i32 0)
  %conv38 = sext i32 %call37 to i64
  br label %cleanup

sw.bb39:                                          ; preds = %LeafBlock31
  %12 = bitcast i8* %call to %struct.snd_ctl_elem_info32*
  %call40 = call i32 @snd_ctl_elem_add_compat(%struct.snd_ctl_file* %1, %struct.snd_ctl_elem_info32* %12, i32 1)
  %conv41 = sext i32 %call40 to i64
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock7, %LeafBlock9, %LeafBlock13, %LeafBlock15, %LeafBlock23, %LeafBlock25, %LeafBlock31, %LeafBlock35, %LeafBlock37
  call void @down_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @snd_control_compat_ioctls, i32 0, i32 0), %sw.epilog ]
  %13 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !2
  %14 = bitcast %struct.list_head* %13 to i8*
  %add.ptr58 = getelementptr inbounds i8, i8* %14, i64 0
  %15 = bitcast i8* %add.ptr58 to %struct.snd_kctl_ioctl*
  %list = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %15, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @snd_control_compat_ioctls
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %fioctl = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %15, i32 0, i32 1
  %16 = load i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)** %fioctl, align 8, !tbaa !121
  %tobool44 = icmp ne i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %16, null
  br i1 %tobool44, label %if.then45, label %for.inc

if.then45:                                        ; preds = %for.body
  %fioctl46 = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %15, i32 0, i32 1
  %17 = load i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)** %fioctl46, align 8, !tbaa !121
  %card47 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %18 = load %struct.snd_card*, %struct.snd_card** %card47, align 8, !tbaa !166
  %call48 = call i32 %17(%struct.snd_card* %18, %struct.snd_ctl_file* %1, i32 %cmd, i64 %arg)
  %cmp49 = icmp ne i32 %call48, -515
  br i1 %cmp49, label %if.then51, label %for.inc

if.then51:                                        ; preds = %if.then45
  call void @up_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %conv52 = sext i32 %call48 to i64
  br label %cleanup

for.inc:                                          ; preds = %if.then45, %for.body
  %list56 = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %15, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list56, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @up_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then51, %sw.bb39, %sw.bb36, %sw.bb33, %sw.bb29, %sw.bb26, %sw.bb22, %sw.bb, %if.end
  %retval.0 = phi i64 [ %call21, %sw.bb ], [ %conv52, %if.then51 ], [ -515, %for.end ], [ %conv25, %sw.bb22 ], [ %conv28, %sw.bb26 ], [ %conv38, %sw.bb36 ], [ %conv41, %sw.bb39 ], [ %conv32, %sw.bb29 ], [ %conv35, %sw.bb33 ], [ -6, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i32 @nonseekable_open(%struct.inode* %inode, %struct.file* %file)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @iminor.119(%struct.inode* %inode)
  %call2 = call i8* @snd_lookup_minor_data(i32 %call1, i32 0)
  %0 = bitcast i8* %call2 to %struct.snd_card*
  %tobool = icmp ne %struct.snd_card* %0, null
  br i1 %tobool, label %if.end4, label %__error1

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @snd_card_file_add(%struct.snd_card* %0, %struct.file* %file)
  %cmp6 = icmp slt i32 %call5, 0
  br i1 %cmp6, label %__error1, label %if.end8

if.end8:                                          ; preds = %if.end4
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 7
  %1 = load %struct.module*, %struct.module** %module, align 8, !tbaa !79
  %call9 = call zeroext i1 @try_module_get(%struct.module* %1)
  br i1 %call9, label %if.end11, label %__error2

if.end11:                                         ; preds = %if.end8
  %call12 = call i8* @kzalloc.107(i64 232, i32 208)
  %2 = bitcast i8* %call12 to %struct.snd_ctl_file*
  %cmp13 = icmp eq %struct.snd_ctl_file* %2, null
  br i1 %cmp13, label %__error, label %if.end15

if.end15:                                         ; preds = %if.end11
  %events = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 9
  call void @INIT_LIST_HEAD.120(%struct.list_head* %events)
  %change_sleep = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 5
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %change_sleep, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.15.121, i32 0, i32 0), %struct.lock_class_key* @snd_ctl_open.__key)
  %read_lock = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 6
  %call17 = call %struct.raw_spinlock* @spinlock_check.110(%struct.spinlock* %read_lock)
  %read_lock19 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 6
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %read_lock19, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %3 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.17.122, i32 0, i32 0), %struct.lock_class_key* @snd_ctl_open.__key.16)
  %card24 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 1
  store %struct.snd_card* %0, %struct.snd_card** %card24, align 8, !tbaa !166
  %prefer_pcm_subdevice = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 3
  store i32 -1, i32* %prefer_pcm_subdevice, align 8, !tbaa !174
  %prefer_rawmidi_subdevice = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 4
  store i32 -1, i32* %prefer_rawmidi_subdevice, align 4, !tbaa !175
  %4 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !167
  %call26 = call %struct.pid* @task_pid(%struct.task_struct* %4)
  %call27 = call %struct.pid* @get_pid(%struct.pid* %call26)
  %pid = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 2
  store %struct.pid* %call27, %struct.pid** %pid, align 8, !tbaa !176
  %5 = bitcast %struct.snd_ctl_file* %2 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %5, i8** %private_data, align 8, !tbaa !86
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 13
  %call30 = call i64 @_raw_write_lock_irqsave(%struct.rwlock_t* %ctl_files_rwlock)
  %list = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 0
  %ctl_files = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 17
  call void @list_add_tail.108(%struct.list_head* %list, %struct.list_head* %ctl_files)
  %ctl_files_rwlock39 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 13
  call void @_raw_write_unlock_irqrestore(%struct.rwlock_t* %ctl_files_rwlock39, i64 %call30)
  call void @snd_card_unref(%struct.snd_card* %0)
  br label %cleanup

__error:                                          ; preds = %if.end11
  %module42 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 7
  %6 = load %struct.module*, %struct.module** %module42, align 8, !tbaa !79
  call void @module_put(%struct.module* %6)
  br label %__error2

__error2:                                         ; preds = %__error, %if.end8
  %err.0 = phi i32 [ -12, %__error ], [ -14, %if.end8 ]
  %call43 = call i32 @snd_card_file_remove(%struct.snd_card* %0, %struct.file* %file)
  br label %__error1

__error1:                                         ; preds = %__error2, %if.end4, %if.end
  %err.1 = phi i32 [ %err.0, %__error2 ], [ -19, %if.end ], [ -19, %if.end4 ]
  %tobool44 = icmp ne %struct.snd_card* %0, null
  br i1 %tobool44, label %if.then45, label %cleanup

if.then45:                                        ; preds = %__error1
  call void @snd_card_unref(%struct.snd_card* %0)
  br label %cleanup

cleanup:                                          ; preds = %if.then45, %__error1, %if.end15, %entry
  %retval.0 = phi i32 [ 0, %if.end15 ], [ %call, %entry ], [ %err.1, %if.then45 ], [ %err.1, %__error1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_ctl_file*
  %private_data1 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* null, i8** %private_data1, align 8, !tbaa !86
  %card2 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %2 = load %struct.snd_card*, %struct.snd_card** %card2, align 8, !tbaa !166
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 13
  %call = call i64 @_raw_write_lock_irqsave(%struct.rwlock_t* %ctl_files_rwlock)
  %list = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  %ctl_files_rwlock9 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 13
  call void @_raw_write_unlock_irqrestore(%struct.rwlock_t* %ctl_files_rwlock9, i64 %call)
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 16
  br label %for.cond

for.cond:                                         ; preds = %for.inc27, %entry
  %list29.sink = phi %struct.list_head* [ %list29, %for.inc27 ], [ %controls, %entry ]
  %next30 = getelementptr inbounds %struct.list_head, %struct.list_head* %list29.sink, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next30, align 8, !tbaa !2
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr32 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr32 to %struct.snd_kcontrol*
  %list13 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 0
  %controls14 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 16
  %cmp15 = icmp ne %struct.list_head* %list13, %controls14
  br i1 %cmp15, label %for.body, label %for.end33

for.body:                                         ; preds = %for.cond
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc, %for.body
  %idx.0 = phi i32 [ 0, %for.body ], [ %inc, %for.inc ]
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 2
  %6 = load i32, i32* %count, align 8, !tbaa !133
  %cmp18 = icmp ult i32 %idx.0, %6
  br i1 %cmp18, label %for.body20, label %for.inc27

for.body20:                                       ; preds = %for.cond17
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 10
  %idxprom = zext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i64 0, i64 %idxprom
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %7 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !177
  %cmp21 = icmp eq %struct.snd_ctl_file* %7, %1
  br i1 %cmp21, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body20
  %vd23 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 10
  %idxprom24 = zext i32 %idx.0 to i64
  %arrayidx25 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd23, i64 0, i64 %idxprom24
  %owner26 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx25, i32 0, i32 0
  store %struct.snd_ctl_file* null, %struct.snd_ctl_file** %owner26, align 8, !tbaa !177
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body20
  %inc = add i32 %idx.0, 1
  br label %for.cond17

for.inc27:                                        ; preds = %for.cond17
  %list29 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 0
  br label %for.cond

for.end33:                                        ; preds = %for.cond
  %controls_rwsem34 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem34)
  call void @snd_ctl_empty_read_queue(%struct.snd_ctl_file* %1)
  %pid = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 2
  %8 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !176
  call void @put_pid(%struct.pid* %8)
  %9 = bitcast %struct.snd_ctl_file* %1 to i8*
  call void @kfree(i8* %9)
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 7
  %10 = load %struct.module*, %struct.module** %module, align 8, !tbaa !79
  call void @module_put(%struct.module* %10)
  %call35 = call i32 @snd_card_file_remove(%struct.snd_card* %2, %struct.file* %file)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_fasync(i32 %fd, %struct.file* %file, i32 %on) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !86
  %1 = bitcast i8* %0 to %struct.snd_ctl_file*
  %fasync = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 7
  %call = call i32 @fasync_helper(i32 %fd, %struct.file* %file, i32 %on, %struct.fasync_struct** %fasync)
  ret i32 %call
}

declare i32 @fasync_helper(i32, %struct.file*, i32, %struct.fasync_struct**) #1

declare i64 @_raw_write_lock_irqsave(%struct.rwlock_t*) #1 section ".spinlock.text"

declare void @_raw_write_unlock_irqrestore(%struct.rwlock_t*, i64) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @snd_ctl_empty_read_queue(%struct.snd_ctl_file* %ctl) #0 {
entry:
  %read_lock = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 6
  %call = call %struct.raw_spinlock* @spinlock_check.110(%struct.spinlock* %read_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %events = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 9
  %call5 = call i32 @list_empty(%struct.list_head* %events)
  %tobool = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %events6 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 9
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %events6, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !169
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.snd_kctl_event*
  %list = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %2, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  %3 = bitcast %struct.snd_kctl_event* %2 to i8*
  call void @kfree(i8* %3)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %read_lock8 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 6
  call void @spin_unlock_irqrestore(%struct.spinlock* %read_lock8, i64 %call2)
  ret void
}

declare void @put_pid(%struct.pid*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !66
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i32 @nonseekable_open(%struct.inode*, %struct.file*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @iminor.119(%struct.inode* %inode) #3 {
entry:
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %0 = load i32, i32* %i_rdev, align 4, !tbaa !41
  %and = and i32 %0, 1048575
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.120(%struct.list_head* %list) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !66
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !67
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.pid* @task_pid(%struct.task_struct* %task) #3 {
entry:
  %pids = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i32 0, i32 45
  %arrayidx = getelementptr inbounds [3 x %struct.pid_link], [3 x %struct.pid_link]* %pids, i64 0, i64 0
  %pid = getelementptr inbounds %struct.pid_link, %struct.pid_link* %arrayidx, i32 0, i32 1
  %0 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !178
  ret %struct.pid* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.pid* @get_pid(%struct.pid* %pid) #3 {
entry:
  %tobool = icmp ne %struct.pid* %pid, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count = getelementptr inbounds %struct.pid, %struct.pid* %pid, i32 0, i32 0
  call void @atomic_inc.124(%union.anon.1* %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.pid* %pid
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.124(%union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !180
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @compat_ptr(i32 %uptr) #3 {
entry:
  %conv = zext i32 %uptr to i64
  %0 = inttoptr i64 %conv to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_list_compat(%struct.snd_card* %card, %struct.snd_ctl_elem_list32* %data32) #0 {
entry:
  %call = call i8* @compat_alloc_user_space(i64 80)
  %0 = bitcast i8* %call to %struct.snd_ctl_elem_list*
  %1 = bitcast %struct.snd_ctl_elem_list* %0 to i8*
  %2 = bitcast %struct.snd_ctl_elem_list32* %data32 to i8*
  %call1 = call i64 @copy_in_user(i8* %1, i8* %2, i32 16)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @might_fault()
  %pids = getelementptr inbounds %struct.snd_ctl_elem_list32, %struct.snd_ctl_elem_list32* %data32, i32 0, i32 4
  %3 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %pids, i64 4) #8, !srcloc !181
  %asmresult = extractvalue { i32*, i64 } %3, 0
  %asmresult2 = extractvalue { i32*, i64 } %3, 1
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  %conv = trunc i64 %asmresult2 to i32
  %tobool3 = icmp ne i32 %5, 0
  br i1 %tobool3, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  call void @might_fault()
  %call4 = call i8* @compat_ptr(i32 %conv)
  %6 = bitcast i8* %call4 to %struct.snd_ctl_elem_id*
  %pids5 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %0, i32 0, i32 4
  %7 = call %struct.snd_ctl_elem_id* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(%struct.snd_ctl_elem_id* %6, %struct.snd_ctl_elem_id** %pids5) #8, !srcloc !182
  %8 = ptrtoint %struct.snd_ctl_elem_id* %7 to i64
  %9 = trunc i64 %8 to i32
  %tobool7 = icmp ne i32 %9, 0
  br i1 %tobool7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %lor.lhs.false
  %call10 = call i32 @snd_ctl_elem_list(%struct.snd_card* %card, %struct.snd_ctl_elem_list* %0)
  %cmp = icmp slt i32 %call10, 0
  br i1 %cmp, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.end9
  %10 = bitcast %struct.snd_ctl_elem_list32* %data32 to i8*
  %11 = bitcast %struct.snd_ctl_elem_list* %0 to i8*
  %call14 = call i64 @copy_in_user(i8* %10, i8* %11, i32 16)
  %tobool15 = icmp ne i64 %call14, 0
  %. = select i1 %tobool15, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %if.end9, %lor.lhs.false, %if.end, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ -14, %lor.lhs.false ], [ -14, %if.end ], [ %call10, %if.end9 ], [ %., %if.end13 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_info_compat(%struct.snd_ctl_file* %ctl, %struct.snd_ctl_elem_info32* %data32) #0 {
entry:
  %call = call i8* @kzalloc.107(i64 272, i32 208)
  %0 = bitcast i8* %call to %struct.snd_ctl_elem_info*
  %tobool = icmp ne %struct.snd_ctl_elem_info* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 0
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 0
  %2 = bitcast %struct.snd_ctl_elem_id* %id1 to i8*
  %call2 = call i64 @copy_from_user.126(i8* %1, i8* %2, i64 64)
  %tobool3 = icmp ne i64 %call2, 0
  br i1 %tobool3, label %error, label %if.end5

if.end5:                                          ; preds = %if.end
  call void @might_fault()
  %value = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %enumerated = bitcast %union.anon.48* %value to %struct.anon.51*
  %item = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated, i32 0, i32 1
  %3 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %item, i64 4) #8, !srcloc !183
  %asmresult = extractvalue { i32*, i64 } %3, 0
  %asmresult6 = extractvalue { i32*, i64 } %3, 1
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  %conv = trunc i64 %asmresult6 to i32
  %value7 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %enumerated8 = bitcast %union.anon.48* %value7 to %struct.anon.51*
  %item9 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated8, i32 0, i32 1
  store i32 %conv, i32* %item9, align 4, !tbaa !29
  %tobool10 = icmp ne i32 %5, 0
  br i1 %tobool10, label %error, label %if.end12

if.end12:                                         ; preds = %if.end5
  %card = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %6 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !166
  call void @snd_power_lock.132(%struct.snd_card* %6)
  %card13 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %7 = load %struct.snd_card*, %struct.snd_card** %card13, align 8, !tbaa !166
  %call14 = call i32 @snd_power_wait(%struct.snd_card* %7, i32 0)
  %cmp = icmp sge i32 %call14, 0
  br i1 %cmp, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end12
  %call17 = call i32 @snd_ctl_elem_info(%struct.snd_ctl_file* %ctl, %struct.snd_ctl_elem_info* %0)
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end12
  %err.0 = phi i32 [ %call17, %if.then16 ], [ %call14, %if.end12 ]
  %card19 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %8 = load %struct.snd_card*, %struct.snd_card** %card19, align 8, !tbaa !166
  call void @snd_power_unlock.133(%struct.snd_card* %8)
  %cmp20 = icmp slt i32 %err.0, 0
  br i1 %cmp20, label %error, label %if.end23

if.end23:                                         ; preds = %if.end18
  %id24 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 0
  %9 = bitcast %struct.snd_ctl_elem_id* %id24 to i8*
  %id25 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 0
  %10 = bitcast %struct.snd_ctl_elem_id* %id25 to i8*
  call void @might_fault() #8
  %call.i5 = call i64 @_copy_to_user(i8* %9, i8* %10, i32 64) #8
  %conv.i6 = trunc i64 %call.i5 to i32
  %tobool27 = icmp ne i32 %conv.i6, 0
  br i1 %tobool27, label %error, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end23
  %type = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 1
  %11 = bitcast i32* %type to i8*
  %type28 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  %12 = bitcast i32* %type28 to i8*
  call void @might_fault() #8
  %call.i3 = call i64 @_copy_to_user(i8* %11, i8* %12, i32 12) #8
  %conv.i4 = trunc i64 %call.i3 to i32
  %tobool30 = icmp ne i32 %conv.i4, 0
  br i1 %tobool30, label %error, label %if.end32

if.end32:                                         ; preds = %lor.lhs.false
  call void @might_fault()
  %owner = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 4
  %13 = load i32, i32* %owner, align 4, !tbaa !184
  %owner33 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 4
  %14 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %13, i32* %owner33) #8, !srcloc !185
  %tobool35 = icmp ne i32 %14, 0
  br i1 %tobool35, label %error, label %if.end37

if.end37:                                         ; preds = %if.end32
  %type38 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  %15 = load i32, i32* %type38, align 8, !tbaa !117
  %Pivot6 = icmp slt i32 %15, 3
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end37
  %Pivot = icmp slt i32 %15, 6
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %15, 6
  br i1 %SwitchLeaf4, label %sw.bb72, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %15, 3
  br i1 %SwitchLeaf2, label %sw.bb80, label %sw.epilog

LeafBlock:                                        ; preds = %if.end37
  %.off = add i32 %15, -1
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @might_fault()
  %value41 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer = bitcast %union.anon.48* %value41 to %struct.task_cputime*
  %min = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer, i32 0, i32 0
  %16 = load i64, i64* %min, align 8, !tbaa !29
  %conv42 = trunc i64 %16 to i32
  %value43 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer44 = bitcast %union.anon.48* %value43 to %struct.anon.67*
  %min45 = getelementptr inbounds %struct.anon.67, %struct.anon.67* %integer44, i32 0, i32 0
  %17 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv42, i32* %min45) #8, !srcloc !186
  %tobool47 = icmp ne i32 %17, 0
  br i1 %tobool47, label %error, label %lor.lhs.false48

lor.lhs.false48:                                  ; preds = %sw.bb
  call void @might_fault()
  %value51 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer52 = bitcast %union.anon.48* %value51 to %struct.task_cputime*
  %max = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer52, i32 0, i32 1
  %18 = load i64, i64* %max, align 8, !tbaa !29
  %conv53 = trunc i64 %18 to i32
  %value54 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer55 = bitcast %union.anon.48* %value54 to %struct.anon.67*
  %max56 = getelementptr inbounds %struct.anon.67, %struct.anon.67* %integer55, i32 0, i32 1
  %19 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv53, i32* %max56) #8, !srcloc !187
  %tobool58 = icmp ne i32 %19, 0
  br i1 %tobool58, label %error, label %lor.lhs.false59

lor.lhs.false59:                                  ; preds = %lor.lhs.false48
  call void @might_fault()
  %value62 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer63 = bitcast %union.anon.48* %value62 to %struct.task_cputime*
  %step = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer63, i32 0, i32 2
  %20 = load i64, i64* %step, align 8, !tbaa !29
  %conv64 = trunc i64 %20 to i32
  %value65 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer66 = bitcast %union.anon.48* %value65 to %struct.anon.67*
  %step67 = getelementptr inbounds %struct.anon.67, %struct.anon.67* %integer66, i32 0, i32 2
  %21 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv64, i32* %step67) #8, !srcloc !188
  %tobool69 = icmp ne i32 %21, 0
  br i1 %tobool69, label %error, label %sw.epilog

sw.bb72:                                          ; preds = %LeafBlock3
  %value73 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer64 = bitcast %union.anon.48* %value73 to %struct.task_cputime*
  %22 = bitcast %struct.task_cputime* %integer64 to i8*
  %value74 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer6475 = bitcast %union.anon.48* %value74 to %struct.task_cputime*
  %23 = bitcast %struct.task_cputime* %integer6475 to i8*
  call void @might_fault() #8
  %call.i1 = call i64 @_copy_to_user(i8* %22, i8* %23, i32 24) #8
  %conv.i2 = trunc i64 %call.i1 to i32
  %tobool77 = icmp ne i32 %conv.i2, 0
  br i1 %tobool77, label %error, label %sw.epilog

sw.bb80:                                          ; preds = %LeafBlock1
  %value81 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %enumerated82 = bitcast %union.anon.48* %value81 to %struct.anon.51*
  %24 = bitcast %struct.anon.51* %enumerated82 to i8*
  %value83 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %enumerated84 = bitcast %union.anon.48* %value83 to %struct.anon.51*
  %25 = bitcast %struct.anon.51* %enumerated84 to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %24, i8* %25, i32 88) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool86 = icmp ne i32 %conv.i, 0
  br i1 %tobool86, label %error, label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb80, %sw.bb72, %lor.lhs.false59, %LeafBlock, %LeafBlock1, %LeafBlock3
  br label %error

error:                                            ; preds = %sw.epilog, %sw.bb80, %sw.bb72, %lor.lhs.false59, %lor.lhs.false48, %sw.bb, %if.end32, %lor.lhs.false, %if.end23, %if.end18, %if.end5, %if.end
  %err.1 = phi i32 [ 0, %sw.epilog ], [ -14, %if.end ], [ -14, %if.end5 ], [ %err.0, %if.end18 ], [ -14, %lor.lhs.false ], [ -14, %if.end23 ], [ -14, %if.end32 ], [ -14, %lor.lhs.false59 ], [ -14, %lor.lhs.false48 ], [ -14, %sw.bb ], [ -14, %sw.bb72 ], [ -14, %sw.bb80 ]
  %26 = bitcast %struct.snd_ctl_elem_info* %0 to i8*
  call void @kfree(i8* %26)
  br label %cleanup

cleanup:                                          ; preds = %error, %entry
  %retval.0 = phi i32 [ %err.1, %error ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_read_user_compat(%struct.snd_card* %card, %struct.snd_ctl_elem_value32* %data32) #0 {
entry:
  %type = alloca i32, align 4
  %count = alloca i32, align 4
  %call = call i8* @kzalloc.107(i64 1224, i32 208)
  %0 = bitcast i8* %call to %struct.snd_ctl_elem_value*
  %cmp = icmp eq %struct.snd_ctl_elem_value* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @copy_ctl_value_from_user(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %0, %struct.snd_ctl_elem_value32* %data32, i32* %type, i32* %count)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %error, label %if.end4

if.end4:                                          ; preds = %if.end
  call void @snd_power_lock.132(%struct.snd_card* %card)
  %call5 = call i32 @snd_power_wait(%struct.snd_card* %card, i32 0)
  %cmp6 = icmp sge i32 %call5, 0
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end4
  %call8 = call i32 @snd_ctl_elem_read(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %0)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end4
  %err.0 = phi i32 [ %call8, %if.then7 ], [ %call5, %if.end4 ]
  call void @snd_power_unlock.133(%struct.snd_card* %card)
  %cmp10 = icmp sge i32 %err.0, 0
  br i1 %cmp10, label %if.then11, label %error

if.then11:                                        ; preds = %if.end9
  %1 = load i32, i32* %type, align 4, !tbaa !25
  %2 = load i32, i32* %count, align 4, !tbaa !25
  %call12 = call i32 @copy_ctl_value_to_user(%struct.snd_ctl_elem_value32* %data32, %struct.snd_ctl_elem_value* %0, i32 %1, i32 %2)
  br label %error

error:                                            ; preds = %if.then11, %if.end9, %if.end
  %err.2 = phi i32 [ %call1, %if.end ], [ %call12, %if.then11 ], [ %err.0, %if.end9 ]
  %3 = bitcast %struct.snd_ctl_elem_value* %0 to i8*
  call void @kfree(i8* %3)
  br label %cleanup

cleanup:                                          ; preds = %error, %entry
  %retval.0 = phi i32 [ %err.2, %error ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_write_user_compat(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value32* %data32) #0 {
entry:
  %type = alloca i32, align 4
  %count = alloca i32, align 4
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !166
  %call = call i8* @kzalloc.107(i64 1224, i32 208)
  %1 = bitcast i8* %call to %struct.snd_ctl_elem_value*
  %cmp = icmp eq %struct.snd_ctl_elem_value* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i32 @copy_ctl_value_from_user(%struct.snd_card* %0, %struct.snd_ctl_elem_value* %1, %struct.snd_ctl_elem_value32* %data32, i32* %type, i32* %count)
  %cmp3 = icmp slt i32 %call2, 0
  br i1 %cmp3, label %error, label %if.end5

if.end5:                                          ; preds = %if.end
  call void @snd_power_lock.132(%struct.snd_card* %0)
  %call6 = call i32 @snd_power_wait(%struct.snd_card* %0, i32 0)
  %cmp7 = icmp sge i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end5
  %call9 = call i32 @snd_ctl_elem_write(%struct.snd_card* %0, %struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value* %1)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end5
  %err.0 = phi i32 [ %call9, %if.then8 ], [ %call6, %if.end5 ]
  call void @snd_power_unlock.133(%struct.snd_card* %0)
  %cmp11 = icmp sge i32 %err.0, 0
  br i1 %cmp11, label %if.then12, label %error

if.then12:                                        ; preds = %if.end10
  %2 = load i32, i32* %type, align 4, !tbaa !25
  %3 = load i32, i32* %count, align 4, !tbaa !25
  %call13 = call i32 @copy_ctl_value_to_user(%struct.snd_ctl_elem_value32* %data32, %struct.snd_ctl_elem_value* %1, i32 %2, i32 %3)
  br label %error

error:                                            ; preds = %if.then12, %if.end10, %if.end
  %err.2 = phi i32 [ %call2, %if.end ], [ %call13, %if.then12 ], [ %err.0, %if.end10 ]
  %4 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

cleanup:                                          ; preds = %error, %entry
  %retval.0 = phi i32 [ %err.2, %error ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_add_compat(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_info32* %data32, i32 %replace) #0 {
entry:
  %call = call i8* @kzalloc.107(i64 272, i32 208)
  %0 = bitcast i8* %call to %struct.snd_ctl_elem_info*
  %tobool = icmp ne %struct.snd_ctl_elem_info* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 0
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 0
  %2 = bitcast %struct.snd_ctl_elem_id* %id1 to i8*
  %call2 = call i64 @copy_from_user.126(i8* %1, i8* %2, i64 64)
  %tobool3 = icmp ne i64 %call2, 0
  br i1 %tobool3, label %error, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  %3 = bitcast i32* %type to i8*
  %type4 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 1
  %4 = bitcast i32* %type4 to i8*
  %call5 = call i64 @copy_from_user.126(i8* %3, i8* %4, i64 12)
  %tobool6 = icmp ne i64 %call5, 0
  br i1 %tobool6, label %error, label %if.end8

if.end8:                                          ; preds = %lor.lhs.false
  call void @might_fault()
  %owner = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 4
  %5 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %owner, i64 4) #8, !srcloc !189
  %asmresult = extractvalue { i32*, i64 } %5, 0
  %asmresult9 = extractvalue { i32*, i64 } %5, 1
  %6 = ptrtoint i32* %asmresult to i64
  %7 = trunc i64 %6 to i32
  %conv = trunc i64 %asmresult9 to i32
  %owner10 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 4
  store i32 %conv, i32* %owner10, align 4, !tbaa !184
  %tobool11 = icmp ne i32 %7, 0
  br i1 %tobool11, label %error, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %if.end8
  call void @might_fault()
  %type15 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 1
  %8 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %type15, i64 4) #8, !srcloc !190
  %asmresult16 = extractvalue { i32*, i64 } %8, 0
  %asmresult17 = extractvalue { i32*, i64 } %8, 1
  %9 = ptrtoint i32* %asmresult16 to i64
  %10 = trunc i64 %9 to i32
  %conv18 = trunc i64 %asmresult17 to i32
  %type19 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  store i32 %conv18, i32* %type19, align 8, !tbaa !117
  %tobool21 = icmp ne i32 %10, 0
  br i1 %tobool21, label %error, label %if.end23

if.end23:                                         ; preds = %lor.lhs.false12
  %type24 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  %11 = load i32, i32* %type24, align 8, !tbaa !117
  %Pivot6 = icmp slt i32 %11, 3
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end23
  %Pivot = icmp slt i32 %11, 6
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %11, 6
  br i1 %SwitchLeaf4, label %sw.bb66, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %11, 3
  br i1 %SwitchLeaf2, label %sw.bb74, label %sw.epilog

LeafBlock:                                        ; preds = %if.end23
  %.off = add i32 %11, -1
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @might_fault()
  %value = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer = bitcast %union.anon.48* %value to %struct.anon.67*
  %min = getelementptr inbounds %struct.anon.67, %struct.anon.67* %integer, i32 0, i32 0
  %12 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %min, i64 4) #8, !srcloc !191
  %asmresult27 = extractvalue { i32*, i64 } %12, 0
  %asmresult28 = extractvalue { i32*, i64 } %12, 1
  %13 = ptrtoint i32* %asmresult27 to i64
  %14 = trunc i64 %13 to i32
  %conv29 = trunc i64 %asmresult28 to i32
  %conv30 = sext i32 %conv29 to i64
  %value31 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer32 = bitcast %union.anon.48* %value31 to %struct.task_cputime*
  %min33 = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer32, i32 0, i32 0
  store i64 %conv30, i64* %min33, align 8, !tbaa !29
  %tobool35 = icmp ne i32 %14, 0
  br i1 %tobool35, label %error, label %lor.lhs.false36

lor.lhs.false36:                                  ; preds = %sw.bb
  call void @might_fault()
  %value39 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer40 = bitcast %union.anon.48* %value39 to %struct.anon.67*
  %max = getelementptr inbounds %struct.anon.67, %struct.anon.67* %integer40, i32 0, i32 1
  %15 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %max, i64 4) #8, !srcloc !192
  %asmresult41 = extractvalue { i32*, i64 } %15, 0
  %asmresult42 = extractvalue { i32*, i64 } %15, 1
  %16 = ptrtoint i32* %asmresult41 to i64
  %17 = trunc i64 %16 to i32
  %conv43 = trunc i64 %asmresult42 to i32
  %conv44 = sext i32 %conv43 to i64
  %value45 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer46 = bitcast %union.anon.48* %value45 to %struct.task_cputime*
  %max47 = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer46, i32 0, i32 1
  store i64 %conv44, i64* %max47, align 8, !tbaa !29
  %tobool49 = icmp ne i32 %17, 0
  br i1 %tobool49, label %error, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %lor.lhs.false36
  call void @might_fault()
  %value53 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer54 = bitcast %union.anon.48* %value53 to %struct.anon.67*
  %step = getelementptr inbounds %struct.anon.67, %struct.anon.67* %integer54, i32 0, i32 2
  %18 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %step, i64 4) #8, !srcloc !193
  %asmresult55 = extractvalue { i32*, i64 } %18, 0
  %asmresult56 = extractvalue { i32*, i64 } %18, 1
  %19 = ptrtoint i32* %asmresult55 to i64
  %20 = trunc i64 %19 to i32
  %conv57 = trunc i64 %asmresult56 to i32
  %conv58 = sext i32 %conv57 to i64
  %value59 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer60 = bitcast %union.anon.48* %value59 to %struct.task_cputime*
  %step61 = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer60, i32 0, i32 2
  store i64 %conv58, i64* %step61, align 8, !tbaa !29
  %tobool63 = icmp ne i32 %20, 0
  br i1 %tobool63, label %error, label %sw.epilog

sw.bb66:                                          ; preds = %LeafBlock3
  %value67 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer64 = bitcast %union.anon.48* %value67 to %struct.task_cputime*
  %21 = bitcast %struct.task_cputime* %integer64 to i8*
  %value68 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer6469 = bitcast %union.anon.48* %value68 to %struct.task_cputime*
  %22 = bitcast %struct.task_cputime* %integer6469 to i8*
  %call70 = call i64 @copy_from_user.126(i8* %21, i8* %22, i64 24)
  %tobool71 = icmp ne i64 %call70, 0
  br i1 %tobool71, label %error, label %sw.epilog

sw.bb74:                                          ; preds = %LeafBlock1
  %value75 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %enumerated = bitcast %union.anon.48* %value75 to %struct.anon.51*
  %23 = bitcast %struct.anon.51* %enumerated to i8*
  %value76 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %enumerated77 = bitcast %union.anon.48* %value76 to %struct.anon.51*
  %24 = bitcast %struct.anon.51* %enumerated77 to i8*
  %call78 = call i64 @copy_from_user.126(i8* %23, i8* %24, i64 88)
  %tobool79 = icmp ne i64 %call78, 0
  br i1 %tobool79, label %error, label %if.end81

if.end81:                                         ; preds = %sw.bb74
  %value82 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %enumerated83 = bitcast %union.anon.48* %value82 to %struct.anon.51*
  %names_ptr = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated83, i32 0, i32 3
  %25 = load i64, i64* %names_ptr, align 8, !tbaa !29
  %conv84 = trunc i64 %25 to i32
  %call85 = call i8* @compat_ptr(i32 %conv84)
  %26 = ptrtoint i8* %call85 to i64
  %value86 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %enumerated87 = bitcast %union.anon.48* %value86 to %struct.anon.51*
  %names_ptr88 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated87, i32 0, i32 3
  store i64 %26, i64* %names_ptr88, align 8, !tbaa !29
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end81, %sw.bb66, %lor.lhs.false50, %LeafBlock, %LeafBlock1, %LeafBlock3
  %call89 = call i32 @snd_ctl_elem_add(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_info* %0, i32 %replace)
  br label %error

error:                                            ; preds = %sw.epilog, %sw.bb74, %sw.bb66, %lor.lhs.false50, %lor.lhs.false36, %sw.bb, %lor.lhs.false12, %if.end8, %lor.lhs.false, %if.end
  %err.0 = phi i32 [ %call89, %sw.epilog ], [ -14, %lor.lhs.false ], [ -14, %if.end ], [ -14, %lor.lhs.false12 ], [ -14, %if.end8 ], [ -14, %lor.lhs.false50 ], [ -14, %lor.lhs.false36 ], [ -14, %sw.bb ], [ -14, %sw.bb66 ], [ -14, %sw.bb74 ]
  %27 = bitcast %struct.snd_ctl_elem_info* %0 to i8*
  call void @kfree(i8* %27)
  br label %cleanup

cleanup:                                          ; preds = %error, %entry
  %retval.0 = phi i32 [ %err.0, %error ], [ -12, %entry ]
  ret i32 %retval.0
}

declare void @down_read(%struct.rw_semaphore*) #1

declare void @up_read(%struct.rw_semaphore*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user.126(i8* %to, i8* %from, i64 %n) #3 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.11.130, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.12.131, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_add(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_info* %info, i32 %replace) #0 {
entry:
  %kctl = alloca %struct.snd_kcontrol, align 8
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !166
  %tobool = icmp ne i32 %replace, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %user_ctl_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 15
  %1 = load i32, i32* %user_ctl_count, align 4, !tbaa !194
  %cmp = icmp sge i32 %1, 32
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %count = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %2 = load i32, i32* %count, align 8, !tbaa !120
  %cmp2 = icmp ult i32 %2, 1
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %access5 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  %3 = load i32, i32* %access5, align 4, !tbaa !195
  %cmp6 = icmp eq i32 %3, 0
  br i1 %cmp6, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end4
  %access7 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  %4 = load i32, i32* %access7, align 4, !tbaa !195
  %and = and i32 %4, 307
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end4
  %cond = phi i32 [ %and, %cond.false ], [ 3, %if.end4 ]
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  store i32 0, i32* %numid, align 8, !tbaa !196
  %5 = bitcast %struct.snd_kcontrol* %kctl to i8*
  call void @llvm.memset.p0i8.i64(i8* %5, i8 0, i64 144, i32 8, i1 false)
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %id8 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %0, %struct.snd_ctl_elem_id* %id8)
  %tobool9 = icmp ne %struct.snd_kcontrol* %call, null
  %tobool11 = icmp ne i32 %replace, 0
  br i1 %tobool9, label %if.then10, label %if.else15

if.then10:                                        ; preds = %cond.end
  br i1 %tobool11, label %if.then12, label %if.end19

if.then12:                                        ; preds = %if.then10
  %call13 = call i32 @snd_ctl_remove(%struct.snd_card* %0, %struct.snd_kcontrol* %call)
  br label %if.end19

if.else15:                                        ; preds = %cond.end
  %. = select i1 %tobool11, i32 -2, i32 0
  br label %if.end19

if.end19:                                         ; preds = %if.else15, %if.then12, %if.then10
  %err.2 = phi i32 [ %., %if.else15 ], [ %call13, %if.then12 ], [ -16, %if.then10 ]
  %controls_rwsem20 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem20)
  %cmp21 = icmp slt i32 %err.2, 0
  br i1 %cmp21, label %cleanup, label %if.end23

if.end23:                                         ; preds = %if.end19
  %cmp24 = icmp uge i64 64, 64
  %id26 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %6 = bitcast %struct.snd_ctl_elem_id* %id26 to i8*
  %id27 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %7 = bitcast %struct.snd_ctl_elem_id* %id27 to i8*
  br i1 %cmp24, label %if.then25, label %if.else29

if.then25:                                        ; preds = %if.end23
  %call28 = call i8* @__memcpy(i8* %6, i8* %7, i64 64)
  br label %if.end32

if.else29:                                        ; preds = %if.end23
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 64, i32 8, i1 false)
  br label %if.end32

if.end32:                                         ; preds = %if.else29, %if.then25
  %owner = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 4
  %8 = load i32, i32* %owner, align 4, !tbaa !184
  %tobool33 = icmp ne i32 %8, 0
  br i1 %tobool33, label %cond.true34, label %cond.end37

cond.true34:                                      ; preds = %if.end32
  %owner35 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 4
  %9 = load i32, i32* %owner35, align 4, !tbaa !184
  br label %cond.end37

cond.end37:                                       ; preds = %cond.true34, %if.end32
  %cond38 = phi i32 [ %9, %cond.true34 ], [ 1, %if.end32 ]
  %count39 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 2
  store i32 %cond38, i32* %count39, align 8, !tbaa !133
  %or = or i32 %cond, 536870912
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 1
  %10 = load i32, i32* %type, align 8, !tbaa !117
  %cmp40 = icmp eq i32 %10, 3
  %info42 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 3
  %snd_ctl_elem_user_info.sink = select i1 %cmp40, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @snd_ctl_elem_user_enum_info, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @snd_ctl_elem_user_info
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* %snd_ctl_elem_user_info.sink, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info42, align 8, !tbaa !147
  %and46 = and i32 %or, 1
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %cond.end37
  %get = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 4
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @snd_ctl_elem_user_get, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !158
  br label %if.end49

if.end49:                                         ; preds = %if.then48, %cond.end37
  %and50 = and i32 %or, 2
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end49
  %put = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 5
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @snd_ctl_elem_user_put, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !160
  br label %if.end53

if.end53:                                         ; preds = %if.then52, %if.end49
  %and54 = and i32 %or, 48
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.then56, label %if.end58

if.then56:                                        ; preds = %if.end53
  %tlv = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 6
  %c = bitcast %union.anon.58* %tlv to i32 (%struct.snd_kcontrol*, i32, i32, i32*)**
  store i32 (%struct.snd_kcontrol*, i32, i32, i32*)* @snd_ctl_elem_user_tlv, i32 (%struct.snd_kcontrol*, i32, i32, i32*)** %c, align 8, !tbaa !29
  %or57 = or i32 %or, 268435456
  br label %if.end58

if.end58:                                         ; preds = %if.then56, %if.end53
  %access.0 = phi i32 [ %or57, %if.then56 ], [ %or, %if.end53 ]
  %type59 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 1
  %11 = load i32, i32* %type59, align 8, !tbaa !117
  %Pivot8 = icmp slt i32 %11, 4
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end58
  %Pivot6 = icmp slt i32 %11, 5
  br i1 %Pivot6, label %sw.bb75, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %11, 6
  br i1 %Pivot4, label %sw.bb80, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %11, 6
  br i1 %SwitchLeaf2, label %sw.bb64, label %cleanup

NodeBlock:                                        ; preds = %if.end58
  %Pivot = icmp slt i32 %11, 3
  br i1 %Pivot, label %LeafBlock, label %sw.bb69

LeafBlock:                                        ; preds = %NodeBlock
  %.off = add i32 %11, -1
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %count60 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %12 = load i32, i32* %count60, align 8, !tbaa !120
  %cmp61 = icmp ugt i32 %12, 128
  br i1 %cmp61, label %cleanup, label %sw.epilog

sw.bb64:                                          ; preds = %LeafBlock1
  %count65 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %13 = load i32, i32* %count65, align 8, !tbaa !120
  %cmp66 = icmp ugt i32 %13, 64
  br i1 %cmp66, label %cleanup, label %sw.epilog

sw.bb69:                                          ; preds = %NodeBlock
  %count70 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %14 = load i32, i32* %count70, align 8, !tbaa !120
  %cmp71 = icmp ugt i32 %14, 128
  br i1 %cmp71, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb69
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated = bitcast %union.anon.48* %value to %struct.anon.51*
  %items = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated, i32 0, i32 0
  %15 = load i32, i32* %items, align 8, !tbaa !29
  %cmp72 = icmp eq i32 %15, 0
  br i1 %cmp72, label %cleanup, label %sw.epilog

sw.bb75:                                          ; preds = %NodeBlock5
  %count76 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %16 = load i32, i32* %count76, align 8, !tbaa !120
  %cmp77 = icmp ugt i32 %16, 512
  br i1 %cmp77, label %cleanup, label %sw.epilog

sw.bb80:                                          ; preds = %NodeBlock3
  %count81 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %17 = load i32, i32* %count81, align 8, !tbaa !120
  %cmp82 = icmp ne i32 %17, 1
  br i1 %cmp82, label %cleanup, label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb80, %sw.bb75, %lor.lhs.false, %sw.bb64, %sw.bb
  %private_size.0 = phi i64 [ 8, %sw.bb ], [ 8, %sw.bb64 ], [ 4, %lor.lhs.false ], [ 1, %sw.bb75 ], [ 176, %sw.bb80 ]
  %count85 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %18 = load i32, i32* %count85, align 8, !tbaa !120
  %conv = zext i32 %18 to i64
  %mul = mul nsw i64 %private_size.0, %conv
  %add = add i64 312, %mul
  %call86 = call i8* @kzalloc.107(i64 %add, i32 208)
  %19 = bitcast i8* %call86 to %struct.user_element*
  %cmp87 = icmp eq %struct.user_element* %19, null
  br i1 %cmp87, label %cleanup, label %if.end90

if.end90:                                         ; preds = %sw.epilog
  %info91 = getelementptr inbounds %struct.user_element, %struct.user_element* %19, i32 0, i32 0
  %20 = bitcast %struct.snd_ctl_elem_info* %info91 to i8*
  %21 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %20, i8* %21, i64 272, i32 8, i1 false), !tbaa.struct !197
  %info92 = getelementptr inbounds %struct.user_element, %struct.user_element* %19, i32 0, i32 0
  %access93 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info92, i32 0, i32 2
  store i32 0, i32* %access93, align 4, !tbaa !198
  %22 = bitcast %struct.user_element* %19 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %22, i64 312
  %elem_data = getelementptr inbounds %struct.user_element, %struct.user_element* %19, i32 0, i32 1
  store i8* %add.ptr, i8** %elem_data, align 8, !tbaa !200
  %elem_data_size = getelementptr inbounds %struct.user_element, %struct.user_element* %19, i32 0, i32 2
  store i64 %mul, i64* %elem_data_size, align 8, !tbaa !201
  %info94 = getelementptr inbounds %struct.user_element, %struct.user_element* %19, i32 0, i32 0
  %type95 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info94, i32 0, i32 1
  %23 = load i32, i32* %type95, align 8, !tbaa !202
  %cmp96 = icmp eq i32 %23, 3
  br i1 %cmp96, label %if.then98, label %if.end104

if.then98:                                        ; preds = %if.end90
  %call99 = call i32 @snd_ctl_elem_init_enum_names(%struct.user_element* %19)
  %cmp100 = icmp slt i32 %call99, 0
  br i1 %cmp100, label %if.then102, label %if.end104

if.then102:                                       ; preds = %if.then98
  %24 = bitcast %struct.user_element* %19 to i8*
  call void @kfree(i8* %24)
  br label %cleanup

if.end104:                                        ; preds = %if.then98, %if.end90
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 9
  store void (%struct.snd_kcontrol*)* @snd_ctl_elem_user_free, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !146
  %call105 = call %struct.snd_kcontrol* @snd_ctl_new(%struct.snd_kcontrol* %kctl, i32 %access.0)
  %cmp106 = icmp eq %struct.snd_kcontrol* %call105, null
  br i1 %cmp106, label %if.then108, label %if.end109

if.then108:                                       ; preds = %if.end104
  %priv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %19, i32 0, i32 5
  %25 = load i8*, i8** %priv_data, align 8, !tbaa !203
  call void @kfree(i8* %25)
  %26 = bitcast %struct.user_element* %19 to i8*
  call void @kfree(i8* %26)
  br label %cleanup

if.end109:                                        ; preds = %if.end104
  %27 = bitcast %struct.user_element* %19 to i8*
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call105, i32 0, i32 8
  store i8* %27, i8** %private_data, align 8, !tbaa !163
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end109
  %idx.0 = phi i32 [ 0, %if.end109 ], [ %inc, %for.body ]
  %count110 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call105, i32 0, i32 2
  %28 = load i32, i32* %count110, align 8, !tbaa !133
  %cmp111 = icmp ult i32 %idx.0, %28
  br i1 %cmp111, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call105, i32 0, i32 10
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i64 0, i64 %idxprom
  %owner113 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  store %struct.snd_ctl_file* %file, %struct.snd_ctl_file** %owner113, align 8, !tbaa !177
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call114 = call i32 @snd_ctl_add(%struct.snd_card* %0, %struct.snd_kcontrol* %call105)
  %cmp115 = icmp slt i32 %call114, 0
  br i1 %cmp115, label %cleanup, label %if.end118

if.end118:                                        ; preds = %for.end
  %controls_rwsem119 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem119)
  %user_ctl_count120 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 15
  %29 = load i32, i32* %user_ctl_count120, align 4, !tbaa !194
  %inc121 = add nsw i32 %29, 1
  store i32 %inc121, i32* %user_ctl_count120, align 4, !tbaa !194
  %controls_rwsem122 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem122)
  br label %cleanup

cleanup:                                          ; preds = %if.end118, %for.end, %if.then108, %if.then102, %sw.epilog, %sw.bb80, %sw.bb75, %lor.lhs.false, %sw.bb69, %sw.bb64, %sw.bb, %LeafBlock, %LeafBlock1, %if.end19, %if.end, %land.lhs.true
  %retval.0 = phi i32 [ %call99, %if.then102 ], [ -12, %if.then108 ], [ 0, %if.end118 ], [ -12, %land.lhs.true ], [ -22, %if.end ], [ %err.2, %if.end19 ], [ -22, %sw.bb ], [ -22, %sw.bb64 ], [ -22, %lor.lhs.false ], [ -22, %sw.bb69 ], [ -22, %sw.bb75 ], [ -22, %sw.bb80 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -12, %sw.epilog ], [ %call114, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_user_enum_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.user_element*
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %enumerated = bitcast %union.anon.48* %value to %struct.anon.51*
  %item1 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated, i32 0, i32 1
  %2 = load i32, i32* %item1, align 4, !tbaa !29
  %info = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 0
  %3 = bitcast %struct.snd_ctl_elem_info* %uinfo to i8*
  %4 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 272, i32 8, i1 false), !tbaa.struct !197
  store i32 %2, i32* %_min1, align 4, !tbaa !25
  %value2 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %enumerated3 = bitcast %union.anon.48* %value2 to %struct.anon.51*
  %items = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated3, i32 0, i32 0
  %5 = load i32, i32* %items, align 8, !tbaa !29
  %sub = sub i32 %5, 1
  store i32 %sub, i32* %_min2, align 4, !tbaa !25
  %6 = load i32, i32* %_min1, align 4, !tbaa !25
  %7 = load i32, i32* %_min2, align 4, !tbaa !25
  %cmp4 = icmp ult i32 %6, %7
  %8 = load i32, i32* %_min1, align 4
  %9 = load i32, i32* %_min2, align 4
  %cond = select i1 %cmp4, i32 %8, i32 %9
  %value6 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %enumerated7 = bitcast %union.anon.48* %value6 to %struct.anon.51*
  %item8 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated7, i32 0, i32 1
  store i32 %cond, i32* %item8, align 4, !tbaa !29
  %priv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 5
  %10 = load i8*, i8** %priv_data, align 8, !tbaa !203
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %names.0 = phi i8* [ %10, %entry ], [ %add.ptr, %for.body ]
  %item.0 = phi i32 [ %cond, %entry ], [ %dec, %for.body ]
  %cmp9 = icmp ugt i32 %item.0, 0
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i64 @strlen(i8* %names.0)
  %add = add i64 %call, 1
  %add.ptr = getelementptr inbounds i8, i8* %names.0, i64 %add
  %dec = add i32 %item.0, -1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %value11 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %enumerated12 = bitcast %union.anon.48* %value11 to %struct.anon.51*
  %name = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated12, i32 0, i32 2
  %arraydecay = getelementptr inbounds [64 x i8], [64 x i8]* %name, i32 0, i32 0
  %call13 = call i8* @strcpy(i8* %arraydecay, i8* %names.0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_user_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.user_element*
  %info = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 0
  %2 = bitcast %struct.snd_ctl_elem_info* %uinfo to i8*
  %3 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 272, i32 8, i1 false), !tbaa.struct !197
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_user_get(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.user_element*
  %elem_data_size = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 2
  %2 = load i64, i64* %elem_data_size, align 8, !tbaa !201
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %3 = bitcast %union.anon.53* %value to i8*
  %elem_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %4 = load i8*, i8** %elem_data, align 8, !tbaa !200
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 %2, i32 1, i1 false)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_user_put(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.user_element*
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %2 = bitcast %union.anon.53* %value to i8*
  %elem_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %3 = load i8*, i8** %elem_data, align 8, !tbaa !200
  %elem_data_size = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 2
  %4 = load i64, i64* %elem_data_size, align 8, !tbaa !201
  %call = call i32 @memcmp(i8* %2, i8* %3, i64 %4)
  %cmp = icmp ne i32 %call, 0
  %conv = zext i1 %cmp to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %elem_data_size1 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 2
  %5 = load i64, i64* %elem_data_size1, align 8, !tbaa !201
  %elem_data2 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %6 = load i8*, i8** %elem_data2, align 8, !tbaa !200
  %value3 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %7 = bitcast %union.anon.53* %value3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 %5, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_user_tlv(%struct.snd_kcontrol* %kcontrol, i32 %op_flag, i32 %size, i32* %tlv) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.user_element*
  %cmp = icmp sgt i32 %op_flag, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %cmp1 = icmp ugt i32 %size, 131072
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %if.then
  %2 = bitcast i32* %tlv to i8*
  %conv = zext i32 %size to i64
  %call = call i8* @memdup_user(i8* %2, i64 %conv)
  %call3 = call i64 @IS_ERR.127(i8* %call)
  %tobool = icmp ne i64 %call3, 0
  br i1 %tobool, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.end
  %call5 = call i64 @PTR_ERR.128(i8* %call)
  %conv6 = trunc i64 %call5 to i32
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %tlv_data_size = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  %3 = load i64, i64* %tlv_data_size, align 8, !tbaa !204
  %conv8 = zext i32 %size to i64
  %cmp9 = icmp ne i64 %3, %conv8
  %conv10 = zext i1 %cmp9 to i32
  %tobool11 = icmp ne i32 %conv10, 0
  br i1 %tobool11, label %if.end15, label %if.then12

if.then12:                                        ; preds = %if.end7
  %tlv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 3
  %4 = load i8*, i8** %tlv_data, align 8, !tbaa !205
  %conv13 = zext i32 %size to i64
  %call14 = call i32 @memcmp(i8* %4, i8* %call, i64 %conv13)
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end7
  %change.0 = phi i32 [ %conv10, %if.end7 ], [ %call14, %if.then12 ]
  %tlv_data16 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 3
  %5 = load i8*, i8** %tlv_data16, align 8, !tbaa !205
  call void @kfree(i8* %5)
  %tlv_data17 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 3
  store i8* %call, i8** %tlv_data17, align 8, !tbaa !205
  %conv18 = zext i32 %size to i64
  %tlv_data_size19 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  store i64 %conv18, i64* %tlv_data_size19, align 8, !tbaa !204
  br label %if.end39

if.else:                                          ; preds = %entry
  %tlv_data_size20 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  %6 = load i64, i64* %tlv_data_size20, align 8, !tbaa !204
  %tobool21 = icmp ne i64 %6, 0
  br i1 %tobool21, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.else
  %tlv_data22 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 3
  %7 = load i8*, i8** %tlv_data22, align 8, !tbaa !205
  %tobool23 = icmp ne i8* %7, null
  br i1 %tobool23, label %if.end25, label %cleanup

if.end25:                                         ; preds = %lor.lhs.false
  %conv26 = zext i32 %size to i64
  %tlv_data_size27 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  %8 = load i64, i64* %tlv_data_size27, align 8, !tbaa !204
  %cmp28 = icmp ult i64 %conv26, %8
  br i1 %cmp28, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.end25
  %9 = bitcast i32* %tlv to i8*
  %tlv_data32 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 3
  %10 = load i8*, i8** %tlv_data32, align 8, !tbaa !205
  %tlv_data_size33 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  %11 = load i64, i64* %tlv_data_size33, align 8, !tbaa !204
  %conv34 = trunc i64 %11 to i32
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %9, i8* %10, i32 %conv34) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool36 = icmp ne i32 %conv.i, 0
  br i1 %tobool36, label %cleanup, label %if.end39

if.end39:                                         ; preds = %if.end31, %if.end15
  %change.1 = phi i32 [ %change.0, %if.end15 ], [ 0, %if.end31 ]
  br label %cleanup

cleanup:                                          ; preds = %if.end39, %if.end31, %if.end25, %lor.lhs.false, %if.else, %if.then4, %if.then
  %retval.0 = phi i32 [ %conv6, %if.then4 ], [ %change.1, %if.end39 ], [ -22, %if.then ], [ -6, %lor.lhs.false ], [ -6, %if.else ], [ -28, %if.end25 ], [ -14, %if.end31 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_init_enum_names(%struct.user_element* %ue) #0 {
entry:
  %info = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated = bitcast %union.anon.48* %value to %struct.anon.51*
  %names_ptr = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated, i32 0, i32 3
  %0 = load i64, i64* %names_ptr, align 8, !tbaa !29
  %info1 = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value2 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info1, i32 0, i32 5
  %enumerated3 = bitcast %union.anon.48* %value2 to %struct.anon.51*
  %names_length = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated3, i32 0, i32 4
  %1 = load i32, i32* %names_length, align 8, !tbaa !29
  %cmp = icmp ugt i32 %1, 65536
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = inttoptr i64 %0 to i8*
  %info4 = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value5 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info4, i32 0, i32 5
  %enumerated6 = bitcast %union.anon.48* %value5 to %struct.anon.51*
  %names_length7 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated6, i32 0, i32 4
  %3 = load i32, i32* %names_length7, align 8, !tbaa !29
  %conv = zext i32 %3 to i64
  %call = call i8* @memdup_user(i8* %2, i64 %conv)
  %call8 = call i64 @IS_ERR.127(i8* %call)
  %tobool = icmp ne i64 %call8, 0
  br i1 %tobool, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %call10 = call i64 @PTR_ERR.128(i8* %call)
  %conv11 = trunc i64 %call10 to i32
  br label %cleanup

if.end12:                                         ; preds = %if.end
  %info13 = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value14 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info13, i32 0, i32 5
  %enumerated15 = bitcast %union.anon.48* %value14 to %struct.anon.51*
  %names_length16 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated15, i32 0, i32 4
  %4 = load i32, i32* %names_length16, align 8, !tbaa !29
  %conv17 = zext i32 %4 to i64
  br label %for.cond

for.cond:                                         ; preds = %if.end32, %if.end12
  %buf_len.0 = phi i64 [ %conv17, %if.end12 ], [ %sub, %if.end32 ]
  %p.0 = phi i8* [ %call, %if.end12 ], [ %add.ptr, %if.end32 ]
  %i.0 = phi i32 [ 0, %if.end12 ], [ %inc, %if.end32 ]
  %info18 = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value19 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info18, i32 0, i32 5
  %enumerated20 = bitcast %union.anon.48* %value19 to %struct.anon.51*
  %items = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated20, i32 0, i32 0
  %5 = load i32, i32* %items, align 8, !tbaa !29
  %cmp21 = icmp ult i32 %i.0, %5
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call23 = call i64 @strnlen(i8* %p.0, i64 %buf_len.0)
  %cmp24 = icmp eq i64 %call23, 0
  %cmp26 = icmp uge i64 %call23, 64
  %or.cond = or i1 %cmp24, %cmp26
  %cmp29 = icmp eq i64 %call23, %buf_len.0
  %or.cond1 = or i1 %or.cond, %cmp29
  br i1 %or.cond1, label %if.then31, label %if.end32

if.then31:                                        ; preds = %for.body
  call void @kfree(i8* %call)
  br label %cleanup

if.end32:                                         ; preds = %for.body
  %add = add i64 %call23, 1
  %add.ptr = getelementptr inbounds i8, i8* %p.0, i64 %add
  %add33 = add i64 %call23, 1
  %sub = sub i64 %buf_len.0, %add33
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %priv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 5
  store i8* %call, i8** %priv_data, align 8, !tbaa !203
  %info34 = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value35 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info34, i32 0, i32 5
  %enumerated36 = bitcast %union.anon.48* %value35 to %struct.anon.51*
  %names_ptr37 = getelementptr inbounds %struct.anon.51, %struct.anon.51* %enumerated36, i32 0, i32 3
  store i64 0, i64* %names_ptr37, align 8, !tbaa !29
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then31, %if.then9, %entry
  %retval.0 = phi i32 [ %conv11, %if.then9 ], [ -22, %if.then31 ], [ 0, %for.end ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_ctl_elem_user_free(%struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.user_element*
  %tlv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 3
  %2 = load i8*, i8** %tlv_data, align 8, !tbaa !205
  call void @kfree(i8* %2)
  %priv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 5
  %3 = load i8*, i8** %priv_data, align 8, !tbaa !203
  call void @kfree(i8* %3)
  %4 = bitcast %struct.user_element* %1 to i8*
  call void @kfree(i8* %4)
  ret void
}

declare i8* @memdup_user(i8*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR.127(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.128(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare i64 @strnlen(i8*, i64) #1

declare i32 @memcmp(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @copy_ctl_value_from_user(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %data, %struct.snd_ctl_elem_value32* %data32, i32* %typep, i32* %countp) #0 {
entry:
  %count = alloca i32, align 4
  %0 = load i32, i32* %count, align 4, !tbaa !25
  store i32 %0, i32* %count, align 4, !tbaa !25
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 0
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_value32, %struct.snd_ctl_elem_value32* %data32, i32 0, i32 0
  %2 = bitcast %struct.snd_ctl_elem_id* %id1 to i8*
  %call = call i64 @copy_from_user.126(i8* %1, i8* %2, i64 64)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup54, label %if.end

if.end:                                           ; preds = %entry
  call void @might_fault()
  %indirect2 = getelementptr inbounds %struct.snd_ctl_elem_value32, %struct.snd_ctl_elem_value32* %data32, i32 0, i32 1
  %3 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %indirect2, i64 4) #8, !srcloc !206
  %asmresult = extractvalue { i32*, i64 } %3, 0
  %asmresult3 = extractvalue { i32*, i64 } %3, 1
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  %conv = trunc i64 %asmresult3 to i32
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %cleanup54, label %if.end6

if.end6:                                          ; preds = %if.end
  %tobool7 = icmp ne i32 %conv, 0
  br i1 %tobool7, label %cleanup54, label %if.end9

if.end9:                                          ; preds = %if.end6
  %id10 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 0
  %call11 = call i32 @get_ctl_type(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id10, i32* %count)
  %cmp = icmp slt i32 %call11, 0
  br i1 %cmp, label %cleanup54, label %if.end14

if.end14:                                         ; preds = %if.end9
  %call11.off = add i32 %call11, -1
  %switch = icmp ult i32 %call11.off, 2
  br i1 %switch, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end14
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then19
  %i.0 = phi i32 [ 0, %if.then19 ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %if.then19 ], [ %retval.1, %for.inc ]
  %6 = load i32, i32* %count, align 4, !tbaa !25
  %cmp20 = icmp slt i32 %i.0, %6
  br i1 %cmp20, label %for.body, label %if.end53

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %value = getelementptr inbounds %struct.snd_ctl_elem_value32, %struct.snd_ctl_elem_value32* %data32, i32 0, i32 2
  %integer = bitcast %union.anon.70* %value to [128 x i32]*
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [128 x i32], [128 x i32]* %integer, i64 0, i64 %idxprom
  %7 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %arrayidx, i64 4) #8, !srcloc !207
  %asmresult24 = extractvalue { i32*, i64 } %7, 0
  %asmresult25 = extractvalue { i32*, i64 } %7, 1
  %8 = ptrtoint i32* %asmresult24 to i64
  %9 = trunc i64 %8 to i32
  %conv26 = trunc i64 %asmresult25 to i32
  %tobool28 = icmp ne i32 %9, 0
  br i1 %tobool28, label %LeafBlock, label %if.end30

if.end30:                                         ; preds = %for.body
  %conv31 = sext i32 %conv26 to i64
  %value32 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 2
  %integer33 = bitcast %union.anon.53* %value32 to %union.anon.54*
  %value34 = bitcast %union.anon.54* %integer33 to [128 x i64]*
  %idxprom35 = sext i32 %i.0 to i64
  %arrayidx36 = getelementptr inbounds [128 x i64], [128 x i64]* %value34, i64 0, i64 %idxprom35
  store i64 %conv31, i64* %arrayidx36, align 8, !tbaa !29
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end30, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end30 ], [ 1, %for.body ]
  %retval.1 = phi i32 [ %retval.0, %if.end30 ], [ -14, %for.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup54

for.inc:                                          ; preds = %LeafBlock
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %if.end14
  %10 = load i32, i32* %count, align 4, !tbaa !25
  %call37 = call i32 @get_elem_size(i32 %call11, i32 %10)
  %cmp38 = icmp slt i32 %call37, 0
  br i1 %cmp38, label %if.then40, label %if.end42

if.then40:                                        ; preds = %if.else
  %11 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup54

if.end42:                                         ; preds = %if.else
  %value43 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 2
  %bytes = bitcast %union.anon.53* %value43 to %union.anon.57*
  %data44 = bitcast %union.anon.57* %bytes to [512 x i8]*
  %arraydecay = getelementptr inbounds [512 x i8], [512 x i8]* %data44, i32 0, i32 0
  %value45 = getelementptr inbounds %struct.snd_ctl_elem_value32, %struct.snd_ctl_elem_value32* %data32, i32 0, i32 2
  %data46 = bitcast %union.anon.70* %value45 to [512 x i8]*
  %arraydecay47 = getelementptr inbounds [512 x i8], [512 x i8]* %data46, i32 0, i32 0
  %conv48 = sext i32 %call37 to i64
  %call49 = call i64 @copy_from_user.126(i8* %arraydecay, i8* %arraydecay47, i64 %conv48)
  %tobool50 = icmp ne i64 %call49, 0
  br i1 %tobool50, label %cleanup54, label %if.end53

if.end53:                                         ; preds = %if.end42, %for.cond
  store i32 %call11, i32* %typep, align 4, !tbaa !25
  %12 = load i32, i32* %count, align 4, !tbaa !25
  store i32 %12, i32* %countp, align 4, !tbaa !25
  br label %cleanup54

cleanup54:                                        ; preds = %if.end53, %if.end42, %if.then40, %LeafBlock, %if.end9, %if.end6, %if.end, %entry
  %retval.2 = phi i32 [ 0, %if.end53 ], [ -22, %if.then40 ], [ -14, %entry ], [ -14, %if.end ], [ -22, %if.end6 ], [ %call11, %if.end9 ], [ -14, %if.end42 ], [ %retval.1, %LeafBlock ]
  ret i32 %retval.2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_power_lock.132(%struct.snd_card* %card) #3 {
entry:
  %power_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 31
  call void @mutex_lock_nested(%struct.mutex* %power_lock, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_write(%struct.snd_card* %card, %struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value* %control) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %if.end22, label %if.else

if.else:                                          ; preds = %entry
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  %call2 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_id* %id1)
  %vd3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom = zext i32 %call2 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd3, i64 0, i64 %idxprom
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %0 = load i32, i32* %access, align 8, !tbaa !137
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.end

lor.lhs.false:                                    ; preds = %if.else
  %put = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 5
  %1 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !160
  %cmp4 = icmp eq i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* %1, null
  br i1 %cmp4, label %if.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %tobool6 = icmp ne %struct.snd_ctl_file* %file, null
  br i1 %tobool6, label %land.lhs.true, label %if.else12

land.lhs.true:                                    ; preds = %lor.lhs.false5
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %2 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !177
  %tobool7 = icmp ne %struct.snd_ctl_file* %2, null
  br i1 %tobool7, label %land.lhs.true8, label %if.else12

land.lhs.true8:                                   ; preds = %land.lhs.true
  %owner9 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %3 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner9, align 8, !tbaa !177
  %cmp10 = icmp ne %struct.snd_ctl_file* %3, %file
  br i1 %cmp10, label %if.end, label %if.else12

if.else12:                                        ; preds = %land.lhs.true8, %land.lhs.true, %lor.lhs.false5
  %id13 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id13, %struct.snd_kcontrol* %call, i32 %call2)
  %put15 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 5
  %4 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put15, align 8, !tbaa !160
  %call16 = call i32 %4(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_value* %control)
  br label %if.end

if.end:                                           ; preds = %if.else12, %land.lhs.true8, %lor.lhs.false, %if.else
  %result.0 = phi i32 [ %call16, %if.else12 ], [ -1, %land.lhs.true8 ], [ -1, %lor.lhs.false ], [ -1, %if.else ]
  %cmp17 = icmp sgt i32 %result.0, 0
  br i1 %cmp17, label %if.then18, label %if.end22

if.then18:                                        ; preds = %if.end
  %controls_rwsem19 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem19)
  %id20 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 1, %struct.snd_ctl_elem_id* %id20)
  br label %cleanup

if.end22:                                         ; preds = %if.end, %entry
  %result.1 = phi i32 [ -2, %entry ], [ %result.0, %if.end ]
  %controls_rwsem23 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem23)
  br label %cleanup

cleanup:                                          ; preds = %if.end22, %if.then18
  %retval.0 = phi i32 [ %result.1, %if.end22 ], [ 0, %if.then18 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_power_unlock.133(%struct.snd_card* %card) #3 {
entry:
  %power_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 31
  call void @mutex_unlock(%struct.mutex* %power_lock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @copy_ctl_value_to_user(%struct.snd_ctl_elem_value32* %data32, %struct.snd_ctl_elem_value* %data, i32 %type, i32 %count) #0 {
entry:
  %type.off = add i32 %type, -1
  %switch = icmp ult i32 %type.off, 2
  br i1 %switch, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %if.then ], [ %.retval.0, %for.inc ]
  %cmp2 = icmp slt i32 %i.0, %count
  br i1 %cmp2, label %for.body, label %if.end18

for.body:                                         ; preds = %for.cond
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 2
  %integer = bitcast %union.anon.53* %value to %union.anon.54*
  %value3 = bitcast %union.anon.54* %integer to [128 x i64]*
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value3, i64 0, i64 %idxprom
  %0 = load i64, i64* %arrayidx, align 8, !tbaa !29
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %value4 = getelementptr inbounds %struct.snd_ctl_elem_value32, %struct.snd_ctl_elem_value32* %data32, i32 0, i32 2
  %integer5 = bitcast %union.anon.70* %value4 to [128 x i32]*
  %idxprom6 = sext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [128 x i32], [128 x i32]* %integer5, i64 0, i64 %idxprom6
  %1 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv, i32* %arrayidx7) #8, !srcloc !208
  %tobool = icmp ne i32 %1, 0
  %. = select i1 %tobool, i32 1, i32 0
  %.retval.0 = select i1 %tobool, i32 -14, i32 %retval.0
  %SwitchLeaf = icmp eq i32 %., 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup19

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %entry
  %call = call i32 @get_elem_size(i32 %type, i32 %count)
  %value9 = getelementptr inbounds %struct.snd_ctl_elem_value32, %struct.snd_ctl_elem_value32* %data32, i32 0, i32 2
  %data10 = bitcast %union.anon.70* %value9 to [512 x i8]*
  %arraydecay = getelementptr inbounds [512 x i8], [512 x i8]* %data10, i32 0, i32 0
  %value11 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 2
  %bytes = bitcast %union.anon.53* %value11 to %union.anon.57*
  %data12 = bitcast %union.anon.57* %bytes to [512 x i8]*
  %arraydecay13 = getelementptr inbounds [512 x i8], [512 x i8]* %data12, i32 0, i32 0
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %arraydecay, i8* %arraydecay13, i32 %call) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool15 = icmp ne i32 %conv.i, 0
  br i1 %tobool15, label %cleanup19, label %if.end18

if.end18:                                         ; preds = %if.else, %for.cond
  br label %cleanup19

cleanup19:                                        ; preds = %if.end18, %if.else, %for.body
  %retval.2 = phi i32 [ 0, %if.end18 ], [ -14, %if.else ], [ %.retval.0, %for.body ]
  ret i32 %retval.2
}

; Function Attrs: nounwind uwtable
define internal i32 @get_elem_size(i32 %type, i32 %count) #0 {
entry:
  %Pivot6 = icmp slt i32 %type, 5
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %type, 6
  br i1 %Pivot4, label %return, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %type, 6
  br i1 %SwitchLeaf2, label %sw.bb, label %return

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %type, 4
  br i1 %Pivot, label %LeafBlock, label %return

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %type, 3
  br i1 %SwitchLeaf, label %sw.bb2, label %return

sw.bb:                                            ; preds = %LeafBlock1
  %conv = sext i32 %count to i64
  %mul = mul i64 8, %conv
  %conv1 = trunc i64 %mul to i32
  br label %return

sw.bb2:                                           ; preds = %LeafBlock
  %conv3 = sext i32 %count to i64
  %mul4 = mul i64 4, %conv3
  %conv5 = trunc i64 %mul4 to i32
  br label %return

return:                                           ; preds = %sw.bb2, %sw.bb, %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3
  %retval.0 = phi i32 [ %conv5, %sw.bb2 ], [ %conv1, %sw.bb ], [ 512, %NodeBlock ], [ 176, %NodeBlock3 ], [ -1, %LeafBlock ], [ -1, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %dst_id, %struct.snd_kcontrol* %src_kctl, i32 %offset) #3 {
entry:
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %src_kctl, i32 0, i32 1
  %0 = bitcast %struct.snd_ctl_elem_id* %dst_id to i8*
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 64, i32 4, i1 false), !tbaa.struct !135
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %dst_id, i32 0, i32 5
  %2 = load i32, i32* %index, align 4, !tbaa !132
  %add = add i32 %2, %offset
  store i32 %add, i32* %index, align 4, !tbaa !132
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %dst_id, i32 0, i32 0
  %3 = load i32, i32* %numid, align 4, !tbaa !123
  %add1 = add i32 %3, %offset
  store i32 %add1, i32* %numid, align 4, !tbaa !123
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @get_ctl_type(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id, i32* %countp) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %tobool = icmp ne %struct.snd_kcontrol* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %controls_rwsem1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call i8* @kzalloc.107(i64 272, i32 208)
  %0 = bitcast i8* %call2 to %struct.snd_ctl_elem_info*
  %cmp = icmp eq %struct.snd_ctl_elem_info* %0, null
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %controls_rwsem4 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem4)
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %id6 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 0
  %1 = bitcast %struct.snd_ctl_elem_id* %id6 to i8*
  %2 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 64, i32 4, i1 false), !tbaa.struct !135
  %info7 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 3
  %3 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info7, align 8, !tbaa !147
  %call8 = call i32 %3(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_info* %0)
  %controls_rwsem9 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem9)
  %cmp10 = icmp sge i32 %call8, 0
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end5
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  %4 = load i32, i32* %type, align 8, !tbaa !117
  %count = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 3
  %5 = load i32, i32* %count, align 8, !tbaa !120
  store i32 %5, i32* %countp, align 4, !tbaa !25
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end5
  %err.0 = phi i32 [ %4, %if.then11 ], [ %call8, %if.end5 ]
  %6 = bitcast %struct.snd_ctl_elem_info* %0 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.then3, %if.then
  %retval.0 = phi i32 [ -12, %if.then3 ], [ %err.0, %if.end12 ], [ -6, %if.then ]
  ret i32 %retval.0
}

declare i32 @printk(i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_read(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %control) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %if.end11, label %if.else

if.else:                                          ; preds = %entry
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  %call2 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_id* %id1)
  %vd3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom = zext i32 %call2 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd3, i64 0, i64 %idxprom
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %0 = load i32, i32* %access, align 8, !tbaa !137
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.else
  %get = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 4
  %1 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !158
  %cmp4 = icmp ne i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* %1, null
  br i1 %cmp4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %land.lhs.true
  %id6 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id6, %struct.snd_kcontrol* %call, i32 %call2)
  %get8 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 4
  %2 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get8, align 8, !tbaa !158
  %call9 = call i32 %2(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_value* %control)
  br label %if.end11

if.end11:                                         ; preds = %if.then5, %land.lhs.true, %if.else, %entry
  %result.1 = phi i32 [ -2, %entry ], [ %call9, %if.then5 ], [ -1, %land.lhs.true ], [ -1, %if.else ]
  %controls_rwsem12 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem12)
  ret i32 %result.1
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_info(%struct.snd_ctl_file* %ctl, %struct.snd_ctl_elem_info* %info) #0 {
entry:
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !166
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %0, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %controls_rwsem2 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem2)
  br label %cleanup

if.end:                                           ; preds = %entry
  %access = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  store i32 0, i32* %access, align 4, !tbaa !195
  %info3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 3
  %1 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info3, align 8, !tbaa !147
  %call4 = call i32 %1(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_info* %info)
  %cmp5 = icmp sge i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end46

if.then6:                                         ; preds = %if.end
  %access7 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  %2 = load i32, i32* %access7, align 4, !tbaa !195
  %tobool = icmp ne i32 %2, 0
  %lnot = xor i1 %tobool, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext13 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.then6
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.103, i32 0, i32 0), i32 792)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.then6
  %id24 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %call25 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_id* %id24)
  %vd26 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom = zext i32 %call25 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd26, i64 0, i64 %idxprom
  %id27 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id27, %struct.snd_kcontrol* %call, i32 %call25)
  %access29 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %3 = load i32, i32* %access29, align 8, !tbaa !137
  %access30 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  store i32 %3, i32* %access30, align 4, !tbaa !195
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %4 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !177
  %tobool31 = icmp ne %struct.snd_ctl_file* %4, null
  br i1 %tobool31, label %if.then32, label %if.end45

if.then32:                                        ; preds = %if.end16
  %access33 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  %5 = load i32, i32* %access33, align 4, !tbaa !195
  %or = or i32 %5, 512
  store i32 %or, i32* %access33, align 4, !tbaa !195
  %owner34 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %6 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner34, align 8, !tbaa !177
  %cmp35 = icmp eq %struct.snd_ctl_file* %6, %ctl
  br i1 %cmp35, label %if.then37, label %if.end40

if.then37:                                        ; preds = %if.then32
  %access38 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  %7 = load i32, i32* %access38, align 4, !tbaa !195
  %or39 = or i32 %7, 1024
  store i32 %or39, i32* %access38, align 4, !tbaa !195
  br label %if.end40

if.end40:                                         ; preds = %if.then37, %if.then32
  %owner41 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %8 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner41, align 8, !tbaa !177
  %pid = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %8, i32 0, i32 2
  %9 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !176
  %call42 = call i32 @pid_vnr(%struct.pid* %9)
  br label %if.end45

if.end45:                                         ; preds = %if.end40, %if.end16
  %.sink = phi i32 [ %call42, %if.end40 ], [ -1, %if.end16 ]
  %owner44 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 4
  store i32 %.sink, i32* %owner44, align 4, !tbaa !184
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.end
  %controls_rwsem47 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem47)
  br label %cleanup

cleanup:                                          ; preds = %if.end46, %if.then
  %retval.0 = phi i32 [ -2, %if.then ], [ %call4, %if.end46 ]
  ret i32 %retval.0
}

declare i32 @pid_vnr(%struct.pid*) #1

declare i8* @compat_alloc_user_space(i64) #1

declare i64 @copy_in_user(i8*, i8*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_list(%struct.snd_card* %card, %struct.snd_ctl_elem_list* %_list) #0 {
entry:
  %list = alloca %struct.snd_ctl_elem_list, align 8
  %0 = bitcast %struct.snd_ctl_elem_list* %list to i8*
  %1 = bitcast %struct.snd_ctl_elem_list* %_list to i8*
  %call = call i64 @copy_from_user.126(i8* %0, i8* %1, i64 80)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %offset1 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 0
  %2 = load i32, i32* %offset1, align 8, !tbaa !209
  %space2 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 1
  %3 = load i32, i32* %space2, align 4, !tbaa !211
  %cmp = icmp ugt i32 %3, 16384
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %cmp5 = icmp ugt i32 %3, 0
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end4
  %conv = zext i32 %3 to i64
  %mul = mul i64 %conv, 64
  %call7 = call i8* @vmalloc(i64 %mul)
  %4 = bitcast i8* %call7 to %struct.snd_ctl_elem_id*
  %cmp8 = icmp eq %struct.snd_ctl_elem_id* %4, null
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.then6
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %controls_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  %5 = load i32, i32* %controls_count, align 8, !tbaa !145
  %count = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 3
  store i32 %5, i32* %count, align 4, !tbaa !212
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  br label %while.cond

while.cond:                                       ; preds = %if.end23, %if.end11
  %.sink = phi %struct.list_head* [ %6, %if.end23 ], [ %controls, %if.end11 ]
  %offset.0 = phi i32 [ %2, %if.end11 ], [ %sub, %if.end23 ]
  %next25 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next25, align 8, !tbaa !2
  %controls12 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  %cmp13 = icmp eq %struct.list_head* %6, %controls12
  %cmp15 = icmp eq i32 %offset.0, 0
  %or.cond = or i1 %cmp13, %cmp15
  br i1 %or.cond, label %while.end, label %if.end18

if.end18:                                         ; preds = %while.cond
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr to %struct.snd_kcontrol*
  %count19 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 2
  %9 = load i32, i32* %count19, align 8, !tbaa !133
  %cmp20 = icmp ult i32 %offset.0, %9
  br i1 %cmp20, label %while.end, label %if.end23

if.end23:                                         ; preds = %if.end18
  %count24 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 2
  %10 = load i32, i32* %count24, align 8, !tbaa !133
  %sub = sub i32 %offset.0, %10
  br label %while.cond

while.end:                                        ; preds = %if.end18, %while.cond
  %used = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 2
  store i32 0, i32* %used, align 8, !tbaa !213
  br label %while.cond26

while.cond26:                                     ; preds = %for.end, %while.end
  %offset.1 = phi i32 [ %offset.0, %while.end ], [ 0, %for.end ]
  %id.0 = phi %struct.snd_ctl_elem_id* [ %4, %while.end ], [ %id.1, %for.end ]
  %space.0 = phi i32 [ %3, %while.end ], [ %space.1, %for.end ]
  %plist.1 = phi %struct.list_head* [ %6, %while.end ], [ %16, %for.end ]
  %cmp27 = icmp ugt i32 %space.0, 0
  %controls29 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  %cmp30 = icmp ne %struct.list_head* %plist.1, %controls29
  %11 = select i1 %cmp27, i1 %cmp30, i1 false
  br i1 %11, label %while.body32, label %while.end47

while.body32:                                     ; preds = %while.cond26
  %12 = bitcast %struct.list_head* %plist.1 to i8*
  %add.ptr35 = getelementptr inbounds i8, i8* %12, i64 0
  %13 = bitcast i8* %add.ptr35 to %struct.snd_kcontrol*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %while.body32
  %id.1 = phi %struct.snd_ctl_elem_id* [ %id.0, %while.body32 ], [ %incdec.ptr, %for.body ]
  %space.1 = phi i32 [ %space.0, %while.body32 ], [ %dec, %for.body ]
  %jidx.0 = phi i32 [ %offset.1, %while.body32 ], [ %inc45, %for.body ]
  %cmp36 = icmp ugt i32 %space.1, 0
  br i1 %cmp36, label %land.rhs38, label %for.end

land.rhs38:                                       ; preds = %for.cond
  %count39 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %13, i32 0, i32 2
  %14 = load i32, i32* %count39, align 8, !tbaa !133
  %cmp40 = icmp ult i32 %jidx.0, %14
  br i1 %cmp40, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs38
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id.1, %struct.snd_kcontrol* %13, i32 %jidx.0)
  %incdec.ptr = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id.1, i32 1
  %dec = add i32 %space.1, -1
  %used44 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 2
  %15 = load i32, i32* %used44, align 8, !tbaa !213
  %inc = add i32 %15, 1
  store i32 %inc, i32* %used44, align 8, !tbaa !213
  %inc45 = add i32 %jidx.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.rhs38, %for.cond
  %next46 = getelementptr inbounds %struct.list_head, %struct.list_head* %plist.1, i32 0, i32 0
  %16 = load %struct.list_head*, %struct.list_head** %next46, align 8, !tbaa !66
  br label %while.cond26

while.end47:                                      ; preds = %while.cond26
  %controls_rwsem48 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem48)
  %used49 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 2
  %17 = load i32, i32* %used49, align 8, !tbaa !213
  %cmp50 = icmp ugt i32 %17, 0
  br i1 %cmp50, label %land.lhs.true, label %if.end59

land.lhs.true:                                    ; preds = %while.end47
  %pids = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 4
  %18 = load %struct.snd_ctl_elem_id*, %struct.snd_ctl_elem_id** %pids, align 8, !tbaa !214
  %19 = bitcast %struct.snd_ctl_elem_id* %18 to i8*
  %20 = bitcast %struct.snd_ctl_elem_id* %4 to i8*
  %used52 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 2
  %21 = load i32, i32* %used52, align 8, !tbaa !213
  %conv53 = zext i32 %21 to i64
  %mul54 = mul i64 %conv53, 64
  %conv55 = trunc i64 %mul54 to i32
  call void @might_fault() #8
  %call.i1 = call i64 @_copy_to_user(i8* %19, i8* %20, i32 %conv55) #8
  %conv.i2 = trunc i64 %call.i1 to i32
  %tobool57 = icmp ne i32 %conv.i2, 0
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %land.lhs.true
  %22 = bitcast %struct.snd_ctl_elem_id* %4 to i8*
  call void @vfree(i8* %22)
  br label %cleanup

if.end59:                                         ; preds = %land.lhs.true, %while.end47
  %23 = bitcast %struct.snd_ctl_elem_id* %4 to i8*
  call void @vfree(i8* %23)
  br label %if.end64

if.else:                                          ; preds = %if.end4
  %controls_rwsem60 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @down_read(%struct.rw_semaphore* %controls_rwsem60)
  %controls_count61 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  %24 = load i32, i32* %controls_count61, align 8, !tbaa !145
  %count62 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 3
  store i32 %24, i32* %count62, align 4, !tbaa !212
  %controls_rwsem63 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem63)
  br label %if.end64

if.end64:                                         ; preds = %if.else, %if.end59
  %25 = bitcast %struct.snd_ctl_elem_list* %_list to i8*
  %26 = bitcast %struct.snd_ctl_elem_list* %list to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %25, i8* %26, i32 80) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool66 = icmp ne i32 %conv.i, 0
  %. = select i1 %tobool66, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end64, %if.then58, %if.then6, %if.end, %entry
  %retval.0 = phi i32 [ -14, %if.then58 ], [ -14, %entry ], [ -12, %if.end ], [ -12, %if.then6 ], [ %., %if.end64 ]
  ret i32 %retval.0
}

declare i8* @vmalloc(i64) #1

declare void @vfree(i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_card_info(%struct.snd_card* %card, i8* %arg) #0 {
entry:
  %call = call i8* @kzalloc.107(i64 376, i32 208)
  %0 = bitcast i8* %call to %struct.snd_ctl_card_info*
  %tobool = icmp ne %struct.snd_ctl_card_info* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  call void @down_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number, align 8, !tbaa !9
  %card1 = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 0
  store i32 %1, i32* %card1, align 4, !tbaa !215
  %id = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 2
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %id2 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay3 = getelementptr inbounds [16 x i8], [16 x i8]* %id2, i32 0, i32 0
  %call4 = call i64 @strlcpy(i8* %arraydecay, i8* %arraydecay3, i64 16)
  %driver = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 3
  %arraydecay5 = getelementptr inbounds [16 x i8], [16 x i8]* %driver, i32 0, i32 0
  %driver6 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [16 x i8], [16 x i8]* %driver6, i32 0, i32 0
  %call8 = call i64 @strlcpy(i8* %arraydecay5, i8* %arraydecay7, i64 16)
  %name = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 4
  %arraydecay9 = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 3
  %arraydecay10 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  %call11 = call i64 @strlcpy(i8* %arraydecay9, i8* %arraydecay10, i64 32)
  %longname = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 5
  %arraydecay12 = getelementptr inbounds [80 x i8], [80 x i8]* %longname, i32 0, i32 0
  %longname13 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 4
  %arraydecay14 = getelementptr inbounds [80 x i8], [80 x i8]* %longname13, i32 0, i32 0
  %call15 = call i64 @strlcpy(i8* %arraydecay12, i8* %arraydecay14, i64 80)
  %mixername = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 7
  %arraydecay16 = getelementptr inbounds [80 x i8], [80 x i8]* %mixername, i32 0, i32 0
  %mixername17 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 5
  %arraydecay18 = getelementptr inbounds [80 x i8], [80 x i8]* %mixername17, i32 0, i32 0
  %call19 = call i64 @strlcpy(i8* %arraydecay16, i8* %arraydecay18, i64 80)
  %components = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 8
  %arraydecay20 = getelementptr inbounds [128 x i8], [128 x i8]* %components, i32 0, i32 0
  %components21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 6
  %arraydecay22 = getelementptr inbounds [128 x i8], [128 x i8]* %components21, i32 0, i32 0
  %call23 = call i64 @strlcpy(i8* %arraydecay20, i8* %arraydecay22, i64 128)
  call void @up_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %2 = bitcast %struct.snd_ctl_card_info* %0 to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %arg, i8* %2, i32 376) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool25 = icmp ne i32 %conv.i, 0
  %3 = bitcast %struct.snd_ctl_card_info* %0 to i8*
  call void @kfree(i8* %3)
  %. = select i1 %tobool25, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_info_user(%struct.snd_ctl_file* %ctl, %struct.snd_ctl_elem_info* %_info) #0 {
entry:
  %info = alloca %struct.snd_ctl_elem_info, align 8
  %0 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  %1 = bitcast %struct.snd_ctl_elem_info* %_info to i8*
  %call = call i64 @copy_from_user.126(i8* %0, i8* %1, i64 272)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %card = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %2 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !166
  call void @snd_power_lock.132(%struct.snd_card* %2)
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %3 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !166
  %call2 = call i32 @snd_power_wait(%struct.snd_card* %3, i32 0)
  %cmp = icmp sge i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call i32 @snd_ctl_elem_info(%struct.snd_ctl_file* %ctl, %struct.snd_ctl_elem_info* %info)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %result.0 = phi i32 [ %call4, %if.then3 ], [ %call2, %if.end ]
  %card6 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %4 = load %struct.snd_card*, %struct.snd_card** %card6, align 8, !tbaa !166
  call void @snd_power_unlock.133(%struct.snd_card* %4)
  %cmp7 = icmp sge i32 %result.0, 0
  br i1 %cmp7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end5
  %5 = bitcast %struct.snd_ctl_elem_info* %_info to i8*
  %6 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %5, i8* %6, i32 272) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool10 = icmp ne i32 %conv.i, 0
  br i1 %tobool10, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.then8, %if.end5
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %if.then8, %entry
  %retval.0 = phi i32 [ %result.0, %if.end13 ], [ -14, %entry ], [ -14, %if.then8 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_read_user(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %_control) #0 {
entry:
  %0 = bitcast %struct.snd_ctl_elem_value* %_control to i8*
  %call = call i8* @memdup_user(i8* %0, i64 1224)
  %1 = bitcast i8* %call to %struct.snd_ctl_elem_value*
  %2 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  %call1 = call i64 @IS_ERR.127(i8* %2)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  %call2 = call i64 @PTR_ERR.128(i8* %3)
  %conv = trunc i64 %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @snd_power_lock.132(%struct.snd_card* %card)
  %call3 = call i32 @snd_power_wait(%struct.snd_card* %card, i32 0)
  %cmp = icmp sge i32 %call3, 0
  br i1 %cmp, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 @snd_ctl_elem_read(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %1)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %result.0 = phi i32 [ %call6, %if.then5 ], [ %call3, %if.end ]
  call void @snd_power_unlock.133(%struct.snd_card* %card)
  %cmp8 = icmp sge i32 %result.0, 0
  br i1 %cmp8, label %if.then10, label %if.end15

if.then10:                                        ; preds = %if.end7
  %4 = bitcast %struct.snd_ctl_elem_value* %_control to i8*
  %5 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %4, i8* %5, i32 1224) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool12 = icmp ne i32 %conv.i, 0
  %.result.0 = select i1 %tobool12, i32 -14, i32 %result.0
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %if.end7
  %result.2 = phi i32 [ %.result.0, %if.then10 ], [ %result.0, %if.end7 ]
  %6 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %result.2, %if.end15 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_write_user(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value* %_control) #0 {
entry:
  %0 = bitcast %struct.snd_ctl_elem_value* %_control to i8*
  %call = call i8* @memdup_user(i8* %0, i64 1224)
  %1 = bitcast i8* %call to %struct.snd_ctl_elem_value*
  %2 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  %call1 = call i64 @IS_ERR.127(i8* %2)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  %call2 = call i64 @PTR_ERR.128(i8* %3)
  %conv = trunc i64 %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  %card3 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %4 = load %struct.snd_card*, %struct.snd_card** %card3, align 8, !tbaa !166
  call void @snd_power_lock.132(%struct.snd_card* %4)
  %call4 = call i32 @snd_power_wait(%struct.snd_card* %4, i32 0)
  %cmp = icmp sge i32 %call4, 0
  br i1 %cmp, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %call7 = call i32 @snd_ctl_elem_write(%struct.snd_card* %4, %struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value* %1)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %result.0 = phi i32 [ %call7, %if.then6 ], [ %call4, %if.end ]
  call void @snd_power_unlock.133(%struct.snd_card* %4)
  %cmp9 = icmp sge i32 %result.0, 0
  br i1 %cmp9, label %if.then11, label %if.end16

if.then11:                                        ; preds = %if.end8
  %5 = bitcast %struct.snd_ctl_elem_value* %_control to i8*
  %6 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %5, i8* %6, i32 1224) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool13 = icmp ne i32 %conv.i, 0
  %.result.0 = select i1 %tobool13, i32 -14, i32 %result.0
  br label %if.end16

if.end16:                                         ; preds = %if.then11, %if.end8
  %result.2 = phi i32 [ %.result.0, %if.then11 ], [ %result.0, %if.end8 ]
  %7 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  call void @kfree(i8* %7)
  br label %cleanup

cleanup:                                          ; preds = %if.end16, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %result.2, %if.end16 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_lock(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %_id) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !166
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %2 = bitcast %struct.snd_ctl_elem_id* %_id to i8*
  %call = call i64 @copy_from_user.126(i8* %1, i8* %2, i64 64)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call2 = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %0, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call2, null
  br i1 %cmp, label %if.end11, label %if.else

if.else:                                          ; preds = %if.end
  %vd4 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call2, i32 0, i32 10
  %call5 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call2, %struct.snd_ctl_elem_id* %id)
  %idxprom = zext i32 %call5 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd4, i64 0, i64 %idxprom
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %3 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !177
  %cmp6 = icmp ne %struct.snd_ctl_file* %3, null
  br i1 %cmp6, label %if.end11, label %if.else8

if.else8:                                         ; preds = %if.else
  %owner9 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  store %struct.snd_ctl_file* %file, %struct.snd_ctl_file** %owner9, align 8, !tbaa !177
  br label %if.end11

if.end11:                                         ; preds = %if.else8, %if.else, %if.end
  %result.1 = phi i32 [ -2, %if.end ], [ 0, %if.else8 ], [ -16, %if.else ]
  %controls_rwsem12 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem12)
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %entry
  %retval.0 = phi i32 [ %result.1, %if.end11 ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_unlock(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %_id) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !166
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %2 = bitcast %struct.snd_ctl_elem_id* %_id to i8*
  %call = call i64 @copy_from_user.126(i8* %1, i8* %2, i64 64)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call2 = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %0, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call2, null
  br i1 %cmp, label %if.end16, label %if.else

if.else:                                          ; preds = %if.end
  %vd4 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call2, i32 0, i32 10
  %call5 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call2, %struct.snd_ctl_elem_id* %id)
  %idxprom = zext i32 %call5 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd4, i64 0, i64 %idxprom
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %3 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !177
  %cmp6 = icmp eq %struct.snd_ctl_file* %3, null
  br i1 %cmp6, label %if.end16, label %if.else8

if.else8:                                         ; preds = %if.else
  %owner9 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %4 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner9, align 8, !tbaa !177
  %cmp10 = icmp ne %struct.snd_ctl_file* %4, %file
  br i1 %cmp10, label %if.end16, label %if.else12

if.else12:                                        ; preds = %if.else8
  %owner13 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  store %struct.snd_ctl_file* null, %struct.snd_ctl_file** %owner13, align 8, !tbaa !177
  br label %if.end16

if.end16:                                         ; preds = %if.else12, %if.else8, %if.else, %if.end
  %result.2 = phi i32 [ -2, %if.end ], [ -22, %if.else ], [ 0, %if.else12 ], [ -1, %if.else8 ]
  %controls_rwsem17 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem17)
  br label %cleanup

cleanup:                                          ; preds = %if.end16, %entry
  %retval.0 = phi i32 [ %result.2, %if.end16 ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_add_user(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_info* %_info, i32 %replace) #0 {
entry:
  %info = alloca %struct.snd_ctl_elem_info, align 8
  %0 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  %1 = bitcast %struct.snd_ctl_elem_info* %_info to i8*
  %call = call i64 @copy_from_user.126(i8* %0, i8* %1, i64 272)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @snd_ctl_elem_add(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_info* %info, i32 %replace)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_remove(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %_id) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %0 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %1 = bitcast %struct.snd_ctl_elem_id* %_id to i8*
  %call = call i64 @copy_from_user.126(i8* %0, i8* %1, i64 64)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @snd_ctl_remove_user_ctl(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %id)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_subscribe_events(%struct.snd_ctl_file* %file, i32* %ptr) #0 {
entry:
  call void @might_fault()
  %0 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %ptr, i64 4) #8, !srcloc !217
  %asmresult = extractvalue { i32*, i64 } %0, 0
  %asmresult1 = extractvalue { i32*, i64 } %0, 1
  %1 = ptrtoint i32* %asmresult to i64
  %2 = trunc i64 %1 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp = icmp slt i32 %conv, 0
  br i1 %cmp, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.end
  %subscribed = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 8
  %3 = load i32, i32* %subscribed, align 8, !tbaa !140
  call void @might_fault()
  %4 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %3, i32* %ptr) #8, !srcloc !218
  %tobool5 = icmp ne i32 %4, 0
  %. = select i1 %tobool5, i32 -14, i32 0
  br label %cleanup

if.end8:                                          ; preds = %if.end
  %tobool9 = icmp ne i32 %conv, 0
  %subscribed11 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 8
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end8
  store i32 1, i32* %subscribed11, align 8, !tbaa !140
  br label %cleanup

if.else:                                          ; preds = %if.end8
  %5 = load i32, i32* %subscribed11, align 8, !tbaa !140
  %tobool13 = icmp ne i32 %5, 0
  br i1 %tobool13, label %if.then14, label %cleanup

if.then14:                                        ; preds = %if.else
  call void @snd_ctl_empty_read_queue(%struct.snd_ctl_file* %file)
  %subscribed15 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 8
  store i32 0, i32* %subscribed15, align 8, !tbaa !140
  br label %cleanup

cleanup:                                          ; preds = %if.then14, %if.else, %if.then10, %if.then3, %entry
  %retval.0 = phi i32 [ 0, %if.then10 ], [ -14, %entry ], [ %., %if.then3 ], [ 0, %if.else ], [ 0, %if.then14 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_tlv_ioctl(%struct.snd_ctl_file* %file, %struct.snd_ctl_tlv* %_tlv, i32 %op_flag) #0 {
entry:
  %tlv = alloca %struct.snd_ctl_tlv, align 4
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !166
  %1 = bitcast %struct.snd_ctl_tlv* %tlv to i8*
  %2 = bitcast %struct.snd_ctl_tlv* %_tlv to i8*
  %call = call i64 @copy_from_user.126(i8* %1, i8* %2, i64 8)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %length = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 1
  %3 = load i32, i32* %length, align 4, !tbaa !219
  %conv = zext i32 %3 to i64
  %cmp = icmp ult i64 %conv, 8
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %numid = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 0
  %4 = load i32, i32* %numid, align 4, !tbaa !221
  %call5 = call %struct.snd_kcontrol* @snd_ctl_find_numid(%struct.snd_card* %0, i32 %4)
  %cmp6 = icmp eq %struct.snd_kcontrol* %call5, null
  br i1 %cmp6, label %__kctl_end, label %if.end9

if.end9:                                          ; preds = %if.end4
  %tlv10 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call5, i32 0, i32 6
  %p = bitcast %union.anon.58* %tlv10 to i32**
  %5 = load i32*, i32** %p, align 8, !tbaa !29
  %cmp11 = icmp eq i32* %5, null
  br i1 %cmp11, label %__kctl_end, label %if.end14

if.end14:                                         ; preds = %if.end9
  %vd15 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call5, i32 0, i32 10
  %numid16 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 0
  %6 = load i32, i32* %numid16, align 4, !tbaa !221
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call5, i32 0, i32 1
  %numid17 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %7 = load i32, i32* %numid17, align 8, !tbaa !134
  %sub = sub i32 %6, %7
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd15, i64 0, i64 %idxprom
  %cmp18 = icmp eq i32 %op_flag, 0
  br i1 %cmp18, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end14
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %8 = load i32, i32* %access, align 8, !tbaa !137
  %and = and i32 %8, 16
  %cmp20 = icmp eq i32 %and, 0
  br i1 %cmp20, label %__kctl_end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end14
  %cmp22 = icmp sgt i32 %op_flag, 0
  br i1 %cmp22, label %land.lhs.true24, label %lor.lhs.false29

land.lhs.true24:                                  ; preds = %lor.lhs.false
  %access25 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %9 = load i32, i32* %access25, align 8, !tbaa !137
  %and26 = and i32 %9, 32
  %cmp27 = icmp eq i32 %and26, 0
  br i1 %cmp27, label %__kctl_end, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %land.lhs.true24, %lor.lhs.false
  %cmp30 = icmp slt i32 %op_flag, 0
  br i1 %cmp30, label %land.lhs.true32, label %if.end38

land.lhs.true32:                                  ; preds = %lor.lhs.false29
  %access33 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %10 = load i32, i32* %access33, align 8, !tbaa !137
  %and34 = and i32 %10, 64
  %cmp35 = icmp eq i32 %and34, 0
  br i1 %cmp35, label %__kctl_end, label %if.end38

if.end38:                                         ; preds = %land.lhs.true32, %lor.lhs.false29
  %access39 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %11 = load i32, i32* %access39, align 8, !tbaa !137
  %and40 = and i32 %11, 268435456
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.end38
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %12 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !177
  %cmp43 = icmp ne %struct.snd_ctl_file* %12, null
  br i1 %cmp43, label %land.lhs.true45, label %if.end50

land.lhs.true45:                                  ; preds = %if.then42
  %owner46 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %13 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner46, align 8, !tbaa !177
  %cmp47 = icmp ne %struct.snd_ctl_file* %13, %file
  br i1 %cmp47, label %__kctl_end, label %if.end50

if.end50:                                         ; preds = %land.lhs.true45, %if.then42
  %tlv51 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call5, i32 0, i32 6
  %c = bitcast %union.anon.58* %tlv51 to i32 (%struct.snd_kcontrol*, i32, i32, i32*)**
  %14 = load i32 (%struct.snd_kcontrol*, i32, i32, i32*)*, i32 (%struct.snd_kcontrol*, i32, i32, i32*)** %c, align 8, !tbaa !29
  %length52 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 1
  %15 = load i32, i32* %length52, align 4, !tbaa !219
  %tlv53 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %_tlv, i32 0, i32 2
  %arraydecay = getelementptr inbounds [0 x i32], [0 x i32]* %tlv53, i32 0, i32 0
  %call54 = call i32 %14(%struct.snd_kcontrol* %call5, i32 %op_flag, i32 %15, i32* %arraydecay)
  %cmp55 = icmp sgt i32 %call54, 0
  br i1 %cmp55, label %if.then57, label %__kctl_end

if.then57:                                        ; preds = %if.end50
  %controls_rwsem58 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem58)
  %id59 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call5, i32 0, i32 1
  call void @snd_ctl_notify(%struct.snd_card* %0, i32 8, %struct.snd_ctl_elem_id* %id59)
  br label %cleanup

if.else:                                          ; preds = %if.end38
  %tobool61 = icmp ne i32 %op_flag, 0
  br i1 %tobool61, label %__kctl_end, label %if.end63

if.end63:                                         ; preds = %if.else
  %tlv64 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call5, i32 0, i32 6
  %p65 = bitcast %union.anon.58* %tlv64 to i32**
  %16 = load i32*, i32** %p65, align 8, !tbaa !29
  %arrayidx66 = getelementptr inbounds i32, i32* %16, i64 1
  %17 = load i32, i32* %arrayidx66, align 4, !tbaa !25
  %conv67 = zext i32 %17 to i64
  %add = add i64 %conv67, 8
  %conv68 = trunc i64 %add to i32
  %length69 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 1
  %18 = load i32, i32* %length69, align 4, !tbaa !219
  %cmp70 = icmp ult i32 %18, %conv68
  br i1 %cmp70, label %__kctl_end, label %if.end73

if.end73:                                         ; preds = %if.end63
  %tlv74 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %_tlv, i32 0, i32 2
  %arraydecay75 = getelementptr inbounds [0 x i32], [0 x i32]* %tlv74, i32 0, i32 0
  %19 = bitcast i32* %arraydecay75 to i8*
  %tlv76 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call5, i32 0, i32 6
  %p77 = bitcast %union.anon.58* %tlv76 to i32**
  %20 = load i32*, i32** %p77, align 8, !tbaa !29
  %21 = bitcast i32* %20 to i8*
  call void @might_fault() #8
  %call.i = call i64 @_copy_to_user(i8* %19, i8* %21, i32 %conv68) #8
  %conv.i = trunc i64 %call.i to i32
  %tobool79 = icmp ne i32 %conv.i, 0
  %. = select i1 %tobool79, i32 -14, i32 0
  br label %__kctl_end

__kctl_end:                                       ; preds = %if.end73, %if.end63, %if.else, %if.end50, %land.lhs.true45, %land.lhs.true32, %land.lhs.true24, %land.lhs.true, %if.end9, %if.end4
  %err.2 = phi i32 [ -2, %if.end4 ], [ -6, %if.end9 ], [ -6, %land.lhs.true32 ], [ -6, %land.lhs.true24 ], [ -6, %land.lhs.true ], [ -1, %land.lhs.true45 ], [ -6, %if.else ], [ -12, %if.end63 ], [ %., %if.end73 ], [ %call54, %if.end50 ]
  %controls_rwsem83 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @up_read(%struct.rw_semaphore* %controls_rwsem83)
  br label %cleanup

cleanup:                                          ; preds = %__kctl_end, %if.then57, %if.end, %entry
  %retval.0 = phi i32 [ %err.2, %__kctl_end ], [ 0, %if.then57 ], [ -14, %entry ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_remove_user_ctl(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %id) #0 {
entry:
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !166
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %0, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %error, label %if.end

if.end:                                           ; preds = %entry
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i64 0, i64 0
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %1 = load i32, i32* %access, align 8, !tbaa !137
  %and = and i32 %1, 536870912
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end3, label %error

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %idx.0 = phi i32 [ 0, %if.end3 ], [ %inc, %for.inc ]
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 2
  %2 = load i32, i32* %count, align 8, !tbaa !133
  %cmp4 = icmp ult i32 %idx.0, %2
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %vd5 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx6 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd5, i64 0, i64 %idxprom
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx6, i32 0, i32 0
  %3 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !177
  %cmp7 = icmp ne %struct.snd_ctl_file* %3, null
  br i1 %cmp7, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %vd8 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom9 = sext i32 %idx.0 to i64
  %arrayidx10 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd8, i64 0, i64 %idxprom9
  %owner11 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx10, i32 0, i32 0
  %4 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner11, align 8, !tbaa !177
  %cmp12 = icmp ne %struct.snd_ctl_file* %4, %file
  br i1 %cmp12, label %error, label %for.inc

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call15 = call i32 @snd_ctl_remove(%struct.snd_card* %0, %struct.snd_kcontrol* %call)
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %error, label %if.end18

if.end18:                                         ; preds = %for.end
  %user_ctl_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 15
  %5 = load i32, i32* %user_ctl_count, align 4, !tbaa !194
  %dec = add nsw i32 %5, -1
  store i32 %dec, i32* %user_ctl_count, align 4, !tbaa !194
  br label %error

error:                                            ; preds = %if.end18, %for.end, %land.lhs.true, %if.end, %entry
  %ret.0 = phi i32 [ %call15, %if.end18 ], [ -2, %entry ], [ -22, %if.end ], [ -16, %land.lhs.true ], [ %call15, %for.end ]
  %controls_rwsem19 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 12
  call void @up_write(%struct.rw_semaphore* %controls_rwsem19)
  ret i32 %ret.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #3 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !222
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !222
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_irq(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_waitqueue_entry.136(%struct.__wait_queue* %q, %struct.task_struct* %p) #3 {
entry:
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !55
  %0 = bitcast %struct.task_struct* %p to i8*
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 1
  store i8* %0, i8** %private, align 8, !tbaa !57
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !58
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irq(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #3 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #3 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !224
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #3 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #3 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #8, !srcloc !250
  ret i32 %0
}

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev* %pci, %struct.snd_pci_quirk* %list) #0 {
entry:
  %subsystem_vendor = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 9
  %0 = load i16, i16* %subsystem_vendor, align 8, !tbaa !251
  %subsystem_device = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 10
  %1 = load i16, i16* %subsystem_device, align 2, !tbaa !266
  %call = call %struct.snd_pci_quirk* @snd_pci_quirk_lookup_id(i16 zeroext %0, i16 zeroext %1, %struct.snd_pci_quirk* %list)
  ret %struct.snd_pci_quirk* %call
}

; Function Attrs: nounwind uwtable
define %struct.snd_pci_quirk* @snd_pci_quirk_lookup_id(i16 zeroext %vendor, i16 zeroext %device, %struct.snd_pci_quirk* %list) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %q.0 = phi %struct.snd_pci_quirk* [ %list, %entry ], [ %incdec.ptr, %for.inc ]
  %subvendor = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 0, i32 0
  %0 = load i16, i16* %subvendor, align 8, !tbaa !267
  %tobool = icmp ne i16 %0, 0
  br i1 %tobool, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %subvendor1 = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 0, i32 0
  %1 = load i16, i16* %subvendor1, align 8, !tbaa !267
  %conv = zext i16 %1 to i32
  %conv2 = zext i16 %vendor to i32
  %cmp = icmp ne i32 %conv, %conv2
  br i1 %cmp, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %subdevice = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 0, i32 1
  %2 = load i16, i16* %subdevice, align 2, !tbaa !269
  %tobool4 = icmp ne i16 %2, 0
  br i1 %tobool4, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %conv5 = zext i16 %device to i32
  %subdevice_mask = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 0, i32 2
  %3 = load i16, i16* %subdevice_mask, align 4, !tbaa !270
  %conv6 = zext i16 %3 to i32
  %and = and i32 %conv5, %conv6
  %subdevice7 = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 0, i32 1
  %4 = load i16, i16* %subdevice7, align 2, !tbaa !269
  %conv8 = zext i16 %4 to i32
  %cmp9 = icmp eq i32 %and, %conv8
  br i1 %cmp9, label %cleanup, label %for.inc

for.inc:                                          ; preds = %lor.lhs.false, %for.body
  %incdec.ptr = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 1
  br label %for.cond

cleanup:                                          ; preds = %lor.lhs.false, %if.end, %for.cond
  %retval.0 = phi %struct.snd_pci_quirk* [ %q.0, %lor.lhs.false ], [ %q.0, %if.end ], [ null, %for.cond ]
  ret %struct.snd_pci_quirk* %retval.0
}

; Function Attrs: nounwind uwtable
define void @__snd_printk(i32 %level, i8* %path, i32 %line, i8* %format, ...) #0 {
entry:
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %vaf = alloca %struct.va_format, align 8
  %verbose_fmt = alloca [17 x i8], align 16
  %0 = bitcast [17 x i8]* %verbose_fmt to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__snd_printk.verbose_fmt, i32 0, i32 0), i64 17, i32 16, i1 false)
  %1 = load i32, i32* @debug, align 4, !tbaa !25
  %cmp = icmp ult i32 %1, %level
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %fmt = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 0
  store i8* %format, i8** %fmt, align 8, !tbaa !271
  %va = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 1
  store [1 x %struct.__va_list_tag]* %args, [1 x %struct.__va_list_tag]** %va, align 8, !tbaa !273
  %call = call i32 @printk_get_level(i8* %format)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %call3 = call i8* @printk_skip_level(i8* %format)
  %sub.ptr.lhs.cast = ptrtoint i8* %call3 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %format to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %arraydecay4 = getelementptr inbounds [17 x i8], [17 x i8]* %verbose_fmt, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay4, i8* %format, i64 %sub.ptr.sub, i32 1, i1 false)
  %fmt5 = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 0
  store i8* %call3, i8** %fmt5, align 8, !tbaa !271
  br label %if.end19

if.else:                                          ; preds = %if.end
  %tobool6 = icmp ne i32 %level, 0
  br i1 %tobool6, label %if.then7, label %if.end19

if.then7:                                         ; preds = %if.else
  %cmp10 = icmp uge i64 2, 64
  %arraydecay12 = getelementptr inbounds [17 x i8], [17 x i8]* %verbose_fmt, i32 0, i32 0
  br i1 %cmp10, label %if.then11, label %if.else14

if.then11:                                        ; preds = %if.then7
  %call13 = call i8* @__memcpy(i8* %arraydecay12, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.140, i32 0, i32 0), i64 2)
  br label %if.end19

if.else14:                                        ; preds = %if.then7
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay12, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.140, i32 0, i32 0), i64 2, i32 1, i1 false)
  br label %if.end19

if.end19:                                         ; preds = %if.else14, %if.then11, %if.else, %if.then2
  call void @sanity_file_name(i8* %path)
  %2 = call i32 (i8*, ...) @printk(i8* null)
  %arraydecay23 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay2324 = bitcast %struct.__va_list_tag* %arraydecay23 to i8*
  call void @llvm.va_end(i8* %arraydecay2324)
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @printk_get_level(i8* %buffer) #3 {
entry:
  %arrayidx = getelementptr inbounds i8, i8* %buffer, i64 0
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !29
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %entry
  %arrayidx2 = getelementptr inbounds i8, i8* %buffer, i64 1
  %1 = load i8, i8* %arrayidx2, align 1, !tbaa !29
  %conv3 = sext i8 %1 to i32
  %tobool = icmp ne i32 %conv3, 0
  br i1 %tobool, label %if.then, label %return

if.then:                                          ; preds = %land.lhs.true
  %arrayidx4 = getelementptr inbounds i8, i8* %buffer, i64 1
  %2 = load i8, i8* %arrayidx4, align 1, !tbaa !29
  %conv5 = sext i8 %2 to i32
  %Pivot = icmp slt i32 %conv5, 100
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then
  %SwitchLeaf2 = icmp eq i32 %conv5, 100
  br i1 %SwitchLeaf2, label %sw.bb6, label %return

LeafBlock:                                        ; preds = %if.then
  %conv5.off = add i32 %conv5, -48
  %SwitchLeaf = icmp ule i32 %conv5.off, 7
  br i1 %SwitchLeaf, label %sw.bb6, label %return

sw.bb6:                                           ; preds = %LeafBlock, %LeafBlock1
  %arrayidx7 = getelementptr inbounds i8, i8* %buffer, i64 1
  %3 = load i8, i8* %arrayidx7, align 1, !tbaa !29
  %conv8 = sext i8 %3 to i32
  br label %return

return:                                           ; preds = %sw.bb6, %LeafBlock, %LeafBlock1, %land.lhs.true, %entry
  %retval.0 = phi i32 [ %conv8, %sw.bb6 ], [ 0, %LeafBlock1 ], [ 0, %LeafBlock ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @printk_skip_level(i8* %buffer) #3 {
entry:
  %call = call i32 @printk_get_level(i8* %buffer)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %return

if.then:                                          ; preds = %entry
  %arrayidx = getelementptr inbounds i8, i8* %buffer, i64 1
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !29
  %conv = sext i8 %0 to i32
  %Pivot = icmp slt i32 %conv, 100
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then
  %SwitchLeaf2 = icmp eq i32 %conv, 100
  br i1 %SwitchLeaf2, label %sw.bb1, label %return

LeafBlock:                                        ; preds = %if.then
  %conv.off = add i32 %conv, -48
  %SwitchLeaf = icmp ule i32 %conv.off, 7
  br i1 %SwitchLeaf, label %sw.bb1, label %return

sw.bb1:                                           ; preds = %LeafBlock, %LeafBlock1
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 2
  br label %return

return:                                           ; preds = %sw.bb1, %LeafBlock, %LeafBlock1, %entry
  %retval.0 = phi i8* [ %add.ptr, %sw.bb1 ], [ %buffer, %LeafBlock1 ], [ %buffer, %LeafBlock ], [ %buffer, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @sanity_file_name(i8* %path) #0 {
entry:
  %0 = load i8, i8* %path, align 1, !tbaa !29
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 47
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %call = call i8* @strrchr(i8* %path, i32 47)
  br label %return

return:                                           ; preds = %if.then, %entry
  ret void
}

declare i8* @strrchr(i8*, i32) #1

; Function Attrs: nounwind uwtable
define void @release_and_free_resource(%struct.resource* %res) #0 {
entry:
  %tobool = icmp ne %struct.resource* %res, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @release_resource(%struct.resource* %res)
  %0 = bitcast %struct.resource* %res to i8*
  call void @kfree(i8* %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @release_resource(%struct.resource*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_device_register(%struct.snd_card* %card, i8* %device_data) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne i8* %device_data, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 162)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %list41.sink = phi %struct.list_head* [ %list41, %for.inc ], [ %devices, %if.end19 ]
  %next42 = getelementptr inbounds %struct.list_head, %struct.list_head* %list41.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next42, align 8, !tbaa !2
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr44 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr44 to %struct.snd_device*
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 0
  %devices21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  %cmp = icmp ne %struct.list_head* %list, %devices21
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %device_data23 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 4
  %4 = load i8*, i8** %device_data23, align 8, !tbaa !112
  %cmp24 = icmp ne i8* %4, %device_data
  br i1 %cmp24, label %for.inc, label %if.end27

if.end27:                                         ; preds = %for.body
  %state = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 2
  %5 = load i32, i32* %state, align 8, !tbaa !274
  %cmp28 = icmp eq i32 %5, 0
  br i1 %cmp28, label %land.lhs.true, label %if.end39

land.lhs.true:                                    ; preds = %if.end27
  %ops = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 5
  %6 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops, align 8, !tbaa !275
  %dev_register = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %6, i32 0, i32 1
  %7 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_register, align 8, !tbaa !276
  %tobool30 = icmp ne i32 (%struct.snd_device*)* %7, null
  br i1 %tobool30, label %if.then31, label %if.end39

if.then31:                                        ; preds = %land.lhs.true
  %ops32 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 5
  %8 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops32, align 8, !tbaa !275
  %dev_register33 = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %8, i32 0, i32 1
  %9 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_register33, align 8, !tbaa !276
  %call = call i32 %9(%struct.snd_device* %3)
  %cmp34 = icmp slt i32 %call, 0
  br i1 %cmp34, label %cleanup, label %if.end37

if.end37:                                         ; preds = %if.then31
  %state38 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 2
  store i32 1, i32* %state38, align 8, !tbaa !274
  br label %cleanup

if.end39:                                         ; preds = %land.lhs.true, %if.end27
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 1, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6.143, i32 0, i32 0))
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %list41 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool46 = icmp ne i32 1, 0
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %conv51 = sext i32 %lnot.ext50 to i64
  %expval52 = call i64 @llvm.expect.i64(i64 %conv51, i64 0)
  %tobool53 = icmp ne i64 %expval52, 0
  br i1 %tobool53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %for.end
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 176, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7.144, i32 0, i32 0))
  br label %if.end55

if.end55:                                         ; preds = %if.then54, %for.end
  br label %cleanup

cleanup:                                          ; preds = %if.end55, %if.end39, %if.end37, %if.then31, %if.end
  %retval.0 = phi i32 [ 0, %if.end37 ], [ -16, %if.end39 ], [ -6, %if.end55 ], [ -6, %if.end ], [ %call, %if.then31 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_device_free(%struct.snd_card* %card, i8* %device_data) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne i8* %device_data, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 83)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %list50.sink = phi %struct.list_head* [ %list50, %for.inc ], [ %devices, %if.end19 ]
  %next51 = getelementptr inbounds %struct.list_head, %struct.list_head* %list50.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next51, align 8, !tbaa !2
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr53 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr53 to %struct.snd_device*
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 0
  %devices21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  %cmp = icmp ne %struct.list_head* %list, %devices21
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %device_data23 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 4
  %4 = load i8*, i8** %device_data23, align 8, !tbaa !112
  %cmp24 = icmp ne i8* %4, %device_data
  %list50 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 0
  br i1 %cmp24, label %for.inc, label %if.end27

if.end27:                                         ; preds = %for.body
  call void @list_del(%struct.list_head* %list50)
  %state = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 2
  %5 = load i32, i32* %state, align 8, !tbaa !274
  %cmp29 = icmp eq i32 %5, 1
  br i1 %cmp29, label %land.lhs.true, label %if.end38

land.lhs.true:                                    ; preds = %if.end27
  %ops = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 5
  %6 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops, align 8, !tbaa !275
  %dev_disconnect = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %6, i32 0, i32 2
  %7 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_disconnect, align 8, !tbaa !278
  %tobool31 = icmp ne i32 (%struct.snd_device*)* %7, null
  br i1 %tobool31, label %if.then32, label %if.end38

if.then32:                                        ; preds = %land.lhs.true
  %ops33 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 5
  %8 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops33, align 8, !tbaa !275
  %dev_disconnect34 = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %8, i32 0, i32 2
  %9 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_disconnect34, align 8, !tbaa !278
  %call = call i32 %9(%struct.snd_device* %3)
  %tobool35 = icmp ne i32 %call, 0
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.then32
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.2.145, i32 0, i32 0))
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.then32, %land.lhs.true, %if.end27
  %ops39 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 5
  %10 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops39, align 8, !tbaa !275
  %dev_free = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %10, i32 0, i32 0
  %11 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_free, align 8, !tbaa !279
  %tobool40 = icmp ne i32 (%struct.snd_device*)* %11, null
  br i1 %tobool40, label %if.then41, label %if.end48

if.then41:                                        ; preds = %if.end38
  %ops42 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 5
  %12 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops42, align 8, !tbaa !275
  %dev_free43 = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %12, i32 0, i32 0
  %13 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_free43, align 8, !tbaa !279
  %call44 = call i32 %13(%struct.snd_device* %3)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %if.then41
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3.146, i32 0, i32 0))
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %if.then41, %if.end38
  %14 = bitcast %struct.snd_device* %3 to i8*
  call void @kfree(i8* %14)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = call i8* @llvm.returnaddress(i32 0)
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 1, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.4.147, i32 0, i32 0), i8* %device_data, i8* %15)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end48, %if.end
  %retval.0 = phi i32 [ 0, %if.end48 ], [ -6, %for.end ], [ -6, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind readnone
declare i8* @llvm.returnaddress(i32) #2

; Function Attrs: nounwind uwtable
define i32 @snd_device_new(%struct.snd_card* %card, i32 %type, i8* %device_data, %struct.snd_device_ops* %ops) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %tobool1 = icmp ne i8* %device_data, null
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool2 = icmp ne %struct.snd_device_ops* %ops, null
  %lnot = xor i1 %tobool2, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot3 = xor i1 %0, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool5 = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 49)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool11 = icmp ne i32 %lnot.ext, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end
  %call = call i8* @kzalloc.150(i64 48, i32 208)
  %1 = bitcast i8* %call to %struct.snd_device*
  %cmp = icmp eq %struct.snd_device* %1, null
  br i1 %cmp, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end20
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1.151, i32 0, i32 0))
  br label %cleanup

if.end23:                                         ; preds = %if.end20
  %card24 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 1
  store %struct.snd_card* %card, %struct.snd_card** %card24, align 8, !tbaa !280
  %type25 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 3
  store i32 %type, i32* %type25, align 4, !tbaa !281
  %state = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 2
  store i32 0, i32* %state, align 8, !tbaa !274
  %device_data26 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 4
  store i8* %device_data, i8** %device_data26, align 8, !tbaa !112
  %ops27 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 5
  store %struct.snd_device_ops* %ops, %struct.snd_device_ops** %ops27, align 8, !tbaa !275
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 0
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  call void @list_add.152(%struct.list_head* %list, %struct.list_head* %devices)
  br label %cleanup

cleanup:                                          ; preds = %if.end23, %if.then22, %if.end
  %retval.0 = phi i32 [ -12, %if.then22 ], [ 0, %if.end23 ], [ -6, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.150(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.152(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !66
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_device_disconnect(%struct.snd_card* %card, i8* %device_data) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne i8* %device_data, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 126)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %list40.sink = phi %struct.list_head* [ %list40, %for.inc ], [ %devices, %if.end19 ]
  %next41 = getelementptr inbounds %struct.list_head, %struct.list_head* %list40.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next41, align 8, !tbaa !2
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr43 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr43 to %struct.snd_device*
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 0
  %devices21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  %cmp = icmp ne %struct.list_head* %list, %devices21
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %device_data23 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 4
  %4 = load i8*, i8** %device_data23, align 8, !tbaa !112
  %cmp24 = icmp ne i8* %4, %device_data
  br i1 %cmp24, label %for.inc, label %if.end27

if.end27:                                         ; preds = %for.body
  %state = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 2
  %5 = load i32, i32* %state, align 8, !tbaa !274
  %cmp28 = icmp eq i32 %5, 1
  br i1 %cmp28, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %if.end27
  %ops = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 5
  %6 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops, align 8, !tbaa !275
  %dev_disconnect = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %6, i32 0, i32 2
  %7 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_disconnect, align 8, !tbaa !278
  %tobool30 = icmp ne i32 (%struct.snd_device*)* %7, null
  br i1 %tobool30, label %if.then31, label %cleanup

if.then31:                                        ; preds = %land.lhs.true
  %ops32 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 5
  %8 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops32, align 8, !tbaa !275
  %dev_disconnect33 = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %8, i32 0, i32 2
  %9 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_disconnect33, align 8, !tbaa !278
  %call = call i32 %9(%struct.snd_device* %3)
  %tobool34 = icmp ne i32 %call, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then31
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.2.145, i32 0, i32 0))
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.then31
  %state37 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 2
  store i32 2, i32* %state37, align 8, !tbaa !274
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %list40 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %3, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = call i8* @llvm.returnaddress(i32 0)
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 1, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.5.154, i32 0, i32 0), i8* %device_data, i8* %10)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end36, %land.lhs.true, %if.end27, %if.end
  %retval.0 = phi i32 [ -6, %for.end ], [ -6, %if.end ], [ 0, %if.end36 ], [ 0, %land.lhs.true ], [ 0, %if.end27 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_device_register_all(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 191)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end18
  %list35.sink = phi %struct.list_head* [ %list35, %for.inc ], [ %devices, %if.end18 ]
  %next36 = getelementptr inbounds %struct.list_head, %struct.list_head* %list35.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next36, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr38 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr38 to %struct.snd_device*
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  %devices20 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  %cmp = icmp ne %struct.list_head* %list, %devices20
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %state = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 2
  %3 = load i32, i32* %state, align 8, !tbaa !274
  %cmp22 = icmp eq i32 %3, 0
  br i1 %cmp22, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %ops = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 5
  %4 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops, align 8, !tbaa !275
  %dev_register = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %4, i32 0, i32 1
  %5 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_register, align 8, !tbaa !276
  %tobool24 = icmp ne i32 (%struct.snd_device*)* %5, null
  br i1 %tobool24, label %if.then25, label %for.inc

if.then25:                                        ; preds = %land.lhs.true
  %ops26 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 5
  %6 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops26, align 8, !tbaa !275
  %dev_register27 = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %6, i32 0, i32 1
  %7 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_register27, align 8, !tbaa !276
  %call = call i32 %7(%struct.snd_device* %2)
  %cmp28 = icmp slt i32 %call, 0
  br i1 %cmp28, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.then25
  %state32 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 2
  store i32 1, i32* %state32, align 8, !tbaa !274
  br label %for.inc

for.inc:                                          ; preds = %if.end31, %land.lhs.true, %for.body
  %list35 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %if.then25, %for.cond, %if.end
  %retval.0 = phi i32 [ -6, %if.end ], [ %call, %if.then25 ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_device_disconnect_all(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 212)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end18
  %list27.sink = phi %struct.list_head* [ %list27, %for.body ], [ %devices, %if.end18 ]
  %err.0 = phi i32 [ 0, %if.end18 ], [ %.err.0, %for.body ]
  %next28 = getelementptr inbounds %struct.list_head, %struct.list_head* %list27.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next28, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr30 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr30 to %struct.snd_device*
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  %devices20 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  %cmp = icmp ne %struct.list_head* %list, %devices20
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 4
  %3 = load i8*, i8** %device_data, align 8, !tbaa !112
  %call = call i32 @snd_device_disconnect(%struct.snd_card* %card, i8* %3)
  %cmp22 = icmp slt i32 %call, 0
  %.err.0 = select i1 %cmp22, i32 -6, i32 %err.0
  %list27 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.end
  %retval.0 = phi i32 [ -6, %if.end ], [ %err.0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_device_free_all(%struct.snd_card* %card, i32 %cmd) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.142, i32 0, i32 0), i32 231)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %mul = mul i32 %cmd, 4096
  %add = add i32 %mul, 4096
  %sub = sub i32 %add, 1
  br label %__again

__again:                                          ; preds = %if.end31, %if.end18
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %__again
  %list34.sink = phi %struct.list_head* [ %list34, %for.inc ], [ %devices, %__again ]
  %next35 = getelementptr inbounds %struct.list_head, %struct.list_head* %list34.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next35, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr37 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr37 to %struct.snd_device*
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  %devices20 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  %cmp = icmp ne %struct.list_head* %list, %devices20
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %type22 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 3
  %3 = load i32, i32* %type22, align 4, !tbaa !281
  %cmp23 = icmp uge i32 %3, %mul
  %cmp25 = icmp ule i32 %3, %sub
  %or.cond = and i1 %cmp23, %cmp25
  br i1 %or.cond, label %if.then27, label %for.inc

if.then27:                                        ; preds = %for.body
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 4
  %4 = load i8*, i8** %device_data, align 8, !tbaa !112
  %call = call i32 @snd_device_free(%struct.snd_card* %card, i8* %4)
  %cmp28 = icmp slt i32 %call, 0
  br i1 %cmp28, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.then27
  br label %__again

for.inc:                                          ; preds = %for.body
  %list34 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %if.then27, %for.cond, %if.end
  %retval.0 = phi i32 [ -6, %if.end ], [ %call, %if.then27 ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_dma_pointer(i64 %dma, i32 %size) #0 {
entry:
  %call = call i64 @claim_dma_lock()
  %conv = trunc i64 %dma to i32
  call void @clear_dma_ff(i32 %conv)
  %0 = load i32, i32* @isa_dma_bridge_buggy, align 4, !tbaa !25
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %conv1 = trunc i64 %dma to i32
  call void @disable_dma(i32 %conv1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %conv2 = trunc i64 %dma to i32
  %call3 = call i32 @get_dma_residue(i32 %conv2)
  %conv4 = trunc i64 %dma to i32
  %call5 = call i32 @get_dma_residue(i32 %conv4)
  %1 = load i32, i32* @isa_dma_bridge_buggy, align 4, !tbaa !25
  %tobool6 = icmp ne i32 %1, 0
  br i1 %tobool6, label %if.end9, label %if.then7

if.then7:                                         ; preds = %if.end
  %conv8 = trunc i64 %dma to i32
  call void @enable_dma(i32 %conv8)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  call void @release_dma_lock(i64 %call)
  %cmp = icmp ult i32 %call3, %call5
  %lnot = xor i1 %cmp, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv12 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  %call5.call3 = select i1 %tobool13, i32 %call5, i32 %call3
  %cmp16 = icmp ugt i32 %call5.call3, %size
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end9
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.162, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.1.163, i32 0, i32 0), i32 %call5.call3, i64 %dma, i32 %size)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end9
  %cmp20 = icmp uge i32 %call5.call3, %size
  %cmp22 = icmp eq i32 %call5.call3, 0
  %or.cond = or i1 %cmp20, %cmp22
  %sub = sub i32 %size, %call5.call3
  %retval.0 = select i1 %or.cond, i32 0, i32 %sub
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @claim_dma_lock() #3 {
entry:
  %call = call %struct.raw_spinlock* @spinlock_check.165(%struct.spinlock* @dma_spin_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  ret i64 %call2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @clear_dma_ff(i32 %dmanr) #3 {
entry:
  %cmp = icmp ule i32 %dmanr, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @outb(i8 zeroext 0, i32 12)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @outb(i8 zeroext 0, i32 216)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @disable_dma(i32 %dmanr) #3 {
entry:
  %cmp = icmp ule i32 %dmanr, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %or = or i32 %dmanr, 4
  %conv = trunc i32 %or to i8
  call void @outb(i8 zeroext %conv, i32 10)
  br label %if.end

if.else:                                          ; preds = %entry
  %and = and i32 %dmanr, 3
  %or1 = or i32 %and, 4
  %conv2 = trunc i32 %or1 to i8
  call void @outb(i8 zeroext %conv2, i32 212)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @get_dma_residue(i32 %dmanr) #3 {
entry:
  %cmp = icmp ule i32 %dmanr, 3
  %and = and i32 %dmanr, 3
  %.sink2 = select i1 %cmp, i32 1, i32 2
  %.sink = select i1 %cmp, i32 0, i32 192
  %shl3 = shl i32 %and, %.sink2
  %add4 = add i32 %shl3, %.sink2
  %add5 = add i32 %add4, %.sink
  %call = call zeroext i8 @inb(i32 %add5)
  %conv = zext i8 %call to i32
  %add6 = add nsw i32 1, %conv
  %conv7 = trunc i32 %add6 to i16
  %call8 = call zeroext i8 @inb(i32 %add5)
  %conv9 = zext i8 %call8 to i32
  %shl10 = shl i32 %conv9, 8
  %conv11 = zext i16 %conv7 to i32
  %add12 = add nsw i32 %conv11, %shl10
  %conv13 = trunc i32 %add12 to i16
  %cmp14 = icmp ule i32 %dmanr, 3
  %conv17 = zext i16 %conv13 to i32
  %shl20 = shl i32 %conv17, 1
  %cond22 = select i1 %cmp14, i32 %conv17, i32 %shl20
  ret i32 %cond22
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @enable_dma(i32 %dmanr) #3 {
entry:
  %cmp = icmp ule i32 %dmanr, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv = trunc i32 %dmanr to i8
  call void @outb(i8 zeroext %conv, i32 10)
  br label %if.end

if.else:                                          ; preds = %entry
  %and = and i32 %dmanr, 3
  %conv1 = trunc i32 %and to i8
  call void @outb(i8 zeroext %conv1, i32 212)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @release_dma_lock(i64 %flags) #3 {
entry:
  call void @spin_unlock_irqrestore.164(%struct.spinlock* @dma_spin_lock, i64 %flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore.164(%struct.spinlock* %lock, i64 %flags) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #3 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #8, !srcloc !282
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #3 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #8, !srcloc !283
  ret i8 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.165(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: nounwind uwtable
define void @snd_dma_disable(i64 %dma) #0 {
entry:
  %call = call i64 @claim_dma_lock()
  %conv = trunc i64 %dma to i32
  call void @clear_dma_ff(i32 %conv)
  %conv1 = trunc i64 %dma to i32
  call void @disable_dma(i32 %conv1)
  call void @release_dma_lock(i64 %call)
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_dma_program(i64 %dma, i64 %addr, i32 %size, i16 zeroext %mode) #0 {
entry:
  %call = call i64 @claim_dma_lock()
  %conv = trunc i64 %dma to i32
  call void @disable_dma(i32 %conv)
  %conv1 = trunc i64 %dma to i32
  call void @clear_dma_ff(i32 %conv1)
  %conv2 = trunc i64 %dma to i32
  %conv3 = trunc i16 %mode to i8
  call void @set_dma_mode(i32 %conv2, i8 signext %conv3)
  %conv4 = trunc i64 %dma to i32
  %conv5 = trunc i64 %addr to i32
  call void @set_dma_addr(i32 %conv4, i32 %conv5)
  %conv6 = trunc i64 %dma to i32
  call void @set_dma_count(i32 %conv6, i32 %size)
  %conv7 = zext i16 %mode to i32
  %and = and i32 %conv7, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %conv8 = trunc i64 %dma to i32
  call void @enable_dma(i32 %conv8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @release_dma_lock(i64 %call)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @set_dma_mode(i32 %dmanr, i8 signext %mode) #3 {
entry:
  %cmp = icmp ule i32 %dmanr, 3
  %conv = sext i8 %mode to i32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %or = or i32 %conv, %dmanr
  %conv1 = trunc i32 %or to i8
  call void @outb(i8 zeroext %conv1, i32 11)
  br label %if.end

if.else:                                          ; preds = %entry
  %and = and i32 %dmanr, 3
  %or3 = or i32 %conv, %and
  %conv4 = trunc i32 %or3 to i8
  call void @outb(i8 zeroext %conv4, i32 214)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @set_dma_addr(i32 %dmanr, i32 %a) #3 {
entry:
  %shr = lshr i32 %a, 16
  %conv = trunc i32 %shr to i8
  call void @set_dma_page(i32 %dmanr, i8 signext %conv)
  %cmp = icmp ule i32 %dmanr, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %and = and i32 %a, 255
  %conv2 = trunc i32 %and to i8
  %and3 = and i32 %dmanr, 3
  %shl = shl i32 %and3, 1
  %add = add i32 %shl, 0
  call void @outb(i8 zeroext %conv2, i32 %add)
  %shr4 = lshr i32 %a, 8
  %and5 = and i32 %shr4, 255
  %conv6 = trunc i32 %and5 to i8
  %and7 = and i32 %dmanr, 3
  %shl8 = shl i32 %and7, 1
  %add9 = add i32 %shl8, 0
  call void @outb(i8 zeroext %conv6, i32 %add9)
  br label %if.end

if.else:                                          ; preds = %entry
  %shr10 = lshr i32 %a, 1
  %and11 = and i32 %shr10, 255
  %conv12 = trunc i32 %and11 to i8
  %and13 = and i32 %dmanr, 3
  %shl14 = shl i32 %and13, 2
  %add15 = add i32 %shl14, 192
  call void @outb(i8 zeroext %conv12, i32 %add15)
  %shr16 = lshr i32 %a, 9
  %and17 = and i32 %shr16, 255
  %conv18 = trunc i32 %and17 to i8
  %and19 = and i32 %dmanr, 3
  %shl20 = shl i32 %and19, 2
  %add21 = add i32 %shl20, 192
  call void @outb(i8 zeroext %conv18, i32 %add21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @set_dma_count(i32 %dmanr, i32 %count) #3 {
entry:
  %dec = add i32 %count, -1
  %cmp = icmp ule i32 %dmanr, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %and = and i32 %dec, 255
  %conv = trunc i32 %and to i8
  %and1 = and i32 %dmanr, 3
  %shl = shl i32 %and1, 1
  %add = add i32 %shl, 1
  %add2 = add i32 %add, 0
  call void @outb(i8 zeroext %conv, i32 %add2)
  %shr = lshr i32 %dec, 8
  %and3 = and i32 %shr, 255
  %conv4 = trunc i32 %and3 to i8
  %and5 = and i32 %dmanr, 3
  %shl6 = shl i32 %and5, 1
  %add7 = add i32 %shl6, 1
  %add8 = add i32 %add7, 0
  call void @outb(i8 zeroext %conv4, i32 %add8)
  br label %if.end

if.else:                                          ; preds = %entry
  %shr9 = lshr i32 %dec, 1
  %and10 = and i32 %shr9, 255
  %conv11 = trunc i32 %and10 to i8
  %and12 = and i32 %dmanr, 3
  %shl13 = shl i32 %and12, 2
  %add14 = add i32 %shl13, 2
  %add15 = add i32 %add14, 192
  call void @outb(i8 zeroext %conv11, i32 %add15)
  %shr16 = lshr i32 %dec, 9
  %and17 = and i32 %shr16, 255
  %conv18 = trunc i32 %and17 to i8
  %and19 = and i32 %dmanr, 3
  %shl20 = shl i32 %and19, 2
  %add21 = add i32 %shl20, 2
  %add22 = add i32 %add21, 192
  call void @outb(i8 zeroext %conv18, i32 %add22)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @set_dma_page(i32 %dmanr, i8 signext %pagenr) #3 {
entry:
  %Pivot14 = icmp slt i32 %dmanr, 3
  br i1 %Pivot14, label %NodeBlock1, label %NodeBlock11

NodeBlock11:                                      ; preds = %entry
  %Pivot12 = icmp slt i32 %dmanr, 6
  br i1 %Pivot12, label %NodeBlock5, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %dmanr, 7
  br i1 %Pivot10, label %sw.bb6, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %dmanr, 7
  br i1 %SwitchLeaf8, label %sw.bb10, label %sw.epilog

NodeBlock5:                                       ; preds = %NodeBlock11
  %Pivot6 = icmp slt i32 %dmanr, 5
  br i1 %Pivot6, label %LeafBlock3, label %sw.bb4

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %dmanr, 3
  br i1 %SwitchLeaf4, label %sw.bb3, label %sw.epilog

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %dmanr, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %dmanr, 2
  br i1 %Pivot, label %sw.bb1, label %sw.bb2

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %dmanr, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @outb(i8 zeroext %pagenr, i32 135)
  br label %sw.epilog

sw.bb1:                                           ; preds = %NodeBlock
  call void @outb(i8 zeroext %pagenr, i32 131)
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock
  call void @outb(i8 zeroext %pagenr, i32 129)
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock3
  call void @outb(i8 zeroext %pagenr, i32 130)
  br label %sw.epilog

sw.bb4:                                           ; preds = %NodeBlock5
  %conv = sext i8 %pagenr to i32
  %and = and i32 %conv, 254
  %conv5 = trunc i32 %and to i8
  call void @outb(i8 zeroext %conv5, i32 139)
  br label %sw.epilog

sw.bb6:                                           ; preds = %NodeBlock9
  %conv7 = sext i8 %pagenr to i32
  %and8 = and i32 %conv7, 254
  %conv9 = trunc i32 %and8 to i8
  call void @outb(i8 zeroext %conv9, i32 137)
  br label %sw.epilog

sw.bb10:                                          ; preds = %LeafBlock7
  %conv11 = sext i8 %pagenr to i32
  %and12 = and i32 %conv11, 254
  %conv13 = trunc i32 %and12 to i8
  call void @outb(i8 zeroext %conv13, i32 138)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb10, %sw.bb6, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb, %LeafBlock, %LeafBlock3, %LeafBlock7
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_unregister_oss_device(i32 %type, %struct.snd_card* %card, i32 %dev) #0 {
entry:
  %call = call i32 @snd_oss_kernel_minor(i32 %type, %struct.snd_card* %card, i32 %dev)
  %shr = ashr i32 %call, 4
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %0 = load i32, i32* %number, align 8, !tbaa !9
  %cmp = icmp sge i32 %0, 16
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* @sound_oss_mutex, i32 0)
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom
  %1 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %cmp4 = icmp eq %struct.snd_minor* %1, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  br label %cleanup

if.end6:                                          ; preds = %if.end3
  call void @unregister_sound_special(i32 %call)
  %and = and i32 %call, 15
  %Pivot6 = icmp slt i32 %and, 3
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end6
  %Pivot = icmp slt i32 %and, 13
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %and, 13
  br i1 %SwitchLeaf4, label %sw.bb10, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 3
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.epilog

LeafBlock:                                        ; preds = %if.end6
  %SwitchLeaf = icmp eq i32 %and, 2
  br i1 %SwitchLeaf, label %sw.bb7, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock1
  %shl = shl i32 %shr, 4
  %or = or i32 %shl, 4
  br label %sw.epilog

sw.bb7:                                           ; preds = %LeafBlock
  %shl8 = shl i32 %shr, 4
  %or9 = or i32 %shl8, 9
  br label %sw.epilog

sw.bb10:                                          ; preds = %LeafBlock3
  %shl11 = shl i32 %shr, 4
  %or12 = or i32 %shl11, 14
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb10, %sw.bb7, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3
  %track2.0 = phi i32 [ %or9, %sw.bb7 ], [ %or, %sw.bb ], [ %or12, %sw.bb10 ], [ -1, %LeafBlock3 ], [ -1, %LeafBlock1 ], [ -1, %LeafBlock ]
  %cmp13 = icmp sge i32 %track2.0, 0
  br i1 %cmp13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %sw.epilog
  call void @unregister_sound_special(i32 %track2.0)
  %idxprom15 = sext i32 %track2.0 to i64
  %arrayidx16 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom15
  store %struct.snd_minor* null, %struct.snd_minor** %arrayidx16, align 8, !tbaa !2
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %sw.epilog
  %idxprom18 = sext i32 %call to i64
  %arrayidx19 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom18
  store %struct.snd_minor* null, %struct.snd_minor** %arrayidx19, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  %2 = bitcast %struct.snd_minor* %1 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %if.then5, %if.end, %land.lhs.true
  %retval.0 = phi i32 [ -2, %if.then5 ], [ 0, %if.end17 ], [ 0, %land.lhs.true ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_oss_kernel_minor(i32 %type, %struct.snd_card* %card, i32 %dev) #0 {
entry:
  %Pivot12 = icmp slt i32 %type, 3
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %type, 5
  br i1 %Pivot10, label %NodeBlock3, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %type, 6
  br i1 %Pivot8, label %sw.epilog, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %type, 6
  br i1 %SwitchLeaf6, label %sw.epilog, label %cleanup

NodeBlock3:                                       ; preds = %NodeBlock9
  %Pivot4 = icmp slt i32 %type, 4
  br i1 %Pivot4, label %sw.bb62, label %sw.bb102

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %type, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %type, 2
  br i1 %Pivot, label %sw.epilog, label %sw.bb22

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %type, 0
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %tobool = icmp eq %struct.snd_card* %card, null
  %cmp = icmp slt i32 %dev, 0
  %or.cond = or i1 %tobool, %cmp
  %cmp1 = icmp sgt i32 %dev, 1
  %.cmp1 = select i1 %or.cond, i1 true, i1 %cmp1
  %lnot = xor i1 %.cmp1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3.169, i32 0, i32 0), i32 73)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %0 = load i32, i32* %number, align 8, !tbaa !9
  %shl = shl i32 %0, 4
  %tobool19 = icmp ne i32 %dev, 0
  %cond = select i1 %tobool19, i32 11, i32 0
  %or = or i32 %shl, %cond
  br label %sw.epilog

sw.bb22:                                          ; preds = %NodeBlock
  %tobool24 = icmp eq %struct.snd_card* %card, null
  %cmp26 = icmp slt i32 %dev, 0
  %or.cond13 = or i1 %tobool24, %cmp26
  %cmp29 = icmp sgt i32 %dev, 1
  %.cmp29 = select i1 %or.cond13, i1 true, i1 %cmp29
  %lnot32 = xor i1 %.cmp29, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %tobool36 = icmp ne i32 %lnot.ext35, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %expval42 = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %tobool43 = icmp ne i64 %expval42, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %sw.bb22
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3.169, i32 0, i32 0), i32 84)
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %sw.bb22
  %tobool47 = icmp ne i32 %lnot.ext35, 0
  %lnot48 = xor i1 %tobool47, true
  %lnot50 = xor i1 %lnot48, true
  %lnot.ext51 = zext i1 %lnot50 to i32
  %conv52 = sext i32 %lnot.ext51 to i64
  %expval53 = call i64 @llvm.expect.i64(i64 %conv52, i64 0)
  %tobool54 = icmp ne i64 %expval53, 0
  br i1 %tobool54, label %cleanup, label %if.end56

if.end56:                                         ; preds = %if.end45
  %number57 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number57, align 8, !tbaa !9
  %shl58 = shl i32 %1, 4
  %tobool59 = icmp ne i32 %dev, 0
  %cond60 = select i1 %tobool59, i32 12, i32 3
  %or61 = or i32 %shl58, %cond60
  br label %sw.epilog

sw.bb62:                                          ; preds = %NodeBlock3
  %tobool64 = icmp eq %struct.snd_card* %card, null
  %cmp66 = icmp slt i32 %dev, 0
  %or.cond14 = or i1 %tobool64, %cmp66
  %cmp69 = icmp sgt i32 %dev, 1
  %.cmp69 = select i1 %or.cond14, i1 true, i1 %cmp69
  %lnot72 = xor i1 %.cmp69, true
  %lnot74 = xor i1 %lnot72, true
  %lnot.ext75 = zext i1 %lnot74 to i32
  %tobool76 = icmp ne i32 %lnot.ext75, 0
  %lnot77 = xor i1 %tobool76, true
  %lnot79 = xor i1 %lnot77, true
  %lnot.ext80 = zext i1 %lnot79 to i32
  %conv81 = sext i32 %lnot.ext80 to i64
  %expval82 = call i64 @llvm.expect.i64(i64 %conv81, i64 0)
  %tobool83 = icmp ne i64 %expval82, 0
  br i1 %tobool83, label %if.then84, label %if.end85

if.then84:                                        ; preds = %sw.bb62
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3.169, i32 0, i32 0), i32 89)
  br label %if.end85

if.end85:                                         ; preds = %if.then84, %sw.bb62
  %tobool87 = icmp ne i32 %lnot.ext75, 0
  %lnot88 = xor i1 %tobool87, true
  %lnot90 = xor i1 %lnot88, true
  %lnot.ext91 = zext i1 %lnot90 to i32
  %conv92 = sext i32 %lnot.ext91 to i64
  %expval93 = call i64 @llvm.expect.i64(i64 %conv92, i64 0)
  %tobool94 = icmp ne i64 %expval93, 0
  br i1 %tobool94, label %cleanup, label %if.end96

if.end96:                                         ; preds = %if.end85
  %number97 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %2 = load i32, i32* %number97, align 8, !tbaa !9
  %shl98 = shl i32 %2, 4
  %tobool99 = icmp ne i32 %dev, 0
  %cond100 = select i1 %tobool99, i32 13, i32 2
  %or101 = or i32 %shl98, %cond100
  br label %sw.epilog

sw.bb102:                                         ; preds = %NodeBlock3
  %number103 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %3 = load i32, i32* %number103, align 8, !tbaa !9
  %shl104 = shl i32 %3, 4
  %or105 = or i32 %shl104, 10
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb102, %if.end96, %if.end56, %if.end18, %NodeBlock, %LeafBlock5, %NodeBlock7
  %minor.0 = phi i32 [ %or, %if.end18 ], [ %or61, %if.end56 ], [ %or101, %if.end96 ], [ %or105, %sw.bb102 ], [ 1, %NodeBlock ], [ 8, %LeafBlock5 ], [ 6, %NodeBlock7 ]
  %cmp107 = icmp slt i32 %minor.0, 0
  %cmp110 = icmp sge i32 %minor.0, 256
  %or.cond15 = or i1 %cmp107, %cmp110
  %.minor.0 = select i1 %or.cond15, i32 -22, i32 %minor.0
  ret i32 %.minor.0

cleanup:                                          ; preds = %if.end85, %if.end45, %if.end, %LeafBlock, %LeafBlock5
  ret i32 -22
}

declare void @unregister_sound_special(i32) #1

; Function Attrs: nounwind uwtable
define i32 @snd_register_oss_device(i32 %type, %struct.snd_card* %card, i32 %dev, %struct.file_operations* %f_ops, i8* %private_data, i8* %name) #0 {
entry:
  %call = call i32 @snd_oss_kernel_minor(i32 %type, %struct.snd_card* %card, i32 %dev)
  %shr = ashr i32 %call, 4
  %call1 = call %struct.device* @snd_card_get_device_link.170(%struct.snd_card* %card)
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %0 = load i32, i32* %number, align 8, !tbaa !9
  %cmp = icmp sge i32 %0, 16
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call.i = call i8* @__kmalloc(i64 48, i32 208) #8
  %1 = bitcast i8* %call.i to %struct.snd_minor*
  %cmp6 = icmp eq %struct.snd_minor* %1, null
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %type9 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 0
  store i32 %type, i32* %type9, align 8, !tbaa !22
  %tobool10 = icmp ne %struct.snd_card* %card, null
  br i1 %tobool10, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end8
  %number11 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %2 = load i32, i32* %number11, align 8, !tbaa !9
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end8
  %cond = phi i32 [ %2, %cond.true ], [ -1, %if.end8 ]
  %card12 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 1
  store i32 %cond, i32* %card12, align 4, !tbaa !23
  %device = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 2
  store i32 %dev, i32* %device, align 8, !tbaa !24
  %f_ops13 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 3
  store %struct.file_operations* %f_ops, %struct.file_operations** %f_ops13, align 8, !tbaa !37
  %private_data14 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 4
  store i8* %private_data, i8** %private_data14, align 8, !tbaa !26
  %card_ptr = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 6
  store %struct.snd_card* %card, %struct.snd_card** %card_ptr, align 8, !tbaa !27
  call void @mutex_lock_nested(%struct.mutex* @sound_oss_mutex, i32 0)
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom
  store %struct.snd_minor* %1, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %and = and i32 %call, 15
  %Pivot6 = icmp slt i32 %and, 3
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %cond.end
  %Pivot = icmp slt i32 %and, 13
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %and, 13
  br i1 %SwitchLeaf4, label %sw.bb18, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 3
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.epilog

LeafBlock:                                        ; preds = %cond.end
  %SwitchLeaf = icmp eq i32 %and, 2
  br i1 %SwitchLeaf, label %sw.bb15, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock1
  %shl = shl i32 %shr, 4
  %or = or i32 %shl, 4
  br label %sw.epilog

sw.bb15:                                          ; preds = %LeafBlock
  %shl16 = shl i32 %shr, 4
  %or17 = or i32 %shl16, 9
  br label %sw.epilog

sw.bb18:                                          ; preds = %LeafBlock3
  %shl19 = shl i32 %shr, 4
  %or20 = or i32 %shl19, 14
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb18, %sw.bb15, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3
  %track2.0 = phi i32 [ %or17, %sw.bb15 ], [ %or, %sw.bb ], [ %or20, %sw.bb18 ], [ -1, %LeafBlock3 ], [ -1, %LeafBlock1 ], [ -1, %LeafBlock ]
  %call21 = call i32 @register_sound_special_device(%struct.file_operations* %f_ops, i32 %call, %struct.device* %call1)
  %cmp22 = icmp ne i32 %call21, %call
  br i1 %cmp22, label %__end, label %if.end24

if.end24:                                         ; preds = %sw.epilog
  %cmp25 = icmp sge i32 %track2.0, 0
  br i1 %cmp25, label %if.then26, label %if.end33

if.then26:                                        ; preds = %if.end24
  %call27 = call i32 @register_sound_special_device(%struct.file_operations* %f_ops, i32 %track2.0, %struct.device* %call1)
  %cmp28 = icmp ne i32 %call27, %track2.0
  br i1 %cmp28, label %__end, label %if.end30

if.end30:                                         ; preds = %if.then26
  %idxprom31 = sext i32 %track2.0 to i64
  %arrayidx32 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom31
  store %struct.snd_minor* %1, %struct.snd_minor** %arrayidx32, align 8, !tbaa !2
  br label %if.end33

if.end33:                                         ; preds = %if.end30, %if.end24
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  br label %cleanup

__end:                                            ; preds = %if.then26, %sw.epilog
  %register2.0 = phi i32 [ -1, %sw.epilog ], [ %call27, %if.then26 ]
  %cmp34 = icmp sge i32 %register2.0, 0
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %__end
  call void @unregister_sound_special(i32 %register2.0)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %__end
  %cmp37 = icmp sge i32 %call21, 0
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end36
  call void @unregister_sound_special(i32 %call21)
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.end36
  %idxprom40 = sext i32 %call to i64
  %arrayidx41 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom40
  store %struct.snd_minor* null, %struct.snd_minor** %arrayidx41, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  %3 = bitcast %struct.snd_minor* %1 to i8*
  call void @kfree(i8* %3)
  br label %cleanup

cleanup:                                          ; preds = %if.end39, %if.end33, %if.end4, %if.end, %land.lhs.true
  %retval.0 = phi i32 [ -16, %if.end39 ], [ 0, %if.end33 ], [ 0, %land.lhs.true ], [ %call, %if.end ], [ -12, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.device* @snd_card_get_device_link.170(%struct.snd_card* %card) #3 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %0 = load %struct.device*, %struct.device** %card_dev, align 8, !tbaa !69
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi %struct.device* [ %0, %cond.true ], [ null, %entry ]
  ret %struct.device* %cond
}

declare i32 @register_sound_special_device(%struct.file_operations*, i32, %struct.device*) #1

; Function Attrs: nounwind uwtable
define i8* @snd_lookup_oss_minor_data(i32 %minor, i32 %type) #0 {
entry:
  %conv = zext i32 %minor to i64
  %cmp = icmp uge i64 %conv, 256
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @sound_oss_mutex, i32 0)
  %idxprom = zext i32 %minor to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end
  %type2 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %1 = load i32, i32* %type2, align 8, !tbaa !22
  %cmp3 = icmp eq i32 %1, %type
  br i1 %cmp3, label %if.then5, label %if.end13

if.then5:                                         ; preds = %land.lhs.true
  %private_data6 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 4
  %2 = load i8*, i8** %private_data6, align 8, !tbaa !26
  %tobool7 = icmp ne i8* %2, null
  br i1 %tobool7, label %land.lhs.true8, label %if.end13

land.lhs.true8:                                   ; preds = %if.then5
  %card_ptr = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  %3 = load %struct.snd_card*, %struct.snd_card** %card_ptr, align 8, !tbaa !27
  %tobool9 = icmp ne %struct.snd_card* %3, null
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %land.lhs.true8
  %card_ptr11 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  %4 = load %struct.snd_card*, %struct.snd_card** %card_ptr11, align 8, !tbaa !27
  %refcount = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 27
  call void @atomic_inc.172(%union.anon.1* %refcount)
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %land.lhs.true8, %if.then5, %land.lhs.true, %if.end
  %private_data.0 = phi i8* [ %2, %if.then10 ], [ %2, %land.lhs.true8 ], [ %2, %if.then5 ], [ null, %land.lhs.true ], [ null, %if.end ]
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %entry
  %retval.0 = phi i8* [ %private_data.0, %if.end13 ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc.172(%union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #8, !srcloc !284
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_minor_info_oss_init() #4 section ".init.text" {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.175, i32 0, i32 0), %struct.snd_info_entry* %0)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.47* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_minor_info_oss_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !29
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.then
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.then, %entry
  %entry1.1 = phi %struct.snd_info_entry* [ %call, %entry ], [ null, %if.then3 ], [ %call, %if.then ]
  store %struct.snd_info_entry* %entry1.1, %struct.snd_info_entry** @snd_minor_info_oss_entry, align 8, !tbaa !2
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @snd_minor_info_oss_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @sound_oss_mutex, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %minor.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %minor.0, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %card = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  %1 = load i32, i32* %card, align 4, !tbaa !23
  %cmp2 = icmp sge i32 %1, 0
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %card4 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  %2 = load i32, i32* %card4, align 4, !tbaa !23
  %device = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 2
  %3 = load i32, i32* %device, align 8, !tbaa !24
  %type = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %4 = load i32, i32* %type, align 8, !tbaa !22
  %call = call i8* @snd_oss_device_type_name(i32 %4)
  %call5 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.4.176, i32 0, i32 0), i32 %minor.0, i32 %2, i32 %3, i8* %call)
  br label %for.inc

if.else:                                          ; preds = %if.end
  %type6 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %5 = load i32, i32* %type6, align 8, !tbaa !22
  %call7 = call i8* @snd_oss_device_type_name(i32 %5)
  %call8 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5.177, i32 0, i32 0), i32 %minor.0, i8* %call7)
  br label %for.inc

for.inc:                                          ; preds = %if.else, %if.then3, %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @snd_oss_device_type_name(i32 %type) #0 {
entry:
  %Pivot12 = icmp slt i32 %type, 3
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %type, 4
  br i1 %Pivot10, label %return, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %type, 6
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %type, 6
  br i1 %SwitchLeaf6, label %return, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %type, 4
  br i1 %SwitchLeaf4, label %return, label %sw.default

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %type, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %type, 2
  %. = select i1 %Pivot, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7.178, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.8.179, i32 0, i32 0)
  ret i8* %.

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %type, 0
  br i1 %SwitchLeaf, label %return, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock3, %LeafBlock5
  br label %return

return:                                           ; preds = %sw.default, %LeafBlock, %LeafBlock3, %LeafBlock5, %NodeBlock9
  %retval.0 = phi i8* [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11.180, i32 0, i32 0), %sw.default ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6.181, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7.178, i32 0, i32 0), %LeafBlock5 ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.182, i32 0, i32 0), %NodeBlock9 ], [ getelementptr inbounds ([19 x i8], [19 x i8]* @.str.10.183, i32 0, i32 0), %LeafBlock3 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_minor_info_oss_done() #4 section ".exit.text" {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_minor_info_oss_entry, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_oss_info_register(i32 %dev, i32 %num, i8* %string) #0 {
entry:
  %cmp = icmp slt i32 %dev, 0
  %cmp1 = icmp sge i32 %dev, 6
  %.cmp1 = select i1 %cmp, i1 true, i1 %cmp1
  %lnot = xor i1 %.cmp1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot3 = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.187, i32 0, i32 0), i32 46)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool8 = icmp ne i32 %lnot.ext, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end
  %cmp19 = icmp slt i32 %num, 0
  %cmp22 = icmp sge i32 %num, 32
  %.cmp22 = select i1 %cmp19, i1 true, i1 %cmp22
  %lnot25 = xor i1 %.cmp22, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %tobool29 = icmp ne i32 %lnot.ext28, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end17
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.187, i32 0, i32 0), i32 48)
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.end17
  %tobool40 = icmp ne i32 %lnot.ext28, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  %expval46 = call i64 @llvm.expect.i64(i64 %conv45, i64 0)
  %tobool47 = icmp ne i64 %expval46, 0
  br i1 %tobool47, label %cleanup, label %if.end49

if.end49:                                         ; preds = %if.end38
  call void @mutex_lock_nested(%struct.mutex* @strings, i32 0)
  %cmp50 = icmp eq i8* %string, null
  br i1 %cmp50, label %if.then52, label %if.else

if.then52:                                        ; preds = %if.end49
  %idxprom = sext i32 %num to i64
  %arrayidx = getelementptr inbounds [32 x [6 x i8*]], [32 x [6 x i8*]]* @snd_sndstat_strings, i64 0, i64 %idxprom
  %idxprom53 = sext i32 %dev to i64
  %arrayidx54 = getelementptr inbounds [6 x i8*], [6 x i8*]* %arrayidx, i64 0, i64 %idxprom53
  %0 = load i8*, i8** %arrayidx54, align 8, !tbaa !2
  %cmp55 = icmp ne i8* %0, null
  br i1 %cmp55, label %if.then57, label %if.end63

if.then57:                                        ; preds = %if.then52
  call void @kfree(i8* %0)
  br label %if.end63

if.else:                                          ; preds = %if.end49
  %call = call i8* @kstrdup(i8* %string, i32 208)
  %cmp59 = icmp eq i8* %call, null
  br i1 %cmp59, label %if.then61, label %if.end63

if.then61:                                        ; preds = %if.else
  call void @mutex_unlock(%struct.mutex* @strings)
  br label %cleanup

if.end63:                                         ; preds = %if.else, %if.then57, %if.then52
  %x.1 = phi i8* [ null, %if.then57 ], [ %0, %if.then52 ], [ %call, %if.else ]
  %idxprom64 = sext i32 %num to i64
  %arrayidx65 = getelementptr inbounds [32 x [6 x i8*]], [32 x [6 x i8*]]* @snd_sndstat_strings, i64 0, i64 %idxprom64
  %idxprom66 = sext i32 %dev to i64
  %arrayidx67 = getelementptr inbounds [6 x i8*], [6 x i8*]* %arrayidx65, i64 0, i64 %idxprom66
  store i8* %x.1, i8** %arrayidx67, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @strings)
  br label %cleanup

cleanup:                                          ; preds = %if.end63, %if.then61, %if.end38, %if.end
  %retval.0 = phi i32 [ 0, %if.end63 ], [ -12, %if.then61 ], [ -6, %if.end ], [ -6, %if.end38 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_minor_register() #0 {
entry:
  call void @llvm.memset.p0i8.i64(i8* bitcast ([32 x [6 x i8*]]* @snd_sndstat_strings to i8*), i8 0, i64 1536, i32 16, i1 false)
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1.192, i32 0, i32 0), %struct.snd_info_entry* %0)
  %cmp = icmp ne %struct.snd_info_entry* %call, null
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.47* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_sndstat_proc_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !29
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  %cmp3 = icmp slt i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.then, %entry
  %entry1.1 = phi %struct.snd_info_entry* [ %call, %entry ], [ null, %if.then4 ], [ %call, %if.then ]
  store %struct.snd_info_entry* %entry1.1, %struct.snd_info_entry** @snd_sndstat_proc_entry, align 8, !tbaa !2
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @snd_sndstat_proc_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  %call = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.4.193, i32 0, i32 0))
  %call2 = call %struct.new_utsname* @init_utsname.194()
  %sysname = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [65 x i8], [65 x i8]* %sysname, i32 0, i32 0
  %call3 = call %struct.new_utsname* @init_utsname.194()
  %nodename = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call3, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [65 x i8], [65 x i8]* %nodename, i32 0, i32 0
  %call5 = call %struct.new_utsname* @init_utsname.194()
  %release = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call5, i32 0, i32 2
  %arraydecay6 = getelementptr inbounds [65 x i8], [65 x i8]* %release, i32 0, i32 0
  %call7 = call %struct.new_utsname* @init_utsname.194()
  %version = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call7, i32 0, i32 3
  %arraydecay8 = getelementptr inbounds [65 x i8], [65 x i8]* %version, i32 0, i32 0
  %call9 = call %struct.new_utsname* @init_utsname.194()
  %machine = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call9, i32 0, i32 4
  %arraydecay10 = getelementptr inbounds [65 x i8], [65 x i8]* %machine, i32 0, i32 0
  %call11 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.5.195, i32 0, i32 0), i8* %arraydecay, i8* %arraydecay4, i8* %arraydecay6, i8* %arraydecay8, i8* %arraydecay10)
  %call12 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.6.196, i32 0, i32 0))
  %call13 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.7.197, i32 0, i32 0))
  %call14 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.8.198, i32 0, i32 0))
  %call15 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.9.199, i32 0, i32 0))
  call void @snd_card_info_read_oss(%struct.snd_info_buffer* %buffer)
  call void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.10.200, i32 0, i32 0), i32 0)
  call void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.11.201, i32 0, i32 0), i32 1)
  call void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.12.202, i32 0, i32 0), i32 2)
  call void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13.203, i32 0, i32 0), i32 4)
  call void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.14.204, i32 0, i32 0), i32 5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.new_utsname* @init_utsname.194() #3 {
entry:
  ret %struct.new_utsname* getelementptr inbounds (%struct.uts_namespace, %struct.uts_namespace* @init_uts_ns, i32 0, i32 1)
}

; Function Attrs: nounwind uwtable
define internal void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buf, i8* %id, i32 %dev) #0 {
entry:
  %call = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.15.205, i32 0, i32 0), i8* %id)
  call void @mutex_lock_nested(%struct.mutex* @strings, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %idx.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
  %ok.0 = phi i32 [ -1, %entry ], [ %ok.2, %for.inc ]
  %cmp = icmp slt i32 %idx.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [32 x [6 x i8*]], [32 x [6 x i8*]]* @snd_sndstat_strings, i64 0, i64 %idxprom
  %idxprom1 = sext i32 %dev to i64
  %arrayidx2 = getelementptr inbounds [6 x i8*], [6 x i8*]* %arrayidx, i64 0, i64 %idxprom1
  %0 = load i8*, i8** %arrayidx2, align 8, !tbaa !2
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %cmp3 = icmp slt i32 %ok.0, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %call5 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buf, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.16.206, i32 0, i32 0))
  %inc = add nsw i32 %ok.0, 1
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %ok.1 = phi i32 [ %inc, %if.then4 ], [ %ok.0, %if.then ]
  %call6 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buf, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.17.207, i32 0, i32 0), i32 %idx.0, i8* %0)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %ok.2 = phi i32 [ %ok.1, %if.end ], [ %ok.0, %for.body ]
  %inc8 = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @strings)
  %cmp9 = icmp slt i32 %ok.0, 0
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.end
  %call11 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buf, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18.208, i32 0, i32 0))
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_minor_unregister() #0 {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_sndstat_proc_entry, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  store %struct.snd_info_entry* null, %struct.snd_info_entry** @snd_sndstat_proc_entry, align 8, !tbaa !2
  ret i32 0
}

; Function Attrs: nounwind uwtable
define void @snd_ctl_sync_vmaster_hook(%struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %tobool = icmp ne %struct.snd_kcontrol* %kcontrol, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_master*
  %hook = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 4
  %2 = load void (i8*, i32)*, void (i8*, i32)** %hook, align 8, !tbaa !285
  %tobool1 = icmp ne void (i8*, i32)* %2, null
  br i1 %tobool1, label %if.then2, label %cleanup.cont

if.then2:                                         ; preds = %if.end
  %hook3 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 4
  %3 = load void (i8*, i32)*, void (i8*, i32)** %hook3, align 8, !tbaa !285
  %hook_private_data = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 5
  %4 = load i8*, i8** %hook_private_data, align 8, !tbaa !288
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  %5 = load i32, i32* %val, align 8, !tbaa !289
  call void %3(i8* %4, i32 %5)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then2, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_add_vmaster_hook(%struct.snd_kcontrol* %kcontrol, void (i8*, i32)* %hook, i8* %private_data) #0 {
entry:
  %private_data1 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data1, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_master*
  %hook2 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 4
  store void (i8*, i32)* %hook, void (i8*, i32)** %hook2, align 8, !tbaa !285
  %hook_private_data = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 5
  store i8* %private_data, i8** %hook_private_data, align 8, !tbaa !288
  ret i32 0
}

; Function Attrs: nounwind uwtable
define %struct.snd_kcontrol* @snd_ctl_make_virtual_master(i8* %name, i32* %tlv) #0 {
entry:
  %knew = alloca %struct.snd_kcontrol_new, align 8
  %0 = bitcast %struct.snd_kcontrol_new* %knew to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 80, i32 8, i1 false)
  %iface = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %knew, i32 0, i32 0
  store i32 2, i32* %iface, align 8, !tbaa !150
  %name1 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %knew, i32 0, i32 3
  store i8* %name, i8** %name1, align 8, !tbaa !153
  %info = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %knew, i32 0, i32 7
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @master_info, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !148
  %call = call i8* @kzalloc.212(i64 72, i32 208)
  %1 = bitcast i8* %call to %struct.link_master*
  %tobool = icmp ne %struct.link_master* %1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %slaves = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 0
  call void @INIT_LIST_HEAD.213(%struct.list_head* %slaves)
  %2 = bitcast %struct.link_master* %1 to i8*
  %call2 = call %struct.snd_kcontrol* @snd_ctl_new1(%struct.snd_kcontrol_new* %knew, i8* %2)
  %tobool3 = icmp ne %struct.snd_kcontrol* %call2, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %3 = bitcast %struct.link_master* %1 to i8*
  call void @kfree(i8* %3)
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %info6 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call2, i32 0, i32 3
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @master_info, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info6, align 8, !tbaa !147
  %get = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call2, i32 0, i32 4
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @master_get, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !158
  %put = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call2, i32 0, i32 5
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @master_put, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !160
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call2, i32 0, i32 9
  store void (%struct.snd_kcontrol*)* @master_free, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !146
  %tobool7 = icmp ne i32* %tlv, null
  br i1 %tobool7, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %if.end5
  %arrayidx = getelementptr inbounds i32, i32* %tlv, i64 0
  %4 = load i32, i32* %arrayidx, align 4, !tbaa !25
  %cmp = icmp eq i32 %4, 1
  br i1 %cmp, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %arrayidx8 = getelementptr inbounds i32, i32* %tlv, i64 0
  %5 = load i32, i32* %arrayidx8, align 4, !tbaa !25
  %cmp9 = icmp eq i32 %5, 4
  br i1 %cmp9, label %if.then13, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false
  %arrayidx11 = getelementptr inbounds i32, i32* %tlv, i64 0
  %6 = load i32, i32* %arrayidx11, align 4, !tbaa !25
  %cmp12 = icmp eq i32 %6, 5
  br i1 %cmp12, label %if.then13, label %cleanup

if.then13:                                        ; preds = %lor.lhs.false10, %lor.lhs.false, %land.lhs.true
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call2, i32 0, i32 10
  %arrayidx14 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i64 0, i64 0
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx14, i32 0, i32 1
  %7 = load i32, i32* %access, align 8, !tbaa !137
  %or = or i32 %7, 16
  store i32 %or, i32* %access, align 8, !tbaa !137
  %cmp15 = icmp uge i64 16, 64
  %tlv17 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 3
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %tlv17, i32 0, i32 0
  %8 = bitcast i32* %arraydecay to i8*
  %9 = bitcast i32* %tlv to i8*
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.then13
  %call18 = call i8* @__memcpy(i8* %8, i8* %9, i64 16)
  br label %if.end21

if.else:                                          ; preds = %if.then13
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 16, i32 4, i1 false)
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then16
  %tlv22 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 3
  %arraydecay23 = getelementptr inbounds [4 x i32], [4 x i32]* %tlv22, i32 0, i32 0
  %tlv24 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call2, i32 0, i32 6
  %p = bitcast %union.anon.58* %tlv24 to i32**
  store i32* %arraydecay23, i32** %p, align 8, !tbaa !29
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %lor.lhs.false10, %if.end5, %if.then4, %entry
  %retval.0 = phi %struct.snd_kcontrol* [ null, %if.then4 ], [ null, %entry ], [ %call2, %if.end21 ], [ %call2, %lor.lhs.false10 ], [ %call2, %if.end5 ]
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @master_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_master*
  %call = call i32 @master_init(%struct.link_master* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %info = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 1
  %type = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 0
  %2 = load i32, i32* %type, align 8, !tbaa !290
  %type1 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 1
  store i32 %2, i32* %type1, align 8, !tbaa !117
  %info2 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 1
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info2, i32 0, i32 1
  %3 = load i32, i32* %count, align 4, !tbaa !291
  %count3 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 3
  store i32 %3, i32* %count3, align 8, !tbaa !120
  %info4 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 1
  %min_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info4, i32 0, i32 2
  %4 = load i32, i32* %min_val, align 8, !tbaa !292
  %conv = sext i32 %4 to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer = bitcast %union.anon.48* %value to %struct.task_cputime*
  %min = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer, i32 0, i32 0
  store i64 %conv, i64* %min, align 8, !tbaa !29
  %info5 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 1
  %max_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info5, i32 0, i32 3
  %5 = load i32, i32* %max_val, align 4, !tbaa !293
  %conv6 = sext i32 %5 to i64
  %value7 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer8 = bitcast %union.anon.48* %value7 to %struct.task_cputime*
  %max = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer8, i32 0, i32 1
  store i64 %conv6, i64* %max, align 8, !tbaa !29
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.212(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.213(%struct.list_head* %list) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !66
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !67
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @master_get(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_master*
  %call = call i32 @master_init(%struct.link_master* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  %2 = load i32, i32* %val, align 8, !tbaa !289
  %conv = sext i32 %2 to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.53* %value to %union.anon.54*
  %value1 = bitcast %union.anon.54* %integer to [128 x i64]*
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value1, i64 0, i64 0
  store i64 %conv, i64* %arrayidx, align 8, !tbaa !29
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @master_put(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_master*
  %call = call i32 @master_init(%struct.link_master* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  %2 = load i32, i32* %val, align 8, !tbaa !289
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.53* %value to %union.anon.54*
  %value1 = bitcast %union.anon.54* %integer to [128 x i64]*
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value1, i64 0, i64 0
  %3 = load i64, i64* %arrayidx, align 8, !tbaa !29
  %conv = sext i32 %2 to i64
  %cmp2 = icmp eq i64 %3, %conv
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %call.i = call i8* @__kmalloc(i64 1224, i32 208) #8
  %4 = bitcast i8* %call.i to %struct.snd_ctl_elem_value*
  %tobool = icmp ne %struct.snd_ctl_elem_value* %4, null
  br i1 %tobool, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.end5
  %slaves = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end8
  %list24.sink = phi %struct.list_head* [ %list24, %for.body ], [ %slaves, %if.end8 ]
  %next25 = getelementptr inbounds %struct.list_head, %struct.list_head* %list24.sink, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next25, align 8, !tbaa !2
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr27 = getelementptr inbounds i8, i8* %6, i64 0
  %7 = bitcast i8* %add.ptr27 to %struct.link_slave*
  %list = getelementptr inbounds %struct.link_slave, %struct.link_slave* %7, i32 0, i32 0
  %slaves9 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 0
  %cmp10 = icmp ne %struct.list_head* %list, %slaves9
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %val12 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  store i32 %2, i32* %val12, align 8, !tbaa !289
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %4, i32 0, i32 0
  %slave13 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %7, i32 0, i32 6
  %id14 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave13, i32 0, i32 1
  %8 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %9 = bitcast %struct.snd_ctl_elem_id* %id14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 64, i32 8, i1 false), !tbaa.struct !135
  %call15 = call i32 @slave_get_val(%struct.link_slave* %7, %struct.snd_ctl_elem_value* %4)
  %value16 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer17 = bitcast %union.anon.53* %value16 to %union.anon.54*
  %value18 = bitcast %union.anon.54* %integer17 to [128 x i64]*
  %arrayidx19 = getelementptr inbounds [128 x i64], [128 x i64]* %value18, i64 0, i64 0
  %10 = load i64, i64* %arrayidx19, align 8, !tbaa !29
  %conv20 = trunc i64 %10 to i32
  %val21 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  store i32 %conv20, i32* %val21, align 8, !tbaa !289
  %call22 = call i32 @slave_put_val(%struct.link_slave* %7, %struct.snd_ctl_elem_value* %4)
  %list24 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %7, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = bitcast %struct.snd_ctl_elem_value* %4 to i8*
  call void @kfree(i8* %11)
  %hook = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 4
  %12 = load void (i8*, i32)*, void (i8*, i32)** %hook, align 8, !tbaa !285
  %tobool28 = icmp eq void (i8*, i32)* %12, null
  %tobool29 = icmp ne i32 %call, 0
  %or.cond = or i1 %tobool28, %tobool29
  br i1 %or.cond, label %cleanup, label %if.then30

if.then30:                                        ; preds = %for.end
  %hook31 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 4
  %13 = load void (i8*, i32)*, void (i8*, i32)** %hook31, align 8, !tbaa !285
  %hook_private_data = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 5
  %14 = load i8*, i8** %hook_private_data, align 8, !tbaa !288
  %val32 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  %15 = load i32, i32* %val32, align 8, !tbaa !289
  call void %13(i8* %14, i32 %15)
  br label %cleanup

cleanup:                                          ; preds = %if.then30, %for.end, %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ 0, %if.end ], [ -12, %if.end5 ], [ 1, %for.end ], [ 1, %if.then30 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @master_free(%struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %olist = alloca %struct.list_head, align 8
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_master*
  %slaves = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %slaves, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !66
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.link_slave*
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %.sink = phi %struct.link_slave* [ %7, %if.end ], [ %4, %entry ]
  %slave.0 = phi %struct.link_slave* [ %4, %entry ], [ %7, %if.end ]
  %list20 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %.sink, i32 0, i32 0
  %next21 = getelementptr inbounds %struct.list_head, %struct.list_head* %list20, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next21, align 8, !tbaa !294
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr23 = getelementptr inbounds i8, i8* %6, i64 0
  %7 = bitcast i8* %add.ptr23 to %struct.link_slave*
  %list5 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave.0, i32 0, i32 0
  %slaves6 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list5, %slaves6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %kctl = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave.0, i32 0, i32 5
  %8 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !296
  %list7 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 0
  %9 = bitcast %struct.list_head* %olist to i8*
  %10 = bitcast %struct.list_head* %list7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 16, i32 8, i1 false), !tbaa.struct !297
  %cmp8 = icmp uge i64 144, 64
  %11 = bitcast %struct.snd_kcontrol* %8 to i8*
  %slave9 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave.0, i32 0, i32 6
  %12 = bitcast %struct.snd_kcontrol* %slave9 to i8*
  br i1 %cmp8, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %call = call i8* @__memcpy(i8* %11, i8* %12, i64 144)
  br label %if.end

if.else:                                          ; preds = %for.body
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 144, i32 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 2
  %13 = load i32, i32* %count, align 8, !tbaa !133
  %conv = zext i32 %13 to i64
  %mul = mul i64 %conv, 16
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 10
  %arraydecay = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i32 0, i32 0
  %14 = bitcast %struct.snd_kcontrol_volatile* %arraydecay to i8*
  %slave14 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave.0, i32 0, i32 6
  %vd15 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave14, i32 0, i32 10
  %arraydecay16 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd15, i32 0, i32 0
  %15 = bitcast %struct.snd_kcontrol_volatile* %arraydecay16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 %mul, i32 8, i1 false)
  %list18 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 0
  %16 = bitcast %struct.list_head* %list18 to i8*
  %17 = bitcast %struct.list_head* %olist to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %17, i64 16, i32 8, i1 false), !tbaa.struct !297
  %18 = bitcast %struct.link_slave* %slave.0 to i8*
  call void @kfree(i8* %18)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = bitcast %struct.link_master* %1 to i8*
  call void @kfree(i8* %19)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @master_init(%struct.link_master* %master) #0 {
entry:
  %info = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 1
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 1
  %0 = load i32, i32* %count, align 4, !tbaa !291
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cleanup20, label %if.end

if.end:                                           ; preds = %entry
  %slaves = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %slaves, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !66
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.link_slave*
  %list = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 0
  %slaves1 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, %slaves1
  br i1 %cmp, label %for.body, label %cleanup20

for.body:                                         ; preds = %if.end
  %call = call i32 @slave_init(%struct.link_slave* %3)
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %cleanup20, label %if.end4

if.end4:                                          ; preds = %for.body
  %info5 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 1
  %info6 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 2
  %4 = bitcast %struct.link_ctl_info* %info5 to i8*
  %5 = bitcast %struct.link_ctl_info* %info6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 16, i32 8, i1 false), !tbaa.struct !298
  %info7 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 1
  %count8 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info7, i32 0, i32 1
  store i32 1, i32* %count8, align 4, !tbaa !291
  %info9 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 1
  %max_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info9, i32 0, i32 3
  %6 = load i32, i32* %max_val, align 4, !tbaa !293
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 2
  store i32 %6, i32* %val, align 8, !tbaa !289
  %hook = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 4
  %7 = load void (i8*, i32)*, void (i8*, i32)** %hook, align 8, !tbaa !285
  %tobool10 = icmp ne void (i8*, i32)* %7, null
  br i1 %tobool10, label %if.then11, label %cleanup20

if.then11:                                        ; preds = %if.end4
  %hook12 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 4
  %8 = load void (i8*, i32)*, void (i8*, i32)** %hook12, align 8, !tbaa !285
  %hook_private_data = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 5
  %9 = load i8*, i8** %hook_private_data, align 8, !tbaa !288
  %val13 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 2
  %10 = load i32, i32* %val13, align 8, !tbaa !289
  call void %8(i8* %9, i32 %10)
  br label %cleanup20

cleanup20:                                        ; preds = %if.then11, %if.end4, %for.body, %if.end, %entry
  %retval.1 = phi i32 [ 0, %entry ], [ %call, %for.body ], [ 1, %if.then11 ], [ 1, %if.end4 ], [ -2, %if.end ]
  ret i32 %retval.1
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_get_val(%struct.link_slave* %slave, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %call = call i32 @slave_init(%struct.link_slave* %slave)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %ch.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %info = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 1
  %0 = load i32, i32* %count, align 4, !tbaa !299
  %cmp1 = icmp slt i32 %ch.0, %0
  br i1 %cmp1, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %vals = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 3
  %idxprom = sext i32 %ch.0 to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %vals, i64 0, i64 %idxprom
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !25
  %conv = sext i32 %1 to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.53* %value to %union.anon.54*
  %value2 = bitcast %union.anon.54* %integer to [128 x i64]*
  %idxprom3 = sext i32 %ch.0 to i64
  %arrayidx4 = getelementptr inbounds [128 x i64], [128 x i64]* %value2, i64 0, i64 %idxprom3
  store i64 %conv, i64* %arrayidx4, align 8, !tbaa !29
  %inc = add nsw i32 %ch.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_put_val(%struct.link_slave* %slave, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %master = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 1
  %0 = load %struct.link_master*, %struct.link_master** %master, align 8, !tbaa !300
  %call = call i32 @master_init(%struct.link_master* %0)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %info = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %type = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 0
  %1 = load i32, i32* %type, align 8, !tbaa !301
  %Pivot = icmp slt i32 %1, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end
  %SwitchLeaf2 = icmp eq i32 %1, 2
  br i1 %SwitchLeaf2, label %sw.bb6, label %sw.epilog

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %1, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  br label %for.cond

for.cond:                                         ; preds = %for.body, %sw.bb
  %ch.0 = phi i32 [ 0, %sw.bb ], [ %inc, %for.body ]
  %info1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info1, i32 0, i32 1
  %2 = load i32, i32* %count, align 4, !tbaa !299
  %cmp2 = icmp slt i32 %ch.0, %2
  br i1 %cmp2, label %for.body, label %sw.epilog

for.body:                                         ; preds = %for.cond
  %master3 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 1
  %3 = load %struct.link_master*, %struct.link_master** %master3, align 8, !tbaa !300
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %3, i32 0, i32 2
  %4 = load i32, i32* %val, align 8, !tbaa !289
  %tobool = icmp ne i32 %4, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.53* %value to %union.anon.54*
  %value5 = bitcast %union.anon.54* %integer to [128 x i64]*
  %idxprom = sext i32 %ch.0 to i64
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value5, i64 0, i64 %idxprom
  %5 = load i64, i64* %arrayidx, align 8, !tbaa !29
  %and = and i64 %5, %conv
  store i64 %and, i64* %arrayidx, align 8, !tbaa !29
  %inc = add nsw i32 %ch.0, 1
  br label %for.cond

sw.bb6:                                           ; preds = %LeafBlock1
  br label %for.cond7

for.cond7:                                        ; preds = %if.end37, %sw.bb6
  %ch.1 = phi i32 [ 0, %sw.bb6 ], [ %inc45, %if.end37 ]
  %info8 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count9 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info8, i32 0, i32 1
  %6 = load i32, i32* %count9, align 4, !tbaa !299
  %cmp10 = icmp slt i32 %ch.1, %6
  br i1 %cmp10, label %for.body12, label %sw.epilog

for.body12:                                       ; preds = %for.cond7
  %value13 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer14 = bitcast %union.anon.53* %value13 to %union.anon.54*
  %value15 = bitcast %union.anon.54* %integer14 to [128 x i64]*
  %idxprom16 = sext i32 %ch.1 to i64
  %arrayidx17 = getelementptr inbounds [128 x i64], [128 x i64]* %value15, i64 0, i64 %idxprom16
  %7 = load i64, i64* %arrayidx17, align 8, !tbaa !29
  %conv18 = trunc i64 %7 to i32
  %master19 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 1
  %8 = load %struct.link_master*, %struct.link_master** %master19, align 8, !tbaa !300
  %val20 = getelementptr inbounds %struct.link_master, %struct.link_master* %8, i32 0, i32 2
  %9 = load i32, i32* %val20, align 8, !tbaa !289
  %master21 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 1
  %10 = load %struct.link_master*, %struct.link_master** %master21, align 8, !tbaa !300
  %info22 = getelementptr inbounds %struct.link_master, %struct.link_master* %10, i32 0, i32 1
  %max_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info22, i32 0, i32 3
  %11 = load i32, i32* %max_val, align 4, !tbaa !293
  %sub = sub nsw i32 %9, %11
  %add = add nsw i32 %conv18, %sub
  %info23 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %min_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info23, i32 0, i32 2
  %12 = load i32, i32* %min_val, align 8, !tbaa !302
  %cmp24 = icmp slt i32 %add, %12
  %info27 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  br i1 %cmp24, label %if.then26, label %if.else

if.then26:                                        ; preds = %for.body12
  %min_val28 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info27, i32 0, i32 2
  %13 = load i32, i32* %min_val28, align 8, !tbaa !302
  br label %if.end37

if.else:                                          ; preds = %for.body12
  %max_val30 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info27, i32 0, i32 3
  %14 = load i32, i32* %max_val30, align 4, !tbaa !303
  %cmp31 = icmp sgt i32 %add, %14
  br i1 %cmp31, label %if.then33, label %if.end37

if.then33:                                        ; preds = %if.else
  %info34 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %max_val35 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info34, i32 0, i32 3
  %15 = load i32, i32* %max_val35, align 4, !tbaa !303
  br label %if.end37

if.end37:                                         ; preds = %if.then33, %if.else, %if.then26
  %vol.1 = phi i32 [ %13, %if.then26 ], [ %15, %if.then33 ], [ %add, %if.else ]
  %conv38 = sext i32 %vol.1 to i64
  %value39 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer40 = bitcast %union.anon.53* %value39 to %union.anon.54*
  %value41 = bitcast %union.anon.54* %integer40 to [128 x i64]*
  %idxprom42 = sext i32 %ch.1 to i64
  %arrayidx43 = getelementptr inbounds [128 x i64], [128 x i64]* %value41, i64 0, i64 %idxprom42
  store i64 %conv38, i64* %arrayidx43, align 8, !tbaa !29
  %inc45 = add nsw i32 %ch.1, 1
  br label %for.cond7

sw.epilog:                                        ; preds = %for.cond7, %for.cond, %LeafBlock, %LeafBlock1
  %slave47 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %put = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave47, i32 0, i32 5
  %16 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !304
  %slave48 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %call49 = call i32 %16(%struct.snd_kcontrol* %slave48, %struct.snd_ctl_elem_value* %ucontrol)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %entry
  %retval.0 = phi i32 [ %call49, %sw.epilog ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_init(%struct.link_slave* %slave) #0 {
entry:
  %info = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 1
  %0 = load i32, i32* %count, align 4, !tbaa !299
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %flags = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 4
  %1 = load i32, i32* %flags, align 8, !tbaa !305
  %and = and i32 %1, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %if.then
  %call = call i32 @slave_update(%struct.link_slave* %slave)
  br label %cleanup

if.end3:                                          ; preds = %entry
  %call.i = call i8* @__kmalloc(i64 272, i32 208) #8
  %2 = bitcast i8* %call.i to %struct.snd_ctl_elem_info*
  %tobool5 = icmp ne %struct.snd_ctl_elem_info* %2, null
  br i1 %tobool5, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.end3
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %2, i32 0, i32 0
  %slave8 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %id9 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave8, i32 0, i32 1
  %3 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %4 = bitcast %struct.snd_ctl_elem_id* %id9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 64, i32 8, i1 false), !tbaa.struct !135
  %slave10 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %info11 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave10, i32 0, i32 3
  %5 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info11, align 8, !tbaa !306
  %slave12 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %call13 = call i32 %5(%struct.snd_kcontrol* %slave12, %struct.snd_ctl_elem_info* %2)
  %cmp = icmp slt i32 %call13, 0
  br i1 %cmp, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end7
  %6 = bitcast %struct.snd_ctl_elem_info* %2 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

if.end15:                                         ; preds = %if.end7
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %2, i32 0, i32 1
  %7 = load i32, i32* %type, align 8, !tbaa !117
  %info16 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %type17 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info16, i32 0, i32 0
  store i32 %7, i32* %type17, align 8, !tbaa !301
  %count18 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %2, i32 0, i32 3
  %8 = load i32, i32* %count18, align 8, !tbaa !120
  %info19 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count20 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info19, i32 0, i32 1
  store i32 %8, i32* %count20, align 4, !tbaa !299
  %info21 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count22 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info21, i32 0, i32 1
  %9 = load i32, i32* %count22, align 4, !tbaa !299
  %cmp23 = icmp sgt i32 %9, 2
  br i1 %cmp23, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end15
  %info24 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %type25 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info24, i32 0, i32 0
  %10 = load i32, i32* %type25, align 8, !tbaa !301
  %cmp26 = icmp ne i32 %10, 2
  br i1 %cmp26, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %lor.lhs.false
  %info27 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %type28 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info27, i32 0, i32 0
  %11 = load i32, i32* %type28, align 8, !tbaa !301
  %cmp29 = icmp ne i32 %11, 1
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %land.lhs.true, %if.end15
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.215, i32 0, i32 0), i32 undef, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.1.216, i32 0, i32 0))
  %12 = bitcast %struct.snd_ctl_elem_info* %2 to i8*
  call void @kfree(i8* %12)
  br label %cleanup

if.end31:                                         ; preds = %land.lhs.true, %lor.lhs.false
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %2, i32 0, i32 5
  %integer = bitcast %union.anon.48* %value to %struct.task_cputime*
  %min = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer, i32 0, i32 0
  %13 = load i64, i64* %min, align 8, !tbaa !29
  %conv = trunc i64 %13 to i32
  %info32 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %min_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info32, i32 0, i32 2
  store i32 %conv, i32* %min_val, align 8, !tbaa !302
  %value33 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %2, i32 0, i32 5
  %integer34 = bitcast %union.anon.48* %value33 to %struct.task_cputime*
  %max = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer34, i32 0, i32 1
  %14 = load i64, i64* %max, align 8, !tbaa !29
  %conv35 = trunc i64 %14 to i32
  %info36 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %max_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info36, i32 0, i32 3
  store i32 %conv35, i32* %max_val, align 4, !tbaa !303
  %15 = bitcast %struct.snd_ctl_elem_info* %2 to i8*
  call void @kfree(i8* %15)
  %call37 = call i32 @slave_update(%struct.link_slave* %slave)
  br label %cleanup

cleanup:                                          ; preds = %if.end31, %if.then30, %if.then14, %if.end3, %if.then2, %if.then
  %retval.0 = phi i32 [ %call, %if.then2 ], [ %call13, %if.then14 ], [ -22, %if.then30 ], [ %call37, %if.end31 ], [ 0, %if.then ], [ -12, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_update(%struct.link_slave* %slave) #0 {
entry:
  %call.i = call i8* @__kmalloc(i64 1224, i32 208) #8
  %0 = bitcast i8* %call.i to %struct.snd_ctl_elem_value*
  %tobool = icmp ne %struct.snd_ctl_elem_value* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %0, i32 0, i32 0
  %slave1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %id2 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave1, i32 0, i32 1
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %2 = bitcast %struct.snd_ctl_elem_id* %id2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 64, i32 8, i1 false), !tbaa.struct !135
  %slave3 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %get = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave3, i32 0, i32 4
  %3 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !307
  %slave4 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %call5 = call i32 %3(%struct.snd_kcontrol* %slave4, %struct.snd_ctl_elem_value* %0)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %ch.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %info = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 1
  %4 = load i32, i32* %count, align 4, !tbaa !299
  %cmp = icmp slt i32 %ch.0, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %0, i32 0, i32 2
  %integer = bitcast %union.anon.53* %value to %union.anon.54*
  %value6 = bitcast %union.anon.54* %integer to [128 x i64]*
  %idxprom = sext i32 %ch.0 to i64
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value6, i64 0, i64 %idxprom
  %5 = load i64, i64* %arrayidx, align 8, !tbaa !29
  %conv = trunc i64 %5 to i32
  %vals = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 3
  %idxprom7 = sext i32 %ch.0 to i64
  %arrayidx8 = getelementptr inbounds [2 x i32], [2 x i32]* %vals, i64 0, i64 %idxprom7
  store i32 %conv, i32* %arrayidx8, align 4, !tbaa !25
  %inc = add nsw i32 %ch.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = bitcast %struct.snd_ctl_elem_value* %0 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i32 [ 0, %for.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @_snd_ctl_add_slave(%struct.snd_kcontrol* %master, %struct.snd_kcontrol* %slave, i32 %flags) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %master, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_master*
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 2
  %2 = load i32, i32* %count, align 8, !tbaa !133
  %conv = zext i32 %2 to i64
  %mul = mul i64 %conv, 16
  %add = add i64 208, %mul
  %call = call i8* @kzalloc.212(i64 %add, i32 208)
  %3 = bitcast i8* %call to %struct.link_slave*
  %tobool = icmp ne %struct.link_slave* %3, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %kctl = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 5
  store %struct.snd_kcontrol* %slave, %struct.snd_kcontrol** %kctl, align 8, !tbaa !296
  %slave1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 6
  %4 = bitcast %struct.snd_kcontrol* %slave1 to i8*
  %5 = bitcast %struct.snd_kcontrol* %slave to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 144, i32 8, i1 false), !tbaa.struct !164
  %count2 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 2
  %6 = load i32, i32* %count2, align 8, !tbaa !133
  %conv3 = zext i32 %6 to i64
  %mul4 = mul i64 %conv3, 16
  %slave5 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 6
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave5, i32 0, i32 10
  %arraydecay = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i32 0, i32 0
  %7 = bitcast %struct.snd_kcontrol_volatile* %arraydecay to i8*
  %vd6 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 10
  %arraydecay7 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd6, i32 0, i32 0
  %8 = bitcast %struct.snd_kcontrol_volatile* %arraydecay7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 %mul4, i32 8, i1 false)
  %master8 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 1
  store %struct.link_master* %1, %struct.link_master** %master8, align 8, !tbaa !300
  %flags9 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 4
  store i32 %flags, i32* %flags9, align 8, !tbaa !305
  %info = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 3
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @slave_info, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !147
  %get = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 4
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @slave_get, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !158
  %put = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 5
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @slave_put, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !160
  %vd10 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 10
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd10, i64 0, i64 0
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %9 = load i32, i32* %access, align 8, !tbaa !137
  %and = and i32 %9, 268435456
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  %tlv = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 6
  %c = bitcast %union.anon.58* %tlv to i32 (%struct.snd_kcontrol*, i32, i32, i32*)**
  store i32 (%struct.snd_kcontrol*, i32, i32, i32*)* @slave_tlv_cmd, i32 (%struct.snd_kcontrol*, i32, i32, i32*)** %c, align 8, !tbaa !29
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end
  %10 = bitcast %struct.link_slave* %3 to i8*
  %private_data14 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 8
  store i8* %10, i8** %private_data14, align 8, !tbaa !163
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 9
  store void (%struct.snd_kcontrol*)* @slave_free, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !146
  %list = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 0
  %slaves = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 0
  call void @list_add_tail.217(%struct.list_head* %list, %struct.list_head* %slaves)
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %entry
  %retval.0 = phi i32 [ 0, %if.end13 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_slave*
  %slave1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %info = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave1, i32 0, i32 3
  %2 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !306
  %slave2 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %call = call i32 %2(%struct.snd_kcontrol* %slave2, %struct.snd_ctl_elem_info* %uinfo)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_get(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_slave*
  %call = call i32 @slave_get_val(%struct.link_slave* %1, %struct.snd_ctl_elem_value* %ucontrol)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_put(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_slave*
  %call = call i32 @slave_init(%struct.link_slave* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %ch.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %changed.0 = phi i32 [ 0, %if.end ], [ %changed.1, %for.inc ]
  %info = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 2
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 1
  %2 = load i32, i32* %count, align 4, !tbaa !299
  %cmp1 = icmp slt i32 %ch.0, %2
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %vals = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 3
  %idxprom = sext i32 %ch.0 to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %vals, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !25
  %conv = sext i32 %3 to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.53* %value to %union.anon.54*
  %value2 = bitcast %union.anon.54* %integer to [128 x i64]*
  %idxprom3 = sext i32 %ch.0 to i64
  %arrayidx4 = getelementptr inbounds [128 x i64], [128 x i64]* %value2, i64 0, i64 %idxprom3
  %4 = load i64, i64* %arrayidx4, align 8, !tbaa !29
  %cmp5 = icmp ne i64 %conv, %4
  br i1 %cmp5, label %if.then7, label %for.inc

if.then7:                                         ; preds = %for.body
  %value8 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer9 = bitcast %union.anon.53* %value8 to %union.anon.54*
  %value10 = bitcast %union.anon.54* %integer9 to [128 x i64]*
  %idxprom11 = sext i32 %ch.0 to i64
  %arrayidx12 = getelementptr inbounds [128 x i64], [128 x i64]* %value10, i64 0, i64 %idxprom11
  %5 = load i64, i64* %arrayidx12, align 8, !tbaa !29
  %conv13 = trunc i64 %5 to i32
  %vals14 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 3
  %idxprom15 = sext i32 %ch.0 to i64
  %arrayidx16 = getelementptr inbounds [2 x i32], [2 x i32]* %vals14, i64 0, i64 %idxprom15
  store i32 %conv13, i32* %arrayidx16, align 4, !tbaa !25
  br label %for.inc

for.inc:                                          ; preds = %if.then7, %for.body
  %changed.1 = phi i32 [ 1, %if.then7 ], [ %changed.0, %for.body ]
  %inc = add nsw i32 %ch.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool = icmp ne i32 %changed.0, 0
  br i1 %tobool, label %if.end19, label %cleanup

if.end19:                                         ; preds = %for.end
  %call20 = call i32 @slave_put_val(%struct.link_slave* %1, %struct.snd_ctl_elem_value* %ucontrol)
  %cmp21 = icmp slt i32 %call20, 0
  %call20. = select i1 %cmp21, i32 %call20, i32 1
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %for.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ 0, %for.end ], [ %call20., %if.end19 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_tlv_cmd(%struct.snd_kcontrol* %kcontrol, i32 %op_flag, i32 %size, i32* %tlv) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_slave*
  %slave1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %tlv2 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave1, i32 0, i32 6
  %c = bitcast %union.anon.58* %tlv2 to i32 (%struct.snd_kcontrol*, i32, i32, i32*)**
  %2 = load i32 (%struct.snd_kcontrol*, i32, i32, i32*)*, i32 (%struct.snd_kcontrol*, i32, i32, i32*)** %c, align 8, !tbaa !29
  %slave3 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %call = call i32 %2(%struct.snd_kcontrol* %slave3, i32 %op_flag, i32 %size, i32* %tlv)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @slave_free(%struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !163
  %1 = bitcast i8* %0 to %struct.link_slave*
  %slave1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave1, i32 0, i32 9
  %2 = load void (%struct.snd_kcontrol*)*, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !308
  %tobool = icmp ne void (%struct.snd_kcontrol*)* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %slave2 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %private_free3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave2, i32 0, i32 9
  %3 = load void (%struct.snd_kcontrol*)*, void (%struct.snd_kcontrol*)** %private_free3, align 8, !tbaa !308
  %slave4 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  call void %3(%struct.snd_kcontrol* %slave4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %master = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 1
  %4 = load %struct.link_master*, %struct.link_master** %master, align 8, !tbaa !300
  %tobool5 = icmp ne %struct.link_master* %4, null
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %list = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %5 = bitcast %struct.link_slave* %1 to i8*
  call void @kfree(i8* %5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.217(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !67
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_kctl_jack_report(%struct.snd_card* %card, %struct.snd_kcontrol* %kctl, i1 zeroext %status) #0 {
entry:
  %frombool = zext i1 %status to i8
  %private_value = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 7
  %0 = load i64, i64* %private_value, align 8, !tbaa !162
  %tobool = trunc i8 %frombool to i1
  %conv = zext i1 %tobool to i64
  %cmp = icmp eq i64 %0, %conv
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool2 = trunc i8 %frombool to i1
  %conv3 = zext i1 %tobool2 to i64
  %private_value4 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 7
  store i64 %conv3, i64* %private_value4, align 8, !tbaa !162
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 1, %struct.snd_ctl_elem_id* %id)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.snd_kcontrol* @snd_kctl_jack_new(i8* %name, i32 %idx, i8* %private_data) #0 {
entry:
  %call = call %struct.snd_kcontrol* @snd_ctl_new1(%struct.snd_kcontrol_new* @jack_detect_kctl, i8* %private_data)
  %tobool = icmp ne %struct.snd_kcontrol* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 1
  %name1 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 4
  %arraydecay = getelementptr inbounds [44 x i8], [44 x i8]* %name1, i32 0, i32 0
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 44, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.219, i32 0, i32 0), i8* %name)
  %id3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 1
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id3, i32 0, i32 5
  store i32 %idx, i32* %index, align 4, !tbaa !131
  %private_value = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 7
  store i64 0, i64* %private_value, align 8, !tbaa !162
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi %struct.snd_kcontrol* [ %call, %if.end ], [ null, %entry ]
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @jack_detect_kctl_get(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_value = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 7
  %0 = load i64, i64* %private_value, align 8, !tbaa !162
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.53* %value to %union.anon.54*
  %value1 = bitcast %union.anon.54* %integer to [128 x i64]*
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value1, i64 0, i64 0
  store i64 %0, i64* %arrayidx, align 8, !tbaa !29
  ret i32 0
}

; Function Attrs: nounwind uwtable
define void @snd_jack_report(%struct.snd_jack* %jack, i32 %status) #0 {
entry:
  %tobool = icmp ne %struct.snd_jack* %jack, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %shr = ashr i32 16384, %i.0
  %type = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 2
  %0 = load i32, i32* %type, align 4, !tbaa !309
  %and = and i32 %0, %shr
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then3, label %for.inc

if.then3:                                         ; preds = %for.body
  %input_dev = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 0
  %1 = load %struct.input_dev*, %struct.input_dev** %input_dev, align 8, !tbaa !311
  %key = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 5
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %key, i64 0, i64 %idxprom
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !25
  %and4 = and i32 %status, %shr
  call void @input_report_key(%struct.input_dev* %1, i32 %2, i32 %and4)
  br label %for.inc

for.inc:                                          ; preds = %if.then3, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc21, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc22, %for.inc21 ]
  %conv7 = sext i32 %i.1 to i64
  %cmp8 = icmp ult i64 %conv7, 6
  br i1 %cmp8, label %for.body10, label %for.end23

for.body10:                                       ; preds = %for.cond6
  %shl = shl i32 1, %i.1
  %type12 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 2
  %3 = load i32, i32* %type12, align 4, !tbaa !309
  %and13 = and i32 %3, %shl
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then15, label %for.inc21

if.then15:                                        ; preds = %for.body10
  %input_dev16 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 0
  %4 = load %struct.input_dev*, %struct.input_dev** %input_dev16, align 8, !tbaa !311
  %idxprom17 = sext i32 %i.1 to i64
  %arrayidx18 = getelementptr inbounds [6 x i32], [6 x i32]* @jack_switch_types, i64 0, i64 %idxprom17
  %5 = load i32, i32* %arrayidx18, align 4, !tbaa !25
  %and19 = and i32 %status, %shl
  call void @input_report_switch(%struct.input_dev* %4, i32 %5, i32 %and19)
  br label %for.inc21

for.inc21:                                        ; preds = %if.then15, %for.body10
  %inc22 = add nsw i32 %i.1, 1
  br label %for.cond6

for.end23:                                        ; preds = %for.cond6
  %input_dev24 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 0
  %6 = load %struct.input_dev*, %struct.input_dev** %input_dev24, align 8, !tbaa !311
  call void @input_sync(%struct.input_dev* %6)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end23, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_key(%struct.input_dev* %dev, i32 %code, i32 %value) #3 {
entry:
  %tobool = icmp ne i32 %value, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  call void @input_event(%struct.input_dev* %dev, i32 1, i32 %code, i32 %lnot.ext)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_switch(%struct.input_dev* %dev, i32 %code, i32 %value) #3 {
entry:
  %tobool = icmp ne i32 %value, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  call void @input_event(%struct.input_dev* %dev, i32 5, i32 %code, i32 %lnot.ext)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_sync(%struct.input_dev* %dev) #3 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 0, i32 0, i32 0)
  ret void
}

declare void @input_event(%struct.input_dev*, i32, i32, i32) #1

; Function Attrs: nounwind uwtable
define i32 @snd_jack_set_key(%struct.snd_jack* %jack, i32 %type, i32 %keytype) #0 {
entry:
  %call = call i32 @fls(i32 16384)
  %call1 = call i32 @fls(i32 %type)
  %sub = sub nsw i32 %call, %call1
  %registered = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 1
  %0 = load i32, i32* %registered, align 8, !tbaa !312
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.1.221, i32 0, i32 0), i32 200)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool16 = icmp eq i32 %keytype, 0
  %conv17 = sext i32 %sub to i64
  %cmp = icmp uge i64 %conv17, 6
  %or.cond = or i1 %tobool16, %cmp
  br i1 %or.cond, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end
  %type21 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 2
  %1 = load i32, i32* %type21, align 4, !tbaa !309
  %or = or i32 %1, %type
  store i32 %or, i32* %type21, align 4, !tbaa !309
  %key22 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 5
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %key22, i64 0, i64 %idxprom
  store i32 %keytype, i32* %arrayidx, align 4, !tbaa !25
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %if.end
  %retval.0 = phi i32 [ 0, %if.end20 ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @fls(i32 %x) #3 {
entry:
  %0 = call i32 asm "bsrl $1,$0", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i32 %x, i32 -1) #10, !srcloc !313
  %add = add nsw i32 %0, 1
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define void @snd_jack_set_parent(%struct.snd_jack* %jack, %struct.device* %parent) #0 {
entry:
  %registered = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 1
  %0 = load i32, i32* %registered, align 8, !tbaa !312
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool2 = icmp ne i32 %lnot.ext, 0
  %lnot3 = xor i1 %tobool2, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.1.221, i32 0, i32 0), i32 164)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %input_dev = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 0
  %1 = load %struct.input_dev*, %struct.input_dev** %input_dev, align 8, !tbaa !311
  %dev = getelementptr inbounds %struct.input_dev, %struct.input_dev* %1, i32 0, i32 39
  %parent15 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  store %struct.device* %parent, %struct.device** %parent15, align 8, !tbaa !314
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_jack_new(%struct.snd_card* %card, i8* %id, i32 %type, %struct.snd_jack** %jjack) #0 {
entry:
  %call = call i8* @kzalloc.222(i64 168, i32 208)
  %0 = bitcast i8* %call to %struct.snd_jack*
  %cmp = icmp eq %struct.snd_jack* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i8* @kstrdup(i8* %id, i32 208)
  %id2 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 3
  store i8* %call1, i8** %id2, align 8, !tbaa !317
  %call3 = call %struct.input_dev* @input_allocate_device()
  %input_dev = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 0
  store %struct.input_dev* %call3, %struct.input_dev** %input_dev, align 8, !tbaa !311
  %input_dev4 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 0
  %1 = load %struct.input_dev*, %struct.input_dev** %input_dev4, align 8, !tbaa !311
  %cmp5 = icmp eq %struct.input_dev* %1, null
  br i1 %cmp5, label %fail_input, label %if.end7

if.end7:                                          ; preds = %if.end
  %input_dev8 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 0
  %2 = load %struct.input_dev*, %struct.input_dev** %input_dev8, align 8, !tbaa !311
  %phys = getelementptr inbounds %struct.input_dev, %struct.input_dev* %2, i32 0, i32 1
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.223, i32 0, i32 0), i8** %phys, align 8, !tbaa !318
  %type9 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 2
  store i32 %type, i32* %type9, align 4, !tbaa !309
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %i.0 = phi i32 [ 0, %if.end7 ], [ %inc, %for.inc ]
  %cmp10 = icmp slt i32 %i.0, 6
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %shl = shl i32 1, %i.0
  %and = and i32 %type, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then11, label %for.inc

if.then11:                                        ; preds = %for.body
  %input_dev12 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 0
  %3 = load %struct.input_dev*, %struct.input_dev** %input_dev12, align 8, !tbaa !311
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* @jack_switch_types, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4, !tbaa !25
  call void @input_set_capability(%struct.input_dev* %3, i32 5, i32 %4)
  br label %for.inc

for.inc:                                          ; preds = %if.then11, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %5 = bitcast %struct.snd_jack* %0 to i8*
  %call14 = call i32 @snd_device_new(%struct.snd_card* %card, i32 4105, i8* %5, %struct.snd_device_ops* @snd_jack_new.ops)
  %cmp15 = icmp slt i32 %call14, 0
  br i1 %cmp15, label %fail_input, label %if.end17

if.end17:                                         ; preds = %for.end
  store %struct.snd_jack* %0, %struct.snd_jack** %jjack, align 8, !tbaa !2
  br label %cleanup

fail_input:                                       ; preds = %for.end, %if.end
  %err.0 = phi i32 [ -12, %if.end ], [ %call14, %for.end ]
  %input_dev18 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 0
  %6 = load %struct.input_dev*, %struct.input_dev** %input_dev18, align 8, !tbaa !311
  call void @input_free_device(%struct.input_dev* %6)
  %id19 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 3
  %7 = load i8*, i8** %id19, align 8, !tbaa !317
  call void @kfree(i8* %7)
  %8 = bitcast %struct.snd_jack* %0 to i8*
  call void @kfree(i8* %8)
  br label %cleanup

cleanup:                                          ; preds = %fail_input, %if.end17, %entry
  %retval.0 = phi i32 [ %err.0, %fail_input ], [ 0, %if.end17 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.222(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #8
  ret i8* %call.i
}

declare %struct.input_dev* @input_allocate_device() #1

declare void @input_set_capability(%struct.input_dev*, i32, i32) #1

declare void @input_free_device(%struct.input_dev*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_jack_dev_free(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !112
  %1 = bitcast i8* %0 to %struct.snd_jack*
  %private_free = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 7
  %2 = load void (%struct.snd_jack*)*, void (%struct.snd_jack*)** %private_free, align 8, !tbaa !319
  %tobool = icmp ne void (%struct.snd_jack*)* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %private_free1 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 7
  %3 = load void (%struct.snd_jack*)*, void (%struct.snd_jack*)** %private_free1, align 8, !tbaa !319
  call void %3(%struct.snd_jack* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %registered = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 1
  %4 = load i32, i32* %registered, align 8, !tbaa !312
  %tobool2 = icmp ne i32 %4, 0
  %input_dev = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 0
  %5 = load %struct.input_dev*, %struct.input_dev** %input_dev, align 8, !tbaa !311
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  call void @input_unregister_device(%struct.input_dev* %5)
  br label %if.end5

if.else:                                          ; preds = %if.end
  call void @input_free_device(%struct.input_dev* %5)
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then3
  %id = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  %6 = load i8*, i8** %id, align 8, !tbaa !317
  call void @kfree(i8* %6)
  %7 = bitcast %struct.snd_jack* %1 to i8*
  call void @kfree(i8* %7)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_jack_dev_register(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !112
  %1 = bitcast i8* %0 to %struct.snd_jack*
  %card1 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 1
  %2 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !280
  %name = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 4
  %arraydecay = getelementptr inbounds [100 x i8], [100 x i8]* %name, i32 0, i32 0
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 3
  %arraydecay2 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  %id = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  %3 = load i8*, i8** %id, align 8, !tbaa !317
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 100, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2.224, i32 0, i32 0), i8* %arraydecay2, i8* %3)
  %name3 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 4
  %arraydecay4 = getelementptr inbounds [100 x i8], [100 x i8]* %name3, i32 0, i32 0
  %input_dev = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 0
  %4 = load %struct.input_dev*, %struct.input_dev** %input_dev, align 8, !tbaa !311
  %name5 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %4, i32 0, i32 0
  store i8* %arraydecay4, i8** %name5, align 8, !tbaa !320
  %input_dev6 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 0
  %5 = load %struct.input_dev*, %struct.input_dev** %input_dev6, align 8, !tbaa !311
  %dev = getelementptr inbounds %struct.input_dev, %struct.input_dev* %5, i32 0, i32 39
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %6 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !314
  %tobool = icmp ne %struct.device* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call7 = call %struct.device* @snd_card_get_device_link.225(%struct.snd_card* %2)
  %input_dev8 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 0
  %7 = load %struct.input_dev*, %struct.input_dev** %input_dev8, align 8, !tbaa !311
  %dev9 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %7, i32 0, i32 39
  %parent10 = getelementptr inbounds %struct.device, %struct.device* %dev9, i32 0, i32 0
  store %struct.device* %call7, %struct.device** %parent10, align 8, !tbaa !314
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %LeafBlock ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %shr = ashr i32 16384, %i.0
  %type = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 2
  %8 = load i32, i32* %type, align 4, !tbaa !309
  %and = and i32 %8, %shr
  %tobool12 = icmp ne i32 %and, 0
  br i1 %tobool12, label %if.end14, label %LeafBlock

if.end14:                                         ; preds = %for.body
  %key = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 5
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %key, i64 0, i64 %idxprom
  %9 = load i32, i32* %arrayidx, align 4, !tbaa !25
  %tobool15 = icmp ne i32 %9, 0
  br i1 %tobool15, label %if.end20, label %if.then16

if.then16:                                        ; preds = %if.end14
  %add = add nsw i32 256, %i.0
  %key17 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 5
  %idxprom18 = sext i32 %i.0 to i64
  %arrayidx19 = getelementptr inbounds [6 x i32], [6 x i32]* %key17, i64 0, i64 %idxprom18
  store i32 %add, i32* %arrayidx19, align 4, !tbaa !25
  br label %if.end20

if.end20:                                         ; preds = %if.then16, %if.end14
  %input_dev21 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 0
  %10 = load %struct.input_dev*, %struct.input_dev** %input_dev21, align 8, !tbaa !311
  %key22 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 5
  %idxprom23 = sext i32 %i.0 to i64
  %arrayidx24 = getelementptr inbounds [6 x i32], [6 x i32]* %key22, i64 0, i64 %idxprom23
  %11 = load i32, i32* %arrayidx24, align 4, !tbaa !25
  call void @input_set_capability(%struct.input_dev* %10, i32 1, i32 %11)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end20, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %input_dev25 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 0
  %12 = load %struct.input_dev*, %struct.input_dev** %input_dev25, align 8, !tbaa !311
  %call26 = call i32 @input_register_device(%struct.input_dev* %12)
  %cmp27 = icmp eq i32 %call26, 0
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %for.end
  %registered = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 1
  store i32 1, i32* %registered, align 8, !tbaa !312
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %for.end
  ret i32 %call26
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.device* @snd_card_get_device_link.225(%struct.snd_card* %card) #3 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %0 = load %struct.device*, %struct.device** %card_dev, align 8, !tbaa !69
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi %struct.device* [ %0, %cond.true ], [ null, %entry ]
  ret %struct.device* %cond
}

declare i32 @input_register_device(%struct.input_dev*) #1

declare void @input_unregister_device(%struct.input_dev*) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readnone }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind }
attributes #6 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readnone speculatable }
attributes #8 = { nounwind }
attributes #9 = { noreturn }
attributes #10 = { nounwind readonly }

!llvm.ident = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !3, i64 0}
!3 = !{!"any pointer", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !3, i64 32}
!7 = !{!"snd_minor", !8, i64 0, !8, i64 4, !8, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40}
!8 = !{!"int", !4, i64 0}
!9 = !{!10, !8, i64 0}
!10 = !{!"snd_card", !8, i64 0, !4, i64 4, !4, i64 20, !4, i64 36, !4, i64 68, !4, i64 148, !4, i64 228, !3, i64 360, !3, i64 368, !3, i64 376, !11, i64 384, !8, i64 400, !12, i64 408, !17, i64 552, !8, i64 624, !8, i64 628, !11, i64 632, !11, i64 648, !3, i64 664, !3, i64 672, !3, i64 680, !11, i64 688, !3, i64 704, !18, i64 712, !8, i64 784, !8, i64 788, !19, i64 792, !20, i64 880, !3, i64 888, !3, i64 896, !8, i64 904, !21, i64 912, !19, i64 1080, !3, i64 1168, !8, i64 1176}
!11 = !{!"list_head", !3, i64 0, !3, i64 8}
!12 = !{!"rw_semaphore", !13, i64 0, !14, i64 8, !11, i64 80, !16, i64 96}
!13 = !{!"long", !4, i64 0}
!14 = !{!"raw_spinlock", !15, i64 0, !8, i64 4, !8, i64 8, !3, i64 16, !16, i64 24}
!15 = !{!"arch_spinlock", !4, i64 0}
!16 = !{!"lockdep_map", !3, i64 0, !4, i64 8, !3, i64 24, !8, i64 32, !13, i64 40}
!17 = !{!"", !4, i64 0, !8, i64 8, !8, i64 12, !3, i64 16, !16, i64 24}
!18 = !{!"spinlock", !4, i64 0}
!19 = !{!"__wait_queue_head", !18, i64 0, !11, i64 72}
!20 = !{!"", !8, i64 0}
!21 = !{!"mutex", !20, i64 0, !18, i64 8, !11, i64 80, !3, i64 96, !3, i64 104, !3, i64 112, !16, i64 120}
!22 = !{!7, !8, i64 0}
!23 = !{!7, !8, i64 4}
!24 = !{!7, !8, i64 8}
!25 = !{!8, !8, i64 0}
!26 = !{!7, !3, i64 24}
!27 = !{!7, !3, i64 40}
!28 = !{i32 -2146203414, i32 -2146203375, i32 -2146203354, i32 -2146203317, i32 -2146203294, i32 -2146203424}
!29 = !{!4, !4, i64 0}
!30 = !{!31, !3, i64 40}
!31 = !{!"file", !4, i64 0, !32, i64 16, !3, i64 32, !3, i64 40, !18, i64 48, !8, i64 120, !33, i64 128, !8, i64 136, !8, i64 140, !34, i64 144, !35, i64 152, !3, i64 248, !36, i64 256, !34, i64 288, !3, i64 296, !3, i64 304, !11, i64 312, !11, i64 328, !3, i64 344, !13, i64 352}
!32 = !{!"path", !3, i64 0, !3, i64 8}
!33 = !{!"", !13, i64 0}
!34 = !{!"long long", !4, i64 0}
!35 = !{!"fown_struct", !17, i64 0, !3, i64 72, !4, i64 80, !8, i64 84, !8, i64 88, !8, i64 92}
!36 = !{!"file_ra_state", !13, i64 0, !8, i64 8, !8, i64 12, !8, i64 16, !8, i64 20, !34, i64 24}
!37 = !{!7, !3, i64 16}
!38 = !{!39, !3, i64 0}
!39 = !{!"file_operations", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !3, i64 112, !3, i64 120, !3, i64 128, !3, i64 136, !3, i64 144, !3, i64 152, !3, i64 160, !3, i64 168, !3, i64 176, !3, i64 184, !3, i64 192, !3, i64 200, !3, i64 208}
!40 = !{!39, !3, i64 88}
!41 = !{!42, !8, i64 76}
!42 = !{!"inode", !43, i64 0, !43, i64 2, !8, i64 4, !8, i64 8, !8, i64 12, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !13, i64 64, !4, i64 72, !8, i64 76, !34, i64 80, !44, i64 88, !44, i64 104, !44, i64 120, !18, i64 136, !43, i64 208, !8, i64 212, !13, i64 216, !13, i64 224, !21, i64 232, !13, i64 400, !45, i64 408, !11, i64 424, !11, i64 440, !11, i64 456, !4, i64 472, !34, i64 488, !20, i64 496, !20, i64 500, !20, i64 504, !3, i64 512, !3, i64 520, !46, i64 528, !4, i64 960, !11, i64 976, !4, i64 992, !8, i64 1000, !8, i64 1004, !49, i64 1008, !20, i64 1016, !3, i64 1024}
!43 = !{!"short", !4, i64 0}
!44 = !{!"timespec", !13, i64 0, !13, i64 8}
!45 = !{!"hlist_node", !3, i64 0, !3, i64 8}
!46 = !{!"address_space", !3, i64 0, !47, i64 8, !18, i64 24, !8, i64 96, !48, i64 104, !11, i64 112, !21, i64 128, !13, i64 296, !13, i64 304, !3, i64 312, !13, i64 320, !3, i64 328, !18, i64 336, !11, i64 408, !3, i64 424}
!47 = !{!"radix_tree_root", !8, i64 0, !8, i64 4, !3, i64 8}
!48 = !{!"rb_root", !3, i64 0}
!49 = !{!"hlist_head", !3, i64 0}
!50 = !{i32 -2146671720}
!51 = !{!10, !8, i64 784}
!52 = !{!13, !13, i64 0}
!53 = !{i32 -2144353975}
!54 = !{!10, !8, i64 904}
!55 = !{!56, !8, i64 0}
!56 = !{!"__wait_queue", !8, i64 0, !3, i64 8, !3, i64 16, !11, i64 24}
!57 = !{!56, !3, i64 8}
!58 = !{!56, !3, i64 16}
!59 = !{!60, !3, i64 0}
!60 = !{!"snd_monitor_file", !3, i64 0, !3, i64 8, !11, i64 16, !11, i64 32}
!61 = !{!60, !3, i64 8}
!62 = !{!10, !8, i64 788}
!63 = !{i32 -2146131287, i32 -2146131248, i32 -2146131227, i32 -2146131190, i32 -2146131167, i32 -2146131297}
!64 = !{!10, !3, i64 376}
!65 = !{!10, !3, i64 672}
!66 = !{!11, !3, i64 0}
!67 = !{!11, !3, i64 8}
!68 = !{i32 -2146131711, i32 -2146131672, i32 -2146131651, i32 -2146131614, i32 -2146131591, i32 -2146131721}
!69 = !{!10, !3, i64 896}
!70 = !{!10, !3, i64 888}
!71 = !{!10, !3, i64 664}
!72 = !{!73, !3, i64 0}
!73 = !{!"snd_info_entry", !3, i64 0, !43, i64 8, !13, i64 16, !43, i64 24, !4, i64 32, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !21, i64 96, !11, i64 264, !11, i64 280}
!74 = !{!73, !3, i64 56}
!75 = !{!31, !8, i64 136}
!76 = !{!39, !3, i64 128}
!77 = !{!39, !3, i64 104}
!78 = !{i32 -2146131499, i32 -2146131460, i32 -2146131439, i32 -2146131402, i32 -2146131379, i32 -2146131509}
!79 = !{!10, !3, i64 360}
!80 = !{!10, !3, i64 368}
!81 = !{!20, !8, i64 0}
!82 = !{!73, !3, i64 48}
!83 = !{!73, !43, i64 8}
!84 = !{!73, !13, i64 16}
!85 = !{!73, !3, i64 88}
!86 = !{!31, !3, i64 304}
!87 = !{!88, !3, i64 16}
!88 = !{!"snd_info_private_data", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24}
!89 = !{!73, !43, i64 24}
!90 = !{!91, !3, i64 32}
!91 = !{!"snd_info_entry_ops", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56}
!92 = !{!88, !3, i64 24}
!93 = !{!31, !34, i64 144}
!94 = !{!34, !34, i64 0}
!95 = !{!88, !3, i64 0}
!96 = !{!97, !8, i64 12}
!97 = !{!"snd_info_buffer", !3, i64 0, !8, i64 8, !8, i64 12, !8, i64 16, !8, i64 20, !8, i64 24}
!98 = !{!97, !3, i64 0}
!99 = !{!91, !3, i64 16}
!100 = !{!88, !3, i64 8}
!101 = !{!97, !8, i64 16}
!102 = !{!91, !3, i64 24}
!103 = !{!91, !3, i64 40}
!104 = !{!91, !3, i64 48}
!105 = !{!91, !3, i64 56}
!106 = !{!73, !3, i64 64}
!107 = !{!91, !3, i64 0}
!108 = !{!97, !8, i64 24}
!109 = !{!91, !3, i64 8}
!110 = !{!31, !3, i64 32}
!111 = !{!73, !3, i64 80}
!112 = !{!113, !3, i64 32}
!113 = !{!"snd_device", !11, i64 0, !3, i64 16, !8, i64 24, !8, i64 28, !3, i64 32, !3, i64 40}
!114 = !{!97, !8, i64 20}
!115 = !{!97, !8, i64 8}
!116 = !{!10, !3, i64 680}
!117 = !{!118, !8, i64 64}
!118 = !{!"snd_ctl_elem_info", !119, i64 0, !8, i64 64, !8, i64 68, !8, i64 72, !8, i64 76, !4, i64 80, !4, i64 208, !4, i64 216}
!119 = !{!"snd_ctl_elem_id", !8, i64 0, !8, i64 4, !8, i64 8, !8, i64 12, !4, i64 16, !8, i64 60}
!120 = !{!118, !8, i64 72}
!121 = !{!122, !3, i64 16}
!122 = !{!"snd_kctl_ioctl", !11, i64 0, !3, i64 16}
!123 = !{!119, !8, i64 0}
!124 = !{!125, !8, i64 20}
!125 = !{!"snd_kcontrol", !11, i64 0, !119, i64 16, !8, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !4, i64 112, !13, i64 120, !3, i64 128, !3, i64 136, !4, i64 144}
!126 = !{!119, !8, i64 4}
!127 = !{!125, !8, i64 24}
!128 = !{!119, !8, i64 8}
!129 = !{!125, !8, i64 28}
!130 = !{!119, !8, i64 12}
!131 = !{!125, !8, i64 76}
!132 = !{!119, !8, i64 60}
!133 = !{!125, !8, i64 80}
!134 = !{!125, !8, i64 16}
!135 = !{i64 0, i64 4, !25, i64 4, i64 4, !25, i64 8, i64 4, !25, i64 12, i64 4, !25, i64 16, i64 44, !29, i64 60, i64 4, !25}
!136 = !{!10, !8, i64 400}
!137 = !{!138, !8, i64 8}
!138 = !{!"snd_kcontrol_volatile", !3, i64 0, !8, i64 8}
!139 = !{!10, !8, i64 1176}
!140 = !{!141, !8, i64 208}
!141 = !{!"snd_ctl_file", !11, i64 0, !3, i64 16, !3, i64 24, !8, i64 32, !8, i64 36, !19, i64 40, !18, i64 128, !3, i64 200, !8, i64 208, !11, i64 216}
!142 = !{!143, !8, i64 16}
!143 = !{!"snd_kctl_event", !11, i64 0, !119, i64 16, !8, i64 80}
!144 = !{!143, !8, i64 80}
!145 = !{!10, !8, i64 624}
!146 = !{!125, !3, i64 136}
!147 = !{!125, !3, i64 88}
!148 = !{!149, !3, i64 40}
!149 = !{!"snd_kcontrol_new", !8, i64 0, !8, i64 4, !8, i64 8, !3, i64 16, !8, i64 24, !8, i64 28, !8, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !4, i64 64, !13, i64 72}
!150 = !{!149, !8, i64 0}
!151 = !{!149, !8, i64 4}
!152 = !{!149, !8, i64 8}
!153 = !{!149, !3, i64 16}
!154 = !{!149, !8, i64 24}
!155 = !{!149, !8, i64 32}
!156 = !{!149, !8, i64 28}
!157 = !{!149, !3, i64 48}
!158 = !{!125, !3, i64 96}
!159 = !{!149, !3, i64 56}
!160 = !{!125, !3, i64 104}
!161 = !{!149, !13, i64 72}
!162 = !{!125, !13, i64 120}
!163 = !{!125, !3, i64 128}
!164 = !{i64 0, i64 8, !2, i64 8, i64 8, !2, i64 16, i64 4, !25, i64 20, i64 4, !25, i64 24, i64 4, !25, i64 28, i64 4, !25, i64 32, i64 44, !29, i64 76, i64 4, !25, i64 80, i64 4, !25, i64 88, i64 8, !2, i64 96, i64 8, !2, i64 104, i64 8, !2, i64 112, i64 8, !2, i64 112, i64 8, !2, i64 120, i64 8, !52, i64 128, i64 8, !2, i64 136, i64 8, !2, i64 144, i64 0, !29}
!165 = !{!10, !3, i64 632}
!166 = !{!141, !3, i64 16}
!167 = !{i32 -2146774271}
!168 = !{i32 -2144264154}
!169 = !{!141, !3, i64 216}
!170 = !{!171, !8, i64 0}
!171 = !{!"snd_ctl_event", !8, i64 0, !4, i64 4}
!172 = !{i32 -2144282631}
!173 = !{i32 -2144267245}
!174 = !{!141, !8, i64 32}
!175 = !{!141, !8, i64 36}
!176 = !{!141, !3, i64 24}
!177 = !{!138, !3, i64 0}
!178 = !{!179, !3, i64 16}
!179 = !{!"pid_link", !45, i64 0, !3, i64 16}
!180 = !{i32 -2146232648, i32 -2146232609, i32 -2146232588, i32 -2146232551, i32 -2146232528, i32 -2146232658}
!181 = !{i32 -2144165663}
!182 = !{i32 -2144164030}
!183 = !{i32 -2144163419}
!184 = !{!118, !8, i64 76}
!185 = !{i32 -2144161841}
!186 = !{i32 -2144159983}
!187 = !{i32 -2144158109}
!188 = !{i32 -2144156222}
!189 = !{i32 -2144151445}
!190 = !{i32 -2144150916}
!191 = !{i32 -2144150326}
!192 = !{i32 -2144149713}
!193 = !{i32 -2144149100}
!194 = !{!10, !8, i64 628}
!195 = !{!118, !8, i64 68}
!196 = !{!118, !8, i64 0}
!197 = !{i64 0, i64 4, !25, i64 4, i64 4, !25, i64 8, i64 4, !25, i64 12, i64 4, !25, i64 16, i64 44, !29, i64 60, i64 4, !25, i64 64, i64 4, !25, i64 68, i64 4, !25, i64 72, i64 4, !25, i64 76, i64 4, !25, i64 80, i64 8, !52, i64 88, i64 8, !52, i64 96, i64 8, !52, i64 80, i64 8, !94, i64 88, i64 8, !94, i64 96, i64 8, !94, i64 80, i64 4, !25, i64 84, i64 4, !25, i64 88, i64 64, !29, i64 152, i64 8, !94, i64 160, i64 4, !25, i64 80, i64 128, !29, i64 208, i64 8, !29, i64 208, i64 8, !2, i64 216, i64 56, !29}
!198 = !{!199, !8, i64 68}
!199 = !{!"user_element", !118, i64 0, !3, i64 272, !13, i64 280, !3, i64 288, !13, i64 296, !3, i64 304}
!200 = !{!199, !3, i64 272}
!201 = !{!199, !13, i64 280}
!202 = !{!199, !8, i64 64}
!203 = !{!199, !3, i64 304}
!204 = !{!199, !13, i64 296}
!205 = !{!199, !3, i64 288}
!206 = !{i32 -2144155046}
!207 = !{i32 -2144154428}
!208 = !{i32 -2144152693}
!209 = !{!210, !8, i64 0}
!210 = !{!"snd_ctl_elem_list", !8, i64 0, !8, i64 4, !8, i64 8, !8, i64 12, !3, i64 16, !4, i64 24}
!211 = !{!210, !8, i64 4}
!212 = !{!210, !8, i64 12}
!213 = !{!210, !8, i64 8}
!214 = !{!210, !3, i64 16}
!215 = !{!216, !8, i64 0}
!216 = !{!"snd_ctl_card_info", !8, i64 0, !8, i64 4, !4, i64 8, !4, i64 24, !4, i64 40, !4, i64 72, !4, i64 152, !4, i64 168, !4, i64 248}
!217 = !{i32 -2144286520}
!218 = !{i32 -2144285263}
!219 = !{!220, !8, i64 4}
!220 = !{!"snd_ctl_tlv", !8, i64 0, !8, i64 4, !4, i64 8}
!221 = !{!220, !8, i64 0}
!222 = !{!223, !3, i64 0}
!223 = !{!"poll_table_struct", !3, i64 0, !13, i64 8}
!224 = !{!225, !3, i64 8}
!225 = !{!"task_struct", !13, i64 0, !3, i64 8, !20, i64 16, !8, i64 20, !8, i64 24, !226, i64 32, !8, i64 40, !8, i64 44, !8, i64 48, !8, i64 52, !8, i64 56, !8, i64 60, !3, i64 64, !227, i64 72, !232, i64 448, !3, i64 520, !49, i64 528, !4, i64 536, !8, i64 540, !8, i64 544, !8, i64 548, !233, i64 552, !234, i64 1064, !11, i64 1096, !235, i64 1112, !3, i64 1152, !3, i64 1160, !8, i64 1168, !8, i64 1172, !8, i64 1176, !8, i64 1180, !8, i64 1184, !8, i64 1188, !8, i64 1192, !8, i64 1196, !8, i64 1196, !8, i64 1196, !8, i64 1196, !8, i64 1196, !8, i64 1196, !8, i64 1200, !8, i64 1204, !13, i64 1208, !3, i64 1216, !3, i64 1224, !11, i64 1232, !11, i64 1248, !3, i64 1264, !11, i64 1272, !11, i64 1288, !4, i64 1304, !11, i64 1376, !3, i64 1392, !3, i64 1400, !3, i64 1408, !13, i64 1416, !13, i64 1424, !13, i64 1432, !13, i64 1440, !13, i64 1448, !236, i64 1456, !13, i64 1472, !13, i64 1480, !44, i64 1488, !44, i64 1504, !13, i64 1520, !13, i64 1528, !237, i64 1536, !4, i64 1560, !3, i64 1608, !3, i64 1616, !4, i64 1624, !8, i64 1640, !8, i64 1644, !238, i64 1648, !13, i64 1656, !239, i64 1664, !3, i64 1848, !3, i64 1856, !3, i64 1864, !3, i64 1872, !3, i64 1880, !241, i64 1888, !241, i64 1896, !241, i64 1904, !242, i64 1912, !13, i64 1936, !13, i64 1944, !3, i64 1952, !3, i64 1960, !3, i64 1968, !3, i64 1976, !3, i64 1984, !8, i64 1992, !8, i64 1996, !243, i64 2000, !8, i64 2016, !8, i64 2020, !18, i64 2024, !14, i64 2096, !244, i64 2168, !3, i64 2184, !3, i64 2192, !8, i64 2200, !13, i64 2208, !13, i64 2216, !8, i64 2224, !8, i64 2228, !8, i64 2232, !8, i64 2236, !13, i64 2240, !13, i64 2248, !8, i64 2256, !8, i64 2260, !8, i64 2264, !8, i64 2268, !34, i64 2272, !8, i64 2280, !8, i64 2284, !4, i64 2288, !8, i64 4976, !3, i64 4984, !3, i64 4992, !3, i64 5000, !3, i64 5008, !3, i64 5016, !3, i64 5024, !13, i64 5032, !3, i64 5040, !245, i64 5048, !34, i64 5104, !34, i64 5112, !13, i64 5120, !241, i64 5128, !246, i64 5256, !8, i64 5260, !8, i64 5264, !3, i64 5272, !11, i64 5280, !3, i64 5296, !3, i64 5304, !11, i64 5312, !3, i64 5328, !4, i64 5336, !21, i64 5352, !11, i64 5520, !3, i64 5536, !43, i64 5544, !43, i64 5546, !8, i64 5548, !8, i64 5552, !8, i64 5556, !34, i64 5560, !247, i64 5568, !247, i64 5584, !3, i64 5600, !248, i64 5608, !3, i64 5624, !8, i64 5632, !8, i64 5636, !8, i64 5640, !13, i64 5648, !8, i64 5656, !4, i64 5664, !13, i64 9504, !13, i64 9512, !8, i64 9520, !3, i64 9528, !34, i64 9536, !20, i64 9544, !20, i64 9548, !13, i64 9552, !13, i64 9560, !249, i64 9568, !8, i64 9600, !20, i64 9604, !3, i64 9608, !8, i64 9616, !8, i64 9620}
!226 = !{!"llist_node", !3, i64 0}
!227 = !{!"sched_entity", !228, i64 0, !229, i64 16, !11, i64 40, !8, i64 56, !34, i64 64, !34, i64 72, !34, i64 80, !34, i64 88, !34, i64 96, !230, i64 104, !3, i64 320, !3, i64 328, !3, i64 336, !231, i64 344}
!228 = !{!"load_weight", !13, i64 0, !13, i64 8}
!229 = !{!"rb_node", !13, i64 0, !3, i64 8, !3, i64 16}
!230 = !{!"sched_statistics", !34, i64 0, !34, i64 8, !34, i64 16, !34, i64 24, !34, i64 32, !34, i64 40, !34, i64 48, !34, i64 56, !34, i64 64, !34, i64 72, !34, i64 80, !34, i64 88, !34, i64 96, !34, i64 104, !34, i64 112, !34, i64 120, !34, i64 128, !34, i64 136, !34, i64 144, !34, i64 152, !34, i64 160, !34, i64 168, !34, i64 176, !34, i64 184, !34, i64 192, !34, i64 200, !34, i64 208}
!231 = !{!"sched_avg", !8, i64 0, !8, i64 4, !34, i64 8, !34, i64 16, !13, i64 24}
!232 = !{!"sched_rt_entity", !11, i64 0, !13, i64 16, !13, i64 24, !8, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64}
!233 = !{!"cpumask", !4, i64 0}
!234 = !{!"sched_info", !13, i64 0, !34, i64 8, !34, i64 16, !34, i64 24}
!235 = !{!"plist_node", !8, i64 0, !11, i64 8, !11, i64 24}
!236 = !{!"cputime", !13, i64 0, !13, i64 8}
!237 = !{!"task_cputime", !13, i64 0, !13, i64 8, !34, i64 16}
!238 = !{!"sysv_sem", !3, i64 0}
!239 = !{!"thread_struct", !4, i64 0, !13, i64 24, !13, i64 32, !13, i64 40, !43, i64 48, !43, i64 50, !43, i64 52, !43, i64 54, !13, i64 56, !13, i64 64, !4, i64 72, !13, i64 104, !13, i64 112, !13, i64 120, !13, i64 128, !13, i64 136, !240, i64 144, !3, i64 160, !13, i64 168, !8, i64 176}
!240 = !{!"fpu", !8, i64 0, !8, i64 4, !3, i64 8}
!241 = !{!"", !4, i64 0}
!242 = !{!"sigpending", !11, i64 0, !241, i64 16}
!243 = !{!"seccomp", !8, i64 0, !3, i64 8}
!244 = !{!"plist_head", !11, i64 0}
!245 = !{!"task_io_accounting", !34, i64 0, !34, i64 8, !34, i64 16, !34, i64 24, !34, i64 32, !34, i64 40, !34, i64 48}
!246 = !{!"seqcount", !8, i64 0}
!247 = !{!"callback_head", !3, i64 0, !3, i64 8}
!248 = !{!"page_frag", !3, i64 0, !8, i64 8, !8, i64 12}
!249 = !{!"memcg_batch_info", !8, i64 0, !3, i64 8, !13, i64 16, !13, i64 24}
!250 = !{i32 387817, i32 387828}
!251 = !{!252, !43, i64 64}
!252 = !{!"pci_dev", !11, i64 0, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !8, i64 56, !43, i64 60, !43, i64 62, !43, i64 64, !43, i64 66, !8, i64 68, !4, i64 72, !4, i64 73, !4, i64 74, !4, i64 75, !4, i64 76, !4, i64 77, !4, i64 78, !4, i64 79, !43, i64 80, !3, i64 88, !34, i64 96, !253, i64 104, !8, i64 120, !4, i64 124, !8, i64 125, !8, i64 125, !8, i64 125, !8, i64 125, !8, i64 126, !8, i64 126, !8, i64 126, !8, i64 126, !8, i64 126, !8, i64 126, !8, i64 126, !8, i64 128, !8, i64 132, !3, i64 136, !8, i64 144, !254, i64 152, !8, i64 1288, !8, i64 1292, !4, i64 1296, !259, i64 2248, !8, i64 2249, !8, i64 2249, !8, i64 2249, !8, i64 2249, !8, i64 2249, !8, i64 2249, !8, i64 2249, !8, i64 2249, !8, i64 2250, !8, i64 2250, !8, i64 2250, !8, i64 2250, !8, i64 2250, !8, i64 2250, !8, i64 2250, !8, i64 2251, !8, i64 2251, !8, i64 2251, !8, i64 2251, !8, i64 2251, !8, i64 2251, !8, i64 2251, !8, i64 2251, !43, i64 2252, !20, i64 2256, !4, i64 2260, !49, i64 2328, !3, i64 2336, !8, i64 2344, !4, i64 2352, !4, i64 2488, !11, i64 2624, !3, i64 2640, !3, i64 2648, !4, i64 2656, !3, i64 2664, !34, i64 2672, !13, i64 2680}
!253 = !{!"device_dma_parameters", !8, i64 0, !13, i64 8}
!254 = !{!"device", !3, i64 0, !3, i64 8, !255, i64 16, !3, i64 80, !3, i64 88, !21, i64 96, !3, i64 264, !3, i64 272, !3, i64 280, !257, i64 288, !3, i64 880, !8, i64 888, !3, i64 896, !34, i64 904, !3, i64 912, !11, i64 920, !3, i64 936, !263, i64 944, !3, i64 960, !264, i64 968, !8, i64 976, !8, i64 980, !18, i64 984, !11, i64 1056, !265, i64 1072, !3, i64 1104, !3, i64 1112, !3, i64 1120, !3, i64 1128}
!255 = !{!"kobject", !3, i64 0, !11, i64 8, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !256, i64 56, !8, i64 60, !8, i64 60, !8, i64 60, !8, i64 60, !8, i64 60}
!256 = !{!"kref", !20, i64 0}
!257 = !{!"dev_pm_info", !258, i64 0, !8, i64 4, !8, i64 4, !259, i64 4, !259, i64 4, !259, i64 4, !259, i64 4, !18, i64 8, !11, i64 80, !260, i64 96, !3, i64 192, !259, i64 200, !259, i64 200, !261, i64 208, !13, i64 336, !262, i64 344, !19, i64 424, !20, i64 512, !20, i64 516, !8, i64 520, !8, i64 520, !8, i64 520, !8, i64 520, !8, i64 520, !8, i64 520, !8, i64 521, !8, i64 521, !8, i64 521, !8, i64 521, !8, i64 521, !4, i64 524, !4, i64 528, !8, i64 532, !8, i64 536, !13, i64 544, !13, i64 552, !13, i64 560, !13, i64 568, !3, i64 576, !3, i64 584}
!258 = !{!"pm_message", !8, i64 0}
!259 = !{!"_Bool", !4, i64 0}
!260 = !{!"completion", !8, i64 0, !19, i64 8}
!261 = !{!"timer_list", !11, i64 0, !13, i64 16, !3, i64 24, !3, i64 32, !13, i64 40, !8, i64 48, !8, i64 52, !3, i64 56, !4, i64 64, !16, i64 80}
!262 = !{!"work_struct", !33, i64 0, !11, i64 8, !3, i64 24, !16, i64 32}
!263 = !{!"dev_archdata", !3, i64 0, !3, i64 8}
!264 = !{!"acpi_dev_node", !3, i64 0}
!265 = !{!"klist_node", !3, i64 0, !11, i64 8, !256, i64 24}
!266 = !{!252, !43, i64 66}
!267 = !{!268, !43, i64 0}
!268 = !{!"snd_pci_quirk", !43, i64 0, !43, i64 2, !43, i64 4, !8, i64 8, !3, i64 16}
!269 = !{!268, !43, i64 2}
!270 = !{!268, !43, i64 4}
!271 = !{!272, !3, i64 0}
!272 = !{!"va_format", !3, i64 0, !3, i64 8}
!273 = !{!272, !3, i64 8}
!274 = !{!113, !8, i64 24}
!275 = !{!113, !3, i64 40}
!276 = !{!277, !3, i64 8}
!277 = !{!"snd_device_ops", !3, i64 0, !3, i64 8, !3, i64 16}
!278 = !{!277, !3, i64 16}
!279 = !{!277, !3, i64 0}
!280 = !{!113, !3, i64 16}
!281 = !{!113, !8, i64 28}
!282 = !{i32 -2145569076}
!283 = !{i32 -2145568874}
!284 = !{i32 -2146208065, i32 -2146208026, i32 -2146208005, i32 -2146207968, i32 -2146207945, i32 -2146208075}
!285 = !{!286, !3, i64 56}
!286 = !{!"link_master", !11, i64 0, !287, i64 16, !8, i64 32, !4, i64 36, !3, i64 56, !3, i64 64}
!287 = !{!"link_ctl_info", !8, i64 0, !8, i64 4, !8, i64 8, !8, i64 12}
!288 = !{!286, !3, i64 64}
!289 = !{!286, !8, i64 32}
!290 = !{!286, !8, i64 16}
!291 = !{!286, !8, i64 20}
!292 = !{!286, !8, i64 24}
!293 = !{!286, !8, i64 28}
!294 = !{!295, !3, i64 0}
!295 = !{!"link_slave", !11, i64 0, !3, i64 16, !287, i64 24, !4, i64 40, !8, i64 48, !3, i64 56, !125, i64 64}
!296 = !{!295, !3, i64 56}
!297 = !{i64 0, i64 8, !2, i64 8, i64 8, !2}
!298 = !{i64 0, i64 4, !25, i64 4, i64 4, !25, i64 8, i64 4, !25, i64 12, i64 4, !25}
!299 = !{!295, !8, i64 28}
!300 = !{!295, !3, i64 16}
!301 = !{!295, !8, i64 24}
!302 = !{!295, !8, i64 32}
!303 = !{!295, !8, i64 36}
!304 = !{!295, !3, i64 168}
!305 = !{!295, !8, i64 48}
!306 = !{!295, !3, i64 152}
!307 = !{!295, !3, i64 160}
!308 = !{!295, !3, i64 200}
!309 = !{!310, !8, i64 12}
!310 = !{!"snd_jack", !3, i64 0, !8, i64 8, !8, i64 12, !3, i64 16, !4, i64 24, !4, i64 124, !3, i64 152, !3, i64 160}
!311 = !{!310, !3, i64 0}
!312 = !{!310, !8, i64 8}
!313 = !{i32 358712}
!314 = !{!315, !3, i64 824}
!315 = !{!"input_dev", !3, i64 0, !3, i64 8, !3, i64 16, !316, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184, !4, i64 200, !8, i64 208, !8, i64 212, !8, i64 216, !3, i64 224, !3, i64 232, !3, i64 240, !3, i64 248, !8, i64 256, !261, i64 264, !4, i64 392, !3, i64 400, !3, i64 408, !4, i64 416, !4, i64 512, !4, i64 520, !4, i64 528, !3, i64 536, !3, i64 544, !3, i64 552, !3, i64 560, !3, i64 568, !18, i64 576, !21, i64 648, !8, i64 816, !259, i64 820, !254, i64 824, !11, i64 1960, !11, i64 1976, !8, i64 1992, !8, i64 1996, !3, i64 2000, !259, i64 2008}
!316 = !{!"input_id", !43, i64 0, !43, i64 2, !43, i64 4, !43, i64 6}
!317 = !{!310, !3, i64 16}
!318 = !{!315, !3, i64 8}
!319 = !{!310, !3, i64 160}
!320 = !{!315, !3, i64 0}
