; ModuleID = 'tests/regression/kernel_modules/snd/snd_new.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm "\09.section \22___kcrctab+snd_major\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_major\09"
module asm "\09.long\09__crc_snd_major\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ecards_limit\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ecards_limit\09"
module asm "\09.long\09__crc_snd_ecards_limit\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_request_card\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_request_card\09"
module asm "\09.long\09__crc_snd_request_card\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_lookup_minor_data\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_lookup_minor_data\09"
module asm "\09.long\09__crc_snd_lookup_minor_data\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_register_device\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_register_device\09"
module asm "\09.long\09__crc_snd_register_device\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_unregister_device\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_unregister_device\09"
module asm "\09.long\09__crc_snd_unregister_device\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_cards\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_cards\09"
module asm "\09.long\09__crc_snd_cards\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_mixer_oss_notify_callback\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_mixer_oss_notify_callback\09"
module asm "\09.long\09__crc_snd_mixer_oss_notify_callback\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+snd_device_initialize\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_device_initialize\09"
module asm "\09.long\09__crc_snd_device_initialize\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_card_new\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_card_new\09"
module asm "\09.long\09__crc_snd_card_new\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_card_disconnect\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_card_disconnect\09"
module asm "\09.long\09__crc_snd_card_disconnect\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_card_free_when_closed\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_card_free_when_closed\09"
module asm "\09.long\09__crc_snd_card_free_when_closed\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_card_free\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_card_free\09"
module asm "\09.long\09__crc_snd_card_free\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_card_set_id\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_card_set_id\09"
module asm "\09.long\09__crc_snd_card_set_id\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+snd_card_add_dev_attr\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_card_add_dev_attr\09"
module asm "\09.long\09__crc_snd_card_add_dev_attr\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_card_register\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_card_register\09"
module asm "\09.long\09__crc_snd_card_register\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_component_add\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_component_add\09"
module asm "\09.long\09__crc_snd_component_add\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_card_file_add\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_card_file_add\09"
module asm "\09.long\09__crc_snd_card_file_add\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_card_file_remove\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_card_file_remove\09"
module asm "\09.long\09__crc_snd_card_file_remove\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_power_wait\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_power_wait\09"
module asm "\09.long\09__crc_snd_power_wait\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+copy_to_user_fromio\22, \22a\22\09"
module asm "\09.weak\09__crc_copy_to_user_fromio\09"
module asm "\09.long\09__crc_copy_to_user_fromio\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+copy_from_user_toio\22, \22a\22\09"
module asm "\09.weak\09__crc_copy_from_user_toio\09"
module asm "\09.long\09__crc_copy_from_user_toio\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_notify\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_notify\09"
module asm "\09.long\09__crc_snd_ctl_notify\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_new1\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_new1\09"
module asm "\09.long\09__crc_snd_ctl_new1\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_free_one\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_free_one\09"
module asm "\09.long\09__crc_snd_ctl_free_one\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_add\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_add\09"
module asm "\09.long\09__crc_snd_ctl_add\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_replace\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_replace\09"
module asm "\09.long\09__crc_snd_ctl_replace\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_remove\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_remove\09"
module asm "\09.long\09__crc_snd_ctl_remove\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_remove_id\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_remove_id\09"
module asm "\09.long\09__crc_snd_ctl_remove_id\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+snd_ctl_activate_id\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_activate_id\09"
module asm "\09.long\09__crc_snd_ctl_activate_id\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_rename_id\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_rename_id\09"
module asm "\09.long\09__crc_snd_ctl_rename_id\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_find_numid\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_find_numid\09"
module asm "\09.long\09__crc_snd_ctl_find_numid\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_find_id\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_find_id\09"
module asm "\09.long\09__crc_snd_ctl_find_id\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_register_ioctl\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_register_ioctl\09"
module asm "\09.long\09__crc_snd_ctl_register_ioctl\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_register_ioctl_compat\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_register_ioctl_compat\09"
module asm "\09.long\09__crc_snd_ctl_register_ioctl_compat\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_unregister_ioctl\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_unregister_ioctl\09"
module asm "\09.long\09__crc_snd_ctl_unregister_ioctl\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_unregister_ioctl_compat\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_unregister_ioctl_compat\09"
module asm "\09.long\09__crc_snd_ctl_unregister_ioctl_compat\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+snd_ctl_get_preferred_subdevice\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_get_preferred_subdevice\09"
module asm "\09.long\09__crc_snd_ctl_get_preferred_subdevice\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_boolean_mono_info\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_boolean_mono_info\09"
module asm "\09.long\09__crc_snd_ctl_boolean_mono_info\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_boolean_stereo_info\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_boolean_stereo_info\09"
module asm "\09.long\09__crc_snd_ctl_boolean_stereo_info\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_enum_info\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_enum_info\09"
module asm "\09.long\09__crc_snd_ctl_enum_info\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+release_and_free_resource\22, \22a\22\09"
module asm "\09.weak\09__crc_release_and_free_resource\09"
module asm "\09.long\09__crc_release_and_free_resource\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+__snd_printk\22, \22a\22\09"
module asm "\09.weak\09__crc___snd_printk\09"
module asm "\09.long\09__crc___snd_printk\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_pci_quirk_lookup_id\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_pci_quirk_lookup_id\09"
module asm "\09.long\09__crc_snd_pci_quirk_lookup_id\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_pci_quirk_lookup\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_pci_quirk_lookup\09"
module asm "\09.long\09__crc_snd_pci_quirk_lookup\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_device_new\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_device_new\09"
module asm "\09.long\09__crc_snd_device_new\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+snd_device_disconnect\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_device_disconnect\09"
module asm "\09.long\09__crc_snd_device_disconnect\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_device_free\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_device_free\09"
module asm "\09.long\09__crc_snd_device_free\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_device_register\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_device_register\09"
module asm "\09.long\09__crc_snd_device_register\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_seq_root\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_seq_root\09"
module asm "\09.long\09__crc_snd_seq_root\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_info_get_line\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_info_get_line\09"
module asm "\09.long\09__crc_snd_info_get_line\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_info_get_str\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_info_get_str\09"
module asm "\09.long\09__crc_snd_info_get_str\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_info_create_module_entry\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_info_create_module_entry\09"
module asm "\09.long\09__crc_snd_info_create_module_entry\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_info_create_card_entry\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_info_create_card_entry\09"
module asm "\09.long\09__crc_snd_info_create_card_entry\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_info_free_entry\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_info_free_entry\09"
module asm "\09.long\09__crc_snd_info_free_entry\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_info_register\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_info_register\09"
module asm "\09.long\09__crc_snd_info_register\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_oss_info_register\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_oss_info_register\09"
module asm "\09.long\09__crc_snd_oss_info_register\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_dma_program\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_dma_program\09"
module asm "\09.long\09__crc_snd_dma_program\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_dma_disable\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_dma_disable\09"
module asm "\09.long\09__crc_snd_dma_disable\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_dma_pointer\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_dma_pointer\09"
module asm "\09.long\09__crc_snd_dma_pointer\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_lookup_oss_minor_data\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_lookup_oss_minor_data\09"
module asm "\09.long\09__crc_snd_lookup_oss_minor_data\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_register_oss_device\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_register_oss_device\09"
module asm "\09.long\09__crc_snd_register_oss_device\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_unregister_oss_device\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_unregister_oss_device\09"
module asm "\09.long\09__crc_snd_unregister_oss_device\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+_snd_ctl_add_slave\22, \22a\22\09"
module asm "\09.weak\09__crc__snd_ctl_add_slave\09"
module asm "\09.long\09__crc__snd_ctl_add_slave\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_ctl_make_virtual_master\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_make_virtual_master\09"
module asm "\09.long\09__crc_snd_ctl_make_virtual_master\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+snd_ctl_add_vmaster_hook\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_add_vmaster_hook\09"
module asm "\09.long\09__crc_snd_ctl_add_vmaster_hook\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab_gpl+snd_ctl_sync_vmaster\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_ctl_sync_vmaster\09"
module asm "\09.long\09__crc_snd_ctl_sync_vmaster\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_jack_add_new_kctl\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_jack_add_new_kctl\09"
module asm "\09.long\09__crc_snd_jack_add_new_kctl\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_jack_new\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_jack_new\09"
module asm "\09.long\09__crc_snd_jack_new\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_jack_set_parent\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_jack_set_parent\09"
module asm "\09.long\09__crc_snd_jack_set_parent\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_jack_set_key\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_jack_set_key\09"
module asm "\09.long\09__crc_snd_jack_set_key\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+snd_jack_report\22, \22a\22\09"
module asm "\09.weak\09__crc_snd_jack_report\09"
module asm "\09.long\09__crc_snd_jack_report\09"
module asm "\09.previous\09\09\09\09\09"

%struct.kernel_symbol = type { i64, i8* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %union.anon.3, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.0, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %union.anon.3, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %struct.qspinlock, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.3, %union.anon.3, %union.anon.0, %union.anon.3, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.atomic_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %union.anon.3, %struct.list_head, %struct.raw_spinlock, %struct.qspinlock, %struct.task_struct*, %struct.lockdep_map }
%struct.task_struct = type { %union.anon.3, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %union.anon.0, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.atomic_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %union.anon.3*, %struct.atomic_t, %struct.atomic_t, %union.anon.3, %union.anon.3, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %union.anon.3, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %union.anon.3, i64, %struct.timerqueue_node, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.mm_rss_stat = type { [4 x %union.anon.3] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.cgroup_namespace* }
%struct.uts_namespace = type { %struct.kref, %struct.new_utsname, %struct.user_namespace*, %struct.ucounts*, %struct.ns_common }
%struct.new_utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.ucounts = type opaque
%struct.ns_common = type { %union.anon.3, %struct.proc_ns_operations*, i32 }
%struct.proc_ns_operations = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.cgroup_namespace = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.timespec], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.timespec], %struct.pacct_struct, %struct.taskstats*, i32, %struct.tty_audit_buf*, i8, i16, i16, %struct.mm_struct*, %struct.mutex }
%struct.timespec = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic, i8, i8 }
%struct.task_cputime_atomic = type { %union.anon.3, %union.anon.3, %union.anon.3 }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.seqlock_t = type { %struct.seqcount, %struct.spinlock }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.12 }
%union.anon.12 = type { %struct.anon.16, [80 x i8] }
%struct.anon.16 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.atomic_t, i32, i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.22, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.22 = type { %struct.anon.23 }
%struct.anon.23 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %union.anon.3, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.timespec }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %union.anon.3* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %union.anon.3, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.0 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.atomic_t, %struct.atomic_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.2, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.bdi_writeback = type opaque
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type { i32, i64, i64, %union.anon.71, %union.anon.3 }
%union.anon.71 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.3 = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.atomic_t, %struct.atomic_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.3, i64, %struct.atomic_t, %struct.atomic_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.3, i64, i64, i64, %union.anon.3, %struct.key*, %struct.key*, %struct.hlist_node, %struct.atomic_t, %union.anon.3 }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.atomic_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %union.anon.3*, %union.anon.3*, %union.anon.3, %struct.page*, %struct.mem_cgroup*, %struct.page*, %union.anon.3*, %struct.spinlock*, %struct.page* }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.qspinlock }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %union.anon.3, %struct.spinlock, %struct.qspinlock, %struct.list_head, i8*, %struct.lockdep_map }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.qspinlock, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.51 = type { i8* }
%struct.snd_minor = type { i32, i32, i32, %struct.file_operations*, i8*, %struct.device*, %struct.snd_card* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %union.anon.51, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.atomic_t, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.device_node = type opaque
%struct.fwnode_handle = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.snd_card = type { i32, [16 x i8], [16 x i8], [32 x i8], [80 x i8], [32 x i8], [80 x i8], [128 x i8], %struct.module*, i8*, void (%struct.snd_card*)*, %struct.list_head, %struct.device, i32, %struct.rw_semaphore, %struct.rwlock_t, i32, i32, %struct.list_head, %struct.list_head, %struct.mutex, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.proc_dir_entry*, %struct.list_head, %struct.snd_shutdown_f_ops*, %struct.spinlock, i32, %struct.completion*, %struct.device*, %struct.device, [4 x %struct.attribute_group*], i8, i32, %struct.mutex, %struct.__wait_queue_head, %struct.snd_mixer_oss*, i32 }
%struct.snd_info_entry = type { i8*, i16, i64, i16, %union.anon.58, %struct.snd_info_entry*, %struct.snd_card*, %struct.module*, i8*, void (%struct.snd_info_entry*)*, %struct.proc_dir_entry*, %struct.mutex, %struct.list_head, %struct.list_head }
%union.anon.58 = type { %struct.snd_info_entry_text }
%struct.snd_info_entry_text = type { void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* }
%struct.snd_info_buffer = type { i8*, i32, i32, i32, i32, i32 }
%struct.proc_dir_entry = type opaque
%struct.snd_shutdown_f_ops = type opaque
%struct.snd_mixer_oss = type opaque
%struct.kparam_array = type { i32, i32, i32*, %struct.kernel_param_ops*, i8* }
%struct.snd_device_ops = type { i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)* }
%struct.snd_device = type { %struct.list_head, %struct.snd_card*, i32, i32, i8*, %struct.snd_device_ops* }
%struct.snd_kcontrol_new = type { i32, i32, i32, i8*, i32, i32, i32, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, %union.anon.69, i64 }
%struct.snd_kcontrol = type { %struct.list_head, %struct.snd_ctl_elem_id, i32, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, %union.anon.69, i64, i8*, void (%struct.snd_kcontrol*)*, [0 x %struct.snd_kcontrol_volatile] }
%struct.snd_ctl_elem_id = type { i32, i32, i32, i32, [44 x i8], i32 }
%struct.snd_kcontrol_volatile = type { %struct.snd_ctl_file*, i32 }
%struct.snd_ctl_file = type { %struct.list_head, %struct.snd_card*, %struct.pid*, [2 x i32], %struct.__wait_queue_head, %struct.spinlock, %struct.fasync_struct*, i32, %struct.list_head }
%struct.snd_ctl_elem_info = type { %struct.snd_ctl_elem_id, i32, i32, i32, i32, %union.anon.59, %union.anon.63, [56 x i8] }
%union.anon.59 = type { %struct.anon.62, [40 x i8] }
%struct.anon.62 = type { i32, i32, [64 x i8], i64, i32 }
%union.anon.63 = type { i16* }
%struct.snd_ctl_elem_value = type { %struct.snd_ctl_elem_id, i8, %union.anon.64, %struct.timespec, [112 x i8] }
%union.anon.64 = type { %struct.cpumask }
%union.anon.69 = type { i32 (%struct.snd_kcontrol*, i32, i32, i32*)* }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.snd_monitor_file = type { %struct.file*, %struct.file_operations*, %struct.list_head, %struct.list_head }
%union.anon.61 = type { %struct.list_head* }
%struct._ddebug = type { i8*, i8*, i8*, i8*, i32 }
%struct.snd_kctl_ioctl = type { %struct.list_head, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* }
%struct.snd_kctl_event = type { %struct.list_head, %struct.snd_ctl_elem_id, i32 }
%struct.snd_ctl_event = type { i32, %union.anon.77 }
%union.anon.77 = type { %struct.anon.78 }
%struct.anon.78 = type { i32, %struct.snd_ctl_elem_id }
%struct.snd_ctl_elem_list = type { i32, i32, i32, i32, %struct.snd_ctl_elem_id*, [50 x i8] }
%struct.snd_ctl_tlv = type { i32, i32, [0 x i32] }
%struct.snd_ctl_elem_list32 = type { i32, i32, i32, i32, i32, [50 x i8] }
%struct.snd_ctl_elem_info32 = type { %struct.snd_ctl_elem_id, i32, i32, i32, i32, %union.anon.59, [64 x i8] }
%struct.snd_ctl_elem_value32 = type { %struct.snd_ctl_elem_id, i32, %union.anon.83, [128 x i8] }
%union.anon.83 = type { [128 x i32] }
%struct.snd_ctl_elem_value_x32 = type { %struct.snd_ctl_elem_id, i32, %union.anon.84, [128 x i8] }
%union.anon.84 = type { [64 x i64] }
%union.anon.68 = type { i8*, [504 x i8] }
%struct.user_element = type { %struct.snd_ctl_elem_info, %struct.snd_card*, i8*, i64, i8*, i64, i8* }
%struct.snd_ctl_card_info = type { i32, i32, [16 x i8], [16 x i8], [32 x i8], [80 x i8], [16 x i8], [80 x i8], [128 x i8] }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i16, i8, i8, i8, i8, i8, i8, i16, [4 x i8], i64*, %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, [3 x i8], i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, i32, i8, i16, %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], i8, i8, [6 x i8], %struct.attribute_group**, %struct.pci_vpd*, %union.anon.52.658, i16, i8, i8, %struct.atomic_t, i64, i64, i8* }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, %struct.msi_controller*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*)*, void (%struct.pci_bus*)*, i8* (%struct.pci_bus*, i32, i32)*, i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.msi_controller = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.__wait_queue_head }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*, i1)*, void (%struct.pci_dev*)* }
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.52.658 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.snd_pci_quirk = type { i16, i16, i16, i32, i8* }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.va_format = type { i8*, [1 x %struct.__va_list_tag]* }
%struct.snd_info_private_data = type { %struct.snd_info_buffer*, %struct.snd_info_buffer*, %struct.snd_info_entry*, i8* }
%struct.snd_info_entry_ops = type { i32 (%struct.snd_info_entry*, i16, i8**)*, i32 (%struct.snd_info_entry*, i16, i8*)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)*, i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)* }
%struct.link_master = type { %struct.list_head, %struct.link_ctl_info, i32, [4 x i32], void (i8*, i32)*, i8* }
%struct.link_ctl_info = type { i32, i32, i32, i32 }
%struct.link_slave = type { %struct.list_head, %struct.link_master*, %struct.link_ctl_info, [2 x i32], i32, %struct.snd_kcontrol*, %struct.snd_kcontrol }
%struct.snd_jack = type { %struct.list_head, %struct.snd_card*, i8*, %struct.input_dev*, i32, i32, [100 x i8], [6 x i32], i8*, void (%struct.snd_jack*)* }
%struct.input_dev = type { i8*, i8*, i8*, %struct.input_id, [1 x i64], [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i32, i32, i32, i8*, i32 (%struct.input_dev*, %struct.input_keymap_entry*, i32*)*, i32 (%struct.input_dev*, %struct.input_keymap_entry*)*, %struct.ff_device*, i32, %struct.timer_list, [2 x i32], %struct.input_mt*, %struct.input_absinfo*, [12 x i64], [1 x i64], [1 x i64], [1 x i64], i32 (%struct.input_dev*)*, void (%struct.input_dev*)*, i32 (%struct.input_dev*, %struct.file*)*, i32 (%struct.input_dev*, i32, i32, i32)*, %struct.input_handle*, %struct.spinlock, %struct.mutex, i32, i8, %struct.device, %struct.list_head, %struct.list_head, i32, i32, %struct.input_value*, i8 }
%struct.input_id = type { i16, i16, i16, i16 }
%struct.input_keymap_entry = type { i8, i8, i16, i32, [32 x i8] }
%struct.ff_device = type { i32 (%struct.input_dev*, %struct.ff_effect*, %struct.ff_effect*)*, i32 (%struct.input_dev*, i32)*, i32 (%struct.input_dev*, i32, i32)*, void (%struct.input_dev*, i16)*, void (%struct.input_dev*, i16)*, void (%struct.ff_device*)*, i8*, [2 x i64], %struct.mutex, i32, %struct.ff_effect*, [0 x %struct.file*] }
%struct.ff_effect = type { i16, i16, i16, %struct.ff_trigger, %struct.ff_trigger, %union.anon.52.3036 }
%struct.ff_trigger = type { i16, i16 }
%union.anon.52.3036 = type { %struct.ff_periodic_effect }
%struct.ff_periodic_effect = type { i16, i16, i16, i16, i16, %struct.input_id, i32, i16* }
%struct.input_mt = type opaque
%struct.input_absinfo = type { i32, i32, i32, i32, i32, i32 }
%struct.input_handle = type { i8*, i32, i8*, %struct.input_dev*, %struct.input_handler*, %struct.list_head, %struct.list_head }
%struct.input_handler = type { i8*, void (%struct.input_handle*, i32, i32, i32)*, void (%struct.input_handle*, %struct.input_value*, i32)*, i1 (%struct.input_handle*, i32, i32, i32)*, i1 (%struct.input_handler*, %struct.input_dev*)*, i32 (%struct.input_handler*, %struct.input_dev*, %struct.input_device_id*)*, void (%struct.input_handle*)*, void (%struct.input_handle*)*, i8, i32, i8*, %struct.input_device_id*, %struct.list_head, %struct.list_head }
%struct.input_device_id = type { i64, i16, i16, i16, i16, [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i64 }
%struct.input_value = type { i16, i16, i32 }
%struct.snd_jack_kctl = type { %struct.snd_kcontrol*, %struct.list_head, i32 }

@snd_major = common global i32 0, align 4
@snd_ecards_limit = common global i32 0, align 4
@llvm.used = appending global [88 x i8*] [i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_major to i8*), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__UNIQUE_ID_author8, i32 0, i32 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @__UNIQUE_ID_description9, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license10, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_major to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_majortype11, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__UNIQUE_ID_major12, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_cards_limit to i8*), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__UNIQUE_ID_cards_limittype13, i32 0, i32 0), i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__UNIQUE_ID_cards_limit14, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__UNIQUE_ID_alias15, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ecards_limit to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_request_card to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_lookup_minor_data to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_register_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_unregister_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_cards to i8*), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_slots to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_slotstype8, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @__UNIQUE_ID_slots9, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_mixer_oss_notify_callback to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_device_initialize to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_new to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_disconnect to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_free_when_closed to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_free to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_set_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_add_dev_attr to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_component_add to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_file_add to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_file_remove to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_power_wait to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_copy_to_user_fromio to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_copy_from_user_toio to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_notify to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_new1 to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_free_one to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_add to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_replace to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_remove to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_remove_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_activate_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_rename_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_find_numid to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_find_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_register_ioctl to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_register_ioctl_compat to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_unregister_ioctl to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_unregister_ioctl_compat to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_get_preferred_subdevice to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_boolean_mono_info to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_boolean_stereo_info to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_enum_info to i8*), i8* bitcast (%struct.kernel_param* @__param_debug to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_debugtype8, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__UNIQUE_ID_debug9, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_release_and_free_resource to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab___snd_printk to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_pci_quirk_lookup_id to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_pci_quirk_lookup to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_device_new to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_device_disconnect to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_device_free to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_device_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_seq_root to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_get_line to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_get_str to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_create_module_entry to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_create_card_entry to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_free_entry to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_oss_info_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_dma_program to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_dma_disable to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_dma_pointer to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_lookup_oss_minor_data to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_register_oss_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_unregister_oss_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab__snd_ctl_add_slave to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_make_virtual_master to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_add_vmaster_hook to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ctl_sync_vmaster to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_jack_add_new_kctl to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_jack_new to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_jack_set_parent to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_jack_set_key to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_jack_report to i8*)], section "llvm.metadata"
@__ksymtab_snd_major = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @snd_major to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_snd_major, i32 0, i32 0) }, section "___ksymtab+snd_major", align 8
@__UNIQUE_ID_author8 = internal constant [40 x i8] c"author=Jaroslav Kysela <perex@perex.cz>\00", section ".modinfo", align 1
@__UNIQUE_ID_description9 = internal constant [69 x i8] c"description=Advanced Linux Sound Architecture driver for soundcards.\00", section ".modinfo", align 1
@__UNIQUE_ID_license10 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__param_major = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_major, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @major to i8*) } }, section "__param", align 8
@__UNIQUE_ID_majortype11 = internal constant [19 x i8] c"parmtype=major:int\00", section ".modinfo", align 1
@__UNIQUE_ID_major12 = internal constant [37 x i8] c"parm=major:Major # for sound driver.\00", section ".modinfo", align 1
@__param_cards_limit = internal constant %struct.kernel_param { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__param_str_cards_limit, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @cards_limit to i8*) } }, section "__param", align 8
@__UNIQUE_ID_cards_limittype13 = internal constant [25 x i8] c"parmtype=cards_limit:int\00", section ".modinfo", align 1
@__UNIQUE_ID_cards_limit14 = internal constant [52 x i8] c"parm=cards_limit:Count of auto-loadable soundcards.\00", section ".modinfo", align 1
@__UNIQUE_ID_alias15 = internal constant [23 x i8] c"alias=char-major-116-*\00", section ".modinfo", align 1
@__ksymtab_snd_ecards_limit = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @snd_ecards_limit to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_ecards_limit, i32 0, i32 0) }, section "___ksymtab+snd_ecards_limit", align 8
@__ksymtab_snd_request_card = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i32)* @snd_request_card to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_request_card, i32 0, i32 0) }, section "___ksymtab+snd_request_card", align 8
@__ksymtab_snd_lookup_minor_data = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (i32, i32)* @snd_lookup_minor_data to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_lookup_minor_data, i32 0, i32 0) }, section "___ksymtab+snd_lookup_minor_data", align 8
@__ksymtab_snd_register_device = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32, %struct.file_operations*, i8*, %struct.device*)* @snd_register_device to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_register_device, i32 0, i32 0) }, section "___ksymtab+snd_register_device", align 8
@__ksymtab_snd_unregister_device = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.device*)* @snd_unregister_device to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_unregister_device, i32 0, i32 0) }, section "___ksymtab+snd_unregister_device", align 8
@__kstrtab_snd_unregister_device = internal constant [22 x i8] c"snd_unregister_device\00", section "__ksymtab_strings", align 1
@sound_mutex = internal global %struct.mutex { %union.anon.3 zeroinitializer, %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.3, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.qspinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @sound_mutex to i8*), i64 88) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @sound_mutex to i8*), i64 88) to %struct.list_head*) }, i8* bitcast (%struct.mutex* @sound_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.4, i32 0, i32 0), i32 0, i64 0 } }, align 8
@snd_minors = internal global [256 x %struct.snd_minor*] zeroinitializer, align 16
@.str.3 = private unnamed_addr constant [22 x i8] c"sound_mutex.wait_lock\00", align 1
@.str.4 = private unnamed_addr constant [12 x i8] c"sound_mutex\00", align 1
@__kstrtab_snd_register_device = internal constant [20 x i8] c"snd_register_device\00", section "__ksymtab_strings", align 1
@.str.1 = private unnamed_addr constant [19 x i8] c"sound/core/sound.c\00", align 1
@major = internal global i32 116, align 4
@__kstrtab_snd_lookup_minor_data = internal constant [22 x i8] c"snd_lookup_minor_data\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_request_card = internal constant [17 x i8] c"snd_request_card\00", section "__ksymtab_strings", align 1
@cards_limit = internal global i32 1, align 4
@.str = private unnamed_addr constant [12 x i8] c"snd-card-%i\00", align 1
@__kstrtab_snd_ecards_limit = internal constant [17 x i8] c"snd_ecards_limit\00", section "__ksymtab_strings", align 1
@__param_str_cards_limit = internal constant [12 x i8] c"cards_limit\00", align 1
@__this_module = external global %struct.module, align 64
@param_ops_int = external constant %struct.kernel_param_ops, align 8
@__param_str_major = internal constant [6 x i8] c"major\00", align 1
@__kstrtab_snd_major = internal constant [10 x i8] c"snd_major\00", section "__ksymtab_strings", align 1
@.str.5 = private unnamed_addr constant [20 x i8] c"%3i: [%2i-%2i]: %s\0A\00", align 1
@.str.6 = private unnamed_addr constant [19 x i8] c"%3i: [%2i]   : %s\0A\00", align 1
@.str.7 = private unnamed_addr constant [18 x i8] c"%3i:        : %s\0A\00", align 1
@.str.14 = private unnamed_addr constant [6 x i8] c"timer\00", align 1
@.str.8 = private unnamed_addr constant [8 x i8] c"control\00", align 1
@.str.11 = private unnamed_addr constant [23 x i8] c"digital audio playback\00", align 1
@.str.12 = private unnamed_addr constant [22 x i8] c"digital audio capture\00", align 1
@.str.16 = private unnamed_addr constant [5 x i8] c"alsa\00", align 1
@snd_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @noop_llseek, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @snd_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.17 = private unnamed_addr constant [63 x i8] c"\013ALSA core: unable to register native major device number %d\0A\00", align 1
@.str.18 = private unnamed_addr constant [8 x i8] c"snd-seq\00", align 1
@.str.19 = private unnamed_addr constant [10 x i8] c"snd-timer\00", align 1
@snd_cards = common global [32 x %struct.snd_card*] zeroinitializer, align 16
@snd_mixer_oss_notify_callback = common global i32 (%struct.snd_card*, i32)* null, align 8
@__ksymtab_snd_cards = internal constant %struct.kernel_symbol { i64 ptrtoint ([32 x %struct.snd_card*]* @snd_cards to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_snd_cards, i32 0, i32 0) }, section "___ksymtab+snd_cards", align 8
@__param_slots = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_slots, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 292, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_slots } }, section "__param", align 8
@__UNIQUE_ID_slotstype8 = internal constant [30 x i8] c"parmtype=slots:array of charp\00", section ".modinfo", align 1
@__UNIQUE_ID_slots9 = internal constant [47 x i8] c"parm=slots:Module names assigned to the slots.\00", section ".modinfo", align 1
@__ksymtab_snd_mixer_oss_notify_callback = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback to i64), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__kstrtab_snd_mixer_oss_notify_callback, i32 0, i32 0) }, section "___ksymtab+snd_mixer_oss_notify_callback", align 8
@__ksymtab_snd_device_initialize = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.device*, %struct.snd_card*)* @snd_device_initialize to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_device_initialize, i32 0, i32 0) }, section "___ksymtab_gpl+snd_device_initialize", align 8
@__ksymtab_snd_card_new = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.device*, i32, i8*, %struct.module*, i32, %struct.snd_card**)* @snd_card_new to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_snd_card_new, i32 0, i32 0) }, section "___ksymtab+snd_card_new", align 8
@__ksymtab_snd_card_disconnect = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*)* @snd_card_disconnect to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_card_disconnect, i32 0, i32 0) }, section "___ksymtab+snd_card_disconnect", align 8
@__ksymtab_snd_card_free_when_closed = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*)* @snd_card_free_when_closed to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_card_free_when_closed, i32 0, i32 0) }, section "___ksymtab+snd_card_free_when_closed", align 8
@__ksymtab_snd_card_free = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*)* @snd_card_free to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_snd_card_free, i32 0, i32 0) }, section "___ksymtab+snd_card_free", align 8
@__ksymtab_snd_card_set_id = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_card*, i8*)* @snd_card_set_id to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_card_set_id, i32 0, i32 0) }, section "___ksymtab+snd_card_set_id", align 8
@__ksymtab_snd_card_add_dev_attr = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.attribute_group*)* @snd_card_add_dev_attr to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_card_add_dev_attr, i32 0, i32 0) }, section "___ksymtab_gpl+snd_card_add_dev_attr", align 8
@__ksymtab_snd_card_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*)* @snd_card_register to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_card_register, i32 0, i32 0) }, section "___ksymtab+snd_card_register", align 8
@__ksymtab_snd_component_add = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i8*)* @snd_component_add to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_component_add, i32 0, i32 0) }, section "___ksymtab+snd_component_add", align 8
@__ksymtab_snd_card_file_add = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.file*)* @snd_card_file_add to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_card_file_add, i32 0, i32 0) }, section "___ksymtab+snd_card_file_add", align 8
@__ksymtab_snd_card_file_remove = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.file*)* @snd_card_file_remove to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_snd_card_file_remove, i32 0, i32 0) }, section "___ksymtab+snd_card_file_remove", align 8
@__ksymtab_snd_power_wait = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i32)* @snd_power_wait to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_snd_power_wait, i32 0, i32 0) }, section "___ksymtab+snd_power_wait", align 8
@__kstrtab_snd_power_wait = internal constant [15 x i8] c"snd_power_wait\00", section "__ksymtab_strings", align 1
@current_task = external global %struct.task_struct*, align 8
@__kstrtab_snd_card_file_remove = internal constant [21 x i8] c"snd_card_file_remove\00", section "__ksymtab_strings", align 1
@shutdown_lock = internal global %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.28, i32 0, i32 0), i32 0, i64 0 } } } }, align 8
@.str.24 = private unnamed_addr constant [31 x i8] c"card file remove problem (%p)\0A\00", align 1
@.str.28 = private unnamed_addr constant [14 x i8] c"shutdown_lock\00", align 1
@__kstrtab_snd_card_file_add = internal constant [18 x i8] c"snd_card_file_add\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_component_add = internal constant [18 x i8] c"snd_component_add\00", section "__ksymtab_strings", align 1
@.str.20 = private unnamed_addr constant [18 x i8] c"sound/core/init.c\00", align 1
@.str.23 = private unnamed_addr constant [2 x i8] c" \00", align 1
@__kstrtab_snd_card_register = internal constant [18 x i8] c"snd_card_register\00", section "__ksymtab_strings", align 1
@snd_card_mutex = internal global %struct.mutex { %union.anon.3 zeroinitializer, %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.25, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.qspinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @snd_card_mutex to i8*), i64 88) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @snd_card_mutex to i8*), i64 88) to %struct.list_head*) }, i8* bitcast (%struct.mutex* @snd_card_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.26, i32 0, i32 0), i32 0, i64 0 } }, align 8
@.str.35 = private unnamed_addr constant [3 x i8] c"id\00", align 1
@init_info_for_card.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1.91, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.init_info_for_card, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.39, i32 0, i32 0), i8 116, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.39 = private unnamed_addr constant [29 x i8] c"unable to create card entry\0A\00", align 1
@.str.18.21 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@__func__.init_info_for_card = private unnamed_addr constant [19 x i8] c"init_info_for_card\00", align 1
@_ctype = external constant [0 x i8], align 1
@.str.32 = private unnamed_addr constant [8 x i8] c"Default\00", align 1
@.str.33 = private unnamed_addr constant [4 x i8] c"_%X\00", align 1
@.str.34 = private unnamed_addr constant [28 x i8] c"unable to set card id (%s)\0A\00", align 1
@.str.25 = private unnamed_addr constant [25 x i8] c"snd_card_mutex.wait_lock\00", align 1
@.str.26 = private unnamed_addr constant [15 x i8] c"snd_card_mutex\00", align 1
@__kstrtab_snd_card_add_dev_attr = internal constant [22 x i8] c"snd_card_add_dev_attr\00", section "__ksymtab_strings", align 1
@.str.17.22 = private unnamed_addr constant [26 x i8] c"Too many groups assigned\0A\00", align 1
@__kstrtab_snd_card_set_id = internal constant [16 x i8] c"snd_card_set_id\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_card_free = internal constant [14 x i8] c"snd_card_free\00", section "__ksymtab_strings", align 1
@snd_cards_lock = internal global [1 x i64] zeroinitializer, align 8
@shutdown_files = internal global %struct.list_head { %struct.list_head* @shutdown_files, %struct.list_head* @shutdown_files }, align 8
@snd_shutdown_f_ops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @snd_disconnect_llseek, i64 (%struct.file*, i8*, i64, i64*)* @snd_disconnect_read, i64 (%struct.file*, i8*, i64, i64*)* @snd_disconnect_write, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @snd_disconnect_poll, i64 (%struct.file*, i32, i64)* @snd_disconnect_ioctl, i64 (%struct.file*, i32, i64)* @snd_disconnect_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* @snd_disconnect_mmap, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @snd_disconnect_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* @snd_disconnect_fasync, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.29 = private unnamed_addr constant [19 x i8] c"%s(%p, %p) failed!\00", align 1
@__func__.snd_disconnect_release = private unnamed_addr constant [23 x i8] c"snd_disconnect_release\00", align 1
@.str.30 = private unnamed_addr constant [9 x i8] c"&x->wait\00", align 1
@init_completion.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@__kstrtab_snd_card_free_when_closed = internal constant [26 x i8] c"snd_card_free_when_closed\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_card_disconnect = internal constant [20 x i8] c"snd_card_disconnect\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_card_new = internal constant [13 x i8] c"snd_card_new\00", section "__ksymtab_strings", align 1
@.str.1.23 = private unnamed_addr constant [59 x i8] c"cannot find the slot for index %d (range 0-%i), error: %d\0A\00", align 1
@.str.2.24 = private unnamed_addr constant [22 x i8] c"&card->controls_rwsem\00", align 1
@snd_card_new.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.4.25 = private unnamed_addr constant [24 x i8] c"&card->ctl_files_rwlock\00", align 1
@snd_card_new.__key.3 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.6.26 = private unnamed_addr constant [21 x i8] c"&card->user_ctl_lock\00", align 1
@snd_card_new.__key.5 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.8.27 = private unnamed_addr constant [28 x i8] c"&(&card->files_lock)->rlock\00", align 1
@snd_card_new.__key.7 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.10.28 = private unnamed_addr constant [18 x i8] c"&card->power_lock\00", align 1
@snd_card_new.__key.9 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.12.29 = private unnamed_addr constant [19 x i8] c"&card->power_sleep\00", align 1
@snd_card_new.__key.11 = internal global %struct.lock_class_key zeroinitializer, align 1
@sound_class = external global %struct.class*, align 8
@card_dev_attr_group = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([3 x %struct.attribute*], [3 x %struct.attribute*]* @card_dev_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@.str.13.30 = private unnamed_addr constant [7 x i8] c"card%d\00", align 1
@.str.14.31 = private unnamed_addr constant [6 x i8] c"%s:%s\00", align 1
@.str.15.32 = private unnamed_addr constant [35 x i8] c"unable to register control minors\0A\00", align 1
@.str.16.33 = private unnamed_addr constant [28 x i8] c"unable to create card info\0A\00", align 1
@card_dev_attrs = internal global [3 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_id, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_number, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_id = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @card_id_show_attr, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @card_id_store_attr }, align 8
@dev_attr_number = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.36, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @card_number_show_attr, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.36 = private unnamed_addr constant [7 x i8] c"number\00", align 1
@.str.37 = private unnamed_addr constant [4 x i8] c"%i\0A\00", align 1
@.str.27 = private unnamed_addr constant [26 x i8] c"unable to free card info\0A\00", align 1
@slots = internal global [32 x i8*] zeroinitializer, align 16
@__kstrtab_snd_device_initialize = internal constant [22 x i8] c"snd_device_initialize\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_mixer_oss_notify_callback = internal constant [30 x i8] c"snd_mixer_oss_notify_callback\00", section "__ksymtab_strings", align 1
@__param_str_slots = internal constant [6 x i8] c"slots\00", align 1
@param_array_ops = external constant %struct.kernel_param_ops, align 8
@__param_arr_slots = internal constant %struct.kparam_array { i32 32, i32 8, i32* null, %struct.kernel_param_ops* @param_ops_charp, i8* bitcast ([32 x i8*]* @slots to i8*) }, align 8
@param_ops_charp = external constant %struct.kernel_param_ops, align 8
@__kstrtab_snd_cards = internal constant [10 x i8] c"snd_cards\00", section "__ksymtab_strings", align 1
@.str.19.36 = private unnamed_addr constant [23 x i8] c"--- no soundcards ---\0A\00", align 1
@.str.21 = private unnamed_addr constant [8 x i8] c"modules\00", align 1
@.str.42 = private unnamed_addr constant [8 x i8] c"%2i %s\0A\00", align 1
@.str.40 = private unnamed_addr constant [22 x i8] c"%2i [%-15s]: %s - %s\0A\00", align 1
@.str.41 = private unnamed_addr constant [26 x i8] c"                      %s\0A\00", align 1
@__ksymtab_copy_to_user_fromio = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i8*, i8*, i64)* @copy_to_user_fromio to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_copy_to_user_fromio, i32 0, i32 0) }, section "___ksymtab+copy_to_user_fromio", align 8
@__ksymtab_copy_from_user_toio = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i8*, i8*, i64)* @copy_from_user_toio to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_copy_from_user_toio, i32 0, i32 0) }, section "___ksymtab+copy_from_user_toio", align 8
@__kstrtab_copy_from_user_toio = internal constant [20 x i8] c"copy_from_user_toio\00", section "__ksymtab_strings", align 1
@__kstrtab_copy_to_user_fromio = internal constant [20 x i8] c"copy_to_user_fromio\00", section "__ksymtab_strings", align 1
@__ksymtab_snd_ctl_notify = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_card*, i32, %struct.snd_ctl_elem_id*)* @snd_ctl_notify to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_snd_ctl_notify, i32 0, i32 0) }, section "___ksymtab+snd_ctl_notify", align 8
@__ksymtab_snd_ctl_new1 = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_kcontrol* (%struct.snd_kcontrol_new*, i8*)* @snd_ctl_new1 to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_snd_ctl_new1, i32 0, i32 0) }, section "___ksymtab+snd_ctl_new1", align 8
@__ksymtab_snd_ctl_free_one = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_kcontrol*)* @snd_ctl_free_one to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_ctl_free_one, i32 0, i32 0) }, section "___ksymtab+snd_ctl_free_one", align 8
@__ksymtab_snd_ctl_add = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_kcontrol*)* @snd_ctl_add to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_snd_ctl_add, i32 0, i32 0) }, section "___ksymtab+snd_ctl_add", align 8
@__ksymtab_snd_ctl_replace = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_kcontrol*, i1)* @snd_ctl_replace to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_ctl_replace, i32 0, i32 0) }, section "___ksymtab+snd_ctl_replace", align 8
@__ksymtab_snd_ctl_remove = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_kcontrol*)* @snd_ctl_remove to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_snd_ctl_remove, i32 0, i32 0) }, section "___ksymtab+snd_ctl_remove", align 8
@__ksymtab_snd_ctl_remove_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_ctl_elem_id*)* @snd_ctl_remove_id to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_ctl_remove_id, i32 0, i32 0) }, section "___ksymtab+snd_ctl_remove_id", align 8
@__ksymtab_snd_ctl_activate_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_ctl_elem_id*, i32)* @snd_ctl_activate_id to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_ctl_activate_id, i32 0, i32 0) }, section "___ksymtab_gpl+snd_ctl_activate_id", align 8
@__ksymtab_snd_ctl_rename_id = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, %struct.snd_ctl_elem_id*, %struct.snd_ctl_elem_id*)* @snd_ctl_rename_id to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_ctl_rename_id, i32 0, i32 0) }, section "___ksymtab+snd_ctl_rename_id", align 8
@__ksymtab_snd_ctl_find_numid = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_kcontrol* (%struct.snd_card*, i32)* @snd_ctl_find_numid to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_snd_ctl_find_numid, i32 0, i32 0) }, section "___ksymtab+snd_ctl_find_numid", align 8
@__ksymtab_snd_ctl_find_id = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_kcontrol* (%struct.snd_card*, %struct.snd_ctl_elem_id*)* @snd_ctl_find_id to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_ctl_find_id, i32 0, i32 0) }, section "___ksymtab+snd_ctl_find_id", align 8
@__ksymtab_snd_ctl_register_ioctl = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*)* @snd_ctl_register_ioctl to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_snd_ctl_register_ioctl, i32 0, i32 0) }, section "___ksymtab+snd_ctl_register_ioctl", align 8
@__ksymtab_snd_ctl_register_ioctl_compat = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*)* @snd_ctl_register_ioctl_compat to i64), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__kstrtab_snd_ctl_register_ioctl_compat, i32 0, i32 0) }, section "___ksymtab+snd_ctl_register_ioctl_compat", align 8
@__ksymtab_snd_ctl_unregister_ioctl = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*)* @snd_ctl_unregister_ioctl to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_snd_ctl_unregister_ioctl, i32 0, i32 0) }, section "___ksymtab+snd_ctl_unregister_ioctl", align 8
@__ksymtab_snd_ctl_unregister_ioctl_compat = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*)* @snd_ctl_unregister_ioctl_compat to i64), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__kstrtab_snd_ctl_unregister_ioctl_compat, i32 0, i32 0) }, section "___ksymtab+snd_ctl_unregister_ioctl_compat", align 8
@__ksymtab_snd_ctl_get_preferred_subdevice = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i32)* @snd_ctl_get_preferred_subdevice to i64), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__kstrtab_snd_ctl_get_preferred_subdevice, i32 0, i32 0) }, section "___ksymtab_gpl+snd_ctl_get_preferred_subdevice", align 8
@__ksymtab_snd_ctl_boolean_mono_info = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @snd_ctl_boolean_mono_info to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_ctl_boolean_mono_info, i32 0, i32 0) }, section "___ksymtab+snd_ctl_boolean_mono_info", align 8
@__ksymtab_snd_ctl_boolean_stereo_info = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @snd_ctl_boolean_stereo_info to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_snd_ctl_boolean_stereo_info, i32 0, i32 0) }, section "___ksymtab+snd_ctl_boolean_stereo_info", align 8
@__ksymtab_snd_ctl_enum_info = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_ctl_elem_info*, i32, i32, i8**)* @snd_ctl_enum_info to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_ctl_enum_info, i32 0, i32 0) }, section "___ksymtab+snd_ctl_enum_info", align 8
@__kstrtab_snd_ctl_enum_info = internal constant [18 x i8] c"snd_ctl_enum_info\00", section "__ksymtab_strings", align 1
@.str.46 = private unnamed_addr constant [21 x i8] c"sound/core/control.c\00", align 1
@.str.5.47 = private unnamed_addr constant [31 x i8] c"ALSA: too long item name '%s'\0A\00", align 1
@__kstrtab_snd_ctl_boolean_stereo_info = internal constant [28 x i8] c"snd_ctl_boolean_stereo_info\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_boolean_mono_info = internal constant [26 x i8] c"snd_ctl_boolean_mono_info\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_get_preferred_subdevice = internal constant [32 x i8] c"snd_ctl_get_preferred_subdevice\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_unregister_ioctl_compat = internal constant [32 x i8] c"snd_ctl_unregister_ioctl_compat\00", section "__ksymtab_strings", align 1
@snd_control_compat_ioctls = internal global %struct.list_head { %struct.list_head* @snd_control_compat_ioctls, %struct.list_head* @snd_control_compat_ioctls }, align 8
@snd_ioctl_rwsem = internal global %struct.rw_semaphore { %union.anon.3 zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @snd_ioctl_rwsem to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.rw_semaphore* @snd_ioctl_rwsem to i8*), i64 8) to %struct.list_head*) }, %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.7.54, i32 0, i32 0), i32 0, i64 0 } }, %struct.qspinlock zeroinitializer, %struct.task_struct* null, %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8.55, i32 0, i32 0), i32 0, i64 0 } }, align 8
@.str.7.54 = private unnamed_addr constant [26 x i8] c"snd_ioctl_rwsem.wait_lock\00", align 1
@.str.8.55 = private unnamed_addr constant [16 x i8] c"snd_ioctl_rwsem\00", align 1
@__kstrtab_snd_ctl_unregister_ioctl = internal constant [25 x i8] c"snd_ctl_unregister_ioctl\00", section "__ksymtab_strings", align 1
@snd_control_ioctls = internal global %struct.list_head { %struct.list_head* @snd_control_ioctls, %struct.list_head* @snd_control_ioctls }, align 8
@__kstrtab_snd_ctl_register_ioctl_compat = internal constant [30 x i8] c"snd_ctl_register_ioctl_compat\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_register_ioctl = internal constant [23 x i8] c"snd_ctl_register_ioctl\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_find_id = internal constant [16 x i8] c"snd_ctl_find_id\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_find_numid = internal constant [19 x i8] c"snd_ctl_find_numid\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_rename_id = internal constant [18 x i8] c"snd_ctl_rename_id\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_activate_id = internal constant [20 x i8] c"snd_ctl_activate_id\00", section "__ksymtab_strings", align 1
@.str.1.60 = private unnamed_addr constant [39 x i8] c"No memory available to allocate event\0A\00", align 1
@__kstrtab_snd_ctl_remove_id = internal constant [18 x i8] c"snd_ctl_remove_id\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_remove = internal constant [15 x i8] c"snd_ctl_remove\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_replace = internal constant [16 x i8] c"snd_ctl_replace\00", section "__ksymtab_strings", align 1
@.str.6.61 = private unnamed_addr constant [38 x i8] c"unable to allocate new control numid\0A\00", align 1
@__kstrtab_snd_ctl_add = internal constant [12 x i8] c"snd_ctl_add\00", section "__ksymtab_strings", align 1
@.str.3.62 = private unnamed_addr constant [43 x i8] c"control %i:%i:%i:%s:%i is already present\0A\00", align 1
@__kstrtab_snd_ctl_free_one = internal constant [17 x i8] c"snd_ctl_free_one\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_new1 = internal constant [13 x i8] c"snd_ctl_new1\00", section "__ksymtab_strings", align 1
@.str.2.63 = private unnamed_addr constant [45 x i8] c"\014ALSA: Control name '%s' truncated to '%s'\0A\00", align 1
@__kstrtab_snd_ctl_notify = internal constant [15 x i8] c"snd_ctl_notify\00", section "__ksymtab_strings", align 1
@.str.4.66 = private unnamed_addr constant [11 x i8] c"controlC%d\00", align 1
@snd_ctl_create.ops = internal global %struct.snd_device_ops { i32 (%struct.snd_device*)* @snd_ctl_dev_free, i32 (%struct.snd_device*)* @snd_ctl_dev_register, i32 (%struct.snd_device*)* @snd_ctl_dev_disconnect }, align 8
@snd_ctl_f_ops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* @snd_ctl_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @snd_ctl_poll, i64 (%struct.file*, i32, i64)* @snd_ctl_ioctl, i64 (%struct.file*, i32, i64)* @snd_ctl_ioctl_compat, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @snd_ctl_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @snd_ctl_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* @snd_ctl_fasync, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.16.69 = private unnamed_addr constant [19 x i8] c"&ctl->change_sleep\00", align 1
@snd_ctl_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.18.70 = private unnamed_addr constant [26 x i8] c"&(&ctl->read_lock)->rlock\00", align 1
@snd_ctl_open.__key.17 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.14.71 = private unnamed_addr constant [28 x i8] c"sound/core/control_compat.c\00", align 1
@.str.15.80 = private unnamed_addr constant [45 x i8] c"snd_ioctl32_ctl_elem_value: unknown type %d\0A\00", align 1
@snd_ctl_elem_add.max_value_counts = internal constant [7 x i32] [i32 0, i32 128, i32 128, i32 128, i32 512, i32 1, i32 64], align 16
@snd_ctl_elem_add.value_sizes = internal constant [7 x i32] [i32 0, i32 8, i32 8, i32 4, i32 1, i32 176, i32 8], align 16
@snd_ctl_ioctl.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1.91, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.snd_ctl_ioctl, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13.81, i32 0, i32 0), i8 21, i8 6, i8 0, i8 0 }, section "__verbose", align 8
@.str.13.81 = private unnamed_addr constant [22 x i8] c"unknown ioctl = 0x%x\0A\00", align 1
@__func__.snd_ctl_ioctl = private unnamed_addr constant [14 x i8] c"snd_ctl_ioctl\00", align 1
@__param_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_debug, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_debugtype8 = internal constant [19 x i8] c"parmtype=debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_debug9 = internal constant [37 x i8] c"parm=debug:Debug level (0 = disable)\00", section ".modinfo", align 1
@__ksymtab_release_and_free_resource = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.resource*)* @release_and_free_resource to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_release_and_free_resource, i32 0, i32 0) }, section "___ksymtab+release_and_free_resource", align 8
@__ksymtab___snd_printk = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i32, i8*, i32, i8*, ...)* @__snd_printk to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab___snd_printk, i32 0, i32 0) }, section "___ksymtab_gpl+__snd_printk", align 8
@__ksymtab_snd_pci_quirk_lookup_id = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_pci_quirk* (i16, i16, %struct.snd_pci_quirk*)* @snd_pci_quirk_lookup_id to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_snd_pci_quirk_lookup_id, i32 0, i32 0) }, section "___ksymtab+snd_pci_quirk_lookup_id", align 8
@__ksymtab_snd_pci_quirk_lookup = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_pci_quirk* (%struct.pci_dev*, %struct.snd_pci_quirk*)* @snd_pci_quirk_lookup to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_snd_pci_quirk_lookup, i32 0, i32 0) }, section "___ksymtab+snd_pci_quirk_lookup", align 8
@__kstrtab_snd_pci_quirk_lookup = internal constant [21 x i8] c"snd_pci_quirk_lookup\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_pci_quirk_lookup_id = internal constant [24 x i8] c"snd_pci_quirk_lookup_id\00", section "__ksymtab_strings", align 1
@__kstrtab___snd_printk = internal constant [13 x i8] c"__snd_printk\00", section "__ksymtab_strings", align 1
@__snd_printk.verbose_fmt = private unnamed_addr constant [17 x i8] c"\01dALSA %s:%d %pV\00", align 16
@debug = internal global i32 2, align 4
@.str.86 = private unnamed_addr constant [3 x i8] c"\017\00", align 1
@__kstrtab_release_and_free_resource = internal constant [26 x i8] c"release_and_free_resource\00", section "__ksymtab_strings", align 1
@__param_str_debug = internal constant [6 x i8] c"debug\00", align 1
@__ksymtab_snd_device_new = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i32, i8*, %struct.snd_device_ops*)* @snd_device_new to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_snd_device_new, i32 0, i32 0) }, section "___ksymtab+snd_device_new", align 8
@__ksymtab_snd_device_disconnect = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_card*, i8*)* @snd_device_disconnect to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_device_disconnect, i32 0, i32 0) }, section "___ksymtab_gpl+snd_device_disconnect", align 8
@__ksymtab_snd_device_free = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_card*, i8*)* @snd_device_free to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_device_free, i32 0, i32 0) }, section "___ksymtab+snd_device_free", align 8
@__ksymtab_snd_device_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i8*)* @snd_device_register to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_device_register, i32 0, i32 0) }, section "___ksymtab+snd_device_register", align 8
@__kstrtab_snd_device_register = internal constant [20 x i8] c"snd_device_register\00", section "__ksymtab_strings", align 1
@.str.88 = private unnamed_addr constant [20 x i8] c"sound/core/device.c\00", align 1
@.str.4.89 = private unnamed_addr constant [6 x i8] c"BUG?\0A\00", align 1
@__kstrtab_snd_device_free = internal constant [16 x i8] c"snd_device_free\00", section "__ksymtab_strings", align 1
@snd_device_free.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1.91, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.snd_device_free, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.3.90, i32 0, i32 0), i8 -100, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.3.90 = private unnamed_addr constant [38 x i8] c"device free %p (from %pF), not found\0A\00", align 1
@.str.1.91 = private unnamed_addr constant [4 x i8] c"snd\00", align 1
@__func__.snd_device_free = private unnamed_addr constant [16 x i8] c"snd_device_free\00", align 1
@.str.6.93 = private unnamed_addr constant [21 x i8] c"device free failure\0A\00", align 1
@.str.5.94 = private unnamed_addr constant [27 x i8] c"device disconnect failure\0A\00", align 1
@__kstrtab_snd_device_disconnect = internal constant [22 x i8] c"snd_device_disconnect\00", section "__ksymtab_strings", align 1
@snd_device_disconnect.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1.91, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.snd_device_disconnect, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.2.98, i32 0, i32 0), i8 -124, i8 0, i8 0, i8 0 }, section "__verbose", align 8
@.str.2.98 = private unnamed_addr constant [44 x i8] c"device disconnect %p (from %pF), not found\0A\00", align 1
@__func__.snd_device_disconnect = private unnamed_addr constant [22 x i8] c"snd_device_disconnect\00", align 1
@__kstrtab_snd_device_new = internal constant [15 x i8] c"snd_device_new\00", section "__ksymtab_strings", align 1
@snd_seq_root = common global %struct.snd_info_entry* null, align 8
@snd_oss_root = common global %struct.snd_info_entry* null, align 8
@__ksymtab_snd_seq_root = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_info_entry** @snd_seq_root to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_snd_seq_root, i32 0, i32 0) }, section "___ksymtab+snd_seq_root", align 8
@__ksymtab_snd_info_get_line = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_info_buffer*, i8*, i32)* @snd_info_get_line to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_info_get_line, i32 0, i32 0) }, section "___ksymtab+snd_info_get_line", align 8
@__ksymtab_snd_info_get_str = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (i8*, i8*, i32)* @snd_info_get_str to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_info_get_str, i32 0, i32 0) }, section "___ksymtab+snd_info_get_str", align 8
@__ksymtab_snd_info_create_module_entry = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_info_entry* (%struct.module*, i8*, %struct.snd_info_entry*)* @snd_info_create_module_entry to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_snd_info_create_module_entry, i32 0, i32 0) }, section "___ksymtab+snd_info_create_module_entry", align 8
@__ksymtab_snd_info_create_card_entry = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_info_entry* (%struct.snd_card*, i8*, %struct.snd_info_entry*)* @snd_info_create_card_entry to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_snd_info_create_card_entry, i32 0, i32 0) }, section "___ksymtab+snd_info_create_card_entry", align 8
@__ksymtab_snd_info_free_entry = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_info_entry*)* @snd_info_free_entry to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_info_free_entry, i32 0, i32 0) }, section "___ksymtab+snd_info_free_entry", align 8
@__ksymtab_snd_info_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_info_entry*)* @snd_info_register to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_info_register, i32 0, i32 0) }, section "___ksymtab+snd_info_register", align 8
@__kstrtab_snd_info_register = internal constant [18 x i8] c"snd_info_register\00", section "__ksymtab_strings", align 1
@.str.13.115 = private unnamed_addr constant [18 x i8] c"sound/core/info.c\00", align 1
@snd_proc_root = internal global %struct.snd_info_entry* null, align 8
@info_mutex = internal global %struct.mutex { %union.anon.3 zeroinitializer, %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.15.123, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.qspinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @info_mutex to i8*), i64 88) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @info_mutex to i8*), i64 88) to %struct.list_head*) }, i8* bitcast (%struct.mutex* @info_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.16.124, i32 0, i32 0), i32 0, i64 0 } }, align 8
@snd_info_entry_operations = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @snd_info_entry_llseek, i64 (%struct.file*, i8*, i64, i64*)* @snd_info_entry_read, i64 (%struct.file*, i8*, i64, i64*)* @snd_info_entry_write, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @snd_info_entry_poll, i64 (%struct.file*, i32, i64)* @snd_info_entry_ioctl, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* @snd_info_entry_mmap, i32 (%struct.inode*, %struct.file*)* @snd_info_entry_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @snd_info_entry_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@snd_info_text_entry_ops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @seq_lseek, i64 (%struct.file*, i8*, i64, i64*)* @seq_read, i64 (%struct.file*, i8*, i64, i64*)* @snd_info_text_entry_write, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @snd_info_text_entry_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @snd_info_text_entry_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.18.119 = private unnamed_addr constant [33 x i8] c"./arch/x86/include/asm/uaccess.h\00", align 1
@.str.19.122 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@.str.15.123 = private unnamed_addr constant [21 x i8] c"info_mutex.wait_lock\00", align 1
@.str.16.124 = private unnamed_addr constant [11 x i8] c"info_mutex\00", align 1
@__kstrtab_snd_info_free_entry = internal constant [20 x i8] c"snd_info_free_entry\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_info_create_card_entry = internal constant [27 x i8] c"snd_info_create_card_entry\00", section "__ksymtab_strings", align 1
@.str.17.133 = private unnamed_addr constant [15 x i8] c"&entry->access\00", align 1
@snd_info_create_entry.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@__kstrtab_snd_info_create_module_entry = internal constant [29 x i8] c"snd_info_create_module_entry\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_info_get_str = internal constant [17 x i8] c"snd_info_get_str\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_info_get_line = internal constant [18 x i8] c"snd_info_get_line\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_seq_root = internal constant [13 x i8] c"snd_seq_root\00", section "__ksymtab_strings", align 1
@snd_info_check_reserved_words.reserved = internal global [12 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.142, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1.143, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2.144, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3.145, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.204, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.147, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6.148, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.7.149, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.8.150, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9.151, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10.152, i32 0, i32 0), i8* null], align 16
@.str.11.141 = private unnamed_addr constant [5 x i8] c"card\00", align 1
@.str.142 = private unnamed_addr constant [8 x i8] c"version\00", align 1
@.str.1.143 = private unnamed_addr constant [8 x i8] c"meminfo\00", align 1
@.str.2.144 = private unnamed_addr constant [9 x i8] c"memdebug\00", align 1
@.str.3.145 = private unnamed_addr constant [7 x i8] c"detect\00", align 1
@.str.5.147 = private unnamed_addr constant [4 x i8] c"oss\00", align 1
@.str.6.148 = private unnamed_addr constant [6 x i8] c"cards\00", align 1
@.str.7.149 = private unnamed_addr constant [7 x i8] c"timers\00", align 1
@.str.8.150 = private unnamed_addr constant [6 x i8] c"synth\00", align 1
@.str.9.151 = private unnamed_addr constant [4 x i8] c"pcm\00", align 1
@.str.10.152 = private unnamed_addr constant [4 x i8] c"seq\00", align 1
@.str.12.155 = private unnamed_addr constant [7 x i8] c"asound\00", align 1
@.str.20.156 = private unnamed_addr constant [55 x i8] c"Advanced Linux Sound Architecture Driver Version k%s.\0A\00", align 1
@init_uts_ns = external global %struct.uts_namespace, align 8
@.str.14.161 = private unnamed_addr constant [7 x i8] c"card%i\00", align 1
@__ksymtab_snd_oss_info_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, i32, i8*)* @snd_oss_info_register to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_oss_info_register, i32 0, i32 0) }, section "___ksymtab+snd_oss_info_register", align 8
@__kstrtab_snd_oss_info_register = internal constant [22 x i8] c"snd_oss_info_register\00", section "__ksymtab_strings", align 1
@.str.171 = private unnamed_addr constant [22 x i8] c"sound/core/info_oss.c\00", align 1
@strings = internal global %struct.mutex { %union.anon.3 zeroinitializer, %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.2.172, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.qspinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @strings to i8*), i64 88) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @strings to i8*), i64 88) to %struct.list_head*) }, i8* bitcast (%struct.mutex* @strings to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.3.173, i32 0, i32 0), i32 0, i64 0 } }, align 8
@snd_sndstat_strings = internal global [32 x [6 x i8*]] zeroinitializer, align 16
@.str.2.172 = private unnamed_addr constant [18 x i8] c"strings.wait_lock\00", align 1
@.str.3.173 = private unnamed_addr constant [8 x i8] c"strings\00", align 1
@.str.1.176 = private unnamed_addr constant [8 x i8] c"sndstat\00", align 1
@.str.4.177 = private unnamed_addr constant [50 x i8] c"Sound Driver:3.8.1a-980706 (ALSA emulation code)\0A\00", align 1
@.str.5.179 = private unnamed_addr constant [24 x i8] c"Kernel: %s %s %s %s %s\0A\00", align 1
@.str.6.180 = private unnamed_addr constant [19 x i8] c"Config options: 0\0A\00", align 1
@.str.7.181 = private unnamed_addr constant [22 x i8] c"\0AInstalled drivers: \0A\00", align 1
@.str.8.182 = private unnamed_addr constant [25 x i8] c"Type 10: ALSA emulation\0A\00", align 1
@.str.9.183 = private unnamed_addr constant [16 x i8] c"\0ACard config: \0A\00", align 1
@.str.10.184 = private unnamed_addr constant [14 x i8] c"Audio devices\00", align 1
@.str.11.185 = private unnamed_addr constant [14 x i8] c"Synth devices\00", align 1
@.str.12.186 = private unnamed_addr constant [13 x i8] c"Midi devices\00", align 1
@.str.13.187 = private unnamed_addr constant [7 x i8] c"Timers\00", align 1
@.str.14.188 = private unnamed_addr constant [7 x i8] c"Mixers\00", align 1
@.str.15.189 = private unnamed_addr constant [5 x i8] c"\0A%s:\00", align 1
@.str.16.190 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.17.191 = private unnamed_addr constant [8 x i8] c"%i: %s\0A\00", align 1
@.str.18.192 = private unnamed_addr constant [24 x i8] c" NOT ENABLED IN CONFIG\0A\00", align 1
@__ksymtab_snd_dma_program = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i64, i64, i32, i16)* @snd_dma_program to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_dma_program, i32 0, i32 0) }, section "___ksymtab+snd_dma_program", align 8
@__ksymtab_snd_dma_disable = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i64)* @snd_dma_disable to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_dma_disable, i32 0, i32 0) }, section "___ksymtab+snd_dma_disable", align 8
@__ksymtab_snd_dma_pointer = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i64, i32)* @snd_dma_pointer to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_dma_pointer, i32 0, i32 0) }, section "___ksymtab+snd_dma_pointer", align 8
@__kstrtab_snd_dma_pointer = internal constant [16 x i8] c"snd_dma_pointer\00", section "__ksymtab_strings", align 1
@isa_dma_bridge_buggy = external global i32, align 4
@.str.194 = private unnamed_addr constant [74 x i8] c"\013ALSA: pointer (0x%x) for DMA #%ld is greater than transfer size (0x%x)\0A\00", align 1
@dma_spin_lock = external global %struct.spinlock, align 8
@__kstrtab_snd_dma_disable = internal constant [16 x i8] c"snd_dma_disable\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_dma_program = internal constant [16 x i8] c"snd_dma_program\00", section "__ksymtab_strings", align 1
@__ksymtab_snd_lookup_oss_minor_data = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (i32, i32)* @snd_lookup_oss_minor_data to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_lookup_oss_minor_data, i32 0, i32 0) }, section "___ksymtab+snd_lookup_oss_minor_data", align 8
@__ksymtab_snd_register_oss_device = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32, %struct.file_operations*, i8*)* @snd_register_oss_device to i64), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__kstrtab_snd_register_oss_device, i32 0, i32 0) }, section "___ksymtab+snd_register_oss_device", align 8
@__ksymtab_snd_unregister_oss_device = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32)* @snd_unregister_oss_device to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_unregister_oss_device, i32 0, i32 0) }, section "___ksymtab+snd_unregister_oss_device", align 8
@__kstrtab_snd_unregister_oss_device = internal constant [26 x i8] c"snd_unregister_oss_device\00", section "__ksymtab_strings", align 1
@sound_oss_mutex = internal global %struct.mutex { %union.anon.3 zeroinitializer, %struct.spinlock { %union.anon.1 { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1.198, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.qspinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @sound_oss_mutex to i8*), i64 88) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @sound_oss_mutex to i8*), i64 88) to %struct.list_head*) }, i8* bitcast (%struct.mutex* @sound_oss_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2.199, i32 0, i32 0), i32 0, i64 0 } }, align 8
@snd_oss_minors = internal global [256 x %struct.snd_minor*] zeroinitializer, align 16
@.str.1.198 = private unnamed_addr constant [26 x i8] c"sound_oss_mutex.wait_lock\00", align 1
@.str.2.199 = private unnamed_addr constant [16 x i8] c"sound_oss_mutex\00", align 1
@.str.3.200 = private unnamed_addr constant [23 x i8] c"sound/core/sound_oss.c\00", align 1
@__kstrtab_snd_register_oss_device = internal constant [24 x i8] c"snd_register_oss_device\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_lookup_oss_minor_data = internal constant [26 x i8] c"snd_lookup_oss_minor_data\00", section "__ksymtab_strings", align 1
@.str.204 = private unnamed_addr constant [8 x i8] c"devices\00", align 1
@.str.4.205 = private unnamed_addr constant [19 x i8] c"%3i: [%i-%2i]: %s\0A\00", align 1
@.str.5.206 = private unnamed_addr constant [17 x i8] c"%3i:       : %s\0A\00", align 1
@.str.7.207 = private unnamed_addr constant [10 x i8] c"sequencer\00", align 1
@.str.8.208 = private unnamed_addr constant [14 x i8] c"digital audio\00", align 1
@.str.11.209 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.6.210 = private unnamed_addr constant [6 x i8] c"mixer\00", align 1
@.str.9.211 = private unnamed_addr constant [9 x i8] c"raw midi\00", align 1
@.str.10.212 = private unnamed_addr constant [19 x i8] c"hardware dependent\00", align 1
@__ksymtab__snd_ctl_add_slave = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_kcontrol*, %struct.snd_kcontrol*, i32)* @_snd_ctl_add_slave to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab__snd_ctl_add_slave, i32 0, i32 0) }, section "___ksymtab+_snd_ctl_add_slave", align 8
@__ksymtab_snd_ctl_make_virtual_master = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_kcontrol* (i8*, i32*)* @snd_ctl_make_virtual_master to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_snd_ctl_make_virtual_master, i32 0, i32 0) }, section "___ksymtab+snd_ctl_make_virtual_master", align 8
@__ksymtab_snd_ctl_add_vmaster_hook = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_kcontrol*, void (i8*, i32)*, i8*)* @snd_ctl_add_vmaster_hook to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_snd_ctl_add_vmaster_hook, i32 0, i32 0) }, section "___ksymtab_gpl+snd_ctl_add_vmaster_hook", align 8
@__ksymtab_snd_ctl_sync_vmaster = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_kcontrol*, i1)* @snd_ctl_sync_vmaster to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_snd_ctl_sync_vmaster, i32 0, i32 0) }, section "___ksymtab_gpl+snd_ctl_sync_vmaster", align 8
@__kstrtab_snd_ctl_sync_vmaster = internal constant [21 x i8] c"snd_ctl_sync_vmaster\00", section "__ksymtab_strings", align 1
@.str.215 = private unnamed_addr constant [40 x i8] c"\013ALSA: vmaster: invalid slave element\0A\00", align 1
@__kstrtab_snd_ctl_add_vmaster_hook = internal constant [25 x i8] c"snd_ctl_add_vmaster_hook\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ctl_make_virtual_master = internal constant [28 x i8] c"snd_ctl_make_virtual_master\00", section "__ksymtab_strings", align 1
@__kstrtab__snd_ctl_add_slave = internal constant [19 x i8] c"_snd_ctl_add_slave\00", section "__ksymtab_strings", align 1
@jack_detect_kctl = internal global %struct.snd_kcontrol_new { i32 0, i32 0, i32 0, i8* null, i32 0, i32 1, i32 0, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @snd_ctl_boolean_mono_info, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @jack_detect_kctl_get, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* null, %union.anon.69 zeroinitializer, i64 0 }, align 8
@.str.224 = private unnamed_addr constant [6 x i8] c" Jack\00", align 1
@.str.1.225 = private unnamed_addr constant [8 x i8] c"%s Jack\00", align 1
@.str.2.226 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@__ksymtab_snd_jack_add_new_kctl = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_jack*, i8*, i32)* @snd_jack_add_new_kctl to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_jack_add_new_kctl, i32 0, i32 0) }, section "___ksymtab+snd_jack_add_new_kctl", align 8
@__ksymtab_snd_jack_new = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i8*, i32, %struct.snd_jack**, i1, i1)* @snd_jack_new to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_snd_jack_new, i32 0, i32 0) }, section "___ksymtab+snd_jack_new", align 8
@__ksymtab_snd_jack_set_parent = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_jack*, %struct.device*)* @snd_jack_set_parent to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_jack_set_parent, i32 0, i32 0) }, section "___ksymtab+snd_jack_set_parent", align 8
@__ksymtab_snd_jack_set_key = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_jack*, i32, i32)* @snd_jack_set_key to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_jack_set_key, i32 0, i32 0) }, section "___ksymtab+snd_jack_set_key", align 8
@__ksymtab_snd_jack_report = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_jack*, i32)* @snd_jack_report to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_snd_jack_report, i32 0, i32 0) }, section "___ksymtab+snd_jack_report", align 8
@__kstrtab_snd_jack_report = internal constant [16 x i8] c"snd_jack_report\00", section "__ksymtab_strings", align 1
@jack_switch_types = internal global [6 x i32] [i32 2, i32 4, i32 6, i32 7, i32 8, i32 13], align 16
@__kstrtab_snd_jack_set_key = internal constant [17 x i8] c"snd_jack_set_key\00", section "__ksymtab_strings", align 1
@.str.1.228 = private unnamed_addr constant [18 x i8] c"sound/core/jack.c\00", align 1
@__kstrtab_snd_jack_set_parent = internal constant [20 x i8] c"snd_jack_set_parent\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_jack_new = internal constant [13 x i8] c"snd_jack_new\00", section "__ksymtab_strings", align 1
@.str.230 = private unnamed_addr constant [5 x i8] c"ALSA\00", align 1
@snd_jack_new.ops = internal global %struct.snd_device_ops { i32 (%struct.snd_device*)* @snd_jack_dev_free, i32 (%struct.snd_device*)* @snd_jack_dev_register, i32 (%struct.snd_device*)* @snd_jack_dev_disconnect }, align 8
@.str.2.235 = private unnamed_addr constant [6 x i8] c"%s %s\00", align 1
@__kstrtab_snd_jack_add_new_kctl = internal constant [22 x i8] c"snd_jack_add_new_kctl\00", section "__ksymtab_strings", align 1

@init_module = alias i32 (), i32 ()* @alsa_sound_init
@cleanup_module = alias void (), void ()* @alsa_sound_exit

; Function Attrs: nounwind uwtable
define i32 @snd_unregister_device(%struct.device* %dev) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %minor.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %conv = sext i32 %minor.0 to i64
  %cmp = icmp ult i64 %conv, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %dev2 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 5
  %1 = load %struct.device*, %struct.device** %dev2, align 8, !tbaa !6
  %cmp3 = icmp eq %struct.device* %1, %dev
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %land.lhs.true
  %idxprom5 = sext i32 %minor.0 to i64
  %arrayidx6 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom5
  store %struct.snd_minor* null, %struct.snd_minor** %arrayidx6, align 8, !tbaa !2
  call void @device_del(%struct.device* %dev)
  %2 = bitcast %struct.snd_minor* %0 to i8*
  call void @kfree(i8* %2)
  br label %for.end

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  %conv7 = sext i32 %minor.0 to i64
  %cmp8 = icmp uge i64 %conv7, 256
  %. = select i1 %cmp8, i32 -2, i32 0
  ret i32 %.
}

declare void @mutex_lock_nested(%struct.mutex*, i32) #1

declare void @device_del(%struct.device*) #1

declare void @kfree(i8*) #1

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_register_device(i32 %type, %struct.snd_card* %card, i32 %dev, %struct.file_operations* %f_ops, i8* %private_data, %struct.device* %device) #0 {
entry:
  %tobool = icmp ne %struct.device* %device, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.1, i32 0, i32 0), i32 268)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %call = call i8* @kmalloc(i64 48, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_minor*
  %cmp = icmp eq %struct.snd_minor* %0, null
  br i1 %cmp, label %cleanup, label %if.end21

if.end21:                                         ; preds = %if.end18
  %type22 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  store i32 %type, i32* %type22, align 8, !tbaa !9
  %tobool23 = icmp ne %struct.snd_card* %card, null
  br i1 %tobool23, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end21
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number, align 8, !tbaa !10
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end21
  %cond = phi i32 [ %1, %cond.true ], [ -1, %if.end21 ]
  %card24 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  store i32 %cond, i32* %card24, align 4, !tbaa !42
  %device25 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 2
  store i32 %dev, i32* %device25, align 8, !tbaa !43
  %f_ops26 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 3
  store %struct.file_operations* %f_ops, %struct.file_operations** %f_ops26, align 8, !tbaa !44
  %private_data27 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 4
  store i8* %private_data, i8** %private_data27, align 8, !tbaa !45
  %card_ptr = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  store %struct.snd_card* %card, %struct.snd_card** %card_ptr, align 8, !tbaa !46
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  %call28 = call i32 @snd_find_free_minor(i32 %type)
  %cmp29 = icmp slt i32 %call28, 0
  br i1 %cmp29, label %error, label %if.end32

if.end32:                                         ; preds = %cond.end
  %dev33 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 5
  store %struct.device* %device, %struct.device** %dev33, align 8, !tbaa !6
  %2 = load i32, i32* @major, align 4, !tbaa !47
  %shl = shl i32 %2, 20
  %or = or i32 %shl, %call28
  %devt = getelementptr inbounds %struct.device, %struct.device* %device, i32 0, i32 28
  store i32 %or, i32* %devt, align 8, !tbaa !48
  %call34 = call i32 @device_add(%struct.device* %device)
  %cmp35 = icmp slt i32 %call34, 0
  br i1 %cmp35, label %error, label %if.end38

if.end38:                                         ; preds = %if.end32
  %idxprom = sext i32 %call28 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  store %struct.snd_minor* %0, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  br label %error

error:                                            ; preds = %if.end38, %if.end32, %cond.end
  %err.0 = phi i32 [ %call34, %if.end38 ], [ %call28, %cond.end ], [ %call34, %if.end32 ]
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  %cmp39 = icmp slt i32 %err.0, 0
  br i1 %cmp39, label %if.then41, label %cleanup

if.then41:                                        ; preds = %error
  %3 = bitcast %struct.snd_minor* %0 to i8*
  call void @kfree(i8* %3)
  br label %cleanup

cleanup:                                          ; preds = %if.then41, %error, %if.end18, %if.end
  %retval.0 = phi i32 [ -22, %if.end ], [ -12, %if.end18 ], [ %err.0, %if.then41 ], [ %err.0, %error ]
  ret i32 %retval.0
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #2

declare void @warn_slowpath_null(i8*, i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #3 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_find_free_minor(i32 %type) #0 {
entry:
  switch i32 %type, label %if.end3 [
    i32 1, label %cleanup
    i32 2, label %if.then2
  ]

if.then2:                                         ; preds = %entry
  br label %cleanup

if.end3:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %minor.0 = phi i32 [ 0, %if.end3 ], [ %inc, %for.inc ]
  %conv = sext i32 %minor.0 to i64
  %cmp4 = icmp ult i64 %conv, 256
  br i1 %cmp4, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %and = and i32 %minor.0, 31
  %cmp6 = icmp eq i32 %and, 0
  br i1 %cmp6, label %for.inc, label %if.end9

if.end9:                                          ; preds = %for.body
  switch i32 %minor.0, label %if.end15 [
    i32 1, label %for.inc
    i32 33, label %for.inc
  ]

if.end15:                                         ; preds = %if.end9
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %for.inc, label %cleanup

for.inc:                                          ; preds = %if.end15, %if.end9, %if.end9, %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.end15, %for.cond, %if.then2, %entry
  %retval.0 = phi i32 [ 33, %if.then2 ], [ 1, %entry ], [ %minor.0, %if.end15 ], [ -16, %for.cond ]
  ret i32 %retval.0
}

declare i32 @device_add(%struct.device*) #1

declare noalias i8* @__kmalloc(i64, i32) #1

; Function Attrs: nounwind uwtable
define i8* @snd_lookup_minor_data(i32 %minor, i32 %type) #0 {
entry:
  %conv = zext i32 %minor to i64
  %cmp = icmp uge i64 %conv, 256
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  %idxprom = zext i32 %minor to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end
  %type2 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %1 = load i32, i32* %type2, align 8, !tbaa !9
  %cmp3 = icmp eq i32 %1, %type
  br i1 %cmp3, label %if.then5, label %if.end13

if.then5:                                         ; preds = %land.lhs.true
  %private_data6 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 4
  %2 = load i8*, i8** %private_data6, align 8, !tbaa !45
  %tobool7 = icmp ne i8* %2, null
  br i1 %tobool7, label %land.lhs.true8, label %if.end13

land.lhs.true8:                                   ; preds = %if.then5
  %card_ptr = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  %3 = load %struct.snd_card*, %struct.snd_card** %card_ptr, align 8, !tbaa !46
  %tobool9 = icmp ne %struct.snd_card* %3, null
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %land.lhs.true8
  %card_ptr11 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  %4 = load %struct.snd_card*, %struct.snd_card** %card_ptr11, align 8, !tbaa !46
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 30
  %call = call %struct.device* @get_device(%struct.device* %card_dev)
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %land.lhs.true8, %if.then5, %land.lhs.true, %if.end
  %private_data.0 = phi i8* [ %2, %if.then10 ], [ %2, %land.lhs.true8 ], [ %2, %if.then5 ], [ null, %land.lhs.true ], [ null, %if.end ]
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %entry
  %retval.0 = phi i8* [ %private_data.0, %if.end13 ], [ null, %entry ]
  ret i8* %retval.0
}

declare %struct.device* @get_device(%struct.device*) #1

; Function Attrs: nounwind uwtable
define void @snd_request_card(i32 %card) #0 {
entry:
  br label %if.end

if.end:                                           ; preds = %entry
  %cmp = icmp slt i32 %card, 0
  %0 = load i32, i32* @cards_limit, align 4
  %cmp1 = icmp sge i32 %card, %0
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %call4 = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0), i32 %card)
  br label %return

return:                                           ; preds = %if.end3, %if.end
  ret void
}

declare i32 @__request_module(i1 zeroext, i8*, ...) #1

; Function Attrs: nounwind uwtable
define i32 @snd_minor_info_init() #4 section ".init.text" {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.204, i32 0, i32 0), %struct.snd_info_entry* null)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.58* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_minor_info_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !49
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call2, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_minor_info_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %minor.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %minor.0, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %card = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  %1 = load i32, i32* %card, align 4, !tbaa !42
  %cmp2 = icmp sge i32 %1, 0
  br i1 %cmp2, label %if.then3, label %if.else14

if.then3:                                         ; preds = %if.end
  %device = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 2
  %2 = load i32, i32* %device, align 8, !tbaa !43
  %cmp4 = icmp sge i32 %2, 0
  %buffer6 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %3 = load i8*, i8** %buffer6, align 8, !tbaa !50
  %4 = bitcast i8* %3 to %struct.seq_file*
  %card7 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  %5 = load i32, i32* %card7, align 4, !tbaa !42
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then3
  %device8 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 2
  %6 = load i32, i32* %device8, align 8, !tbaa !43
  %type = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %7 = load i32, i32* %type, align 8, !tbaa !9
  %call = call i8* @snd_device_type_name(i32 %7)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %4, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.5, i32 0, i32 0), i32 %minor.0, i32 %5, i32 %6, i8* %call)
  br label %for.inc

if.else:                                          ; preds = %if.then3
  %type11 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %8 = load i32, i32* %type11, align 8, !tbaa !9
  %call12 = call i8* @snd_device_type_name(i32 %8)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %4, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.6, i32 0, i32 0), i32 %minor.0, i32 %5, i8* %call12)
  br label %for.inc

if.else14:                                        ; preds = %if.end
  %buffer15 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %9 = load i8*, i8** %buffer15, align 8, !tbaa !50
  %10 = bitcast i8* %9 to %struct.seq_file*
  %type16 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %11 = load i32, i32* %type16, align 8, !tbaa !9
  %call17 = call i8* @snd_device_type_name(i32 %11)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %10, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.7, i32 0, i32 0), i32 %minor.0, i8* %call17)
  br label %for.inc

for.inc:                                          ; preds = %if.else14, %if.else, %if.then5, %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @snd_device_type_name(i32 %type) #0 {
entry:
  %Pivot12 = icmp slt i32 %type, 3
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %type, 5
  br i1 %Pivot10, label %NodeBlock3, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %type, 6
  br i1 %Pivot8, label %return, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %type, 6
  br i1 %SwitchLeaf6, label %return, label %sw.default

NodeBlock3:                                       ; preds = %NodeBlock9
  %Pivot4 = icmp slt i32 %type, 4
  %. = select i1 %Pivot4, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.10.212, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.211, i32 0, i32 0)
  br label %return

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %type, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %type, 2
  %.13 = select i1 %Pivot, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7.207, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.14, i32 0, i32 0)
  br label %return

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %type, 0
  br i1 %SwitchLeaf, label %return, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock5
  br label %return

return:                                           ; preds = %sw.default, %LeafBlock, %NodeBlock, %NodeBlock3, %LeafBlock5, %NodeBlock7
  %retval.0 = phi i8* [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11.209, i32 0, i32 0), %sw.default ], [ %., %NodeBlock3 ], [ %.13, %NodeBlock ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.8, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11, i32 0, i32 0), %NodeBlock7 ], [ getelementptr inbounds ([22 x i8], [22 x i8]* @.str.12, i32 0, i32 0), %LeafBlock5 ]
  ret i8* %retval.0
}

declare void @seq_printf(%struct.seq_file*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @alsa_sound_init() #4 section ".init.text" {
entry:
  %0 = load i32, i32* @cards_limit, align 4, !tbaa !47
  store i32 %0, i32* @snd_ecards_limit, align 4, !tbaa !47
  br label %return

return:                                           ; preds = %entry
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @register_chrdev(i32 %major, i8* %name, %struct.file_operations* %fops) #5 {
entry:
  %call = call i32 @__register_chrdev(i32 %major, i32 0, i32 256, i8* %name, %struct.file_operations* %fops)
  ret void
}

declare i32 @printk(i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @unregister_chrdev(i32 %major, i8* %name) #5 {
entry:
  call void @__unregister_chrdev(i32 %major, i32 0, i32 256, i8* %name)
  ret void
}

declare void @__unregister_chrdev(i32, i32, i32, i8*) #1

declare i32 @__register_chrdev(i32, i32, i32, i8*, %struct.file_operations*) #1

declare i64 @noop_llseek(%struct.file*, i64, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i32 @iminor(%struct.inode* %inode)
  %conv = zext i32 %call to i64
  %cmp = icmp uge i64 %conv, 256
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  %idxprom = zext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %cmp2 = icmp eq %struct.snd_minor* %0, null
  br i1 %cmp2, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %call5 = call %struct.snd_minor* @autoload_device(i32 %call)
  %tobool = icmp ne %struct.snd_minor* %call5, null
  br i1 %tobool, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.then4
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

if.end8:                                          ; preds = %if.then4, %if.end
  %mptr.0 = phi %struct.snd_minor* [ %0, %if.end ], [ %call5, %if.then4 ]
  %f_ops = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %mptr.0, i32 0, i32 3
  %1 = load %struct.file_operations*, %struct.file_operations** %f_ops, align 8, !tbaa !44
  %tobool9 = icmp ne %struct.file_operations* %1, null
  br i1 %tobool9, label %land.lhs.true, label %cond.end

land.lhs.true:                                    ; preds = %if.end8
  %f_ops10 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %mptr.0, i32 0, i32 3
  %2 = load %struct.file_operations*, %struct.file_operations** %f_ops10, align 8, !tbaa !44
  %owner = getelementptr inbounds %struct.file_operations, %struct.file_operations* %2, i32 0, i32 0
  %3 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !52
  %call11 = call zeroext i1 @try_module_get(%struct.module* %3)
  br i1 %call11, label %cond.true, label %cond.end

cond.true:                                        ; preds = %land.lhs.true
  %f_ops13 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %mptr.0, i32 0, i32 3
  %4 = load %struct.file_operations*, %struct.file_operations** %f_ops13, align 8, !tbaa !44
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %land.lhs.true, %if.end8
  %cond = phi %struct.file_operations* [ %4, %cond.true ], [ null, %land.lhs.true ], [ null, %if.end8 ]
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  %tobool14 = icmp ne %struct.file_operations* %cond, null
  br i1 %tobool14, label %do.body17, label %cleanup

do.body17:                                        ; preds = %cond.end
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %5 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8, !tbaa !54
  %tobool18 = icmp ne %struct.file_operations* %5, null
  br i1 %tobool18, label %if.then19, label %do.body23

if.then19:                                        ; preds = %do.body17
  %f_op20 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %6 = load %struct.file_operations*, %struct.file_operations** %f_op20, align 8, !tbaa !54
  %owner21 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %6, i32 0, i32 0
  %7 = load %struct.module*, %struct.module** %owner21, align 8, !tbaa !52
  call void @module_put(%struct.module* %7)
  br label %do.body23

do.body23:                                        ; preds = %if.then19, %do.body17
  %f_op24 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  store %struct.file_operations* %cond, %struct.file_operations** %f_op24, align 8, !tbaa !54
  %tobool25 = icmp ne %struct.file_operations* %cond, null
  %lnot = xor i1 %tobool25, true
  %lnot26 = xor i1 %lnot, true
  %lnot27 = xor i1 %lnot26, true
  %lnot.ext = zext i1 %lnot27 to i32
  %conv28 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool29 = icmp ne i64 %expval, 0
  br i1 %tobool29, label %do.body31, label %do.end41

do.body31:                                        ; preds = %do.body23
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.1, i32 0, i32 0), i32 174, i64 12) #9, !srcloc !59
  br label %do.body32

do.body32:                                        ; preds = %do.body32, %do.body31
  br label %do.body32

do.end41:                                         ; preds = %do.body23
  %f_op42 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %8 = load %struct.file_operations*, %struct.file_operations** %f_op42, align 8, !tbaa !54
  %open = getelementptr inbounds %struct.file_operations, %struct.file_operations* %8, i32 0, i32 12
  %9 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %open, align 8, !tbaa !60
  %tobool43 = icmp ne i32 (%struct.inode*, %struct.file*)* %9, null
  br i1 %tobool43, label %if.then44, label %cleanup

if.then44:                                        ; preds = %do.end41
  %f_op45 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %10 = load %struct.file_operations*, %struct.file_operations** %f_op45, align 8, !tbaa !54
  %open46 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %10, i32 0, i32 12
  %11 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %open46, align 8, !tbaa !60
  %call47 = call i32 %11(%struct.inode* %inode, %struct.file* %file)
  br label %cleanup

cleanup:                                          ; preds = %if.then44, %do.end41, %cond.end, %if.then6, %entry
  %retval.0 = phi i32 [ -19, %if.then6 ], [ -19, %entry ], [ -19, %cond.end ], [ %call47, %if.then44 ], [ 0, %do.end41 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @iminor(%struct.inode* %inode) #5 {
entry:
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %0 = load i32, i32* %i_rdev, align 4, !tbaa !61
  %and = and i32 %0, 1048575
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal %struct.snd_minor* @autoload_device(i32 %minor) #0 {
entry:
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  %and = and i32 %minor, 31
  switch i32 %and, label %if.end6 [
    i32 0, label %if.then
    i32 1, label %if.then4
  ]

if.then:                                          ; preds = %entry
  %shr = lshr i32 %minor, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %0 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %cmp1 = icmp eq %struct.snd_card* %0, null
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.then
  call void @snd_request_card(i32 %shr)
  br label %if.end6

if.then4:                                         ; preds = %entry
  call void @snd_request_other(i32 %minor)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.then2, %if.then, %entry
  call void @mutex_lock_nested(%struct.mutex* @sound_mutex, i32 0)
  %idxprom7 = zext i32 %minor to i64
  %arrayidx8 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom7
  %1 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx8, align 8, !tbaa !2
  ret %struct.snd_minor* %1
}

declare zeroext i1 @try_module_get(%struct.module*) #1

declare void @module_put(%struct.module*) #1

; Function Attrs: nounwind uwtable
define internal void @snd_request_other(i32 %minor) #0 {
entry:
  %Pivot = icmp slt i32 %minor, 33
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %minor, 33
  br i1 %SwitchLeaf2, label %sw.epilog, label %cleanup.cont

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %minor, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %cleanup.cont

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1
  %str.0 = phi i8* [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.18, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.19, i32 0, i32 0), %LeafBlock1 ]
  %call = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* %str.0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %sw.epilog, %LeafBlock, %LeafBlock1
  %cleanup.dest.slot.0 = phi i32 [ 0, %sw.epilog ], [ 1, %LeafBlock ], [ 1, %LeafBlock1 ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @alsa_sound_exit() #4 section ".exit.text" {
entry:
  %call = call i32 @snd_info_done()
  %0 = load i32, i32* @major, align 4, !tbaa !47
  call void @unregister_chrdev(i32 %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.16, i32 0, i32 0))
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_power_wait(%struct.snd_card* %card, i32 %power_state) #0 {
entry:
  %wait = alloca %struct.__wait_queue, align 8
  %__ret = alloca i64, align 8
  %0 = bitcast %struct.__wait_queue* %wait to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %0) #9
  %call = call i32 @snd_power_get_state(%struct.snd_card* %card)
  %cmp = icmp eq i32 %call, %power_state
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call %struct.task_struct* @get_current()
  call void @init_waitqueue_entry(%struct.__wait_queue* %wait, %struct.task_struct* %call1)
  %power_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 35
  call void @add_wait_queue(%struct.__wait_queue_head* %power_sleep, %struct.__wait_queue* %wait)
  br label %while.cond

while.cond:                                       ; preds = %__here, %if.end
  %shutdown = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  %1 = load i32, i32* %shutdown, align 8, !tbaa !69
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %while.end, label %if.end3

if.end3:                                          ; preds = %while.cond
  %call4 = call i32 @snd_power_get_state(%struct.snd_card* %card)
  %cmp5 = icmp eq i32 %call4, %power_state
  br i1 %cmp5, label %while.end, label %__here

__here:                                           ; preds = %if.end3
  %call8 = call %struct.task_struct* @get_current()
  %task_state_change = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call8, i32 0, i32 208
  store i64 ptrtoint (i8* blockaddress(@snd_power_wait, %__here) to i64), i64* %task_state_change, align 32, !tbaa !70
  %2 = bitcast i64* %__ret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #9
  store volatile i64 2, i64* %__ret, align 8, !tbaa !104
  %3 = load volatile i64, i64* %__ret, align 8, !tbaa !104
  %call10 = call %struct.task_struct* @get_current()
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call10, i32 0, i32 1
  %4 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state, i64 %3, i64* %state) #9, !srcloc !105
  store volatile i64 %4, i64* %__ret, align 8, !tbaa !104
  %5 = load volatile i64, i64* %__ret, align 8, !tbaa !104
  %6 = bitcast i64* %__ret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #9
  call void @snd_power_unlock(%struct.snd_card* %card)
  %call14 = call i64 @schedule_timeout(i64 7500)
  call void @snd_power_lock(%struct.snd_card* %card)
  br label %while.cond

while.end:                                        ; preds = %if.end3, %while.cond
  %result.0 = phi i32 [ -19, %while.cond ], [ 0, %if.end3 ]
  %power_sleep15 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 35
  call void @remove_wait_queue(%struct.__wait_queue_head* %power_sleep15, %struct.__wait_queue* %wait)
  br label %cleanup

cleanup:                                          ; preds = %while.end, %entry
  %retval.0 = phi i32 [ %result.0, %while.end ], [ 0, %entry ]
  %7 = bitcast %struct.__wait_queue* %wait to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %7) #9
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #6

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @snd_power_get_state(%struct.snd_card* %card) #5 {
entry:
  %power_state = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 33
  %0 = load i32, i32* %power_state, align 4, !tbaa !106
  ret i32 %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #3 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !107
  ret %struct.task_struct* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_waitqueue_entry(%struct.__wait_queue* %q, %struct.task_struct* %p) #5 {
entry:
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !108
  %0 = bitcast %struct.task_struct* %p to i8*
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 1
  store i8* %0, i8** %private, align 8, !tbaa !110
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !111
  ret void
}

declare void @add_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #6

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_power_unlock(%struct.snd_card* %card) #5 {
entry:
  %power_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 34
  call void @mutex_unlock(%struct.mutex* %power_lock)
  ret void
}

declare i64 @schedule_timeout(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_power_lock(%struct.snd_card* %card) #5 {
entry:
  %power_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 34
  call void @mutex_lock_nested(%struct.mutex* %power_lock, i32 0)
  ret void
}

declare void @remove_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

declare i32 @default_wake_function(%struct.__wait_queue*, i32, i32, i8*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_card_file_remove(%struct.snd_card* %card, %struct.file* %file) #0 {
entry:
  %files_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @spin_lock(%struct.spinlock* %files_lock)
  %files_list = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 24
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list13.sink = phi %struct.list_head* [ %list4, %for.inc ], [ %files_list, %entry ]
  %next14 = getelementptr inbounds %struct.list_head, %struct.list_head* %list13.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next14, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %1, i64 -32
  %2 = bitcast i8* %add.ptr16 to %struct.snd_monitor_file*
  %list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 3
  %files_list1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 24
  %cmp = icmp ne %struct.list_head* %list, %files_list1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %file2 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 0
  %3 = load %struct.file*, %struct.file** %file2, align 8, !tbaa !112
  %cmp3 = icmp eq %struct.file* %3, %file
  %list4 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 3
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_del(%struct.list_head* %list4)
  call void @spin_lock(%struct.spinlock* @shutdown_lock)
  %shutdown_list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 2
  call void @list_del(%struct.list_head* %shutdown_list)
  call void @spin_unlock(%struct.spinlock* @shutdown_lock)
  %disconnected_f_op = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 1
  %4 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op, align 8, !tbaa !114
  %tobool = icmp ne %struct.file_operations* %4, null
  br i1 %tobool, label %do.body, label %for.end

do.body:                                          ; preds = %if.then
  %disconnected_f_op6 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 1
  %5 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op6, align 8, !tbaa !114
  %tobool7 = icmp ne %struct.file_operations* %5, null
  br i1 %tobool7, label %if.then8, label %for.end

if.then8:                                         ; preds = %do.body
  %disconnected_f_op9 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 1
  %6 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op9, align 8, !tbaa !114
  %owner = getelementptr inbounds %struct.file_operations, %struct.file_operations* %6, i32 0, i32 0
  %7 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !52
  call void @module_put(%struct.module* %7)
  br label %for.end

for.inc:                                          ; preds = %for.body
  br label %for.cond

for.end:                                          ; preds = %if.then8, %do.body, %if.then, %for.cond
  %found.0 = phi %struct.snd_monitor_file* [ %2, %do.body ], [ %2, %if.then8 ], [ %2, %if.then ], [ null, %for.cond ]
  %files_lock17 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @spin_unlock(%struct.spinlock* %files_lock17)
  %tobool18 = icmp ne %struct.snd_monitor_file* %found.0, null
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %for.end
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %8 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !115
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %8, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.24, i32 0, i32 0), %struct.file* %file)
  br label %cleanup

if.end20:                                         ; preds = %for.end
  %9 = bitcast %struct.snd_monitor_file* %found.0 to i8*
  call void @kfree(i8* %9)
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 30
  call void @put_device(%struct.device* %card_dev)
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %if.then19
  %retval.0 = phi i32 [ 0, %if.end20 ], [ -2, %if.then19 ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del(%struct.list_head* %entry1) #5 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !116
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @dev_err(%struct.device*, i8*, ...) #1

declare void @put_device(%struct.device*) #1

declare void @_raw_spin_unlock(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #5 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_del_entry_valid(%struct.list_head*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !49
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val3 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val3, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size(i8* %p, i8* %res, i32 %size) #3 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !49
  store volatile i8 %0, i8* %p, align 1, !tbaa !49
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !118
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !118
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !47
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !47
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !119
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !119
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !120
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !121
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #6

declare void @_raw_spin_lock(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define i32 @snd_card_file_add(%struct.snd_card* %card, %struct.file* %file) #0 {
entry:
  %call = call i8* @kmalloc.4(i64 48, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_monitor_file*
  %cmp = icmp eq %struct.snd_monitor_file* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %file1 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %0, i32 0, i32 0
  store %struct.file* %file, %struct.file** %file1, align 8, !tbaa !112
  %disconnected_f_op = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %0, i32 0, i32 1
  store %struct.file_operations* null, %struct.file_operations** %disconnected_f_op, align 8, !tbaa !114
  %shutdown_list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %0, i32 0, i32 2
  call void @INIT_LIST_HEAD(%struct.list_head* %shutdown_list)
  %files_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @spin_lock(%struct.spinlock* %files_lock)
  %shutdown = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  %1 = load i32, i32* %shutdown, align 8, !tbaa !69
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %files_lock3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @spin_unlock(%struct.spinlock* %files_lock3)
  %2 = bitcast %struct.snd_monitor_file* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %0, i32 0, i32 3
  %files_list = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 24
  call void @list_add(%struct.list_head* %list, %struct.list_head* %files_list)
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 30
  %call5 = call %struct.device* @get_device(%struct.device* %card_dev)
  %files_lock6 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @spin_unlock(%struct.spinlock* %files_lock6)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.then2, %entry
  %retval.0 = phi i32 [ -19, %if.then2 ], [ 0, %if.end4 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc.4(i64 %size, i32 %flags) #3 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !49
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #5 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !117
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !116
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !49
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val5 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val5, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare zeroext i1 @__list_add_valid(%struct.list_head*, %struct.list_head*, %struct.list_head*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_component_add(%struct.snd_card* %card, i8* %component) #0 {
entry:
  %call = call i64 @strlen(i8* %component)
  %conv = trunc i64 %call to i32
  %components = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 7
  %arraydecay = getelementptr inbounds [128 x i8], [128 x i8]* %components, i32 0, i32 0
  %call1 = call i8* @strstr(i8* %arraydecay, i8* %component)
  %cmp = icmp ne i8* %call1, null
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds i8, i8* %call1, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv3 = sext i8 %0 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %idxprom6 = sext i32 %conv to i64
  %arrayidx7 = getelementptr inbounds i8, i8* %call1, i64 %idxprom6
  %1 = load i8, i8* %arrayidx7, align 1, !tbaa !49
  %conv8 = sext i8 %1 to i32
  %cmp9 = icmp eq i32 %conv8, 32
  br i1 %cmp9, label %cleanup, label %if.end12

if.end12:                                         ; preds = %lor.lhs.false, %entry
  %components13 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 7
  %arraydecay14 = getelementptr inbounds [128 x i8], [128 x i8]* %components13, i32 0, i32 0
  %call15 = call i64 @strlen(i8* %arraydecay14)
  %add = add i64 %call15, 1
  %conv16 = sext i32 %conv to i64
  %add17 = add i64 %add, %conv16
  %add18 = add i64 %add17, 1
  %cmp19 = icmp ugt i64 %add18, 128
  br i1 %cmp19, label %if.then21, label %if.end34

if.then21:                                        ; preds = %if.end12
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot22 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot22 to i32
  %conv23 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool24 = icmp ne i64 %expval, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.then21
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.20, i32 0, i32 0), i32 890, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.4.89, i32 0, i32 0))
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %if.then21
  %tobool27 = icmp ne i32 1, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  br label %cleanup

if.end34:                                         ; preds = %if.end12
  %components35 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 7
  %arrayidx36 = getelementptr inbounds [128 x i8], [128 x i8]* %components35, i64 0, i64 0
  %2 = load i8, i8* %arrayidx36, align 4, !tbaa !49
  %conv37 = sext i8 %2 to i32
  %cmp38 = icmp ne i32 %conv37, 0
  br i1 %cmp38, label %if.then40, label %if.end44

if.then40:                                        ; preds = %if.end34
  %components41 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 7
  %arraydecay42 = getelementptr inbounds [128 x i8], [128 x i8]* %components41, i32 0, i32 0
  %call43 = call i8* @strcat(i8* %arraydecay42, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.23, i32 0, i32 0))
  br label %if.end44

if.end44:                                         ; preds = %if.then40, %if.end34
  %components45 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 7
  %arraydecay46 = getelementptr inbounds [128 x i8], [128 x i8]* %components45, i32 0, i32 0
  %call47 = call i8* @strcat(i8* %arraydecay46, i8* %component)
  br label %cleanup

cleanup:                                          ; preds = %if.end44, %if.end26, %lor.lhs.false, %if.then
  %retval.0 = phi i32 [ -12, %if.end26 ], [ 0, %if.end44 ], [ 1, %lor.lhs.false ], [ 1, %if.then ]
  ret i32 %retval.0
}

declare i64 @strlen(i8*) #1

declare i8* @strstr(i8*, i8*) #1

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #1

declare i8* @strcat(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_card_register(%struct.snd_card* %card) #0 {
entry:
  %tmpid = alloca [16 x i8], align 16
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.20, i32 0, i32 0), i32 739)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %registered = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 32
  %0 = load i8, i8* %registered, align 8, !tbaa !122, !range !123
  %tobool19 = trunc i8 %0 to i1
  br i1 %tobool19, label %if.end25, label %if.then20

if.then20:                                        ; preds = %if.end18
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 30
  %call = call i32 @device_add(%struct.device* %card_dev)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end23

if.end23:                                         ; preds = %if.then20
  %registered24 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 32
  store i8 1, i8* %registered24, align 8, !tbaa !122
  br label %if.end25

if.end25:                                         ; preds = %if.end23, %if.end18
  %call26 = call i32 @snd_device_register_all(%struct.snd_card* %card)
  %cmp27 = icmp slt i32 %call26, 0
  br i1 %cmp27, label %cleanup, label %if.end30

if.end30:                                         ; preds = %if.end25
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number, align 8, !tbaa !10
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %2 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %tobool31 = icmp ne %struct.snd_card* %2, null
  br i1 %tobool31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end30
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %call33 = call i32 @snd_info_card_register(%struct.snd_card* %card)
  br label %cleanup

if.end34:                                         ; preds = %if.end30
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %3 = load i8, i8* %arraydecay, align 4, !tbaa !49
  %tobool35 = icmp ne i8 %3, 0
  br i1 %tobool35, label %if.then36, label %if.else

if.then36:                                        ; preds = %if.end34
  %4 = bitcast [16 x i8]* %tmpid to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %4) #9
  %arraydecay37 = getelementptr inbounds [16 x i8], [16 x i8]* %tmpid, i32 0, i32 0
  %id38 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay39 = getelementptr inbounds [16 x i8], [16 x i8]* %id38, i32 0, i32 0
  %call40 = call i8* @__memcpy(i8* %arraydecay37, i8* %arraydecay39, i64 16)
  %arraydecay41 = getelementptr inbounds [16 x i8], [16 x i8]* %tmpid, i32 0, i32 0
  %arraydecay42 = getelementptr inbounds [16 x i8], [16 x i8]* %tmpid, i32 0, i32 0
  call void @snd_card_set_id_no_lock(%struct.snd_card* %card, i8* %arraydecay41, i8* %arraydecay42)
  %5 = bitcast [16 x i8]* %tmpid to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %5) #9
  br label %if.end50

if.else:                                          ; preds = %if.end34
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 3
  %arraydecay43 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  %6 = load i8, i8* %arraydecay43, align 4, !tbaa !49
  %conv44 = sext i8 %6 to i32
  %tobool45 = icmp ne i32 %conv44, 0
  %shortname46 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 3
  %arraydecay47 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname46, i32 0, i32 0
  %longname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 4
  %arraydecay48 = getelementptr inbounds [80 x i8], [80 x i8]* %longname, i32 0, i32 0
  %cond = select i1 %tobool45, i8* %arraydecay47, i8* %arraydecay48
  %call49 = call i8* @retrieve_id_from_card_name(i8* %cond)
  call void @snd_card_set_id_no_lock(%struct.snd_card* %card, i8* %cond, i8* %call49)
  br label %if.end50

if.end50:                                         ; preds = %if.else, %if.then36
  %number51 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %7 = load i32, i32* %number51, align 8, !tbaa !10
  %idxprom52 = sext i32 %7 to i64
  %arrayidx53 = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom52
  store %struct.snd_card* %card, %struct.snd_card** %arrayidx53, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  call void @init_info_for_card(%struct.snd_card* %card)
  %8 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %tobool55 = icmp ne i32 (%struct.snd_card*, i32)* %8, null
  br i1 %tobool55, label %if.then56, label %cleanup

if.then56:                                        ; preds = %if.end50
  %9 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %call57 = call i32 %9(%struct.snd_card* %card, i32 0)
  br label %cleanup

cleanup:                                          ; preds = %if.then56, %if.end50, %if.then32, %if.end25, %if.then20, %if.end
  %retval.0 = phi i32 [ %call33, %if.then32 ], [ -22, %if.end ], [ %call, %if.then20 ], [ %call26, %if.end25 ], [ 0, %if.then56 ], [ 0, %if.end50 ]
  ret i32 %retval.0
}

declare i8* @__memcpy(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @snd_card_set_id_no_lock(%struct.snd_card* %card, i8* %src, i8* %nid) #0 {
entry:
  %sfxstr = alloca [5 x i8], align 1
  call void @copy_valid_id_string(%struct.snd_card* %card, i8* %src, i8* %nid)
  %id1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id1, i32 0, i32 0
  br label %again

again:                                            ; preds = %if.then29, %entry
  %is_default.0 = phi i8 [ 0, %entry ], [ %is_default.1, %if.then29 ]
  %0 = load i8, i8* %arraydecay, align 1, !tbaa !49
  %tobool = icmp ne i8 %0, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %again
  %call = call i32 @strncmp(i8* %arraydecay, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11.141, i32 0, i32 0), i64 4)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %again
  %call3 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.32, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %is_default.1 = phi i8 [ %is_default.0, %lor.lhs.false ], [ 1, %if.then ]
  %call4 = call i64 @strlen(i8* %arraydecay)
  %conv = trunc i64 %call4 to i32
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %loops.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %loops.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = bitcast [5 x i8]* %sfxstr to i8*
  call void @llvm.lifetime.start.p0i8(i64 5, i8* %1) #9
  %call6 = call zeroext i1 @card_id_ok(%struct.snd_card* %card, i8* %arraydecay)
  br i1 %call6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %for.body
  %arraydecay9 = getelementptr inbounds [5 x i8], [5 x i8]* %sfxstr, i32 0, i32 0
  %add = add nsw i32 %loops.0, 1
  %call10 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay9, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.33, i32 0, i32 0), i32 %add)
  %arraydecay11 = getelementptr inbounds [5 x i8], [5 x i8]* %sfxstr, i32 0, i32 0
  %call12 = call i64 @strlen(i8* %arraydecay11)
  %conv13 = trunc i64 %call12 to i32
  %add14 = add nsw i32 %conv, %conv13
  %conv15 = sext i32 %add14 to i64
  %cmp16 = icmp uge i64 %conv15, 16
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 16
  %idx.ext = sext i32 %conv13 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr19 = getelementptr inbounds i8, i8* %add.ptr, i64 %idx.neg
  %add.ptr20 = getelementptr inbounds i8, i8* %add.ptr19, i64 -1
  %idx.ext21 = sext i32 %conv to i64
  %add.ptr22 = getelementptr inbounds i8, i8* %arraydecay, i64 %idx.ext21
  %spos.0 = select i1 %cmp16, i8* %add.ptr20, i8* %add.ptr22
  %arraydecay24 = getelementptr inbounds [5 x i8], [5 x i8]* %sfxstr, i32 0, i32 0
  %call25 = call i8* @strcpy(i8* %spos.0, i8* %arraydecay24)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end8 ], [ 1, %for.body ]
  %2 = bitcast [5 x i8]* %sfxstr to i8*
  call void @llvm.lifetime.end.p0i8(i64 5, i8* %2) #9
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup.cont44

for.inc:                                          ; preds = %cleanup
  %inc = add nsw i32 %loops.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool28 = trunc i8 %is_default.1 to i1
  br i1 %tobool28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %for.end
  store i8 0, i8* %arraydecay, align 1, !tbaa !49
  br label %again

if.end30:                                         ; preds = %for.end
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %3 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !115
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %3, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.34, i32 0, i32 0), i8* %arraydecay)
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %4 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !124
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %4, i32 0, i32 0
  %5 = load i8*, i8** %name, align 8, !tbaa !125
  %tobool31 = icmp ne i8* %5, null
  br i1 %tobool31, label %if.then32, label %cleanup.cont44

if.then32:                                        ; preds = %if.end30
  %id33 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay34 = getelementptr inbounds [16 x i8], [16 x i8]* %id33, i32 0, i32 0
  %proc_root35 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %6 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root35, align 8, !tbaa !124
  %name36 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %6, i32 0, i32 0
  %7 = load i8*, i8** %name36, align 8, !tbaa !125
  %call37 = call i64 @strlcpy(i8* %arraydecay34, i8* %7, i64 16)
  br label %cleanup.cont44

cleanup.cont44:                                   ; preds = %if.then32, %if.end30, %cleanup
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.then32 ], [ 0, %if.end30 ], [ %cleanup.dest.slot.0, %cleanup ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @retrieve_id_from_card_name(i8* %name) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %spos.0 = phi i8* [ %name, %entry ], [ %spos.1, %if.end ]
  %name.addr.0 = phi i8* [ %name, %entry ], [ %incdec.ptr, %if.end ]
  %0 = load i8, i8* %name.addr.0, align 1, !tbaa !49
  %tobool = icmp ne i8 %0, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i8, i8* %name.addr.0, align 1, !tbaa !49
  %conv = zext i8 %1 to i32
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv1 = zext i8 %2 to i32
  %and = and i32 %conv1, 32
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %arrayidx3 = getelementptr inbounds i8, i8* %name.addr.0, i64 1
  %3 = load i8, i8* %arrayidx3, align 1, !tbaa !49
  %conv4 = zext i8 %3 to i32
  %idxprom5 = sext i32 %conv4 to i64
  %arrayidx6 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom5
  %4 = load i8, i8* %arrayidx6, align 1, !tbaa !49
  %conv7 = zext i8 %4 to i32
  %and8 = and i32 %conv7, 7
  %cmp9 = icmp ne i32 %and8, 0
  %add.ptr = getelementptr inbounds i8, i8* %name.addr.0, i64 1
  %add.ptr.spos.0 = select i1 %cmp9, i8* %add.ptr, i8* %spos.0
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %while.body
  %spos.1 = phi i8* [ %spos.0, %while.body ], [ %add.ptr.spos.0, %land.lhs.true ]
  %incdec.ptr = getelementptr inbounds i8, i8* %name.addr.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret i8* %spos.0
}

; Function Attrs: nounwind uwtable
define internal void @init_info_for_card(%struct.snd_card* %card) #0 {
entry:
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !124
  %call = call %struct.snd_info_entry* @snd_info_create_card_entry(%struct.snd_card* %card, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), %struct.snd_info_entry* %0)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.end9, label %do.body2

do.body2:                                         ; preds = %entry
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @init_info_for_card.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool3 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %do.body2
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %1 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !115
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @init_info_for_card.descriptor to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.39, i32 0, i32 0))
  br label %cleanup

if.end9:                                          ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.58* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_card_id_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !49
  %proc_id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 22
  store %struct.snd_info_entry* %call, %struct.snd_info_entry** %proc_id, align 8, !tbaa !127
  %call10 = call i32 @snd_info_card_register(%struct.snd_card* %card)
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %if.then6, %do.body2
  %retval.0 = phi i32 [ %call10, %if.end9 ], [ -12, %if.then6 ], [ -12, %do.body2 ]
  ret void
}

declare void @__dynamic_dev_dbg(%struct._ddebug*, %struct.device*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal void @snd_card_id_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  %buffer2 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %0 = load i8*, i8** %buffer2, align 8, !tbaa !50
  %1 = bitcast i8* %0 to %struct.seq_file*
  %card = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 6
  %2 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !128
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18.21, i32 0, i32 0), i8* %arraydecay)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @copy_valid_id_string(%struct.snd_card* %card, i8* %src, i8* %nid) #0 {
entry:
  %id1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id1, i32 0, i32 0
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %nid.addr.0 = phi i8* [ %nid, %entry ], [ %incdec.ptr, %while.body ]
  %0 = load i8, i8* %nid.addr.0, align 1, !tbaa !49
  %conv = sext i8 %0 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %while.cond
  %1 = load i8, i8* %nid.addr.0, align 1, !tbaa !49
  %conv2 = zext i8 %1 to i32
  %idxprom = sext i32 %conv2 to i64
  %arrayidx = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv3 = zext i8 %2 to i32
  %and = and i32 %conv3, 7
  %cmp = icmp ne i32 %and, 0
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %incdec.ptr = getelementptr inbounds i8, i8* %nid.addr.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %land.rhs, %while.cond
  %3 = load i8, i8* %nid.addr.0, align 1, !tbaa !49
  %conv5 = sext i8 %3 to i32
  %call = call i32 @isdigit(i32 %conv5)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %4 = load i8, i8* %src, align 1, !tbaa !49
  %conv7 = zext i8 %4 to i32
  %idxprom8 = sext i32 %conv7 to i64
  %arrayidx9 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom8
  %5 = load i8, i8* %arrayidx9, align 1, !tbaa !49
  %conv10 = zext i8 %5 to i32
  %and11 = and i32 %conv10, 3
  %cmp12 = icmp ne i32 %and11, 0
  br i1 %cmp12, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then
  %6 = load i8, i8* %src, align 1, !tbaa !49
  %conv14 = sext i8 %6 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.then
  %cond = phi i32 [ %conv14, %cond.true ], [ 68, %if.then ]
  %conv15 = trunc i32 %cond to i8
  %incdec.ptr16 = getelementptr inbounds i8, i8* %arraydecay, i32 1
  store i8 %conv15, i8* %arraydecay, align 1, !tbaa !49
  br label %if.end

if.end:                                           ; preds = %cond.end, %while.end
  %id.0 = phi i8* [ %incdec.ptr16, %cond.end ], [ %arraydecay, %while.end ]
  br label %while.cond17

while.cond17:                                     ; preds = %if.end36, %if.end
  %nid.addr.1 = phi i8* [ %nid.addr.0, %if.end ], [ %incdec.ptr37, %if.end36 ]
  %id.1 = phi i8* [ %id.0, %if.end ], [ %id.2, %if.end36 ]
  %7 = load i8, i8* %nid.addr.1, align 1, !tbaa !49
  %conv18 = sext i8 %7 to i32
  %tobool19 = icmp ne i32 %conv18, 0
  %id21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay22 = getelementptr inbounds [16 x i8], [16 x i8]* %id21, i32 0, i32 0
  %sub.ptr.lhs.cast = ptrtoint i8* %id.1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %arraydecay22 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp23 = icmp ult i64 %sub.ptr.sub, 15
  %8 = select i1 %tobool19, i1 %cmp23, i1 false
  br i1 %8, label %while.body26, label %while.end38

while.body26:                                     ; preds = %while.cond17
  %9 = load i8, i8* %nid.addr.1, align 1, !tbaa !49
  %conv27 = zext i8 %9 to i32
  %idxprom28 = sext i32 %conv27 to i64
  %arrayidx29 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom28
  %10 = load i8, i8* %arrayidx29, align 1, !tbaa !49
  %conv30 = zext i8 %10 to i32
  %and31 = and i32 %conv30, 7
  %cmp32 = icmp ne i32 %and31, 0
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %while.body26
  %11 = load i8, i8* %nid.addr.1, align 1, !tbaa !49
  %incdec.ptr35 = getelementptr inbounds i8, i8* %id.1, i32 1
  store i8 %11, i8* %id.1, align 1, !tbaa !49
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %while.body26
  %id.2 = phi i8* [ %incdec.ptr35, %if.then34 ], [ %id.1, %while.body26 ]
  %incdec.ptr37 = getelementptr inbounds i8, i8* %nid.addr.1, i32 1
  br label %while.cond17

while.end38:                                      ; preds = %while.cond17
  store i8 0, i8* %id.1, align 1, !tbaa !49
  ret void
}

declare i32 @strncmp(i8*, i8*, i64) #1

declare i8* @strcpy(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal zeroext i1 @card_id_ok(%struct.snd_card* %card, i8* %id) #0 {
entry:
  %call = call i32 @snd_info_check_reserved_words(i8* %id)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %0 = load i32, i32* @snd_ecards_limit, align 4, !tbaa !47
  %cmp = icmp slt i32 %i.0, %0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %1 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %tobool1 = icmp ne %struct.snd_card* %1, null
  br i1 %tobool1, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %idxprom2 = sext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom2
  %2 = load %struct.snd_card*, %struct.snd_card** %arrayidx3, align 8, !tbaa !2
  %cmp4 = icmp ne %struct.snd_card* %2, %card
  br i1 %cmp4, label %land.lhs.true5, label %for.inc

land.lhs.true5:                                   ; preds = %land.lhs.true
  %idxprom6 = sext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom6
  %3 = load %struct.snd_card*, %struct.snd_card** %arrayidx7, align 8, !tbaa !2
  %id8 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id8, i32 0, i32 0
  %call9 = call i32 @strcmp(i8* %arraydecay, i8* %id)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %for.inc, label %cleanup

for.inc:                                          ; preds = %land.lhs.true5, %land.lhs.true, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %land.lhs.true5, %for.cond, %entry
  %retval.0 = phi i1 [ false, %entry ], [ false, %land.lhs.true5 ], [ true, %for.cond ]
  ret i1 %retval.0
}

declare i32 @sprintf(i8*, i8*, ...) #1

declare i64 @strlcpy(i8*, i8*, i64) #1

declare i32 @strcmp(i8*, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @isdigit(i32 %c) #5 {
entry:
  %cmp = icmp sle i32 48, %c
  %cmp1 = icmp sle i32 %c, 57
  %cmp1. = select i1 %cmp, i1 %cmp1, i1 false
  %land.ext = zext i1 %cmp1. to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_add_dev_attr(%struct.snd_card* %card, %struct.attribute_group* %group) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dev_groups = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 31
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.attribute_group*], [4 x %struct.attribute_group*]* %dev_groups, i64 0, i64 %idxprom
  %0 = load %struct.attribute_group*, %struct.attribute_group** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.attribute_group* %0, null
  br i1 %tobool, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %dev_groups2 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 31
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [4 x %struct.attribute_group*], [4 x %struct.attribute_group*]* %dev_groups2, i64 0, i64 %idxprom3
  store %struct.attribute_group* %group, %struct.attribute_group** %arrayidx4, align 8, !tbaa !2
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %1 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !115
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %1, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.17.22, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ -28, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @snd_card_set_id(%struct.snd_card* %card, i8* %nid) #0 {
entry:
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arrayidx = getelementptr inbounds [16 x i8], [16 x i8]* %id, i64 0, i64 0
  %0 = load i8, i8* %arrayidx, align 4, !tbaa !49
  %conv = sext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  call void @snd_card_set_id_no_lock(%struct.snd_card* %card, i8* %nid, i8* %nid)
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_free(%struct.snd_card* %card) #0 {
entry:
  %released = alloca %struct.completion, align 8
  %0 = bitcast %struct.completion* %released to i8*
  call void @llvm.lifetime.start.p0i8(i64 96, i8* %0) #9
  call void @init_completion(%struct.completion* %released)
  %release_completion = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 28
  store %struct.completion* %released, %struct.completion** %release_completion, align 8, !tbaa !129
  %call = call i32 @snd_card_free_when_closed(%struct.snd_card* %card)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @wait_for_completion(%struct.completion* %released)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  %1 = bitcast %struct.completion* %released to i8*
  call void @llvm.lifetime.end.p0i8(i64 96, i8* %1) #9
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_completion(%struct.completion* %x) #5 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 0
  store i32 0, i32* %done, align 8, !tbaa !130
  %wait = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 1
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.30, i32 0, i32 0), %struct.lock_class_key* @init_completion.__key)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_free_when_closed(%struct.snd_card* %card) #0 {
entry:
  %call = call i32 @snd_card_disconnect(%struct.snd_card* %card)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 30
  call void @put_device(%struct.device* %card_dev)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

declare void @wait_for_completion(%struct.completion*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_card_disconnect(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %files_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @spin_lock(%struct.spinlock* %files_lock)
  %shutdown = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  %0 = load i32, i32* %shutdown, align 8, !tbaa !69
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %files_lock3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @spin_unlock(%struct.spinlock* %files_lock3)
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %shutdown5 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  store i32 1, i32* %shutdown5, align 8, !tbaa !69
  %files_lock6 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @spin_unlock(%struct.spinlock* %files_lock6)
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number, align 8, !tbaa !10
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  store %struct.snd_card* null, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %number7 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %2 = load i32, i32* %number7, align 8, !tbaa !10
  %conv = sext i32 %2 to i64
  call void @clear_bit(i64 %conv, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @snd_cards_lock, i32 0, i32 0))
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %files_lock8 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @spin_lock(%struct.spinlock* %files_lock8)
  %files_list = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 24
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %list22.sink = phi %struct.list_head* [ %list22, %for.inc ], [ %files_list, %if.end4 ]
  %next23 = getelementptr inbounds %struct.list_head, %struct.list_head* %list22.sink, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next23, align 8, !tbaa !2
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr25 = getelementptr inbounds i8, i8* %4, i64 -32
  %5 = bitcast i8* %add.ptr25 to %struct.snd_monitor_file*
  %list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %5, i32 0, i32 3
  %files_list9 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 24
  %cmp = icmp ne %struct.list_head* %list, %files_list9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %file = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %5, i32 0, i32 0
  %6 = load %struct.file*, %struct.file** %file, align 8, !tbaa !112
  %f_op = getelementptr inbounds %struct.file, %struct.file* %6, i32 0, i32 3
  %7 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8, !tbaa !54
  %disconnected_f_op = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %5, i32 0, i32 1
  store %struct.file_operations* %7, %struct.file_operations** %disconnected_f_op, align 8, !tbaa !114
  call void @spin_lock(%struct.spinlock* @shutdown_lock)
  %shutdown_list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %5, i32 0, i32 2
  call void @list_add(%struct.list_head* %shutdown_list, %struct.list_head* @shutdown_files)
  call void @spin_unlock(%struct.spinlock* @shutdown_lock)
  %file11 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %5, i32 0, i32 0
  %8 = load %struct.file*, %struct.file** %file11, align 8, !tbaa !112
  %f_op12 = getelementptr inbounds %struct.file, %struct.file* %8, i32 0, i32 3
  store %struct.file_operations* @snd_shutdown_f_ops, %struct.file_operations** %f_op12, align 8, !tbaa !54
  %file13 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %5, i32 0, i32 0
  %9 = load %struct.file*, %struct.file** %file13, align 8, !tbaa !112
  %f_op14 = getelementptr inbounds %struct.file, %struct.file* %9, i32 0, i32 3
  %10 = load %struct.file_operations*, %struct.file_operations** %f_op14, align 8, !tbaa !54
  %tobool15 = icmp ne %struct.file_operations* %10, null
  br i1 %tobool15, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %file16 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %5, i32 0, i32 0
  %11 = load %struct.file*, %struct.file** %file16, align 8, !tbaa !112
  %f_op17 = getelementptr inbounds %struct.file, %struct.file* %11, i32 0, i32 3
  %12 = load %struct.file_operations*, %struct.file_operations** %f_op17, align 8, !tbaa !54
  %owner = getelementptr inbounds %struct.file_operations, %struct.file_operations* %12, i32 0, i32 0
  %13 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !52
  %call = call zeroext i1 @try_module_get(%struct.module* %13)
  br i1 %call, label %cond.true, label %for.inc

cond.true:                                        ; preds = %land.lhs.true
  %file19 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %5, i32 0, i32 0
  %14 = load %struct.file*, %struct.file** %file19, align 8, !tbaa !112
  %f_op20 = getelementptr inbounds %struct.file, %struct.file* %14, i32 0, i32 3
  %15 = load %struct.file_operations*, %struct.file_operations** %f_op20, align 8, !tbaa !54
  br label %for.inc

for.inc:                                          ; preds = %cond.true, %land.lhs.true, %for.body
  %cond = phi %struct.file_operations* [ %15, %cond.true ], [ null, %land.lhs.true ], [ null, %for.body ]
  %list22 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %5, i32 0, i32 3
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %files_lock26 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 26
  call void @spin_unlock(%struct.spinlock* %files_lock26)
  %16 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %tobool27 = icmp ne i32 (%struct.snd_card*, i32)* %16, null
  br i1 %tobool27, label %if.then28, label %if.end30

if.then28:                                        ; preds = %for.end
  %17 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %call29 = call i32 %17(%struct.snd_card* %card, i32 1)
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %for.end
  call void @snd_device_disconnect_all(%struct.snd_card* %card)
  call void @snd_info_card_disconnect(%struct.snd_card* %card)
  %registered = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 32
  %18 = load i8, i8* %registered, align 8, !tbaa !122, !range !123
  %tobool31 = trunc i8 %18 to i1
  br i1 %tobool31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end30
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 30
  call void @device_del(%struct.device* %card_dev)
  %registered33 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 32
  store i8 0, i8* %registered33, align 8, !tbaa !122
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end30
  %power_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 35
  call void @__wake_up(%struct.__wait_queue_head* %power_sleep, i32 3, i32 1, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.end34, %if.then2, %entry
  %retval.0 = phi i32 [ 0, %if.then2 ], [ 0, %if.end34 ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @clear_bit(i64 %nr, i64* %addr) #3 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i64 %nr, i64* %addr) #9, !srcloc !131
  ret void
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

; Function Attrs: nounwind uwtable
define internal i64 @snd_disconnect_llseek(%struct.file* %file, i64 %offset, i32 %orig) #0 {
entry:
  ret i64 -19
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_disconnect_read(%struct.file* %file, i8* %buf, i64 %count, i64* %offset) #0 {
entry:
  ret i64 -19
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_disconnect_write(%struct.file* %file, i8* %buf, i64 %count, i64* %offset) #0 {
entry:
  ret i64 -19
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_disconnect_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  ret i32 40
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_disconnect_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  ret i64 -19
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_disconnect_mmap(%struct.file* %file, %struct.vm_area_struct* %vma) #0 {
entry:
  ret i32 -19
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_disconnect_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  call void @spin_lock(%struct.spinlock* @shutdown_lock)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @shutdown_files, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %1, i64 -16
  %2 = bitcast i8* %add.ptr7 to %struct.snd_monitor_file*
  %shutdown_list = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 2
  %cmp = icmp ne %struct.list_head* %shutdown_list, @shutdown_files
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %file1 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 0
  %3 = load %struct.file*, %struct.file** %file1, align 8, !tbaa !112
  %cmp2 = icmp eq %struct.file* %3, %file
  %shutdown_list3 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %2, i32 0, i32 2
  br i1 %cmp2, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_del_init(%struct.list_head* %shutdown_list3)
  br label %for.end

for.inc:                                          ; preds = %for.body
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %shutdown_list3, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %df.0 = phi %struct.snd_monitor_file* [ %2, %if.then ], [ null, %for.cond ]
  call void @spin_unlock(%struct.spinlock* @shutdown_lock)
  %tobool = icmp ne %struct.snd_monitor_file* %df.0, null
  %lnot = xor i1 %tobool, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %if.end19

if.then10:                                        ; preds = %for.end
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 6
  %4 = load i32, i32* %f_flags, align 8, !tbaa !132
  %and = and i32 %4, 8192
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.then10
  %disconnected_f_op = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %df.0, i32 0, i32 1
  %5 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op, align 8, !tbaa !114
  %fasync = getelementptr inbounds %struct.file_operations, %struct.file_operations* %5, i32 0, i32 16
  %6 = load i32 (i32, %struct.file*, i32)*, i32 (i32, %struct.file*, i32)** %fasync, align 8, !tbaa !133
  %tobool12 = icmp ne i32 (i32, %struct.file*, i32)* %6, null
  br i1 %tobool12, label %if.then13, label %if.end16

if.then13:                                        ; preds = %land.lhs.true
  %disconnected_f_op14 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %df.0, i32 0, i32 1
  %7 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op14, align 8, !tbaa !114
  %fasync15 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %7, i32 0, i32 16
  %8 = load i32 (i32, %struct.file*, i32)*, i32 (i32, %struct.file*, i32)** %fasync15, align 8, !tbaa !133
  %call = call i32 %8(i32 -1, %struct.file* %file, i32 0)
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %land.lhs.true, %if.then10
  %disconnected_f_op17 = getelementptr inbounds %struct.snd_monitor_file, %struct.snd_monitor_file* %df.0, i32 0, i32 1
  %9 = load %struct.file_operations*, %struct.file_operations** %disconnected_f_op17, align 8, !tbaa !114
  %release = getelementptr inbounds %struct.file_operations, %struct.file_operations* %9, i32 0, i32 14
  %10 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %release, align 8, !tbaa !134
  %call18 = call i32 %10(%struct.inode* %inode, %struct.file* %file)
  ret i32 %call18

if.end19:                                         ; preds = %for.end
  call void (i8*, ...) @panic(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.29, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.snd_disconnect_release, i32 0, i32 0), %struct.inode* %inode, %struct.file* %file) #10
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_disconnect_fasync(i32 %fd, %struct.file* %file, i32 %on) #0 {
entry:
  ret i32 -19
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #5 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: noreturn
declare void @panic(i8*, ...) #7

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_card_new(%struct.device* %parent, i32 %idx, i8* %xid, %struct.module* %module, i32 %extra_size, %struct.snd_card** %card_ret) #0 {
entry:
  %tobool = icmp ne %struct.snd_card** %card_ret, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.20, i32 0, i32 0), i32 208)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  store %struct.snd_card* null, %struct.snd_card** %card_ret, align 8, !tbaa !2
  %cmp = icmp slt i32 %extra_size, 0
  %.extra_size = select i1 %cmp, i32 0, i32 %extra_size
  %conv22 = sext i32 %.extra_size to i64
  %add = add i64 4168, %conv22
  %call = call i8* @kzalloc(i64 %add, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_card*
  %tobool23 = icmp ne %struct.snd_card* %0, null
  br i1 %tobool23, label %if.end25, label %cleanup

if.end25:                                         ; preds = %if.end18
  %cmp26 = icmp sgt i32 %.extra_size, 0
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end25
  %1 = bitcast %struct.snd_card* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 4168
  %private_data = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 9
  store i8* %add.ptr, i8** %private_data, align 8, !tbaa !135
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end25
  %tobool30 = icmp ne i8* %xid, null
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end29
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %call32 = call i64 @strlcpy(i8* %arraydecay, i8* %xid, i64 16)
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end29
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %cmp34 = icmp slt i32 %idx, 0
  br i1 %cmp34, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.end33
  %call37 = call i32 @get_slot_from_bitmask(i32 %idx, i32 (%struct.module*, i32)* @module_slot_match, %struct.module* %module)
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.end33
  %idx.addr.0 = phi i32 [ %call37, %if.then36 ], [ %idx, %if.end33 ]
  %cmp39 = icmp slt i32 %idx.addr.0, 0
  br i1 %cmp39, label %if.then41, label %if.end43

if.then41:                                        ; preds = %if.end38
  %call42 = call i32 @get_slot_from_bitmask(i32 %idx.addr.0, i32 (%struct.module*, i32)* @check_empty_slot, %struct.module* %module)
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %if.end38
  %idx.addr.1 = phi i32 [ %call42, %if.then41 ], [ %idx.addr.0, %if.end38 ]
  %cmp44 = icmp slt i32 %idx.addr.1, 0
  br i1 %cmp44, label %if.end64, label %if.else

if.else:                                          ; preds = %if.end43
  %2 = load i32, i32* @snd_ecards_limit, align 4, !tbaa !47
  %cmp47 = icmp slt i32 %idx.addr.1, %2
  br i1 %cmp47, label %cond.false, label %if.else58

cond.false:                                       ; preds = %if.else
  %conv53 = sext i32 %idx.addr.1 to i64
  %call54 = call zeroext i1 @variable_test_bit(i64 %conv53, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @snd_cards_lock, i32 0, i32 0))
  %. = select i1 %call54, i32 -16, i32 0
  br label %if.end64

if.else58:                                        ; preds = %if.else
  %cmp59 = icmp sge i32 %idx.addr.1, 32
  %.1 = select i1 %cmp59, i32 -19, i32 0
  br label %if.end64

if.end64:                                         ; preds = %if.else58, %cond.false, %if.end43
  %err.3 = phi i32 [ -19, %if.end43 ], [ %., %cond.false ], [ %.1, %if.else58 ]
  %cmp65 = icmp slt i32 %err.3, 0
  br i1 %cmp65, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.end64
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %3 = load i32, i32* @snd_ecards_limit, align 4, !tbaa !47
  %sub = sub nsw i32 %3, 1
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %parent, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.1.23, i32 0, i32 0), i32 %idx.addr.1, i32 %sub, i32 %err.3)
  %4 = bitcast %struct.snd_card* %0 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

if.end68:                                         ; preds = %if.end64
  %conv69 = sext i32 %idx.addr.1 to i64
  call void @set_bit(i64 %conv69, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @snd_cards_lock, i32 0, i32 0))
  %5 = load i32, i32* @snd_ecards_limit, align 4, !tbaa !47
  %cmp70 = icmp sge i32 %idx.addr.1, %5
  br i1 %cmp70, label %if.then72, label %if.end74

if.then72:                                        ; preds = %if.end68
  %add73 = add nsw i32 %idx.addr.1, 1
  store i32 %add73, i32* @snd_ecards_limit, align 4, !tbaa !47
  br label %if.end74

if.end74:                                         ; preds = %if.then72, %if.end68
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 29
  store %struct.device* %parent, %struct.device** %dev, align 8, !tbaa !115
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 0
  store i32 %idx.addr.1, i32* %number, align 8, !tbaa !10
  %module75 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 8
  store %struct.module* %module, %struct.module** %module75, align 8, !tbaa !136
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 11
  call void @INIT_LIST_HEAD(%struct.list_head* %devices)
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @__init_rwsem(%struct.rw_semaphore* %controls_rwsem, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.2.24, i32 0, i32 0), %struct.lock_class_key* @snd_card_new.__key)
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 15
  call void @__rwlock_init(%struct.rwlock_t* %ctl_files_rwlock, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.4.25, i32 0, i32 0), %struct.lock_class_key* @snd_card_new.__key.3)
  %user_ctl_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 20
  call void @__mutex_init(%struct.mutex* %user_ctl_lock, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6.26, i32 0, i32 0), %struct.lock_class_key* @snd_card_new.__key.5)
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 18
  call void @INIT_LIST_HEAD(%struct.list_head* %controls)
  %ctl_files = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 19
  call void @INIT_LIST_HEAD(%struct.list_head* %ctl_files)
  %files_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 26
  call void @spinlock_check(%struct.spinlock* %files_lock)
  %files_lock85 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 26
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %files_lock85, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.8.27, i32 0, i32 0), %struct.lock_class_key* @snd_card_new.__key.7)
  %files_list = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 24
  call void @INIT_LIST_HEAD(%struct.list_head* %files_list)
  %power_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 34
  call void @__mutex_init(%struct.mutex* %power_lock, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.10.28, i32 0, i32 0), %struct.lock_class_key* @snd_card_new.__key.9)
  %power_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 35
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %power_sleep, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.12.29, i32 0, i32 0), %struct.lock_class_key* @snd_card_new.__key.11)
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 30
  call void @device_initialize(%struct.device* %card_dev)
  %card_dev96 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 30
  %parent97 = getelementptr inbounds %struct.device, %struct.device* %card_dev96, i32 0, i32 0
  store %struct.device* %parent, %struct.device** %parent97, align 8, !tbaa !137
  %7 = load %struct.class*, %struct.class** @sound_class, align 8, !tbaa !2
  %card_dev98 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 30
  %class = getelementptr inbounds %struct.device, %struct.device* %card_dev98, i32 0, i32 33
  store %struct.class* %7, %struct.class** %class, align 8, !tbaa !138
  %card_dev99 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 30
  %release = getelementptr inbounds %struct.device, %struct.device* %card_dev99, i32 0, i32 35
  store void (%struct.device*)* @release_card_device, void (%struct.device*)** %release, align 8, !tbaa !139
  %dev_groups = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 31
  %arraydecay100 = getelementptr inbounds [4 x %struct.attribute_group*], [4 x %struct.attribute_group*]* %dev_groups, i32 0, i32 0
  %card_dev101 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 30
  %groups = getelementptr inbounds %struct.device, %struct.device* %card_dev101, i32 0, i32 34
  store %struct.attribute_group** %arraydecay100, %struct.attribute_group*** %groups, align 8, !tbaa !140
  %dev_groups102 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 31
  %arrayidx = getelementptr inbounds [4 x %struct.attribute_group*], [4 x %struct.attribute_group*]* %dev_groups102, i64 0, i64 0
  store %struct.attribute_group* @card_dev_attr_group, %struct.attribute_group** %arrayidx, align 8, !tbaa !2
  %card_dev103 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 30
  %kobj = getelementptr inbounds %struct.device, %struct.device* %card_dev103, i32 0, i32 2
  %call104 = call i32 (%struct.kobject*, i8*, ...) @kobject_set_name(%struct.kobject* %kobj, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13.30, i32 0, i32 0), i32 %idx.addr.1)
  %cmp105 = icmp slt i32 %call104, 0
  br i1 %cmp105, label %__error, label %if.end108

if.end108:                                        ; preds = %if.end74
  %irq_descr = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 5
  %arraydecay109 = getelementptr inbounds [32 x i8], [32 x i8]* %irq_descr, i32 0, i32 0
  %dev110 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 29
  %8 = load %struct.device*, %struct.device** %dev110, align 8, !tbaa !115
  %call111 = call i8* @dev_driver_string(%struct.device* %8)
  %card_dev112 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 30
  %call113 = call i8* @dev_name(%struct.device* %card_dev112)
  %call114 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay109, i64 32, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.14.31, i32 0, i32 0), i8* %call111, i8* %call113)
  %call115 = call i32 @snd_ctl_create(%struct.snd_card* %0)
  %cmp116 = icmp slt i32 %call115, 0
  br i1 %cmp116, label %if.then118, label %if.end119

if.then118:                                       ; preds = %if.end108
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %parent, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.15.32, i32 0, i32 0))
  br label %__error

if.end119:                                        ; preds = %if.end108
  %call120 = call i32 @snd_info_card_create(%struct.snd_card* %0)
  %cmp121 = icmp slt i32 %call120, 0
  br i1 %cmp121, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.end119
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %parent, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.16.33, i32 0, i32 0))
  call void @snd_device_free_all(%struct.snd_card* %0)
  br label %__error

if.end124:                                        ; preds = %if.end119
  store %struct.snd_card* %0, %struct.snd_card** %card_ret, align 8, !tbaa !2
  br label %cleanup

__error:                                          ; preds = %if.then123, %if.then118, %if.end74
  %err.4 = phi i32 [ %call115, %if.then118 ], [ %call120, %if.then123 ], [ %call104, %if.end74 ]
  %card_dev125 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 30
  call void @put_device(%struct.device* %card_dev125)
  br label %cleanup

cleanup:                                          ; preds = %__error, %if.end124, %if.then67, %if.end18, %if.end
  %retval.0 = phi i32 [ %err.3, %if.then67 ], [ %err.4, %__error ], [ 0, %if.end124 ], [ -22, %if.end ], [ -12, %if.end18 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #5 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc.4(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @module_slot_match(%struct.module* %module, i32 %idx) #0 {
entry:
  %tobool = icmp ne %struct.module* %module, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup34

lor.lhs.false:                                    ; preds = %entry
  %name = getelementptr inbounds %struct.module, %struct.module* %module, i32 0, i32 2
  %arraydecay = getelementptr inbounds [56 x i8], [56 x i8]* %name, i32 0, i32 0
  %0 = load i8, i8* %arraydecay, align 8, !tbaa !49
  %tobool1 = icmp ne i8 %0, 0
  br i1 %tobool1, label %lor.lhs.false2, label %cleanup34

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %idxprom = sext i32 %idx to i64
  %arrayidx = getelementptr inbounds [32 x i8*], [32 x i8*]* @slots, i64 0, i64 %idxprom
  %1 = load i8*, i8** %arrayidx, align 8, !tbaa !2
  %tobool3 = icmp ne i8* %1, null
  br i1 %tobool3, label %if.end, label %cleanup34

if.end:                                           ; preds = %lor.lhs.false2
  %name4 = getelementptr inbounds %struct.module, %struct.module* %module, i32 0, i32 2
  %arraydecay5 = getelementptr inbounds [56 x i8], [56 x i8]* %name4, i32 0, i32 0
  %idxprom6 = sext i32 %idx to i64
  %arrayidx7 = getelementptr inbounds [32 x i8*], [32 x i8*]* @slots, i64 0, i64 %idxprom6
  %2 = load i8*, i8** %arrayidx7, align 8, !tbaa !2
  %3 = load i8, i8* %2, align 1, !tbaa !49
  %conv = sext i8 %3 to i32
  %cmp = icmp eq i32 %conv, 33
  %incdec.ptr = getelementptr inbounds i8, i8* %2, i32 1
  %incdec.ptr. = select i1 %cmp, i8* %incdec.ptr, i8* %2
  %. = select i1 %cmp, i32 0, i32 1
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.end
  %s2.1 = phi i8* [ %incdec.ptr., %if.end ], [ %incdec.ptr12, %cleanup.cont ]
  %s1.0 = phi i8* [ %arraydecay5, %if.end ], [ %incdec.ptr11, %cleanup.cont ]
  %retval.0 = phi i32 [ undef, %if.end ], [ %retval.1, %cleanup.cont ]
  %incdec.ptr11 = getelementptr inbounds i8, i8* %s1.0, i32 1
  %4 = load i8, i8* %s1.0, align 1, !tbaa !49
  %incdec.ptr12 = getelementptr inbounds i8, i8* %s2.1, i32 1
  %5 = load i8, i8* %s2.1, align 1, !tbaa !49
  %conv13 = sext i8 %4 to i32
  %cmp14 = icmp eq i32 %conv13, 45
  %.3 = select i1 %cmp14, i8 95, i8 %4
  %conv18 = sext i8 %5 to i32
  %cmp19 = icmp eq i32 %conv18, 45
  %c2.0 = select i1 %cmp19, i8 95, i8 %5
  %conv23 = sext i8 %.3 to i32
  %conv24 = sext i8 %c2.0 to i32
  %cmp25 = icmp ne i32 %conv23, %conv24
  br i1 %cmp25, label %if.then27, label %if.end29

if.then27:                                        ; preds = %for.cond
  %tobool28 = icmp ne i32 %., 0
  %lnot = xor i1 %tobool28, true
  %lnot.ext = zext i1 %lnot to i32
  br label %NodeBlock

if.end29:                                         ; preds = %for.cond
  %tobool30 = icmp ne i8 %.3, 0
  %.4 = select i1 %tobool30, i32 0, i32 2
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end29, %if.then27
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then27 ], [ %.4, %if.end29 ]
  %retval.1 = phi i32 [ %lnot.ext, %if.then27 ], [ %retval.0, %if.end29 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %cleanup34, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %cleanup.cont, label %NewDefault

cleanup.cont:                                     ; preds = %LeafBlock
  br label %for.cond

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %cleanup34

cleanup34:                                        ; preds = %NewDefault, %LeafBlock1, %lor.lhs.false2, %lor.lhs.false, %entry
  %retval.2 = phi i32 [ %retval.1, %NewDefault ], [ 0, %lor.lhs.false2 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ %., %LeafBlock1 ]
  ret i32 %retval.2
}

; Function Attrs: nounwind uwtable
define internal i32 @get_slot_from_bitmask(i32 %mask, i32 (%struct.module*, i32)* %check, %struct.module* %module) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %slot.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %slot.0, 32
  br i1 %cmp, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %for.cond
  %shl = shl i32 1, %slot.0
  %and = and i32 %mask, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.false, label %for.inc

cond.false:                                       ; preds = %land.lhs.true
  %conv3 = sext i32 %slot.0 to i64
  %call4 = call zeroext i1 @variable_test_bit(i64 %conv3, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @snd_cards_lock, i32 0, i32 0))
  br i1 %call4, label %for.inc, label %if.then6

if.then6:                                         ; preds = %cond.false
  %call7 = call i32 %check(%struct.module* %module, i32 %slot.0)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.then6, %cond.false, %land.lhs.true
  %inc = add nsw i32 %slot.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then6, %for.cond
  %retval.0 = phi i32 [ %slot.0, %if.then6 ], [ %mask, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @check_empty_slot(%struct.module* %module, i32 %slot) #0 {
entry:
  %idxprom = sext i32 %slot to i64
  %arrayidx = getelementptr inbounds [32 x i8*], [32 x i8*]* @slots, i64 0, i64 %idxprom
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %idxprom1 = sext i32 %slot to i64
  %arrayidx2 = getelementptr inbounds [32 x i8*], [32 x i8*]* @slots, i64 0, i64 %idxprom1
  %1 = load i8*, i8** %arrayidx2, align 8, !tbaa !2
  %2 = load i8, i8* %1, align 1, !tbaa !49
  %tobool3 = icmp ne i8 %2, 0
  %lnot = xor i1 %tobool3, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  ret i32 %lor.ext
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @variable_test_bit(i64 %nr, i64* %addr) #3 {
entry:
  %oldbit = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %oldbit) #9
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit, i64* %addr, i64 %nr) #9, !srcloc !141
  %0 = load i8, i8* %oldbit, align 1, !tbaa !142, !range !123
  %tobool = trunc i8 %0 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %oldbit) #9
  ret i1 %tobool
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @set_bit(i64 %nr, i64* %addr) #3 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i64 %nr, i64* %addr) #9, !srcloc !143
  ret void
}

declare void @__init_rwsem(%struct.rw_semaphore*, i8*, %struct.lock_class_key*) #1

declare void @__rwlock_init(%struct.rwlock_t*, i8*, %struct.lock_class_key*) #1

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spinlock_check(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  ret void
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #1

declare void @device_initialize(%struct.device*) #1

; Function Attrs: nounwind uwtable
define internal void @release_card_device(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -2440
  %1 = bitcast i8* %add.ptr to %struct.snd_card*
  call void @snd_card_do_free(%struct.snd_card* %1)
  ret void
}

declare i32 @kobject_set_name(%struct.kobject*, i8*, ...) #1

declare i8* @dev_driver_string(%struct.device*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name(%struct.device* %dev) #5 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !144
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !144
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

declare i32 @snprintf(i8*, i64, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name(%struct.kobject* %kobj) #5 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !145
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i64 @card_number_show_attr(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -2440
  %1 = bitcast i8* %add.ptr to %struct.snd_card*
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 0
  %2 = load i32, i32* %number, align 8, !tbaa !10
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.37, i32 0, i32 0), i32 %2)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @card_id_show_attr(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -2440
  %1 = bitcast i8* %add.ptr to %struct.snd_card*
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %buf, i64 4096, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18.21, i32 0, i32 0), i8* %arraydecay)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @card_id_store_attr(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %buf1 = alloca [16 x i8], align 16
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -2440
  %1 = bitcast i8* %add.ptr to %struct.snd_card*
  %2 = bitcast [16 x i8]* %buf1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %2) #9
  %cmp = icmp ugt i64 %count, 15
  %.count = select i1 %cmp, i64 15, i64 %count
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %idx.0 = phi i64 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp1 = icmp ult i64 %idx.0, %.count
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds i8, i8* %buf, i64 %idx.0
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv = sext i8 %3 to i32
  %conv2 = trunc i32 %conv to i8
  %conv3 = zext i8 %conv2 to i32
  %idxprom = sext i32 %conv3 to i64
  %arrayidx4 = getelementptr inbounds [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %4 = load i8, i8* %arrayidx4, align 1, !tbaa !49
  %conv5 = zext i8 %4 to i32
  %and = and i32 %conv5, 7
  %cmp6 = icmp eq i32 %and, 0
  br i1 %cmp6, label %switch.early.test, label %for.inc

switch.early.test:                                ; preds = %for.body
  switch i32 %conv, label %cleanup [
    i32 95, label %for.inc
    i32 45, label %for.inc
  ]

for.inc:                                          ; preds = %switch.early.test, %switch.early.test, %for.body
  %inc = add i64 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %buf1, i32 0, i32 0
  %call = call i8* @__memcpy(i8* %arraydecay, i8* %buf, i64 %.count)
  %arrayidx13 = getelementptr inbounds [16 x i8], [16 x i8]* %buf1, i64 0, i64 %.count
  store i8 0, i8* %arrayidx13, align 1, !tbaa !49
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %arraydecay14 = getelementptr inbounds [16 x i8], [16 x i8]* %buf1, i32 0, i32 0
  %call15 = call zeroext i1 @card_id_ok(%struct.snd_card* null, i8* %arraydecay14)
  br i1 %call15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %for.end
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  br label %cleanup

if.end17:                                         ; preds = %for.end
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 1
  %arraydecay18 = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %buf1, i32 0, i32 0
  %call20 = call i8* @strcpy(i8* %arraydecay18, i8* %arraydecay19)
  call void @snd_info_card_id_change(%struct.snd_card* %1)
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %if.then16, %switch.early.test
  %retval.0 = phi i64 [ %count, %if.end17 ], [ -17, %if.then16 ], [ -22, %switch.early.test ]
  %5 = bitcast [16 x i8]* %buf1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %5) #9
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_card_do_free(%struct.snd_card* %card) #0 {
entry:
  %0 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %tobool = icmp ne i32 (%struct.snd_card*, i32)* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32 (%struct.snd_card*, i32)*, i32 (%struct.snd_card*, i32)** @snd_mixer_oss_notify_callback, align 8, !tbaa !2
  %call = call i32 %1(%struct.snd_card* %card, i32 2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @snd_device_free_all(%struct.snd_card* %card)
  %private_free = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  %2 = load void (%struct.snd_card*)*, void (%struct.snd_card*)** %private_free, align 8, !tbaa !146
  %tobool1 = icmp ne void (%struct.snd_card*)* %2, null
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %private_free3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 10
  %3 = load void (%struct.snd_card*)*, void (%struct.snd_card*)** %private_free3, align 8, !tbaa !146
  call void %3(%struct.snd_card* %card)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %proc_id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 22
  %4 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_id, align 8, !tbaa !127
  call void @snd_info_free_entry(%struct.snd_info_entry* %4)
  %call5 = call i32 @snd_info_card_free(%struct.snd_card* %card)
  %cmp = icmp slt i32 %call5, 0
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %5 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !115
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %5, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.27, i32 0, i32 0))
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end4
  %release_completion = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 28
  %6 = load %struct.completion*, %struct.completion** %release_completion, align 8, !tbaa !129
  %tobool8 = icmp ne %struct.completion* %6, null
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end7
  %release_completion10 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 28
  %7 = load %struct.completion*, %struct.completion** %release_completion10, align 8, !tbaa !129
  call void @complete(%struct.completion* %7)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end7
  %8 = bitcast %struct.snd_card* %card to i8*
  call void @kfree(i8* %8)
  ret void
}

declare void @dev_warn(%struct.device*, i8*, ...) #1

declare void @complete(%struct.completion*) #1

; Function Attrs: nounwind uwtable
define void @snd_device_initialize(%struct.device* %dev, %struct.snd_card* %card) #0 {
entry:
  call void @device_initialize(%struct.device* %dev)
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 30
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  store %struct.device* %card_dev, %struct.device** %parent, align 8, !tbaa !147
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %0 = load %struct.class*, %struct.class** @sound_class, align 8, !tbaa !2
  %class = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 33
  store %struct.class* %0, %struct.class** %class, align 8, !tbaa !148
  %release = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 35
  store void (%struct.device*)* @default_release, void (%struct.device*)** %release, align 8, !tbaa !149
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @default_release(%struct.device* %dev) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_locked(i32 %card) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %conv = sext i32 %card to i64
  %call = call zeroext i1 @variable_test_bit(i64 %conv, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @snd_cards_lock, i32 0, i32 0))
  %conv1 = zext i1 %call to i32
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define void @snd_card_info_read_oss(%struct.snd_info_buffer* %buffer) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %idx.0 = phi i32 [ 0, %entry ], [ %inc3, %if.end ]
  %count.0 = phi i32 [ 0, %entry ], [ %count.1, %if.end ]
  %cmp = icmp slt i32 %idx.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %0 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %cmp1 = icmp ne %struct.snd_card* %0, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %inc = add nsw i32 %count.0, 1
  %buffer2 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %1 = load i8*, i8** %buffer2, align 8, !tbaa !50
  %2 = bitcast i8* %1 to %struct.seq_file*
  %longname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 4
  %arraydecay = getelementptr inbounds [80 x i8], [80 x i8]* %longname, i32 0, i32 0
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.18.21, i32 0, i32 0), i8* %arraydecay)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %count.1 = phi i32 [ %inc, %if.then ], [ %count.0, %for.body ]
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %inc3 = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool = icmp ne i32 %count.0, 0
  br i1 %tobool, label %if.end6, label %if.then4

if.then4:                                         ; preds = %for.end
  %buffer5 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %3 = load i8*, i8** %buffer5, align 8, !tbaa !50
  %4 = bitcast i8* %3 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %4, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.19.36, i32 0, i32 0))
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_card_info_init() #4 section ".init.text" {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6.148, i32 0, i32 0), %struct.snd_info_entry* null)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.58* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_card_info_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !49
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.21, i32 0, i32 0), %struct.snd_info_entry* null)
  %tobool6 = icmp ne %struct.snd_info_entry* %call5, null
  br i1 %tobool6, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.end4
  %c9 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call5, i32 0, i32 4
  %text10 = bitcast %union.anon.58* %c9 to %struct.snd_info_entry_text*
  %read11 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text10, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_card_module_info_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read11, align 8, !tbaa !49
  %call12 = call i32 @snd_info_register(%struct.snd_info_entry* %call5)
  %cmp13 = icmp slt i32 %call12, 0
  %. = select i1 %cmp13, i32 -12, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ -12, %if.end ], [ -12, %if.end4 ], [ %., %if.end8 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_card_info_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %idx.0 = phi i32 [ 0, %entry ], [ %inc8, %if.end ]
  %count.0 = phi i32 [ 0, %entry ], [ %count.1, %if.end ]
  %cmp = icmp slt i32 %idx.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %0 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %cmp2 = icmp ne %struct.snd_card* %0, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %inc = add nsw i32 %count.0, 1
  %buffer3 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %1 = load i8*, i8** %buffer3, align 8, !tbaa !50
  %2 = bitcast i8* %1 to %struct.seq_file*
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %driver = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [16 x i8], [16 x i8]* %driver, i32 0, i32 0
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 3
  %arraydecay5 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.40, i32 0, i32 0), i32 %idx.0, i8* %arraydecay, i8* %arraydecay4, i8* %arraydecay5)
  %buffer6 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %3 = load i8*, i8** %buffer6, align 8, !tbaa !50
  %4 = bitcast i8* %3 to %struct.seq_file*
  %longname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 4
  %arraydecay7 = getelementptr inbounds [80 x i8], [80 x i8]* %longname, i32 0, i32 0
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %4, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.41, i32 0, i32 0), i8* %arraydecay7)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %count.1 = phi i32 [ %inc, %if.then ], [ %count.0, %for.body ]
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %inc8 = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool = icmp ne i32 %count.0, 0
  br i1 %tobool, label %if.end11, label %if.then9

if.then9:                                         ; preds = %for.end
  %buffer10 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %5 = load i8*, i8** %buffer10, align 8, !tbaa !50
  %6 = bitcast i8* %5 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %6, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.19.36, i32 0, i32 0))
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snd_card_module_info_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %idx.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %cmp = icmp slt i32 %idx.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @mutex_lock_nested(%struct.mutex* @snd_card_mutex, i32 0)
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %0 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %cmp2 = icmp ne %struct.snd_card* %0, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %buffer3 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %1 = load i8*, i8** %buffer3, align 8, !tbaa !50
  %2 = bitcast i8* %1 to %struct.seq_file*
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 8
  %3 = load %struct.module*, %struct.module** %module, align 8, !tbaa !136
  %name = getelementptr inbounds %struct.module, %struct.module* %3, i32 0, i32 2
  %arraydecay = getelementptr inbounds [56 x i8], [56 x i8]* %name, i32 0, i32 0
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.42, i32 0, i32 0), i32 %idx.0, i8* %arraydecay)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  call void @mutex_unlock(%struct.mutex* @snd_card_mutex)
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @copy_from_user_toio(i8* %dst, i8* %src, i64 %count) #0 {
entry:
  %buf = alloca [256 x i8], align 16
  %0 = bitcast [256 x i8]* %buf to i8*
  call void @llvm.lifetime.start.p0i8(i64 256, i8* %0) #9
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %entry
  %count.addr.0 = phi i64 [ %count, %entry ], [ %count.addr.1, %cleanup.cont ]
  %src.addr.0 = phi i8* [ %src, %entry ], [ %src.addr.1, %cleanup.cont ]
  %dst.addr.0 = phi i8* [ %dst, %entry ], [ %dst.addr.1, %cleanup.cont ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %cleanup.cont ]
  %tobool = icmp ne i64 %count.addr.0, 0
  br i1 %tobool, label %while.body, label %cleanup6

while.body:                                       ; preds = %while.cond
  %cmp = icmp ugt i64 %count.addr.0, 256
  %.count.addr.0 = select i1 %cmp, i64 256, i64 %count.addr.0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %buf, i32 0, i32 0
  %call = call i64 @copy_from_user(i8* %arraydecay, i8* %src.addr.0, i64 %.count.addr.0)
  %tobool1 = icmp ne i64 %call, 0
  br i1 %tobool1, label %LeafBlock, label %if.end3

if.end3:                                          ; preds = %while.body
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %buf, i32 0, i32 0
  call void @memcpy_toio(i8* %dst.addr.0, i8* %arraydecay4, i64 %.count.addr.0)
  %sub = sub i64 %count.addr.0, %.count.addr.0
  %add.ptr = getelementptr i8, i8* %dst.addr.0, i64 %.count.addr.0
  %add.ptr5 = getelementptr i8, i8* %src.addr.0, i64 %.count.addr.0
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end3, %while.body
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end3 ], [ 1, %while.body ]
  %count.addr.1 = phi i64 [ %sub, %if.end3 ], [ %count.addr.0, %while.body ]
  %src.addr.1 = phi i8* [ %add.ptr5, %if.end3 ], [ %src.addr.0, %while.body ]
  %dst.addr.1 = phi i8* [ %add.ptr, %if.end3 ], [ %dst.addr.0, %while.body ]
  %retval.1 = phi i32 [ %retval.0, %if.end3 ], [ -14, %while.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %cleanup.cont, label %cleanup6

cleanup.cont:                                     ; preds = %LeafBlock
  br label %while.cond

cleanup6:                                         ; preds = %LeafBlock, %while.cond
  %retval.2 = phi i32 [ 0, %while.cond ], [ %retval.1, %LeafBlock ]
  %1 = bitcast [256 x i8]* %buf to i8*
  call void @llvm.lifetime.end.p0i8(i64 256, i8* %1) #9
  ret i32 %retval.2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #3 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.18.119, i32 0, i32 0), i32 696)
  %conv1 = trunc i64 %n to i32
  call void @kasan_check_write(i8* %to, i32 %conv1)
  %cmp = icmp slt i32 %conv, 0
  %conv3 = sext i32 %conv to i64
  %cmp4 = icmp uge i64 %conv3, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp4
  %lnot = xor i1 %1, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @check_object_size(i8* %to, i64 %n, i1 zeroext false)
  %conv8 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @copy_user_overflow(i32 %conv, i64 %n)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.else ]
  ret i64 %n.addr.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @memcpy_toio(i8* %dst, i8* %src, i64 %count) #5 {
entry:
  %call = call i8* @__memcpy(i8* %dst, i8* %src, i64 %count)
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #8

declare void @__might_fault(i8*, i32) #1

declare void @kasan_check_write(i8*, i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @check_object_size(i8* %ptr, i64 %n, i1 zeroext %to_user) #3 {
entry:
  %frombool = zext i1 %to_user to i8
  %tobool = trunc i8 %frombool to i1
  call void @__check_object_size(i8* %ptr, i64 %n, i1 zeroext %tobool)
  ret void
}

declare i64 @_copy_from_user(i8*, i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @copy_user_overflow(i32 %size, i64 %count) #5 {
entry:
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.18.119, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.19.122, i32 0, i32 0), i32 %size, i64 %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool3 = icmp ne i32 1, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %expval9 = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  ret void
}

declare void @__check_object_size(i8*, i64, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define i32 @copy_to_user_fromio(i8* %dst, i8* %src, i64 %count) #0 {
entry:
  %buf = alloca [256 x i8], align 16
  %0 = bitcast [256 x i8]* %buf to i8*
  call void @llvm.lifetime.start.p0i8(i64 256, i8* %0) #9
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %entry
  %count.addr.0 = phi i64 [ %count, %entry ], [ %count.addr.1, %cleanup.cont ]
  %src.addr.0 = phi i8* [ %src, %entry ], [ %src.addr.1, %cleanup.cont ]
  %dst.addr.0 = phi i8* [ %dst, %entry ], [ %dst.addr.1, %cleanup.cont ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %cleanup.cont ]
  %tobool = icmp ne i64 %count.addr.0, 0
  br i1 %tobool, label %while.body, label %cleanup6

while.body:                                       ; preds = %while.cond
  %cmp = icmp ugt i64 %count.addr.0, 256
  %.count.addr.0 = select i1 %cmp, i64 256, i64 %count.addr.0
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %buf, i32 0, i32 0
  call void @memcpy_fromio(i8* %arraydecay, i8* %src.addr.0, i64 %.count.addr.0)
  %arraydecay1 = getelementptr inbounds [256 x i8], [256 x i8]* %buf, i32 0, i32 0
  %call = call i64 @copy_to_user(i8* %dst.addr.0, i8* %arraydecay1, i64 %.count.addr.0)
  %tobool2 = icmp ne i64 %call, 0
  br i1 %tobool2, label %LeafBlock, label %if.end4

if.end4:                                          ; preds = %while.body
  %sub = sub i64 %count.addr.0, %.count.addr.0
  %add.ptr = getelementptr i8, i8* %dst.addr.0, i64 %.count.addr.0
  %add.ptr5 = getelementptr i8, i8* %src.addr.0, i64 %.count.addr.0
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end4, %while.body
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end4 ], [ 1, %while.body ]
  %count.addr.1 = phi i64 [ %sub, %if.end4 ], [ %count.addr.0, %while.body ]
  %src.addr.1 = phi i8* [ %add.ptr5, %if.end4 ], [ %src.addr.0, %while.body ]
  %dst.addr.1 = phi i8* [ %add.ptr, %if.end4 ], [ %dst.addr.0, %while.body ]
  %retval.1 = phi i32 [ %retval.0, %if.end4 ], [ -14, %while.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %cleanup.cont, label %cleanup6

cleanup.cont:                                     ; preds = %LeafBlock
  br label %while.cond

cleanup6:                                         ; preds = %LeafBlock, %while.cond
  %retval.2 = phi i32 [ 0, %while.cond ], [ %retval.1, %LeafBlock ]
  %1 = bitcast [256 x i8]* %buf to i8*
  call void @llvm.lifetime.end.p0i8(i64 256, i8* %1) #9
  ret i32 %retval.2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @memcpy_fromio(i8* %dst, i8* %src, i64 %count) #5 {
entry:
  %call = call i8* @__memcpy(i8* %dst, i8* %src, i64 %count)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @copy_to_user(i8* %to, i8* %from, i64 %n) #3 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %from, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  %conv1 = trunc i64 %n to i32
  call void @kasan_check_read(i8* %from, i32 %conv1)
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.18.119, i32 0, i32 0), i32 718)
  %cmp = icmp slt i32 %conv, 0
  %conv3 = sext i32 %conv to i64
  %cmp4 = icmp uge i64 %conv3, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp4
  %lnot = xor i1 %1, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @check_object_size(i8* %from, i64 %n, i1 zeroext true)
  %conv8 = trunc i64 %n to i32
  %call = call i64 @_copy_to_user(i8* %to, i8* %from, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @copy_user_overflow(i32 %conv, i64 %n)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.else ]
  ret i64 %n.addr.0
}

declare void @kasan_check_read(i8*, i32) #1

declare i64 @_copy_to_user(i8*, i8*, i32) #1

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_enum_info(%struct.snd_ctl_elem_info* %info, i32 %channels, i32 %items, i8** %names) #0 {
entry:
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 1
  store i32 3, i32* %type, align 8, !tbaa !150
  %count = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  store i32 %channels, i32* %count, align 8, !tbaa !153
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated = bitcast %union.anon.59* %value to %struct.anon.62*
  %items1 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated, i32 0, i32 0
  store i32 %items, i32* %items1, align 8, !tbaa !49
  %tobool = icmp ne i32 %items, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %value2 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated3 = bitcast %union.anon.59* %value2 to %struct.anon.62*
  %item = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated3, i32 0, i32 1
  %0 = load i32, i32* %item, align 4, !tbaa !49
  %cmp = icmp uge i32 %0, %items
  br i1 %cmp, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %sub = sub i32 %items, 1
  %value5 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated6 = bitcast %union.anon.59* %value5 to %struct.anon.62*
  %item7 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated6, i32 0, i32 1
  store i32 %sub, i32* %item7, align 4, !tbaa !49
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  %value9 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated10 = bitcast %union.anon.59* %value9 to %struct.anon.62*
  %item11 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated10, i32 0, i32 1
  %1 = load i32, i32* %item11, align 4, !tbaa !49
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %names, i64 %idxprom
  %2 = load i8*, i8** %arrayidx, align 8, !tbaa !2
  %call = call i64 @strlen(i8* %2)
  %cmp12 = icmp uge i64 %call, 64
  %lnot = xor i1 %cmp12, true
  %lnot13 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot13 to i32
  %tobool14 = icmp ne i32 %lnot.ext, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv = sext i32 %lnot.ext18 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool19 = icmp ne i64 %expval, 0
  br i1 %tobool19, label %if.then20, label %if.end26

if.then20:                                        ; preds = %if.end8
  %value21 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated22 = bitcast %union.anon.59* %value21 to %struct.anon.62*
  %item23 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated22, i32 0, i32 1
  %3 = load i32, i32* %item23, align 4, !tbaa !49
  %idxprom24 = zext i32 %3 to i64
  %arrayidx25 = getelementptr inbounds i8*, i8** %names, i64 %idxprom24
  %4 = load i8*, i8** %arrayidx25, align 8, !tbaa !2
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1924, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.5.47, i32 0, i32 0), i8* %4)
  br label %if.end26

if.end26:                                         ; preds = %if.then20, %if.end8
  %tobool27 = icmp ne i32 %lnot.ext, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %value34 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated35 = bitcast %union.anon.59* %value34 to %struct.anon.62*
  %name = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated35, i32 0, i32 2
  %arraydecay = getelementptr inbounds [64 x i8], [64 x i8]* %name, i32 0, i32 0
  %value36 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated37 = bitcast %union.anon.59* %value36 to %struct.anon.62*
  %item38 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated37, i32 0, i32 1
  %5 = load i32, i32* %item38, align 4, !tbaa !49
  %idxprom39 = zext i32 %5 to i64
  %arrayidx40 = getelementptr inbounds i8*, i8** %names, i64 %idxprom39
  %6 = load i8*, i8** %arrayidx40, align 8, !tbaa !2
  %call41 = call i64 @strlcpy(i8* %arraydecay, i8* %6, i64 64)
  br label %return

return:                                           ; preds = %if.end26, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_boolean_stereo_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 1
  store i32 1, i32* %type, align 8, !tbaa !150
  %count = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 3
  store i32 2, i32* %count, align 8, !tbaa !153
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer = bitcast %union.anon.59* %value to %struct.task_cputime*
  %min = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer, i32 0, i32 0
  store i64 0, i64* %min, align 8, !tbaa !49
  %value1 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer2 = bitcast %union.anon.59* %value1 to %struct.task_cputime*
  %max = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer2, i32 0, i32 1
  store i64 1, i64* %max, align 8, !tbaa !49
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_boolean_mono_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 1
  store i32 1, i32* %type, align 8, !tbaa !150
  %count = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 3
  store i32 1, i32* %count, align 8, !tbaa !153
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer = bitcast %union.anon.59* %value to %struct.task_cputime*
  %min = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer, i32 0, i32 0
  store i64 0, i64* %min, align 8, !tbaa !49
  %value1 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer2 = bitcast %union.anon.59* %value1 to %struct.task_cputime*
  %max = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer2, i32 0, i32 1
  store i64 1, i64* %max, align 8, !tbaa !49
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_get_preferred_subdevice(%struct.snd_card* %card, i32 %type) #0 {
entry:
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 15
  call void @_raw_read_lock(%struct.rwlock_t* %ctl_files_rwlock)
  %ctl_files = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 19
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list8.sink = phi %struct.list_head* [ %list8, %for.inc ], [ %ctl_files, %entry ]
  %subdevice.0 = phi i32 [ -1, %entry ], [ %subdevice.1, %for.inc ]
  %next9 = getelementptr inbounds %struct.list_head, %struct.list_head* %list8.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next9, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr11 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr11 to %struct.snd_ctl_file*
  %list = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 0
  %ctl_files1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 19
  %cmp = icmp ne %struct.list_head* %list, %ctl_files1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pid = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 2
  %3 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !154
  %call = call %struct.task_struct* @get_current.48()
  %call2 = call %struct.pid* @task_pid(%struct.task_struct* %call)
  %cmp3 = icmp eq %struct.pid* %3, %call2
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %preferred_subdevice = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 3
  %idxprom = sext i32 %type to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %preferred_subdevice, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4, !tbaa !47
  %cmp4 = icmp ne i32 %4, -1
  br i1 %cmp4, label %for.end, label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %subdevice.1 = phi i32 [ %subdevice.0, %for.body ], [ %4, %if.then ]
  %list8 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %subdevice.2 = phi i32 [ %4, %if.then ], [ %subdevice.0, %for.cond ]
  %ctl_files_rwlock12 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 15
  call void @_raw_read_unlock(%struct.rwlock_t* %ctl_files_rwlock12)
  ret i32 %subdevice.2
}

declare void @_raw_read_lock(%struct.rwlock_t*) #1 section ".spinlock.text"

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current.48() #3 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !156
  ret %struct.task_struct* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.pid* @task_pid(%struct.task_struct* %task) #5 {
entry:
  %pids = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i32 0, i32 61
  %arrayidx = getelementptr inbounds [3 x %struct.pid_link], [3 x %struct.pid_link]* %pids, i64 0, i64 0
  %pid = getelementptr inbounds %struct.pid_link, %struct.pid_link* %arrayidx, i32 0, i32 1
  %0 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !157
  ret %struct.pid* %0
}

declare void @_raw_read_unlock(%struct.rwlock_t*) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_unregister_ioctl_compat(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn) #0 {
entry:
  %call = call i32 @_snd_ctl_unregister_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* @snd_control_compat_ioctls)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @_snd_ctl_unregister_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* %lists) #0 {
entry:
  %tobool = icmp ne i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1687)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  call void @down_write(%struct.rw_semaphore* @snd_ioctl_rwsem)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end18
  %list27.sink = phi %struct.list_head* [ %list24, %for.inc ], [ %lists, %if.end18 ]
  %next28 = getelementptr inbounds %struct.list_head, %struct.list_head* %list27.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next28, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr30 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr30 to %struct.snd_kctl_ioctl*
  %list = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %2, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, %lists
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %fioctl = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %2, i32 0, i32 1
  %3 = load i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)** %fioctl, align 8, !tbaa !159
  %cmp21 = icmp eq i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %3, %fcn
  %list24 = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %2, i32 0, i32 0
  br i1 %cmp21, label %if.then23, label %for.inc

if.then23:                                        ; preds = %for.body
  call void @list_del.49(%struct.list_head* %list24)
  call void @up_write(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %4 = bitcast %struct.snd_kctl_ioctl* %2 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @up_write(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %tobool32 = icmp ne i32 1, 0
  %lnot33 = xor i1 %tobool32, true
  %lnot35 = xor i1 %lnot33, true
  %lnot.ext36 = zext i1 %lnot35 to i32
  %conv37 = sext i32 %lnot.ext36 to i64
  %expval38 = call i64 @llvm.expect.i64(i64 %conv37, i64 0)
  %tobool39 = icmp ne i64 %expval38, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %for.end
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1699, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.4.89, i32 0, i32 0))
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %for.end
  %tobool43 = icmp ne i32 1, 0
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot.ext47 = zext i1 %lnot46 to i32
  %conv48 = sext i32 %lnot.ext47 to i64
  %expval49 = call i64 @llvm.expect.i64(i64 %conv48, i64 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end41, %if.then23, %if.end
  %retval.0 = phi i32 [ 0, %if.then23 ], [ -22, %if.end41 ], [ -22, %if.end ]
  ret i32 %retval.0
}

declare void @down_write(%struct.rw_semaphore*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del.49(%struct.list_head* %entry1) #5 {
entry:
  call void @__list_del_entry.51(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !116
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

declare void @up_write(%struct.rw_semaphore*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry.51(%struct.list_head* %entry1) #5 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  call void @__list_del.52(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del.52(%struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !49
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.53(i8* %1, i8* %arraydecay, i32 8)
  %__val3 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val3, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size.53(i8* %p, i8* %res, i32 %size) #3 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !49
  store volatile i8 %0, i8* %p, align 1, !tbaa !49
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !118
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !118
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !47
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !47
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !119
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !119
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !161
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !162
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_unregister_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn) #0 {
entry:
  %call = call i32 @_snd_ctl_unregister_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* @snd_control_ioctls)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_register_ioctl_compat(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn) #0 {
entry:
  %call = call i32 @_snd_ctl_register_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* @snd_control_compat_ioctls)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @_snd_ctl_register_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* %lists) #0 {
entry:
  %call = call i8* @kzalloc.56(i64 24, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_kctl_ioctl*
  %cmp = icmp eq %struct.snd_kctl_ioctl* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %fioctl = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %0, i32 0, i32 1
  store i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)** %fioctl, align 8, !tbaa !159
  call void @down_write(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %list = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %0, i32 0, i32 0
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %lists)
  call void @up_write(%struct.rw_semaphore* @snd_ioctl_rwsem)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.56(i64 %size, i32 %flags) #5 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc.58(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #5 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  call void @__list_add.57(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add.57(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !117
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !116
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !49
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.53(i8* %1, i8* %arraydecay, i32 8)
  %__val5 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val5, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc.58(i64 %size, i32 %flags) #3 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_register_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn) #0 {
entry:
  %call = call i32 @_snd_ctl_register_ioctl(i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %fcn, %struct.list_head* @snd_control_ioctls)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne %struct.snd_ctl_elem_id* %id, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 699)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %1 = load i32, i32* %numid, align 4, !tbaa !163
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end19
  %numid22 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %2 = load i32, i32* %numid22, align 4, !tbaa !163
  %call = call %struct.snd_kcontrol* @snd_ctl_find_numid(%struct.snd_card* %card, i32 %2)
  br label %cleanup

if.end23:                                         ; preds = %if.end19
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end23
  %list67.sink = phi %struct.list_head* [ %list67, %for.inc ], [ %controls, %if.end23 ]
  %next68 = getelementptr inbounds %struct.list_head, %struct.list_head* %list67.sink, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next68, align 8, !tbaa !2
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr70 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr70 to %struct.snd_kcontrol*
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 0
  %controls25 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %cmp26 = icmp ne %struct.list_head* %list, %controls25
  br i1 %cmp26, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %id28 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %iface = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id28, i32 0, i32 1
  %6 = load i32, i32* %iface, align 4, !tbaa !164
  %iface29 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 1
  %7 = load i32, i32* %iface29, align 4, !tbaa !166
  %cmp30 = icmp ne i32 %6, %7
  br i1 %cmp30, label %for.inc, label %if.end33

if.end33:                                         ; preds = %for.body
  %id34 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %device = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id34, i32 0, i32 2
  %8 = load i32, i32* %device, align 8, !tbaa !167
  %device35 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 2
  %9 = load i32, i32* %device35, align 4, !tbaa !168
  %cmp36 = icmp ne i32 %8, %9
  br i1 %cmp36, label %for.inc, label %if.end39

if.end39:                                         ; preds = %if.end33
  %id40 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %subdevice = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id40, i32 0, i32 3
  %10 = load i32, i32* %subdevice, align 4, !tbaa !169
  %subdevice41 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 3
  %11 = load i32, i32* %subdevice41, align 4, !tbaa !170
  %cmp42 = icmp ne i32 %10, %11
  br i1 %cmp42, label %for.inc, label %if.end45

if.end45:                                         ; preds = %if.end39
  %id46 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %name = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id46, i32 0, i32 4
  %arraydecay = getelementptr inbounds [44 x i8], [44 x i8]* %name, i32 0, i32 0
  %name47 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 4
  %arraydecay48 = getelementptr inbounds [44 x i8], [44 x i8]* %name47, i32 0, i32 0
  %call49 = call i32 @strncmp(i8* %arraydecay, i8* %arraydecay48, i64 44)
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %for.inc, label %if.end52

if.end52:                                         ; preds = %if.end45
  %id53 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id53, i32 0, i32 5
  %12 = load i32, i32* %index, align 4, !tbaa !171
  %index54 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %13 = load i32, i32* %index54, align 4, !tbaa !172
  %cmp55 = icmp ugt i32 %12, %13
  br i1 %cmp55, label %for.inc, label %if.end58

if.end58:                                         ; preds = %if.end52
  %id59 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 1
  %index60 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id59, i32 0, i32 5
  %14 = load i32, i32* %index60, align 4, !tbaa !171
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 2
  %15 = load i32, i32* %count, align 8, !tbaa !173
  %add = add i32 %14, %15
  %index61 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %16 = load i32, i32* %index61, align 4, !tbaa !172
  %cmp62 = icmp ule i32 %add, %16
  br i1 %cmp62, label %for.inc, label %cleanup

for.inc:                                          ; preds = %if.end58, %if.end52, %if.end45, %if.end39, %if.end33, %for.body
  %list67 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %5, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %if.end58, %for.cond, %if.then21, %if.end
  %retval.0 = phi %struct.snd_kcontrol* [ %call, %if.then21 ], [ null, %if.end ], [ %5, %if.end58 ], [ null, %for.cond ]
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.snd_kcontrol* @snd_ctl_find_numid(%struct.snd_card* %card, i32 %numid) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne i32 %numid, 0
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 671)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %list33.sink = phi %struct.list_head* [ %list33, %for.inc ], [ %controls, %if.end19 ]
  %next34 = getelementptr inbounds %struct.list_head, %struct.list_head* %list33.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next34, align 8, !tbaa !2
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr36 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr36 to %struct.snd_kcontrol*
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 0
  %controls21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %cmp = icmp ne %struct.list_head* %list, %controls21
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 1
  %numid23 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %4 = load i32, i32* %numid23, align 8, !tbaa !174
  %cmp24 = icmp ule i32 %4, %numid
  br i1 %cmp24, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %id26 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 1
  %numid27 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id26, i32 0, i32 0
  %5 = load i32, i32* %numid27, align 8, !tbaa !174
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 2
  %6 = load i32, i32* %count, align 8, !tbaa !173
  %add = add i32 %5, %6
  %cmp28 = icmp ugt i32 %add, %numid
  br i1 %cmp28, label %cleanup, label %for.inc

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %list33 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %land.lhs.true, %for.cond, %if.end
  %retval.0 = phi %struct.snd_kcontrol* [ null, %if.end ], [ %3, %land.lhs.true ], [ null, %for.cond ]
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_rename_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %src_id, %struct.snd_ctl_elem_id* %dst_id) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %src_id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %controls_rwsem1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 1
  %0 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %1 = bitcast %struct.snd_ctl_elem_id* %dst_id to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 64, i32 4, i1 false), !tbaa.struct !175
  %last_numid = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  %2 = load i32, i32* %last_numid, align 8, !tbaa !176
  %add = add i32 %2, 1
  %id2 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 1
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id2, i32 0, i32 0
  store i32 %add, i32* %numid, align 8, !tbaa !174
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 2
  %3 = load i32, i32* %count, align 8, !tbaa !173
  %last_numid3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  %4 = load i32, i32* %last_numid3, align 8, !tbaa !176
  %add4 = add i32 %4, %3
  store i32 %add4, i32* %last_numid3, align 8, !tbaa !176
  %controls_rwsem5 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem5)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ -2, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_activate_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id, i32 %active) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %unlock, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_id* %id)
  %vd2 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom = zext i32 %call1 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd2, i64 0, i64 %idxprom
  %tobool = icmp ne i32 %active, 0
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %0 = load i32, i32* %access, align 8, !tbaa !177
  %and = and i32 %0, 256
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  br i1 %tobool4, label %if.end6, label %unlock

if.end6:                                          ; preds = %if.then3
  %access7 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %1 = load i32, i32* %access7, align 8, !tbaa !177
  %and8 = and i32 %1, -257
  store i32 %and8, i32* %access7, align 8, !tbaa !177
  br label %if.end15

if.else:                                          ; preds = %if.end
  br i1 %tobool4, label %unlock, label %if.end13

if.end13:                                         ; preds = %if.else
  %access14 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %2 = load i32, i32* %access14, align 8, !tbaa !177
  %or = or i32 %2, 256
  store i32 %or, i32* %access14, align 8, !tbaa !177
  br label %if.end15

if.end15:                                         ; preds = %if.end13, %if.end6
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id, %struct.snd_kcontrol* %call, i32 %call1)
  br label %unlock

unlock:                                           ; preds = %if.end15, %if.else, %if.then3, %entry
  %ret.0 = phi i32 [ 1, %if.end15 ], [ -2, %entry ], [ 0, %if.then3 ], [ 0, %if.else ]
  %controls_rwsem17 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem17)
  %cmp18 = icmp sgt i32 %ret.0, 0
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %unlock
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 2, %struct.snd_ctl_elem_id* %id)
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %unlock
  ret i32 %ret.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %kctl, %struct.snd_ctl_elem_id* %id) #5 {
entry:
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %0 = load i32, i32* %numid, align 4, !tbaa !163
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i32 @snd_ctl_get_ioffnum(%struct.snd_kcontrol* %kctl, %struct.snd_ctl_elem_id* %id)
  br label %return

if.else:                                          ; preds = %entry
  %call1 = call i32 @snd_ctl_get_ioffidx(%struct.snd_kcontrol* %kctl, %struct.snd_ctl_elem_id* %id)
  br label %return

return:                                           ; preds = %if.else, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %dst_id, %struct.snd_kcontrol* %src_kctl, i32 %offset) #5 {
entry:
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %src_kctl, i32 0, i32 1
  %0 = bitcast %struct.snd_ctl_elem_id* %dst_id to i8*
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 64, i32 4, i1 false), !tbaa.struct !175
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %dst_id, i32 0, i32 5
  %2 = load i32, i32* %index, align 4, !tbaa !172
  %add = add i32 %2, %offset
  store i32 %add, i32* %index, align 4, !tbaa !172
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %dst_id, i32 0, i32 0
  %3 = load i32, i32* %numid, align 4, !tbaa !163
  %add1 = add i32 %3, %offset
  store i32 %add1, i32* %numid, align 4, !tbaa !163
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_ctl_notify(%struct.snd_card* %card, i32 %mask, %struct.snd_ctl_elem_id* %id) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne %struct.snd_ctl_elem_id* %id, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 162)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup.cont, label %if.end19

if.end19:                                         ; preds = %if.end
  %shutdown = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 27
  %1 = load i32, i32* %shutdown, align 8, !tbaa !69
  %tobool20 = icmp ne i32 %1, 0
  br i1 %tobool20, label %cleanup.cont, label %if.end22

if.end22:                                         ; preds = %if.end19
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 15
  call void @_raw_read_lock(%struct.rwlock_t* %ctl_files_rwlock)
  %mixer_oss_change_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 37
  %2 = load i32, i32* %mixer_oss_change_count, align 8, !tbaa !179
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %mixer_oss_change_count, align 8, !tbaa !179
  %ctl_files = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 19
  br label %for.cond

for.cond:                                         ; preds = %for.inc67, %if.end22
  %list69.sink = phi %struct.list_head* [ %list69, %for.inc67 ], [ %ctl_files, %if.end22 ]
  %next70 = getelementptr inbounds %struct.list_head, %struct.list_head* %list69.sink, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next70, align 8, !tbaa !2
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr72 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr72 to %struct.snd_ctl_file*
  %list = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 0
  %ctl_files24 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 19
  %cmp = icmp ne %struct.list_head* %list, %ctl_files24
  br i1 %cmp, label %for.body, label %for.end73

for.body:                                         ; preds = %for.cond
  %subscribed = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 7
  %6 = load i32, i32* %subscribed, align 8, !tbaa !180
  %tobool26 = icmp ne i32 %6, 0
  br i1 %tobool26, label %do.body29, label %for.inc67

do.body29:                                        ; preds = %for.body
  %7 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #9
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #9
  %cmp30 = icmp eq i64* %__dummy, %__dummy2
  %conv31 = zext i1 %cmp30 to i32
  %9 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #9
  %10 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #9
  %read_lock = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 5
  %call = call %struct.raw_spinlock* @spinlock_check.59(%struct.spinlock* %read_lock)
  %call33 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %events = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 8
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc, %do.body29
  %list54.sink = phi %struct.list_head* [ %list54, %for.inc ], [ %events, %do.body29 ]
  %next55 = getelementptr inbounds %struct.list_head, %struct.list_head* %list54.sink, i32 0, i32 0
  %11 = load %struct.list_head*, %struct.list_head** %next55, align 8, !tbaa !2
  %12 = bitcast %struct.list_head* %11 to i8*
  %add.ptr57 = getelementptr inbounds i8, i8* %12, i64 0
  %13 = bitcast i8* %add.ptr57 to %struct.snd_kctl_event*
  %list41 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %13, i32 0, i32 0
  %events42 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 8
  %cmp43 = icmp ne %struct.list_head* %list41, %events42
  br i1 %cmp43, label %for.body45, label %for.end

for.body45:                                       ; preds = %for.cond40
  %id46 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %13, i32 0, i32 1
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id46, i32 0, i32 0
  %14 = load i32, i32* %numid, align 8, !tbaa !181
  %numid47 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %15 = load i32, i32* %numid47, align 4, !tbaa !163
  %cmp48 = icmp eq i32 %14, %15
  br i1 %cmp48, label %if.then50, label %for.inc

if.then50:                                        ; preds = %for.body45
  %mask51 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %13, i32 0, i32 2
  %16 = load i32, i32* %mask51, align 8, !tbaa !183
  %or = or i32 %16, %mask
  store i32 %or, i32* %mask51, align 8, !tbaa !183
  br label %_found

for.inc:                                          ; preds = %for.body45
  %list54 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %13, i32 0, i32 0
  br label %for.cond40

for.end:                                          ; preds = %for.cond40
  %call58 = call i8* @kzalloc.56(i64 88, i32 17301536)
  %17 = bitcast i8* %call58 to %struct.snd_kctl_event*
  %tobool59 = icmp ne %struct.snd_kctl_event* %17, null
  br i1 %tobool59, label %if.then60, label %if.else

if.then60:                                        ; preds = %for.end
  %id61 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %17, i32 0, i32 1
  %18 = bitcast %struct.snd_ctl_elem_id* %id61 to i8*
  %19 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 64, i32 4, i1 false), !tbaa.struct !175
  %mask62 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %17, i32 0, i32 2
  store i32 %mask, i32* %mask62, align 8, !tbaa !183
  %list63 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %17, i32 0, i32 0
  %events64 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 8
  call void @list_add_tail(%struct.list_head* %list63, %struct.list_head* %events64)
  br label %_found

if.else:                                          ; preds = %for.end
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %20 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !115
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %20, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.1.60, i32 0, i32 0))
  br label %_found

_found:                                           ; preds = %if.else, %if.then60, %if.then50
  %change_sleep = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 4
  call void @__wake_up(%struct.__wait_queue_head* %change_sleep, i32 3, i32 1, i8* null)
  %read_lock66 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %read_lock66, i64 %call33)
  %fasync = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 6
  call void @kill_fasync(%struct.fasync_struct** %fasync, i32 29, i32 131073)
  br label %for.inc67

for.inc67:                                        ; preds = %_found, %for.body
  %list69 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %5, i32 0, i32 0
  br label %for.cond

for.end73:                                        ; preds = %for.cond
  %ctl_files_rwlock74 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 15
  call void @_raw_read_unlock(%struct.rwlock_t* %ctl_files_rwlock74)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end73, %if.end19, %if.end
  %cleanup.dest.slot.0 = phi i32 [ 0, %for.end73 ], [ 1, %if.end ], [ 1, %if.end19 ]
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.59(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #3 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #9
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #9
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @kill_fasync(%struct.fasync_struct**, i32, i32) #1

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @snd_ctl_get_ioffnum(%struct.snd_kcontrol* %kctl, %struct.snd_ctl_elem_id* %id) #5 {
entry:
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %0 = load i32, i32* %numid, align 4, !tbaa !163
  %id1 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %numid2 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id1, i32 0, i32 0
  %1 = load i32, i32* %numid2, align 8, !tbaa !174
  %sub = sub i32 %0, %1
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @snd_ctl_get_ioffidx(%struct.snd_kcontrol* %kctl, %struct.snd_ctl_elem_id* %id) #5 {
entry:
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %0 = load i32, i32* %index, align 4, !tbaa !172
  %id1 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  %index2 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id1, i32 0, i32 5
  %1 = load i32, i32* %index2, align 4, !tbaa !171
  %sub = sub i32 %0, %1
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_remove_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %controls_rwsem1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call i32 @snd_ctl_remove(%struct.snd_card* %card, %struct.snd_kcontrol* %call)
  %controls_rwsem3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem3)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ -2, %if.then ], [ %call2, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_remove(%struct.snd_card* %card, %struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %0 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #9
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne %struct.snd_kcontrol* %kcontrol, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %1 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %1, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 496)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 0
  call void @list_del.49(%struct.list_head* %list)
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %2 = load i32, i32* %count, align 8, !tbaa !173
  %controls_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  %3 = load i32, i32* %controls_count, align 8, !tbaa !184
  %sub = sub i32 %3, %2
  store i32 %sub, i32* %controls_count, align 8, !tbaa !184
  %id20 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %4 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %5 = bitcast %struct.snd_ctl_elem_id* %id20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 64, i32 4, i1 false), !tbaa.struct !175
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end19
  %idx.0 = phi i32 [ 0, %if.end19 ], [ %inc, %for.body ]
  %count21 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %6 = load i32, i32* %count21, align 8, !tbaa !173
  %cmp = icmp ult i32 %idx.0, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 -1, %struct.snd_ctl_elem_id* %id)
  %inc = add i32 %idx.0, 1
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %7 = load i32, i32* %index, align 4, !tbaa !172
  %inc23 = add i32 %7, 1
  store i32 %inc23, i32* %index, align 4, !tbaa !172
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %8 = load i32, i32* %numid, align 4, !tbaa !163
  %inc24 = add i32 %8, 1
  store i32 %inc24, i32* %numid, align 4, !tbaa !163
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @snd_ctl_free_one(%struct.snd_kcontrol* %kcontrol)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end
  %retval.0 = phi i32 [ 0, %for.end ], [ -22, %if.end ]
  %9 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %9) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @snd_ctl_free_one(%struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %tobool = icmp ne %struct.snd_kcontrol* %kcontrol, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 9
  %0 = load void (%struct.snd_kcontrol*)*, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !185
  %tobool1 = icmp ne void (%struct.snd_kcontrol*)* %0, null
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %private_free3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 9
  %1 = load void (%struct.snd_kcontrol*)*, void (%struct.snd_kcontrol*)** %private_free3, align 8, !tbaa !185
  call void %1(%struct.snd_kcontrol* %kcontrol)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %2 = bitcast %struct.snd_kcontrol* %kcontrol to i8*
  call void @kfree(i8* %2)
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_replace(%struct.snd_card* %card, %struct.snd_kcontrol* %kcontrol, i1 zeroext %add_on_replace) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %frombool = zext i1 %add_on_replace to i8
  %0 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #9
  %tobool = icmp ne %struct.snd_kcontrol* %kcontrol, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %tobool1 = icmp ne %struct.snd_card* %card, null
  br i1 %tobool1, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end
  %info = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 3
  %1 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !186
  %tobool2 = icmp ne i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* %1, null
  %lnot = xor i1 %tobool2, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end
  %2 = phi i1 [ true, %if.end ], [ %lnot, %lor.rhs ]
  %lnot3 = xor i1 %2, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool5 = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 438)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %lor.end
  %tobool13 = icmp ne i32 %lnot.ext, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %error, label %if.end22

if.end22:                                         ; preds = %if.end12
  %id23 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %3 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %4 = bitcast %struct.snd_ctl_elem_id* %id23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 64, i32 4, i1 false), !tbaa.struct !175
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %tobool24 = icmp ne %struct.snd_kcontrol* %call, null
  br i1 %tobool24, label %if.end30, label %if.then25

if.then25:                                        ; preds = %if.end22
  %tobool26 = trunc i8 %frombool to i1
  br i1 %tobool26, label %add, label %if.end28

if.end28:                                         ; preds = %if.then25
  %controls_rwsem29 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem29)
  br label %error

if.end30:                                         ; preds = %if.end22
  %call31 = call i32 @snd_ctl_remove(%struct.snd_card* %card, %struct.snd_kcontrol* %call)
  %cmp = icmp slt i32 %call31, 0
  br i1 %cmp, label %if.then33, label %add

if.then33:                                        ; preds = %if.end30
  %controls_rwsem34 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem34)
  br label %error

add:                                              ; preds = %if.end30, %if.then25
  %count36 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %5 = load i32, i32* %count36, align 8, !tbaa !173
  %call37 = call i32 @snd_ctl_find_hole(%struct.snd_card* %card, i32 %5)
  %cmp38 = icmp slt i32 %call37, 0
  br i1 %cmp38, label %if.then40, label %if.end42

if.then40:                                        ; preds = %add
  %controls_rwsem41 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem41)
  br label %error

if.end42:                                         ; preds = %add
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 0
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %controls)
  %count43 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %6 = load i32, i32* %count43, align 8, !tbaa !173
  %controls_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  %7 = load i32, i32* %controls_count, align 8, !tbaa !184
  %add44 = add i32 %7, %6
  store i32 %add44, i32* %controls_count, align 8, !tbaa !184
  %last_numid = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  %8 = load i32, i32* %last_numid, align 8, !tbaa !176
  %add45 = add i32 %8, 1
  %id46 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id46, i32 0, i32 0
  store i32 %add45, i32* %numid, align 8, !tbaa !174
  %count47 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %9 = load i32, i32* %count47, align 8, !tbaa !173
  %last_numid48 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  %10 = load i32, i32* %last_numid48, align 8, !tbaa !176
  %add49 = add i32 %10, %9
  store i32 %add49, i32* %last_numid48, align 8, !tbaa !176
  %id50 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %11 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %12 = bitcast %struct.snd_ctl_elem_id* %id50 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 64, i32 4, i1 false), !tbaa.struct !175
  %count51 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %13 = load i32, i32* %count51, align 8, !tbaa !173
  %controls_rwsem52 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem52)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end42
  %idx.0 = phi i32 [ 0, %if.end42 ], [ %inc, %for.body ]
  %cmp53 = icmp ult i32 %idx.0, %13
  br i1 %cmp53, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 4, %struct.snd_ctl_elem_id* %id)
  %inc = add i32 %idx.0, 1
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %14 = load i32, i32* %index, align 4, !tbaa !172
  %inc55 = add i32 %14, 1
  store i32 %inc55, i32* %index, align 4, !tbaa !172
  %numid56 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %15 = load i32, i32* %numid56, align 4, !tbaa !163
  %inc57 = add i32 %15, 1
  store i32 %inc57, i32* %numid56, align 4, !tbaa !163
  br label %for.cond

error:                                            ; preds = %if.then40, %if.then33, %if.end28, %if.end12
  %ret.0 = phi i32 [ %call31, %if.then33 ], [ -12, %if.then40 ], [ -22, %if.end28 ], [ -22, %if.end12 ]
  call void @snd_ctl_free_one(%struct.snd_kcontrol* %kcontrol)
  br label %cleanup

cleanup:                                          ; preds = %error, %for.cond, %entry
  %retval.0 = phi i32 [ %ret.0, %error ], [ -22, %entry ], [ 0, %for.cond ]
  %16 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %16) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_find_hole(%struct.snd_card* %card, i32 %count) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %iter.0 = phi i32 [ 100000, %entry ], [ %dec, %if.end ]
  %call = call zeroext i1 @snd_ctl_remove_numid_conflict(%struct.snd_card* %card, i32 %count)
  br i1 %call, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %dec = add i32 %iter.0, -1
  %cmp = icmp eq i32 %dec, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %0 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !115
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.6.61, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %while.body
  br label %while.cond

cleanup:                                          ; preds = %if.then, %while.cond
  %retval.0 = phi i32 [ -12, %if.then ], [ 0, %while.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @snd_ctl_remove_numid_conflict(%struct.snd_card* %card, i32 %count) #0 {
entry:
  %last_numid = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  %0 = load i32, i32* %last_numid, align 8, !tbaa !176
  %sub = sub i32 -1, %count
  %cmp = icmp uge i32 %0, %sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %last_numid1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  store i32 0, i32* %last_numid1, align 8, !tbaa !176
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %list23.sink = phi %struct.list_head* [ %list23, %for.inc ], [ %controls, %if.end ]
  %next24 = getelementptr inbounds %struct.list_head, %struct.list_head* %list23.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next24, align 8, !tbaa !2
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr26 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr26 to %struct.snd_kcontrol*
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 0
  %controls2 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %cmp3 = icmp ne %struct.list_head* %list, %controls2
  br i1 %cmp3, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 1
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %4 = load i32, i32* %numid, align 8, !tbaa !174
  %last_numid4 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  %5 = load i32, i32* %last_numid4, align 8, !tbaa !176
  %add = add i32 %5, 1
  %add5 = add i32 %add, %count
  %cmp6 = icmp ult i32 %4, %add5
  br i1 %cmp6, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %id7 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 1
  %numid8 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id7, i32 0, i32 0
  %6 = load i32, i32* %numid8, align 8, !tbaa !174
  %count9 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 2
  %7 = load i32, i32* %count9, align 8, !tbaa !173
  %add10 = add i32 %6, %7
  %last_numid11 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  %8 = load i32, i32* %last_numid11, align 8, !tbaa !176
  %add12 = add i32 %8, 1
  %cmp13 = icmp ugt i32 %add10, %add12
  br i1 %cmp13, label %if.then14, label %for.inc

if.then14:                                        ; preds = %land.lhs.true
  %id15 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 1
  %numid16 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id15, i32 0, i32 0
  %9 = load i32, i32* %numid16, align 8, !tbaa !174
  %count17 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 2
  %10 = load i32, i32* %count17, align 8, !tbaa !173
  %add18 = add i32 %9, %10
  %sub19 = sub i32 %add18, 1
  %last_numid20 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  store i32 %sub19, i32* %last_numid20, align 8, !tbaa !176
  br label %cleanup

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %list23 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %if.then14, %for.cond
  %retval.0 = phi i1 [ true, %if.then14 ], [ false, %for.cond ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_add(%struct.snd_card* %card, %struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %0 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #9
  %tobool = icmp ne %struct.snd_kcontrol* %kcontrol, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %tobool1 = icmp ne %struct.snd_card* %card, null
  br i1 %tobool1, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end
  %info = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 3
  %1 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !186
  %tobool2 = icmp ne i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* %1, null
  %lnot = xor i1 %tobool2, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end
  %2 = phi i1 [ true, %if.end ], [ %lnot, %lor.rhs ]
  %lnot3 = xor i1 %2, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool5 = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 373)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %lor.end
  %tobool13 = icmp ne i32 %lnot.ext, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %error, label %if.end22

if.end22:                                         ; preds = %if.end12
  %id23 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %3 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %4 = bitcast %struct.snd_ctl_elem_id* %id23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 64, i32 4, i1 false), !tbaa.struct !175
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %5 = load i32, i32* %index, align 4, !tbaa !172
  %count24 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %6 = load i32, i32* %count24, align 8, !tbaa !173
  %sub = sub i32 -1, %6
  %cmp = icmp ugt i32 %5, %sub
  br i1 %cmp, label %error, label %if.end27

if.end27:                                         ; preds = %if.end22
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %tobool28 = icmp ne %struct.snd_kcontrol* %call, null
  br i1 %tobool28, label %if.then29, label %if.end32

if.then29:                                        ; preds = %if.end27
  %controls_rwsem30 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem30)
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %7 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !115
  %iface = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 1
  %8 = load i32, i32* %iface, align 4, !tbaa !166
  %device = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 2
  %9 = load i32, i32* %device, align 4, !tbaa !168
  %subdevice = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 3
  %10 = load i32, i32* %subdevice, align 4, !tbaa !170
  %name = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 4
  %arraydecay = getelementptr inbounds [44 x i8], [44 x i8]* %name, i32 0, i32 0
  %index31 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %11 = load i32, i32* %index31, align 4, !tbaa !172
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %7, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3.62, i32 0, i32 0), i32 %8, i32 %9, i32 %10, i8* %arraydecay, i32 %11)
  br label %error

if.end32:                                         ; preds = %if.end27
  %count33 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %12 = load i32, i32* %count33, align 8, !tbaa !173
  %call34 = call i32 @snd_ctl_find_hole(%struct.snd_card* %card, i32 %12)
  %cmp35 = icmp slt i32 %call34, 0
  br i1 %cmp35, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end32
  %controls_rwsem38 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem38)
  br label %error

if.end39:                                         ; preds = %if.end32
  %list = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 0
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %controls)
  %count40 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %13 = load i32, i32* %count40, align 8, !tbaa !173
  %controls_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  %14 = load i32, i32* %controls_count, align 8, !tbaa !184
  %add = add i32 %14, %13
  store i32 %add, i32* %controls_count, align 8, !tbaa !184
  %last_numid = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  %15 = load i32, i32* %last_numid, align 8, !tbaa !176
  %add41 = add i32 %15, 1
  %id42 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id42, i32 0, i32 0
  store i32 %add41, i32* %numid, align 8, !tbaa !174
  %count43 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %16 = load i32, i32* %count43, align 8, !tbaa !173
  %last_numid44 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 13
  %17 = load i32, i32* %last_numid44, align 8, !tbaa !176
  %add45 = add i32 %17, %16
  store i32 %add45, i32* %last_numid44, align 8, !tbaa !176
  %id46 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 1
  %18 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %19 = bitcast %struct.snd_ctl_elem_id* %id46 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 64, i32 4, i1 false), !tbaa.struct !175
  %count47 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 2
  %20 = load i32, i32* %count47, align 8, !tbaa !173
  %controls_rwsem48 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem48)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end39
  %idx.0 = phi i32 [ 0, %if.end39 ], [ %inc, %for.body ]
  %cmp49 = icmp ult i32 %idx.0, %20
  br i1 %cmp49, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 4, %struct.snd_ctl_elem_id* %id)
  %inc = add i32 %idx.0, 1
  %index51 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 5
  %21 = load i32, i32* %index51, align 4, !tbaa !172
  %inc52 = add i32 %21, 1
  store i32 %inc52, i32* %index51, align 4, !tbaa !172
  %numid53 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %22 = load i32, i32* %numid53, align 4, !tbaa !163
  %inc54 = add i32 %22, 1
  store i32 %inc54, i32* %numid53, align 4, !tbaa !163
  br label %for.cond

error:                                            ; preds = %if.then37, %if.then29, %if.end22, %if.end12
  %err.0 = phi i32 [ -16, %if.then29 ], [ -12, %if.then37 ], [ -22, %if.end12 ], [ -22, %if.end22 ]
  call void @snd_ctl_free_one(%struct.snd_kcontrol* %kcontrol)
  br label %cleanup

cleanup:                                          ; preds = %error, %for.cond, %entry
  %retval.0 = phi i32 [ %err.0, %error ], [ -22, %entry ], [ 0, %for.cond ]
  %23 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %23) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.snd_kcontrol* @snd_ctl_new1(%struct.snd_kcontrol_new* %ncontrol, i8* %private_data) #0 {
entry:
  %kctl = alloca %struct.snd_kcontrol*, align 8
  %0 = bitcast %struct.snd_kcontrol** %kctl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %tobool = icmp ne %struct.snd_kcontrol_new* %ncontrol, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %info = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 7
  %1 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !187
  %tobool1 = icmp ne i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* %1, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %2, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 254)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %count20 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 6
  %3 = load i32, i32* %count20, align 8, !tbaa !189
  %cmp = icmp eq i32 %3, 0
  %. = select i1 %cmp, i32 1, i32 %3
  %access24 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 5
  %4 = load i32, i32* %access24, align 4, !tbaa !190
  %cmp25 = icmp eq i32 %4, 0
  %access.0 = select i1 %cmp25, i32 3, i32 %4
  %and = and i32 %access.0, 268435831
  %call = call i32 @snd_ctl_new(%struct.snd_kcontrol** %kctl, i32 %., i32 %and, %struct.snd_ctl_file* null)
  %cmp29 = icmp slt i32 %call, 0
  br i1 %cmp29, label %cleanup, label %if.end32

if.end32:                                         ; preds = %if.end19
  %iface = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 0
  %5 = load i32, i32* %iface, align 8, !tbaa !191
  %6 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %6, i32 0, i32 1
  %iface33 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 1
  store i32 %5, i32* %iface33, align 4, !tbaa !164
  %device = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 1
  %7 = load i32, i32* %device, align 4, !tbaa !192
  %8 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %id34 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 1
  %device35 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id34, i32 0, i32 2
  store i32 %7, i32* %device35, align 8, !tbaa !167
  %subdevice = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 2
  %9 = load i32, i32* %subdevice, align 8, !tbaa !193
  %10 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %id36 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %10, i32 0, i32 1
  %subdevice37 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id36, i32 0, i32 3
  store i32 %9, i32* %subdevice37, align 4, !tbaa !169
  %name = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 3
  %11 = load i8*, i8** %name, align 8, !tbaa !194
  %tobool38 = icmp ne i8* %11, null
  br i1 %tobool38, label %if.then39, label %if.end58

if.then39:                                        ; preds = %if.end32
  %12 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %id40 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %12, i32 0, i32 1
  %name41 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id40, i32 0, i32 4
  %arraydecay = getelementptr inbounds [44 x i8], [44 x i8]* %name41, i32 0, i32 0
  %name42 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 3
  %13 = load i8*, i8** %name42, align 8, !tbaa !194
  %call43 = call i64 @strlcpy(i8* %arraydecay, i8* %13, i64 44)
  %name44 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 3
  %14 = load i8*, i8** %name44, align 8, !tbaa !194
  %15 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %id45 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %15, i32 0, i32 1
  %name46 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id45, i32 0, i32 4
  %arraydecay47 = getelementptr inbounds [44 x i8], [44 x i8]* %name46, i32 0, i32 0
  %call48 = call i32 @strcmp(i8* %14, i8* %arraydecay47)
  %cmp49 = icmp ne i32 %call48, 0
  br i1 %cmp49, label %if.then51, label %if.end58

if.then51:                                        ; preds = %if.then39
  %name52 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 3
  %16 = load i8*, i8** %name52, align 8, !tbaa !194
  %17 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %id53 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %17, i32 0, i32 1
  %name54 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id53, i32 0, i32 4
  %arraydecay55 = getelementptr inbounds [44 x i8], [44 x i8]* %name54, i32 0, i32 0
  %call56 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.2.63, i32 0, i32 0), i8* %16, i8* %arraydecay55)
  br label %if.end58

if.end58:                                         ; preds = %if.then51, %if.then39, %if.end32
  %index = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 4
  %18 = load i32, i32* %index, align 8, !tbaa !195
  %19 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %id59 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %19, i32 0, i32 1
  %index60 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id59, i32 0, i32 5
  store i32 %18, i32* %index60, align 4, !tbaa !171
  %info61 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 7
  %20 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info61, align 8, !tbaa !187
  %21 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %info62 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %21, i32 0, i32 3
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* %20, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info62, align 8, !tbaa !186
  %get = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 8
  %22 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !196
  %23 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %get63 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %23, i32 0, i32 4
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* %22, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get63, align 8, !tbaa !197
  %put = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 9
  %24 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !198
  %25 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %put64 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %25, i32 0, i32 5
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* %24, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put64, align 8, !tbaa !199
  %tlv = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 10
  %p = bitcast %union.anon.69* %tlv to i32**
  %26 = load i32*, i32** %p, align 8, !tbaa !49
  %27 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %tlv65 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %27, i32 0, i32 6
  %p66 = bitcast %union.anon.69* %tlv65 to i32**
  store i32* %26, i32** %p66, align 8, !tbaa !49
  %private_value = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %ncontrol, i32 0, i32 11
  %28 = load i64, i64* %private_value, align 8, !tbaa !200
  %29 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %private_value67 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %29, i32 0, i32 7
  store i64 %28, i64* %private_value67, align 8, !tbaa !201
  %30 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %private_data68 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %30, i32 0, i32 8
  store i8* %private_data, i8** %private_data68, align 8, !tbaa !202
  %31 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.end58, %if.end19, %if.end
  %retval.0 = phi %struct.snd_kcontrol* [ %31, %if.end58 ], [ null, %if.end ], [ null, %if.end19 ]
  %32 = bitcast %struct.snd_kcontrol** %kctl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %32) #9
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_new(%struct.snd_kcontrol** %kctl, i32 %count, i32 %access, %struct.snd_ctl_file* %file) #0 {
entry:
  %cmp = icmp eq i32 %count, 0
  %cmp1 = icmp ugt i32 %count, 1028
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i32 %count to i64
  %mul = mul i64 16, %conv
  %conv2 = zext i32 144 to i64
  %add = add i64 %conv2, %mul
  %conv3 = trunc i64 %add to i32
  %conv4 = zext i32 %conv3 to i64
  %call = call i8* @kzalloc.56(i64 %conv4, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_kcontrol*
  store %struct.snd_kcontrol* %0, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %1 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_kcontrol* %1, null
  br i1 %tobool, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end6
  %idx.0 = phi i32 [ 0, %if.end6 ], [ %inc, %for.body ]
  %cmp7 = icmp ult i32 %idx.0, %count
  %2 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %2, i32 0, i32 10
  %idxprom = zext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i64 0, i64 %idxprom
  %access9 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  store i32 %access, i32* %access9, align 8, !tbaa !177
  %3 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %vd10 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %3, i32 0, i32 10
  %idxprom11 = zext i32 %idx.0 to i64
  %arrayidx12 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd10, i64 0, i64 %idxprom11
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx12, i32 0, i32 0
  store %struct.snd_ctl_file* %file, %struct.snd_ctl_file** %owner, align 8, !tbaa !203
  %inc = add i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %count13 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %2, i32 0, i32 2
  store i32 %count, i32* %count13, align 8, !tbaa !173
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end, %entry
  %retval.0 = phi i32 [ 0, %for.end ], [ -22, %entry ], [ -12, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_create(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1841)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %0 = load i32, i32* %number, align 8, !tbaa !10
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end18
  %number21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number21, align 8, !tbaa !10
  %cmp22 = icmp sge i32 %1, 32
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end18
  %2 = phi i1 [ true, %if.end18 ], [ %cmp22, %lor.rhs ]
  %lnot24 = xor i1 %2, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %tobool28 = icmp ne i32 %lnot.ext27, 0
  %lnot29 = xor i1 %tobool28, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  %expval34 = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool35 = icmp ne i64 %expval34, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1843)
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %lor.end
  %tobool39 = icmp ne i32 %lnot.ext27, 0
  %lnot40 = xor i1 %tobool39, true
  %lnot42 = xor i1 %lnot40, true
  %lnot.ext43 = zext i1 %lnot42 to i32
  %conv44 = sext i32 %lnot.ext43 to i64
  %expval45 = call i64 @llvm.expect.i64(i64 %conv44, i64 0)
  %tobool46 = icmp ne i64 %expval45, 0
  br i1 %tobool46, label %cleanup, label %if.end48

if.end48:                                         ; preds = %if.end37
  %ctl_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @snd_device_initialize(%struct.device* %ctl_dev, %struct.snd_card* %card)
  %ctl_dev49 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  %number50 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %3 = load i32, i32* %number50, align 8, !tbaa !10
  %call = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %ctl_dev49, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.4.66, i32 0, i32 0), i32 %3)
  %4 = bitcast %struct.snd_card* %card to i8*
  %call51 = call i32 @snd_device_new(%struct.snd_card* %card, i32 1, i8* %4, %struct.snd_device_ops* @snd_ctl_create.ops)
  %cmp52 = icmp slt i32 %call51, 0
  br i1 %cmp52, label %if.then54, label %cleanup

if.then54:                                        ; preds = %if.end48
  %ctl_dev55 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 12
  call void @put_device(%struct.device* %ctl_dev55)
  br label %cleanup

cleanup:                                          ; preds = %if.then54, %if.end48, %if.end37, %if.end
  %retval.0 = phi i32 [ -6, %if.end ], [ -6, %if.end37 ], [ %call51, %if.then54 ], [ %call51, %if.end48 ]
  ret i32 %retval.0
}

declare i32 @dev_set_name(%struct.device*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_dev_free(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !204
  %1 = bitcast i8* %0 to %struct.snd_card*
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 18
  %call = call i32 @list_empty(%struct.list_head* %controls)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %controls1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 18
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %controls1, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !206
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.snd_kcontrol*
  %call2 = call i32 @snd_ctl_remove(%struct.snd_card* %1, %struct.snd_kcontrol* %4)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %controls_rwsem3 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem3)
  %ctl_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 12
  call void @put_device(%struct.device* %ctl_dev)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_dev_register(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !204
  %1 = bitcast i8* %0 to %struct.snd_card*
  %2 = bitcast %struct.snd_card* %1 to i8*
  %ctl_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 12
  %call = call i32 @snd_register_device(i32 0, %struct.snd_card* %1, i32 -1, %struct.file_operations* @snd_ctl_f_ops, i8* %2, %struct.device* %ctl_dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_dev_disconnect(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !204
  %1 = bitcast i8* %0 to %struct.snd_card*
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 15
  call void @_raw_read_lock(%struct.rwlock_t* %ctl_files_rwlock)
  %ctl_files = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 19
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %list3.sink = phi %struct.list_head* [ %list3, %for.body ], [ %ctl_files, %entry ]
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %list3.sink, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next4, align 8, !tbaa !2
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr6 = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr6 to %struct.snd_ctl_file*
  %list = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 0
  %ctl_files1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 19
  %cmp = icmp ne %struct.list_head* %list, %ctl_files1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %change_sleep = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 4
  call void @__wake_up(%struct.__wait_queue_head* %change_sleep, i32 3, i32 1, i8* null)
  %fasync = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 6
  call void @kill_fasync(%struct.fasync_struct** %fasync, i32 29, i32 131076)
  %list3 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %4, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %ctl_files_rwlock7 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 15
  call void @_raw_read_unlock(%struct.rwlock_t* %ctl_files_rwlock7)
  %ctl_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %1, i32 0, i32 12
  %call = call i32 @snd_unregister_device(%struct.device* %ctl_dev)
  ret i32 %call
}

declare i64 @no_llseek(%struct.file*, i64, i32) #1

; Function Attrs: nounwind uwtable
define internal i64 @snd_ctl_read(%struct.file* %file, i8* %buffer, i64 %count, i64* %offset) #0 {
entry:
  %ev = alloca %struct.snd_ctl_event, align 4
  %wait = alloca %struct.__wait_queue, align 8
  %__ret = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_ctl_file*
  %tobool = icmp ne %struct.snd_ctl_file* %1, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %card = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %2 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !208
  %tobool1 = icmp ne %struct.snd_card* %2, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %3, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1569)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup79, label %if.end19

if.end19:                                         ; preds = %if.end
  %subscribed = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 7
  %4 = load i32, i32* %subscribed, align 8, !tbaa !180
  %tobool20 = icmp ne i32 %4, 0
  br i1 %tobool20, label %if.end22, label %cleanup79

if.end22:                                         ; preds = %if.end19
  %cmp = icmp ult i64 %count, 72
  br i1 %cmp, label %cleanup79, label %if.end25

if.end25:                                         ; preds = %if.end22
  %read_lock = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 5
  call void @spin_lock_irq(%struct.spinlock* %read_lock)
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont73, %if.end25
  %err.0 = phi i32 [ 0, %if.end25 ], [ %err.3, %cleanup.cont73 ]
  %result.0 = phi i64 [ 0, %if.end25 ], [ %result.1, %cleanup.cont73 ]
  %count.addr.0 = phi i64 [ %count, %if.end25 ], [ %count.addr.1, %cleanup.cont73 ]
  %buffer.addr.0 = phi i8* [ %buffer, %if.end25 ], [ %buffer.addr.1, %cleanup.cont73 ]
  %retval.0 = phi i64 [ undef, %if.end25 ], [ %retval.3, %cleanup.cont73 ]
  %cmp26 = icmp uge i64 %count.addr.0, 72
  br i1 %cmp26, label %while.body, label %__end_lock

while.body:                                       ; preds = %while.cond
  %5 = bitcast %struct.snd_ctl_event* %ev to i8*
  call void @llvm.lifetime.start.p0i8(i64 72, i8* %5) #9
  br label %while.cond28

while.cond28:                                     ; preds = %cleanup.cont, %while.body
  %err.1 = phi i32 [ %err.0, %while.body ], [ %err.2, %cleanup.cont ]
  %retval.1 = phi i64 [ %retval.0, %while.body ], [ %retval.2, %cleanup.cont ]
  %events = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 8
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool29 = icmp ne i32 %call, 0
  br i1 %tobool29, label %while.body30, label %while.end

while.body30:                                     ; preds = %while.cond28
  %6 = bitcast %struct.__wait_queue* %wait to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %6) #9
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 6
  %7 = load i32, i32* %f_flags, align 8, !tbaa !132
  %and = and i32 %7, 2048
  %cmp31 = icmp ne i32 %and, 0
  %cmp33 = icmp sgt i64 %result.0, 0
  %or.cond = or i1 %cmp31, %cmp33
  br i1 %or.cond, label %cleanup, label %if.end36

if.end36:                                         ; preds = %while.body30
  %call37 = call %struct.task_struct* @get_current.48()
  call void @init_waitqueue_entry.83(%struct.__wait_queue* %wait, %struct.task_struct* %call37)
  %change_sleep = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 4
  call void @add_wait_queue(%struct.__wait_queue_head* %change_sleep, %struct.__wait_queue* %wait)
  br label %__here

__here:                                           ; preds = %if.end36
  %call39 = call %struct.task_struct* @get_current.48()
  %task_state_change = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call39, i32 0, i32 208
  store i64 ptrtoint (i8* blockaddress(@snd_ctl_read, %__here) to i64), i64* %task_state_change, align 32, !tbaa !70
  %8 = bitcast i64* %__ret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #9
  store volatile i64 1, i64* %__ret, align 8, !tbaa !104
  %9 = load volatile i64, i64* %__ret, align 8, !tbaa !104
  %call41 = call %struct.task_struct* @get_current.48()
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call41, i32 0, i32 1
  %10 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state, i64 %9, i64* %state) #9, !srcloc !209
  store volatile i64 %10, i64* %__ret, align 8, !tbaa !104
  %11 = load volatile i64, i64* %__ret, align 8, !tbaa !104
  %12 = bitcast i64* %__ret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #9
  %read_lock45 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 5
  call void @spin_unlock_irq(%struct.spinlock* %read_lock45)
  call void @schedule()
  %change_sleep46 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 4
  call void @remove_wait_queue(%struct.__wait_queue_head* %change_sleep46, %struct.__wait_queue* %wait)
  %card47 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %13 = load %struct.snd_card*, %struct.snd_card** %card47, align 8, !tbaa !208
  %shutdown = getelementptr inbounds %struct.snd_card, %struct.snd_card* %13, i32 0, i32 27
  %14 = load i32, i32* %shutdown, align 8, !tbaa !69
  %tobool48 = icmp ne i32 %14, 0
  br i1 %tobool48, label %cleanup, label %if.end50

if.end50:                                         ; preds = %__here
  %call51 = call %struct.task_struct* @get_current.48()
  %call52 = call i32 @signal_pending(%struct.task_struct* %call51)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %cleanup, label %if.end55

if.end55:                                         ; preds = %if.end50
  %read_lock56 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 5
  call void @spin_lock_irq(%struct.spinlock* %read_lock56)
  br label %cleanup

cleanup:                                          ; preds = %if.end55, %if.end50, %__here, %while.body30
  %err.2 = phi i32 [ %err.1, %if.end55 ], [ -11, %while.body30 ], [ %err.1, %__here ], [ %err.1, %if.end50 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end55 ], [ 6, %while.body30 ], [ 1, %__here ], [ 1, %if.end50 ]
  %retval.2 = phi i64 [ %retval.1, %if.end55 ], [ %retval.1, %while.body30 ], [ -19, %__here ], [ -512, %if.end50 ]
  %15 = bitcast %struct.__wait_queue* %wait to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %15) #9
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %cleanup.cont, label %cleanup70

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond28

while.end:                                        ; preds = %while.cond28
  %events57 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %events57, i32 0, i32 0
  %16 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !210
  %17 = bitcast %struct.list_head* %16 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %17, i64 0
  %18 = bitcast i8* %add.ptr to %struct.snd_kctl_event*
  %type = getelementptr inbounds %struct.snd_ctl_event, %struct.snd_ctl_event* %ev, i32 0, i32 0
  store i32 0, i32* %type, align 4, !tbaa !211
  %mask = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %18, i32 0, i32 2
  %19 = load i32, i32* %mask, align 8, !tbaa !183
  %data = getelementptr inbounds %struct.snd_ctl_event, %struct.snd_ctl_event* %ev, i32 0, i32 1
  %elem = bitcast %union.anon.77* %data to %struct.anon.78*
  %mask59 = getelementptr inbounds %struct.anon.78, %struct.anon.78* %elem, i32 0, i32 0
  store i32 %19, i32* %mask59, align 4, !tbaa !49
  %data60 = getelementptr inbounds %struct.snd_ctl_event, %struct.snd_ctl_event* %ev, i32 0, i32 1
  %elem61 = bitcast %union.anon.77* %data60 to %struct.anon.78*
  %id = getelementptr inbounds %struct.anon.78, %struct.anon.78* %elem61, i32 0, i32 1
  %id62 = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %18, i32 0, i32 1
  %20 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %21 = bitcast %struct.snd_ctl_elem_id* %id62 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %20, i8* %21, i64 64, i32 4, i1 false), !tbaa.struct !175
  %list = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %18, i32 0, i32 0
  call void @list_del.49(%struct.list_head* %list)
  %read_lock63 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 5
  call void @spin_unlock_irq(%struct.spinlock* %read_lock63)
  %22 = bitcast %struct.snd_kctl_event* %18 to i8*
  call void @kfree(i8* %22)
  %23 = bitcast %struct.snd_ctl_event* %ev to i8*
  %call64 = call i64 @copy_to_user.74(i8* %buffer.addr.0, i8* %23, i64 72)
  %tobool65 = icmp ne i64 %call64, 0
  br i1 %tobool65, label %cleanup70, label %if.end67

if.end67:                                         ; preds = %while.end
  %read_lock68 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 5
  call void @spin_lock_irq(%struct.spinlock* %read_lock68)
  %add.ptr69 = getelementptr inbounds i8, i8* %buffer.addr.0, i64 72
  %sub = sub i64 %count.addr.0, 72
  %add = add i64 %result.0, 72
  br label %cleanup70

cleanup70:                                        ; preds = %if.end67, %while.end, %cleanup
  %err.3 = phi i32 [ %err.1, %if.end67 ], [ -14, %while.end ], [ %err.2, %cleanup ]
  %result.1 = phi i64 [ %add, %if.end67 ], [ %result.0, %while.end ], [ %result.0, %cleanup ]
  %count.addr.1 = phi i64 [ %sub, %if.end67 ], [ %count.addr.0, %while.end ], [ %count.addr.0, %cleanup ]
  %buffer.addr.1 = phi i8* [ %add.ptr69, %if.end67 ], [ %buffer.addr.0, %while.end ], [ %buffer.addr.0, %cleanup ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end67 ], [ 12, %while.end ], [ %cleanup.dest.slot.0, %cleanup ]
  %retval.3 = phi i64 [ %retval.1, %if.end67 ], [ %retval.1, %while.end ], [ %retval.2, %cleanup ]
  %24 = bitcast %struct.snd_ctl_event* %ev to i8*
  call void @llvm.lifetime.end.p0i8(i64 72, i8* %24) #9
  %Pivot9 = icmp slt i32 %cleanup.dest.slot.1, 6
  br i1 %Pivot9, label %LeafBlock2, label %NodeBlock

NodeBlock:                                        ; preds = %cleanup70
  %Pivot = icmp slt i32 %cleanup.dest.slot.1, 12
  br i1 %Pivot, label %LeafBlock4, label %LeafBlock6

LeafBlock6:                                       ; preds = %NodeBlock
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.1, 12
  br i1 %SwitchLeaf7, label %__end, label %cleanup79

LeafBlock4:                                       ; preds = %NodeBlock
  %SwitchLeaf5 = icmp eq i32 %cleanup.dest.slot.1, 6
  br i1 %SwitchLeaf5, label %__end_lock, label %cleanup79

LeafBlock2:                                       ; preds = %cleanup70
  %SwitchLeaf3 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %SwitchLeaf3, label %cleanup.cont73, label %cleanup79

cleanup.cont73:                                   ; preds = %LeafBlock2
  br label %while.cond

__end_lock:                                       ; preds = %LeafBlock4, %while.cond
  %err.4 = phi i32 [ %err.3, %LeafBlock4 ], [ %err.0, %while.cond ]
  %result.2 = phi i64 [ %result.1, %LeafBlock4 ], [ %result.0, %while.cond ]
  %read_lock75 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 5
  call void @spin_unlock_irq(%struct.spinlock* %read_lock75)
  br label %__end

__end:                                            ; preds = %__end_lock, %LeafBlock6
  %err.5 = phi i32 [ %err.4, %__end_lock ], [ %err.3, %LeafBlock6 ]
  %result.3 = phi i64 [ %result.2, %__end_lock ], [ %result.1, %LeafBlock6 ]
  %cmp76 = icmp sgt i64 %result.3, 0
  %conv78 = sext i32 %err.5 to i64
  %cond = select i1 %cmp76, i64 %result.3, i64 %conv78
  br label %cleanup79

cleanup79:                                        ; preds = %__end, %LeafBlock2, %LeafBlock4, %LeafBlock6, %if.end22, %if.end19, %if.end
  %retval.4 = phi i64 [ -6, %if.end ], [ -77, %if.end19 ], [ -22, %if.end22 ], [ %cond, %__end ], [ %retval.3, %LeafBlock2 ], [ %retval.3, %LeafBlock6 ], [ %retval.3, %LeafBlock4 ]
  ret i64 %retval.4
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_ctl_file*
  %subscribed = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 7
  %2 = load i32, i32* %subscribed, align 8, !tbaa !180
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %change_sleep = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 4
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* %change_sleep, %struct.poll_table_struct* %wait)
  %events = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 8
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool1 = icmp ne i32 %call, 0
  %or = or i32 0, 65
  %.or = select i1 %tobool1, i32 0, i32 %or
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %.or, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_ctl_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %0 = inttoptr i64 %arg to i8*
  %1 = bitcast i8* %0 to i32*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %2 = load i8*, i8** %private_data, align 8, !tbaa !207
  %3 = bitcast i8* %2 to %struct.snd_ctl_file*
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %3, i32 0, i32 1
  %4 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !208
  %tobool = icmp ne %struct.snd_card* %4, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1506)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %NodeBlock51

NodeBlock51:                                      ; preds = %if.end
  %Pivot52 = icmp slt i32 %cmd, -1069525735
  br i1 %Pivot52, label %NodeBlock21, label %NodeBlock49

NodeBlock49:                                      ; preds = %NodeBlock51
  %Pivot50 = icmp slt i32 %cmd, -1055894248
  br i1 %Pivot50, label %NodeBlock33, label %NodeBlock47

NodeBlock47:                                      ; preds = %NodeBlock49
  %Pivot48 = icmp slt i32 %cmd, -993503981
  br i1 %Pivot48, label %NodeBlock37, label %NodeBlock45

NodeBlock45:                                      ; preds = %NodeBlock47
  %Pivot46 = icmp slt i32 %cmd, 1077957908
  br i1 %Pivot46, label %LeafBlock39, label %NodeBlock43

NodeBlock43:                                      ; preds = %NodeBlock45
  %Pivot44 = icmp slt i32 %cmd, 1077957909
  br i1 %Pivot44, label %sw.bb39, label %LeafBlock41

LeafBlock41:                                      ; preds = %NodeBlock43
  %SwitchLeaf42 = icmp eq i32 %cmd, 1077957909
  br i1 %SwitchLeaf42, label %sw.bb42, label %sw.epilog

LeafBlock39:                                      ; preds = %NodeBlock45
  %SwitchLeaf40 = icmp eq i32 %cmd, -993503981
  br i1 %SwitchLeaf40, label %sw.bb36, label %sw.epilog

NodeBlock37:                                      ; preds = %NodeBlock47
  %Pivot38 = icmp slt i32 %cmd, -993503982
  br i1 %Pivot38, label %LeafBlock35, label %sw.bb33

LeafBlock35:                                      ; preds = %NodeBlock37
  %SwitchLeaf36 = icmp eq i32 %cmd, -1055894248
  br i1 %SwitchLeaf36, label %sw.bb48, label %sw.epilog

NodeBlock33:                                      ; preds = %NodeBlock49
  %Pivot34 = icmp slt i32 %cmd, -1055894255
  br i1 %Pivot34, label %NodeBlock27, label %NodeBlock31

NodeBlock31:                                      ; preds = %NodeBlock33
  %Pivot32 = icmp slt i32 %cmd, -1055894249
  br i1 %Pivot32, label %LeafBlock29, label %sw.bb45

LeafBlock29:                                      ; preds = %NodeBlock31
  %SwitchLeaf30 = icmp eq i32 %cmd, -1055894255
  br i1 %SwitchLeaf30, label %sw.bb30, label %sw.epilog

NodeBlock27:                                      ; preds = %NodeBlock33
  %Pivot28 = icmp slt i32 %cmd, -1068477168
  br i1 %Pivot28, label %LeafBlock23, label %LeafBlock25

LeafBlock25:                                      ; preds = %NodeBlock27
  %SwitchLeaf26 = icmp eq i32 %cmd, -1068477168
  br i1 %SwitchLeaf26, label %sw.bb27, label %sw.epilog

LeafBlock23:                                      ; preds = %NodeBlock27
  %SwitchLeaf24 = icmp eq i32 %cmd, -1069525735
  br i1 %SwitchLeaf24, label %sw.bb51, label %sw.epilog

NodeBlock21:                                      ; preds = %NodeBlock51
  %Pivot22 = icmp slt i32 %cmd, -1073457712
  br i1 %Pivot22, label %NodeBlock9, label %NodeBlock19

NodeBlock19:                                      ; preds = %NodeBlock21
  %Pivot20 = icmp slt i32 %cmd, -1073195749
  br i1 %Pivot20, label %NodeBlock13, label %NodeBlock17

NodeBlock17:                                      ; preds = %NodeBlock19
  %Pivot18 = icmp slt i32 %cmd, -1073195748
  br i1 %Pivot18, label %sw.bb60, label %LeafBlock15

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %cmd, -1073195748
  br i1 %SwitchLeaf16, label %sw.bb63, label %sw.epilog

NodeBlock13:                                      ; preds = %NodeBlock19
  %Pivot14 = icmp slt i32 %cmd, -1073195750
  br i1 %Pivot14, label %LeafBlock11, label %sw.bb57

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %cmd, -1073457712
  br i1 %SwitchLeaf12, label %cleanup, label %sw.epilog

NodeBlock9:                                       ; preds = %NodeBlock21
  %Pivot10 = icmp slt i32 %cmd, -2122820351
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %cmd, -1073457898
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %cmd, -1073457898
  br i1 %SwitchLeaf6, label %sw.bb54, label %sw.epilog

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %cmd, -2122820351
  br i1 %SwitchLeaf4, label %sw.bb25, label %sw.epilog

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %cmd, -2147199535
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, -2147199535
  br i1 %SwitchLeaf2, label %sw.bb67, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, -2147199744
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @__might_fault(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1510)
  %5 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 131079, i32* %1) #9, !srcloc !213
  %conv21 = sext i32 %5 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  %6 = zext i1 %tobool23 to i64
  %cond = select i1 %tobool23, i32 -14, i32 0
  %conv24 = sext i32 %cond to i64
  br label %cleanup

sw.bb25:                                          ; preds = %LeafBlock3
  %call = call i32 @snd_ctl_card_info(%struct.snd_card* %4, i8* %0)
  %conv26 = sext i32 %call to i64
  br label %cleanup

sw.bb27:                                          ; preds = %LeafBlock25
  %7 = bitcast i8* %0 to %struct.snd_ctl_elem_list*
  %call28 = call i32 @snd_ctl_elem_list(%struct.snd_card* %4, %struct.snd_ctl_elem_list* %7)
  %conv29 = sext i32 %call28 to i64
  br label %cleanup

sw.bb30:                                          ; preds = %LeafBlock29
  %8 = bitcast i8* %0 to %struct.snd_ctl_elem_info*
  %call31 = call i32 @snd_ctl_elem_info_user(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_info* %8)
  %conv32 = sext i32 %call31 to i64
  br label %cleanup

sw.bb33:                                          ; preds = %NodeBlock37
  %9 = bitcast i8* %0 to %struct.snd_ctl_elem_value*
  %call34 = call i32 @snd_ctl_elem_read_user(%struct.snd_card* %4, %struct.snd_ctl_elem_value* %9)
  %conv35 = sext i32 %call34 to i64
  br label %cleanup

sw.bb36:                                          ; preds = %LeafBlock39
  %10 = bitcast i8* %0 to %struct.snd_ctl_elem_value*
  %call37 = call i32 @snd_ctl_elem_write_user(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_value* %10)
  %conv38 = sext i32 %call37 to i64
  br label %cleanup

sw.bb39:                                          ; preds = %NodeBlock43
  %11 = bitcast i8* %0 to %struct.snd_ctl_elem_id*
  %call40 = call i32 @snd_ctl_elem_lock(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_id* %11)
  %conv41 = sext i32 %call40 to i64
  br label %cleanup

sw.bb42:                                          ; preds = %LeafBlock41
  %12 = bitcast i8* %0 to %struct.snd_ctl_elem_id*
  %call43 = call i32 @snd_ctl_elem_unlock(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_id* %12)
  %conv44 = sext i32 %call43 to i64
  br label %cleanup

sw.bb45:                                          ; preds = %NodeBlock31
  %13 = bitcast i8* %0 to %struct.snd_ctl_elem_info*
  %call46 = call i32 @snd_ctl_elem_add_user(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_info* %13, i32 0)
  %conv47 = sext i32 %call46 to i64
  br label %cleanup

sw.bb48:                                          ; preds = %LeafBlock35
  %14 = bitcast i8* %0 to %struct.snd_ctl_elem_info*
  %call49 = call i32 @snd_ctl_elem_add_user(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_info* %14, i32 1)
  %conv50 = sext i32 %call49 to i64
  br label %cleanup

sw.bb51:                                          ; preds = %LeafBlock23
  %15 = bitcast i8* %0 to %struct.snd_ctl_elem_id*
  %call52 = call i32 @snd_ctl_elem_remove(%struct.snd_ctl_file* %3, %struct.snd_ctl_elem_id* %15)
  %conv53 = sext i32 %call52 to i64
  br label %cleanup

sw.bb54:                                          ; preds = %LeafBlock5
  %call55 = call i32 @snd_ctl_subscribe_events(%struct.snd_ctl_file* %3, i32* %1)
  %conv56 = sext i32 %call55 to i64
  br label %cleanup

sw.bb57:                                          ; preds = %NodeBlock13
  %16 = bitcast i8* %0 to %struct.snd_ctl_tlv*
  %call58 = call i32 @snd_ctl_tlv_ioctl(%struct.snd_ctl_file* %3, %struct.snd_ctl_tlv* %16, i32 0)
  %conv59 = sext i32 %call58 to i64
  br label %cleanup

sw.bb60:                                          ; preds = %NodeBlock17
  %17 = bitcast i8* %0 to %struct.snd_ctl_tlv*
  %call61 = call i32 @snd_ctl_tlv_ioctl(%struct.snd_ctl_file* %3, %struct.snd_ctl_tlv* %17, i32 1)
  %conv62 = sext i32 %call61 to i64
  br label %cleanup

sw.bb63:                                          ; preds = %LeafBlock15
  %18 = bitcast i8* %0 to %struct.snd_ctl_tlv*
  %call64 = call i32 @snd_ctl_tlv_ioctl(%struct.snd_ctl_file* %3, %struct.snd_ctl_tlv* %18, i32 -1)
  %conv65 = sext i32 %call64 to i64
  br label %cleanup

sw.bb67:                                          ; preds = %LeafBlock1
  call void @__might_fault(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1543)
  %power_state = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 33
  %19 = load i32, i32* %power_state, align 4, !tbaa !106
  %20 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %19, i32* %1) #9, !srcloc !214
  %conv71 = sext i32 %20 to i64
  %expval72 = call i64 @llvm.expect.i64(i64 %conv71, i64 0)
  %tobool73 = icmp ne i64 %expval72, 0
  %21 = zext i1 %tobool73 to i64
  %cond74 = select i1 %tobool73, i32 -14, i32 0
  %conv75 = sext i32 %cond74 to i64
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock11, %LeafBlock15, %LeafBlock23, %LeafBlock25, %LeafBlock29, %LeafBlock35, %LeafBlock39, %LeafBlock41
  call void @down_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @snd_control_ioctls, i32 0, i32 0), %sw.epilog ]
  %22 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !2
  %23 = bitcast %struct.list_head* %22 to i8*
  %add.ptr87 = getelementptr inbounds i8, i8* %23, i64 0
  %24 = bitcast i8* %add.ptr87 to %struct.snd_kctl_ioctl*
  %list = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %24, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @snd_control_ioctls
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %fioctl = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %24, i32 0, i32 1
  %25 = load i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)** %fioctl, align 8, !tbaa !159
  %call78 = call i32 %25(%struct.snd_card* %4, %struct.snd_ctl_file* %3, i32 %cmd, i64 %arg)
  %cmp79 = icmp ne i32 %call78, -515
  br i1 %cmp79, label %if.then81, label %for.inc

if.then81:                                        ; preds = %for.body
  call void @up_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %conv82 = sext i32 %call78 to i64
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %list85 = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %24, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list85, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @up_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @snd_ctl_ioctl.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool89 = icmp ne i32 %and, 0
  %lnot90 = xor i1 %tobool89, true
  %lnot92 = xor i1 %lnot90, true
  %lnot.ext93 = zext i1 %lnot92 to i32
  %conv94 = sext i32 %lnot.ext93 to i64
  %expval95 = call i64 @llvm.expect.i64(i64 %conv94, i64 0)
  %tobool96 = icmp ne i64 %expval95, 0
  br i1 %tobool96, label %if.then97, label %cleanup

if.then97:                                        ; preds = %for.end
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 29
  %26 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !115
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @snd_ctl_ioctl.descriptor to %struct._ddebug*), %struct.device* %26, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13.81, i32 0, i32 0), i32 %cmd)
  br label %cleanup

cleanup:                                          ; preds = %if.then97, %for.end, %if.then81, %sw.bb67, %sw.bb63, %sw.bb60, %sw.bb57, %sw.bb54, %sw.bb51, %sw.bb48, %sw.bb45, %sw.bb42, %sw.bb39, %sw.bb36, %sw.bb33, %sw.bb30, %sw.bb27, %sw.bb25, %sw.bb, %LeafBlock11, %if.end
  %retval.0 = phi i64 [ %conv24, %sw.bb ], [ %conv82, %if.then81 ], [ %conv75, %sw.bb67 ], [ %conv26, %sw.bb25 ], [ %conv56, %sw.bb54 ], [ %conv59, %sw.bb57 ], [ %conv62, %sw.bb60 ], [ %conv65, %sw.bb63 ], [ %conv53, %sw.bb51 ], [ %conv29, %sw.bb27 ], [ %conv32, %sw.bb30 ], [ %conv47, %sw.bb45 ], [ %conv50, %sw.bb48 ], [ %conv35, %sw.bb33 ], [ %conv38, %sw.bb36 ], [ %conv41, %sw.bb39 ], [ %conv44, %sw.bb42 ], [ -6, %if.end ], [ -92, %LeafBlock11 ], [ -25, %if.then97 ], [ -25, %for.end ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @snd_ctl_ioctl_compat(%struct.file* %file, i32 %cmd, i64 %arg) #5 {
entry:
  %conv = trunc i64 %arg to i32
  %call = call i8* @compat_ptr(i32 %conv)
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_ctl_file*
  %tobool = icmp ne %struct.snd_ctl_file* %1, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %card = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %2 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !208
  %tobool1 = icmp ne %struct.snd_card* %2, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %3, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 458)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool11 = icmp ne i32 %lnot.ext, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %cleanup, label %NodeBlock52

NodeBlock52:                                      ; preds = %if.end
  %Pivot53 = icmp slt i32 %cmd, -1055894255
  br i1 %Pivot53, label %NodeBlock25, label %NodeBlock50

NodeBlock50:                                      ; preds = %NodeBlock52
  %Pivot51 = icmp slt i32 %cmd, -1027320557
  br i1 %Pivot51, label %NodeBlock35, label %NodeBlock48

NodeBlock48:                                      ; preds = %NodeBlock50
  %Pivot49 = icmp slt i32 %cmd, -1027058413
  br i1 %Pivot49, label %NodeBlock39, label %NodeBlock46

NodeBlock46:                                      ; preds = %NodeBlock48
  %Pivot47 = icmp slt i32 %cmd, 1077957908
  br i1 %Pivot47, label %LeafBlock41, label %LeafBlock43

LeafBlock43:                                      ; preds = %NodeBlock46
  %.off44 = add i32 %cmd, -1077957908
  %SwitchLeaf45 = icmp ule i32 %.off44, 1
  br i1 %SwitchLeaf45, label %sw.bb, label %sw.epilog

LeafBlock41:                                      ; preds = %NodeBlock46
  %SwitchLeaf42 = icmp eq i32 %cmd, -1027058413
  br i1 %SwitchLeaf42, label %sw.bb46, label %sw.epilog

NodeBlock39:                                      ; preds = %NodeBlock48
  %Pivot40 = icmp slt i32 %cmd, -1027058414
  br i1 %Pivot40, label %LeafBlock37, label %sw.bb42

LeafBlock37:                                      ; preds = %NodeBlock39
  %SwitchLeaf38 = icmp eq i32 %cmd, -1027320557
  br i1 %SwitchLeaf38, label %sw.bb33, label %sw.epilog

NodeBlock35:                                      ; preds = %NodeBlock50
  %Pivot36 = icmp slt i32 %cmd, -1055894248
  br i1 %Pivot36, label %NodeBlock29, label %NodeBlock33

NodeBlock33:                                      ; preds = %NodeBlock35
  %Pivot34 = icmp slt i32 %cmd, -1027320558
  br i1 %Pivot34, label %LeafBlock31, label %sw.bb29

LeafBlock31:                                      ; preds = %NodeBlock33
  %SwitchLeaf32 = icmp eq i32 %cmd, -1055894248
  br i1 %SwitchLeaf32, label %sw.bb39, label %sw.epilog

NodeBlock29:                                      ; preds = %NodeBlock35
  %Pivot30 = icmp slt i32 %cmd, -1055894249
  br i1 %Pivot30, label %LeafBlock27, label %sw.bb36

LeafBlock27:                                      ; preds = %NodeBlock29
  %SwitchLeaf28 = icmp eq i32 %cmd, -1055894255
  br i1 %SwitchLeaf28, label %sw.bb26, label %sw.epilog

NodeBlock25:                                      ; preds = %NodeBlock52
  %Pivot26 = icmp slt i32 %cmd, -1073457712
  br i1 %Pivot26, label %NodeBlock9, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %cmd, -1069525735
  br i1 %Pivot24, label %NodeBlock15, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %cmd, -1069001456
  br i1 %Pivot22, label %LeafBlock17, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %cmd, -1069001456
  br i1 %SwitchLeaf20, label %sw.bb22, label %sw.epilog

LeafBlock17:                                      ; preds = %NodeBlock21
  %SwitchLeaf18 = icmp eq i32 %cmd, -1069525735
  br i1 %SwitchLeaf18, label %sw.bb, label %sw.epilog

NodeBlock15:                                      ; preds = %NodeBlock23
  %Pivot16 = icmp slt i32 %cmd, -1073195750
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %.off = add i32 %cmd, 1073195750
  %SwitchLeaf14 = icmp ule i32 %.off, 2
  br i1 %SwitchLeaf14, label %sw.bb, label %sw.epilog

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %cmd, -1073457712
  br i1 %SwitchLeaf12, label %sw.bb, label %sw.epilog

NodeBlock9:                                       ; preds = %NodeBlock25
  %Pivot10 = icmp slt i32 %cmd, -2122820351
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %cmd, -1073457898
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %cmd, -1073457898
  br i1 %SwitchLeaf6, label %sw.bb, label %sw.epilog

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %cmd, -2122820351
  br i1 %SwitchLeaf4, label %sw.bb, label %sw.epilog

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %cmd, -2147199535
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, -2147199535
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.epilog

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, -2147199744
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock11, %LeafBlock13, %LeafBlock17, %LeafBlock43
  %4 = ptrtoint i8* %call to i64
  %call21 = call i64 @snd_ctl_ioctl(%struct.file* %file, i32 %cmd, i64 %4)
  br label %cleanup

sw.bb22:                                          ; preds = %LeafBlock19
  %card23 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %5 = load %struct.snd_card*, %struct.snd_card** %card23, align 8, !tbaa !208
  %6 = bitcast i8* %call to %struct.snd_ctl_elem_list32*
  %call24 = call i32 @snd_ctl_elem_list_compat(%struct.snd_card* %5, %struct.snd_ctl_elem_list32* %6)
  %conv25 = sext i32 %call24 to i64
  br label %cleanup

sw.bb26:                                          ; preds = %LeafBlock27
  %7 = bitcast i8* %call to %struct.snd_ctl_elem_info32*
  %call27 = call i32 @snd_ctl_elem_info_compat(%struct.snd_ctl_file* %1, %struct.snd_ctl_elem_info32* %7)
  %conv28 = sext i32 %call27 to i64
  br label %cleanup

sw.bb29:                                          ; preds = %NodeBlock33
  %card30 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %8 = load %struct.snd_card*, %struct.snd_card** %card30, align 8, !tbaa !208
  %9 = bitcast i8* %call to %struct.snd_ctl_elem_value32*
  %call31 = call i32 @snd_ctl_elem_read_user_compat(%struct.snd_card* %8, %struct.snd_ctl_elem_value32* %9)
  %conv32 = sext i32 %call31 to i64
  br label %cleanup

sw.bb33:                                          ; preds = %LeafBlock37
  %10 = bitcast i8* %call to %struct.snd_ctl_elem_value32*
  %call34 = call i32 @snd_ctl_elem_write_user_compat(%struct.snd_ctl_file* %1, %struct.snd_ctl_elem_value32* %10)
  %conv35 = sext i32 %call34 to i64
  br label %cleanup

sw.bb36:                                          ; preds = %NodeBlock29
  %11 = bitcast i8* %call to %struct.snd_ctl_elem_info32*
  %call37 = call i32 @snd_ctl_elem_add_compat(%struct.snd_ctl_file* %1, %struct.snd_ctl_elem_info32* %11, i32 0)
  %conv38 = sext i32 %call37 to i64
  br label %cleanup

sw.bb39:                                          ; preds = %LeafBlock31
  %12 = bitcast i8* %call to %struct.snd_ctl_elem_info32*
  %call40 = call i32 @snd_ctl_elem_add_compat(%struct.snd_ctl_file* %1, %struct.snd_ctl_elem_info32* %12, i32 1)
  %conv41 = sext i32 %call40 to i64
  br label %cleanup

sw.bb42:                                          ; preds = %NodeBlock39
  %card43 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %13 = load %struct.snd_card*, %struct.snd_card** %card43, align 8, !tbaa !208
  %14 = bitcast i8* %call to %struct.snd_ctl_elem_value_x32*
  %call44 = call i32 @snd_ctl_elem_read_user_x32(%struct.snd_card* %13, %struct.snd_ctl_elem_value_x32* %14)
  %conv45 = sext i32 %call44 to i64
  br label %cleanup

sw.bb46:                                          ; preds = %LeafBlock41
  %15 = bitcast i8* %call to %struct.snd_ctl_elem_value_x32*
  %call47 = call i32 @snd_ctl_elem_write_user_x32(%struct.snd_ctl_file* %1, %struct.snd_ctl_elem_value_x32* %15)
  %conv48 = sext i32 %call47 to i64
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5, %LeafBlock11, %LeafBlock13, %LeafBlock17, %LeafBlock19, %LeafBlock27, %LeafBlock31, %LeafBlock37, %LeafBlock41, %LeafBlock43
  call void @down_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @snd_control_compat_ioctls, i32 0, i32 0), %sw.epilog ]
  %16 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !2
  %17 = bitcast %struct.list_head* %16 to i8*
  %add.ptr65 = getelementptr inbounds i8, i8* %17, i64 0
  %18 = bitcast i8* %add.ptr65 to %struct.snd_kctl_ioctl*
  %list = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %18, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @snd_control_compat_ioctls
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %fioctl = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %18, i32 0, i32 1
  %19 = load i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)** %fioctl, align 8, !tbaa !159
  %tobool51 = icmp ne i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)* %19, null
  br i1 %tobool51, label %if.then52, label %for.inc

if.then52:                                        ; preds = %for.body
  %fioctl53 = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %18, i32 0, i32 1
  %20 = load i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)*, i32 (%struct.snd_card*, %struct.snd_ctl_file*, i32, i64)** %fioctl53, align 8, !tbaa !159
  %card54 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %21 = load %struct.snd_card*, %struct.snd_card** %card54, align 8, !tbaa !208
  %call55 = call i32 %20(%struct.snd_card* %21, %struct.snd_ctl_file* %1, i32 %cmd, i64 %arg)
  %cmp56 = icmp ne i32 %call55, -515
  br i1 %cmp56, label %if.then58, label %for.inc

if.then58:                                        ; preds = %if.then52
  call void @up_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %conv59 = sext i32 %call55 to i64
  br label %cleanup

for.inc:                                          ; preds = %if.then52, %for.body
  %list63 = getelementptr inbounds %struct.snd_kctl_ioctl, %struct.snd_kctl_ioctl* %18, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list63, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @up_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then58, %sw.bb46, %sw.bb42, %sw.bb39, %sw.bb36, %sw.bb33, %sw.bb29, %sw.bb26, %sw.bb22, %sw.bb, %if.end
  %retval.0 = phi i64 [ %call21, %sw.bb ], [ %conv59, %if.then58 ], [ -515, %for.end ], [ %conv25, %sw.bb22 ], [ %conv28, %sw.bb26 ], [ %conv38, %sw.bb36 ], [ %conv41, %sw.bb39 ], [ %conv32, %sw.bb29 ], [ %conv35, %sw.bb33 ], [ %conv45, %sw.bb42 ], [ %conv48, %sw.bb46 ], [ -6, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy35 = alloca i64, align 8
  %__dummy236 = alloca i64, align 8
  %call = call i32 @nonseekable_open(%struct.inode* %inode, %struct.file* %file)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @iminor.67(%struct.inode* %inode)
  %call2 = call i8* @snd_lookup_minor_data(i32 %call1, i32 0)
  %0 = bitcast i8* %call2 to %struct.snd_card*
  %tobool = icmp ne %struct.snd_card* %0, null
  br i1 %tobool, label %if.end4, label %__error1

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @snd_card_file_add(%struct.snd_card* %0, %struct.file* %file)
  %cmp6 = icmp slt i32 %call5, 0
  br i1 %cmp6, label %__error1, label %if.end8

if.end8:                                          ; preds = %if.end4
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 8
  %1 = load %struct.module*, %struct.module** %module, align 8, !tbaa !136
  %call9 = call zeroext i1 @try_module_get(%struct.module* %1)
  br i1 %call9, label %if.end11, label %__error2

if.end11:                                         ; preds = %if.end8
  %call12 = call i8* @kzalloc.56(i64 232, i32 20971712)
  %2 = bitcast i8* %call12 to %struct.snd_ctl_file*
  %cmp13 = icmp eq %struct.snd_ctl_file* %2, null
  br i1 %cmp13, label %__error, label %if.end15

if.end15:                                         ; preds = %if.end11
  %events = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 8
  call void @INIT_LIST_HEAD.68(%struct.list_head* %events)
  %change_sleep = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 4
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %change_sleep, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.16.69, i32 0, i32 0), %struct.lock_class_key* @snd_ctl_open.__key)
  %read_lock = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 5
  %call17 = call %struct.raw_spinlock* @spinlock_check.59(%struct.spinlock* %read_lock)
  %read_lock19 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 5
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %read_lock19, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.18.70, i32 0, i32 0), %struct.lock_class_key* @snd_ctl_open.__key.17)
  %card24 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 1
  store %struct.snd_card* %0, %struct.snd_card** %card24, align 8, !tbaa !208
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end15
  %i.0 = phi i32 [ 0, %if.end15 ], [ %inc, %for.body ]
  %cmp25 = icmp slt i32 %i.0, 2
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %preferred_subdevice = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %preferred_subdevice, i64 0, i64 %idxprom
  store i32 -1, i32* %arrayidx, align 4, !tbaa !47
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call26 = call %struct.task_struct* @get_current.48()
  %call27 = call %struct.pid* @task_pid(%struct.task_struct* %call26)
  %call28 = call %struct.pid* @get_pid(%struct.pid* %call27)
  %pid = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 2
  store %struct.pid* %call28, %struct.pid** %pid, align 8, !tbaa !154
  %4 = bitcast %struct.snd_ctl_file* %2 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %4, i8** %private_data, align 8, !tbaa !207
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #9
  %6 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #9
  %cmp30 = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp30 to i32
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #9
  %8 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #9
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 15
  %call31 = call i64 @_raw_write_lock_irqsave(%struct.rwlock_t* %ctl_files_rwlock)
  %list = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %2, i32 0, i32 0
  %ctl_files = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 19
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %ctl_files)
  %9 = bitcast i64* %__dummy35 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #9
  %10 = bitcast i64* %__dummy236 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #9
  %cmp37 = icmp eq i64* %__dummy35, %__dummy236
  %conv38 = zext i1 %cmp37 to i32
  %11 = bitcast i64* %__dummy236 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #9
  %12 = bitcast i64* %__dummy35 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #9
  %ctl_files_rwlock40 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 15
  call void @_raw_write_unlock_irqrestore(%struct.rwlock_t* %ctl_files_rwlock40, i64 %call31)
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 30
  call void @put_device(%struct.device* %card_dev)
  br label %cleanup

__error:                                          ; preds = %if.end11
  %module43 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 8
  %13 = load %struct.module*, %struct.module** %module43, align 8, !tbaa !136
  call void @module_put(%struct.module* %13)
  br label %__error2

__error2:                                         ; preds = %__error, %if.end8
  %err.0 = phi i32 [ -12, %__error ], [ -14, %if.end8 ]
  %call44 = call i32 @snd_card_file_remove(%struct.snd_card* %0, %struct.file* %file)
  br label %__error1

__error1:                                         ; preds = %__error2, %if.end4, %if.end
  %err.1 = phi i32 [ %err.0, %__error2 ], [ -19, %if.end ], [ -19, %if.end4 ]
  %tobool45 = icmp ne %struct.snd_card* %0, null
  br i1 %tobool45, label %if.then46, label %cleanup

if.then46:                                        ; preds = %__error1
  %card_dev47 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 30
  call void @put_device(%struct.device* %card_dev47)
  br label %cleanup

cleanup:                                          ; preds = %if.then46, %__error1, %for.end, %entry
  %retval.0 = phi i32 [ 0, %for.end ], [ %call, %entry ], [ %err.1, %if.then46 ], [ %err.1, %__error1 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy4 = alloca i64, align 8
  %__dummy25 = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_ctl_file*
  %private_data1 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* null, i8** %private_data1, align 8, !tbaa !207
  %card2 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 1
  %2 = load %struct.snd_card*, %struct.snd_card** %card2, align 8, !tbaa !208
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #9
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #9
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %5 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #9
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #9
  %ctl_files_rwlock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 15
  %call = call i64 @_raw_write_lock_irqsave(%struct.rwlock_t* %ctl_files_rwlock)
  %list = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 0
  call void @list_del.49(%struct.list_head* %list)
  %7 = bitcast i64* %__dummy4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #9
  %8 = bitcast i64* %__dummy25 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #9
  %cmp6 = icmp eq i64* %__dummy4, %__dummy25
  %conv7 = zext i1 %cmp6 to i32
  %9 = bitcast i64* %__dummy25 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #9
  %10 = bitcast i64* %__dummy4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #9
  %ctl_files_rwlock9 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 15
  call void @_raw_write_unlock_irqrestore(%struct.rwlock_t* %ctl_files_rwlock9, i64 %call)
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 18
  br label %for.cond

for.cond:                                         ; preds = %for.inc27, %entry
  %list29.sink = phi %struct.list_head* [ %list29, %for.inc27 ], [ %controls, %entry ]
  %next30 = getelementptr inbounds %struct.list_head, %struct.list_head* %list29.sink, i32 0, i32 0
  %11 = load %struct.list_head*, %struct.list_head** %next30, align 8, !tbaa !2
  %12 = bitcast %struct.list_head* %11 to i8*
  %add.ptr32 = getelementptr inbounds i8, i8* %12, i64 0
  %13 = bitcast i8* %add.ptr32 to %struct.snd_kcontrol*
  %list13 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %13, i32 0, i32 0
  %controls14 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 18
  %cmp15 = icmp ne %struct.list_head* %list13, %controls14
  br i1 %cmp15, label %for.body, label %for.end33

for.body:                                         ; preds = %for.cond
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc, %for.body
  %idx.0 = phi i32 [ 0, %for.body ], [ %inc, %for.inc ]
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %13, i32 0, i32 2
  %14 = load i32, i32* %count, align 8, !tbaa !173
  %cmp18 = icmp ult i32 %idx.0, %14
  br i1 %cmp18, label %for.body20, label %for.inc27

for.body20:                                       ; preds = %for.cond17
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %13, i32 0, i32 10
  %idxprom = zext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i64 0, i64 %idxprom
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %15 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !203
  %cmp21 = icmp eq %struct.snd_ctl_file* %15, %1
  br i1 %cmp21, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body20
  %vd23 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %13, i32 0, i32 10
  %idxprom24 = zext i32 %idx.0 to i64
  %arrayidx25 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd23, i64 0, i64 %idxprom24
  %owner26 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx25, i32 0, i32 0
  store %struct.snd_ctl_file* null, %struct.snd_ctl_file** %owner26, align 8, !tbaa !203
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body20
  %inc = add i32 %idx.0, 1
  br label %for.cond17

for.inc27:                                        ; preds = %for.cond17
  %list29 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %13, i32 0, i32 0
  br label %for.cond

for.end33:                                        ; preds = %for.cond
  %controls_rwsem34 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem34)
  call void @snd_ctl_empty_read_queue(%struct.snd_ctl_file* %1)
  %pid = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 2
  %16 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !154
  call void @put_pid(%struct.pid* %16)
  %17 = bitcast %struct.snd_ctl_file* %1 to i8*
  call void @kfree(i8* %17)
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 8
  %18 = load %struct.module*, %struct.module** %module, align 8, !tbaa !136
  call void @module_put(%struct.module* %18)
  %call35 = call i32 @snd_card_file_remove(%struct.snd_card* %2, %struct.file* %file)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_fasync(i32 %fd, %struct.file* %file, i32 %on) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_ctl_file*
  %fasync = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %1, i32 0, i32 6
  %call = call i32 @fasync_helper(i32 %fd, %struct.file* %file, i32 %on, %struct.fasync_struct** %fasync)
  ret i32 %call
}

declare i32 @fasync_helper(i32, %struct.file*, i32, %struct.fasync_struct**) #1

declare i64 @_raw_write_lock_irqsave(%struct.rwlock_t*) #1 section ".spinlock.text"

declare void @_raw_write_unlock_irqrestore(%struct.rwlock_t*, i64) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @snd_ctl_empty_read_queue(%struct.snd_ctl_file* %ctl) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #9
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #9
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %read_lock = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 5
  %call = call %struct.raw_spinlock* @spinlock_check.59(%struct.spinlock* %read_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %events = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 8
  %call5 = call i32 @list_empty(%struct.list_head* %events)
  %tobool = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %events6 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %events6, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !210
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.snd_kctl_event*
  %list = getelementptr inbounds %struct.snd_kctl_event, %struct.snd_kctl_event* %6, i32 0, i32 0
  call void @list_del.49(%struct.list_head* %list)
  %7 = bitcast %struct.snd_kctl_event* %6 to i8*
  call void @kfree(i8* %7)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %read_lock8 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 5
  call void @spin_unlock_irqrestore(%struct.spinlock* %read_lock8, i64 %call2)
  ret void
}

declare void @put_pid(%struct.pid*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %cmp = icmp eq %struct.list_head* %2, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__read_once_size(i8* %p, i8* %res, i32 %size) #3 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load volatile i8, i8* %p, align 1, !tbaa !49
  store i8 %0, i8* %res, align 1, !tbaa !49
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %p to i16*
  %2 = load volatile i16, i16* %1, align 2, !tbaa !118
  %3 = bitcast i8* %res to i16*
  store i16 %2, i16* %3, align 2, !tbaa !118
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %p to i32*
  %5 = load volatile i32, i32* %4, align 4, !tbaa !47
  %6 = bitcast i8* %res to i32*
  store i32 %5, i32* %6, align 4, !tbaa !47
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %p to i64*
  %8 = load volatile i64, i64* %7, align 8, !tbaa !119
  %9 = bitcast i8* %res to i64*
  store i64 %8, i64* %9, align 8, !tbaa !119
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !215
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %res, i8* %p, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !216
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

declare i32 @nonseekable_open(%struct.inode*, %struct.file*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @iminor.67(%struct.inode* %inode) #5 {
entry:
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %0 = load i32, i32* %i_rdev, align 4, !tbaa !61
  %and = and i32 %0, 1048575
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.68(%struct.list_head* %list) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !49
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.53(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.pid* @get_pid(%struct.pid* %pid) #5 {
entry:
  %tobool = icmp ne %struct.pid* %pid, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count = getelementptr inbounds %struct.pid, %struct.pid* %pid, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.pid* %pid
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @atomic_inc(%struct.atomic_t* %v) #3 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #9, !srcloc !217
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @compat_ptr(i32 %uptr) #5 {
entry:
  %conv = zext i32 %uptr to i64
  %0 = inttoptr i64 %conv to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_list_compat(%struct.snd_card* %card, %struct.snd_ctl_elem_list32* %data32) #0 {
entry:
  %call = call i8* @compat_alloc_user_space(i64 80)
  %0 = bitcast i8* %call to %struct.snd_ctl_elem_list*
  %1 = bitcast %struct.snd_ctl_elem_list* %0 to i8*
  %2 = bitcast %struct.snd_ctl_elem_list32* %data32 to i8*
  %call1 = call i64 @copy_in_user(i8* %1, i8* %2, i32 16)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 48)
  %pids = getelementptr inbounds %struct.snd_ctl_elem_list32, %struct.snd_ctl_elem_list32* %data32, i32 0, i32 4
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %pids, i64 4, i8* undef) #9, !srcloc !218
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult3 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  %conv = trunc i64 %asmresult2 to i32
  %conv4 = sext i32 %5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 49)
  %call6 = call i8* @compat_ptr(i32 %conv)
  %6 = bitcast i8* %call6 to %struct.snd_ctl_elem_id*
  %pids7 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %0, i32 0, i32 4
  %7 = call %struct.snd_ctl_elem_id* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(%struct.snd_ctl_elem_id* %6, %struct.snd_ctl_elem_id** %pids7) #9, !srcloc !219
  %8 = ptrtoint %struct.snd_ctl_elem_id* %7 to i64
  %9 = trunc i64 %8 to i32
  %conv9 = sext i32 %9 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 0)
  %tobool11 = icmp ne i64 %expval10, 0
  br i1 %tobool11, label %cleanup, label %if.end13

if.end13:                                         ; preds = %lor.lhs.false
  %call14 = call i32 @snd_ctl_elem_list(%struct.snd_card* %card, %struct.snd_ctl_elem_list* %0)
  %cmp = icmp slt i32 %call14, 0
  br i1 %cmp, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end13
  %10 = bitcast %struct.snd_ctl_elem_list32* %data32 to i8*
  %11 = bitcast %struct.snd_ctl_elem_list* %0 to i8*
  %call18 = call i64 @copy_in_user(i8* %10, i8* %11, i32 16)
  %tobool19 = icmp ne i64 %call18, 0
  %. = select i1 %tobool19, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %if.end13, %lor.lhs.false, %if.end, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ -14, %lor.lhs.false ], [ -14, %if.end ], [ %call14, %if.end13 ], [ %., %if.end17 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_info_compat(%struct.snd_ctl_file* %ctl, %struct.snd_ctl_elem_info32* %data32) #0 {
entry:
  %call = call i8* @kzalloc.56(i64 272, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_ctl_elem_info*
  %tobool = icmp ne %struct.snd_ctl_elem_info* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 0
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 0
  %2 = bitcast %struct.snd_ctl_elem_id* %id1 to i8*
  %call2 = call i64 @copy_from_user.79(i8* %1, i8* %2, i64 64)
  %tobool3 = icmp ne i64 %call2, 0
  br i1 %tobool3, label %error, label %if.end5

if.end5:                                          ; preds = %if.end
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 111)
  %value = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %enumerated = bitcast %union.anon.59* %value to %struct.anon.62*
  %item = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated, i32 0, i32 1
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %item, i64 4, i8* undef) #9, !srcloc !220
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult6 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult7 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  %conv = trunc i64 %asmresult6 to i32
  %value8 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %enumerated9 = bitcast %union.anon.59* %value8 to %struct.anon.62*
  %item10 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated9, i32 0, i32 1
  store i32 %conv, i32* %item10, align 4, !tbaa !49
  %conv11 = sext i32 %5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %error, label %if.end14

if.end14:                                         ; preds = %if.end5
  %card = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %6 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !208
  call void @snd_power_lock.72(%struct.snd_card* %6)
  %card15 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %7 = load %struct.snd_card*, %struct.snd_card** %card15, align 8, !tbaa !208
  %call16 = call i32 @snd_power_wait(%struct.snd_card* %7, i32 0)
  %cmp = icmp sge i32 %call16, 0
  br i1 %cmp, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end14
  %call19 = call i32 @snd_ctl_elem_info(%struct.snd_ctl_file* %ctl, %struct.snd_ctl_elem_info* %0)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end14
  %err.0 = phi i32 [ %call19, %if.then18 ], [ %call16, %if.end14 ]
  %card21 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %8 = load %struct.snd_card*, %struct.snd_card** %card21, align 8, !tbaa !208
  call void @snd_power_unlock.73(%struct.snd_card* %8)
  %cmp22 = icmp slt i32 %err.0, 0
  br i1 %cmp22, label %error, label %if.end25

if.end25:                                         ; preds = %if.end20
  %id26 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 0
  %9 = bitcast %struct.snd_ctl_elem_id* %id26 to i8*
  %id27 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 0
  %10 = bitcast %struct.snd_ctl_elem_id* %id27 to i8*
  %call28 = call i64 @copy_to_user.74(i8* %9, i8* %10, i64 64)
  %tobool29 = icmp ne i64 %call28, 0
  br i1 %tobool29, label %error, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end25
  %type = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 1
  %11 = bitcast i32* %type to i8*
  %type30 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  %12 = bitcast i32* %type30 to i8*
  %call31 = call i64 @copy_to_user.74(i8* %11, i8* %12, i64 12)
  %tobool32 = icmp ne i64 %call31, 0
  br i1 %tobool32, label %error, label %if.end34

if.end34:                                         ; preds = %lor.lhs.false
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 128)
  %owner = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 4
  %13 = load i32, i32* %owner, align 4, !tbaa !221
  %owner35 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 4
  %14 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %13, i32* %owner35) #9, !srcloc !222
  %conv37 = sext i32 %14 to i64
  %expval38 = call i64 @llvm.expect.i64(i64 %conv37, i64 0)
  %tobool39 = icmp ne i64 %expval38, 0
  br i1 %tobool39, label %error, label %if.end41

if.end41:                                         ; preds = %if.end34
  %type42 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  %15 = load i32, i32* %type42, align 8, !tbaa !150
  %Pivot6 = icmp slt i32 %15, 3
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end41
  %Pivot = icmp slt i32 %15, 6
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %15, 6
  br i1 %SwitchLeaf4, label %sw.bb82, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %15, 3
  br i1 %SwitchLeaf2, label %sw.bb90, label %sw.epilog

LeafBlock:                                        ; preds = %if.end41
  %.off = add i32 %15, -1
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 133)
  %value45 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer = bitcast %union.anon.59* %value45 to %struct.task_cputime*
  %min = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer, i32 0, i32 0
  %16 = load i64, i64* %min, align 8, !tbaa !49
  %conv46 = trunc i64 %16 to i32
  %value47 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer48 = bitcast %union.anon.59* %value47 to %struct.exception_table_entry*
  %min49 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %integer48, i32 0, i32 0
  %17 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv46, i32* %min49) #9, !srcloc !223
  %conv51 = sext i32 %17 to i64
  %expval52 = call i64 @llvm.expect.i64(i64 %conv51, i64 0)
  %tobool53 = icmp ne i64 %expval52, 0
  br i1 %tobool53, label %error, label %lor.lhs.false54

lor.lhs.false54:                                  ; preds = %sw.bb
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 134)
  %value57 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer58 = bitcast %union.anon.59* %value57 to %struct.task_cputime*
  %max = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer58, i32 0, i32 1
  %18 = load i64, i64* %max, align 8, !tbaa !49
  %conv59 = trunc i64 %18 to i32
  %value60 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer61 = bitcast %union.anon.59* %value60 to %struct.exception_table_entry*
  %max62 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %integer61, i32 0, i32 1
  %19 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv59, i32* %max62) #9, !srcloc !224
  %conv64 = sext i32 %19 to i64
  %expval65 = call i64 @llvm.expect.i64(i64 %conv64, i64 0)
  %tobool66 = icmp ne i64 %expval65, 0
  br i1 %tobool66, label %error, label %lor.lhs.false67

lor.lhs.false67:                                  ; preds = %lor.lhs.false54
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 135)
  %value70 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer71 = bitcast %union.anon.59* %value70 to %struct.task_cputime*
  %step = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer71, i32 0, i32 2
  %20 = load i64, i64* %step, align 8, !tbaa !49
  %conv72 = trunc i64 %20 to i32
  %value73 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer74 = bitcast %union.anon.59* %value73 to %struct.exception_table_entry*
  %step75 = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %integer74, i32 0, i32 2
  %21 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv72, i32* %step75) #9, !srcloc !225
  %conv77 = sext i32 %21 to i64
  %expval78 = call i64 @llvm.expect.i64(i64 %conv77, i64 0)
  %tobool79 = icmp ne i64 %expval78, 0
  br i1 %tobool79, label %error, label %sw.epilog

sw.bb82:                                          ; preds = %LeafBlock3
  %value83 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer64 = bitcast %union.anon.59* %value83 to %struct.task_cputime*
  %22 = bitcast %struct.task_cputime* %integer64 to i8*
  %value84 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer6485 = bitcast %union.anon.59* %value84 to %struct.task_cputime*
  %23 = bitcast %struct.task_cputime* %integer6485 to i8*
  %call86 = call i64 @copy_to_user.74(i8* %22, i8* %23, i64 24)
  %tobool87 = icmp ne i64 %call86, 0
  br i1 %tobool87, label %error, label %sw.epilog

sw.bb90:                                          ; preds = %LeafBlock1
  %value91 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %enumerated92 = bitcast %union.anon.59* %value91 to %struct.anon.62*
  %24 = bitcast %struct.anon.62* %enumerated92 to i8*
  %value93 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %enumerated94 = bitcast %union.anon.59* %value93 to %struct.anon.62*
  %25 = bitcast %struct.anon.62* %enumerated94 to i8*
  %call95 = call i64 @copy_to_user.74(i8* %24, i8* %25, i64 88)
  %tobool96 = icmp ne i64 %call95, 0
  br i1 %tobool96, label %error, label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb90, %sw.bb82, %lor.lhs.false67, %LeafBlock, %LeafBlock1, %LeafBlock3
  br label %error

error:                                            ; preds = %sw.epilog, %sw.bb90, %sw.bb82, %lor.lhs.false67, %lor.lhs.false54, %sw.bb, %if.end34, %lor.lhs.false, %if.end25, %if.end20, %if.end5, %if.end
  %err.1 = phi i32 [ 0, %sw.epilog ], [ -14, %if.end ], [ -14, %if.end5 ], [ %err.0, %if.end20 ], [ -14, %lor.lhs.false ], [ -14, %if.end25 ], [ -14, %if.end34 ], [ -14, %lor.lhs.false67 ], [ -14, %lor.lhs.false54 ], [ -14, %sw.bb ], [ -14, %sw.bb82 ], [ -14, %sw.bb90 ]
  %26 = bitcast %struct.snd_ctl_elem_info* %0 to i8*
  call void @kfree(i8* %26)
  br label %cleanup

cleanup:                                          ; preds = %error, %entry
  %retval.0 = phi i32 [ %err.1, %error ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_read_user_compat(%struct.snd_card* %card, %struct.snd_ctl_elem_value32* %data32) #0 {
entry:
  %0 = bitcast %struct.snd_ctl_elem_value32* %data32 to i8*
  %value = getelementptr inbounds %struct.snd_ctl_elem_value32, %struct.snd_ctl_elem_value32* %data32, i32 0, i32 2
  %1 = bitcast %union.anon.83* %value to i8*
  %call = call i32 @ctl_elem_read_user(%struct.snd_card* %card, i8* %0, i8* %1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_write_user_compat(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value32* %data32) #0 {
entry:
  %0 = bitcast %struct.snd_ctl_elem_value32* %data32 to i8*
  %value = getelementptr inbounds %struct.snd_ctl_elem_value32, %struct.snd_ctl_elem_value32* %data32, i32 0, i32 2
  %1 = bitcast %union.anon.83* %value to i8*
  %call = call i32 @ctl_elem_write_user(%struct.snd_ctl_file* %file, i8* %0, i8* %1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_add_compat(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_info32* %data32, i32 %replace) #0 {
entry:
  %call = call i8* @kzalloc.56(i64 272, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_ctl_elem_info*
  %tobool = icmp ne %struct.snd_ctl_elem_info* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 0
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 0
  %2 = bitcast %struct.snd_ctl_elem_id* %id1 to i8*
  %call2 = call i64 @copy_from_user.79(i8* %1, i8* %2, i64 64)
  %tobool3 = icmp ne i64 %call2, 0
  br i1 %tobool3, label %error, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  %3 = bitcast i32* %type to i8*
  %type4 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 1
  %4 = bitcast i32* %type4 to i8*
  %call5 = call i64 @copy_from_user.79(i8* %3, i8* %4, i64 12)
  %tobool6 = icmp ne i64 %call5, 0
  br i1 %tobool6, label %error, label %if.end8

if.end8:                                          ; preds = %lor.lhs.false
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 403)
  %owner = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 4
  %5 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %owner, i64 4, i8* undef) #9, !srcloc !226
  %asmresult = extractvalue { i32*, i64, i8* } %5, 0
  %asmresult9 = extractvalue { i32*, i64, i8* } %5, 1
  %asmresult10 = extractvalue { i32*, i64, i8* } %5, 2
  %6 = ptrtoint i32* %asmresult to i64
  %7 = trunc i64 %6 to i32
  %conv = trunc i64 %asmresult9 to i32
  %owner11 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 4
  store i32 %conv, i32* %owner11, align 4, !tbaa !221
  %conv12 = sext i32 %7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %error, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %if.end8
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 404)
  %type18 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 1
  %8 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %type18, i64 4, i8* undef) #9, !srcloc !227
  %asmresult19 = extractvalue { i32*, i64, i8* } %8, 0
  %asmresult20 = extractvalue { i32*, i64, i8* } %8, 1
  %asmresult21 = extractvalue { i32*, i64, i8* } %8, 2
  %9 = ptrtoint i32* %asmresult19 to i64
  %10 = trunc i64 %9 to i32
  %conv22 = trunc i64 %asmresult20 to i32
  %type23 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  store i32 %conv22, i32* %type23, align 8, !tbaa !150
  %conv25 = sext i32 %10 to i64
  %expval26 = call i64 @llvm.expect.i64(i64 %conv25, i64 0)
  %tobool27 = icmp ne i64 %expval26, 0
  br i1 %tobool27, label %error, label %if.end29

if.end29:                                         ; preds = %lor.lhs.false14
  %type30 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  %11 = load i32, i32* %type30, align 8, !tbaa !150
  %Pivot6 = icmp slt i32 %11, 3
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end29
  %Pivot = icmp slt i32 %11, 6
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %11, 6
  br i1 %SwitchLeaf4, label %sw.bb84, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %11, 3
  br i1 %SwitchLeaf2, label %sw.bb92, label %sw.epilog

LeafBlock:                                        ; preds = %if.end29
  %.off = add i32 %11, -1
  %SwitchLeaf = icmp ule i32 %.off, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 409)
  %value = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer = bitcast %union.anon.59* %value to %struct.exception_table_entry*
  %min = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %integer, i32 0, i32 0
  %12 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %min, i64 4, i8* undef) #9, !srcloc !228
  %asmresult34 = extractvalue { i32*, i64, i8* } %12, 0
  %asmresult35 = extractvalue { i32*, i64, i8* } %12, 1
  %asmresult36 = extractvalue { i32*, i64, i8* } %12, 2
  %13 = ptrtoint i32* %asmresult34 to i64
  %14 = trunc i64 %13 to i32
  %conv37 = trunc i64 %asmresult35 to i32
  %conv38 = sext i32 %conv37 to i64
  %value39 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer40 = bitcast %union.anon.59* %value39 to %struct.task_cputime*
  %min41 = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer40, i32 0, i32 0
  store i64 %conv38, i64* %min41, align 8, !tbaa !49
  %conv43 = sext i32 %14 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %tobool45 = icmp ne i64 %expval44, 0
  br i1 %tobool45, label %error, label %lor.lhs.false46

lor.lhs.false46:                                  ; preds = %sw.bb
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 410)
  %value50 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer51 = bitcast %union.anon.59* %value50 to %struct.exception_table_entry*
  %max = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %integer51, i32 0, i32 1
  %15 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %max, i64 4, i8* undef) #9, !srcloc !229
  %asmresult52 = extractvalue { i32*, i64, i8* } %15, 0
  %asmresult53 = extractvalue { i32*, i64, i8* } %15, 1
  %asmresult54 = extractvalue { i32*, i64, i8* } %15, 2
  %16 = ptrtoint i32* %asmresult52 to i64
  %17 = trunc i64 %16 to i32
  %conv55 = trunc i64 %asmresult53 to i32
  %conv56 = sext i32 %conv55 to i64
  %value57 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer58 = bitcast %union.anon.59* %value57 to %struct.task_cputime*
  %max59 = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer58, i32 0, i32 1
  store i64 %conv56, i64* %max59, align 8, !tbaa !49
  %conv61 = sext i32 %17 to i64
  %expval62 = call i64 @llvm.expect.i64(i64 %conv61, i64 0)
  %tobool63 = icmp ne i64 %expval62, 0
  br i1 %tobool63, label %error, label %lor.lhs.false64

lor.lhs.false64:                                  ; preds = %lor.lhs.false46
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 411)
  %value68 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer69 = bitcast %union.anon.59* %value68 to %struct.exception_table_entry*
  %step = getelementptr inbounds %struct.exception_table_entry, %struct.exception_table_entry* %integer69, i32 0, i32 2
  %18 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %step, i64 4, i8* undef) #9, !srcloc !230
  %asmresult70 = extractvalue { i32*, i64, i8* } %18, 0
  %asmresult71 = extractvalue { i32*, i64, i8* } %18, 1
  %asmresult72 = extractvalue { i32*, i64, i8* } %18, 2
  %19 = ptrtoint i32* %asmresult70 to i64
  %20 = trunc i64 %19 to i32
  %conv73 = trunc i64 %asmresult71 to i32
  %conv74 = sext i32 %conv73 to i64
  %value75 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer76 = bitcast %union.anon.59* %value75 to %struct.task_cputime*
  %step77 = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer76, i32 0, i32 2
  store i64 %conv74, i64* %step77, align 8, !tbaa !49
  %conv79 = sext i32 %20 to i64
  %expval80 = call i64 @llvm.expect.i64(i64 %conv79, i64 0)
  %tobool81 = icmp ne i64 %expval80, 0
  br i1 %tobool81, label %error, label %sw.epilog

sw.bb84:                                          ; preds = %LeafBlock3
  %value85 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %integer64 = bitcast %union.anon.59* %value85 to %struct.task_cputime*
  %21 = bitcast %struct.task_cputime* %integer64 to i8*
  %value86 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %integer6487 = bitcast %union.anon.59* %value86 to %struct.task_cputime*
  %22 = bitcast %struct.task_cputime* %integer6487 to i8*
  %call88 = call i64 @copy_from_user.79(i8* %21, i8* %22, i64 24)
  %tobool89 = icmp ne i64 %call88, 0
  br i1 %tobool89, label %error, label %sw.epilog

sw.bb92:                                          ; preds = %LeafBlock1
  %value93 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %enumerated = bitcast %union.anon.59* %value93 to %struct.anon.62*
  %23 = bitcast %struct.anon.62* %enumerated to i8*
  %value94 = getelementptr inbounds %struct.snd_ctl_elem_info32, %struct.snd_ctl_elem_info32* %data32, i32 0, i32 5
  %enumerated95 = bitcast %union.anon.59* %value94 to %struct.anon.62*
  %24 = bitcast %struct.anon.62* %enumerated95 to i8*
  %call96 = call i64 @copy_from_user.79(i8* %23, i8* %24, i64 88)
  %tobool97 = icmp ne i64 %call96, 0
  br i1 %tobool97, label %error, label %if.end99

if.end99:                                         ; preds = %sw.bb92
  %value100 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %enumerated101 = bitcast %union.anon.59* %value100 to %struct.anon.62*
  %names_ptr = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated101, i32 0, i32 3
  %25 = load i64, i64* %names_ptr, align 8, !tbaa !49
  %conv102 = trunc i64 %25 to i32
  %call103 = call i8* @compat_ptr(i32 %conv102)
  %26 = ptrtoint i8* %call103 to i64
  %value104 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 5
  %enumerated105 = bitcast %union.anon.59* %value104 to %struct.anon.62*
  %names_ptr106 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated105, i32 0, i32 3
  store i64 %26, i64* %names_ptr106, align 8, !tbaa !49
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end99, %sw.bb84, %lor.lhs.false64, %LeafBlock, %LeafBlock1, %LeafBlock3
  %call107 = call i32 @snd_ctl_elem_add(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_info* %0, i32 %replace)
  br label %error

error:                                            ; preds = %sw.epilog, %sw.bb92, %sw.bb84, %lor.lhs.false64, %lor.lhs.false46, %sw.bb, %lor.lhs.false14, %if.end8, %lor.lhs.false, %if.end
  %err.0 = phi i32 [ %call107, %sw.epilog ], [ -14, %lor.lhs.false ], [ -14, %if.end ], [ -14, %lor.lhs.false14 ], [ -14, %if.end8 ], [ -14, %lor.lhs.false64 ], [ -14, %lor.lhs.false46 ], [ -14, %sw.bb ], [ -14, %sw.bb84 ], [ -14, %sw.bb92 ]
  %27 = bitcast %struct.snd_ctl_elem_info* %0 to i8*
  call void @kfree(i8* %27)
  br label %cleanup

cleanup:                                          ; preds = %error, %entry
  %retval.0 = phi i32 [ %err.0, %error ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_read_user_x32(%struct.snd_card* %card, %struct.snd_ctl_elem_value_x32* %data32) #0 {
entry:
  %0 = bitcast %struct.snd_ctl_elem_value_x32* %data32 to i8*
  %value = getelementptr inbounds %struct.snd_ctl_elem_value_x32, %struct.snd_ctl_elem_value_x32* %data32, i32 0, i32 2
  %1 = bitcast %union.anon.84* %value to i8*
  %call = call i32 @ctl_elem_read_user(%struct.snd_card* %card, i8* %0, i8* %1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_write_user_x32(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value_x32* %data32) #0 {
entry:
  %0 = bitcast %struct.snd_ctl_elem_value_x32* %data32 to i8*
  %value = getelementptr inbounds %struct.snd_ctl_elem_value_x32, %struct.snd_ctl_elem_value_x32* %data32, i32 0, i32 2
  %1 = bitcast %union.anon.84* %value to i8*
  %call = call i32 @ctl_elem_write_user(%struct.snd_ctl_file* %file, i8* %0, i8* %1)
  ret i32 %call
}

declare void @down_read(%struct.rw_semaphore*) #1

declare void @up_read(%struct.rw_semaphore*) #1

; Function Attrs: nounwind uwtable
define internal i32 @ctl_elem_write_user(%struct.snd_ctl_file* %file, i8* %userdata, i8* %valuep) #0 {
entry:
  %type = alloca i32, align 4
  %count = alloca i32, align 4
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !208
  %1 = bitcast i32* %type to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #9
  %2 = bitcast i32* %count to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #9
  %call = call i8* @kzalloc.56(i64 1224, i32 20971712)
  %3 = bitcast i8* %call to %struct.snd_ctl_elem_value*
  %cmp = icmp eq %struct.snd_ctl_elem_value* %3, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i32 @copy_ctl_value_from_user(%struct.snd_card* %0, %struct.snd_ctl_elem_value* %3, i8* %userdata, i8* %valuep, i32* %type, i32* %count)
  %cmp3 = icmp slt i32 %call2, 0
  br i1 %cmp3, label %error, label %if.end5

if.end5:                                          ; preds = %if.end
  call void @snd_power_lock.72(%struct.snd_card* %0)
  %call6 = call i32 @snd_power_wait(%struct.snd_card* %0, i32 0)
  %cmp7 = icmp sge i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end5
  %call9 = call i32 @snd_ctl_elem_write(%struct.snd_card* %0, %struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value* %3)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end5
  %err.0 = phi i32 [ %call9, %if.then8 ], [ %call6, %if.end5 ]
  call void @snd_power_unlock.73(%struct.snd_card* %0)
  %cmp11 = icmp sge i32 %err.0, 0
  br i1 %cmp11, label %if.then12, label %error

if.then12:                                        ; preds = %if.end10
  %4 = load i32, i32* %type, align 4, !tbaa !47
  %5 = load i32, i32* %count, align 4, !tbaa !47
  %call13 = call i32 @copy_ctl_value_to_user(i8* %valuep, %struct.snd_ctl_elem_value* %3, i32 %4, i32 %5)
  br label %error

error:                                            ; preds = %if.then12, %if.end10, %if.end
  %err.2 = phi i32 [ %call2, %if.end ], [ %call13, %if.then12 ], [ %err.0, %if.end10 ]
  %6 = bitcast %struct.snd_ctl_elem_value* %3 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %error, %entry
  %retval.0 = phi i32 [ %err.2, %error ], [ -12, %entry ]
  %7 = bitcast i32* %count to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #9
  %8 = bitcast i32* %type to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @copy_ctl_value_from_user(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %data, i8* %userdata, i8* %valuep, i32* %typep, i32* %countp) #0 {
entry:
  %count = alloca i32, align 4
  %0 = bitcast i8* %userdata to %struct.snd_ctl_elem_value32*
  %1 = bitcast i32* %count to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #9
  %2 = load i32, i32* %count, align 4, !tbaa !47
  store i32 %2, i32* %count, align 4, !tbaa !47
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 0
  %3 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_value32, %struct.snd_ctl_elem_value32* %0, i32 0, i32 0
  %4 = bitcast %struct.snd_ctl_elem_id* %id1 to i8*
  %call = call i64 @copy_from_user.79(i8* %3, i8* %4, i64 64)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup55, label %if.end

if.end:                                           ; preds = %entry
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 246)
  %indirect2 = getelementptr inbounds %struct.snd_ctl_elem_value32, %struct.snd_ctl_elem_value32* %0, i32 0, i32 1
  %5 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %indirect2, i64 4, i8* undef) #9, !srcloc !231
  %asmresult = extractvalue { i32*, i64, i8* } %5, 0
  %asmresult3 = extractvalue { i32*, i64, i8* } %5, 1
  %asmresult4 = extractvalue { i32*, i64, i8* } %5, 2
  %6 = ptrtoint i32* %asmresult to i64
  %7 = trunc i64 %6 to i32
  %conv = trunc i64 %asmresult3 to i32
  %conv5 = sext i32 %7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %cleanup55, label %if.end8

if.end8:                                          ; preds = %if.end
  %tobool9 = icmp ne i32 %conv, 0
  br i1 %tobool9, label %cleanup55, label %if.end11

if.end11:                                         ; preds = %if.end8
  %id12 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 0
  %call13 = call i32 @get_ctl_type(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id12, i32* %count)
  %cmp = icmp slt i32 %call13, 0
  br i1 %cmp, label %cleanup55, label %if.end16

if.end16:                                         ; preds = %if.end11
  %call13.off = add i32 %call13, -1
  %switch = icmp ult i32 %call13.off, 2
  br i1 %switch, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end16
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then21
  %i.0 = phi i32 [ 0, %if.then21 ], [ %inc, %for.inc ]
  %__sp26.0 = phi i8* [ undef, %if.then21 ], [ %asmresult29, %for.inc ]
  %retval.0 = phi i32 [ undef, %if.then21 ], [ %retval.1, %for.inc ]
  %8 = load i32, i32* %count, align 4, !tbaa !47
  %cmp22 = icmp slt i32 %i.0, %8
  br i1 %cmp22, label %for.body, label %if.end54

for.body:                                         ; preds = %for.cond
  %9 = bitcast i8* %valuep to i32*
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 259)
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i32, i32* %9, i64 %idxprom
  %10 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %arrayidx, i64 4, i8* %__sp26.0) #9, !srcloc !232
  %asmresult27 = extractvalue { i32*, i64, i8* } %10, 0
  %asmresult28 = extractvalue { i32*, i64, i8* } %10, 1
  %asmresult29 = extractvalue { i32*, i64, i8* } %10, 2
  %11 = ptrtoint i32* %asmresult27 to i64
  %12 = trunc i64 %11 to i32
  %conv30 = trunc i64 %asmresult28 to i32
  %conv32 = sext i32 %12 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %LeafBlock, label %if.end36

if.end36:                                         ; preds = %for.body
  %conv37 = sext i32 %conv30 to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 2
  %integer = bitcast %union.anon.64* %value to %struct.cpumask*
  %value38 = bitcast %struct.cpumask* %integer to [128 x i64]*
  %idxprom39 = sext i32 %i.0 to i64
  %arrayidx40 = getelementptr inbounds [128 x i64], [128 x i64]* %value38, i64 0, i64 %idxprom39
  store i64 %conv37, i64* %arrayidx40, align 8, !tbaa !49
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end36, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end36 ], [ 1, %for.body ]
  %retval.1 = phi i32 [ %retval.0, %if.end36 ], [ -14, %for.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup55

for.inc:                                          ; preds = %LeafBlock
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %if.end16
  %13 = load i32, i32* %count, align 4, !tbaa !47
  %call42 = call i32 @get_elem_size(i32 %call13, i32 %13)
  %cmp43 = icmp slt i32 %call42, 0
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.else
  %dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %14 = load %struct.device*, %struct.device** %dev, align 8, !tbaa !115
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %14, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.15.80, i32 0, i32 0), i32 %call13)
  br label %cleanup55

if.end46:                                         ; preds = %if.else
  %value47 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 2
  %bytes = bitcast %union.anon.64* %value47 to %union.anon.68*
  %data48 = bitcast %union.anon.68* %bytes to [512 x i8]*
  %arraydecay = getelementptr inbounds [512 x i8], [512 x i8]* %data48, i32 0, i32 0
  %conv49 = sext i32 %call42 to i64
  %call50 = call i64 @copy_from_user.79(i8* %arraydecay, i8* %valuep, i64 %conv49)
  %tobool51 = icmp ne i64 %call50, 0
  br i1 %tobool51, label %cleanup55, label %if.end54

if.end54:                                         ; preds = %if.end46, %for.cond
  store i32 %call13, i32* %typep, align 4, !tbaa !47
  %15 = load i32, i32* %count, align 4, !tbaa !47
  store i32 %15, i32* %countp, align 4, !tbaa !47
  br label %cleanup55

cleanup55:                                        ; preds = %if.end54, %if.end46, %if.then45, %LeafBlock, %if.end11, %if.end8, %if.end, %entry
  %retval.2 = phi i32 [ 0, %if.end54 ], [ -22, %if.then45 ], [ -14, %entry ], [ -14, %if.end ], [ -22, %if.end8 ], [ %call13, %if.end11 ], [ -14, %if.end46 ], [ %retval.1, %LeafBlock ]
  %16 = bitcast i32* %count to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %16) #9
  ret i32 %retval.2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_power_lock.72(%struct.snd_card* %card) #5 {
entry:
  %power_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 34
  call void @mutex_lock_nested(%struct.mutex* %power_lock, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_write(%struct.snd_card* %card, %struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value* %control) #0 {
entry:
  %id19 = alloca %struct.snd_ctl_elem_id, align 4
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %if.end23, label %if.else

if.else:                                          ; preds = %entry
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  %call2 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_id* %id1)
  %vd3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom = zext i32 %call2 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd3, i64 0, i64 %idxprom
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %0 = load i32, i32* %access, align 8, !tbaa !177
  %and = and i32 %0, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.end

lor.lhs.false:                                    ; preds = %if.else
  %put = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 5
  %1 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !199
  %cmp4 = icmp eq i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* %1, null
  br i1 %cmp4, label %if.end, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %tobool6 = icmp ne %struct.snd_ctl_file* %file, null
  br i1 %tobool6, label %land.lhs.true, label %if.else12

land.lhs.true:                                    ; preds = %lor.lhs.false5
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %2 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !203
  %tobool7 = icmp ne %struct.snd_ctl_file* %2, null
  br i1 %tobool7, label %land.lhs.true8, label %if.else12

land.lhs.true8:                                   ; preds = %land.lhs.true
  %owner9 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %3 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner9, align 8, !tbaa !203
  %cmp10 = icmp ne %struct.snd_ctl_file* %3, %file
  br i1 %cmp10, label %if.end, label %if.else12

if.else12:                                        ; preds = %land.lhs.true8, %land.lhs.true, %lor.lhs.false5
  %id13 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id13, %struct.snd_kcontrol* %call, i32 %call2)
  %put15 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 5
  %4 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put15, align 8, !tbaa !199
  %call16 = call i32 %4(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_value* %control)
  br label %if.end

if.end:                                           ; preds = %if.else12, %land.lhs.true8, %lor.lhs.false, %if.else
  %result.0 = phi i32 [ %call16, %if.else12 ], [ -1, %land.lhs.true8 ], [ -1, %lor.lhs.false ], [ -1, %if.else ]
  %cmp17 = icmp sgt i32 %result.0, 0
  br i1 %cmp17, label %if.then18, label %if.end23

if.then18:                                        ; preds = %if.end
  %5 = bitcast %struct.snd_ctl_elem_id* %id19 to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %5) #9
  %id20 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  %6 = bitcast %struct.snd_ctl_elem_id* %id19 to i8*
  %7 = bitcast %struct.snd_ctl_elem_id* %id20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 64, i32 4, i1 false), !tbaa.struct !175
  %controls_rwsem21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem21)
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 1, %struct.snd_ctl_elem_id* %id19)
  %8 = bitcast %struct.snd_ctl_elem_id* %id19 to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %8) #9
  br label %cleanup

if.end23:                                         ; preds = %if.end, %entry
  %result.1 = phi i32 [ -2, %entry ], [ %result.0, %if.end ]
  %controls_rwsem24 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem24)
  br label %cleanup

cleanup:                                          ; preds = %if.end23, %if.then18
  %retval.0 = phi i32 [ %result.1, %if.end23 ], [ 0, %if.then18 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_power_unlock.73(%struct.snd_card* %card) #5 {
entry:
  %power_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 34
  call void @mutex_unlock(%struct.mutex* %power_lock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @copy_ctl_value_to_user(i8* %valuep, %struct.snd_ctl_elem_value* %data, i32 %type, i32 %count) #0 {
entry:
  %type.off = add i32 %type, -1
  %switch = icmp ult i32 %type.off, 2
  br i1 %switch, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %if.then ], [ %.retval.0, %for.inc ]
  %cmp2 = icmp slt i32 %i.0, %count
  br i1 %cmp2, label %for.body, label %if.end16

for.body:                                         ; preds = %for.cond
  %0 = bitcast i8* %valuep to i32*
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 2
  %integer = bitcast %union.anon.64* %value to %struct.cpumask*
  %value3 = bitcast %struct.cpumask* %integer to [128 x i64]*
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value3, i64 0, i64 %idxprom
  %1 = load i64, i64* %arrayidx, align 8, !tbaa !49
  %conv = trunc i64 %1 to i32
  call void @__might_fault(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14.71, i32 0, i32 0), i32 292)
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds i32, i32* %0, i64 %idxprom4
  %2 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv, i32* %arrayidx5) #9, !srcloc !233
  %conv6 = sext i32 %2 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool = icmp ne i64 %expval, 0
  %. = select i1 %tobool, i32 1, i32 0
  %.retval.0 = select i1 %tobool, i32 -14, i32 %retval.0
  %SwitchLeaf = icmp eq i32 %., 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup17

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %entry
  %call = call i32 @get_elem_size(i32 %type, i32 %count)
  %value9 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %data, i32 0, i32 2
  %bytes = bitcast %union.anon.64* %value9 to %union.anon.68*
  %data10 = bitcast %union.anon.68* %bytes to [512 x i8]*
  %arraydecay = getelementptr inbounds [512 x i8], [512 x i8]* %data10, i32 0, i32 0
  %conv11 = sext i32 %call to i64
  %call12 = call i64 @copy_to_user.74(i8* %valuep, i8* %arraydecay, i64 %conv11)
  %tobool13 = icmp ne i64 %call12, 0
  br i1 %tobool13, label %cleanup17, label %if.end16

if.end16:                                         ; preds = %if.else, %for.cond
  br label %cleanup17

cleanup17:                                        ; preds = %if.end16, %if.else, %for.body
  %retval.2 = phi i32 [ 0, %if.end16 ], [ -14, %if.else ], [ %.retval.0, %for.body ]
  ret i32 %retval.2
}

; Function Attrs: nounwind uwtable
define internal i32 @get_elem_size(i32 %type, i32 %count) #0 {
entry:
  %Pivot6 = icmp slt i32 %type, 5
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %type, 6
  br i1 %Pivot4, label %return, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %type, 6
  br i1 %SwitchLeaf2, label %sw.bb, label %return

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %type, 4
  br i1 %Pivot, label %LeafBlock, label %return

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %type, 3
  br i1 %SwitchLeaf, label %sw.bb2, label %return

sw.bb:                                            ; preds = %LeafBlock1
  %conv = sext i32 %count to i64
  %mul = mul i64 8, %conv
  %conv1 = trunc i64 %mul to i32
  br label %return

sw.bb2:                                           ; preds = %LeafBlock
  %conv3 = sext i32 %count to i64
  %mul4 = mul i64 4, %conv3
  %conv5 = trunc i64 %mul4 to i32
  br label %return

return:                                           ; preds = %sw.bb2, %sw.bb, %LeafBlock, %NodeBlock, %LeafBlock1, %NodeBlock3
  %retval.0 = phi i32 [ %conv5, %sw.bb2 ], [ %conv1, %sw.bb ], [ 512, %NodeBlock ], [ 176, %NodeBlock3 ], [ -1, %LeafBlock ], [ -1, %LeafBlock1 ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @copy_to_user.74(i8* %to, i8* %from, i64 %n) #3 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %from, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  %conv1 = trunc i64 %n to i32
  call void @kasan_check_read(i8* %from, i32 %conv1)
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.18.119, i32 0, i32 0), i32 718)
  %cmp = icmp slt i32 %conv, 0
  %conv3 = sext i32 %conv to i64
  %cmp4 = icmp uge i64 %conv3, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp4
  %lnot = xor i1 %1, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @check_object_size.76(i8* %from, i64 %n, i1 zeroext true)
  %conv8 = trunc i64 %n to i32
  %call = call i64 @_copy_to_user(i8* %to, i8* %from, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @copy_user_overflow.77(i32 %conv, i64 %n)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.else ]
  ret i64 %n.addr.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @check_object_size.76(i8* %ptr, i64 %n, i1 zeroext %to_user) #3 {
entry:
  %frombool = zext i1 %to_user to i8
  %tobool = trunc i8 %frombool to i1
  call void @__check_object_size(i8* %ptr, i64 %n, i1 zeroext %tobool)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @copy_user_overflow.77(i32 %size, i64 %count) #5 {
entry:
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.18.119, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.19.122, i32 0, i32 0), i32 %size, i64 %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool3 = icmp ne i32 1, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %expval9 = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @copy_from_user.79(i8* %to, i8* %from, i64 %n) #3 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.18.119, i32 0, i32 0), i32 696)
  %conv1 = trunc i64 %n to i32
  call void @kasan_check_write(i8* %to, i32 %conv1)
  %cmp = icmp slt i32 %conv, 0
  %conv3 = sext i32 %conv to i64
  %cmp4 = icmp uge i64 %conv3, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp4
  %lnot = xor i1 %1, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @check_object_size.76(i8* %to, i64 %n, i1 zeroext false)
  %conv8 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @copy_user_overflow.77(i32 %conv, i64 %n)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.else ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_ctl_type(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id, i32* %countp) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %tobool = icmp ne %struct.snd_kcontrol* %call, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %controls_rwsem1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem1)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call i8* @kzalloc.56(i64 272, i32 20971712)
  %0 = bitcast i8* %call2 to %struct.snd_ctl_elem_info*
  %cmp = icmp eq %struct.snd_ctl_elem_info* %0, null
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %controls_rwsem4 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem4)
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %id6 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 0
  %1 = bitcast %struct.snd_ctl_elem_id* %id6 to i8*
  %2 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 64, i32 4, i1 false), !tbaa.struct !175
  %info7 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 3
  %3 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info7, align 8, !tbaa !186
  %call8 = call i32 %3(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_info* %0)
  %controls_rwsem9 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem9)
  %cmp10 = icmp sge i32 %call8, 0
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end5
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 1
  %4 = load i32, i32* %type, align 8, !tbaa !150
  %count = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %0, i32 0, i32 3
  %5 = load i32, i32* %count, align 8, !tbaa !153
  store i32 %5, i32* %countp, align 4, !tbaa !47
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end5
  %err.0 = phi i32 [ %4, %if.then11 ], [ %call8, %if.end5 ]
  %6 = bitcast %struct.snd_ctl_elem_info* %0 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.then3, %if.then
  %retval.0 = phi i32 [ -12, %if.then3 ], [ %err.0, %if.end12 ], [ -2, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ctl_elem_read_user(%struct.snd_card* %card, i8* %userdata, i8* %valuep) #0 {
entry:
  %type = alloca i32, align 4
  %count = alloca i32, align 4
  %0 = bitcast i32* %type to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #9
  %1 = bitcast i32* %count to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #9
  %call = call i8* @kzalloc.56(i64 1224, i32 20971712)
  %2 = bitcast i8* %call to %struct.snd_ctl_elem_value*
  %cmp = icmp eq %struct.snd_ctl_elem_value* %2, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @copy_ctl_value_from_user(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %2, i8* %userdata, i8* %valuep, i32* %type, i32* %count)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %error, label %if.end4

if.end4:                                          ; preds = %if.end
  call void @snd_power_lock.72(%struct.snd_card* %card)
  %call5 = call i32 @snd_power_wait(%struct.snd_card* %card, i32 0)
  %cmp6 = icmp sge i32 %call5, 0
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end4
  %call8 = call i32 @snd_ctl_elem_read(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %2)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end4
  %err.0 = phi i32 [ %call8, %if.then7 ], [ %call5, %if.end4 ]
  call void @snd_power_unlock.73(%struct.snd_card* %card)
  %cmp10 = icmp sge i32 %err.0, 0
  br i1 %cmp10, label %if.then11, label %error

if.then11:                                        ; preds = %if.end9
  %3 = load i32, i32* %type, align 4, !tbaa !47
  %4 = load i32, i32* %count, align 4, !tbaa !47
  %call12 = call i32 @copy_ctl_value_to_user(i8* %valuep, %struct.snd_ctl_elem_value* %2, i32 %3, i32 %4)
  br label %error

error:                                            ; preds = %if.then11, %if.end9, %if.end
  %err.2 = phi i32 [ %call1, %if.end ], [ %call12, %if.then11 ], [ %err.0, %if.end9 ]
  %5 = bitcast %struct.snd_ctl_elem_value* %2 to i8*
  call void @kfree(i8* %5)
  br label %cleanup

cleanup:                                          ; preds = %error, %entry
  %retval.0 = phi i32 [ %err.2, %error ], [ -12, %entry ]
  %6 = bitcast i32* %count to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %6) #9
  %7 = bitcast i32* %type to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_read(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %control) #0 {
entry:
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %if.end11, label %if.else

if.else:                                          ; preds = %entry
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  %call2 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_id* %id1)
  %vd3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom = zext i32 %call2 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd3, i64 0, i64 %idxprom
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %0 = load i32, i32* %access, align 8, !tbaa !177
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.else
  %get = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 4
  %1 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !197
  %cmp4 = icmp ne i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* %1, null
  br i1 %cmp4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %land.lhs.true
  %id6 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %control, i32 0, i32 0
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id6, %struct.snd_kcontrol* %call, i32 %call2)
  %get8 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 4
  %2 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get8, align 8, !tbaa !197
  %call9 = call i32 %2(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_value* %control)
  br label %if.end11

if.end11:                                         ; preds = %if.then5, %land.lhs.true, %if.else, %entry
  %result.1 = phi i32 [ -2, %entry ], [ %call9, %if.then5 ], [ -1, %land.lhs.true ], [ -1, %if.else ]
  %controls_rwsem12 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem12)
  ret i32 %result.1
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_add(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_info* %info, i32 %replace) #0 {
entry:
  %kctl = alloca %struct.snd_kcontrol*, align 8
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !208
  %1 = bitcast %struct.snd_kcontrol** %kctl to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #9
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %name = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 4
  %arraydecay = getelementptr inbounds [44 x i8], [44 x i8]* %name, i32 0, i32 0
  %2 = load i8, i8* %arraydecay, align 8, !tbaa !49
  %tobool = icmp ne i8 %2, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %id2 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %name3 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id2, i32 0, i32 4
  %arraydecay4 = getelementptr inbounds [44 x i8], [44 x i8]* %name3, i32 0, i32 0
  %call = call i64 @strnlen(i8* %arraydecay4, i64 44)
  %cmp = icmp uge i64 %call, 44
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %tobool7 = icmp ne i32 %replace, 0
  br i1 %tobool7, label %if.then8, label %if.end15

if.then8:                                         ; preds = %if.end6
  %id9 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id9, i32 0, i32 0
  store i32 0, i32* %numid, align 8, !tbaa !234
  %id10 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %call11 = call i32 @snd_ctl_remove_user_ctl(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %id10)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %cleanup, label %if.end15

if.end15:                                         ; preds = %if.then8, %if.end6
  %user_ctl_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 17
  %3 = load i32, i32* %user_ctl_count, align 4, !tbaa !235
  %add = add nsw i32 %3, 1
  %cmp16 = icmp sgt i32 %add, 32
  br i1 %cmp16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end15
  %owner = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 4
  %4 = load i32, i32* %owner, align 4, !tbaa !221
  %cmp19 = icmp eq i32 %4, 0
  %. = select i1 %cmp19, i32 1, i32 %4
  %access22 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  %5 = load i32, i32* %access22, align 4, !tbaa !236
  %cmp23 = icmp eq i32 %5, 0
  %access.0 = select i1 %cmp23, i32 3, i32 %5
  %and = and i32 %access.0, 307
  %and26 = and i32 %and, 48
  %tobool27 = icmp ne i32 %and26, 0
  %or = or i32 %and, 268435456
  %or.and = select i1 %tobool27, i32 %or, i32 %and
  %or30 = or i32 %or.and, 536870912
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 1
  %6 = load i32, i32* %type, align 8, !tbaa !150
  %cmp31 = icmp slt i32 %6, 1
  br i1 %cmp31, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end18
  %type32 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 1
  %7 = load i32, i32* %type32, align 8, !tbaa !150
  %cmp33 = icmp sgt i32 %7, 6
  br i1 %cmp33, label %cleanup, label %if.end35

if.end35:                                         ; preds = %lor.lhs.false
  %type36 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 1
  %8 = load i32, i32* %type36, align 8, !tbaa !150
  %cmp37 = icmp eq i32 %8, 3
  br i1 %cmp37, label %land.lhs.true, label %if.end40

land.lhs.true:                                    ; preds = %if.end35
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated = bitcast %union.anon.59* %value to %struct.anon.62*
  %items = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated, i32 0, i32 0
  %9 = load i32, i32* %items, align 8, !tbaa !49
  %cmp38 = icmp eq i32 %9, 0
  br i1 %cmp38, label %cleanup, label %if.end40

if.end40:                                         ; preds = %land.lhs.true, %if.end35
  %count41 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %10 = load i32, i32* %count41, align 8, !tbaa !153
  %cmp42 = icmp ult i32 %10, 1
  br i1 %cmp42, label %cleanup, label %lor.lhs.false43

lor.lhs.false43:                                  ; preds = %if.end40
  %count44 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %11 = load i32, i32* %count44, align 8, !tbaa !153
  %type45 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 1
  %12 = load i32, i32* %type45, align 8, !tbaa !150
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds [7 x i32], [7 x i32]* @snd_ctl_elem_add.max_value_counts, i64 0, i64 %idxprom
  %13 = load i32, i32* %arrayidx, align 4, !tbaa !47
  %cmp46 = icmp ugt i32 %11, %13
  br i1 %cmp46, label %cleanup, label %if.end48

if.end48:                                         ; preds = %lor.lhs.false43
  %call49 = call zeroext i1 @validate_element_member_dimension(%struct.snd_ctl_elem_info* %info)
  br i1 %call49, label %if.end51, label %cleanup

if.end51:                                         ; preds = %if.end48
  %type52 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 1
  %14 = load i32, i32* %type52, align 8, !tbaa !150
  %idxprom53 = sext i32 %14 to i64
  %arrayidx54 = getelementptr inbounds [7 x i32], [7 x i32]* @snd_ctl_elem_add.value_sizes, i64 0, i64 %idxprom53
  %15 = load i32, i32* %arrayidx54, align 4, !tbaa !47
  %count55 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %16 = load i32, i32* %count55, align 8, !tbaa !153
  %mul = mul i32 %15, %16
  %conv = zext i32 %mul to i64
  %call56 = call i32 @snd_ctl_new(%struct.snd_kcontrol** %kctl, i32 %., i32 %or30, %struct.snd_ctl_file* %file)
  %cmp57 = icmp slt i32 %call56, 0
  br i1 %cmp57, label %cleanup, label %if.end60

if.end60:                                         ; preds = %if.end51
  %17 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %id61 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %17, i32 0, i32 1
  %18 = bitcast %struct.snd_ctl_elem_id* %id61 to i8*
  %id62 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %19 = bitcast %struct.snd_ctl_elem_id* %id62 to i8*
  %call63 = call i8* @__memcpy(i8* %18, i8* %19, i64 64)
  %conv64 = zext i32 %. to i64
  %mul65 = mul nsw i64 %conv, %conv64
  %add66 = add i64 320, %mul65
  %call67 = call i8* @kzalloc.56(i64 %add66, i32 20971712)
  %20 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %20, i32 0, i32 8
  store i8* %call67, i8** %private_data, align 8, !tbaa !202
  %21 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %private_data68 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %21, i32 0, i32 8
  %22 = load i8*, i8** %private_data68, align 8, !tbaa !202
  %cmp69 = icmp eq i8* %22, null
  %23 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  br i1 %cmp69, label %if.then71, label %if.end72

if.then71:                                        ; preds = %if.end60
  %24 = bitcast %struct.snd_kcontrol* %23 to i8*
  call void @kfree(i8* %24)
  br label %cleanup

if.end72:                                         ; preds = %if.end60
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %23, i32 0, i32 9
  store void (%struct.snd_kcontrol*)* @snd_ctl_elem_user_free, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !185
  %25 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %private_data73 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %25, i32 0, i32 8
  %26 = load i8*, i8** %private_data73, align 8, !tbaa !202
  %27 = bitcast i8* %26 to %struct.user_element*
  %card74 = getelementptr inbounds %struct.user_element, %struct.user_element* %27, i32 0, i32 1
  store %struct.snd_card* %0, %struct.snd_card** %card74, align 8, !tbaa !237
  %info75 = getelementptr inbounds %struct.user_element, %struct.user_element* %27, i32 0, i32 0
  %28 = bitcast %struct.snd_ctl_elem_info* %info75 to i8*
  %29 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %28, i8* %29, i64 272, i32 8, i1 false), !tbaa.struct !239
  %info76 = getelementptr inbounds %struct.user_element, %struct.user_element* %27, i32 0, i32 0
  %access77 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info76, i32 0, i32 2
  store i32 0, i32* %access77, align 4, !tbaa !240
  %30 = bitcast %struct.user_element* %27 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %30, i64 320
  %elem_data = getelementptr inbounds %struct.user_element, %struct.user_element* %27, i32 0, i32 2
  store i8* %add.ptr, i8** %elem_data, align 8, !tbaa !241
  %elem_data_size = getelementptr inbounds %struct.user_element, %struct.user_element* %27, i32 0, i32 3
  store i64 %conv, i64* %elem_data_size, align 8, !tbaa !242
  %info78 = getelementptr inbounds %struct.user_element, %struct.user_element* %27, i32 0, i32 0
  %type79 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info78, i32 0, i32 1
  %31 = load i32, i32* %type79, align 8, !tbaa !243
  %cmp80 = icmp eq i32 %31, 3
  br i1 %cmp80, label %if.then82, label %if.end88

if.then82:                                        ; preds = %if.end72
  %call83 = call i32 @snd_ctl_elem_init_enum_names(%struct.user_element* %27)
  %cmp84 = icmp slt i32 %call83, 0
  br i1 %cmp84, label %if.then86, label %if.end88

if.then86:                                        ; preds = %if.then82
  %32 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  call void @snd_ctl_free_one(%struct.snd_kcontrol* %32)
  br label %cleanup

if.end88:                                         ; preds = %if.then82, %if.end72
  %type89 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 1
  %33 = load i32, i32* %type89, align 8, !tbaa !150
  %cmp90 = icmp eq i32 %33, 3
  %34 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %info93 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %34, i32 0, i32 3
  %snd_ctl_elem_user_info.sink = select i1 %cmp90, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @snd_ctl_elem_user_enum_info, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @snd_ctl_elem_user_info
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* %snd_ctl_elem_user_info.sink, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info93, align 8, !tbaa !186
  %and96 = and i32 %or30, 1
  %tobool97 = icmp ne i32 %and96, 0
  br i1 %tobool97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.end88
  %35 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %get = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %35, i32 0, i32 4
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @snd_ctl_elem_user_get, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !197
  br label %if.end99

if.end99:                                         ; preds = %if.then98, %if.end88
  %and100 = and i32 %or30, 2
  %tobool101 = icmp ne i32 %and100, 0
  br i1 %tobool101, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.end99
  %36 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %put = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %36, i32 0, i32 5
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @snd_ctl_elem_user_put, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !199
  br label %if.end103

if.end103:                                        ; preds = %if.then102, %if.end99
  %and104 = and i32 %or30, 48
  %tobool105 = icmp ne i32 %and104, 0
  br i1 %tobool105, label %if.then106, label %if.end107

if.then106:                                       ; preds = %if.end103
  %37 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %tlv = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %37, i32 0, i32 6
  %c = bitcast %union.anon.69* %tlv to i32 (%struct.snd_kcontrol*, i32, i32, i32*)**
  store i32 (%struct.snd_kcontrol*, i32, i32, i32*)* @snd_ctl_elem_user_tlv, i32 (%struct.snd_kcontrol*, i32, i32, i32*)** %c, align 8, !tbaa !49
  br label %if.end107

if.end107:                                        ; preds = %if.then106, %if.end103
  %38 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %call108 = call i32 @snd_ctl_add(%struct.snd_card* %0, %struct.snd_kcontrol* %38)
  %cmp109 = icmp slt i32 %call108, 0
  br i1 %cmp109, label %cleanup, label %if.end112

if.end112:                                        ; preds = %if.end107
  %39 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  %id113 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %call114 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %39, %struct.snd_ctl_elem_id* %id113)
  %id115 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %40 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !2
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id115, %struct.snd_kcontrol* %40, i32 %call114)
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %user_ctl_count117 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 17
  %41 = load i32, i32* %user_ctl_count117, align 4, !tbaa !235
  %inc = add nsw i32 %41, 1
  store i32 %inc, i32* %user_ctl_count117, align 4, !tbaa !235
  %controls_rwsem118 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem118)
  br label %cleanup

cleanup:                                          ; preds = %if.end112, %if.end107, %if.then86, %if.then71, %if.end51, %if.end48, %lor.lhs.false43, %if.end40, %land.lhs.true, %lor.lhs.false, %if.end18, %if.end15, %if.then8, %if.end, %entry
  %retval.0 = phi i32 [ -12, %if.then71 ], [ %call83, %if.then86 ], [ 0, %if.end112 ], [ -22, %entry ], [ -22, %if.end ], [ %call11, %if.then8 ], [ -12, %if.end15 ], [ -22, %lor.lhs.false ], [ -22, %if.end18 ], [ -22, %land.lhs.true ], [ -22, %lor.lhs.false43 ], [ -22, %if.end40 ], [ -22, %if.end48 ], [ %call56, %if.end51 ], [ %call108, %if.end107 ]
  %42 = bitcast %struct.snd_kcontrol** %kctl to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %42) #9
  ret i32 %retval.0
}

declare i64 @strnlen(i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_remove_user_ctl(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %id) #0 {
entry:
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !208
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %0, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %error, label %if.end

if.end:                                           ; preds = %entry
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i64 0, i64 0
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %1 = load i32, i32* %access, align 8, !tbaa !177
  %and = and i32 %1, 536870912
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end3, label %error

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %idx.0 = phi i32 [ 0, %if.end3 ], [ %inc, %for.inc ]
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 2
  %2 = load i32, i32* %count, align 8, !tbaa !173
  %cmp4 = icmp ult i32 %idx.0, %2
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %vd5 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx6 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd5, i64 0, i64 %idxprom
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx6, i32 0, i32 0
  %3 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !203
  %cmp7 = icmp ne %struct.snd_ctl_file* %3, null
  br i1 %cmp7, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %vd8 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom9 = sext i32 %idx.0 to i64
  %arrayidx10 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd8, i64 0, i64 %idxprom9
  %owner11 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx10, i32 0, i32 0
  %4 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner11, align 8, !tbaa !203
  %cmp12 = icmp ne %struct.snd_ctl_file* %4, %file
  br i1 %cmp12, label %error, label %for.inc

for.inc:                                          ; preds = %land.lhs.true, %for.body
  %inc = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call15 = call i32 @snd_ctl_remove(%struct.snd_card* %0, %struct.snd_kcontrol* %call)
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %error, label %if.end18

if.end18:                                         ; preds = %for.end
  %user_ctl_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 17
  %5 = load i32, i32* %user_ctl_count, align 4, !tbaa !235
  %dec = add nsw i32 %5, -1
  store i32 %dec, i32* %user_ctl_count, align 4, !tbaa !235
  br label %error

error:                                            ; preds = %if.end18, %for.end, %land.lhs.true, %if.end, %entry
  %ret.0 = phi i32 [ %call15, %if.end18 ], [ -2, %entry ], [ -22, %if.end ], [ -16, %land.lhs.true ], [ %call15, %for.end ]
  %controls_rwsem19 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem19)
  ret i32 %ret.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @validate_element_member_dimension(%struct.snd_ctl_elem_info* %info) #0 {
entry:
  %dimen = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 6
  %d = bitcast %union.anon.63* %dimen to [4 x i16]*
  %arrayidx = getelementptr inbounds [4 x i16], [4 x i16]* %d, i64 0, i64 0
  %0 = load i16, i16* %arrayidx, align 8, !tbaa !49
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %members.0 = phi i32 [ 1, %if.end ], [ %mul, %for.inc ]
  %conv2 = zext i32 %i.0 to i64
  %cmp3 = icmp ult i64 %conv2, 4
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %dimen5 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 6
  %d6 = bitcast %union.anon.63* %dimen5 to [4 x i16]*
  %idxprom = zext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [4 x i16], [4 x i16]* %d6, i64 0, i64 %idxprom
  %1 = load i16, i16* %arrayidx7, align 2, !tbaa !49
  %conv8 = zext i16 %1 to i32
  %cmp9 = icmp eq i32 %conv8, 0
  br i1 %cmp9, label %for.end, label %if.end12

if.end12:                                         ; preds = %for.body
  %dimen13 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 6
  %d14 = bitcast %union.anon.63* %dimen13 to [4 x i16]*
  %idxprom15 = zext i32 %i.0 to i64
  %arrayidx16 = getelementptr inbounds [4 x i16], [4 x i16]* %d14, i64 0, i64 %idxprom15
  %2 = load i16, i16* %arrayidx16, align 2, !tbaa !49
  %conv17 = zext i16 %2 to i32
  %mul = mul i32 %members.0, %conv17
  %count = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %3 = load i32, i32* %count, align 8, !tbaa !153
  %cmp18 = icmp ugt i32 %mul, %3
  br i1 %cmp18, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end12
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc37, %for.end
  %i.1.sink = phi i32 [ %inc38, %for.inc37 ], [ %i.0, %for.end ]
  %inc38 = add i32 %i.1.sink, 1
  %conv24 = zext i32 %inc38 to i64
  %cmp25 = icmp ult i64 %conv24, 4
  br i1 %cmp25, label %for.body27, label %for.end39

for.body27:                                       ; preds = %for.cond23
  %dimen28 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 6
  %d29 = bitcast %union.anon.63* %dimen28 to [4 x i16]*
  %idxprom30 = zext i32 %inc38 to i64
  %arrayidx31 = getelementptr inbounds [4 x i16], [4 x i16]* %d29, i64 0, i64 %idxprom30
  %4 = load i16, i16* %arrayidx31, align 2, !tbaa !49
  %conv32 = zext i16 %4 to i32
  %cmp33 = icmp sgt i32 %conv32, 0
  br i1 %cmp33, label %cleanup, label %for.inc37

for.inc37:                                        ; preds = %for.body27
  br label %for.cond23

for.end39:                                        ; preds = %for.cond23
  %count40 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 3
  %5 = load i32, i32* %count40, align 8, !tbaa !153
  %cmp41 = icmp eq i32 %members.0, %5
  br label %cleanup

cleanup:                                          ; preds = %for.end39, %for.body27, %if.end12, %entry
  %retval.0 = phi i1 [ %cmp41, %for.end39 ], [ true, %entry ], [ false, %if.end12 ], [ false, %for.body27 ]
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_ctl_elem_user_free(%struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.user_element*
  %tlv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  %2 = load i8*, i8** %tlv_data, align 8, !tbaa !244
  call void @kfree(i8* %2)
  %priv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 6
  %3 = load i8*, i8** %priv_data, align 8, !tbaa !245
  call void @kfree(i8* %3)
  %4 = bitcast %struct.user_element* %1 to i8*
  call void @kfree(i8* %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_init_enum_names(%struct.user_element* %ue) #0 {
entry:
  %info = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 5
  %enumerated = bitcast %union.anon.59* %value to %struct.anon.62*
  %names_ptr = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated, i32 0, i32 3
  %0 = load i64, i64* %names_ptr, align 8, !tbaa !49
  %info1 = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value2 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info1, i32 0, i32 5
  %enumerated3 = bitcast %union.anon.59* %value2 to %struct.anon.62*
  %names_length = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated3, i32 0, i32 4
  %1 = load i32, i32* %names_length, align 8, !tbaa !49
  %cmp = icmp ugt i32 %1, 65536
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = inttoptr i64 %0 to i8*
  %info4 = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value5 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info4, i32 0, i32 5
  %enumerated6 = bitcast %union.anon.59* %value5 to %struct.anon.62*
  %names_length7 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated6, i32 0, i32 4
  %3 = load i32, i32* %names_length7, align 8, !tbaa !49
  %conv = zext i32 %3 to i64
  %call = call i8* @memdup_user(i8* %2, i64 %conv)
  %call8 = call zeroext i1 @IS_ERR(i8* %call)
  br i1 %call8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %call10 = call i64 @PTR_ERR(i8* %call)
  %conv11 = trunc i64 %call10 to i32
  br label %cleanup

if.end12:                                         ; preds = %if.end
  %info13 = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value14 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info13, i32 0, i32 5
  %enumerated15 = bitcast %union.anon.59* %value14 to %struct.anon.62*
  %names_length16 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated15, i32 0, i32 4
  %4 = load i32, i32* %names_length16, align 8, !tbaa !49
  %conv17 = zext i32 %4 to i64
  br label %for.cond

for.cond:                                         ; preds = %if.end32, %if.end12
  %buf_len.0 = phi i64 [ %conv17, %if.end12 ], [ %sub, %if.end32 ]
  %p.0 = phi i8* [ %call, %if.end12 ], [ %add.ptr, %if.end32 ]
  %i.0 = phi i32 [ 0, %if.end12 ], [ %inc, %if.end32 ]
  %info18 = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value19 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info18, i32 0, i32 5
  %enumerated20 = bitcast %union.anon.59* %value19 to %struct.anon.62*
  %items = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated20, i32 0, i32 0
  %5 = load i32, i32* %items, align 8, !tbaa !49
  %cmp21 = icmp ult i32 %i.0, %5
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call23 = call i64 @strnlen(i8* %p.0, i64 %buf_len.0)
  %cmp24 = icmp eq i64 %call23, 0
  %cmp26 = icmp uge i64 %call23, 64
  %or.cond = or i1 %cmp24, %cmp26
  %cmp29 = icmp eq i64 %call23, %buf_len.0
  %or.cond1 = or i1 %or.cond, %cmp29
  br i1 %or.cond1, label %if.then31, label %if.end32

if.then31:                                        ; preds = %for.body
  call void @kfree(i8* %call)
  br label %cleanup

if.end32:                                         ; preds = %for.body
  %add = add i64 %call23, 1
  %add.ptr = getelementptr inbounds i8, i8* %p.0, i64 %add
  %add33 = add i64 %call23, 1
  %sub = sub i64 %buf_len.0, %add33
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %priv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 6
  store i8* %call, i8** %priv_data, align 8, !tbaa !245
  %info34 = getelementptr inbounds %struct.user_element, %struct.user_element* %ue, i32 0, i32 0
  %value35 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info34, i32 0, i32 5
  %enumerated36 = bitcast %union.anon.59* %value35 to %struct.anon.62*
  %names_ptr37 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated36, i32 0, i32 3
  store i64 0, i64* %names_ptr37, align 8, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then31, %if.then9, %entry
  %retval.0 = phi i32 [ %conv11, %if.then9 ], [ -22, %if.then31 ], [ 0, %for.end ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_user_enum_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %__UNIQUE_ID_min1_8 = alloca i32, align 4
  %__UNIQUE_ID_min2_9 = alloca i32, align 4
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.user_element*
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %enumerated = bitcast %union.anon.59* %value to %struct.anon.62*
  %item1 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated, i32 0, i32 1
  %2 = load i32, i32* %item1, align 4, !tbaa !49
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 0
  %call = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_id* %id)
  %info = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 0
  %3 = bitcast %struct.snd_ctl_elem_info* %uinfo to i8*
  %4 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 272, i32 8, i1 false), !tbaa.struct !239
  %id2 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 0
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id2, %struct.snd_kcontrol* %kcontrol, i32 %call)
  %5 = bitcast i32* %__UNIQUE_ID_min1_8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #9
  store i32 %2, i32* %__UNIQUE_ID_min1_8, align 4, !tbaa !47
  %6 = bitcast i32* %__UNIQUE_ID_min2_9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #9
  %value4 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %enumerated5 = bitcast %union.anon.59* %value4 to %struct.anon.62*
  %items = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated5, i32 0, i32 0
  %7 = load i32, i32* %items, align 8, !tbaa !49
  %sub = sub i32 %7, 1
  store i32 %sub, i32* %__UNIQUE_ID_min2_9, align 4, !tbaa !47
  %cmp = icmp eq i32* %__UNIQUE_ID_min1_8, %__UNIQUE_ID_min2_9
  %conv = zext i1 %cmp to i32
  %8 = load i32, i32* %__UNIQUE_ID_min1_8, align 4, !tbaa !47
  %9 = load i32, i32* %__UNIQUE_ID_min2_9, align 4, !tbaa !47
  %cmp6 = icmp ult i32 %8, %9
  %10 = load i32, i32* %__UNIQUE_ID_min1_8, align 4
  %11 = load i32, i32* %__UNIQUE_ID_min2_9, align 4
  %cond = select i1 %cmp6, i32 %10, i32 %11
  %12 = bitcast i32* %__UNIQUE_ID_min2_9 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #9
  %13 = bitcast i32* %__UNIQUE_ID_min1_8 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %13) #9
  %value8 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %enumerated9 = bitcast %union.anon.59* %value8 to %struct.anon.62*
  %item10 = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated9, i32 0, i32 1
  store i32 %cond, i32* %item10, align 4, !tbaa !49
  %priv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 6
  %14 = load i8*, i8** %priv_data, align 8, !tbaa !245
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %names.0 = phi i8* [ %14, %entry ], [ %add.ptr, %for.body ]
  %item.0 = phi i32 [ %cond, %entry ], [ %dec, %for.body ]
  %cmp11 = icmp ugt i32 %item.0, 0
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call13 = call i64 @strlen(i8* %names.0)
  %add = add i64 %call13, 1
  %add.ptr = getelementptr inbounds i8, i8* %names.0, i64 %add
  %dec = add i32 %item.0, -1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %value14 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %enumerated15 = bitcast %union.anon.59* %value14 to %struct.anon.62*
  %name = getelementptr inbounds %struct.anon.62, %struct.anon.62* %enumerated15, i32 0, i32 2
  %arraydecay = getelementptr inbounds [64 x i8], [64 x i8]* %name, i32 0, i32 0
  %call16 = call i8* @strcpy(i8* %arraydecay, i8* %names.0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_user_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.user_element*
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 0
  %call = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_id* %id)
  %info = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 0
  %2 = bitcast %struct.snd_ctl_elem_info* %uinfo to i8*
  %3 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 272, i32 8, i1 false), !tbaa.struct !239
  %id1 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 0
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id1, %struct.snd_kcontrol* %kcontrol, i32 %call)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_user_get(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.user_element*
  %elem_data_size = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 3
  %2 = load i64, i64* %elem_data_size, align 8, !tbaa !242
  %conv = trunc i64 %2 to i32
  %elem_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 2
  %3 = load i8*, i8** %elem_data, align 8, !tbaa !241
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 0
  %call = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_id* %id)
  %mul = mul i32 %call, %conv
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %idx.ext
  %card = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %4 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !237
  %user_ctl_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 20
  call void @mutex_lock_nested(%struct.mutex* %user_ctl_lock, i32 0)
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %5 = bitcast %union.anon.64* %value to i8*
  %conv1 = zext i32 %conv to i64
  %call2 = call i8* @__memcpy(i8* %5, i8* %add.ptr, i64 %conv1)
  %card3 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %6 = load %struct.snd_card*, %struct.snd_card** %card3, align 8, !tbaa !237
  %user_ctl_lock4 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %6, i32 0, i32 20
  call void @mutex_unlock(%struct.mutex* %user_ctl_lock4)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_user_put(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.user_element*
  %elem_data_size = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 3
  %2 = load i64, i64* %elem_data_size, align 8, !tbaa !242
  %conv = trunc i64 %2 to i32
  %elem_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 2
  %3 = load i8*, i8** %elem_data, align 8, !tbaa !241
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 0
  %call = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_id* %id)
  %mul = mul i32 %call, %conv
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 %idx.ext
  %card = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %4 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !237
  %user_ctl_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 20
  call void @mutex_lock_nested(%struct.mutex* %user_ctl_lock, i32 0)
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %5 = bitcast %union.anon.64* %value to i8*
  %conv1 = zext i32 %conv to i64
  %call2 = call i32 @memcmp(i8* %5, i8* %add.ptr, i64 %conv1)
  %cmp = icmp ne i32 %call2, 0
  %conv3 = zext i1 %cmp to i32
  %tobool = icmp ne i32 %conv3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %value4 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %6 = bitcast %union.anon.64* %value4 to i8*
  %conv5 = zext i32 %conv to i64
  %call6 = call i8* @__memcpy(i8* %add.ptr, i8* %6, i64 %conv5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %card7 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %7 = load %struct.snd_card*, %struct.snd_card** %card7, align 8, !tbaa !237
  %user_ctl_lock8 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %7, i32 0, i32 20
  call void @mutex_unlock(%struct.mutex* %user_ctl_lock8)
  ret i32 %conv3
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_user_tlv(%struct.snd_kcontrol* %kcontrol, i32 %op_flag, i32 %size, i32* %tlv) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.user_element*
  %cmp = icmp eq i32 %op_flag, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %cmp1 = icmp ugt i32 %size, 131072
  br i1 %cmp1, label %cleanup47, label %if.end

if.end:                                           ; preds = %if.then
  %2 = bitcast i32* %tlv to i8*
  %conv = zext i32 %size to i64
  %call = call i8* @memdup_user(i8* %2, i64 %conv)
  %call3 = call zeroext i1 @IS_ERR(i8* %call)
  br i1 %call3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.end
  %call5 = call i64 @PTR_ERR(i8* %call)
  %conv6 = trunc i64 %call5 to i32
  br label %cleanup47

if.end7:                                          ; preds = %if.end
  %card = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %3 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !237
  %user_ctl_lock = getelementptr inbounds %struct.snd_card, %struct.snd_card* %3, i32 0, i32 20
  call void @mutex_lock_nested(%struct.mutex* %user_ctl_lock, i32 0)
  %tlv_data_size = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 5
  %4 = load i64, i64* %tlv_data_size, align 8, !tbaa !246
  %conv8 = zext i32 %size to i64
  %cmp9 = icmp ne i64 %4, %conv8
  %conv10 = zext i1 %cmp9 to i32
  %tobool = icmp ne i32 %conv10, 0
  br i1 %tobool, label %if.end14, label %if.then11

if.then11:                                        ; preds = %if.end7
  %tlv_data = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  %5 = load i8*, i8** %tlv_data, align 8, !tbaa !244
  %conv12 = zext i32 %size to i64
  %call13 = call i32 @memcmp(i8* %5, i8* %call, i64 %conv12)
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.end7
  %change.0 = phi i32 [ %conv10, %if.end7 ], [ %call13, %if.then11 ]
  %tlv_data15 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  %6 = load i8*, i8** %tlv_data15, align 8, !tbaa !244
  call void @kfree(i8* %6)
  %tlv_data16 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  store i8* %call, i8** %tlv_data16, align 8, !tbaa !244
  %conv17 = zext i32 %size to i64
  %tlv_data_size18 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 5
  store i64 %conv17, i64* %tlv_data_size18, align 8, !tbaa !246
  %card19 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %7 = load %struct.snd_card*, %struct.snd_card** %card19, align 8, !tbaa !237
  %user_ctl_lock20 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %7, i32 0, i32 20
  call void @mutex_unlock(%struct.mutex* %user_ctl_lock20)
  br label %cleanup47

if.else:                                          ; preds = %entry
  %card21 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %8 = load %struct.snd_card*, %struct.snd_card** %card21, align 8, !tbaa !237
  %user_ctl_lock22 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %8, i32 0, i32 20
  call void @mutex_lock_nested(%struct.mutex* %user_ctl_lock22, i32 0)
  %tlv_data_size23 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 5
  %9 = load i64, i64* %tlv_data_size23, align 8, !tbaa !246
  %tobool24 = icmp ne i64 %9, 0
  br i1 %tobool24, label %lor.lhs.false, label %err_unlock

lor.lhs.false:                                    ; preds = %if.else
  %tlv_data25 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  %10 = load i8*, i8** %tlv_data25, align 8, !tbaa !244
  %tobool26 = icmp ne i8* %10, null
  br i1 %tobool26, label %if.end28, label %err_unlock

if.end28:                                         ; preds = %lor.lhs.false
  %conv29 = zext i32 %size to i64
  %tlv_data_size30 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 5
  %11 = load i64, i64* %tlv_data_size30, align 8, !tbaa !246
  %cmp31 = icmp ult i64 %conv29, %11
  br i1 %cmp31, label %err_unlock, label %if.end34

if.end34:                                         ; preds = %if.end28
  %12 = bitcast i32* %tlv to i8*
  %tlv_data35 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 4
  %13 = load i8*, i8** %tlv_data35, align 8, !tbaa !244
  %tlv_data_size36 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 5
  %14 = load i64, i64* %tlv_data_size36, align 8, !tbaa !246
  %call37 = call i64 @copy_to_user.74(i8* %12, i8* %13, i64 %14)
  %tobool38 = icmp ne i64 %call37, 0
  %. = select i1 %tobool38, i32 -14, i32 0
  br label %err_unlock

err_unlock:                                       ; preds = %if.end34, %if.end28, %lor.lhs.false, %if.else
  %ret.1 = phi i32 [ %., %if.end34 ], [ -6, %lor.lhs.false ], [ -6, %if.else ], [ -28, %if.end28 ]
  %card41 = getelementptr inbounds %struct.user_element, %struct.user_element* %1, i32 0, i32 1
  %15 = load %struct.snd_card*, %struct.snd_card** %card41, align 8, !tbaa !237
  %user_ctl_lock42 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %15, i32 0, i32 20
  call void @mutex_unlock(%struct.mutex* %user_ctl_lock42)
  %tobool43 = icmp ne i32 %ret.1, 0
  %.1 = select i1 %tobool43, i32 1, i32 0
  %SwitchLeaf = icmp eq i32 %.1, 0
  %.ret.1 = select i1 %SwitchLeaf, i32 0, i32 %ret.1
  br label %UnifiedReturnBlock

cleanup47:                                        ; preds = %if.end14, %if.then4, %if.then
  %retval.1 = phi i32 [ %conv6, %if.then4 ], [ -22, %if.then ], [ %change.0, %if.end14 ]
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %cleanup47, %err_unlock
  %UnifiedRetVal = phi i32 [ %.ret.1, %err_unlock ], [ %retval.1, %cleanup47 ]
  ret i32 %UnifiedRetVal
}

declare i8* @memdup_user(i8*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #5 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #5 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare i32 @memcmp(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_info(%struct.snd_ctl_file* %ctl, %struct.snd_ctl_elem_info* %info) #0 {
entry:
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !208
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %call = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %0, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %controls_rwsem2 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem2)
  br label %cleanup

if.end:                                           ; preds = %entry
  %access = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  store i32 0, i32* %access, align 4, !tbaa !236
  %info3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 3
  %1 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info3, align 8, !tbaa !186
  %call4 = call i32 %1(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_info* %info)
  %cmp5 = icmp sge i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end46

if.then6:                                         ; preds = %if.end
  %access7 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  %2 = load i32, i32* %access7, align 4, !tbaa !236
  %tobool = icmp ne i32 %2, 0
  %lnot = xor i1 %tobool, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext13 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.then6
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 861)
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.then6
  %tobool17 = icmp ne i32 %lnot.ext, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %id24 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %call25 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call, %struct.snd_ctl_elem_id* %id24)
  %vd26 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 10
  %idxprom = zext i32 %call25 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd26, i64 0, i64 %idxprom
  %id27 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id27, %struct.snd_kcontrol* %call, i32 %call25)
  %access29 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %3 = load i32, i32* %access29, align 8, !tbaa !177
  %access30 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  store i32 %3, i32* %access30, align 4, !tbaa !236
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %4 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !203
  %tobool31 = icmp ne %struct.snd_ctl_file* %4, null
  br i1 %tobool31, label %if.then32, label %if.end45

if.then32:                                        ; preds = %if.end16
  %access33 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  %5 = load i32, i32* %access33, align 4, !tbaa !236
  %or = or i32 %5, 512
  store i32 %or, i32* %access33, align 4, !tbaa !236
  %owner34 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %6 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner34, align 8, !tbaa !203
  %cmp35 = icmp eq %struct.snd_ctl_file* %6, %ctl
  br i1 %cmp35, label %if.then37, label %if.end40

if.then37:                                        ; preds = %if.then32
  %access38 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 2
  %7 = load i32, i32* %access38, align 4, !tbaa !236
  %or39 = or i32 %7, 1024
  store i32 %or39, i32* %access38, align 4, !tbaa !236
  br label %if.end40

if.end40:                                         ; preds = %if.then37, %if.then32
  %owner41 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %8 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner41, align 8, !tbaa !203
  %pid = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %8, i32 0, i32 2
  %9 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !154
  %call42 = call i32 @pid_vnr(%struct.pid* %9)
  br label %if.end45

if.end45:                                         ; preds = %if.end40, %if.end16
  %.sink = phi i32 [ %call42, %if.end40 ], [ -1, %if.end16 ]
  %owner44 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 4
  store i32 %.sink, i32* %owner44, align 4, !tbaa !221
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.end
  %controls_rwsem47 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem47)
  br label %cleanup

cleanup:                                          ; preds = %if.end46, %if.then
  %retval.0 = phi i32 [ -2, %if.then ], [ %call4, %if.end46 ]
  ret i32 %retval.0
}

declare i32 @pid_vnr(%struct.pid*) #1

declare i8* @compat_alloc_user_space(i64) #1

declare i64 @copy_in_user(i8*, i8*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_list(%struct.snd_card* %card, %struct.snd_ctl_elem_list* %_list) #0 {
entry:
  %list = alloca %struct.snd_ctl_elem_list, align 8
  %0 = bitcast %struct.snd_ctl_elem_list* %list to i8*
  call void @llvm.lifetime.start.p0i8(i64 80, i8* %0) #9
  %1 = bitcast %struct.snd_ctl_elem_list* %list to i8*
  %2 = bitcast %struct.snd_ctl_elem_list* %_list to i8*
  %call = call i64 @copy_from_user.79(i8* %1, i8* %2, i64 80)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %offset1 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 0
  %3 = load i32, i32* %offset1, align 8, !tbaa !247
  %space2 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 1
  %4 = load i32, i32* %space2, align 4, !tbaa !249
  %cmp = icmp ugt i32 %4, 16384
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %cmp5 = icmp ugt i32 %4, 0
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end4
  %conv = zext i32 %4 to i64
  %mul = mul i64 %conv, 64
  %call7 = call i8* @vmalloc(i64 %mul)
  %5 = bitcast i8* %call7 to %struct.snd_ctl_elem_id*
  %cmp8 = icmp eq %struct.snd_ctl_elem_id* %5, null
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.then6
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %controls_count = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  %6 = load i32, i32* %controls_count, align 8, !tbaa !184
  %count = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 3
  store i32 %6, i32* %count, align 4, !tbaa !250
  %controls = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  br label %while.cond

while.cond:                                       ; preds = %if.end23, %if.end11
  %.sink = phi %struct.list_head* [ %7, %if.end23 ], [ %controls, %if.end11 ]
  %offset.0 = phi i32 [ %3, %if.end11 ], [ %sub, %if.end23 ]
  %next25 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next25, align 8, !tbaa !2
  %controls12 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %cmp13 = icmp eq %struct.list_head* %7, %controls12
  %cmp15 = icmp eq i32 %offset.0, 0
  %or.cond = or i1 %cmp13, %cmp15
  br i1 %or.cond, label %while.end, label %if.end18

if.end18:                                         ; preds = %while.cond
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr to %struct.snd_kcontrol*
  %count19 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %9, i32 0, i32 2
  %10 = load i32, i32* %count19, align 8, !tbaa !173
  %cmp20 = icmp ult i32 %offset.0, %10
  br i1 %cmp20, label %while.end, label %if.end23

if.end23:                                         ; preds = %if.end18
  %count24 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %9, i32 0, i32 2
  %11 = load i32, i32* %count24, align 8, !tbaa !173
  %sub = sub i32 %offset.0, %11
  br label %while.cond

while.end:                                        ; preds = %if.end18, %while.cond
  %used = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 2
  store i32 0, i32* %used, align 8, !tbaa !251
  br label %while.cond26

while.cond26:                                     ; preds = %for.end, %while.end
  %offset.1 = phi i32 [ %offset.0, %while.end ], [ 0, %for.end ]
  %id.0 = phi %struct.snd_ctl_elem_id* [ %5, %while.end ], [ %id.1, %for.end ]
  %space.0 = phi i32 [ %4, %while.end ], [ %space.1, %for.end ]
  %plist.1 = phi %struct.list_head* [ %7, %while.end ], [ %17, %for.end ]
  %cmp27 = icmp ugt i32 %space.0, 0
  %controls29 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %cmp30 = icmp ne %struct.list_head* %plist.1, %controls29
  %12 = select i1 %cmp27, i1 %cmp30, i1 false
  br i1 %12, label %while.body32, label %while.end47

while.body32:                                     ; preds = %while.cond26
  %13 = bitcast %struct.list_head* %plist.1 to i8*
  %add.ptr35 = getelementptr inbounds i8, i8* %13, i64 0
  %14 = bitcast i8* %add.ptr35 to %struct.snd_kcontrol*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %while.body32
  %id.1 = phi %struct.snd_ctl_elem_id* [ %id.0, %while.body32 ], [ %incdec.ptr, %for.body ]
  %space.1 = phi i32 [ %space.0, %while.body32 ], [ %dec, %for.body ]
  %jidx.0 = phi i32 [ %offset.1, %while.body32 ], [ %inc45, %for.body ]
  %cmp36 = icmp ugt i32 %space.1, 0
  br i1 %cmp36, label %land.rhs38, label %for.end

land.rhs38:                                       ; preds = %for.cond
  %count39 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %14, i32 0, i32 2
  %15 = load i32, i32* %count39, align 8, !tbaa !173
  %cmp40 = icmp ult i32 %jidx.0, %15
  br i1 %cmp40, label %for.body, label %for.end

for.body:                                         ; preds = %land.rhs38
  call void @snd_ctl_build_ioff(%struct.snd_ctl_elem_id* %id.1, %struct.snd_kcontrol* %14, i32 %jidx.0)
  %incdec.ptr = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id.1, i32 1
  %dec = add i32 %space.1, -1
  %used44 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 2
  %16 = load i32, i32* %used44, align 8, !tbaa !251
  %inc = add i32 %16, 1
  store i32 %inc, i32* %used44, align 8, !tbaa !251
  %inc45 = add i32 %jidx.0, 1
  br label %for.cond

for.end:                                          ; preds = %land.rhs38, %for.cond
  %next46 = getelementptr inbounds %struct.list_head, %struct.list_head* %plist.1, i32 0, i32 0
  %17 = load %struct.list_head*, %struct.list_head** %next46, align 8, !tbaa !116
  br label %while.cond26

while.end47:                                      ; preds = %while.cond26
  %controls_rwsem48 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem48)
  %used49 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 2
  %18 = load i32, i32* %used49, align 8, !tbaa !251
  %cmp50 = icmp ugt i32 %18, 0
  br i1 %cmp50, label %land.lhs.true, label %if.end58

land.lhs.true:                                    ; preds = %while.end47
  %pids = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 4
  %19 = load %struct.snd_ctl_elem_id*, %struct.snd_ctl_elem_id** %pids, align 8, !tbaa !252
  %20 = bitcast %struct.snd_ctl_elem_id* %19 to i8*
  %21 = bitcast %struct.snd_ctl_elem_id* %5 to i8*
  %used52 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 2
  %22 = load i32, i32* %used52, align 8, !tbaa !251
  %conv53 = zext i32 %22 to i64
  %mul54 = mul i64 %conv53, 64
  %call55 = call i64 @copy_to_user.74(i8* %20, i8* %21, i64 %mul54)
  %tobool56 = icmp ne i64 %call55, 0
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %land.lhs.true
  %23 = bitcast %struct.snd_ctl_elem_id* %5 to i8*
  call void @vfree(i8* %23)
  br label %cleanup

if.end58:                                         ; preds = %land.lhs.true, %while.end47
  %24 = bitcast %struct.snd_ctl_elem_id* %5 to i8*
  call void @vfree(i8* %24)
  br label %if.end63

if.else:                                          ; preds = %if.end4
  %controls_rwsem59 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @down_read(%struct.rw_semaphore* %controls_rwsem59)
  %controls_count60 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 16
  %25 = load i32, i32* %controls_count60, align 8, !tbaa !184
  %count61 = getelementptr inbounds %struct.snd_ctl_elem_list, %struct.snd_ctl_elem_list* %list, i32 0, i32 3
  store i32 %25, i32* %count61, align 4, !tbaa !250
  %controls_rwsem62 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem62)
  br label %if.end63

if.end63:                                         ; preds = %if.else, %if.end58
  %26 = bitcast %struct.snd_ctl_elem_list* %_list to i8*
  %27 = bitcast %struct.snd_ctl_elem_list* %list to i8*
  %call64 = call i64 @copy_to_user.74(i8* %26, i8* %27, i64 80)
  %tobool65 = icmp ne i64 %call64, 0
  %. = select i1 %tobool65, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end63, %if.then57, %if.then6, %if.end, %entry
  %retval.0 = phi i32 [ -14, %if.then57 ], [ -14, %entry ], [ -12, %if.end ], [ -12, %if.then6 ], [ %., %if.end63 ]
  %28 = bitcast %struct.snd_ctl_elem_list* %list to i8*
  call void @llvm.lifetime.end.p0i8(i64 80, i8* %28) #9
  ret i32 %retval.0
}

declare i8* @vmalloc(i64) #1

declare void @vfree(i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_card_info(%struct.snd_card* %card, i8* %arg) #0 {
entry:
  %call = call i8* @kzalloc.56(i64 376, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_ctl_card_info*
  %tobool = icmp ne %struct.snd_ctl_card_info* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  call void @down_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number, align 8, !tbaa !10
  %card1 = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 0
  store i32 %1, i32* %card1, align 4, !tbaa !253
  %id = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 2
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %id2 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay3 = getelementptr inbounds [16 x i8], [16 x i8]* %id2, i32 0, i32 0
  %call4 = call i64 @strlcpy(i8* %arraydecay, i8* %arraydecay3, i64 16)
  %driver = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 3
  %arraydecay5 = getelementptr inbounds [16 x i8], [16 x i8]* %driver, i32 0, i32 0
  %driver6 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [16 x i8], [16 x i8]* %driver6, i32 0, i32 0
  %call8 = call i64 @strlcpy(i8* %arraydecay5, i8* %arraydecay7, i64 16)
  %name = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 4
  %arraydecay9 = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 3
  %arraydecay10 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  %call11 = call i64 @strlcpy(i8* %arraydecay9, i8* %arraydecay10, i64 32)
  %longname = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 5
  %arraydecay12 = getelementptr inbounds [80 x i8], [80 x i8]* %longname, i32 0, i32 0
  %longname13 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 4
  %arraydecay14 = getelementptr inbounds [80 x i8], [80 x i8]* %longname13, i32 0, i32 0
  %call15 = call i64 @strlcpy(i8* %arraydecay12, i8* %arraydecay14, i64 80)
  %mixername = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 7
  %arraydecay16 = getelementptr inbounds [80 x i8], [80 x i8]* %mixername, i32 0, i32 0
  %mixername17 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 6
  %arraydecay18 = getelementptr inbounds [80 x i8], [80 x i8]* %mixername17, i32 0, i32 0
  %call19 = call i64 @strlcpy(i8* %arraydecay16, i8* %arraydecay18, i64 80)
  %components = getelementptr inbounds %struct.snd_ctl_card_info, %struct.snd_ctl_card_info* %0, i32 0, i32 8
  %arraydecay20 = getelementptr inbounds [128 x i8], [128 x i8]* %components, i32 0, i32 0
  %components21 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 7
  %arraydecay22 = getelementptr inbounds [128 x i8], [128 x i8]* %components21, i32 0, i32 0
  %call23 = call i64 @strlcpy(i8* %arraydecay20, i8* %arraydecay22, i64 128)
  call void @up_read(%struct.rw_semaphore* @snd_ioctl_rwsem)
  %2 = bitcast %struct.snd_ctl_card_info* %0 to i8*
  %call24 = call i64 @copy_to_user.74(i8* %arg, i8* %2, i64 376)
  %tobool25 = icmp ne i64 %call24, 0
  %3 = bitcast %struct.snd_ctl_card_info* %0 to i8*
  call void @kfree(i8* %3)
  %. = select i1 %tobool25, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_info_user(%struct.snd_ctl_file* %ctl, %struct.snd_ctl_elem_info* %_info) #0 {
entry:
  %info = alloca %struct.snd_ctl_elem_info, align 8
  %0 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @llvm.lifetime.start.p0i8(i64 272, i8* %0) #9
  %1 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  %2 = bitcast %struct.snd_ctl_elem_info* %_info to i8*
  %call = call i64 @copy_from_user.79(i8* %1, i8* %2, i64 272)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %card = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %3 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !208
  call void @snd_power_lock.72(%struct.snd_card* %3)
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %4 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !208
  %call2 = call i32 @snd_power_wait(%struct.snd_card* %4, i32 0)
  %cmp = icmp sge i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call i32 @snd_ctl_elem_info(%struct.snd_ctl_file* %ctl, %struct.snd_ctl_elem_info* %info)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %result.0 = phi i32 [ %call4, %if.then3 ], [ %call2, %if.end ]
  %card6 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %ctl, i32 0, i32 1
  %5 = load %struct.snd_card*, %struct.snd_card** %card6, align 8, !tbaa !208
  call void @snd_power_unlock.73(%struct.snd_card* %5)
  %cmp7 = icmp sge i32 %result.0, 0
  br i1 %cmp7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end5
  %6 = bitcast %struct.snd_ctl_elem_info* %_info to i8*
  %7 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  %call9 = call i64 @copy_to_user.74(i8* %6, i8* %7, i64 272)
  %tobool10 = icmp ne i64 %call9, 0
  br i1 %tobool10, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.then8, %if.end5
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %if.then8, %entry
  %retval.0 = phi i32 [ %result.0, %if.end13 ], [ -14, %entry ], [ -14, %if.then8 ]
  %8 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @llvm.lifetime.end.p0i8(i64 272, i8* %8) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_read_user(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %_control) #0 {
entry:
  %0 = bitcast %struct.snd_ctl_elem_value* %_control to i8*
  %call = call i8* @memdup_user(i8* %0, i64 1224)
  %1 = bitcast i8* %call to %struct.snd_ctl_elem_value*
  %2 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  %call1 = call zeroext i1 @IS_ERR(i8* %2)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  %call2 = call i64 @PTR_ERR(i8* %3)
  %conv = trunc i64 %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @snd_power_lock.72(%struct.snd_card* %card)
  %call3 = call i32 @snd_power_wait(%struct.snd_card* %card, i32 0)
  %cmp = icmp sge i32 %call3, 0
  br i1 %cmp, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 @snd_ctl_elem_read(%struct.snd_card* %card, %struct.snd_ctl_elem_value* %1)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %result.0 = phi i32 [ %call6, %if.then5 ], [ %call3, %if.end ]
  call void @snd_power_unlock.73(%struct.snd_card* %card)
  %cmp8 = icmp sge i32 %result.0, 0
  br i1 %cmp8, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end7
  %4 = bitcast %struct.snd_ctl_elem_value* %_control to i8*
  %5 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  %call11 = call i64 @copy_to_user.74(i8* %4, i8* %5, i64 1224)
  %tobool = icmp ne i64 %call11, 0
  %.result.0 = select i1 %tobool, i32 -14, i32 %result.0
  br label %if.end14

if.end14:                                         ; preds = %if.then10, %if.end7
  %result.2 = phi i32 [ %.result.0, %if.then10 ], [ %result.0, %if.end7 ]
  %6 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %result.2, %if.end14 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_write_user(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value* %_control) #0 {
entry:
  %0 = bitcast %struct.snd_ctl_elem_value* %_control to i8*
  %call = call i8* @memdup_user(i8* %0, i64 1224)
  %1 = bitcast i8* %call to %struct.snd_ctl_elem_value*
  %2 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  %call1 = call zeroext i1 @IS_ERR(i8* %2)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  %call2 = call i64 @PTR_ERR(i8* %3)
  %conv = trunc i64 %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  %card3 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %4 = load %struct.snd_card*, %struct.snd_card** %card3, align 8, !tbaa !208
  call void @snd_power_lock.72(%struct.snd_card* %4)
  %call4 = call i32 @snd_power_wait(%struct.snd_card* %4, i32 0)
  %cmp = icmp sge i32 %call4, 0
  br i1 %cmp, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %call7 = call i32 @snd_ctl_elem_write(%struct.snd_card* %4, %struct.snd_ctl_file* %file, %struct.snd_ctl_elem_value* %1)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %result.0 = phi i32 [ %call7, %if.then6 ], [ %call4, %if.end ]
  call void @snd_power_unlock.73(%struct.snd_card* %4)
  %cmp9 = icmp sge i32 %result.0, 0
  br i1 %cmp9, label %if.then11, label %if.end15

if.then11:                                        ; preds = %if.end8
  %5 = bitcast %struct.snd_ctl_elem_value* %_control to i8*
  %6 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  %call12 = call i64 @copy_to_user.74(i8* %5, i8* %6, i64 1224)
  %tobool = icmp ne i64 %call12, 0
  %.result.0 = select i1 %tobool, i32 -14, i32 %result.0
  br label %if.end15

if.end15:                                         ; preds = %if.then11, %if.end8
  %result.2 = phi i32 [ %.result.0, %if.then11 ], [ %result.0, %if.end8 ]
  %7 = bitcast %struct.snd_ctl_elem_value* %1 to i8*
  call void @kfree(i8* %7)
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %result.2, %if.end15 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_lock(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %_id) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !208
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %1) #9
  %2 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %3 = bitcast %struct.snd_ctl_elem_id* %_id to i8*
  %call = call i64 @copy_from_user.79(i8* %2, i8* %3, i64 64)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call2 = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %0, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call2, null
  br i1 %cmp, label %if.end11, label %if.else

if.else:                                          ; preds = %if.end
  %vd4 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call2, i32 0, i32 10
  %call5 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call2, %struct.snd_ctl_elem_id* %id)
  %idxprom = zext i32 %call5 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd4, i64 0, i64 %idxprom
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %4 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !203
  %cmp6 = icmp ne %struct.snd_ctl_file* %4, null
  br i1 %cmp6, label %if.end11, label %if.else8

if.else8:                                         ; preds = %if.else
  %owner9 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  store %struct.snd_ctl_file* %file, %struct.snd_ctl_file** %owner9, align 8, !tbaa !203
  br label %if.end11

if.end11:                                         ; preds = %if.else8, %if.else, %if.end
  %result.1 = phi i32 [ -2, %if.end ], [ 0, %if.else8 ], [ -16, %if.else ]
  %controls_rwsem12 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem12)
  br label %cleanup

cleanup:                                          ; preds = %if.end11, %entry
  %retval.0 = phi i32 [ %result.1, %if.end11 ], [ -14, %entry ]
  %5 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %5) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_unlock(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %_id) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !208
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %1) #9
  %2 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %3 = bitcast %struct.snd_ctl_elem_id* %_id to i8*
  %call = call i64 @copy_from_user.79(i8* %2, i8* %3, i64 64)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @down_write(%struct.rw_semaphore* %controls_rwsem)
  %call2 = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %0, %struct.snd_ctl_elem_id* %id)
  %cmp = icmp eq %struct.snd_kcontrol* %call2, null
  br i1 %cmp, label %if.end16, label %if.else

if.else:                                          ; preds = %if.end
  %vd4 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call2, i32 0, i32 10
  %call5 = call i32 @snd_ctl_get_ioff(%struct.snd_kcontrol* %call2, %struct.snd_ctl_elem_id* %id)
  %idxprom = zext i32 %call5 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd4, i64 0, i64 %idxprom
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %4 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !203
  %cmp6 = icmp eq %struct.snd_ctl_file* %4, null
  br i1 %cmp6, label %if.end16, label %if.else8

if.else8:                                         ; preds = %if.else
  %owner9 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %5 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner9, align 8, !tbaa !203
  %cmp10 = icmp ne %struct.snd_ctl_file* %5, %file
  br i1 %cmp10, label %if.end16, label %if.else12

if.else12:                                        ; preds = %if.else8
  %owner13 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  store %struct.snd_ctl_file* null, %struct.snd_ctl_file** %owner13, align 8, !tbaa !203
  br label %if.end16

if.end16:                                         ; preds = %if.else12, %if.else8, %if.else, %if.end
  %result.2 = phi i32 [ -2, %if.end ], [ -22, %if.else ], [ 0, %if.else12 ], [ -1, %if.else8 ]
  %controls_rwsem17 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @up_write(%struct.rw_semaphore* %controls_rwsem17)
  br label %cleanup

cleanup:                                          ; preds = %if.end16, %entry
  %retval.0 = phi i32 [ %result.2, %if.end16 ], [ -14, %entry ]
  %6 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %6) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_add_user(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_info* %_info, i32 %replace) #0 {
entry:
  %info = alloca %struct.snd_ctl_elem_info, align 8
  %0 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @llvm.lifetime.start.p0i8(i64 272, i8* %0) #9
  %1 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  %2 = bitcast %struct.snd_ctl_elem_info* %_info to i8*
  %call = call i64 @copy_from_user.79(i8* %1, i8* %2, i64 272)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @snd_ctl_elem_add(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_info* %info, i32 %replace)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = bitcast %struct.snd_ctl_elem_info* %_info to i8*
  %4 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  %call4 = call i64 @copy_to_user.74(i8* %3, i8* %4, i64 272)
  %tobool5 = icmp ne i64 %call4, 0
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %if.end3
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %info, i32 0, i32 0
  %call7 = call i32 @snd_ctl_remove_user_ctl(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %id)
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %if.end3, %if.end, %entry
  %retval.0 = phi i32 [ -14, %if.then6 ], [ -14, %entry ], [ %call1, %if.end ], [ 0, %if.end3 ]
  %5 = bitcast %struct.snd_ctl_elem_info* %info to i8*
  call void @llvm.lifetime.end.p0i8(i64 272, i8* %5) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_elem_remove(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %_id) #0 {
entry:
  %id = alloca %struct.snd_ctl_elem_id, align 4
  %0 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #9
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %2 = bitcast %struct.snd_ctl_elem_id* %_id to i8*
  %call = call i64 @copy_from_user.79(i8* %1, i8* %2, i64 64)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @snd_ctl_remove_user_ctl(%struct.snd_ctl_file* %file, %struct.snd_ctl_elem_id* %id)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  %3 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %3) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_subscribe_events(%struct.snd_ctl_file* %file, i32* %ptr) #0 {
entry:
  call void @__might_fault(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1410)
  %0 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %ptr, i64 4, i8* undef) #9, !srcloc !255
  %asmresult = extractvalue { i32*, i64, i8* } %0, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %0, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %0, 2
  %1 = ptrtoint i32* %asmresult to i64
  %2 = trunc i64 %1 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %2 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp = icmp slt i32 %conv, 0
  br i1 %cmp, label %if.then5, label %if.end12

if.then5:                                         ; preds = %if.end
  %subscribed = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 7
  %3 = load i32, i32* %subscribed, align 8, !tbaa !180
  call void @__might_fault(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.46, i32 0, i32 0), i32 1414)
  %4 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %3, i32* %ptr) #9, !srcloc !256
  %conv7 = sext i32 %4 to i64
  %expval8 = call i64 @llvm.expect.i64(i64 %conv7, i64 0)
  %tobool9 = icmp ne i64 %expval8, 0
  %. = select i1 %tobool9, i32 -14, i32 0
  br label %cleanup

if.end12:                                         ; preds = %if.end
  %tobool13 = icmp ne i32 %conv, 0
  %subscribed15 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 7
  br i1 %tobool13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end12
  store i32 1, i32* %subscribed15, align 8, !tbaa !180
  br label %cleanup

if.else:                                          ; preds = %if.end12
  %5 = load i32, i32* %subscribed15, align 8, !tbaa !180
  %tobool17 = icmp ne i32 %5, 0
  br i1 %tobool17, label %if.then18, label %cleanup

if.then18:                                        ; preds = %if.else
  call void @snd_ctl_empty_read_queue(%struct.snd_ctl_file* %file)
  %subscribed19 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 7
  store i32 0, i32* %subscribed19, align 8, !tbaa !180
  br label %cleanup

cleanup:                                          ; preds = %if.then18, %if.else, %if.then14, %if.then5, %entry
  %retval.0 = phi i32 [ 0, %if.then14 ], [ -14, %entry ], [ %., %if.then5 ], [ 0, %if.else ], [ 0, %if.then18 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_ctl_tlv_ioctl(%struct.snd_ctl_file* %file, %struct.snd_ctl_tlv* %_tlv, i32 %op_flag) #0 {
entry:
  %tlv = alloca %struct.snd_ctl_tlv, align 4
  %id62 = alloca %struct.snd_ctl_elem_id, align 4
  %card1 = getelementptr inbounds %struct.snd_ctl_file, %struct.snd_ctl_file* %file, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !208
  %1 = bitcast %struct.snd_ctl_tlv* %tlv to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #9
  %2 = bitcast %struct.snd_ctl_tlv* %tlv to i8*
  %3 = bitcast %struct.snd_ctl_tlv* %_tlv to i8*
  %call = call i64 @copy_from_user.79(i8* %2, i8* %3, i64 8)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %length = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 1
  %4 = load i32, i32* %length, align 4, !tbaa !257
  %conv = zext i32 %4 to i64
  %cmp = icmp ult i64 %conv, 8
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %numid = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 0
  %5 = load i32, i32* %numid, align 4, !tbaa !259
  %tobool5 = icmp ne i32 %5, 0
  br i1 %tobool5, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.end4
  %controls_rwsem = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @down_read(%struct.rw_semaphore* %controls_rwsem)
  %numid8 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 0
  %6 = load i32, i32* %numid8, align 4, !tbaa !259
  %call9 = call %struct.snd_kcontrol* @snd_ctl_find_numid(%struct.snd_card* %0, i32 %6)
  %cmp10 = icmp eq %struct.snd_kcontrol* %call9, null
  br i1 %cmp10, label %__kctl_end, label %if.end13

if.end13:                                         ; preds = %if.end7
  %tlv14 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call9, i32 0, i32 6
  %p = bitcast %union.anon.69* %tlv14 to i32**
  %7 = load i32*, i32** %p, align 8, !tbaa !49
  %cmp15 = icmp eq i32* %7, null
  br i1 %cmp15, label %__kctl_end, label %if.end18

if.end18:                                         ; preds = %if.end13
  %vd19 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call9, i32 0, i32 10
  %numid20 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 0
  %8 = load i32, i32* %numid20, align 4, !tbaa !259
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call9, i32 0, i32 1
  %numid21 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 0
  %9 = load i32, i32* %numid21, align 8, !tbaa !174
  %sub = sub i32 %8, %9
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd19, i64 0, i64 %idxprom
  switch i32 %op_flag, label %if.end42 [
    i32 0, label %land.lhs.true
    i32 1, label %land.lhs.true28
    i32 -1, label %land.lhs.true36
  ]

land.lhs.true:                                    ; preds = %if.end18
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %10 = load i32, i32* %access, align 8, !tbaa !177
  %and = and i32 %10, 16
  %cmp24 = icmp eq i32 %and, 0
  br i1 %cmp24, label %__kctl_end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  switch i32 %op_flag, label %if.end42 [
    i32 1, label %land.lhs.true28
    i32 -1, label %land.lhs.true36
  ]

land.lhs.true28:                                  ; preds = %lor.lhs.false, %if.end18
  %access29 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %11 = load i32, i32* %access29, align 8, !tbaa !177
  %and30 = and i32 %11, 32
  %cmp31 = icmp eq i32 %and30, 0
  br i1 %cmp31, label %__kctl_end, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %land.lhs.true28
  %cmp34 = icmp eq i32 %op_flag, -1
  br i1 %cmp34, label %land.lhs.true36, label %if.end42

land.lhs.true36:                                  ; preds = %lor.lhs.false33, %lor.lhs.false, %if.end18
  %access37 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %12 = load i32, i32* %access37, align 8, !tbaa !177
  %and38 = and i32 %12, 64
  %cmp39 = icmp eq i32 %and38, 0
  br i1 %cmp39, label %__kctl_end, label %if.end42

if.end42:                                         ; preds = %land.lhs.true36, %lor.lhs.false33, %lor.lhs.false, %if.end18
  %access43 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %13 = load i32, i32* %access43, align 8, !tbaa !177
  %and44 = and i32 %13, 268435456
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %if.then46, label %if.else

if.then46:                                        ; preds = %if.end42
  %owner = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %14 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner, align 8, !tbaa !203
  %cmp47 = icmp ne %struct.snd_ctl_file* %14, null
  br i1 %cmp47, label %land.lhs.true49, label %if.end54

land.lhs.true49:                                  ; preds = %if.then46
  %owner50 = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 0
  %15 = load %struct.snd_ctl_file*, %struct.snd_ctl_file** %owner50, align 8, !tbaa !203
  %cmp51 = icmp ne %struct.snd_ctl_file* %15, %file
  br i1 %cmp51, label %__kctl_end, label %if.end54

if.end54:                                         ; preds = %land.lhs.true49, %if.then46
  %tlv55 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call9, i32 0, i32 6
  %c = bitcast %union.anon.69* %tlv55 to i32 (%struct.snd_kcontrol*, i32, i32, i32*)**
  %16 = load i32 (%struct.snd_kcontrol*, i32, i32, i32*)*, i32 (%struct.snd_kcontrol*, i32, i32, i32*)** %c, align 8, !tbaa !49
  %length56 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 1
  %17 = load i32, i32* %length56, align 4, !tbaa !257
  %tlv57 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %_tlv, i32 0, i32 2
  %arraydecay = getelementptr inbounds [0 x i32], [0 x i32]* %tlv57, i32 0, i32 0
  %call58 = call i32 %16(%struct.snd_kcontrol* %call9, i32 %op_flag, i32 %17, i32* %arraydecay)
  %cmp59 = icmp sgt i32 %call58, 0
  br i1 %cmp59, label %if.then61, label %__kctl_end

if.then61:                                        ; preds = %if.end54
  %18 = bitcast %struct.snd_ctl_elem_id* %id62 to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %18) #9
  %id63 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call9, i32 0, i32 1
  %19 = bitcast %struct.snd_ctl_elem_id* %id62 to i8*
  %20 = bitcast %struct.snd_ctl_elem_id* %id63 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* %20, i64 64, i32 4, i1 false), !tbaa.struct !175
  %controls_rwsem64 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem64)
  call void @snd_ctl_notify(%struct.snd_card* %0, i32 8, %struct.snd_ctl_elem_id* %id62)
  %21 = bitcast %struct.snd_ctl_elem_id* %id62 to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %21) #9
  br label %cleanup

if.else:                                          ; preds = %if.end42
  %cmp66 = icmp ne i32 %op_flag, 0
  br i1 %cmp66, label %__kctl_end, label %if.end69

if.end69:                                         ; preds = %if.else
  %tlv70 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call9, i32 0, i32 6
  %p71 = bitcast %union.anon.69* %tlv70 to i32**
  %22 = load i32*, i32** %p71, align 8, !tbaa !49
  %arrayidx72 = getelementptr inbounds i32, i32* %22, i64 1
  %23 = load i32, i32* %arrayidx72, align 4, !tbaa !47
  %conv73 = zext i32 %23 to i64
  %add = add i64 %conv73, 8
  %conv74 = trunc i64 %add to i32
  %length75 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %tlv, i32 0, i32 1
  %24 = load i32, i32* %length75, align 4, !tbaa !257
  %cmp76 = icmp ult i32 %24, %conv74
  br i1 %cmp76, label %__kctl_end, label %if.end79

if.end79:                                         ; preds = %if.end69
  %tlv80 = getelementptr inbounds %struct.snd_ctl_tlv, %struct.snd_ctl_tlv* %_tlv, i32 0, i32 2
  %arraydecay81 = getelementptr inbounds [0 x i32], [0 x i32]* %tlv80, i32 0, i32 0
  %25 = bitcast i32* %arraydecay81 to i8*
  %tlv82 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call9, i32 0, i32 6
  %p83 = bitcast %union.anon.69* %tlv82 to i32**
  %26 = load i32*, i32** %p83, align 8, !tbaa !49
  %27 = bitcast i32* %26 to i8*
  %conv84 = zext i32 %conv74 to i64
  %call85 = call i64 @copy_to_user.74(i8* %25, i8* %27, i64 %conv84)
  %tobool86 = icmp ne i64 %call85, 0
  %. = select i1 %tobool86, i32 -14, i32 0
  br label %__kctl_end

__kctl_end:                                       ; preds = %if.end79, %if.end69, %if.else, %if.end54, %land.lhs.true49, %land.lhs.true36, %land.lhs.true28, %land.lhs.true, %if.end13, %if.end7
  %err.2 = phi i32 [ -2, %if.end7 ], [ -6, %if.end13 ], [ -6, %land.lhs.true36 ], [ -6, %land.lhs.true28 ], [ -6, %land.lhs.true ], [ -1, %land.lhs.true49 ], [ -6, %if.else ], [ -12, %if.end69 ], [ %., %if.end79 ], [ %call58, %if.end54 ]
  %controls_rwsem90 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %0, i32 0, i32 14
  call void @up_read(%struct.rw_semaphore* %controls_rwsem90)
  br label %cleanup

cleanup:                                          ; preds = %__kctl_end, %if.then61, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %err.2, %__kctl_end ], [ 0, %if.then61 ], [ -14, %entry ], [ -22, %if.end ], [ -22, %if.end4 ]
  %28 = bitcast %struct.snd_ctl_tlv* %tlv to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #9
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #5 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !260
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !260
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_lock_irq(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_waitqueue_entry.83(%struct.__wait_queue* %q, %struct.task_struct* %p) #5 {
entry:
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !108
  %0 = bitcast %struct.task_struct* %p to i8*
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 1
  store i8* %0, i8** %private, align 8, !tbaa !110
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %q, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !111
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock_irq(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @schedule() #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #5 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #5 {
entry:
  %call = call %union.anon.3* @task_thread_info(%struct.task_struct* %tsk)
  %call1 = call i32 @test_ti_thread_flag(%union.anon.3* %call, i32 %flag)
  ret i32 %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal %union.anon.3* @task_thread_info(%struct.task_struct* %task) #5 {
entry:
  %thread_info = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i32 0, i32 0
  ret %union.anon.3* %thread_info
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%union.anon.3* %ti, i32 %flag) #5 {
entry:
  %conv = sext i32 %flag to i64
  %flags = getelementptr inbounds %union.anon.3, %union.anon.3* %ti, i32 0, i32 0
  %call = call zeroext i1 @variable_test_bit.84(i64 %conv, i64* %flags)
  %conv1 = zext i1 %call to i32
  ret i32 %conv1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @variable_test_bit.84(i64 %nr, i64* %addr) #3 {
entry:
  %oldbit = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %oldbit) #9
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit, i64* %addr, i64 %nr) #9, !srcloc !262
  %0 = load i8, i8* %oldbit, align 1, !tbaa !142, !range !123
  %tobool = trunc i8 %0 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %oldbit) #9
  ret i1 %tobool
}

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev* %pci, %struct.snd_pci_quirk* %list) #0 {
entry:
  %tobool = icmp ne %struct.pci_dev* %pci, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %subsystem_vendor = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 9
  %0 = load i16, i16* %subsystem_vendor, align 8, !tbaa !263
  %subsystem_device = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 10
  %1 = load i16, i16* %subsystem_device, align 2, !tbaa !266
  %call = call %struct.snd_pci_quirk* @snd_pci_quirk_lookup_id(i16 zeroext %0, i16 zeroext %1, %struct.snd_pci_quirk* %list)
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi %struct.snd_pci_quirk* [ %call, %if.end ], [ null, %entry ]
  ret %struct.snd_pci_quirk* %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.snd_pci_quirk* @snd_pci_quirk_lookup_id(i16 zeroext %vendor, i16 zeroext %device, %struct.snd_pci_quirk* %list) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %q.0 = phi %struct.snd_pci_quirk* [ %list, %entry ], [ %incdec.ptr, %for.inc ]
  %subvendor = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 0, i32 0
  %0 = load i16, i16* %subvendor, align 8, !tbaa !267
  %tobool = icmp ne i16 %0, 0
  br i1 %tobool, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %subvendor1 = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 0, i32 0
  %1 = load i16, i16* %subvendor1, align 8, !tbaa !267
  %conv = zext i16 %1 to i32
  %conv2 = zext i16 %vendor to i32
  %cmp = icmp ne i32 %conv, %conv2
  br i1 %cmp, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %subdevice = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 0, i32 1
  %2 = load i16, i16* %subdevice, align 2, !tbaa !269
  %tobool4 = icmp ne i16 %2, 0
  br i1 %tobool4, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %conv5 = zext i16 %device to i32
  %subdevice_mask = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 0, i32 2
  %3 = load i16, i16* %subdevice_mask, align 4, !tbaa !270
  %conv6 = zext i16 %3 to i32
  %and = and i32 %conv5, %conv6
  %subdevice7 = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 0, i32 1
  %4 = load i16, i16* %subdevice7, align 2, !tbaa !269
  %conv8 = zext i16 %4 to i32
  %cmp9 = icmp eq i32 %and, %conv8
  br i1 %cmp9, label %cleanup, label %for.inc

for.inc:                                          ; preds = %lor.lhs.false, %for.body
  %incdec.ptr = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %q.0, i32 1
  br label %for.cond

cleanup:                                          ; preds = %lor.lhs.false, %if.end, %for.cond
  %retval.0 = phi %struct.snd_pci_quirk* [ %q.0, %lor.lhs.false ], [ %q.0, %if.end ], [ null, %for.cond ]
  ret %struct.snd_pci_quirk* %retval.0
}

; Function Attrs: nounwind uwtable
define void @__snd_printk(i32 %level, i8* %path, i32 %line, i8* %format, ...) #0 {
entry:
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %vaf = alloca %struct.va_format, align 8
  %verbose_fmt = alloca [17 x i8], align 16
  %0 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #9
  %1 = bitcast %struct.va_format* %vaf to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #9
  %2 = bitcast [17 x i8]* %verbose_fmt to i8*
  call void @llvm.lifetime.start.p0i8(i64 17, i8* %2) #9
  %3 = bitcast [17 x i8]* %verbose_fmt to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__snd_printk.verbose_fmt, i32 0, i32 0), i64 17, i32 16, i1 false)
  %4 = load i32, i32* @debug, align 4, !tbaa !47
  %cmp = icmp ult i32 %4, %level
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %fmt = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 0
  store i8* %format, i8** %fmt, align 8, !tbaa !271
  %va = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 1
  store [1 x %struct.__va_list_tag]* %args, [1 x %struct.__va_list_tag]** %va, align 8, !tbaa !273
  br label %while.cond

while.cond:                                       ; preds = %if.end13, %if.end
  %level_found.0 = phi i8 [ 0, %if.end ], [ %level_found.1, %if.end13 ]
  %fmt2 = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 0
  %5 = load i8*, i8** %fmt2, align 8, !tbaa !271
  %call = call i32 @printk_get_level(i8* %5)
  %cmp3 = icmp ne i32 %call, 0
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %fmt4 = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 0
  %6 = load i8*, i8** %fmt4, align 8, !tbaa !271
  %call5 = call i8* @printk_skip_level(i8* %6)
  %cmp6 = icmp sge i32 %call, 48
  %cmp7 = icmp sle i32 %call, 55
  %or.cond = and i1 %cmp6, %cmp7
  br i1 %or.cond, label %if.then8, label %if.end13

if.then8:                                         ; preds = %while.body
  %arraydecay9 = getelementptr inbounds [17 x i8], [17 x i8]* %verbose_fmt, i32 0, i32 0
  %fmt10 = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 0
  %7 = load i8*, i8** %fmt10, align 8, !tbaa !271
  %fmt11 = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 0
  %8 = load i8*, i8** %fmt11, align 8, !tbaa !271
  %sub.ptr.lhs.cast = ptrtoint i8* %call5 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call12 = call i8* @__memcpy(i8* %arraydecay9, i8* %7, i64 %sub.ptr.sub)
  br label %if.end13

if.end13:                                         ; preds = %if.then8, %while.body
  %level_found.1 = phi i8 [ 1, %if.then8 ], [ %level_found.0, %while.body ]
  %fmt14 = getelementptr inbounds %struct.va_format, %struct.va_format* %vaf, i32 0, i32 0
  store i8* %call5, i8** %fmt14, align 8, !tbaa !271
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %tobool = trunc i8 %level_found.0 to i1
  %tobool.not = xor i1 %tobool, true
  %tobool16 = icmp ne i32 %level, 0
  %or.cond1 = and i1 %tobool.not, %tobool16
  br i1 %or.cond1, label %if.then17, label %if.end20

if.then17:                                        ; preds = %while.end
  %arraydecay18 = getelementptr inbounds [17 x i8], [17 x i8]* %verbose_fmt, i32 0, i32 0
  %call19 = call i8* @__memcpy(i8* %arraydecay18, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.86, i32 0, i32 0), i64 2)
  br label %if.end20

if.end20:                                         ; preds = %if.then17, %while.end
  %arraydecay21 = getelementptr inbounds [17 x i8], [17 x i8]* %verbose_fmt, i32 0, i32 0
  %call22 = call i8* @sanity_file_name(i8* %path)
  %call23 = call i32 (i8*, ...) @printk(i8* %arraydecay21, i8* %call22, i32 %line, %struct.va_format* %vaf)
  %arraydecay24 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay2425 = bitcast %struct.__va_list_tag* %arraydecay24 to i8*
  call void @llvm.va_end(i8* %arraydecay2425)
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %entry
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end20 ], [ 1, %entry ]
  %9 = bitcast [17 x i8]* %verbose_fmt to i8*
  call void @llvm.lifetime.end.p0i8(i64 17, i8* %9) #9
  %10 = bitcast %struct.va_format* %vaf to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %10) #9
  %11 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %11) #9
  ret void
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #9

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @printk_get_level(i8* %buffer) #5 {
entry:
  %arrayidx = getelementptr inbounds i8, i8* %buffer, i64 0
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %return

land.lhs.true:                                    ; preds = %entry
  %arrayidx2 = getelementptr inbounds i8, i8* %buffer, i64 1
  %1 = load i8, i8* %arrayidx2, align 1, !tbaa !49
  %conv3 = sext i8 %1 to i32
  %tobool = icmp ne i32 %conv3, 0
  br i1 %tobool, label %if.then, label %return

if.then:                                          ; preds = %land.lhs.true
  %arrayidx4 = getelementptr inbounds i8, i8* %buffer, i64 1
  %2 = load i8, i8* %arrayidx4, align 1, !tbaa !49
  %conv5 = sext i8 %2 to i32
  %Pivot = icmp slt i32 %conv5, 99
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then
  %conv5.off2 = add i32 %conv5, -99
  %SwitchLeaf3 = icmp ule i32 %conv5.off2, 1
  br i1 %SwitchLeaf3, label %sw.bb6, label %return

LeafBlock:                                        ; preds = %if.then
  %conv5.off = add i32 %conv5, -48
  %SwitchLeaf = icmp ule i32 %conv5.off, 7
  br i1 %SwitchLeaf, label %sw.bb6, label %return

sw.bb6:                                           ; preds = %LeafBlock, %LeafBlock1
  %arrayidx7 = getelementptr inbounds i8, i8* %buffer, i64 1
  %3 = load i8, i8* %arrayidx7, align 1, !tbaa !49
  %conv8 = sext i8 %3 to i32
  br label %return

return:                                           ; preds = %sw.bb6, %LeafBlock, %LeafBlock1, %land.lhs.true, %entry
  %retval.0 = phi i32 [ %conv8, %sw.bb6 ], [ 0, %LeafBlock1 ], [ 0, %LeafBlock ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @printk_skip_level(i8* %buffer) #5 {
entry:
  %call = call i32 @printk_get_level(i8* %buffer)
  %tobool = icmp ne i32 %call, 0
  %add.ptr = getelementptr inbounds i8, i8* %buffer, i64 2
  %retval.0 = select i1 %tobool, i8* %add.ptr, i8* %buffer
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @sanity_file_name(i8* %path) #0 {
entry:
  %0 = load i8, i8* %path, align 1, !tbaa !49
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 47
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %call = call i8* @strrchr(i8* %path, i32 47)
  %add.ptr = getelementptr inbounds i8, i8* %call, i64 1
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval.0 = phi i8* [ %add.ptr, %if.then ], [ %path, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #9

declare i8* @strrchr(i8*, i32) #1

; Function Attrs: nounwind uwtable
define void @release_and_free_resource(%struct.resource* %res) #0 {
entry:
  %tobool = icmp ne %struct.resource* %res, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @release_resource(%struct.resource* %res)
  %0 = bitcast %struct.resource* %res to i8*
  call void @kfree(i8* %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @release_resource(%struct.resource*) #1

; Function Attrs: nounwind uwtable
define i32 @snd_device_register(%struct.snd_card* %card, i8* %device_data) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne i8* %device_data, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i32 190)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %call = call %struct.snd_device* @look_for_dev(%struct.snd_card* %card, i8* %device_data)
  %tobool20 = icmp ne %struct.snd_device* %call, null
  br i1 %tobool20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end19
  %call22 = call i32 @__snd_device_register(%struct.snd_device* %call)
  br label %cleanup

if.end23:                                         ; preds = %if.end19
  %tobool25 = icmp ne i32 1, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  %expval31 = call i64 @llvm.expect.i64(i64 %conv30, i64 0)
  %tobool32 = icmp ne i64 %expval31, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end23
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i32 195, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.4.89, i32 0, i32 0))
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.end23
  %tobool36 = icmp ne i32 1, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %expval42 = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end34, %if.then21, %if.end
  %retval.0 = phi i32 [ %call22, %if.then21 ], [ -6, %if.end34 ], [ -6, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.snd_device* @look_for_dev(%struct.snd_card* %card, i8* %device_data) #0 {
entry:
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list5.sink = phi %struct.list_head* [ %list5, %for.inc ], [ %devices, %entry ]
  %next6 = getelementptr inbounds %struct.list_head, %struct.list_head* %list5.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next6, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr8 to %struct.snd_device*
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  %devices1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %cmp = icmp ne %struct.list_head* %list, %devices1
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %device_data2 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 4
  %3 = load i8*, i8** %device_data2, align 8, !tbaa !204
  %cmp3 = icmp eq i8* %3, %device_data
  br i1 %cmp3, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %list5 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond
  %retval.0 = phi %struct.snd_device* [ %2, %for.body ], [ null, %for.cond ]
  ret %struct.snd_device* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @__snd_device_register(%struct.snd_device* %dev) #0 {
entry:
  %state = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 2
  %0 = load i32, i32* %state, align 8, !tbaa !274
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 5
  %1 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops, align 8, !tbaa !275
  %dev_register = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %1, i32 0, i32 1
  %2 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_register, align 8, !tbaa !276
  %tobool = icmp ne i32 (%struct.snd_device*)* %2, null
  br i1 %tobool, label %if.then1, label %if.end6

if.then1:                                         ; preds = %if.then
  %ops2 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 5
  %3 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops2, align 8, !tbaa !275
  %dev_register3 = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %3, i32 0, i32 1
  %4 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_register3, align 8, !tbaa !276
  %call = call i32 %4(%struct.snd_device* %dev)
  %cmp4 = icmp slt i32 %call, 0
  %. = select i1 %cmp4, i32 1, i32 0
  %SwitchLeaf = icmp eq i32 %., 1
  br i1 %SwitchLeaf, label %return, label %if.end6

if.end6:                                          ; preds = %if.then1, %if.then
  %state7 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 2
  store i32 1, i32* %state7, align 8, !tbaa !274
  br label %return

return:                                           ; preds = %if.end6, %if.then1, %entry
  %retval.1 = phi i32 [ %call, %if.then1 ], [ 0, %if.end6 ], [ 0, %entry ]
  ret i32 %retval.1
}

; Function Attrs: nounwind uwtable
define void @snd_device_free(%struct.snd_card* %card, i8* %device_data) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne i8* %device_data, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i32 149)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup.cont, label %if.end19

if.end19:                                         ; preds = %if.end
  %call = call %struct.snd_device* @look_for_dev(%struct.snd_card* %card, i8* %device_data)
  %tobool20 = icmp ne %struct.snd_device* %call, null
  br i1 %tobool20, label %if.then21, label %do.body22

if.then21:                                        ; preds = %if.end19
  call void @__snd_device_free(%struct.snd_device* %call)
  br label %cleanup.cont

do.body22:                                        ; preds = %if.end19
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @snd_device_free.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool23 = icmp ne i32 %and, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %cleanup.cont

if.then31:                                        ; preds = %do.body22
  %dev32 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %1 = load %struct.device*, %struct.device** %dev32, align 8, !tbaa !115
  %2 = call i8* @llvm.returnaddress(i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @snd_device_free.descriptor to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.3.90, i32 0, i32 0), i8* %device_data, i8* %2)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then31, %do.body22, %if.then21, %if.end
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.end ], [ 0, %do.body22 ], [ 0, %if.then31 ], [ 0, %if.then21 ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__snd_device_free(%struct.snd_device* %dev) #0 {
entry:
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 0
  call void @list_del.92(%struct.list_head* %list)
  call void @__snd_device_disconnect(%struct.snd_device* %dev)
  %ops = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 5
  %0 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops, align 8, !tbaa !275
  %dev_free = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %0, i32 0, i32 0
  %1 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_free, align 8, !tbaa !278
  %tobool = icmp ne i32 (%struct.snd_device*)* %1, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %ops1 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 5
  %2 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops1, align 8, !tbaa !275
  %dev_free2 = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %2, i32 0, i32 0
  %3 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_free2, align 8, !tbaa !278
  %call = call i32 %3(%struct.snd_device* %dev)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.then
  %card = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 1
  %4 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !279
  %dev5 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 29
  %5 = load %struct.device*, %struct.device** %dev5, align 8, !tbaa !115
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %5, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6.93, i32 0, i32 0))
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.then, %entry
  %6 = bitcast %struct.snd_device* %dev to i8*
  call void @kfree(i8* %6)
  ret void
}

; Function Attrs: nounwind readnone
declare i8* @llvm.returnaddress(i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del.92(%struct.list_head* %entry1) #5 {
entry:
  call void @__list_del_entry.95(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !116
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__snd_device_disconnect(%struct.snd_device* %dev) #0 {
entry:
  %state = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 2
  %0 = load i32, i32* %state, align 8, !tbaa !274
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 5
  %1 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops, align 8, !tbaa !275
  %dev_disconnect = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %1, i32 0, i32 2
  %2 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_disconnect, align 8, !tbaa !280
  %tobool = icmp ne i32 (%struct.snd_device*)* %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %ops1 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 5
  %3 = load %struct.snd_device_ops*, %struct.snd_device_ops** %ops1, align 8, !tbaa !275
  %dev_disconnect2 = getelementptr inbounds %struct.snd_device_ops, %struct.snd_device_ops* %3, i32 0, i32 2
  %4 = load i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)** %dev_disconnect2, align 8, !tbaa !280
  %call = call i32 %4(%struct.snd_device* %dev)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %land.lhs.true
  %card = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 1
  %5 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !279
  %dev5 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %5, i32 0, i32 29
  %6 = load %struct.device*, %struct.device** %dev5, align 8, !tbaa !115
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %6, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.5.94, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  %state6 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev, i32 0, i32 2
  store i32 2, i32* %state6, align 8, !tbaa !274
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry.95(%struct.list_head* %entry1) #5 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  call void @__list_del.96(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del.96(%struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !49
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.97(i8* %1, i8* %arraydecay, i32 8)
  %__val3 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val3, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size.97(i8* %p, i8* %res, i32 %size) #3 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !49
  store volatile i8 %0, i8* %p, align 1, !tbaa !49
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !118
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !118
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !47
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !47
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !119
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !119
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !281
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !282
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_device_disconnect(%struct.snd_card* %card, i8* %device_data) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool1 = icmp ne i8* %device_data, null
  %lnot = xor i1 %tobool1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot2 = xor i1 %0, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i32 125)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup.cont, label %if.end19

if.end19:                                         ; preds = %if.end
  %call = call %struct.snd_device* @look_for_dev(%struct.snd_card* %card, i8* %device_data)
  %tobool20 = icmp ne %struct.snd_device* %call, null
  br i1 %tobool20, label %if.then21, label %do.body22

if.then21:                                        ; preds = %if.end19
  call void @__snd_device_disconnect(%struct.snd_device* %call)
  br label %cleanup.cont

do.body22:                                        ; preds = %if.end19
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @snd_device_disconnect.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool23 = icmp ne i32 %and, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %cleanup.cont

if.then31:                                        ; preds = %do.body22
  %dev32 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 29
  %1 = load %struct.device*, %struct.device** %dev32, align 8, !tbaa !115
  %2 = call i8* @llvm.returnaddress(i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @snd_device_disconnect.descriptor to %struct._ddebug*), %struct.device* %1, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.2.98, i32 0, i32 0), i8* %device_data, i8* %2)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then31, %do.body22, %if.then21, %if.end
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.end ], [ 0, %do.body22 ], [ 0, %if.then31 ], [ 0, %if.then21 ]
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_device_new(%struct.snd_card* %card, i32 %type, i8* %device_data, %struct.snd_device_ops* %ops) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %tobool1 = icmp ne i8* %device_data, null
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %tobool2 = icmp ne %struct.snd_device_ops* %ops, null
  %lnot = xor i1 %tobool2, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot3 = xor i1 %0, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool5 = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i32 50)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool11 = icmp ne i32 %lnot.ext, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %cleanup38, label %if.end20

if.end20:                                         ; preds = %if.end
  %call = call i8* @kzalloc.101(i64 48, i32 20971712)
  %1 = bitcast i8* %call to %struct.snd_device*
  %tobool21 = icmp ne %struct.snd_device* %1, null
  br i1 %tobool21, label %if.end23, label %cleanup38

if.end23:                                         ; preds = %if.end20
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 0
  call void @INIT_LIST_HEAD.102(%struct.list_head* %list)
  %card24 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 1
  store %struct.snd_card* %card, %struct.snd_card** %card24, align 8, !tbaa !279
  %type25 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 3
  store i32 %type, i32* %type25, align 4, !tbaa !283
  %state = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 2
  store i32 0, i32* %state, align 8, !tbaa !274
  %device_data26 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 4
  store i8* %device_data, i8** %device_data26, align 8, !tbaa !204
  %ops27 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 5
  store %struct.snd_device_ops* %ops, %struct.snd_device_ops** %ops27, align 8, !tbaa !275
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end23
  %.sink = phi %struct.list_head* [ %2, %for.inc ], [ %devices, %if.end23 ]
  %prev36 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 1
  %2 = load %struct.list_head*, %struct.list_head** %prev36, align 8, !tbaa !117
  %devices28 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %cmp = icmp ne %struct.list_head* %2, %devices28
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.snd_device*
  %type31 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %4, i32 0, i32 3
  %5 = load i32, i32* %type31, align 4, !tbaa !283
  %cmp32 = icmp ule i32 %5, %type
  %. = select i1 %cmp32, i32 2, i32 0
  %SwitchLeaf = icmp eq i32 %., 2
  br i1 %SwitchLeaf, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %list37 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %1, i32 0, i32 0
  call void @list_add.103(%struct.list_head* %list37, %struct.list_head* %2)
  br label %cleanup38

cleanup38:                                        ; preds = %for.end, %if.end20, %if.end
  %retval.0 = phi i32 [ 0, %for.end ], [ -6, %if.end ], [ -12, %if.end20 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.101(i64 %size, i32 %flags) #5 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc.105(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.102(%struct.list_head* %list) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !49
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.97(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add.103(%struct.list_head* %new, %struct.list_head* %head) #5 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  call void @__list_add.104(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add.104(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !117
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !116
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !49
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.97(i8* %1, i8* %arraydecay, i32 8)
  %__val5 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val5, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc.105(i64 %size, i32 %flags) #3 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define i32 @snd_device_register_all(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i32 209)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end18
  %list27.sink = phi %struct.list_head* [ %list27, %for.inc ], [ %devices, %if.end18 ]
  %next28 = getelementptr inbounds %struct.list_head, %struct.list_head* %list27.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next28, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr30 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr30 to %struct.snd_device*
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  %devices20 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %cmp = icmp ne %struct.list_head* %list, %devices20
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %call = call i32 @__snd_device_register(%struct.snd_device* %2)
  %cmp22 = icmp slt i32 %call, 0
  br i1 %cmp22, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %list27 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond, %if.end
  %retval.0 = phi i32 [ -6, %if.end ], [ %call, %for.body ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define void @snd_device_disconnect_all(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i32 227)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup.cont, label %if.end18

if.end18:                                         ; preds = %if.end
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end18
  %list23.sink = phi %struct.list_head* [ %list23, %for.body ], [ %devices, %if.end18 ]
  %prev24 = getelementptr inbounds %struct.list_head, %struct.list_head* %list23.sink, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev24, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr26 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr26 to %struct.snd_device*
  %list = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  %devices20 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %cmp = icmp ne %struct.list_head* %list, %devices20
  br i1 %cmp, label %for.body, label %cleanup.cont

for.body:                                         ; preds = %for.cond
  call void @__snd_device_disconnect(%struct.snd_device* %2)
  %list23 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %2, i32 0, i32 0
  br label %for.cond

cleanup.cont:                                     ; preds = %for.cond, %if.end
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.end ], [ 0, %for.cond ]
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_device_free_all(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i32 241)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup.cont, label %if.end18

if.end18:                                         ; preds = %if.end
  %devices = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %devices, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.snd_device*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end18
  %.sink = phi %struct.snd_device* [ %5, %for.body ], [ %2, %if.end18 ]
  %dev.0 = phi %struct.snd_device* [ %2, %if.end18 ], [ %5, %for.body ]
  %list28 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %.sink, i32 0, i32 0
  %prev29 = getelementptr inbounds %struct.list_head, %struct.list_head* %list28, i32 0, i32 1
  %3 = load %struct.list_head*, %struct.list_head** %prev29, align 8, !tbaa !284
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr31 = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr31 to %struct.snd_device*
  %list24 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %dev.0, i32 0, i32 0
  %devices25 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 11
  %cmp = icmp ne %struct.list_head* %list24, %devices25
  br i1 %cmp, label %for.body, label %cleanup.cont

for.body:                                         ; preds = %for.cond
  call void @__snd_device_free(%struct.snd_device* %dev.0)
  br label %for.cond

cleanup.cont:                                     ; preds = %for.cond, %if.end
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.end ], [ 0, %for.cond ]
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_register(%struct.snd_info_entry* %entry1) #0 {
entry:
  %tobool = icmp ne %struct.snd_info_entry* %entry1, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.13.115, i32 0, i32 0), i32 833)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup46, label %if.end19

if.end19:                                         ; preds = %if.end
  %parent = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent, align 8, !tbaa !285
  %cmp = icmp eq %struct.snd_info_entry* %0, null
  %parent22 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %parent22.sink = select i1 %cmp, %struct.snd_info_entry** @snd_proc_root, %struct.snd_info_entry** %parent22
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent22.sink, align 8, !tbaa !2
  %p23 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %1, i32 0, i32 10
  %2 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p23, align 8, !tbaa !286
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 1
  %3 = load i16, i16* %mode, align 8, !tbaa !287
  %conv24 = zext i16 %3 to i32
  %and = and i32 %conv24, 61440
  %cmp25 = icmp eq i32 %and, 16384
  br i1 %cmp25, label %if.then27, label %if.else

if.then27:                                        ; preds = %if.end19
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 0
  %4 = load i8*, i8** %name, align 8, !tbaa !125
  %mode28 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 1
  %5 = load i16, i16* %mode28, align 8, !tbaa !287
  %call = call %struct.proc_dir_entry* @proc_mkdir_mode(i8* %4, i16 zeroext %5, %struct.proc_dir_entry* %2)
  %tobool29 = icmp ne %struct.proc_dir_entry* %call, null
  br i1 %tobool29, label %if.end44, label %if.then30

if.then30:                                        ; preds = %if.then27
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup46

if.else:                                          ; preds = %if.end19
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 3
  %6 = load i16, i16* %content, align 8, !tbaa !288
  %conv32 = zext i16 %6 to i32
  %cmp33 = icmp eq i32 %conv32, 1
  %snd_info_entry_operations.snd_info_text_entry_ops = select i1 %cmp33, %struct.file_operations* @snd_info_entry_operations, %struct.file_operations* @snd_info_text_entry_ops
  %name38 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 0
  %7 = load i8*, i8** %name38, align 8, !tbaa !125
  %mode39 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 1
  %8 = load i16, i16* %mode39, align 8, !tbaa !287
  %9 = bitcast %struct.snd_info_entry* %entry1 to i8*
  %call40 = call %struct.proc_dir_entry* @proc_create_data(i8* %7, i16 zeroext %8, %struct.proc_dir_entry* %2, %struct.file_operations* %snd_info_entry_operations.snd_info_text_entry_ops, i8* %9)
  %tobool41 = icmp ne %struct.proc_dir_entry* %call40, null
  br i1 %tobool41, label %if.end43, label %if.then42

if.then42:                                        ; preds = %if.else
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %LeafBlock

if.end43:                                         ; preds = %if.else
  %size = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 2
  %10 = load i64, i64* %size, align 8, !tbaa !289
  call void @proc_set_size(%struct.proc_dir_entry* %call40, i64 %10)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end43, %if.then42
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end43 ], [ 1, %if.then42 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end44, label %cleanup46

if.end44:                                         ; preds = %LeafBlock, %if.then27
  %p.0 = phi %struct.proc_dir_entry* [ %call, %if.then27 ], [ %call40, %LeafBlock ]
  %p45 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  store %struct.proc_dir_entry* %p.0, %struct.proc_dir_entry** %p45, align 8, !tbaa !286
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup46

cleanup46:                                        ; preds = %if.end44, %LeafBlock, %if.then30, %if.end
  %retval.1 = phi i32 [ 0, %if.end44 ], [ -12, %if.then30 ], [ -6, %if.end ], [ -12, %LeafBlock ]
  ret i32 %retval.1
}

declare %struct.proc_dir_entry* @proc_mkdir_mode(i8*, i16 zeroext, %struct.proc_dir_entry*) #1

declare %struct.proc_dir_entry* @proc_create_data(i8*, i16 zeroext, %struct.proc_dir_entry*, %struct.file_operations*, i8*) #1

declare void @proc_set_size(%struct.proc_dir_entry*, i64) #1

declare i64 @seq_lseek(%struct.file*, i64, i32) #1

declare i64 @seq_read(%struct.file*, i8*, i64, i64*) #1

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_text_entry_write(%struct.file* %file, i8* %buffer, i64 %count, i64* %offset) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.seq_file*
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %1, i32 0, i32 12
  %2 = load i8*, i8** %private, align 8, !tbaa !290
  %3 = bitcast i8* %2 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 2
  %4 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !292
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %4, i32 0, i32 4
  %text = bitcast %union.anon.58* %c to %struct.snd_info_entry_text*
  %write = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 1
  %5 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %write, align 8, !tbaa !49
  %tobool = icmp ne void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %5, null
  br i1 %tobool, label %if.end, label %cleanup42

if.end:                                           ; preds = %entry
  %6 = load i64, i64* %offset, align 8, !tbaa !119
  %call = call zeroext i1 @valid_pos(i64 %6, i64 %count)
  br i1 %call, label %if.end4, label %cleanup42

if.end4:                                          ; preds = %if.end
  %add = add i64 %6, %count
  %cmp = icmp ugt i64 %add, 16384
  br i1 %cmp, label %cleanup42, label %if.end6

if.end6:                                          ; preds = %if.end4
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %4, i32 0, i32 11
  call void @mutex_lock_nested(%struct.mutex* %access, i32 0)
  %wbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 1
  %7 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer, align 8, !tbaa !294
  %tobool7 = icmp ne %struct.snd_info_buffer* %7, null
  br i1 %tobool7, label %if.end14, label %if.then8

if.then8:                                         ; preds = %if.end6
  %call9 = call i8* @kzalloc.116(i64 32, i32 20971712)
  %8 = bitcast i8* %call9 to %struct.snd_info_buffer*
  %wbuffer10 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 1
  store %struct.snd_info_buffer* %8, %struct.snd_info_buffer** %wbuffer10, align 8, !tbaa !294
  %tobool11 = icmp ne %struct.snd_info_buffer* %8, null
  br i1 %tobool11, label %if.end14, label %error

if.end14:                                         ; preds = %if.then8, %if.end6
  %buf.0 = phi %struct.snd_info_buffer* [ %7, %if.end6 ], [ %8, %if.then8 ]
  %len = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buf.0, i32 0, i32 3
  %9 = load i32, i32* %len, align 8, !tbaa !295
  %conv = zext i32 %9 to i64
  %cmp15 = icmp ugt i64 %add, %conv
  br i1 %cmp15, label %if.then17, label %if.end29

if.then17:                                        ; preds = %if.end14
  %buffer18 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buf.0, i32 0, i32 0
  %10 = load i8*, i8** %buffer18, align 8, !tbaa !50
  %add19 = add i64 %add, 4095
  %and = and i64 %add19, -4096
  %call20 = call i8* @krealloc(i8* %10, i64 %and, i32 21004480)
  %tobool21 = icmp ne i8* %call20, null
  br i1 %tobool21, label %if.end23, label %NodeBlock

if.end23:                                         ; preds = %if.then17
  %buffer24 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buf.0, i32 0, i32 0
  store i8* %call20, i8** %buffer24, align 8, !tbaa !50
  %add25 = add i64 %add, 4095
  %and26 = and i64 %add25, -4096
  %conv27 = trunc i64 %and26 to i32
  %len28 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buf.0, i32 0, i32 3
  store i32 %conv27, i32* %len28, align 8, !tbaa !295
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end23, %if.then17
  %err.0 = phi i32 [ 0, %if.end23 ], [ -12, %if.then17 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end23 ], [ 2, %if.then17 ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %error, label %cleanup42

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end29, label %cleanup42

if.end29:                                         ; preds = %LeafBlock, %if.end14
  %err.1 = phi i32 [ 0, %if.end14 ], [ %err.0, %LeafBlock ]
  %buffer30 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buf.0, i32 0, i32 0
  %11 = load i8*, i8** %buffer30, align 8, !tbaa !50
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 %6
  %call31 = call i64 @copy_from_user.118(i8* %add.ptr, i8* %buffer, i64 %count)
  %tobool32 = icmp ne i64 %call31, 0
  br i1 %tobool32, label %error, label %if.end34

if.end34:                                         ; preds = %if.end29
  %conv35 = trunc i64 %add to i32
  %size = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buf.0, i32 0, i32 2
  store i32 %conv35, i32* %size, align 4, !tbaa !296
  br label %error

error:                                            ; preds = %if.end34, %if.end29, %LeafBlock1, %if.then8
  %err.2 = phi i32 [ %err.1, %if.end34 ], [ %err.0, %LeafBlock1 ], [ -12, %if.then8 ], [ -14, %if.end29 ]
  %access36 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %4, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access36)
  %cmp37 = icmp slt i32 %err.2, 0
  br i1 %cmp37, label %if.then39, label %if.end41

if.then39:                                        ; preds = %error
  %conv40 = sext i32 %err.2 to i64
  br label %cleanup42

if.end41:                                         ; preds = %error
  store i64 %add, i64* %offset, align 8, !tbaa !119
  br label %cleanup42

cleanup42:                                        ; preds = %if.end41, %if.then39, %LeafBlock, %LeafBlock1, %if.end4, %if.end, %entry
  %retval.0 = phi i64 [ %conv40, %if.then39 ], [ %count, %if.end41 ], [ -5, %entry ], [ -5, %if.end ], [ -5, %if.end4 ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_text_entry_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %data = alloca %struct.snd_info_private_data*, align 8
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %0 = bitcast i8* %call to %struct.snd_info_entry*
  %1 = bitcast %struct.snd_info_private_data** %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #9
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  %call2 = call i32 @alloc_info_private(%struct.snd_info_entry* %0, %struct.snd_info_private_data** %data)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %unlock, label %if.end

if.end:                                           ; preds = %entry
  %call3 = call i8* @kzalloc.116(i64 32, i32 20971712)
  %2 = bitcast i8* %call3 to %struct.snd_info_buffer*
  %3 = load %struct.snd_info_private_data*, %struct.snd_info_private_data** %data, align 8, !tbaa !2
  %rbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 0
  store %struct.snd_info_buffer* %2, %struct.snd_info_buffer** %rbuffer, align 8, !tbaa !297
  %4 = load %struct.snd_info_private_data*, %struct.snd_info_private_data** %data, align 8, !tbaa !2
  %rbuffer4 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %4, i32 0, i32 0
  %5 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer4, align 8, !tbaa !297
  %tobool = icmp ne %struct.snd_info_buffer* %5, null
  br i1 %tobool, label %if.end6, label %error

if.end6:                                          ; preds = %if.end
  %size = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 2
  %6 = load i64, i64* %size, align 8, !tbaa !289
  %tobool7 = icmp ne i64 %6, 0
  %7 = load %struct.snd_info_private_data*, %struct.snd_info_private_data** %data, align 8, !tbaa !2
  %8 = bitcast %struct.snd_info_private_data* %7 to i8*
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end6
  %size9 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 2
  %9 = load i64, i64* %size9, align 8, !tbaa !289
  %call10 = call i32 @single_open_size(%struct.file* %file, i32 (%struct.seq_file*, i8*)* @snd_info_seq_show, i8* %8, i64 %9)
  br label %if.end12

if.else:                                          ; preds = %if.end6
  %call11 = call i32 @single_open(%struct.file* %file, i32 (%struct.seq_file*, i8*)* @snd_info_seq_show, i8* %8)
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then8
  %err.0 = phi i32 [ %call10, %if.then8 ], [ %call11, %if.else ]
  %cmp13 = icmp slt i32 %err.0, 0
  br i1 %cmp13, label %error, label %if.end15

if.end15:                                         ; preds = %if.end12
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

error:                                            ; preds = %if.end12, %if.end
  %err.1 = phi i32 [ -12, %if.end ], [ %err.0, %if.end12 ]
  %10 = load %struct.snd_info_private_data*, %struct.snd_info_private_data** %data, align 8, !tbaa !2
  %rbuffer16 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  %11 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer16, align 8, !tbaa !297
  %12 = bitcast %struct.snd_info_buffer* %11 to i8*
  call void @kfree(i8* %12)
  %13 = load %struct.snd_info_private_data*, %struct.snd_info_private_data** %data, align 8, !tbaa !2
  %14 = bitcast %struct.snd_info_private_data* %13 to i8*
  call void @kfree(i8* %14)
  %module = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 7
  %15 = load %struct.module*, %struct.module** %module, align 8, !tbaa !298
  call void @module_put(%struct.module* %15)
  br label %unlock

unlock:                                           ; preds = %error, %entry
  %err.2 = phi i32 [ %err.1, %error ], [ %call2, %entry ]
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

cleanup:                                          ; preds = %unlock, %if.end15
  %retval.0 = phi i32 [ %err.2, %unlock ], [ 0, %if.end15 ]
  %16 = bitcast %struct.snd_info_private_data** %data to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %16) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_text_entry_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.seq_file*
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %1, i32 0, i32 12
  %2 = load i8*, i8** %private, align 8, !tbaa !290
  %3 = bitcast i8* %2 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 2
  %4 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !292
  %wbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 1
  %5 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer, align 8, !tbaa !294
  %tobool = icmp ne %struct.snd_info_buffer* %5, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %4, i32 0, i32 4
  %text = bitcast %union.anon.58* %c to %struct.snd_info_entry_text*
  %write = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 1
  %6 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %write, align 8, !tbaa !49
  %tobool3 = icmp ne void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %6, null
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %c4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %4, i32 0, i32 4
  %text5 = bitcast %union.anon.58* %c4 to %struct.snd_info_entry_text*
  %write6 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text5, i32 0, i32 1
  %7 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %write6, align 8, !tbaa !49
  %wbuffer7 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 1
  %8 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer7, align 8, !tbaa !294
  call void %7(%struct.snd_info_entry* %4, %struct.snd_info_buffer* %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %call = call i32 @single_release(%struct.inode* %inode, %struct.file* %file)
  %rbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 0
  %9 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer, align 8, !tbaa !297
  %10 = bitcast %struct.snd_info_buffer* %9 to i8*
  call void @kfree(i8* %10)
  %wbuffer8 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 1
  %11 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer8, align 8, !tbaa !294
  %tobool9 = icmp ne %struct.snd_info_buffer* %11, null
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.end
  %wbuffer11 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 1
  %12 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer11, align 8, !tbaa !294
  %buffer = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %12, i32 0, i32 0
  %13 = load i8*, i8** %buffer, align 8, !tbaa !50
  call void @kfree(i8* %13)
  %wbuffer12 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %3, i32 0, i32 1
  %14 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer12, align 8, !tbaa !294
  %15 = bitcast %struct.snd_info_buffer* %14 to i8*
  call void @kfree(i8* %15)
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.end
  %module = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %4, i32 0, i32 7
  %16 = load %struct.module*, %struct.module** %module, align 8, !tbaa !298
  call void @module_put(%struct.module* %16)
  %17 = bitcast %struct.snd_info_private_data* %3 to i8*
  call void @kfree(i8* %17)
  ret i32 0
}

declare i32 @single_release(%struct.inode*, %struct.file*) #1

declare i8* @PDE_DATA(%struct.inode*) #1

; Function Attrs: nounwind uwtable
define internal i32 @alloc_info_private(%struct.snd_info_entry* %entry1, %struct.snd_info_private_data** %ret) #0 {
entry:
  %tobool = icmp ne %struct.snd_info_entry* %entry1, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %p = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p, align 8, !tbaa !286
  %tobool2 = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool2, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %module = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 7
  %1 = load %struct.module*, %struct.module** %module, align 8, !tbaa !298
  %call = call zeroext i1 @try_module_get(%struct.module* %1)
  br i1 %call, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %call5 = call i8* @kzalloc.116(i64 32, i32 20971712)
  %2 = bitcast i8* %call5 to %struct.snd_info_private_data*
  %tobool6 = icmp ne %struct.snd_info_private_data* %2, null
  br i1 %tobool6, label %if.end9, label %if.then7

if.then7:                                         ; preds = %if.end4
  %module8 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 7
  %3 = load %struct.module*, %struct.module** %module8, align 8, !tbaa !298
  call void @module_put(%struct.module* %3)
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %entry10 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 2
  store %struct.snd_info_entry* %entry1, %struct.snd_info_entry** %entry10, align 8, !tbaa !292
  store %struct.snd_info_private_data* %2, %struct.snd_info_private_data** %ret, align 8, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %if.then7, %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ 0, %if.end9 ], [ -12, %if.then7 ], [ -19, %lor.lhs.false ], [ -19, %entry ], [ -14, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.116(i64 %size, i32 %flags) #5 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc.117(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_seq_show(%struct.seq_file* %seq, i8* %p) #0 {
entry:
  %private = getelementptr inbounds %struct.seq_file, %struct.seq_file* %seq, i32 0, i32 12
  %0 = load i8*, i8** %private, align 8, !tbaa !290
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !292
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %text = bitcast %union.anon.58* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  %3 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !49
  %tobool = icmp ne void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %3, null
  br i1 %tobool, label %if.else, label %cleanup

if.else:                                          ; preds = %entry
  %4 = bitcast %struct.seq_file* %seq to i8*
  %rbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 0
  %5 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer, align 8, !tbaa !297
  %buffer = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 0
  store i8* %4, i8** %buffer, align 8, !tbaa !50
  %c3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %text4 = bitcast %union.anon.58* %c3 to %struct.snd_info_entry_text*
  %read5 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text4, i32 0, i32 0
  %6 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read5, align 8, !tbaa !49
  %rbuffer6 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 0
  %7 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer6, align 8, !tbaa !297
  call void %6(%struct.snd_info_entry* %2, %struct.snd_info_buffer* %7)
  br label %cleanup

cleanup:                                          ; preds = %if.else, %entry
  %retval.0 = phi i32 [ 0, %if.else ], [ -5, %entry ]
  ret i32 %retval.0
}

declare i32 @single_open_size(%struct.file*, i32 (%struct.seq_file*, i8*)*, i8*, i64) #1

declare i32 @single_open(%struct.file*, i32 (%struct.seq_file*, i8*)*, i8*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc.117(i64 %size, i32 %flags) #3 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @valid_pos(i64 %pos, i64 %count) #0 {
entry:
  %cmp = icmp slt i64 %pos, 0
  %cmp1 = icmp ne i64 %pos, %pos
  %or.cond = or i1 %cmp, %cmp1
  %cmp3 = icmp slt i64 %count, 0
  %or.cond1 = or i1 %or.cond, %cmp3
  br i1 %or.cond1, label %return, label %if.end

if.end:                                           ; preds = %entry
  %add = add i64 %pos, %count
  %cmp4 = icmp ult i64 %add, %pos
  %. = select i1 %cmp4, i1 false, i1 true
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i1 [ false, %entry ], [ %., %if.end ]
  ret i1 %retval.0
}

declare i8* @krealloc(i8*, i64, i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @copy_from_user.118(i8* %to, i8* %from, i64 %n) #3 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.18.119, i32 0, i32 0), i32 696)
  %conv1 = trunc i64 %n to i32
  call void @kasan_check_write(i8* %to, i32 %conv1)
  %cmp = icmp slt i32 %conv, 0
  %conv3 = sext i32 %conv to i64
  %cmp4 = icmp uge i64 %conv3, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp4
  %lnot = xor i1 %1, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @check_object_size.120(i8* %to, i64 %n, i1 zeroext false)
  %conv8 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @copy_user_overflow.121(i32 %conv, i64 %n)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.else ]
  ret i64 %n.addr.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @check_object_size.120(i8* %ptr, i64 %n, i1 zeroext %to_user) #3 {
entry:
  %frombool = zext i1 %to_user to i8
  %tobool = trunc i8 %frombool to i1
  call void @__check_object_size(i8* %ptr, i64 %n, i1 zeroext %tobool)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @copy_user_overflow.121(i32 %size, i64 %count) #5 {
entry:
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.18.119, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.19.122, i32 0, i32 0), i32 %size, i64 %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool3 = icmp ne i32 1, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %expval9 = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_llseek(%struct.file* %file, i64 %offset, i32 %orig) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !292
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_lock_nested(%struct.mutex* %access, i32 0)
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.58* %c to %struct.snd_info_entry_ops**
  %3 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !49
  %llseek = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %3, i32 0, i32 4
  %4 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)** %llseek, align 8, !tbaa !299
  %tobool = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)* %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %c3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops4 = bitcast %union.anon.58* %c3 to %struct.snd_info_entry_ops**
  %5 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops4, align 8, !tbaa !49
  %llseek5 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %5, i32 0, i32 4
  %6 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)** %llseek5, align 8, !tbaa !299
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %7 = load i8*, i8** %file_private_data, align 8, !tbaa !301
  %call = call i64 %6(%struct.snd_info_entry* %2, i8* %7, %struct.file* %file, i64 %offset, i32 %orig)
  br label %out

if.end:                                           ; preds = %entry
  %size6 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 2
  %8 = load i64, i64* %size6, align 8, !tbaa !289
  %Pivot4 = icmp slt i32 %orig, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %orig, 2
  br i1 %Pivot, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %orig, 2
  %tobool8 = icmp ne i64 %8, 0
  %or.cond5 = and i1 %SwitchLeaf2, %tobool8
  br i1 %or.cond5, label %if.end10, label %out

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %orig, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %out

sw.bb:                                            ; preds = %NodeBlock
  %f_pos = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %9 = load i64, i64* %f_pos, align 8, !tbaa !302
  %add = add nsw i64 %offset, %9
  br label %sw.epilog

if.end10:                                         ; preds = %LeafBlock1
  %add11 = add nsw i64 %offset, %8
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end10, %sw.bb, %LeafBlock
  %offset.addr.0 = phi i64 [ %offset, %LeafBlock ], [ %add, %sw.bb ], [ %add11, %if.end10 ]
  %cmp = icmp slt i64 %offset.addr.0, 0
  br i1 %cmp, label %out, label %if.end13

if.end13:                                         ; preds = %sw.epilog
  %tobool14 = icmp ne i64 %8, 0
  %cmp15 = icmp sgt i64 %offset.addr.0, %8
  %or.cond = and i1 %tobool14, %cmp15
  %offset.addr.1 = select i1 %or.cond, i64 %8, i64 %offset.addr.0
  %f_pos18 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  store i64 %offset.addr.1, i64* %f_pos18, align 8, !tbaa !302
  br label %out

out:                                              ; preds = %if.end13, %sw.epilog, %LeafBlock, %LeafBlock1, %if.then
  %ret.0 = phi i64 [ -22, %if.then ], [ %offset.addr.1, %if.end13 ], [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %sw.epilog ]
  %access19 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access19)
  ret i64 %ret.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_read(%struct.file* %file, i8* %buffer, i64 %count, i64* %offset) #0 {
entry:
  %__UNIQUE_ID_min1_12 = alloca i64, align 8
  %__UNIQUE_ID_min2_13 = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !292
  %3 = load i64, i64* %offset, align 8, !tbaa !119
  %call = call zeroext i1 @valid_pos(i64 %3, i64 %count)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %size3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 2
  %4 = load i64, i64* %size3, align 8, !tbaa !289
  %cmp = icmp sge i64 %3, %4
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %size6 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 2
  %5 = load i64, i64* %size6, align 8, !tbaa !289
  %sub = sub nsw i64 %5, %3
  %6 = bitcast i64* %__UNIQUE_ID_min1_12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #9
  store i64 %count, i64* %__UNIQUE_ID_min1_12, align 8, !tbaa !104
  %7 = bitcast i64* %__UNIQUE_ID_min2_13 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #9
  store i64 %sub, i64* %__UNIQUE_ID_min2_13, align 8, !tbaa !104
  %cmp7 = icmp eq i64* %__UNIQUE_ID_min1_12, %__UNIQUE_ID_min2_13
  %conv = zext i1 %cmp7 to i32
  %8 = load i64, i64* %__UNIQUE_ID_min1_12, align 8, !tbaa !104
  %9 = load i64, i64* %__UNIQUE_ID_min2_13, align 8, !tbaa !104
  %cmp8 = icmp ult i64 %8, %9
  %10 = load i64, i64* %__UNIQUE_ID_min1_12, align 8
  %11 = load i64, i64* %__UNIQUE_ID_min2_13, align 8
  %cond = select i1 %cmp8, i64 %10, i64 %11
  %12 = bitcast i64* %__UNIQUE_ID_min2_13 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #9
  %13 = bitcast i64* %__UNIQUE_ID_min1_12 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #9
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.58* %c to %struct.snd_info_entry_ops**
  %14 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !49
  %read = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %14, i32 0, i32 2
  %15 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read, align 8, !tbaa !303
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %16 = load i8*, i8** %file_private_data, align 8, !tbaa !301
  %call10 = call i64 %15(%struct.snd_info_entry* %2, i8* %16, %struct.file* %file, i8* %buffer, i64 %cond, i64 %3)
  %cmp11 = icmp sgt i64 %call10, 0
  br i1 %cmp11, label %if.then13, label %cleanup

if.then13:                                        ; preds = %if.end5
  %add = add i64 %3, %call10
  store i64 %add, i64* %offset, align 8, !tbaa !119
  br label %cleanup

cleanup:                                          ; preds = %if.then13, %if.end5, %if.end, %entry
  %retval.0 = phi i64 [ -5, %entry ], [ 0, %if.end ], [ %call10, %if.then13 ], [ %call10, %if.end5 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_write(%struct.file* %file, i8* %buffer, i64 %count, i64* %offset) #0 {
entry:
  %__UNIQUE_ID_min1_14 = alloca i64, align 8
  %__UNIQUE_ID_min2_15 = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !292
  %3 = load i64, i64* %offset, align 8, !tbaa !119
  %call = call zeroext i1 @valid_pos(i64 %3, i64 %count)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %cmp = icmp ugt i64 %count, 0
  br i1 %cmp, label %if.then3, label %if.end9

if.then3:                                         ; preds = %if.end
  %size4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 2
  %4 = load i64, i64* %size4, align 8, !tbaa !289
  %sub = sub nsw i64 %4, %3
  %5 = bitcast i64* %__UNIQUE_ID_min1_14 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #9
  store i64 %count, i64* %__UNIQUE_ID_min1_14, align 8, !tbaa !104
  %6 = bitcast i64* %__UNIQUE_ID_min2_15 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #9
  store i64 %sub, i64* %__UNIQUE_ID_min2_15, align 8, !tbaa !104
  %cmp5 = icmp eq i64* %__UNIQUE_ID_min1_14, %__UNIQUE_ID_min2_15
  %conv = zext i1 %cmp5 to i32
  %7 = load i64, i64* %__UNIQUE_ID_min1_14, align 8, !tbaa !104
  %8 = load i64, i64* %__UNIQUE_ID_min2_15, align 8, !tbaa !104
  %cmp6 = icmp ult i64 %7, %8
  %9 = load i64, i64* %__UNIQUE_ID_min1_14, align 8
  %10 = load i64, i64* %__UNIQUE_ID_min2_15, align 8
  %cond = select i1 %cmp6, i64 %9, i64 %10
  %11 = bitcast i64* %__UNIQUE_ID_min2_15 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #9
  %12 = bitcast i64* %__UNIQUE_ID_min1_14 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #9
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.58* %c to %struct.snd_info_entry_ops**
  %13 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !49
  %write = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %13, i32 0, i32 3
  %14 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write, align 8, !tbaa !304
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %15 = load i8*, i8** %file_private_data, align 8, !tbaa !301
  %call8 = call i64 %14(%struct.snd_info_entry* %2, i8* %15, %struct.file* %file, i8* %buffer, i64 %cond, i64 %3)
  br label %if.end9

if.end9:                                          ; preds = %if.then3, %if.end
  %size.0 = phi i64 [ %call8, %if.then3 ], [ 0, %if.end ]
  %cmp10 = icmp sgt i64 %size.0, 0
  br i1 %cmp10, label %if.then12, label %cleanup

if.then12:                                        ; preds = %if.end9
  %add = add nsw i64 %3, %size.0
  store i64 %add, i64* %offset, align 8, !tbaa !119
  br label %cleanup

cleanup:                                          ; preds = %if.then12, %if.end9, %entry
  %retval.0 = phi i64 [ -5, %entry ], [ %size.0, %if.then12 ], [ %size.0, %if.end9 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !292
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.58* %c to %struct.snd_info_entry_ops**
  %3 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !49
  %poll = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %3, i32 0, i32 5
  %4 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)** %poll, align 8, !tbaa !305
  %tobool = icmp ne i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)* %4, null
  %c3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops4 = bitcast %union.anon.58* %c3 to %struct.snd_info_entry_ops**
  %5 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops4, align 8, !tbaa !49
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %poll5 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %5, i32 0, i32 5
  %6 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)** %poll5, align 8, !tbaa !305
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %7 = load i8*, i8** %file_private_data, align 8, !tbaa !301
  %call = call i32 %6(%struct.snd_info_entry* %2, i8* %7, %struct.file* %file, %struct.poll_table_struct* %wait)
  br label %cleanup

if.end:                                           ; preds = %entry
  %read = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %5, i32 0, i32 2
  %8 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read, align 8, !tbaa !303
  %tobool8 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %8, null
  %or = or i32 0, 65
  %or. = select i1 %tobool8, i32 %or, i32 0
  %c11 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops12 = bitcast %union.anon.58* %c11 to %struct.snd_info_entry_ops**
  %9 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops12, align 8, !tbaa !49
  %write = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %9, i32 0, i32 3
  %10 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write, align 8, !tbaa !304
  %tobool13 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %10, null
  %or15 = or i32 %or., 260
  %mask.1 = select i1 %tobool13, i32 %or15, i32 %or.
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %mask.1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !292
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.58* %c to %struct.snd_info_entry_ops**
  %3 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !49
  %ioctl = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %3, i32 0, i32 6
  %4 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)** %ioctl, align 8, !tbaa !306
  %tobool = icmp ne i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)* %4, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %c3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops4 = bitcast %union.anon.58* %c3 to %struct.snd_info_entry_ops**
  %5 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops4, align 8, !tbaa !49
  %ioctl5 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %5, i32 0, i32 6
  %6 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)** %ioctl5, align 8, !tbaa !306
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %7 = load i8*, i8** %file_private_data, align 8, !tbaa !301
  %call = call i32 %6(%struct.snd_info_entry* %2, i8* %7, %struct.file* %file, i32 %cmd, i64 %arg)
  %conv = sext i32 %call to i64
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i64 [ %conv, %if.end ], [ -25, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_mmap(%struct.file* %file, %struct.vm_area_struct* %vma) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %file)
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %cmp = icmp eq %struct.snd_info_private_data* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !292
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.58* %c to %struct.snd_info_entry_ops**
  %3 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !49
  %mmap = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %3, i32 0, i32 7
  %4 = load i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)** %mmap, align 8, !tbaa !307
  %tobool = icmp ne i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)* %4, null
  br i1 %tobool, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %c5 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops6 = bitcast %union.anon.58* %c5 to %struct.snd_info_entry_ops**
  %5 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops6, align 8, !tbaa !49
  %mmap7 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %5, i32 0, i32 7
  %6 = load i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)** %mmap7, align 8, !tbaa !307
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %7 = load i8*, i8** %file_private_data, align 8, !tbaa !301
  %call8 = call i32 %6(%struct.snd_info_entry* %2, i8* %7, %struct.inode* %call, %struct.file* %file, %struct.vm_area_struct* %vma)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call8, %if.end4 ], [ 0, %entry ], [ -6, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %data = alloca %struct.snd_info_private_data*, align 8
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %0 = bitcast i8* %call to %struct.snd_info_entry*
  %1 = bitcast %struct.snd_info_private_data** %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #9
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  %call2 = call i32 @alloc_info_private(%struct.snd_info_entry* %0, %struct.snd_info_private_data** %data)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %unlock, label %if.end

if.end:                                           ; preds = %entry
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 6
  %2 = load i32, i32* %f_flags, align 8, !tbaa !132
  %and = and i32 %2, 3
  switch i32 %and, label %if.end14 [
    i32 0, label %land.lhs.true
    i32 2, label %land.lhs.true
    i32 1, label %land.lhs.true9
  ]

land.lhs.true:                                    ; preds = %if.end, %if.end
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops = bitcast %union.anon.58* %c to %struct.snd_info_entry_ops**
  %3 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !49
  %read = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %3, i32 0, i32 2
  %4 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read, align 8, !tbaa !303
  %tobool = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %4, null
  br i1 %tobool, label %lor.lhs.false5, label %error

lor.lhs.false5:                                   ; preds = %land.lhs.true
  %and.off = add i32 %and, -1
  %switch = icmp ult i32 %and.off, 2
  br i1 %switch, label %land.lhs.true9, label %if.end14

land.lhs.true9:                                   ; preds = %lor.lhs.false5, %if.end
  %c10 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops11 = bitcast %union.anon.58* %c10 to %struct.snd_info_entry_ops**
  %5 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops11, align 8, !tbaa !49
  %write = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %5, i32 0, i32 3
  %6 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write, align 8, !tbaa !304
  %tobool12 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %6, null
  br i1 %tobool12, label %if.end14, label %error

if.end14:                                         ; preds = %land.lhs.true9, %lor.lhs.false5, %if.end
  %c15 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops16 = bitcast %union.anon.58* %c15 to %struct.snd_info_entry_ops**
  %7 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops16, align 8, !tbaa !49
  %open = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %7, i32 0, i32 0
  %8 = load i32 (%struct.snd_info_entry*, i16, i8**)*, i32 (%struct.snd_info_entry*, i16, i8**)** %open, align 8, !tbaa !308
  %tobool17 = icmp ne i32 (%struct.snd_info_entry*, i16, i8**)* %8, null
  br i1 %tobool17, label %if.then18, label %if.end27

if.then18:                                        ; preds = %if.end14
  %c19 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops20 = bitcast %union.anon.58* %c19 to %struct.snd_info_entry_ops**
  %9 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops20, align 8, !tbaa !49
  %open21 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %9, i32 0, i32 0
  %10 = load i32 (%struct.snd_info_entry*, i16, i8**)*, i32 (%struct.snd_info_entry*, i16, i8**)** %open21, align 8, !tbaa !308
  %conv = trunc i32 %and to i16
  %11 = load %struct.snd_info_private_data*, %struct.snd_info_private_data** %data, align 8, !tbaa !2
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %11, i32 0, i32 3
  %call22 = call i32 %10(%struct.snd_info_entry* %0, i16 zeroext %conv, i8** %file_private_data)
  %cmp23 = icmp slt i32 %call22, 0
  br i1 %cmp23, label %error, label %if.end27

if.end27:                                         ; preds = %if.then18, %if.end14
  %12 = load %struct.snd_info_private_data*, %struct.snd_info_private_data** %data, align 8, !tbaa !2
  %13 = bitcast %struct.snd_info_private_data* %12 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %13, i8** %private_data, align 8, !tbaa !207
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

error:                                            ; preds = %if.then18, %land.lhs.true9, %land.lhs.true
  %err.0 = phi i32 [ -19, %land.lhs.true9 ], [ -19, %land.lhs.true ], [ %call22, %if.then18 ]
  %14 = load %struct.snd_info_private_data*, %struct.snd_info_private_data** %data, align 8, !tbaa !2
  %15 = bitcast %struct.snd_info_private_data* %14 to i8*
  call void @kfree(i8* %15)
  %module = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 7
  %16 = load %struct.module*, %struct.module** %module, align 8, !tbaa !298
  call void @module_put(%struct.module* %16)
  br label %unlock

unlock:                                           ; preds = %error, %entry
  %err.1 = phi i32 [ %err.0, %error ], [ %call2, %entry ]
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

cleanup:                                          ; preds = %unlock, %if.end27
  %retval.0 = phi i32 [ %err.1, %unlock ], [ 0, %if.end27 ]
  %17 = bitcast %struct.snd_info_private_data** %data to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !207
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !292
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.58* %c to %struct.snd_info_entry_ops**
  %3 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !49
  %release = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %3, i32 0, i32 1
  %4 = load i32 (%struct.snd_info_entry*, i16, i8*)*, i32 (%struct.snd_info_entry*, i16, i8*)** %release, align 8, !tbaa !309
  %tobool = icmp ne i32 (%struct.snd_info_entry*, i16, i8*)* %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %c3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops4 = bitcast %union.anon.58* %c3 to %struct.snd_info_entry_ops**
  %5 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops4, align 8, !tbaa !49
  %release5 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %5, i32 0, i32 1
  %6 = load i32 (%struct.snd_info_entry*, i16, i8*)*, i32 (%struct.snd_info_entry*, i16, i8*)** %release5, align 8, !tbaa !309
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 6
  %7 = load i32, i32* %f_flags, align 8, !tbaa !132
  %and = and i32 %7, 3
  %conv = trunc i32 %and to i16
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %8 = load i8*, i8** %file_private_data, align 8, !tbaa !301
  %call = call i32 %6(%struct.snd_info_entry* %2, i16 zeroext %conv, i8* %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %module = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 7
  %9 = load %struct.module*, %struct.module** %module, align 8, !tbaa !298
  call void @module_put(%struct.module* %9)
  %10 = bitcast %struct.snd_info_private_data* %1 to i8*
  call void @kfree(i8* %10)
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #5 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !310
  ret %struct.inode* %0
}

; Function Attrs: nounwind uwtable
define void @snd_info_free_entry(%struct.snd_info_entry* %entry1) #0 {
entry:
  %tobool = icmp ne %struct.snd_info_entry* %entry1, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %p2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p2, align 8, !tbaa !286
  %tobool3 = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  call void @snd_info_disconnect(%struct.snd_info_entry* %entry1)
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %children = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %children, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -272
  %3 = bitcast i8* %add.ptr to %struct.snd_info_entry*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end5
  %.sink = phi %struct.snd_info_entry* [ %6, %for.body ], [ %3, %if.end5 ]
  %p.0 = phi %struct.snd_info_entry* [ %3, %if.end5 ], [ %6, %for.body ]
  %list13 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %.sink, i32 0, i32 13
  %next14 = getelementptr inbounds %struct.list_head, %struct.list_head* %list13, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next14, align 8, !tbaa !311
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %5, i64 -272
  %6 = bitcast i8* %add.ptr16 to %struct.snd_info_entry*
  %list10 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %p.0, i32 0, i32 13
  %children11 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %list10, %children11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @snd_info_free_entry(%struct.snd_info_entry* %p.0)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %list17 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 13
  call void @list_del.127(%struct.list_head* %list17)
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 0
  %7 = load i8*, i8** %name, align 8, !tbaa !125
  call void @kfree(i8* %7)
  %private_free = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 9
  %8 = load void (%struct.snd_info_entry*)*, void (%struct.snd_info_entry*)** %private_free, align 8, !tbaa !312
  %tobool18 = icmp ne void (%struct.snd_info_entry*)* %8, null
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %for.end
  %private_free20 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 9
  %9 = load void (%struct.snd_info_entry*)*, void (%struct.snd_info_entry*)** %private_free20, align 8, !tbaa !312
  call void %9(%struct.snd_info_entry* %entry1)
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %for.end
  %10 = bitcast %struct.snd_info_entry* %entry1 to i8*
  call void @kfree(i8* %10)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end21, %entry
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end21 ], [ 1, %entry ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snd_info_disconnect(%struct.snd_info_entry* %entry1) #0 {
entry:
  %p2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p2, align 8, !tbaa !286
  %tobool = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %children = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 12
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %list5.sink = phi %struct.list_head* [ %list5, %for.body ], [ %children, %if.end ]
  %next6 = getelementptr inbounds %struct.list_head, %struct.list_head* %list5.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next6, align 8, !tbaa !2
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %2, i64 -272
  %3 = bitcast i8* %add.ptr8 to %struct.snd_info_entry*
  %list = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 13
  %children3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %list, %children3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @snd_info_disconnect(%struct.snd_info_entry* %3)
  %list5 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 13
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %p9 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %4 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p9, align 8, !tbaa !286
  call void @proc_remove(%struct.proc_dir_entry* %4)
  %p10 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %p10, align 8, !tbaa !286
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %entry
  %cleanup.dest.slot.0 = phi i32 [ 0, %for.end ], [ 1, %entry ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del.127(%struct.list_head* %entry1) #5 {
entry:
  call void @__list_del_entry.128(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !116
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry.128(%struct.list_head* %entry1) #5 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  call void @__list_del.129(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del.129(%struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !49
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.130(i8* %1, i8* %arraydecay, i32 8)
  %__val3 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val3, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size.130(i8* %p, i8* %res, i32 %size) #3 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !49
  store volatile i8 %0, i8* %p, align 1, !tbaa !49
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !118
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !118
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !47
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !47
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !119
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !119
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !313
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !314
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

declare void @proc_remove(%struct.proc_dir_entry*) #1

; Function Attrs: nounwind uwtable
define %struct.snd_info_entry* @snd_info_create_card_entry(%struct.snd_card* %card, i8* %name, %struct.snd_info_entry* %parent) #0 {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_entry(i8* %name, %struct.snd_info_entry* %parent)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 8
  %0 = load %struct.module*, %struct.module** %module, align 8, !tbaa !136
  %module2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 7
  store %struct.module* %0, %struct.module** %module2, align 8, !tbaa !298
  %card3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 6
  store %struct.snd_card* %card, %struct.snd_card** %card3, align 8, !tbaa !128
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.snd_info_entry* %call
}

; Function Attrs: nounwind uwtable
define internal %struct.snd_info_entry* @snd_info_create_entry(i8* %name, %struct.snd_info_entry* %parent) #0 {
entry:
  %call = call i8* @kzalloc.116(i64 288, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_info_entry*
  %cmp = icmp eq %struct.snd_info_entry* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call noalias i8* @kstrdup(i8* %name, i32 20971712)
  %name3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 0
  store i8* %call2, i8** %name3, align 8, !tbaa !125
  %name4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 0
  %1 = load i8*, i8** %name4, align 8, !tbaa !125
  %cmp5 = icmp eq i8* %1, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %2 = bitcast %struct.snd_info_entry* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 1
  store i16 -32476, i16* %mode, align 8, !tbaa !287
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  store i16 0, i16* %content, align 8, !tbaa !288
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 11
  call void @__mutex_init(%struct.mutex* %access, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.17.133, i32 0, i32 0), %struct.lock_class_key* @snd_info_create_entry.__key)
  %children = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 12
  call void @INIT_LIST_HEAD.134(%struct.list_head* %children)
  %list = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 13
  call void @INIT_LIST_HEAD.134(%struct.list_head* %list)
  %parent8 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 5
  store %struct.snd_info_entry* %parent, %struct.snd_info_entry** %parent8, align 8, !tbaa !285
  %tobool = icmp ne %struct.snd_info_entry* %parent, null
  br i1 %tobool, label %if.then9, label %cleanup

if.then9:                                         ; preds = %if.end7
  %list10 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 13
  %children11 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %parent, i32 0, i32 12
  call void @list_add_tail.135(%struct.list_head* %list10, %struct.list_head* %children11)
  br label %cleanup

cleanup:                                          ; preds = %if.then9, %if.end7, %if.then6, %entry
  %retval.0 = phi %struct.snd_info_entry* [ null, %if.then6 ], [ null, %entry ], [ %0, %if.then9 ], [ %0, %if.end7 ]
  ret %struct.snd_info_entry* %retval.0
}

declare noalias i8* @kstrdup(i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.134(%struct.list_head* %list) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !49
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.130(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.135(%struct.list_head* %new, %struct.list_head* %head) #5 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  call void @__list_add.136(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add.136(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !117
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !116
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !49
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.130(i8* %1, i8* %arraydecay, i32 8)
  %__val5 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val5, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* %module, i8* %name, %struct.snd_info_entry* %parent) #0 {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_entry(i8* %name, %struct.snd_info_entry* %parent)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %module2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 7
  store %struct.module* %module, %struct.module** %module2, align 8, !tbaa !298
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.snd_info_entry* %call
}

; Function Attrs: nounwind uwtable
define i8* @snd_info_get_str(i8* %dest, i8* %src, i32 %len) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %src.addr.0 = phi i8* [ %src, %entry ], [ %incdec.ptr, %while.body ]
  %0 = load i8, i8* %src.addr.0, align 1, !tbaa !49
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 32
  br i1 %cmp, label %while.body, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %1 = load i8, i8* %src.addr.0, align 1, !tbaa !49
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 9
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %lor.rhs, %while.cond
  %incdec.ptr = getelementptr inbounds i8, i8* %src.addr.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %lor.rhs
  %2 = load i8, i8* %src.addr.0, align 1, !tbaa !49
  %conv5 = sext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv5, 34
  br i1 %cmp6, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.end
  %3 = load i8, i8* %src.addr.0, align 1, !tbaa !49
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 39
  br i1 %cmp9, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %while.end
  %incdec.ptr11 = getelementptr inbounds i8, i8* %src.addr.0, i32 1
  %4 = load i8, i8* %src.addr.0, align 1, !tbaa !49
  %conv12 = sext i8 %4 to i32
  br label %while.cond13

while.cond13:                                     ; preds = %while.body20, %if.then
  %len.addr.0 = phi i32 [ %len, %if.then ], [ %dec, %while.body20 ]
  %src.addr.1 = phi i8* [ %incdec.ptr11, %if.then ], [ %incdec.ptr21, %while.body20 ]
  %dest.addr.0 = phi i8* [ %dest, %if.then ], [ %incdec.ptr22, %while.body20 ]
  %dec = add nsw i32 %len.addr.0, -1
  %cmp14 = icmp sgt i32 %dec, 0
  br i1 %cmp14, label %land.lhs.true, label %while.end23

land.lhs.true:                                    ; preds = %while.cond13
  %5 = load i8, i8* %src.addr.1, align 1, !tbaa !49
  %conv16 = sext i8 %5 to i32
  %tobool = icmp ne i32 %conv16, 0
  br i1 %tobool, label %land.rhs, label %while.end23

land.rhs:                                         ; preds = %land.lhs.true
  %6 = load i8, i8* %src.addr.1, align 1, !tbaa !49
  %conv17 = sext i8 %6 to i32
  %cmp18 = icmp ne i32 %conv17, %conv12
  br i1 %cmp18, label %while.body20, label %while.end23

while.body20:                                     ; preds = %land.rhs
  %incdec.ptr21 = getelementptr inbounds i8, i8* %src.addr.1, i32 1
  %7 = load i8, i8* %src.addr.1, align 1, !tbaa !49
  %incdec.ptr22 = getelementptr inbounds i8, i8* %dest.addr.0, i32 1
  store i8 %7, i8* %dest.addr.0, align 1, !tbaa !49
  br label %while.cond13

while.end23:                                      ; preds = %land.rhs, %land.lhs.true, %while.cond13
  %8 = load i8, i8* %src.addr.1, align 1, !tbaa !49
  %conv24 = sext i8 %8 to i32
  %cmp25 = icmp eq i32 %conv24, %conv12
  %incdec.ptr28 = getelementptr inbounds i8, i8* %src.addr.1, i32 1
  %incdec.ptr28.src.addr.1 = select i1 %cmp25, i8* %incdec.ptr28, i8* %src.addr.1
  br label %if.end49

if.else:                                          ; preds = %lor.lhs.false
  br label %while.cond29

while.cond29:                                     ; preds = %while.body45, %if.else
  %len.addr.1 = phi i32 [ %len, %if.else ], [ %dec30, %while.body45 ]
  %src.addr.3 = phi i8* [ %src.addr.0, %if.else ], [ %incdec.ptr46, %while.body45 ]
  %dest.addr.1 = phi i8* [ %dest, %if.else ], [ %incdec.ptr47, %while.body45 ]
  %dec30 = add nsw i32 %len.addr.1, -1
  %cmp31 = icmp sgt i32 %dec30, 0
  br i1 %cmp31, label %land.lhs.true33, label %if.end49

land.lhs.true33:                                  ; preds = %while.cond29
  %9 = load i8, i8* %src.addr.3, align 1, !tbaa !49
  %conv34 = sext i8 %9 to i32
  %tobool35 = icmp ne i32 %conv34, 0
  br i1 %tobool35, label %land.lhs.true36, label %if.end49

land.lhs.true36:                                  ; preds = %land.lhs.true33
  %10 = load i8, i8* %src.addr.3, align 1, !tbaa !49
  %conv37 = sext i8 %10 to i32
  %cmp38 = icmp ne i32 %conv37, 32
  br i1 %cmp38, label %land.rhs40, label %if.end49

land.rhs40:                                       ; preds = %land.lhs.true36
  %11 = load i8, i8* %src.addr.3, align 1, !tbaa !49
  %conv41 = sext i8 %11 to i32
  %cmp42 = icmp ne i32 %conv41, 9
  br i1 %cmp42, label %while.body45, label %if.end49

while.body45:                                     ; preds = %land.rhs40
  %incdec.ptr46 = getelementptr inbounds i8, i8* %src.addr.3, i32 1
  %12 = load i8, i8* %src.addr.3, align 1, !tbaa !49
  %incdec.ptr47 = getelementptr inbounds i8, i8* %dest.addr.1, i32 1
  store i8 %12, i8* %dest.addr.1, align 1, !tbaa !49
  br label %while.cond29

if.end49:                                         ; preds = %land.rhs40, %land.lhs.true36, %land.lhs.true33, %while.cond29, %while.end23
  %src.addr.4 = phi i8* [ %incdec.ptr28.src.addr.1, %while.end23 ], [ %src.addr.3, %while.cond29 ], [ %src.addr.3, %land.lhs.true33 ], [ %src.addr.3, %land.lhs.true36 ], [ %src.addr.3, %land.rhs40 ]
  %dest.addr.2 = phi i8* [ %dest.addr.0, %while.end23 ], [ %dest.addr.1, %while.cond29 ], [ %dest.addr.1, %land.lhs.true33 ], [ %dest.addr.1, %land.lhs.true36 ], [ %dest.addr.1, %land.rhs40 ]
  store i8 0, i8* %dest.addr.2, align 1, !tbaa !49
  br label %while.cond50

while.cond50:                                     ; preds = %while.body59, %if.end49
  %src.addr.5 = phi i8* [ %src.addr.4, %if.end49 ], [ %incdec.ptr60, %while.body59 ]
  %13 = load i8, i8* %src.addr.5, align 1, !tbaa !49
  %conv51 = sext i8 %13 to i32
  %cmp52 = icmp eq i32 %conv51, 32
  br i1 %cmp52, label %while.body59, label %lor.rhs54

lor.rhs54:                                        ; preds = %while.cond50
  %14 = load i8, i8* %src.addr.5, align 1, !tbaa !49
  %conv55 = sext i8 %14 to i32
  %cmp56 = icmp eq i32 %conv55, 9
  br i1 %cmp56, label %while.body59, label %while.end61

while.body59:                                     ; preds = %lor.rhs54, %while.cond50
  %incdec.ptr60 = getelementptr inbounds i8, i8* %src.addr.5, i32 1
  br label %while.cond50

while.end61:                                      ; preds = %lor.rhs54
  ret i8* %src.addr.5
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_get_line(%struct.snd_info_buffer* %buffer, i8* %line, i32 %len) #0 {
entry:
  %tobool = icmp ne %struct.snd_info_buffer* %buffer, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %buffer1 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %0 = load i8*, i8** %buffer1, align 8, !tbaa !50
  %tobool2 = icmp ne i8* %0, null
  %lnot = xor i1 %tobool2, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %1 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot3 = xor i1 %1, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool5 = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.13.115, i32 0, i32 0), i32 637)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %tobool11 = icmp ne i32 %lnot.ext, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  %cmp = icmp sle i32 %len, 0
  %or.cond = or i1 %tobool18, %cmp
  br i1 %or.cond, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %stop = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  %2 = load i32, i32* %stop, align 4, !tbaa !315
  %tobool22 = icmp ne i32 %2, 0
  br i1 %tobool22, label %cleanup, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %lor.lhs.false
  %error = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 5
  %3 = load i32, i32* %error, align 8, !tbaa !316
  %tobool24 = icmp ne i32 %3, 0
  br i1 %tobool24, label %cleanup, label %if.end26

if.end26:                                         ; preds = %lor.lhs.false23
  br label %while.cond

while.cond:                                       ; preds = %if.end47, %if.end26
  %len.addr.0 = phi i32 [ %len, %if.end26 ], [ %len.addr.1, %if.end47 ]
  %line.addr.0 = phi i8* [ %line, %if.end26 ], [ %line.addr.1, %if.end47 ]
  %stop27 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  %4 = load i32, i32* %stop27, align 4, !tbaa !315
  %tobool28 = icmp ne i32 %4, 0
  %lnot29 = xor i1 %tobool28, true
  br i1 %lnot29, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %buffer31 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %5 = load i8*, i8** %buffer31, align 8, !tbaa !50
  %curr = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 1
  %6 = load i32, i32* %curr, align 8, !tbaa !317
  %inc = add i32 %6, 1
  store i32 %inc, i32* %curr, align 8, !tbaa !317
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr inbounds i8, i8* %5, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv32 = sext i8 %7 to i32
  %curr33 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 1
  %8 = load i32, i32* %curr33, align 8, !tbaa !317
  %size = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 2
  %9 = load i32, i32* %size, align 4, !tbaa !296
  %cmp34 = icmp uge i32 %8, %9
  br i1 %cmp34, label %if.then36, label %if.end38

if.then36:                                        ; preds = %while.body
  %stop37 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  store i32 1, i32* %stop37, align 4, !tbaa !315
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %while.body
  %cmp39 = icmp eq i32 %conv32, 10
  br i1 %cmp39, label %while.end, label %if.end42

if.end42:                                         ; preds = %if.end38
  %cmp43 = icmp sgt i32 %len.addr.0, 1
  br i1 %cmp43, label %if.then45, label %if.end47

if.then45:                                        ; preds = %if.end42
  %dec = add nsw i32 %len.addr.0, -1
  %conv46 = trunc i32 %conv32 to i8
  %incdec.ptr = getelementptr inbounds i8, i8* %line.addr.0, i32 1
  store i8 %conv46, i8* %line.addr.0, align 1, !tbaa !49
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %if.end42
  %len.addr.1 = phi i32 [ %dec, %if.then45 ], [ %len.addr.0, %if.end42 ]
  %line.addr.1 = phi i8* [ %incdec.ptr, %if.then45 ], [ %line.addr.0, %if.end42 ]
  br label %while.cond

while.end:                                        ; preds = %if.end38, %while.cond
  store i8 0, i8* %line.addr.0, align 1, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %while.end, %lor.lhs.false23, %lor.lhs.false, %if.end
  %retval.0 = phi i32 [ 0, %while.end ], [ 1, %if.end ], [ 1, %lor.lhs.false23 ], [ 1, %lor.lhs.false ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_check_reserved_words(i8* %str) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %xstr.0 = phi i8** [ getelementptr inbounds ([12 x i8*], [12 x i8*]* @snd_info_check_reserved_words.reserved, i32 0, i32 0), %entry ], [ %incdec.ptr, %if.end ]
  %0 = load i8*, i8** %xstr.0, align 8, !tbaa !2
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i8*, i8** %xstr.0, align 8, !tbaa !2
  %call = call i32 @strcmp(i8* %1, i8* %str)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.end, label %cleanup

if.end:                                           ; preds = %while.body
  %incdec.ptr = getelementptr inbounds i8*, i8** %xstr.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %call2 = call i32 @strncmp(i8* %str, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11.141, i32 0, i32 0), i64 4)
  %tobool3 = icmp ne i32 %call2, 0
  %. = select i1 %tobool3, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %while.end, %while.body
  %retval.0 = phi i32 [ 0, %while.body ], [ %., %while.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_init() #4 section ".init.text" {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_entry(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12.155, i32 0, i32 0), %struct.snd_info_entry* null)
  store %struct.snd_info_entry* %call, %struct.snd_info_entry** @snd_proc_root, align 8, !tbaa !2
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_proc_root, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_info_entry* %0, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_proc_root, align 8, !tbaa !2
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %1, i32 0, i32 1
  store i16 16749, i16* %mode, align 8, !tbaa !287
  %call1 = call %struct.proc_dir_entry* @proc_mkdir(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12.155, i32 0, i32 0), %struct.proc_dir_entry* null)
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_proc_root, align 8, !tbaa !2
  %p = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 10
  store %struct.proc_dir_entry* %call1, %struct.proc_dir_entry** %p, align 8, !tbaa !286
  %3 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_proc_root, align 8, !tbaa !2
  %p2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 10
  %4 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p2, align 8, !tbaa !286
  %tobool3 = icmp ne %struct.proc_dir_entry* %4, null
  br i1 %tobool3, label %if.end5, label %error

if.end5:                                          ; preds = %if.end
  %call6 = call %struct.snd_info_entry* @create_subdir(%struct.module* @__this_module, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.147, i32 0, i32 0))
  store %struct.snd_info_entry* %call6, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  %5 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  %tobool7 = icmp ne %struct.snd_info_entry* %5, null
  br i1 %tobool7, label %if.end9, label %error

if.end9:                                          ; preds = %if.end5
  %call10 = call %struct.snd_info_entry* @create_subdir(%struct.module* @__this_module, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10.152, i32 0, i32 0))
  store %struct.snd_info_entry* %call10, %struct.snd_info_entry** @snd_seq_root, align 8, !tbaa !2
  %6 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_seq_root, align 8, !tbaa !2
  %tobool11 = icmp ne %struct.snd_info_entry* %6, null
  br i1 %tobool11, label %if.end13, label %error

if.end13:                                         ; preds = %if.end9
  %call14 = call i32 @snd_info_version_init()
  %cmp = icmp slt i32 %call14, 0
  br i1 %cmp, label %error, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end13
  %call15 = call i32 @snd_minor_info_init()
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %error, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false
  %call18 = call i32 @snd_minor_info_oss_init()
  %cmp19 = icmp slt i32 %call18, 0
  br i1 %cmp19, label %error, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false17
  %call21 = call i32 @snd_card_info_init()
  %cmp22 = icmp slt i32 %call21, 0
  br i1 %cmp22, label %error, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %lor.lhs.false20
  %call24 = call i32 @snd_info_minor_register()
  %cmp25 = icmp slt i32 %call24, 0
  br i1 %cmp25, label %error, label %return

error:                                            ; preds = %lor.lhs.false23, %lor.lhs.false20, %lor.lhs.false17, %lor.lhs.false, %if.end13, %if.end9, %if.end5, %if.end
  %7 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_proc_root, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %7)
  br label %return

return:                                           ; preds = %error, %lor.lhs.false23, %entry
  %retval.0 = phi i32 [ -12, %error ], [ -12, %entry ], [ 0, %lor.lhs.false23 ]
  ret i32 %retval.0
}

declare %struct.proc_dir_entry* @proc_mkdir(i8*, %struct.proc_dir_entry*) #1

; Function Attrs: nounwind uwtable
define internal %struct.snd_info_entry* @create_subdir(%struct.module* %mod, i8* %name) #0 {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* %mod, i8* %name, %struct.snd_info_entry* null)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 1
  store i16 16749, i16* %mode, align 8, !tbaa !287
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %cleanup

if.then3:                                         ; preds = %if.end
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.then3, %if.end, %entry
  %retval.0 = phi %struct.snd_info_entry* [ null, %if.then3 ], [ null, %entry ], [ %call, %if.end ]
  ret %struct.snd_info_entry* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_version_init() #4 section ".init.text" {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.142, i32 0, i32 0), %struct.snd_info_entry* null)
  %cmp = icmp eq %struct.snd_info_entry* %call, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.58* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_info_version_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !49
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call2, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_info_version_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  %buffer2 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %0 = load i8*, i8** %buffer2, align 8, !tbaa !50
  %1 = bitcast i8* %0 to %struct.seq_file*
  %call = call %struct.new_utsname* @init_utsname()
  %release = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call, i32 0, i32 2
  %arraydecay = getelementptr inbounds [65 x i8], [65 x i8]* %release, i32 0, i32 0
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %1, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.20.156, i32 0, i32 0), i8* %arraydecay)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.new_utsname* @init_utsname() #5 {
entry:
  ret %struct.new_utsname* getelementptr inbounds (%struct.uts_namespace, %struct.uts_namespace* @init_uts_ns, i32 0, i32 1)
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_done() #4 section ".exit.text" {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_proc_root, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_card_create(%struct.snd_card* %card) #0 {
entry:
  %str = alloca [8 x i8], align 1
  %0 = bitcast [8 x i8]* %str to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.13.115, i32 0, i32 0), i32 515)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool10 = icmp ne i32 %lnot.ext, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %str, i32 0, i32 0
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number, align 8, !tbaa !10
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.14.161, i32 0, i32 0), i32 %1)
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 8
  %2 = load %struct.module*, %struct.module** %module, align 8, !tbaa !136
  %arraydecay20 = getelementptr inbounds [8 x i8], [8 x i8]* %str, i32 0, i32 0
  %call21 = call %struct.snd_info_entry* @create_subdir(%struct.module* %2, i8* %arraydecay20)
  %tobool22 = icmp ne %struct.snd_info_entry* %call21, null
  br i1 %tobool22, label %if.end24, label %cleanup

if.end24:                                         ; preds = %if.end19
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  store %struct.snd_info_entry* %call21, %struct.snd_info_entry** %proc_root, align 8, !tbaa !124
  br label %cleanup

cleanup:                                          ; preds = %if.end24, %if.end19, %if.end
  %retval.0 = phi i32 [ 0, %if.end24 ], [ -6, %if.end ], [ -12, %if.end19 ]
  %3 = bitcast [8 x i8]* %str to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_card_register(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.13.115, i32 0, i32 0), i32 557)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !124
  %call = call i32 @snd_info_register_recursive(%struct.snd_info_entry* %0)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end21

if.end21:                                         ; preds = %if.end18
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %proc_root22 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root22, align 8, !tbaa !124
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %1, i32 0, i32 0
  %2 = load i8*, i8** %name, align 8, !tbaa !125
  %call23 = call i32 @strcmp(i8* %arraydecay, i8* %2)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.end26, label %cleanup

if.end26:                                         ; preds = %if.end21
  %proc_root_link = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  %3 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_root_link, align 8, !tbaa !318
  %tobool27 = icmp ne %struct.proc_dir_entry* %3, null
  br i1 %tobool27, label %cleanup, label %if.end29

if.end29:                                         ; preds = %if.end26
  %id30 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay31 = getelementptr inbounds [16 x i8], [16 x i8]* %id30, i32 0, i32 0
  %4 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_proc_root, align 8, !tbaa !2
  %p32 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %4, i32 0, i32 10
  %5 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p32, align 8, !tbaa !286
  %proc_root33 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %6 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root33, align 8, !tbaa !124
  %name34 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %6, i32 0, i32 0
  %7 = load i8*, i8** %name34, align 8, !tbaa !125
  %call35 = call %struct.proc_dir_entry* @proc_symlink(i8* %arraydecay31, %struct.proc_dir_entry* %5, i8* %7)
  %tobool36 = icmp ne %struct.proc_dir_entry* %call35, null
  br i1 %tobool36, label %if.end38, label %cleanup

if.end38:                                         ; preds = %if.end29
  %proc_root_link39 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  store %struct.proc_dir_entry* %call35, %struct.proc_dir_entry** %proc_root_link39, align 8, !tbaa !318
  br label %cleanup

cleanup:                                          ; preds = %if.end38, %if.end29, %if.end26, %if.end21, %if.end18, %if.end
  %retval.0 = phi i32 [ 0, %if.end38 ], [ -6, %if.end ], [ %call, %if.end18 ], [ 0, %if.end21 ], [ 0, %if.end26 ], [ -12, %if.end29 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_register_recursive(%struct.snd_info_entry* %entry1) #0 {
entry:
  %p2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p2, align 8, !tbaa !286
  %tobool = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @snd_info_register(%struct.snd_info_entry* %entry1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.then, %entry
  %children = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 12
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %list12.sink = phi %struct.list_head* [ %list12, %for.inc ], [ %children, %if.end4 ]
  %next13 = getelementptr inbounds %struct.list_head, %struct.list_head* %list12.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next13, align 8, !tbaa !2
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr15 = getelementptr inbounds i8, i8* %2, i64 -272
  %3 = bitcast i8* %add.ptr15 to %struct.snd_info_entry*
  %list = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 13
  %children5 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 12
  %cmp6 = icmp ne %struct.list_head* %list, %children5
  br i1 %cmp6, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %call7 = call i32 @snd_info_register_recursive(%struct.snd_info_entry* %3)
  %cmp8 = icmp slt i32 %call7, 0
  br i1 %cmp8, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %list12 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 13
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call7, %for.body ], [ 0, %for.cond ]
  ret i32 %retval.0
}

declare %struct.proc_dir_entry* @proc_symlink(i8*, %struct.proc_dir_entry*, i8*) #1

; Function Attrs: nounwind uwtable
define void @snd_info_card_id_change(%struct.snd_card* %card) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  %proc_root_link = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_root_link, align 8, !tbaa !318
  %tobool = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %proc_root_link1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  %1 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_root_link1, align 8, !tbaa !318
  call void @proc_remove(%struct.proc_dir_entry* %1)
  %proc_root_link2 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %proc_root_link2, align 8, !tbaa !318
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !124
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 0
  %3 = load i8*, i8** %name, align 8, !tbaa !125
  %call = call i32 @strcmp(i8* %arraydecay, i8* %3)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.then4, label %if.end11

if.then4:                                         ; preds = %if.end
  %id5 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay6 = getelementptr inbounds [16 x i8], [16 x i8]* %id5, i32 0, i32 0
  %4 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_proc_root, align 8, !tbaa !2
  %p = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %4, i32 0, i32 10
  %5 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p, align 8, !tbaa !286
  %proc_root7 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %6 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root7, align 8, !tbaa !124
  %name8 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %6, i32 0, i32 0
  %7 = load i8*, i8** %name8, align 8, !tbaa !125
  %call9 = call %struct.proc_dir_entry* @proc_symlink(i8* %arraydecay6, %struct.proc_dir_entry* %5, i8* %7)
  %proc_root_link10 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  store %struct.proc_dir_entry* %call9, %struct.proc_dir_entry** %proc_root_link10, align 8, !tbaa !318
  br label %if.end11

if.end11:                                         ; preds = %if.then4, %if.end
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_info_card_disconnect(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @info_mutex, i32 0)
  %proc_root_link = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_root_link, align 8, !tbaa !318
  call void @proc_remove(%struct.proc_dir_entry* %0)
  %proc_root_link1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 23
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %proc_root_link1, align 8, !tbaa !318
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !124
  %tobool2 = icmp ne %struct.snd_info_entry* %1, null
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %proc_root4 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root4, align 8, !tbaa !124
  call void @snd_info_disconnect(%struct.snd_info_entry* %2)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %return

return:                                           ; preds = %if.end5, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_card_free(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !124
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  %proc_root1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 21
  store %struct.snd_info_entry* null, %struct.snd_info_entry** %proc_root1, align 8, !tbaa !124
  br label %return

return:                                           ; preds = %if.end, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_oss_info_register(i32 %dev, i32 %num, i8* %string) #0 {
entry:
  %cmp = icmp slt i32 %dev, 0
  %cmp1 = icmp sge i32 %dev, 6
  %.cmp1 = select i1 %cmp, i1 true, i1 %cmp1
  %lnot = xor i1 %.cmp1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot3 = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.171, i32 0, i32 0), i32 43)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool8 = icmp ne i32 %lnot.ext, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end
  %cmp19 = icmp slt i32 %num, 0
  %cmp22 = icmp sge i32 %num, 32
  %.cmp22 = select i1 %cmp19, i1 true, i1 %cmp22
  %lnot25 = xor i1 %.cmp22, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %tobool29 = icmp ne i32 %lnot.ext28, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end17
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.171, i32 0, i32 0), i32 45)
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.end17
  %tobool40 = icmp ne i32 %lnot.ext28, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  %expval46 = call i64 @llvm.expect.i64(i64 %conv45, i64 0)
  %tobool47 = icmp ne i64 %expval46, 0
  br i1 %tobool47, label %cleanup, label %if.end49

if.end49:                                         ; preds = %if.end38
  call void @mutex_lock_nested(%struct.mutex* @strings, i32 0)
  %cmp50 = icmp eq i8* %string, null
  br i1 %cmp50, label %if.then52, label %if.else

if.then52:                                        ; preds = %if.end49
  %idxprom = sext i32 %num to i64
  %arrayidx = getelementptr inbounds [32 x [6 x i8*]], [32 x [6 x i8*]]* @snd_sndstat_strings, i64 0, i64 %idxprom
  %idxprom53 = sext i32 %dev to i64
  %arrayidx54 = getelementptr inbounds [6 x i8*], [6 x i8*]* %arrayidx, i64 0, i64 %idxprom53
  %0 = load i8*, i8** %arrayidx54, align 8, !tbaa !2
  %cmp55 = icmp ne i8* %0, null
  br i1 %cmp55, label %if.then57, label %if.end63

if.then57:                                        ; preds = %if.then52
  call void @kfree(i8* %0)
  br label %if.end63

if.else:                                          ; preds = %if.end49
  %call = call noalias i8* @kstrdup(i8* %string, i32 20971712)
  %cmp59 = icmp eq i8* %call, null
  br i1 %cmp59, label %if.then61, label %if.end63

if.then61:                                        ; preds = %if.else
  call void @mutex_unlock(%struct.mutex* @strings)
  br label %cleanup

if.end63:                                         ; preds = %if.else, %if.then57, %if.then52
  %x.1 = phi i8* [ null, %if.then57 ], [ %0, %if.then52 ], [ %call, %if.else ]
  %idxprom64 = sext i32 %num to i64
  %arrayidx65 = getelementptr inbounds [32 x [6 x i8*]], [32 x [6 x i8*]]* @snd_sndstat_strings, i64 0, i64 %idxprom64
  %idxprom66 = sext i32 %dev to i64
  %arrayidx67 = getelementptr inbounds [6 x i8*], [6 x i8*]* %arrayidx65, i64 0, i64 %idxprom66
  store i8* %x.1, i8** %arrayidx67, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @strings)
  br label %cleanup

cleanup:                                          ; preds = %if.end63, %if.then61, %if.end38, %if.end
  %retval.0 = phi i32 [ 0, %if.end63 ], [ -12, %if.then61 ], [ -6, %if.end ], [ -6, %if.end38 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_minor_register() #4 section ".init.text" {
entry:
  %call = call i8* @__memset(i8* bitcast ([32 x [6 x i8*]]* @snd_sndstat_strings to i8*), i32 0, i64 1536)
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  %call2 = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1.176, i32 0, i32 0), %struct.snd_info_entry* %0)
  %tobool = icmp ne %struct.snd_info_entry* %call2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call2, i32 0, i32 4
  %text = bitcast %union.anon.58* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_sndstat_proc_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !49
  %call3 = call i32 @snd_info_register(%struct.snd_info_entry* %call2)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call3, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

declare i8* @__memset(i8*, i32, i64) #1

; Function Attrs: nounwind uwtable
define internal void @snd_sndstat_proc_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  %buffer2 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %0 = load i8*, i8** %buffer2, align 8, !tbaa !50
  %1 = bitcast i8* %0 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %1, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.4.177, i32 0, i32 0))
  %buffer3 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %2 = load i8*, i8** %buffer3, align 8, !tbaa !50
  %3 = bitcast i8* %2 to %struct.seq_file*
  %call = call %struct.new_utsname* @init_utsname.178()
  %sysname = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call, i32 0, i32 0
  %arraydecay = getelementptr inbounds [65 x i8], [65 x i8]* %sysname, i32 0, i32 0
  %call4 = call %struct.new_utsname* @init_utsname.178()
  %nodename = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call4, i32 0, i32 1
  %arraydecay5 = getelementptr inbounds [65 x i8], [65 x i8]* %nodename, i32 0, i32 0
  %call6 = call %struct.new_utsname* @init_utsname.178()
  %release = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call6, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [65 x i8], [65 x i8]* %release, i32 0, i32 0
  %call8 = call %struct.new_utsname* @init_utsname.178()
  %version = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call8, i32 0, i32 3
  %arraydecay9 = getelementptr inbounds [65 x i8], [65 x i8]* %version, i32 0, i32 0
  %call10 = call %struct.new_utsname* @init_utsname.178()
  %machine = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call10, i32 0, i32 4
  %arraydecay11 = getelementptr inbounds [65 x i8], [65 x i8]* %machine, i32 0, i32 0
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %3, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.5.179, i32 0, i32 0), i8* %arraydecay, i8* %arraydecay5, i8* %arraydecay7, i8* %arraydecay9, i8* %arraydecay11)
  %buffer12 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %4 = load i8*, i8** %buffer12, align 8, !tbaa !50
  %5 = bitcast i8* %4 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %5, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.6.180, i32 0, i32 0))
  %buffer13 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %6 = load i8*, i8** %buffer13, align 8, !tbaa !50
  %7 = bitcast i8* %6 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %7, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.7.181, i32 0, i32 0))
  %buffer14 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %8 = load i8*, i8** %buffer14, align 8, !tbaa !50
  %9 = bitcast i8* %8 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %9, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.8.182, i32 0, i32 0))
  %buffer15 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %10 = load i8*, i8** %buffer15, align 8, !tbaa !50
  %11 = bitcast i8* %10 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %11, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.9.183, i32 0, i32 0))
  call void @snd_card_info_read_oss(%struct.snd_info_buffer* %buffer)
  call void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.10.184, i32 0, i32 0), i32 0)
  call void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.11.185, i32 0, i32 0), i32 1)
  call void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.12.186, i32 0, i32 0), i32 2)
  call void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13.187, i32 0, i32 0), i32 4)
  call void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.14.188, i32 0, i32 0), i32 5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.new_utsname* @init_utsname.178() #5 {
entry:
  ret %struct.new_utsname* getelementptr inbounds (%struct.uts_namespace, %struct.uts_namespace* @init_uts_ns, i32 0, i32 1)
}

; Function Attrs: nounwind uwtable
define internal void @snd_sndstat_show_strings(%struct.snd_info_buffer* %buf, i8* %id, i32 %dev) #0 {
entry:
  %buffer = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buf, i32 0, i32 0
  %0 = load i8*, i8** %buffer, align 8, !tbaa !50
  %1 = bitcast i8* %0 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.15.189, i32 0, i32 0), i8* %id)
  call void @mutex_lock_nested(%struct.mutex* @strings, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %idx.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
  %ok.0 = phi i32 [ -1, %entry ], [ %ok.2, %for.inc ]
  %cmp = icmp slt i32 %idx.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [32 x [6 x i8*]], [32 x [6 x i8*]]* @snd_sndstat_strings, i64 0, i64 %idxprom
  %idxprom1 = sext i32 %dev to i64
  %arrayidx2 = getelementptr inbounds [6 x i8*], [6 x i8*]* %arrayidx, i64 0, i64 %idxprom1
  %2 = load i8*, i8** %arrayidx2, align 8, !tbaa !2
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %cmp3 = icmp slt i32 %ok.0, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %buffer5 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buf, i32 0, i32 0
  %3 = load i8*, i8** %buffer5, align 8, !tbaa !50
  %4 = bitcast i8* %3 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %4, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.16.190, i32 0, i32 0))
  %inc = add nsw i32 %ok.0, 1
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %ok.1 = phi i32 [ %inc, %if.then4 ], [ %ok.0, %if.then ]
  %buffer6 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buf, i32 0, i32 0
  %5 = load i8*, i8** %buffer6, align 8, !tbaa !50
  %6 = bitcast i8* %5 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %6, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.17.191, i32 0, i32 0), i32 %idx.0, i8* %2)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %ok.2 = phi i32 [ %ok.1, %if.end ], [ %ok.0, %for.body ]
  %inc8 = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @strings)
  %cmp9 = icmp slt i32 %ok.0, 0
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.end
  %buffer11 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buf, i32 0, i32 0
  %7 = load i8*, i8** %buffer11, align 8, !tbaa !50
  %8 = bitcast i8* %7 to %struct.seq_file*
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %8, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18.192, i32 0, i32 0))
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_dma_pointer(i64 %dma, i32 %size) #0 {
entry:
  %call = call i64 @claim_dma_lock()
  %conv = trunc i64 %dma to i32
  call void @clear_dma_ff(i32 %conv)
  %0 = load i32, i32* @isa_dma_bridge_buggy, align 4, !tbaa !47
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %conv1 = trunc i64 %dma to i32
  call void @disable_dma(i32 %conv1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %conv2 = trunc i64 %dma to i32
  %call3 = call i32 @get_dma_residue(i32 %conv2)
  %conv4 = trunc i64 %dma to i32
  %call5 = call i32 @get_dma_residue(i32 %conv4)
  %1 = load i32, i32* @isa_dma_bridge_buggy, align 4, !tbaa !47
  %tobool6 = icmp ne i32 %1, 0
  br i1 %tobool6, label %if.end9, label %if.then7

if.then7:                                         ; preds = %if.end
  %conv8 = trunc i64 %dma to i32
  call void @enable_dma(i32 %conv8)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  call void @release_dma_lock(i64 %call)
  %cmp = icmp ult i32 %call3, %call5
  %lnot = xor i1 %cmp, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv12 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  %call5.call3 = select i1 %tobool13, i32 %call5, i32 %call3
  %cmp16 = icmp ugt i32 %call5.call3, %size
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end9
  %call19 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([74 x i8], [74 x i8]* @.str.194, i32 0, i32 0), i32 %call5.call3, i64 %dma, i32 %size)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end9
  %cmp21 = icmp uge i32 %call5.call3, %size
  %cmp23 = icmp eq i32 %call5.call3, 0
  %or.cond = or i1 %cmp21, %cmp23
  %sub = sub i32 %size, %call5.call3
  %retval.0 = select i1 %or.cond, i32 0, i32 %sub
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @claim_dma_lock() #5 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #9
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #9
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %call = call %struct.raw_spinlock* @spinlock_check.196(%struct.spinlock* @dma_spin_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  ret i64 %call2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @clear_dma_ff(i32 %dmanr) #5 {
entry:
  %cmp = icmp ule i32 %dmanr, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @outb(i8 zeroext 0, i32 12)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @outb(i8 zeroext 0, i32 216)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @disable_dma(i32 %dmanr) #5 {
entry:
  %cmp = icmp ule i32 %dmanr, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %or = or i32 %dmanr, 4
  %conv = trunc i32 %or to i8
  call void @outb(i8 zeroext %conv, i32 10)
  br label %if.end

if.else:                                          ; preds = %entry
  %and = and i32 %dmanr, 3
  %or1 = or i32 %and, 4
  %conv2 = trunc i32 %or1 to i8
  call void @outb(i8 zeroext %conv2, i32 212)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @get_dma_residue(i32 %dmanr) #5 {
entry:
  %cmp = icmp ule i32 %dmanr, 3
  %and = and i32 %dmanr, 3
  %.sink2 = select i1 %cmp, i32 1, i32 2
  %.sink = select i1 %cmp, i32 0, i32 192
  %shl3 = shl i32 %and, %.sink2
  %add4 = add i32 %shl3, %.sink2
  %add5 = add i32 %add4, %.sink
  %call = call zeroext i8 @inb(i32 %add5)
  %conv = zext i8 %call to i32
  %add6 = add nsw i32 1, %conv
  %conv7 = trunc i32 %add6 to i16
  %call8 = call zeroext i8 @inb(i32 %add5)
  %conv9 = zext i8 %call8 to i32
  %shl10 = shl i32 %conv9, 8
  %conv11 = zext i16 %conv7 to i32
  %add12 = add nsw i32 %conv11, %shl10
  %conv13 = trunc i32 %add12 to i16
  %cmp14 = icmp ule i32 %dmanr, 3
  %conv17 = zext i16 %conv13 to i32
  %shl20 = shl i32 %conv17, 1
  %cond22 = select i1 %cmp14, i32 %conv17, i32 %shl20
  ret i32 %cond22
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @enable_dma(i32 %dmanr) #5 {
entry:
  %cmp = icmp ule i32 %dmanr, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv = trunc i32 %dmanr to i8
  call void @outb(i8 zeroext %conv, i32 10)
  br label %if.end

if.else:                                          ; preds = %entry
  %and = and i32 %dmanr, 3
  %conv1 = trunc i32 %and to i8
  call void @outb(i8 zeroext %conv1, i32 212)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @release_dma_lock(i64 %flags) #5 {
entry:
  call void @spin_unlock_irqrestore.195(%struct.spinlock* @dma_spin_lock, i64 %flags)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock_irqrestore.195(%struct.spinlock* %lock, i64 %flags) #3 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #9
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #9
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #5 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #9, !srcloc !319
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #5 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #9, !srcloc !320
  ret i8 %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.196(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: nounwind uwtable
define void @snd_dma_disable(i64 %dma) #0 {
entry:
  %call = call i64 @claim_dma_lock()
  %conv = trunc i64 %dma to i32
  call void @clear_dma_ff(i32 %conv)
  %conv1 = trunc i64 %dma to i32
  call void @disable_dma(i32 %conv1)
  call void @release_dma_lock(i64 %call)
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_dma_program(i64 %dma, i64 %addr, i32 %size, i16 zeroext %mode) #0 {
entry:
  %call = call i64 @claim_dma_lock()
  %conv = trunc i64 %dma to i32
  call void @disable_dma(i32 %conv)
  %conv1 = trunc i64 %dma to i32
  call void @clear_dma_ff(i32 %conv1)
  %conv2 = trunc i64 %dma to i32
  %conv3 = trunc i16 %mode to i8
  call void @set_dma_mode(i32 %conv2, i8 signext %conv3)
  %conv4 = trunc i64 %dma to i32
  %conv5 = trunc i64 %addr to i32
  call void @set_dma_addr(i32 %conv4, i32 %conv5)
  %conv6 = trunc i64 %dma to i32
  call void @set_dma_count(i32 %conv6, i32 %size)
  %conv7 = zext i16 %mode to i32
  %and = and i32 %conv7, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %conv8 = trunc i64 %dma to i32
  call void @enable_dma(i32 %conv8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @release_dma_lock(i64 %call)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @set_dma_mode(i32 %dmanr, i8 signext %mode) #5 {
entry:
  %cmp = icmp ule i32 %dmanr, 3
  %conv = sext i8 %mode to i32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %or = or i32 %conv, %dmanr
  %conv1 = trunc i32 %or to i8
  call void @outb(i8 zeroext %conv1, i32 11)
  br label %if.end

if.else:                                          ; preds = %entry
  %and = and i32 %dmanr, 3
  %or3 = or i32 %conv, %and
  %conv4 = trunc i32 %or3 to i8
  call void @outb(i8 zeroext %conv4, i32 214)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @set_dma_addr(i32 %dmanr, i32 %a) #5 {
entry:
  %shr = lshr i32 %a, 16
  %conv = trunc i32 %shr to i8
  call void @set_dma_page(i32 %dmanr, i8 signext %conv)
  %cmp = icmp ule i32 %dmanr, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %and = and i32 %a, 255
  %conv2 = trunc i32 %and to i8
  %and3 = and i32 %dmanr, 3
  %shl = shl i32 %and3, 1
  %add = add i32 %shl, 0
  call void @outb(i8 zeroext %conv2, i32 %add)
  %shr4 = lshr i32 %a, 8
  %and5 = and i32 %shr4, 255
  %conv6 = trunc i32 %and5 to i8
  %and7 = and i32 %dmanr, 3
  %shl8 = shl i32 %and7, 1
  %add9 = add i32 %shl8, 0
  call void @outb(i8 zeroext %conv6, i32 %add9)
  br label %if.end

if.else:                                          ; preds = %entry
  %shr10 = lshr i32 %a, 1
  %and11 = and i32 %shr10, 255
  %conv12 = trunc i32 %and11 to i8
  %and13 = and i32 %dmanr, 3
  %shl14 = shl i32 %and13, 2
  %add15 = add i32 %shl14, 192
  call void @outb(i8 zeroext %conv12, i32 %add15)
  %shr16 = lshr i32 %a, 9
  %and17 = and i32 %shr16, 255
  %conv18 = trunc i32 %and17 to i8
  %and19 = and i32 %dmanr, 3
  %shl20 = shl i32 %and19, 2
  %add21 = add i32 %shl20, 192
  call void @outb(i8 zeroext %conv18, i32 %add21)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @set_dma_count(i32 %dmanr, i32 %count) #5 {
entry:
  %dec = add i32 %count, -1
  %cmp = icmp ule i32 %dmanr, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %and = and i32 %dec, 255
  %conv = trunc i32 %and to i8
  %and1 = and i32 %dmanr, 3
  %shl = shl i32 %and1, 1
  %add = add i32 %shl, 1
  %add2 = add i32 %add, 0
  call void @outb(i8 zeroext %conv, i32 %add2)
  %shr = lshr i32 %dec, 8
  %and3 = and i32 %shr, 255
  %conv4 = trunc i32 %and3 to i8
  %and5 = and i32 %dmanr, 3
  %shl6 = shl i32 %and5, 1
  %add7 = add i32 %shl6, 1
  %add8 = add i32 %add7, 0
  call void @outb(i8 zeroext %conv4, i32 %add8)
  br label %if.end

if.else:                                          ; preds = %entry
  %shr9 = lshr i32 %dec, 1
  %and10 = and i32 %shr9, 255
  %conv11 = trunc i32 %and10 to i8
  %and12 = and i32 %dmanr, 3
  %shl13 = shl i32 %and12, 2
  %add14 = add i32 %shl13, 2
  %add15 = add i32 %add14, 192
  call void @outb(i8 zeroext %conv11, i32 %add15)
  %shr16 = lshr i32 %dec, 9
  %and17 = and i32 %shr16, 255
  %conv18 = trunc i32 %and17 to i8
  %and19 = and i32 %dmanr, 3
  %shl20 = shl i32 %and19, 2
  %add21 = add i32 %shl20, 2
  %add22 = add i32 %add21, 192
  call void @outb(i8 zeroext %conv18, i32 %add22)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @set_dma_page(i32 %dmanr, i8 signext %pagenr) #5 {
entry:
  %Pivot14 = icmp slt i32 %dmanr, 3
  br i1 %Pivot14, label %NodeBlock1, label %NodeBlock11

NodeBlock11:                                      ; preds = %entry
  %Pivot12 = icmp slt i32 %dmanr, 6
  br i1 %Pivot12, label %NodeBlock5, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %dmanr, 7
  br i1 %Pivot10, label %sw.bb6, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %dmanr, 7
  br i1 %SwitchLeaf8, label %sw.bb10, label %sw.epilog

NodeBlock5:                                       ; preds = %NodeBlock11
  %Pivot6 = icmp slt i32 %dmanr, 5
  br i1 %Pivot6, label %LeafBlock3, label %sw.bb4

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %dmanr, 3
  br i1 %SwitchLeaf4, label %sw.bb3, label %sw.epilog

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %dmanr, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %dmanr, 2
  br i1 %Pivot, label %sw.bb1, label %sw.bb2

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %dmanr, 0
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  call void @outb(i8 zeroext %pagenr, i32 135)
  br label %sw.epilog

sw.bb1:                                           ; preds = %NodeBlock
  call void @outb(i8 zeroext %pagenr, i32 131)
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock
  call void @outb(i8 zeroext %pagenr, i32 129)
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock3
  call void @outb(i8 zeroext %pagenr, i32 130)
  br label %sw.epilog

sw.bb4:                                           ; preds = %NodeBlock5
  %conv = sext i8 %pagenr to i32
  %and = and i32 %conv, 254
  %conv5 = trunc i32 %and to i8
  call void @outb(i8 zeroext %conv5, i32 139)
  br label %sw.epilog

sw.bb6:                                           ; preds = %NodeBlock9
  %conv7 = sext i8 %pagenr to i32
  %and8 = and i32 %conv7, 254
  %conv9 = trunc i32 %and8 to i8
  call void @outb(i8 zeroext %conv9, i32 137)
  br label %sw.epilog

sw.bb10:                                          ; preds = %LeafBlock7
  %conv11 = sext i8 %pagenr to i32
  %and12 = and i32 %conv11, 254
  %conv13 = trunc i32 %and12 to i8
  call void @outb(i8 zeroext %conv13, i32 138)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb10, %sw.bb6, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb, %LeafBlock, %LeafBlock3, %LeafBlock7
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_unregister_oss_device(i32 %type, %struct.snd_card* %card, i32 %dev) #0 {
entry:
  %call = call i32 @snd_oss_kernel_minor(i32 %type, %struct.snd_card* %card, i32 %dev)
  %shr = ashr i32 %call, 4
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %0 = load i32, i32* %number, align 8, !tbaa !10
  %cmp = icmp sge i32 %0, 16
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  call void @mutex_lock_nested(%struct.mutex* @sound_oss_mutex, i32 0)
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom
  %1 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %cmp4 = icmp eq %struct.snd_minor* %1, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  br label %cleanup

if.end6:                                          ; preds = %if.end3
  call void @unregister_sound_special(i32 %call)
  %and = and i32 %call, 15
  %Pivot6 = icmp slt i32 %and, 3
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.end6
  %Pivot = icmp slt i32 %and, 13
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %and, 13
  br i1 %SwitchLeaf4, label %sw.bb10, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 3
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.epilog

LeafBlock:                                        ; preds = %if.end6
  %SwitchLeaf = icmp eq i32 %and, 2
  br i1 %SwitchLeaf, label %sw.bb7, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock1
  %shl = shl i32 %shr, 4
  %or = or i32 %shl, 4
  br label %sw.epilog

sw.bb7:                                           ; preds = %LeafBlock
  %shl8 = shl i32 %shr, 4
  %or9 = or i32 %shl8, 9
  br label %sw.epilog

sw.bb10:                                          ; preds = %LeafBlock3
  %shl11 = shl i32 %shr, 4
  %or12 = or i32 %shl11, 14
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb10, %sw.bb7, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3
  %track2.0 = phi i32 [ %or9, %sw.bb7 ], [ %or, %sw.bb ], [ %or12, %sw.bb10 ], [ -1, %LeafBlock3 ], [ -1, %LeafBlock1 ], [ -1, %LeafBlock ]
  %cmp13 = icmp sge i32 %track2.0, 0
  br i1 %cmp13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %sw.epilog
  call void @unregister_sound_special(i32 %track2.0)
  %idxprom15 = sext i32 %track2.0 to i64
  %arrayidx16 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom15
  store %struct.snd_minor* null, %struct.snd_minor** %arrayidx16, align 8, !tbaa !2
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %sw.epilog
  %idxprom18 = sext i32 %call to i64
  %arrayidx19 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom18
  store %struct.snd_minor* null, %struct.snd_minor** %arrayidx19, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  %2 = bitcast %struct.snd_minor* %1 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %if.then5, %if.end, %land.lhs.true
  %retval.0 = phi i32 [ -2, %if.then5 ], [ 0, %if.end17 ], [ 0, %land.lhs.true ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_oss_kernel_minor(i32 %type, %struct.snd_card* %card, i32 %dev) #0 {
entry:
  %Pivot12 = icmp slt i32 %type, 3
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %type, 5
  br i1 %Pivot10, label %NodeBlock3, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %type, 6
  br i1 %Pivot8, label %sw.epilog, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %type, 6
  br i1 %SwitchLeaf6, label %sw.epilog, label %cleanup

NodeBlock3:                                       ; preds = %NodeBlock9
  %Pivot4 = icmp slt i32 %type, 4
  br i1 %Pivot4, label %sw.bb62, label %sw.bb102

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %type, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %type, 2
  br i1 %Pivot, label %sw.epilog, label %sw.bb22

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %type, 0
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %tobool = icmp eq %struct.snd_card* %card, null
  %cmp = icmp slt i32 %dev, 0
  %or.cond = or i1 %tobool, %cmp
  %cmp1 = icmp sgt i32 %dev, 1
  %.cmp1 = select i1 %or.cond, i1 true, i1 %cmp1
  %lnot = xor i1 %.cmp1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3.200, i32 0, i32 0), i32 67)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %0 = load i32, i32* %number, align 8, !tbaa !10
  %shl = shl i32 %0, 4
  %tobool19 = icmp ne i32 %dev, 0
  %1 = zext i1 %tobool19 to i64
  %cond = select i1 %tobool19, i32 11, i32 0
  %or = or i32 %shl, %cond
  br label %sw.epilog

sw.bb22:                                          ; preds = %NodeBlock
  %tobool24 = icmp eq %struct.snd_card* %card, null
  %cmp26 = icmp slt i32 %dev, 0
  %or.cond13 = or i1 %tobool24, %cmp26
  %cmp29 = icmp sgt i32 %dev, 1
  %.cmp29 = select i1 %or.cond13, i1 true, i1 %cmp29
  %lnot32 = xor i1 %.cmp29, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %tobool36 = icmp ne i32 %lnot.ext35, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %expval42 = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %tobool43 = icmp ne i64 %expval42, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %sw.bb22
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3.200, i32 0, i32 0), i32 78)
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %sw.bb22
  %tobool47 = icmp ne i32 %lnot.ext35, 0
  %lnot48 = xor i1 %tobool47, true
  %lnot50 = xor i1 %lnot48, true
  %lnot.ext51 = zext i1 %lnot50 to i32
  %conv52 = sext i32 %lnot.ext51 to i64
  %expval53 = call i64 @llvm.expect.i64(i64 %conv52, i64 0)
  %tobool54 = icmp ne i64 %expval53, 0
  br i1 %tobool54, label %cleanup, label %if.end56

if.end56:                                         ; preds = %if.end45
  %number57 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %2 = load i32, i32* %number57, align 8, !tbaa !10
  %shl58 = shl i32 %2, 4
  %tobool59 = icmp ne i32 %dev, 0
  %3 = zext i1 %tobool59 to i64
  %cond60 = select i1 %tobool59, i32 12, i32 3
  %or61 = or i32 %shl58, %cond60
  br label %sw.epilog

sw.bb62:                                          ; preds = %NodeBlock3
  %tobool64 = icmp eq %struct.snd_card* %card, null
  %cmp66 = icmp slt i32 %dev, 0
  %or.cond14 = or i1 %tobool64, %cmp66
  %cmp69 = icmp sgt i32 %dev, 1
  %.cmp69 = select i1 %or.cond14, i1 true, i1 %cmp69
  %lnot72 = xor i1 %.cmp69, true
  %lnot74 = xor i1 %lnot72, true
  %lnot.ext75 = zext i1 %lnot74 to i32
  %tobool76 = icmp ne i32 %lnot.ext75, 0
  %lnot77 = xor i1 %tobool76, true
  %lnot79 = xor i1 %lnot77, true
  %lnot.ext80 = zext i1 %lnot79 to i32
  %conv81 = sext i32 %lnot.ext80 to i64
  %expval82 = call i64 @llvm.expect.i64(i64 %conv81, i64 0)
  %tobool83 = icmp ne i64 %expval82, 0
  br i1 %tobool83, label %if.then84, label %if.end85

if.then84:                                        ; preds = %sw.bb62
  call void @warn_slowpath_null(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3.200, i32 0, i32 0), i32 83)
  br label %if.end85

if.end85:                                         ; preds = %if.then84, %sw.bb62
  %tobool87 = icmp ne i32 %lnot.ext75, 0
  %lnot88 = xor i1 %tobool87, true
  %lnot90 = xor i1 %lnot88, true
  %lnot.ext91 = zext i1 %lnot90 to i32
  %conv92 = sext i32 %lnot.ext91 to i64
  %expval93 = call i64 @llvm.expect.i64(i64 %conv92, i64 0)
  %tobool94 = icmp ne i64 %expval93, 0
  br i1 %tobool94, label %cleanup, label %if.end96

if.end96:                                         ; preds = %if.end85
  %number97 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %4 = load i32, i32* %number97, align 8, !tbaa !10
  %shl98 = shl i32 %4, 4
  %tobool99 = icmp ne i32 %dev, 0
  %5 = zext i1 %tobool99 to i64
  %cond100 = select i1 %tobool99, i32 13, i32 2
  %or101 = or i32 %shl98, %cond100
  br label %sw.epilog

sw.bb102:                                         ; preds = %NodeBlock3
  %number103 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %6 = load i32, i32* %number103, align 8, !tbaa !10
  %shl104 = shl i32 %6, 4
  %or105 = or i32 %shl104, 10
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb102, %if.end96, %if.end56, %if.end18, %NodeBlock, %LeafBlock5, %NodeBlock7
  %minor.0 = phi i32 [ %or, %if.end18 ], [ %or61, %if.end56 ], [ %or101, %if.end96 ], [ %or105, %sw.bb102 ], [ 1, %NodeBlock ], [ 8, %LeafBlock5 ], [ 6, %NodeBlock7 ]
  %cmp107 = icmp slt i32 %minor.0, 0
  %cmp110 = icmp sge i32 %minor.0, 256
  %or.cond15 = or i1 %cmp107, %cmp110
  %.minor.0 = select i1 %or.cond15, i32 -22, i32 %minor.0
  br label %UnifiedReturnBlock

cleanup:                                          ; preds = %if.end85, %if.end45, %if.end, %LeafBlock, %LeafBlock5
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %cleanup, %sw.epilog
  %UnifiedRetVal = phi i32 [ %.minor.0, %sw.epilog ], [ -22, %cleanup ]
  ret i32 %UnifiedRetVal
}

declare void @unregister_sound_special(i32) #1

; Function Attrs: nounwind uwtable
define i32 @snd_register_oss_device(i32 %type, %struct.snd_card* %card, i32 %dev, %struct.file_operations* %f_ops, i8* %private_data) #0 {
entry:
  %call = call i32 @snd_oss_kernel_minor(i32 %type, %struct.snd_card* %card, i32 %dev)
  %shr = ashr i32 %call, 4
  %call1 = call %struct.device* @snd_card_get_device_link(%struct.snd_card* %card)
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %0 = load i32, i32* %number, align 8, !tbaa !10
  %cmp = icmp sge i32 %0, 16
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i8* @kmalloc.201(i64 48, i32 20971712)
  %1 = bitcast i8* %call5 to %struct.snd_minor*
  %cmp6 = icmp eq %struct.snd_minor* %1, null
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %type9 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 0
  store i32 %type, i32* %type9, align 8, !tbaa !9
  %tobool10 = icmp ne %struct.snd_card* %card, null
  br i1 %tobool10, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end8
  %number11 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %2 = load i32, i32* %number11, align 8, !tbaa !10
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end8
  %cond = phi i32 [ %2, %cond.true ], [ -1, %if.end8 ]
  %card12 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 1
  store i32 %cond, i32* %card12, align 4, !tbaa !42
  %device = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 2
  store i32 %dev, i32* %device, align 8, !tbaa !43
  %f_ops13 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 3
  store %struct.file_operations* %f_ops, %struct.file_operations** %f_ops13, align 8, !tbaa !44
  %private_data14 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 4
  store i8* %private_data, i8** %private_data14, align 8, !tbaa !45
  %card_ptr = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 6
  store %struct.snd_card* %card, %struct.snd_card** %card_ptr, align 8, !tbaa !46
  call void @mutex_lock_nested(%struct.mutex* @sound_oss_mutex, i32 0)
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom
  store %struct.snd_minor* %1, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %and = and i32 %call, 15
  %Pivot6 = icmp slt i32 %and, 3
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %cond.end
  %Pivot = icmp slt i32 %and, 13
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %and, 13
  br i1 %SwitchLeaf4, label %sw.bb18, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 3
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.epilog

LeafBlock:                                        ; preds = %cond.end
  %SwitchLeaf = icmp eq i32 %and, 2
  br i1 %SwitchLeaf, label %sw.bb15, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock1
  %shl = shl i32 %shr, 4
  %or = or i32 %shl, 4
  br label %sw.epilog

sw.bb15:                                          ; preds = %LeafBlock
  %shl16 = shl i32 %shr, 4
  %or17 = or i32 %shl16, 9
  br label %sw.epilog

sw.bb18:                                          ; preds = %LeafBlock3
  %shl19 = shl i32 %shr, 4
  %or20 = or i32 %shl19, 14
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb18, %sw.bb15, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3
  %track2.0 = phi i32 [ %or17, %sw.bb15 ], [ %or, %sw.bb ], [ %or20, %sw.bb18 ], [ -1, %LeafBlock3 ], [ -1, %LeafBlock1 ], [ -1, %LeafBlock ]
  %call21 = call i32 @register_sound_special_device(%struct.file_operations* %f_ops, i32 %call, %struct.device* %call1)
  %cmp22 = icmp ne i32 %call21, %call
  br i1 %cmp22, label %__end, label %if.end24

if.end24:                                         ; preds = %sw.epilog
  %cmp25 = icmp sge i32 %track2.0, 0
  br i1 %cmp25, label %if.then26, label %if.end33

if.then26:                                        ; preds = %if.end24
  %call27 = call i32 @register_sound_special_device(%struct.file_operations* %f_ops, i32 %track2.0, %struct.device* %call1)
  %cmp28 = icmp ne i32 %call27, %track2.0
  br i1 %cmp28, label %__end, label %if.end30

if.end30:                                         ; preds = %if.then26
  %idxprom31 = sext i32 %track2.0 to i64
  %arrayidx32 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom31
  store %struct.snd_minor* %1, %struct.snd_minor** %arrayidx32, align 8, !tbaa !2
  br label %if.end33

if.end33:                                         ; preds = %if.end30, %if.end24
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  br label %cleanup

__end:                                            ; preds = %if.then26, %sw.epilog
  %register2.0 = phi i32 [ -1, %sw.epilog ], [ %call27, %if.then26 ]
  %cmp34 = icmp sge i32 %register2.0, 0
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %__end
  call void @unregister_sound_special(i32 %register2.0)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %__end
  %cmp37 = icmp sge i32 %call21, 0
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end36
  call void @unregister_sound_special(i32 %call21)
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.end36
  %idxprom40 = sext i32 %call to i64
  %arrayidx41 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom40
  store %struct.snd_minor* null, %struct.snd_minor** %arrayidx41, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  %3 = bitcast %struct.snd_minor* %1 to i8*
  call void @kfree(i8* %3)
  br label %cleanup

cleanup:                                          ; preds = %if.end39, %if.end33, %if.end4, %if.end, %land.lhs.true
  %retval.0 = phi i32 [ -16, %if.end39 ], [ 0, %if.end33 ], [ 0, %land.lhs.true ], [ %call, %if.end ], [ -12, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.device* @snd_card_get_device_link(%struct.snd_card* %card) #5 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 30
  %cond = select i1 %tobool, %struct.device* %card_dev, %struct.device* null
  ret %struct.device* %cond
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc.201(i64 %size, i32 %flags) #3 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare i32 @register_sound_special_device(%struct.file_operations*, i32, %struct.device*) #1

; Function Attrs: nounwind uwtable
define i8* @snd_lookup_oss_minor_data(i32 %minor, i32 %type) #0 {
entry:
  %conv = zext i32 %minor to i64
  %cmp = icmp uge i64 %conv, 256
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @sound_oss_mutex, i32 0)
  %idxprom = zext i32 %minor to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end
  %type2 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %1 = load i32, i32* %type2, align 8, !tbaa !9
  %cmp3 = icmp eq i32 %1, %type
  br i1 %cmp3, label %if.then5, label %if.end13

if.then5:                                         ; preds = %land.lhs.true
  %private_data6 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 4
  %2 = load i8*, i8** %private_data6, align 8, !tbaa !45
  %tobool7 = icmp ne i8* %2, null
  br i1 %tobool7, label %land.lhs.true8, label %if.end13

land.lhs.true8:                                   ; preds = %if.then5
  %card_ptr = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  %3 = load %struct.snd_card*, %struct.snd_card** %card_ptr, align 8, !tbaa !46
  %tobool9 = icmp ne %struct.snd_card* %3, null
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %land.lhs.true8
  %card_ptr11 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  %4 = load %struct.snd_card*, %struct.snd_card** %card_ptr11, align 8, !tbaa !46
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 30
  %call = call %struct.device* @get_device(%struct.device* %card_dev)
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %land.lhs.true8, %if.then5, %land.lhs.true, %if.end
  %private_data.0 = phi i8* [ %2, %if.then10 ], [ %2, %land.lhs.true8 ], [ %2, %if.then5 ], [ null, %land.lhs.true ], [ null, %if.end ]
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %entry
  %retval.0 = phi i8* [ %private_data.0, %if.end13 ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_minor_info_oss_init() #4 section ".init.text" {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.204, i32 0, i32 0), %struct.snd_info_entry* %0)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.58* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_minor_info_oss_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !49
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %call2, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_minor_info_oss_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  call void @mutex_lock_nested(%struct.mutex* @sound_oss_mutex, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %minor.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %minor.0, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_oss_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %card = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  %1 = load i32, i32* %card, align 4, !tbaa !42
  %cmp2 = icmp sge i32 %1, 0
  %buffer4 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %2 = load i8*, i8** %buffer4, align 8, !tbaa !50
  %3 = bitcast i8* %2 to %struct.seq_file*
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %card5 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  %4 = load i32, i32* %card5, align 4, !tbaa !42
  %device = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 2
  %5 = load i32, i32* %device, align 8, !tbaa !43
  %type = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %6 = load i32, i32* %type, align 8, !tbaa !9
  %call = call i8* @snd_oss_device_type_name(i32 %6)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %3, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.4.205, i32 0, i32 0), i32 %minor.0, i32 %4, i32 %5, i8* %call)
  br label %for.inc

if.else:                                          ; preds = %if.end
  %type7 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %7 = load i32, i32* %type7, align 8, !tbaa !9
  %call8 = call i8* @snd_oss_device_type_name(i32 %7)
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.5.206, i32 0, i32 0), i32 %minor.0, i8* %call8)
  br label %for.inc

for.inc:                                          ; preds = %if.else, %if.then3, %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @sound_oss_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @snd_oss_device_type_name(i32 %type) #0 {
entry:
  %Pivot12 = icmp slt i32 %type, 3
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %type, 4
  br i1 %Pivot10, label %return, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %type, 6
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %type, 6
  br i1 %SwitchLeaf6, label %return, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %type, 4
  br i1 %SwitchLeaf4, label %return, label %sw.default

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %type, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %type, 2
  %. = select i1 %Pivot, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7.207, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.8.208, i32 0, i32 0)
  br label %UnifiedReturnBlock

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %type, 0
  br i1 %SwitchLeaf, label %return, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock3, %LeafBlock5
  br label %return

return:                                           ; preds = %sw.default, %LeafBlock, %LeafBlock3, %LeafBlock5, %NodeBlock9
  %retval.0 = phi i8* [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.11.209, i32 0, i32 0), %sw.default ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6.210, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7.207, i32 0, i32 0), %LeafBlock5 ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9.211, i32 0, i32 0), %NodeBlock9 ], [ getelementptr inbounds ([19 x i8], [19 x i8]* @.str.10.212, i32 0, i32 0), %LeafBlock3 ]
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %return, %NodeBlock
  %UnifiedRetVal = phi i8* [ %., %NodeBlock ], [ %retval.0, %return ]
  ret i8* %UnifiedRetVal
}

; Function Attrs: nounwind uwtable
define void @snd_ctl_sync_vmaster(%struct.snd_kcontrol* %kcontrol, i1 zeroext %hook_only) #0 {
entry:
  %frombool = zext i1 %hook_only to i8
  %tobool = icmp ne %struct.snd_kcontrol* %kcontrol, null
  br i1 %tobool, label %if.end, label %cleanup.cont22

if.end:                                           ; preds = %entry
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_master*
  %tobool1 = trunc i8 %frombool to i1
  br i1 %tobool1, label %if.end12, label %if.then2

if.then2:                                         ; preds = %if.end
  %call = call i32 @master_init(%struct.link_master* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %LeafBlock, label %if.end4

if.end4:                                          ; preds = %if.then2
  %tobool5 = icmp ne i32 %call, 0
  %frombool6 = zext i1 %tobool5 to i8
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  %2 = load i32, i32* %val, align 8, !tbaa !321
  %val7 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  %3 = load i32, i32* %val7, align 8, !tbaa !321
  %call8 = call i32 @sync_slaves(%struct.link_master* %1, i32 %2, i32 %3)
  %cmp9 = icmp slt i32 %call8, 0
  %. = select i1 %cmp9, i32 1, i32 0
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end4, %if.then2
  %first_init.0 = phi i8 [ 0, %if.then2 ], [ %frombool6, %if.end4 ]
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then2 ], [ %., %if.end4 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end12, label %cleanup.cont22

if.end12:                                         ; preds = %LeafBlock, %if.end
  %first_init.1 = phi i8 [ 0, %if.end ], [ %first_init.0, %LeafBlock ]
  %hook = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 4
  %4 = load void (i8*, i32)*, void (i8*, i32)** %hook, align 8, !tbaa !324
  %tobool13 = icmp ne void (i8*, i32)* %4, null
  br i1 %tobool13, label %land.lhs.true, label %cleanup.cont22

land.lhs.true:                                    ; preds = %if.end12
  %tobool14 = trunc i8 %first_init.1 to i1
  br i1 %tobool14, label %cleanup.cont22, label %if.then15

if.then15:                                        ; preds = %land.lhs.true
  %hook16 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 4
  %5 = load void (i8*, i32)*, void (i8*, i32)** %hook16, align 8, !tbaa !324
  %hook_private_data = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 5
  %6 = load i8*, i8** %hook_private_data, align 8, !tbaa !325
  %val17 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  %7 = load i32, i32* %val17, align 8, !tbaa !321
  call void %5(i8* %6, i32 %7)
  br label %cleanup.cont22

cleanup.cont22:                                   ; preds = %if.then15, %land.lhs.true, %if.end12, %LeafBlock, %entry
  %cleanup.dest.slot.1 = phi i32 [ 1, %entry ], [ 0, %if.then15 ], [ 0, %land.lhs.true ], [ 0, %if.end12 ], [ %cleanup.dest.slot.0, %LeafBlock ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @master_init(%struct.link_master* %master) #0 {
entry:
  %info = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 1
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 1
  %0 = load i32, i32* %count, align 4, !tbaa !326
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cleanup20, label %if.end

if.end:                                           ; preds = %entry
  %slaves = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %slaves, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.link_slave*
  %list = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 0
  %slaves1 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, %slaves1
  br i1 %cmp, label %for.body, label %cleanup20

for.body:                                         ; preds = %if.end
  %call = call i32 @slave_init(%struct.link_slave* %3)
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %cleanup20, label %if.end4

if.end4:                                          ; preds = %for.body
  %info5 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 1
  %info6 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 2
  %4 = bitcast %struct.link_ctl_info* %info5 to i8*
  %5 = bitcast %struct.link_ctl_info* %info6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 16, i32 8, i1 false), !tbaa.struct !327
  %info7 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 1
  %count8 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info7, i32 0, i32 1
  store i32 1, i32* %count8, align 4, !tbaa !326
  %info9 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 1
  %max_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info9, i32 0, i32 3
  %6 = load i32, i32* %max_val, align 4, !tbaa !328
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 2
  store i32 %6, i32* %val, align 8, !tbaa !321
  %hook = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 4
  %7 = load void (i8*, i32)*, void (i8*, i32)** %hook, align 8, !tbaa !324
  %tobool10 = icmp ne void (i8*, i32)* %7, null
  br i1 %tobool10, label %if.then11, label %cleanup20

if.then11:                                        ; preds = %if.end4
  %hook12 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 4
  %8 = load void (i8*, i32)*, void (i8*, i32)** %hook12, align 8, !tbaa !324
  %hook_private_data = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 5
  %9 = load i8*, i8** %hook_private_data, align 8, !tbaa !325
  %val13 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 2
  %10 = load i32, i32* %val13, align 8, !tbaa !321
  call void %8(i8* %9, i32 %10)
  br label %cleanup20

cleanup20:                                        ; preds = %if.then11, %if.end4, %for.body, %if.end, %entry
  %retval.1 = phi i32 [ 0, %entry ], [ %call, %for.body ], [ 1, %if.then11 ], [ 1, %if.end4 ], [ -2, %if.end ]
  ret i32 %retval.1
}

; Function Attrs: nounwind uwtable
define internal i32 @sync_slaves(%struct.link_master* %master, i32 %old_val, i32 %new_val) #0 {
entry:
  %call = call i8* @kmalloc.214(i64 1224, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_ctl_elem_value*
  %tobool = icmp ne %struct.snd_ctl_elem_value* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %slaves = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %list8.sink = phi %struct.list_head* [ %list8, %for.body ], [ %slaves, %if.end ]
  %next9 = getelementptr inbounds %struct.list_head, %struct.list_head* %list8.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next9, align 8, !tbaa !2
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr11 = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr11 to %struct.link_slave*
  %list = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 0
  %slaves1 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, %slaves1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 2
  store i32 %old_val, i32* %val, align 8, !tbaa !321
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %0, i32 0, i32 0
  %slave2 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 6
  %id3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave2, i32 0, i32 1
  %4 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %5 = bitcast %struct.snd_ctl_elem_id* %id3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 64, i32 8, i1 false), !tbaa.struct !175
  %call4 = call i32 @slave_get_val(%struct.link_slave* %3, %struct.snd_ctl_elem_value* %0)
  %val5 = getelementptr inbounds %struct.link_master, %struct.link_master* %master, i32 0, i32 2
  store i32 %new_val, i32* %val5, align 8, !tbaa !321
  %call6 = call i32 @slave_put_val(%struct.link_slave* %3, %struct.snd_ctl_elem_value* %0)
  %list8 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = bitcast %struct.snd_ctl_elem_value* %0 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i32 [ 0, %for.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc.214(i64 %size, i32 %flags) #3 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_get_val(%struct.link_slave* %slave, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %call = call i32 @slave_init(%struct.link_slave* %slave)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %ch.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %info = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 1
  %0 = load i32, i32* %count, align 4, !tbaa !329
  %cmp1 = icmp slt i32 %ch.0, %0
  br i1 %cmp1, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %vals = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 3
  %idxprom = sext i32 %ch.0 to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %vals, i64 0, i64 %idxprom
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !47
  %conv = sext i32 %1 to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.64* %value to %struct.cpumask*
  %value2 = bitcast %struct.cpumask* %integer to [128 x i64]*
  %idxprom3 = sext i32 %ch.0 to i64
  %arrayidx4 = getelementptr inbounds [128 x i64], [128 x i64]* %value2, i64 0, i64 %idxprom3
  store i64 %conv, i64* %arrayidx4, align 8, !tbaa !49
  %inc = add nsw i32 %ch.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_put_val(%struct.link_slave* %slave, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %master = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 1
  %0 = load %struct.link_master*, %struct.link_master** %master, align 8, !tbaa !331
  %call = call i32 @master_init(%struct.link_master* %0)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %info = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %type = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 0
  %1 = load i32, i32* %type, align 8, !tbaa !332
  %Pivot = icmp slt i32 %1, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.end
  %SwitchLeaf2 = icmp eq i32 %1, 2
  br i1 %SwitchLeaf2, label %sw.bb6, label %sw.epilog

LeafBlock:                                        ; preds = %if.end
  %SwitchLeaf = icmp eq i32 %1, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  br label %for.cond

for.cond:                                         ; preds = %for.body, %sw.bb
  %ch.0 = phi i32 [ 0, %sw.bb ], [ %inc, %for.body ]
  %info1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info1, i32 0, i32 1
  %2 = load i32, i32* %count, align 4, !tbaa !329
  %cmp2 = icmp slt i32 %ch.0, %2
  br i1 %cmp2, label %for.body, label %sw.epilog

for.body:                                         ; preds = %for.cond
  %master3 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 1
  %3 = load %struct.link_master*, %struct.link_master** %master3, align 8, !tbaa !331
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %3, i32 0, i32 2
  %4 = load i32, i32* %val, align 8, !tbaa !321
  %tobool = icmp ne i32 %4, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.64* %value to %struct.cpumask*
  %value5 = bitcast %struct.cpumask* %integer to [128 x i64]*
  %idxprom = sext i32 %ch.0 to i64
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value5, i64 0, i64 %idxprom
  %5 = load i64, i64* %arrayidx, align 8, !tbaa !49
  %and = and i64 %5, %conv
  store i64 %and, i64* %arrayidx, align 8, !tbaa !49
  %inc = add nsw i32 %ch.0, 1
  br label %for.cond

sw.bb6:                                           ; preds = %LeafBlock1
  br label %for.cond7

for.cond7:                                        ; preds = %if.end37, %sw.bb6
  %ch.1 = phi i32 [ 0, %sw.bb6 ], [ %inc45, %if.end37 ]
  %info8 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count9 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info8, i32 0, i32 1
  %6 = load i32, i32* %count9, align 4, !tbaa !329
  %cmp10 = icmp slt i32 %ch.1, %6
  br i1 %cmp10, label %for.body12, label %sw.epilog

for.body12:                                       ; preds = %for.cond7
  %value13 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer14 = bitcast %union.anon.64* %value13 to %struct.cpumask*
  %value15 = bitcast %struct.cpumask* %integer14 to [128 x i64]*
  %idxprom16 = sext i32 %ch.1 to i64
  %arrayidx17 = getelementptr inbounds [128 x i64], [128 x i64]* %value15, i64 0, i64 %idxprom16
  %7 = load i64, i64* %arrayidx17, align 8, !tbaa !49
  %conv18 = trunc i64 %7 to i32
  %master19 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 1
  %8 = load %struct.link_master*, %struct.link_master** %master19, align 8, !tbaa !331
  %val20 = getelementptr inbounds %struct.link_master, %struct.link_master* %8, i32 0, i32 2
  %9 = load i32, i32* %val20, align 8, !tbaa !321
  %master21 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 1
  %10 = load %struct.link_master*, %struct.link_master** %master21, align 8, !tbaa !331
  %info22 = getelementptr inbounds %struct.link_master, %struct.link_master* %10, i32 0, i32 1
  %max_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info22, i32 0, i32 3
  %11 = load i32, i32* %max_val, align 4, !tbaa !328
  %sub = sub nsw i32 %9, %11
  %add = add nsw i32 %conv18, %sub
  %info23 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %min_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info23, i32 0, i32 2
  %12 = load i32, i32* %min_val, align 8, !tbaa !333
  %cmp24 = icmp slt i32 %add, %12
  %info27 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  br i1 %cmp24, label %if.then26, label %if.else

if.then26:                                        ; preds = %for.body12
  %min_val28 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info27, i32 0, i32 2
  %13 = load i32, i32* %min_val28, align 8, !tbaa !333
  br label %if.end37

if.else:                                          ; preds = %for.body12
  %max_val30 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info27, i32 0, i32 3
  %14 = load i32, i32* %max_val30, align 4, !tbaa !334
  %cmp31 = icmp sgt i32 %add, %14
  br i1 %cmp31, label %if.then33, label %if.end37

if.then33:                                        ; preds = %if.else
  %info34 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %max_val35 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info34, i32 0, i32 3
  %15 = load i32, i32* %max_val35, align 4, !tbaa !334
  br label %if.end37

if.end37:                                         ; preds = %if.then33, %if.else, %if.then26
  %vol.1 = phi i32 [ %13, %if.then26 ], [ %15, %if.then33 ], [ %add, %if.else ]
  %conv38 = sext i32 %vol.1 to i64
  %value39 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer40 = bitcast %union.anon.64* %value39 to %struct.cpumask*
  %value41 = bitcast %struct.cpumask* %integer40 to [128 x i64]*
  %idxprom42 = sext i32 %ch.1 to i64
  %arrayidx43 = getelementptr inbounds [128 x i64], [128 x i64]* %value41, i64 0, i64 %idxprom42
  store i64 %conv38, i64* %arrayidx43, align 8, !tbaa !49
  %inc45 = add nsw i32 %ch.1, 1
  br label %for.cond7

sw.epilog:                                        ; preds = %for.cond7, %for.cond, %LeafBlock, %LeafBlock1
  %slave47 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %put = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave47, i32 0, i32 5
  %16 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !335
  %slave48 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %call49 = call i32 %16(%struct.snd_kcontrol* %slave48, %struct.snd_ctl_elem_value* %ucontrol)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %entry
  %retval.0 = phi i32 [ %call49, %sw.epilog ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_init(%struct.link_slave* %slave) #0 {
entry:
  %info = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 1
  %0 = load i32, i32* %count, align 4, !tbaa !329
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %flags = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 4
  %1 = load i32, i32* %flags, align 8, !tbaa !336
  %and = and i32 %1, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then2, label %cleanup

if.then2:                                         ; preds = %if.then
  %call = call i32 @slave_update(%struct.link_slave* %slave)
  br label %cleanup

if.end3:                                          ; preds = %entry
  %call4 = call i8* @kmalloc.214(i64 272, i32 20971712)
  %2 = bitcast i8* %call4 to %struct.snd_ctl_elem_info*
  %tobool5 = icmp ne %struct.snd_ctl_elem_info* %2, null
  br i1 %tobool5, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.end3
  %id = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %2, i32 0, i32 0
  %slave8 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %id9 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave8, i32 0, i32 1
  %3 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %4 = bitcast %struct.snd_ctl_elem_id* %id9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 64, i32 8, i1 false), !tbaa.struct !175
  %slave10 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %info11 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave10, i32 0, i32 3
  %5 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info11, align 8, !tbaa !337
  %slave12 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %call13 = call i32 %5(%struct.snd_kcontrol* %slave12, %struct.snd_ctl_elem_info* %2)
  %cmp = icmp slt i32 %call13, 0
  br i1 %cmp, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end7
  %6 = bitcast %struct.snd_ctl_elem_info* %2 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

if.end15:                                         ; preds = %if.end7
  %type = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %2, i32 0, i32 1
  %7 = load i32, i32* %type, align 8, !tbaa !150
  %info16 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %type17 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info16, i32 0, i32 0
  store i32 %7, i32* %type17, align 8, !tbaa !332
  %count18 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %2, i32 0, i32 3
  %8 = load i32, i32* %count18, align 8, !tbaa !153
  %info19 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count20 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info19, i32 0, i32 1
  store i32 %8, i32* %count20, align 4, !tbaa !329
  %info21 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count22 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info21, i32 0, i32 1
  %9 = load i32, i32* %count22, align 4, !tbaa !329
  %cmp23 = icmp sgt i32 %9, 2
  br i1 %cmp23, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end15
  %info24 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %type25 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info24, i32 0, i32 0
  %10 = load i32, i32* %type25, align 8, !tbaa !332
  %cmp26 = icmp ne i32 %10, 2
  br i1 %cmp26, label %land.lhs.true, label %if.end32

land.lhs.true:                                    ; preds = %lor.lhs.false
  %info27 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %type28 = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info27, i32 0, i32 0
  %11 = load i32, i32* %type28, align 8, !tbaa !332
  %cmp29 = icmp ne i32 %11, 1
  br i1 %cmp29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %land.lhs.true, %if.end15
  %call31 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.215, i32 0, i32 0))
  %12 = bitcast %struct.snd_ctl_elem_info* %2 to i8*
  call void @kfree(i8* %12)
  br label %cleanup

if.end32:                                         ; preds = %land.lhs.true, %lor.lhs.false
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %2, i32 0, i32 5
  %integer = bitcast %union.anon.59* %value to %struct.task_cputime*
  %min = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer, i32 0, i32 0
  %13 = load i64, i64* %min, align 8, !tbaa !49
  %conv = trunc i64 %13 to i32
  %info33 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %min_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info33, i32 0, i32 2
  store i32 %conv, i32* %min_val, align 8, !tbaa !333
  %value34 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %2, i32 0, i32 5
  %integer35 = bitcast %union.anon.59* %value34 to %struct.task_cputime*
  %max = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer35, i32 0, i32 1
  %14 = load i64, i64* %max, align 8, !tbaa !49
  %conv36 = trunc i64 %14 to i32
  %info37 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %max_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info37, i32 0, i32 3
  store i32 %conv36, i32* %max_val, align 4, !tbaa !334
  %15 = bitcast %struct.snd_ctl_elem_info* %2 to i8*
  call void @kfree(i8* %15)
  %call38 = call i32 @slave_update(%struct.link_slave* %slave)
  br label %cleanup

cleanup:                                          ; preds = %if.end32, %if.then30, %if.then14, %if.end3, %if.then2, %if.then
  %retval.0 = phi i32 [ %call, %if.then2 ], [ %call13, %if.then14 ], [ -22, %if.then30 ], [ %call38, %if.end32 ], [ 0, %if.then ], [ -12, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_update(%struct.link_slave* %slave) #0 {
entry:
  %call = call i8* @kmalloc.214(i64 1224, i32 20971712)
  %0 = bitcast i8* %call to %struct.snd_ctl_elem_value*
  %tobool = icmp ne %struct.snd_ctl_elem_value* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %0, i32 0, i32 0
  %slave1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %id2 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave1, i32 0, i32 1
  %1 = bitcast %struct.snd_ctl_elem_id* %id to i8*
  %2 = bitcast %struct.snd_ctl_elem_id* %id2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 64, i32 8, i1 false), !tbaa.struct !175
  %slave3 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %get = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave3, i32 0, i32 4
  %3 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !338
  %slave4 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 6
  %call5 = call i32 %3(%struct.snd_kcontrol* %slave4, %struct.snd_ctl_elem_value* %0)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %ch.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %info = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 2
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 1
  %4 = load i32, i32* %count, align 4, !tbaa !329
  %cmp = icmp slt i32 %ch.0, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %0, i32 0, i32 2
  %integer = bitcast %union.anon.64* %value to %struct.cpumask*
  %value6 = bitcast %struct.cpumask* %integer to [128 x i64]*
  %idxprom = sext i32 %ch.0 to i64
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value6, i64 0, i64 %idxprom
  %5 = load i64, i64* %arrayidx, align 8, !tbaa !49
  %conv = trunc i64 %5 to i32
  %vals = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave, i32 0, i32 3
  %idxprom7 = sext i32 %ch.0 to i64
  %arrayidx8 = getelementptr inbounds [2 x i32], [2 x i32]* %vals, i64 0, i64 %idxprom7
  store i32 %conv, i32* %arrayidx8, align 4, !tbaa !47
  %inc = add nsw i32 %ch.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = bitcast %struct.snd_ctl_elem_value* %0 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i32 [ 0, %for.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_ctl_add_vmaster_hook(%struct.snd_kcontrol* %kcontrol, void (i8*, i32)* %hook, i8* %private_data) #0 {
entry:
  %private_data1 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data1, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_master*
  %hook2 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 4
  store void (i8*, i32)* %hook, void (i8*, i32)** %hook2, align 8, !tbaa !324
  %hook_private_data = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 5
  store i8* %private_data, i8** %hook_private_data, align 8, !tbaa !325
  ret i32 0
}

; Function Attrs: nounwind uwtable
define %struct.snd_kcontrol* @snd_ctl_make_virtual_master(i8* %name, i32* %tlv) #0 {
entry:
  %knew = alloca %struct.snd_kcontrol_new, align 8
  %0 = bitcast %struct.snd_kcontrol_new* %knew to i8*
  call void @llvm.lifetime.start.p0i8(i64 80, i8* %0) #9
  %1 = bitcast %struct.snd_kcontrol_new* %knew to i8*
  %call = call i8* @__memset(i8* %1, i32 0, i64 80)
  %iface = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %knew, i32 0, i32 0
  store i32 2, i32* %iface, align 8, !tbaa !191
  %name1 = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %knew, i32 0, i32 3
  store i8* %name, i8** %name1, align 8, !tbaa !194
  %info = getelementptr inbounds %struct.snd_kcontrol_new, %struct.snd_kcontrol_new* %knew, i32 0, i32 7
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @master_info, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !187
  %call2 = call i8* @kzalloc.216(i64 72, i32 20971712)
  %2 = bitcast i8* %call2 to %struct.link_master*
  %tobool = icmp ne %struct.link_master* %2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %slaves = getelementptr inbounds %struct.link_master, %struct.link_master* %2, i32 0, i32 0
  call void @INIT_LIST_HEAD.217(%struct.list_head* %slaves)
  %3 = bitcast %struct.link_master* %2 to i8*
  %call3 = call %struct.snd_kcontrol* @snd_ctl_new1(%struct.snd_kcontrol_new* %knew, i8* %3)
  %tobool4 = icmp ne %struct.snd_kcontrol* %call3, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  %4 = bitcast %struct.link_master* %2 to i8*
  call void @kfree(i8* %4)
  br label %cleanup

if.end6:                                          ; preds = %if.end
  %info7 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call3, i32 0, i32 3
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @master_info, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info7, align 8, !tbaa !186
  %get = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call3, i32 0, i32 4
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @master_get, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !197
  %put = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call3, i32 0, i32 5
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @master_put, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !199
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call3, i32 0, i32 9
  store void (%struct.snd_kcontrol*)* @master_free, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !185
  %tobool8 = icmp ne i32* %tlv, null
  br i1 %tobool8, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %if.end6
  %arrayidx = getelementptr inbounds i32, i32* %tlv, i64 0
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !47
  %cmp = icmp eq i32 %5, 1
  br i1 %cmp, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %arrayidx9 = getelementptr inbounds i32, i32* %tlv, i64 0
  %6 = load i32, i32* %arrayidx9, align 4, !tbaa !47
  %cmp10 = icmp eq i32 %6, 4
  br i1 %cmp10, label %if.then14, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false
  %arrayidx12 = getelementptr inbounds i32, i32* %tlv, i64 0
  %7 = load i32, i32* %arrayidx12, align 4, !tbaa !47
  %cmp13 = icmp eq i32 %7, 5
  br i1 %cmp13, label %if.then14, label %cleanup

if.then14:                                        ; preds = %lor.lhs.false11, %lor.lhs.false, %land.lhs.true
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call3, i32 0, i32 10
  %arrayidx15 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i64 0, i64 0
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx15, i32 0, i32 1
  %8 = load i32, i32* %access, align 8, !tbaa !177
  %or = or i32 %8, 16
  store i32 %or, i32* %access, align 8, !tbaa !177
  %tlv16 = getelementptr inbounds %struct.link_master, %struct.link_master* %2, i32 0, i32 3
  %arraydecay = getelementptr inbounds [4 x i32], [4 x i32]* %tlv16, i32 0, i32 0
  %9 = bitcast i32* %arraydecay to i8*
  %10 = bitcast i32* %tlv to i8*
  %call17 = call i8* @__memcpy(i8* %9, i8* %10, i64 16)
  %tlv18 = getelementptr inbounds %struct.link_master, %struct.link_master* %2, i32 0, i32 3
  %arraydecay19 = getelementptr inbounds [4 x i32], [4 x i32]* %tlv18, i32 0, i32 0
  %tlv20 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call3, i32 0, i32 6
  %p = bitcast %union.anon.69* %tlv20 to i32**
  store i32* %arraydecay19, i32** %p, align 8, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %if.then14, %lor.lhs.false11, %if.end6, %if.then5, %entry
  %retval.0 = phi %struct.snd_kcontrol* [ null, %if.then5 ], [ null, %entry ], [ %call3, %if.then14 ], [ %call3, %lor.lhs.false11 ], [ %call3, %if.end6 ]
  %11 = bitcast %struct.snd_kcontrol_new* %knew to i8*
  call void @llvm.lifetime.end.p0i8(i64 80, i8* %11) #9
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @master_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_master*
  %call = call i32 @master_init(%struct.link_master* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %info = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 1
  %type = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 0
  %2 = load i32, i32* %type, align 8, !tbaa !339
  %type1 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 1
  store i32 %2, i32* %type1, align 8, !tbaa !150
  %info2 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 1
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info2, i32 0, i32 1
  %3 = load i32, i32* %count, align 4, !tbaa !326
  %count3 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 3
  store i32 %3, i32* %count3, align 8, !tbaa !153
  %info4 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 1
  %min_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info4, i32 0, i32 2
  %4 = load i32, i32* %min_val, align 8, !tbaa !340
  %conv = sext i32 %4 to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer = bitcast %union.anon.59* %value to %struct.task_cputime*
  %min = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer, i32 0, i32 0
  store i64 %conv, i64* %min, align 8, !tbaa !49
  %info5 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 1
  %max_val = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info5, i32 0, i32 3
  %5 = load i32, i32* %max_val, align 4, !tbaa !328
  %conv6 = sext i32 %5 to i64
  %value7 = getelementptr inbounds %struct.snd_ctl_elem_info, %struct.snd_ctl_elem_info* %uinfo, i32 0, i32 5
  %integer8 = bitcast %union.anon.59* %value7 to %struct.task_cputime*
  %max = getelementptr inbounds %struct.task_cputime, %struct.task_cputime* %integer8, i32 0, i32 1
  store i64 %conv6, i64* %max, align 8, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.216(i64 %size, i32 %flags) #5 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc.214(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.217(%struct.list_head* %list) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !49
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.218(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @master_get(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_master*
  %call = call i32 @master_init(%struct.link_master* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  %2 = load i32, i32* %val, align 8, !tbaa !321
  %conv = sext i32 %2 to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.64* %value to %struct.cpumask*
  %value1 = bitcast %struct.cpumask* %integer to [128 x i64]*
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value1, i64 0, i64 0
  store i64 %conv, i64* %arrayidx, align 8, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ %call, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @master_put(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_master*
  %call = call i32 @master_init(%struct.link_master* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %tobool = icmp ne i32 %call, 0
  %frombool = zext i1 %tobool to i8
  %val = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  %2 = load i32, i32* %val, align 8, !tbaa !321
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.64* %value to %struct.cpumask*
  %value1 = bitcast %struct.cpumask* %integer to [128 x i64]*
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value1, i64 0, i64 0
  %3 = load i64, i64* %arrayidx, align 8, !tbaa !49
  %conv = trunc i64 %3 to i32
  %cmp2 = icmp eq i32 %conv, %2
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @sync_slaves(%struct.link_master* %1, i32 %2, i32 %conv)
  %cmp7 = icmp slt i32 %call6, 0
  br i1 %cmp7, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end5
  %hook = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 4
  %4 = load void (i8*, i32)*, void (i8*, i32)** %hook, align 8, !tbaa !324
  %tobool11 = icmp ne void (i8*, i32)* %4, null
  br i1 %tobool11, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %if.end10
  %tobool12 = trunc i8 %frombool to i1
  br i1 %tobool12, label %cleanup, label %if.then13

if.then13:                                        ; preds = %land.lhs.true
  %hook14 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 4
  %5 = load void (i8*, i32)*, void (i8*, i32)** %hook14, align 8, !tbaa !324
  %hook_private_data = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 5
  %6 = load i8*, i8** %hook_private_data, align 8, !tbaa !325
  %val15 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 2
  %7 = load i32, i32* %val15, align 8, !tbaa !321
  call void %5(i8* %6, i32 %7)
  br label %cleanup

cleanup:                                          ; preds = %if.then13, %land.lhs.true, %if.end10, %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ 0, %if.end ], [ %call6, %if.end5 ], [ 1, %if.then13 ], [ 1, %land.lhs.true ], [ 1, %if.end10 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @master_free(%struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %olist = alloca %struct.list_head, align 8
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_master*
  %slaves = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %slaves, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.link_slave*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.link_slave* [ %7, %for.body ], [ %4, %entry ]
  %slave.0 = phi %struct.link_slave* [ %4, %entry ], [ %7, %for.body ]
  %list15 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %.sink, i32 0, i32 0
  %next16 = getelementptr inbounds %struct.list_head, %struct.list_head* %list15, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next16, align 8, !tbaa !341
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr18 = getelementptr inbounds i8, i8* %6, i64 0
  %7 = bitcast i8* %add.ptr18 to %struct.link_slave*
  %list5 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave.0, i32 0, i32 0
  %slaves6 = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list5, %slaves6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %kctl = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave.0, i32 0, i32 5
  %8 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !342
  %9 = bitcast %struct.list_head* %olist to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %9) #9
  %list7 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 0
  %10 = bitcast %struct.list_head* %olist to i8*
  %11 = bitcast %struct.list_head* %list7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 16, i32 8, i1 false), !tbaa.struct !343
  %12 = bitcast %struct.snd_kcontrol* %8 to i8*
  %slave8 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave.0, i32 0, i32 6
  %13 = bitcast %struct.snd_kcontrol* %slave8 to i8*
  %call = call i8* @__memcpy(i8* %12, i8* %13, i64 144)
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 10
  %arraydecay = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i32 0, i32 0
  %14 = bitcast %struct.snd_kcontrol_volatile* %arraydecay to i8*
  %slave9 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %slave.0, i32 0, i32 6
  %vd10 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave9, i32 0, i32 10
  %arraydecay11 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd10, i32 0, i32 0
  %15 = bitcast %struct.snd_kcontrol_volatile* %arraydecay11 to i8*
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 2
  %16 = load i32, i32* %count, align 8, !tbaa !173
  %conv = zext i32 %16 to i64
  %mul = mul i64 %conv, 16
  %call12 = call i8* @__memcpy(i8* %14, i8* %15, i64 %mul)
  %list13 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %8, i32 0, i32 0
  %17 = bitcast %struct.list_head* %list13 to i8*
  %18 = bitcast %struct.list_head* %olist to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %18, i64 16, i32 8, i1 false), !tbaa.struct !343
  %19 = bitcast %struct.link_slave* %slave.0 to i8*
  call void @kfree(i8* %19)
  %20 = bitcast %struct.list_head* %olist to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %20) #9
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %21 = bitcast %struct.link_master* %1 to i8*
  call void @kfree(i8* %21)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size.218(i8* %p, i8* %res, i32 %size) #3 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !49
  store volatile i8 %0, i8* %p, align 1, !tbaa !49
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !118
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !118
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !47
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !47
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !119
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !119
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !344
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !345
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @_snd_ctl_add_slave(%struct.snd_kcontrol* %master, %struct.snd_kcontrol* %slave, i32 %flags) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %master, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_master*
  %count = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 2
  %2 = load i32, i32* %count, align 8, !tbaa !173
  %conv = zext i32 %2 to i64
  %mul = mul i64 %conv, 16
  %add = add i64 208, %mul
  %call = call i8* @kzalloc.216(i64 %add, i32 20971712)
  %3 = bitcast i8* %call to %struct.link_slave*
  %tobool = icmp ne %struct.link_slave* %3, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %kctl = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 5
  store %struct.snd_kcontrol* %slave, %struct.snd_kcontrol** %kctl, align 8, !tbaa !342
  %slave1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 6
  %4 = bitcast %struct.snd_kcontrol* %slave1 to i8*
  %5 = bitcast %struct.snd_kcontrol* %slave to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 144, i32 8, i1 false), !tbaa.struct !346
  %slave2 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 6
  %vd = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave2, i32 0, i32 10
  %arraydecay = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd, i32 0, i32 0
  %6 = bitcast %struct.snd_kcontrol_volatile* %arraydecay to i8*
  %vd3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 10
  %arraydecay4 = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd3, i32 0, i32 0
  %7 = bitcast %struct.snd_kcontrol_volatile* %arraydecay4 to i8*
  %count5 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 2
  %8 = load i32, i32* %count5, align 8, !tbaa !173
  %conv6 = zext i32 %8 to i64
  %mul7 = mul i64 %conv6, 16
  %call8 = call i8* @__memcpy(i8* %6, i8* %7, i64 %mul7)
  %master9 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 1
  store %struct.link_master* %1, %struct.link_master** %master9, align 8, !tbaa !331
  %flags10 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 4
  store i32 %flags, i32* %flags10, align 8, !tbaa !336
  %info = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 3
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)* @slave_info, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !186
  %get = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 4
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @slave_get, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %get, align 8, !tbaa !197
  %put = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 5
  store i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)* @slave_put, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)** %put, align 8, !tbaa !199
  %vd11 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 10
  %arrayidx = getelementptr inbounds [0 x %struct.snd_kcontrol_volatile], [0 x %struct.snd_kcontrol_volatile]* %vd11, i64 0, i64 0
  %access = getelementptr inbounds %struct.snd_kcontrol_volatile, %struct.snd_kcontrol_volatile* %arrayidx, i32 0, i32 1
  %9 = load i32, i32* %access, align 8, !tbaa !177
  %and = and i32 %9, 268435456
  %tobool12 = icmp ne i32 %and, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  %tlv = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 6
  %c = bitcast %union.anon.69* %tlv to i32 (%struct.snd_kcontrol*, i32, i32, i32*)**
  store i32 (%struct.snd_kcontrol*, i32, i32, i32*)* @slave_tlv_cmd, i32 (%struct.snd_kcontrol*, i32, i32, i32*)** %c, align 8, !tbaa !49
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end
  %10 = bitcast %struct.link_slave* %3 to i8*
  %private_data15 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 8
  store i8* %10, i8** %private_data15, align 8, !tbaa !202
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave, i32 0, i32 9
  store void (%struct.snd_kcontrol*)* @slave_free, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !185
  %list = getelementptr inbounds %struct.link_slave, %struct.link_slave* %3, i32 0, i32 0
  %slaves = getelementptr inbounds %struct.link_master, %struct.link_master* %1, i32 0, i32 0
  call void @list_add_tail.219(%struct.list_head* %list, %struct.list_head* %slaves)
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %entry
  %retval.0 = phi i32 [ 0, %if.end14 ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_info(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_info* %uinfo) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_slave*
  %slave1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %info = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave1, i32 0, i32 3
  %2 = load i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)** %info, align 8, !tbaa !337
  %slave2 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %call = call i32 %2(%struct.snd_kcontrol* %slave2, %struct.snd_ctl_elem_info* %uinfo)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_get(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_slave*
  %call = call i32 @slave_get_val(%struct.link_slave* %1, %struct.snd_ctl_elem_value* %ucontrol)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_put(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_slave*
  %call = call i32 @slave_init(%struct.link_slave* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %ch.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %changed.0 = phi i32 [ 0, %if.end ], [ %changed.1, %for.inc ]
  %info = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 2
  %count = getelementptr inbounds %struct.link_ctl_info, %struct.link_ctl_info* %info, i32 0, i32 1
  %2 = load i32, i32* %count, align 4, !tbaa !329
  %cmp1 = icmp slt i32 %ch.0, %2
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %vals = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 3
  %idxprom = sext i32 %ch.0 to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %vals, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !47
  %conv = sext i32 %3 to i64
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.64* %value to %struct.cpumask*
  %value2 = bitcast %struct.cpumask* %integer to [128 x i64]*
  %idxprom3 = sext i32 %ch.0 to i64
  %arrayidx4 = getelementptr inbounds [128 x i64], [128 x i64]* %value2, i64 0, i64 %idxprom3
  %4 = load i64, i64* %arrayidx4, align 8, !tbaa !49
  %cmp5 = icmp ne i64 %conv, %4
  br i1 %cmp5, label %if.then7, label %for.inc

if.then7:                                         ; preds = %for.body
  %value8 = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer9 = bitcast %union.anon.64* %value8 to %struct.cpumask*
  %value10 = bitcast %struct.cpumask* %integer9 to [128 x i64]*
  %idxprom11 = sext i32 %ch.0 to i64
  %arrayidx12 = getelementptr inbounds [128 x i64], [128 x i64]* %value10, i64 0, i64 %idxprom11
  %5 = load i64, i64* %arrayidx12, align 8, !tbaa !49
  %conv13 = trunc i64 %5 to i32
  %vals14 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 3
  %idxprom15 = sext i32 %ch.0 to i64
  %arrayidx16 = getelementptr inbounds [2 x i32], [2 x i32]* %vals14, i64 0, i64 %idxprom15
  store i32 %conv13, i32* %arrayidx16, align 4, !tbaa !47
  br label %for.inc

for.inc:                                          ; preds = %if.then7, %for.body
  %changed.1 = phi i32 [ 1, %if.then7 ], [ %changed.0, %for.body ]
  %inc = add nsw i32 %ch.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool = icmp ne i32 %changed.0, 0
  br i1 %tobool, label %if.end19, label %cleanup

if.end19:                                         ; preds = %for.end
  %call20 = call i32 @slave_put_val(%struct.link_slave* %1, %struct.snd_ctl_elem_value* %ucontrol)
  %cmp21 = icmp slt i32 %call20, 0
  %call20. = select i1 %cmp21, i32 %call20, i32 1
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %for.end, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ 0, %for.end ], [ %call20., %if.end19 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @slave_tlv_cmd(%struct.snd_kcontrol* %kcontrol, i32 %op_flag, i32 %size, i32* %tlv) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_slave*
  %slave1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %tlv2 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave1, i32 0, i32 6
  %c = bitcast %union.anon.69* %tlv2 to i32 (%struct.snd_kcontrol*, i32, i32, i32*)**
  %2 = load i32 (%struct.snd_kcontrol*, i32, i32, i32*)*, i32 (%struct.snd_kcontrol*, i32, i32, i32*)** %c, align 8, !tbaa !49
  %slave3 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %call = call i32 %2(%struct.snd_kcontrol* %slave3, i32 %op_flag, i32 %size, i32* %tlv)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @slave_free(%struct.snd_kcontrol* %kcontrol) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.link_slave*
  %slave1 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave1, i32 0, i32 9
  %2 = load void (%struct.snd_kcontrol*)*, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !347
  %tobool = icmp ne void (%struct.snd_kcontrol*)* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %slave2 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  %private_free3 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %slave2, i32 0, i32 9
  %3 = load void (%struct.snd_kcontrol*)*, void (%struct.snd_kcontrol*)** %private_free3, align 8, !tbaa !347
  %slave4 = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 6
  call void %3(%struct.snd_kcontrol* %slave4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %master = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 1
  %4 = load %struct.link_master*, %struct.link_master** %master, align 8, !tbaa !331
  %tobool5 = icmp ne %struct.link_master* %4, null
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %list = getelementptr inbounds %struct.link_slave, %struct.link_slave* %1, i32 0, i32 0
  call void @list_del.221(%struct.list_head* %list)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %5 = bitcast %struct.link_slave* %1 to i8*
  call void @kfree(i8* %5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.219(%struct.list_head* %new, %struct.list_head* %head) #5 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  call void @__list_add.220(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add.220(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !117
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !116
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !49
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.218(i8* %1, i8* %arraydecay, i32 8)
  %__val5 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val5, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del.221(%struct.list_head* %entry1) #5 {
entry:
  call void @__list_del_entry.222(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !116
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry.222(%struct.list_head* %entry1) #5 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  call void @__list_del.223(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del.223(%struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !49
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.218(i8* %1, i8* %arraydecay, i32 8)
  %__val3 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val3, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.snd_kcontrol* @snd_kctl_jack_new(i8* %name, %struct.snd_card* %card) #0 {
entry:
  %call = call %struct.snd_kcontrol* @snd_ctl_new1(%struct.snd_kcontrol_new* @jack_detect_kctl, i8* null)
  %tobool = icmp ne %struct.snd_kcontrol* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 1
  %name1 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id, i32 0, i32 4
  %arraydecay = getelementptr inbounds [44 x i8], [44 x i8]* %name1, i32 0, i32 0
  call void @jack_kctl_name_gen(i8* %arraydecay, i8* %name, i32 44)
  %id2 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 1
  %name3 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id2, i32 0, i32 4
  %arraydecay4 = getelementptr inbounds [44 x i8], [44 x i8]* %name3, i32 0, i32 0
  %call5 = call i32 @get_available_index(%struct.snd_card* %card, i8* %arraydecay4)
  %id6 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 1
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %id6, i32 0, i32 5
  store i32 %call5, i32* %index, align 4, !tbaa !171
  %private_value = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 7
  store i64 0, i64* %private_value, align 8, !tbaa !201
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi %struct.snd_kcontrol* [ %call, %if.end ], [ null, %entry ]
  ret %struct.snd_kcontrol* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @jack_kctl_name_gen(i8* %name, i8* %src_name, i32 %size) #0 {
entry:
  %call = call i64 @strlen(i8* %src_name)
  %cmp = icmp uge i64 %call, 5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sub = sub i64 %call, 5
  %arrayidx = getelementptr inbounds i8, i8* %src_name, i64 %sub
  %call1 = call i32 @strncmp(i8* %arrayidx, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i32 0, i32 0), i64 5)
  %tobool = icmp ne i32 %call1, 0
  %0 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %tobool2 = icmp ne i32 %cond, 0
  %frombool = zext i1 %tobool2 to i8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %need_cat.0 = phi i8 [ %frombool, %if.then ], [ 1, %entry ]
  %conv = sext i32 %size to i64
  %tobool3 = trunc i8 %need_cat.0 to i1
  %1 = zext i1 %tobool3 to i64
  %cond5 = select i1 %tobool3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1.225, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2.226, i32 0, i32 0)
  %call6 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %name, i64 %conv, i8* %cond5, i8* %src_name)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @get_available_index(%struct.snd_card* %card, i8* %name) #0 {
entry:
  %sid = alloca %struct.snd_ctl_elem_id, align 4
  %0 = bitcast %struct.snd_ctl_elem_id* %sid to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #9
  %1 = bitcast %struct.snd_ctl_elem_id* %sid to i8*
  %call = call i8* @__memset(i8* %1, i32 0, i64 64)
  %index = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %sid, i32 0, i32 5
  store i32 0, i32* %index, align 4, !tbaa !172
  %iface = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %sid, i32 0, i32 1
  store i32 0, i32* %iface, align 4, !tbaa !166
  %name1 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %sid, i32 0, i32 4
  %arraydecay = getelementptr inbounds [44 x i8], [44 x i8]* %name1, i32 0, i32 0
  %call2 = call i64 @strlcpy(i8* %arraydecay, i8* %name, i64 44)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call3 = call %struct.snd_kcontrol* @snd_ctl_find_id(%struct.snd_card* %card, %struct.snd_ctl_elem_id* %sid)
  %tobool = icmp ne %struct.snd_kcontrol* %call3, null
  %index4 = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %sid, i32 0, i32 5
  %2 = load i32, i32* %index4, align 4, !tbaa !172
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %inc = add i32 %2, 1
  store i32 %inc, i32* %index4, align 4, !tbaa !172
  %numid = getelementptr inbounds %struct.snd_ctl_elem_id, %struct.snd_ctl_elem_id* %sid, i32 0, i32 0
  store i32 0, i32* %numid, align 4, !tbaa !163
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %3 = bitcast %struct.snd_ctl_elem_id* %sid to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %3) #9
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @jack_detect_kctl_get(%struct.snd_kcontrol* %kcontrol, %struct.snd_ctl_elem_value* %ucontrol) #0 {
entry:
  %private_value = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kcontrol, i32 0, i32 7
  %0 = load i64, i64* %private_value, align 8, !tbaa !201
  %value = getelementptr inbounds %struct.snd_ctl_elem_value, %struct.snd_ctl_elem_value* %ucontrol, i32 0, i32 2
  %integer = bitcast %union.anon.64* %value to %struct.cpumask*
  %value1 = bitcast %struct.cpumask* %integer to [128 x i64]*
  %arrayidx = getelementptr inbounds [128 x i64], [128 x i64]* %value1, i64 0, i64 0
  store i64 %0, i64* %arrayidx, align 8, !tbaa !49
  ret i32 0
}

; Function Attrs: nounwind uwtable
define void @snd_kctl_jack_report(%struct.snd_card* %card, %struct.snd_kcontrol* %kctl, i1 zeroext %status) #0 {
entry:
  %frombool = zext i1 %status to i8
  %private_value = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 7
  %0 = load i64, i64* %private_value, align 8, !tbaa !201
  %tobool = trunc i8 %frombool to i1
  %conv = zext i1 %tobool to i64
  %cmp = icmp eq i64 %0, %conv
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool2 = trunc i8 %frombool to i1
  %conv3 = zext i1 %tobool2 to i64
  %private_value4 = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 7
  store i64 %conv3, i64* %private_value4, align 8, !tbaa !201
  %id = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 1
  call void @snd_ctl_notify(%struct.snd_card* %card, i32 1, %struct.snd_ctl_elem_id* %id)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_jack_report(%struct.snd_jack* %jack, i32 %status) #0 {
entry:
  %tobool = icmp ne %struct.snd_jack* %jack, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %kctl_list = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %list4.sink = phi %struct.list_head* [ %list4, %for.body ], [ %kctl_list, %if.end ]
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %list4.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next5, align 8, !tbaa !2
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %1, i64 -8
  %2 = bitcast i8* %add.ptr7 to %struct.snd_jack_kctl*
  %list = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %2, i32 0, i32 1
  %kctl_list1 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, %kctl_list1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %card = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 1
  %3 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !348
  %kctl = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %2, i32 0, i32 0
  %4 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !350
  %mask_bits = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %2, i32 0, i32 2
  %5 = load i32, i32* %mask_bits, align 8, !tbaa !352
  %and = and i32 %status, %5
  %tobool2 = icmp ne i32 %and, 0
  call void @snd_kctl_jack_report(%struct.snd_card* %3, %struct.snd_kcontrol* %4, i1 zeroext %tobool2)
  %list4 = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %2, i32 0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %input_dev = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 3
  %6 = load %struct.input_dev*, %struct.input_dev** %input_dev, align 8, !tbaa !353
  %tobool8 = icmp ne %struct.input_dev* %6, null
  br i1 %tobool8, label %if.end10, label %cleanup.cont

if.end10:                                         ; preds = %for.end
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc21, %if.end10
  %i.0 = phi i32 [ 0, %if.end10 ], [ %inc, %for.inc21 ]
  %conv = sext i32 %i.0 to i64
  %cmp12 = icmp ult i64 %conv, 6
  br i1 %cmp12, label %for.body14, label %for.end22

for.body14:                                       ; preds = %for.cond11
  %shr = ashr i32 16384, %i.0
  %type = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 5
  %7 = load i32, i32* %type, align 4, !tbaa !354
  %and15 = and i32 %7, %shr
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %for.inc21

if.then17:                                        ; preds = %for.body14
  %input_dev18 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 3
  %8 = load %struct.input_dev*, %struct.input_dev** %input_dev18, align 8, !tbaa !353
  %key = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 7
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %key, i64 0, i64 %idxprom
  %9 = load i32, i32* %arrayidx, align 4, !tbaa !47
  %and19 = and i32 %status, %shr
  call void @input_report_key(%struct.input_dev* %8, i32 %9, i32 %and19)
  br label %for.inc21

for.inc21:                                        ; preds = %if.then17, %for.body14
  %inc = add nsw i32 %i.0, 1
  br label %for.cond11

for.end22:                                        ; preds = %for.cond11
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc38, %for.end22
  %i.1 = phi i32 [ 0, %for.end22 ], [ %inc39, %for.inc38 ]
  %conv24 = sext i32 %i.1 to i64
  %cmp25 = icmp ult i64 %conv24, 6
  br i1 %cmp25, label %for.body27, label %for.end40

for.body27:                                       ; preds = %for.cond23
  %shl = shl i32 1, %i.1
  %type29 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 5
  %10 = load i32, i32* %type29, align 4, !tbaa !354
  %and30 = and i32 %10, %shl
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.then32, label %for.inc38

if.then32:                                        ; preds = %for.body27
  %input_dev33 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 3
  %11 = load %struct.input_dev*, %struct.input_dev** %input_dev33, align 8, !tbaa !353
  %idxprom34 = sext i32 %i.1 to i64
  %arrayidx35 = getelementptr inbounds [6 x i32], [6 x i32]* @jack_switch_types, i64 0, i64 %idxprom34
  %12 = load i32, i32* %arrayidx35, align 4, !tbaa !47
  %and36 = and i32 %status, %shl
  call void @input_report_switch(%struct.input_dev* %11, i32 %12, i32 %and36)
  br label %for.inc38

for.inc38:                                        ; preds = %if.then32, %for.body27
  %inc39 = add nsw i32 %i.1, 1
  br label %for.cond23

for.end40:                                        ; preds = %for.cond23
  %input_dev41 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 3
  %13 = load %struct.input_dev*, %struct.input_dev** %input_dev41, align 8, !tbaa !353
  call void @input_sync(%struct.input_dev* %13)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end40, %for.end, %entry
  %cleanup.dest.slot.0 = phi i32 [ 0, %for.end40 ], [ 1, %entry ], [ 1, %for.end ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_key(%struct.input_dev* %dev, i32 %code, i32 %value) #5 {
entry:
  %tobool = icmp ne i32 %value, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  call void @input_event(%struct.input_dev* %dev, i32 1, i32 %code, i32 %lnot.ext)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_report_switch(%struct.input_dev* %dev, i32 %code, i32 %value) #5 {
entry:
  %tobool = icmp ne i32 %value, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  call void @input_event(%struct.input_dev* %dev, i32 5, i32 %code, i32 %lnot.ext)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @input_sync(%struct.input_dev* %dev) #5 {
entry:
  call void @input_event(%struct.input_dev* %dev, i32 0, i32 0, i32 0)
  ret void
}

declare void @input_event(%struct.input_dev*, i32, i32, i32) #1

; Function Attrs: nounwind uwtable
define i32 @snd_jack_set_key(%struct.snd_jack* %jack, i32 %type, i32 %keytype) #0 {
entry:
  %call = call i32 @fls(i32 16384)
  %call1 = call i32 @fls(i32 %type)
  %sub = sub nsw i32 %call, %call1
  %registered = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 4
  %0 = load i32, i32* %registered, align 8, !tbaa !355
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.1.228, i32 0, i32 0), i32 336)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp eq i32 %keytype, 0
  %conv17 = sext i32 %sub to i64
  %cmp = icmp uge i64 %conv17, 6
  %or.cond = or i1 %tobool16, %cmp
  br i1 %or.cond, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end
  %type21 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 5
  %1 = load i32, i32* %type21, align 4, !tbaa !354
  %or = or i32 %1, %type
  store i32 %or, i32* %type21, align 4, !tbaa !354
  %key22 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 7
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %key22, i64 0, i64 %idxprom
  store i32 %keytype, i32* %arrayidx, align 4, !tbaa !47
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %if.end
  %retval.0 = phi i32 [ 0, %if.end20 ], [ -22, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @fls(i32 %x) #3 {
entry:
  %0 = call i32 asm "bsrl $1,$0", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i32 %x, i32 -1) #11, !srcloc !356
  %add = add nsw i32 %0, 1
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define void @snd_jack_set_parent(%struct.snd_jack* %jack, %struct.device* %parent) #0 {
entry:
  %registered = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 4
  %0 = load i32, i32* %registered, align 8, !tbaa !355
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool2 = icmp ne i32 %lnot.ext, 0
  %lnot3 = xor i1 %tobool2, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.1.228, i32 0, i32 0), i32 298)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool8 = icmp ne i32 %lnot.ext, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %input_dev = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 3
  %1 = load %struct.input_dev*, %struct.input_dev** %input_dev, align 8, !tbaa !353
  %tobool15 = icmp ne %struct.input_dev* %1, null
  br i1 %tobool15, label %if.end17, label %return

if.end17:                                         ; preds = %if.end
  %input_dev18 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 3
  %2 = load %struct.input_dev*, %struct.input_dev** %input_dev18, align 8, !tbaa !353
  %dev = getelementptr inbounds %struct.input_dev, %struct.input_dev* %2, i32 0, i32 39
  %parent19 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  store %struct.device* %parent, %struct.device** %parent19, align 8, !tbaa !357
  br label %return

return:                                           ; preds = %if.end17, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_jack_new(%struct.snd_card* %card, i8* %id, i32 %type, %struct.snd_jack** %jjack, i1 zeroext %initial_kctl, i1 zeroext %phantom_jack) #0 {
entry:
  %frombool = zext i1 %initial_kctl to i8
  %frombool1 = zext i1 %phantom_jack to i8
  %tobool = trunc i8 %frombool to i1
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %call = call %struct.snd_jack_kctl* @snd_jack_kctl_new(%struct.snd_card* %card, i8* %id, i32 %type)
  %tobool2 = icmp ne %struct.snd_jack_kctl* %call, null
  br i1 %tobool2, label %if.end4, label %cleanup35

if.end4:                                          ; preds = %if.then, %entry
  %jack_kctl.0 = phi %struct.snd_jack_kctl* [ null, %entry ], [ %call, %if.then ]
  %call5 = call i8* @kzalloc.229(i64 192, i32 20971712)
  %0 = bitcast i8* %call5 to %struct.snd_jack*
  %cmp = icmp eq %struct.snd_jack* %0, null
  br i1 %cmp, label %cleanup35, label %if.end7

if.end7:                                          ; preds = %if.end4
  %call8 = call noalias i8* @kstrdup(i8* %id, i32 20971712)
  %id9 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 2
  store i8* %call8, i8** %id9, align 8, !tbaa !360
  %tobool10 = trunc i8 %frombool1 to i1
  br i1 %tobool10, label %if.end24, label %if.then11

if.then11:                                        ; preds = %if.end7
  %call12 = call %struct.input_dev* @input_allocate_device()
  %input_dev = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 3
  store %struct.input_dev* %call12, %struct.input_dev** %input_dev, align 8, !tbaa !353
  %input_dev13 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 3
  %1 = load %struct.input_dev*, %struct.input_dev** %input_dev13, align 8, !tbaa !353
  %cmp14 = icmp eq %struct.input_dev* %1, null
  br i1 %cmp14, label %NodeBlock, label %if.end16

if.end16:                                         ; preds = %if.then11
  %input_dev17 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 3
  %2 = load %struct.input_dev*, %struct.input_dev** %input_dev17, align 8, !tbaa !353
  %phys = getelementptr inbounds %struct.input_dev, %struct.input_dev* %2, i32 0, i32 1
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.230, i32 0, i32 0), i8** %phys, align 8, !tbaa !361
  %type18 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 5
  store i32 %type, i32* %type18, align 4, !tbaa !354
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end16
  %i.0 = phi i32 [ 0, %if.end16 ], [ %inc, %for.inc ]
  %cmp19 = icmp slt i32 %i.0, 6
  br i1 %cmp19, label %for.body, label %NodeBlock

for.body:                                         ; preds = %for.cond
  %shl = shl i32 1, %i.0
  %and = and i32 %type, %shl
  %tobool20 = icmp ne i32 %and, 0
  br i1 %tobool20, label %if.then21, label %for.inc

if.then21:                                        ; preds = %for.body
  %input_dev22 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 3
  %3 = load %struct.input_dev*, %struct.input_dev** %input_dev22, align 8, !tbaa !353
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* @jack_switch_types, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4, !tbaa !47
  call void @input_set_capability(%struct.input_dev* %3, i32 5, i32 %4)
  br label %for.inc

for.inc:                                          ; preds = %if.then21, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

NodeBlock:                                        ; preds = %for.cond, %if.then11
  %cleanup.dest.slot.0 = phi i32 [ 2, %if.then11 ], [ 0, %for.cond ]
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 2
  br i1 %SwitchLeaf2, label %fail_input, label %cleanup35

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %if.end24, label %cleanup35

if.end24:                                         ; preds = %LeafBlock, %if.end7
  %5 = bitcast %struct.snd_jack* %0 to i8*
  %call25 = call i32 @snd_device_new(%struct.snd_card* %card, i32 11, i8* %5, %struct.snd_device_ops* @snd_jack_new.ops)
  %cmp26 = icmp slt i32 %call25, 0
  br i1 %cmp26, label %fail_input, label %if.end28

if.end28:                                         ; preds = %if.end24
  %card29 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 1
  store %struct.snd_card* %card, %struct.snd_card** %card29, align 8, !tbaa !348
  %kctl_list = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 0
  call void @INIT_LIST_HEAD.231(%struct.list_head* %kctl_list)
  %tobool30 = trunc i8 %frombool to i1
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  call void @snd_jack_kctl_add(%struct.snd_jack* %0, %struct.snd_jack_kctl* %jack_kctl.0)
  br label %if.end32

if.end32:                                         ; preds = %if.then31, %if.end28
  store %struct.snd_jack* %0, %struct.snd_jack** %jjack, align 8, !tbaa !2
  br label %cleanup35

fail_input:                                       ; preds = %if.end24, %LeafBlock1
  %err.1 = phi i32 [ -12, %LeafBlock1 ], [ %call25, %if.end24 ]
  %input_dev33 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 3
  %6 = load %struct.input_dev*, %struct.input_dev** %input_dev33, align 8, !tbaa !353
  call void @input_free_device(%struct.input_dev* %6)
  %id34 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %0, i32 0, i32 2
  %7 = load i8*, i8** %id34, align 8, !tbaa !360
  call void @kfree(i8* %7)
  %8 = bitcast %struct.snd_jack* %0 to i8*
  call void @kfree(i8* %8)
  br label %cleanup35

cleanup35:                                        ; preds = %fail_input, %if.end32, %LeafBlock, %LeafBlock1, %if.end4, %if.then
  %retval.0 = phi i32 [ %err.1, %fail_input ], [ 0, %if.end32 ], [ -12, %if.then ], [ -12, %if.end4 ], [ undef, %LeafBlock1 ], [ undef, %LeafBlock ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.snd_jack_kctl* @snd_jack_kctl_new(%struct.snd_card* %card, i8* %name, i32 %mask) #0 {
entry:
  %call = call %struct.snd_kcontrol* @snd_kctl_jack_new(i8* %name, %struct.snd_card* %card)
  %tobool = icmp ne %struct.snd_kcontrol* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @snd_ctl_add(%struct.snd_card* %card, %struct.snd_kcontrol* %call)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %call4 = call i8* @kzalloc.229(i64 32, i32 20971712)
  %0 = bitcast i8* %call4 to %struct.snd_jack_kctl*
  %tobool5 = icmp ne %struct.snd_jack_kctl* %0, null
  br i1 %tobool5, label %if.end7, label %error

if.end7:                                          ; preds = %if.end3
  %kctl8 = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %0, i32 0, i32 0
  store %struct.snd_kcontrol* %call, %struct.snd_kcontrol** %kctl8, align 8, !tbaa !350
  %mask_bits = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %0, i32 0, i32 2
  store i32 %mask, i32* %mask_bits, align 8, !tbaa !352
  %1 = bitcast %struct.snd_jack_kctl* %0 to i8*
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 8
  store i8* %1, i8** %private_data, align 8, !tbaa !202
  %private_free = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %call, i32 0, i32 9
  store void (%struct.snd_kcontrol*)* @snd_jack_kctl_private_free, void (%struct.snd_kcontrol*)** %private_free, align 8, !tbaa !185
  br label %cleanup

error:                                            ; preds = %if.end3
  call void @snd_ctl_free_one(%struct.snd_kcontrol* %call)
  br label %cleanup

cleanup:                                          ; preds = %error, %if.end7, %if.end, %entry
  %retval.0 = phi %struct.snd_jack_kctl* [ %0, %if.end7 ], [ null, %error ], [ null, %entry ], [ null, %if.end ]
  ret %struct.snd_jack_kctl* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.229(i64 %size, i32 %flags) #5 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc.240(i64 %size, i32 %or)
  ret i8* %call
}

declare %struct.input_dev* @input_allocate_device() #1

declare void @input_set_capability(%struct.input_dev*, i32, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD.231(%struct.list_head* %list) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !49
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.234(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snd_jack_kctl_add(%struct.snd_jack* %jack, %struct.snd_jack_kctl* %jack_kctl) #0 {
entry:
  %list = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %jack_kctl, i32 0, i32 1
  %kctl_list = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 0
  call void @list_add_tail.232(%struct.list_head* %list, %struct.list_head* %kctl_list)
  ret void
}

declare void @input_free_device(%struct.input_dev*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail.232(%struct.list_head* %new, %struct.list_head* %head) #5 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  call void @__list_add.233(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add.233(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !117
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !116
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !49
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.234(i8* %1, i8* %arraydecay, i32 8)
  %__val5 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val5, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size.234(i8* %p, i8* %res, i32 %size) #3 {
entry:
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %entry
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %sw.default

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !49
  store volatile i8 %0, i8* %p, align 1, !tbaa !49
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !118
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !118
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !47
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !47
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !119
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !119
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !362
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #9, !srcloc !363
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_jack_dev_free(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !204
  %1 = bitcast i8* %0 to %struct.snd_jack*
  %card1 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 1
  %2 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !279
  %kctl_list = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %kctl_list, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 -8
  %5 = bitcast i8* %add.ptr to %struct.snd_jack_kctl*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.snd_jack_kctl* [ %8, %for.body ], [ %5, %entry ]
  %jack_kctl.0 = phi %struct.snd_jack_kctl* [ %5, %entry ], [ %8, %for.body ]
  %list10 = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %.sink, i32 0, i32 1
  %next11 = getelementptr inbounds %struct.list_head, %struct.list_head* %list10, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next11, align 8, !tbaa !364
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %7, i64 -8
  %8 = bitcast i8* %add.ptr13 to %struct.snd_jack_kctl*
  %list6 = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %jack_kctl.0, i32 0, i32 1
  %kctl_list7 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list6, %kctl_list7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %list8 = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %jack_kctl.0, i32 0, i32 1
  call void @list_del_init.237(%struct.list_head* %list8)
  %kctl = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %jack_kctl.0, i32 0, i32 0
  %9 = load %struct.snd_kcontrol*, %struct.snd_kcontrol** %kctl, align 8, !tbaa !350
  %call = call i32 @snd_ctl_remove(%struct.snd_card* %2, %struct.snd_kcontrol* %9)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %private_free = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 9
  %10 = load void (%struct.snd_jack*)*, void (%struct.snd_jack*)** %private_free, align 8, !tbaa !365
  %tobool = icmp ne void (%struct.snd_jack*)* %10, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %private_free14 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 9
  %11 = load void (%struct.snd_jack*)*, void (%struct.snd_jack*)** %private_free14, align 8, !tbaa !365
  call void %11(%struct.snd_jack* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %call15 = call i32 @snd_jack_dev_disconnect(%struct.snd_device* %device)
  %id = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 2
  %12 = load i8*, i8** %id, align 8, !tbaa !360
  call void @kfree(i8* %12)
  %13 = bitcast %struct.snd_jack* %1 to i8*
  call void @kfree(i8* %13)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_jack_dev_register(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !204
  %1 = bitcast i8* %0 to %struct.snd_jack*
  %card1 = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 1
  %2 = load %struct.snd_card*, %struct.snd_card** %card1, align 8, !tbaa !279
  %name = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 6
  %arraydecay = getelementptr inbounds [100 x i8], [100 x i8]* %name, i32 0, i32 0
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 3
  %arraydecay2 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  %id = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 2
  %3 = load i8*, i8** %id, align 8, !tbaa !360
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 100, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.2.235, i32 0, i32 0), i8* %arraydecay2, i8* %3)
  %input_dev = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  %4 = load %struct.input_dev*, %struct.input_dev** %input_dev, align 8, !tbaa !353
  %tobool = icmp ne %struct.input_dev* %4, null
  br i1 %tobool, label %if.end, label %cleanup35

if.end:                                           ; preds = %entry
  %name3 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 6
  %arraydecay4 = getelementptr inbounds [100 x i8], [100 x i8]* %name3, i32 0, i32 0
  %input_dev5 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  %5 = load %struct.input_dev*, %struct.input_dev** %input_dev5, align 8, !tbaa !353
  %name6 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %5, i32 0, i32 0
  store i8* %arraydecay4, i8** %name6, align 8, !tbaa !366
  %input_dev7 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  %6 = load %struct.input_dev*, %struct.input_dev** %input_dev7, align 8, !tbaa !353
  %dev = getelementptr inbounds %struct.input_dev, %struct.input_dev* %6, i32 0, i32 39
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %7 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !357
  %tobool8 = icmp ne %struct.device* %7, null
  br i1 %tobool8, label %if.end14, label %if.then9

if.then9:                                         ; preds = %if.end
  %call10 = call %struct.device* @snd_card_get_device_link.236(%struct.snd_card* %2)
  %input_dev11 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  %8 = load %struct.input_dev*, %struct.input_dev** %input_dev11, align 8, !tbaa !353
  %dev12 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %8, i32 0, i32 39
  %parent13 = getelementptr inbounds %struct.device, %struct.device* %dev12, i32 0, i32 0
  store %struct.device* %call10, %struct.device** %parent13, align 8, !tbaa !357
  br label %if.end14

if.end14:                                         ; preds = %if.then9, %if.end
  br label %for.cond

for.cond:                                         ; preds = %LeafBlock, %if.end14
  %i.0 = phi i32 [ 0, %if.end14 ], [ %inc, %LeafBlock ]
  %conv = sext i32 %i.0 to i64
  %cmp = icmp ult i64 %conv, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %shr = ashr i32 16384, %i.0
  %type = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 5
  %9 = load i32, i32* %type, align 4, !tbaa !354
  %and = and i32 %9, %shr
  %tobool16 = icmp ne i32 %and, 0
  br i1 %tobool16, label %if.end18, label %LeafBlock

if.end18:                                         ; preds = %for.body
  %key = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 7
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %key, i64 0, i64 %idxprom
  %10 = load i32, i32* %arrayidx, align 4, !tbaa !47
  %tobool19 = icmp ne i32 %10, 0
  br i1 %tobool19, label %if.end24, label %if.then20

if.then20:                                        ; preds = %if.end18
  %add = add nsw i32 256, %i.0
  %key21 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 7
  %idxprom22 = sext i32 %i.0 to i64
  %arrayidx23 = getelementptr inbounds [6 x i32], [6 x i32]* %key21, i64 0, i64 %idxprom22
  store i32 %add, i32* %arrayidx23, align 4, !tbaa !47
  br label %if.end24

if.end24:                                         ; preds = %if.then20, %if.end18
  %input_dev25 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  %11 = load %struct.input_dev*, %struct.input_dev** %input_dev25, align 8, !tbaa !353
  %key26 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 7
  %idxprom27 = sext i32 %i.0 to i64
  %arrayidx28 = getelementptr inbounds [6 x i32], [6 x i32]* %key26, i64 0, i64 %idxprom27
  %12 = load i32, i32* %arrayidx28, align 4, !tbaa !47
  call void @input_set_capability(%struct.input_dev* %11, i32 1, i32 %12)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end24, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end24 ], [ 4, %for.body ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 4
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %input_dev29 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  %13 = load %struct.input_dev*, %struct.input_dev** %input_dev29, align 8, !tbaa !353
  %call30 = call i32 @input_register_device(%struct.input_dev* %13)
  %cmp31 = icmp eq i32 %call30, 0
  br i1 %cmp31, label %if.then33, label %cleanup35

if.then33:                                        ; preds = %for.end
  %registered = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 4
  store i32 1, i32* %registered, align 8, !tbaa !355
  br label %cleanup35

cleanup35:                                        ; preds = %if.then33, %for.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %call30, %if.then33 ], [ %call30, %for.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_jack_dev_disconnect(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !204
  %1 = bitcast i8* %0 to %struct.snd_jack*
  %input_dev = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  %2 = load %struct.input_dev*, %struct.input_dev** %input_dev, align 8, !tbaa !353
  %tobool = icmp ne %struct.input_dev* %2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %registered = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 4
  %3 = load i32, i32* %registered, align 8, !tbaa !355
  %tobool1 = icmp ne i32 %3, 0
  %input_dev3 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  %4 = load %struct.input_dev*, %struct.input_dev** %input_dev3, align 8, !tbaa !353
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  call void @input_unregister_device(%struct.input_dev* %4)
  br label %if.end5

if.else:                                          ; preds = %if.end
  call void @input_free_device(%struct.input_dev* %4)
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then2
  %input_dev6 = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %1, i32 0, i32 3
  store %struct.input_dev* null, %struct.input_dev** %input_dev6, align 8, !tbaa !353
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %entry
  ret i32 0
}

declare void @input_unregister_device(%struct.input_dev*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.device* @snd_card_get_device_link.236(%struct.snd_card* %card) #5 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %card_dev = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 30
  %cond = select i1 %tobool, %struct.device* %card_dev, %struct.device* null
  ret %struct.device* %cond
}

declare i32 @input_register_device(%struct.input_dev*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init.237(%struct.list_head* %entry1) #5 {
entry:
  call void @__list_del_entry.238(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD.231(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry.238(%struct.list_head* %entry1) #5 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !117
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  call void @__list_del.239(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del.239(%struct.list_head* %prev, %struct.list_head* %next) #5 {
entry:
  %__u = alloca %union.anon.61, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !117
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #9
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !49
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size.234(i8* %1, i8* %arraydecay, i32 8)
  %__val3 = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val3, align 8, !tbaa !49
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #9
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc.240(i64 %size, i32 %flags) #3 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal void @snd_jack_kctl_private_free(%struct.snd_kcontrol* %kctl) #0 {
entry:
  %private_data = getelementptr inbounds %struct.snd_kcontrol, %struct.snd_kcontrol* %kctl, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !202
  %1 = bitcast i8* %0 to %struct.snd_jack_kctl*
  %tobool = icmp ne %struct.snd_jack_kctl* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %list = getelementptr inbounds %struct.snd_jack_kctl, %struct.snd_jack_kctl* %1, i32 0, i32 1
  call void @list_del.241(%struct.list_head* %list)
  %2 = bitcast %struct.snd_jack_kctl* %1 to i8*
  call void @kfree(i8* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del.241(%struct.list_head* %entry1) #5 {
entry:
  call void @__list_del_entry.238(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !116
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !117
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_jack_add_new_kctl(%struct.snd_jack* %jack, i8* %name, i32 %mask) #0 {
entry:
  %card = getelementptr inbounds %struct.snd_jack, %struct.snd_jack* %jack, i32 0, i32 1
  %0 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !348
  %call = call %struct.snd_jack_kctl* @snd_jack_kctl_new(%struct.snd_card* %0, i8* %name, i32 %mask)
  %tobool = icmp ne %struct.snd_jack_kctl* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  call void @snd_jack_kctl_add(%struct.snd_jack* %jack, %struct.snd_jack_kctl* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readnone }
attributes #3 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { argmemonly nounwind }
attributes #7 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind readnone speculatable }
attributes #9 = { nounwind }
attributes #10 = { noreturn }
attributes #11 = { nounwind readonly }

!llvm.ident = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !3, i64 0}
!3 = !{!"any pointer", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !3, i64 32}
!7 = !{!"snd_minor", !8, i64 0, !8, i64 4, !8, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40}
!8 = !{!"int", !4, i64 0}
!9 = !{!7, !8, i64 0}
!10 = !{!11, !8, i64 0}
!11 = !{!"snd_card", !8, i64 0, !4, i64 4, !4, i64 20, !4, i64 36, !4, i64 68, !4, i64 148, !4, i64 180, !4, i64 260, !3, i64 392, !3, i64 400, !3, i64 408, !12, i64 416, !13, i64 432, !8, i64 1856, !37, i64 1864, !40, i64 2024, !8, i64 2096, !8, i64 2100, !12, i64 2104, !12, i64 2120, !25, i64 2136, !3, i64 2296, !3, i64 2304, !3, i64 2312, !12, i64 2320, !3, i64 2336, !26, i64 2344, !8, i64 2416, !3, i64 2424, !3, i64 2432, !13, i64 2440, !4, i64 3864, !31, i64 3896, !8, i64 3900, !25, i64 3904, !33, i64 4064, !3, i64 4152, !8, i64 4160}
!12 = !{!"list_head", !3, i64 0, !3, i64 8}
!13 = !{!"device", !3, i64 0, !3, i64 8, !14, i64 16, !3, i64 280, !3, i64 288, !25, i64 296, !3, i64 456, !3, i64 464, !3, i64 472, !3, i64 480, !28, i64 488, !29, i64 528, !3, i64 1104, !3, i64 1112, !3, i64 1120, !12, i64 1128, !8, i64 1144, !3, i64 1152, !3, i64 1160, !34, i64 1168, !21, i64 1176, !3, i64 1184, !12, i64 1192, !3, i64 1208, !3, i64 1216, !35, i64 1224, !3, i64 1232, !3, i64 1240, !8, i64 1248, !8, i64 1252, !26, i64 1256, !12, i64 1328, !36, i64 1344, !3, i64 1376, !3, i64 1384, !3, i64 1392, !3, i64 1400, !3, i64 1408, !31, i64 1416, !31, i64 1416}
!14 = !{!"kobject", !3, i64 0, !12, i64 8, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !15, i64 56, !18, i64 64, !8, i64 256, !8, i64 256, !8, i64 256, !8, i64 256, !8, i64 256}
!15 = !{!"kref", !16, i64 0}
!16 = !{!"refcount_struct", !17, i64 0}
!17 = !{!"", !8, i64 0}
!18 = !{!"delayed_work", !19, i64 0, !23, i64 80, !3, i64 176, !8, i64 184}
!19 = !{!"work_struct", !20, i64 0, !12, i64 8, !3, i64 24, !22, i64 32}
!20 = !{!"", !21, i64 0}
!21 = !{!"long", !4, i64 0}
!22 = !{!"lockdep_map", !3, i64 0, !4, i64 8, !3, i64 24, !8, i64 32, !21, i64 40}
!23 = !{!"timer_list", !24, i64 0, !21, i64 16, !3, i64 24, !21, i64 32, !8, i64 40, !22, i64 48}
!24 = !{!"hlist_node", !3, i64 0, !3, i64 8}
!25 = !{!"mutex", !20, i64 0, !26, i64 8, !27, i64 80, !12, i64 88, !3, i64 104, !22, i64 112}
!26 = !{!"spinlock", !4, i64 0}
!27 = !{!"optimistic_spin_queue", !17, i64 0}
!28 = !{!"dev_links_info", !12, i64 0, !12, i64 16, !4, i64 32}
!29 = !{!"dev_pm_info", !30, i64 0, !8, i64 4, !8, i64 4, !31, i64 4, !31, i64 4, !31, i64 4, !31, i64 4, !31, i64 4, !31, i64 4, !31, i64 5, !26, i64 8, !12, i64 80, !32, i64 96, !3, i64 192, !31, i64 200, !31, i64 200, !31, i64 200, !23, i64 208, !21, i64 304, !19, i64 312, !33, i64 392, !3, i64 480, !17, i64 488, !17, i64 492, !8, i64 496, !8, i64 496, !8, i64 496, !8, i64 496, !8, i64 496, !8, i64 496, !31, i64 497, !8, i64 497, !8, i64 497, !8, i64 497, !8, i64 497, !8, i64 497, !8, i64 500, !4, i64 504, !4, i64 508, !8, i64 512, !8, i64 516, !21, i64 520, !21, i64 528, !21, i64 536, !21, i64 544, !3, i64 552, !3, i64 560, !3, i64 568}
!30 = !{!"pm_message", !8, i64 0}
!31 = !{!"_Bool", !4, i64 0}
!32 = !{!"completion", !8, i64 0, !33, i64 8}
!33 = !{!"__wait_queue_head", !26, i64 0, !12, i64 72}
!34 = !{!"long long", !4, i64 0}
!35 = !{!"dev_archdata", !3, i64 0}
!36 = !{!"klist_node", !3, i64 0, !12, i64 8, !15, i64 24}
!37 = !{!"rw_semaphore", !20, i64 0, !12, i64 8, !38, i64 24, !27, i64 96, !3, i64 104, !22, i64 112}
!38 = !{!"raw_spinlock", !39, i64 0, !8, i64 4, !8, i64 8, !3, i64 16, !22, i64 24}
!39 = !{!"qspinlock", !17, i64 0}
!40 = !{!"", !41, i64 0, !8, i64 8, !8, i64 12, !3, i64 16, !22, i64 24}
!41 = !{!"qrwlock", !17, i64 0, !39, i64 4}
!42 = !{!7, !8, i64 4}
!43 = !{!7, !8, i64 8}
!44 = !{!7, !3, i64 16}
!45 = !{!7, !3, i64 24}
!46 = !{!7, !3, i64 40}
!47 = !{!8, !8, i64 0}
!48 = !{!13, !8, i64 1248}
!49 = !{!4, !4, i64 0}
!50 = !{!51, !3, i64 0}
!51 = !{!"snd_info_buffer", !3, i64 0, !8, i64 8, !8, i64 12, !8, i64 16, !8, i64 20, !8, i64 24}
!52 = !{!53, !3, i64 0}
!53 = !{!"file_operations", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !3, i64 112, !3, i64 120, !3, i64 128, !3, i64 136, !3, i64 144, !3, i64 152, !3, i64 160, !3, i64 168, !3, i64 176, !3, i64 184, !3, i64 192, !3, i64 200, !3, i64 208, !3, i64 216, !3, i64 224, !3, i64 232}
!54 = !{!55, !3, i64 40}
!55 = !{!"file", !4, i64 0, !56, i64 16, !3, i64 32, !3, i64 40, !26, i64 48, !20, i64 120, !8, i64 128, !8, i64 132, !25, i64 136, !34, i64 296, !57, i64 304, !3, i64 400, !58, i64 408, !34, i64 440, !3, i64 448, !3, i64 456, !12, i64 464, !12, i64 480, !3, i64 496}
!56 = !{!"path", !3, i64 0, !3, i64 8}
!57 = !{!"fown_struct", !40, i64 0, !3, i64 72, !4, i64 80, !17, i64 84, !17, i64 88, !8, i64 92}
!58 = !{!"file_ra_state", !21, i64 0, !8, i64 8, !8, i64 12, !8, i64 16, !8, i64 20, !34, i64 24}
!59 = !{i32 -2143656082, i32 -2143656057, i32 -2143655787, i32 -2143655990, i32 -2143655959, i32 -2143655929}
!60 = !{!53, !3, i64 96}
!61 = !{!62, !8, i64 76}
!62 = !{!"inode", !63, i64 0, !63, i64 2, !17, i64 4, !17, i64 8, !8, i64 12, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !21, i64 64, !4, i64 72, !8, i64 76, !34, i64 80, !64, i64 88, !64, i64 104, !64, i64 120, !26, i64 136, !63, i64 208, !8, i64 212, !21, i64 216, !21, i64 224, !37, i64 232, !21, i64 392, !21, i64 400, !24, i64 408, !12, i64 424, !3, i64 440, !8, i64 448, !63, i64 452, !63, i64 454, !12, i64 456, !12, i64 472, !12, i64 488, !4, i64 504, !34, i64 520, !17, i64 528, !17, i64 532, !17, i64 536, !17, i64 540, !3, i64 544, !3, i64 552, !65, i64 560, !12, i64 976, !4, i64 992, !8, i64 1000, !8, i64 1004, !68, i64 1008, !3, i64 1016, !3, i64 1024}
!63 = !{!"short", !4, i64 0}
!64 = !{!"timespec", !21, i64 0, !21, i64 8}
!65 = !{!"address_space", !3, i64 0, !66, i64 8, !26, i64 24, !17, i64 96, !67, i64 104, !37, i64 112, !21, i64 272, !21, i64 280, !21, i64 288, !3, i64 296, !21, i64 304, !26, i64 312, !8, i64 384, !12, i64 392, !3, i64 408}
!66 = !{!"radix_tree_root", !8, i64 0, !3, i64 8}
!67 = !{!"rb_root", !3, i64 0}
!68 = !{!"hlist_head", !3, i64 0}
!69 = !{!11, !8, i64 2416}
!70 = !{!71, !21, i64 11680}
!71 = !{!"task_struct", !72, i64 0, !21, i64 8, !3, i64 16, !17, i64 24, !8, i64 28, !8, i64 32, !73, i64 40, !8, i64 48, !8, i64 52, !8, i64 56, !21, i64 64, !3, i64 72, !8, i64 80, !8, i64 84, !8, i64 88, !8, i64 92, !8, i64 96, !8, i64 100, !3, i64 104, !74, i64 128, !79, i64 576, !3, i64 648, !80, i64 656, !68, i64 808, !8, i64 816, !8, i64 820, !8, i64 824, !83, i64 832, !21, i64 1856, !31, i64 1864, !12, i64 1872, !8, i64 1888, !84, i64 1896, !12, i64 1928, !85, i64 1944, !76, i64 1984, !3, i64 2008, !3, i64 2016, !86, i64 2024, !87, i64 2064, !8, i64 2084, !8, i64 2088, !8, i64 2092, !8, i64 2096, !21, i64 2104, !8, i64 2112, !8, i64 2116, !8, i64 2116, !8, i64 2116, !8, i64 2116, !8, i64 2120, !8, i64 2120, !8, i64 2120, !8, i64 2120, !8, i64 2120, !8, i64 2120, !8, i64 2120, !8, i64 2120, !21, i64 2128, !88, i64 2136, !8, i64 2184, !8, i64 2188, !3, i64 2192, !3, i64 2200, !12, i64 2208, !12, i64 2224, !3, i64 2240, !12, i64 2248, !12, i64 2264, !4, i64 2280, !12, i64 2352, !12, i64 2368, !3, i64 2384, !3, i64 2392, !3, i64 2400, !34, i64 2408, !34, i64 2416, !34, i64 2424, !89, i64 2432, !21, i64 2520, !21, i64 2528, !34, i64 2536, !34, i64 2544, !21, i64 2552, !21, i64 2560, !90, i64 2568, !4, i64 2592, !3, i64 2640, !3, i64 2648, !3, i64 2656, !4, i64 2664, !3, i64 2680, !91, i64 2688, !92, i64 2696, !21, i64 2712, !3, i64 2720, !3, i64 2728, !3, i64 2736, !3, i64 2744, !3, i64 2752, !93, i64 2760, !93, i64 2768, !93, i64 2776, !94, i64 2784, !21, i64 2808, !21, i64 2816, !8, i64 2824, !3, i64 2832, !3, i64 2840, !17, i64 2848, !8, i64 2852, !95, i64 2856, !8, i64 2872, !8, i64 2876, !26, i64 2880, !38, i64 2952, !96, i64 3024, !67, i64 3032, !3, i64 3040, !3, i64 3048, !3, i64 3056, !8, i64 3064, !21, i64 3072, !21, i64 3080, !8, i64 3088, !8, i64 3092, !8, i64 3096, !8, i64 3100, !21, i64 3104, !21, i64 3112, !8, i64 3120, !8, i64 3124, !8, i64 3128, !8, i64 3132, !34, i64 3136, !8, i64 3144, !8, i64 3148, !4, i64 3152, !8, i64 5840, !8, i64 5844, !3, i64 5848, !3, i64 5856, !3, i64 5864, !3, i64 5872, !3, i64 5880, !3, i64 5888, !21, i64 5896, !3, i64 5904, !97, i64 5912, !34, i64 5968, !34, i64 5976, !34, i64 5984, !93, i64 5992, !98, i64 6120, !8, i64 6176, !8, i64 6180, !3, i64 6184, !12, i64 6192, !8, i64 6208, !3, i64 6216, !3, i64 6224, !12, i64 6232, !3, i64 6248, !4, i64 6256, !25, i64 6272, !12, i64 6432, !3, i64 6448, !63, i64 6456, !63, i64 6458, !8, i64 6460, !8, i64 6464, !8, i64 6468, !8, i64 6472, !21, i64 6480, !34, i64 6488, !34, i64 6496, !34, i64 6504, !99, i64 6512, !12, i64 6528, !3, i64 6544, !3, i64 6552, !21, i64 6560, !4, i64 6568, !21, i64 6592, !100, i64 6600, !99, i64 7632, !3, i64 7648, !101, i64 7656, !3, i64 7672, !8, i64 7680, !8, i64 7684, !8, i64 7688, !21, i64 7696, !8, i64 7704, !4, i64 7712, !34, i64 11552, !34, i64 11560, !8, i64 11568, !8, i64 11572, !3, i64 11576, !34, i64 11584, !17, i64 11592, !17, i64 11596, !21, i64 11600, !21, i64 11608, !4, i64 11616, !8, i64 11620, !3, i64 11624, !3, i64 11632, !3, i64 11640, !8, i64 11648, !8, i64 11652, !8, i64 11656, !3, i64 11664, !8, i64 11672, !8, i64 11676, !21, i64 11680, !8, i64 11688, !3, i64 11696, !17, i64 11704, !102, i64 11712}
!72 = !{!"thread_info", !21, i64 0}
!73 = !{!"llist_node", !3, i64 0}
!74 = !{!"sched_entity", !75, i64 0, !76, i64 16, !12, i64 40, !8, i64 56, !34, i64 64, !34, i64 72, !34, i64 80, !34, i64 88, !34, i64 96, !77, i64 104, !8, i64 320, !3, i64 328, !3, i64 336, !3, i64 344, !78, i64 384}
!75 = !{!"load_weight", !21, i64 0, !8, i64 8}
!76 = !{!"rb_node", !21, i64 0, !3, i64 8, !3, i64 16}
!77 = !{!"sched_statistics", !34, i64 0, !34, i64 8, !34, i64 16, !34, i64 24, !34, i64 32, !34, i64 40, !34, i64 48, !34, i64 56, !34, i64 64, !34, i64 72, !34, i64 80, !34, i64 88, !34, i64 96, !34, i64 104, !34, i64 112, !34, i64 120, !34, i64 128, !34, i64 136, !34, i64 144, !34, i64 152, !34, i64 160, !34, i64 168, !34, i64 176, !34, i64 184, !34, i64 192, !34, i64 200, !34, i64 208}
!78 = !{!"sched_avg", !34, i64 0, !34, i64 8, !8, i64 16, !8, i64 20, !21, i64 24, !21, i64 32}
!79 = !{!"sched_rt_entity", !12, i64 0, !21, i64 16, !21, i64 24, !8, i64 32, !63, i64 36, !63, i64 38, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64}
!80 = !{!"sched_dl_entity", !76, i64 0, !34, i64 24, !34, i64 32, !34, i64 40, !34, i64 48, !34, i64 56, !34, i64 64, !8, i64 72, !8, i64 76, !8, i64 80, !8, i64 84, !81, i64 88}
!81 = !{!"hrtimer", !82, i64 0, !34, i64 32, !3, i64 40, !3, i64 48, !4, i64 56, !4, i64 57}
!82 = !{!"timerqueue_node", !76, i64 0, !34, i64 24}
!83 = !{!"cpumask", !4, i64 0}
!84 = !{!"sched_info", !21, i64 0, !34, i64 8, !34, i64 16, !34, i64 24}
!85 = !{!"plist_node", !8, i64 0, !12, i64 8, !12, i64 24}
!86 = !{!"vmacache", !8, i64 0, !4, i64 8}
!87 = !{!"task_rss_stat", !8, i64 0, !4, i64 4}
!88 = !{!"restart_block", !3, i64 0, !4, i64 8}
!89 = !{!"prev_cputime", !34, i64 0, !34, i64 8, !38, i64 16}
!90 = !{!"task_cputime", !34, i64 0, !34, i64 8, !34, i64 16}
!91 = !{!"sysv_sem", !3, i64 0}
!92 = !{!"sysv_shm", !12, i64 0}
!93 = !{!"", !4, i64 0}
!94 = !{!"sigpending", !12, i64 0, !93, i64 16}
!95 = !{!"seccomp", !8, i64 0, !3, i64 8}
!96 = !{!"wake_q_node", !3, i64 0}
!97 = !{!"task_io_accounting", !34, i64 0, !34, i64 8, !34, i64 16, !34, i64 24, !34, i64 32, !34, i64 40, !34, i64 48}
!98 = !{!"seqcount", !8, i64 0, !22, i64 8}
!99 = !{!"callback_head", !3, i64 0, !3, i64 8}
!100 = !{!"tlbflush_unmap_batch", !83, i64 0, !31, i64 1024, !31, i64 1025}
!101 = !{!"page_frag", !3, i64 0, !8, i64 8, !8, i64 12}
!102 = !{!"thread_struct", !4, i64 0, !21, i64 24, !21, i64 32, !63, i64 40, !63, i64 42, !63, i64 44, !63, i64 46, !8, i64 48, !21, i64 56, !21, i64 64, !4, i64 72, !21, i64 104, !21, i64 112, !21, i64 120, !21, i64 128, !21, i64 136, !3, i64 144, !21, i64 152, !8, i64 160, !20, i64 168, !8, i64 176, !8, i64 176, !103, i64 192}
!103 = !{!"fpu", !8, i64 0, !4, i64 4, !4, i64 5, !4, i64 64}
!104 = !{!21, !21, i64 0}
!105 = !{i32 -2143613615}
!106 = !{!11, !8, i64 3900}
!107 = !{i32 -2146710835}
!108 = !{!109, !8, i64 0}
!109 = !{!"__wait_queue", !8, i64 0, !3, i64 8, !3, i64 16, !12, i64 24}
!110 = !{!109, !3, i64 8}
!111 = !{!109, !3, i64 16}
!112 = !{!113, !3, i64 0}
!113 = !{!"snd_monitor_file", !3, i64 0, !3, i64 8, !12, i64 16, !12, i64 32}
!114 = !{!113, !3, i64 8}
!115 = !{!11, !3, i64 2432}
!116 = !{!12, !3, i64 0}
!117 = !{!12, !3, i64 8}
!118 = !{!63, !63, i64 0}
!119 = !{!34, !34, i64 0}
!120 = !{i32 -2147038545}
!121 = !{i32 -2147038507}
!122 = !{!11, !31, i64 3896}
!123 = !{i8 0, i8 2}
!124 = !{!11, !3, i64 2296}
!125 = !{!126, !3, i64 0}
!126 = !{!"snd_info_entry", !3, i64 0, !63, i64 8, !21, i64 16, !63, i64 24, !4, i64 32, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !25, i64 96, !12, i64 256, !12, i64 272}
!127 = !{!11, !3, i64 2304}
!128 = !{!126, !3, i64 56}
!129 = !{!11, !3, i64 2424}
!130 = !{!32, !8, i64 0}
!131 = !{i32 -2146873993, i32 -2146873954, i32 -2146873933, i32 -2146873896, i32 -2146873873, i32 -2146874003}
!132 = !{!55, !8, i64 128}
!133 = !{!53, !3, i64 128}
!134 = !{!53, !3, i64 112}
!135 = !{!11, !3, i64 400}
!136 = !{!11, !3, i64 392}
!137 = !{!11, !3, i64 2440}
!138 = !{!11, !3, i64 3816}
!139 = !{!11, !3, i64 3832}
!140 = !{!11, !3, i64 3824}
!141 = !{i32 578467, i32 578478, i32 -2146868740}
!142 = !{!31, !31, i64 0}
!143 = !{i32 -2146874739, i32 -2146874700, i32 -2146874679, i32 -2146874642, i32 -2146874619, i32 -2146874749}
!144 = !{!13, !3, i64 280}
!145 = !{!14, !3, i64 0}
!146 = !{!11, !3, i64 408}
!147 = !{!13, !3, i64 0}
!148 = !{!13, !3, i64 1376}
!149 = !{!13, !3, i64 1392}
!150 = !{!151, !8, i64 64}
!151 = !{!"snd_ctl_elem_info", !152, i64 0, !8, i64 64, !8, i64 68, !8, i64 72, !8, i64 76, !4, i64 80, !4, i64 208, !4, i64 216}
!152 = !{!"snd_ctl_elem_id", !8, i64 0, !8, i64 4, !8, i64 8, !8, i64 12, !4, i64 16, !8, i64 60}
!153 = !{!151, !8, i64 72}
!154 = !{!155, !3, i64 24}
!155 = !{!"snd_ctl_file", !12, i64 0, !3, i64 16, !3, i64 24, !4, i64 32, !33, i64 40, !26, i64 128, !3, i64 200, !8, i64 208, !12, i64 216}
!156 = !{i32 -2146650252}
!157 = !{!158, !3, i64 16}
!158 = !{!"pid_link", !24, i64 0, !3, i64 16}
!159 = !{!160, !3, i64 16}
!160 = !{!"snd_kctl_ioctl", !12, i64 0, !3, i64 16}
!161 = !{i32 -2146963046}
!162 = !{i32 -2146963008}
!163 = !{!152, !8, i64 0}
!164 = !{!165, !8, i64 20}
!165 = !{!"snd_kcontrol", !12, i64 0, !152, i64 16, !8, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !4, i64 112, !21, i64 120, !3, i64 128, !3, i64 136, !4, i64 144}
!166 = !{!152, !8, i64 4}
!167 = !{!165, !8, i64 24}
!168 = !{!152, !8, i64 8}
!169 = !{!165, !8, i64 28}
!170 = !{!152, !8, i64 12}
!171 = !{!165, !8, i64 76}
!172 = !{!152, !8, i64 60}
!173 = !{!165, !8, i64 80}
!174 = !{!165, !8, i64 16}
!175 = !{i64 0, i64 4, !47, i64 4, i64 4, !47, i64 8, i64 4, !47, i64 12, i64 4, !47, i64 16, i64 44, !49, i64 60, i64 4, !47}
!176 = !{!11, !8, i64 1856}
!177 = !{!178, !8, i64 8}
!178 = !{!"snd_kcontrol_volatile", !3, i64 0, !8, i64 8}
!179 = !{!11, !8, i64 4160}
!180 = !{!155, !8, i64 208}
!181 = !{!182, !8, i64 16}
!182 = !{!"snd_kctl_event", !12, i64 0, !152, i64 16, !8, i64 80}
!183 = !{!182, !8, i64 80}
!184 = !{!11, !8, i64 2096}
!185 = !{!165, !3, i64 136}
!186 = !{!165, !3, i64 88}
!187 = !{!188, !3, i64 40}
!188 = !{!"snd_kcontrol_new", !8, i64 0, !8, i64 4, !8, i64 8, !3, i64 16, !8, i64 24, !8, i64 28, !8, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !4, i64 64, !21, i64 72}
!189 = !{!188, !8, i64 32}
!190 = !{!188, !8, i64 28}
!191 = !{!188, !8, i64 0}
!192 = !{!188, !8, i64 4}
!193 = !{!188, !8, i64 8}
!194 = !{!188, !3, i64 16}
!195 = !{!188, !8, i64 24}
!196 = !{!188, !3, i64 48}
!197 = !{!165, !3, i64 96}
!198 = !{!188, !3, i64 56}
!199 = !{!165, !3, i64 104}
!200 = !{!188, !21, i64 72}
!201 = !{!165, !21, i64 120}
!202 = !{!165, !3, i64 128}
!203 = !{!178, !3, i64 0}
!204 = !{!205, !3, i64 32}
!205 = !{!"snd_device", !12, i64 0, !3, i64 16, !4, i64 24, !4, i64 28, !3, i64 32, !3, i64 40}
!206 = !{!11, !3, i64 2104}
!207 = !{!55, !3, i64 456}
!208 = !{!155, !3, i64 16}
!209 = !{i32 -2143389439}
!210 = !{!155, !3, i64 216}
!211 = !{!212, !8, i64 0}
!212 = !{!"snd_ctl_event", !8, i64 0, !4, i64 4}
!213 = !{i32 -2143409229}
!214 = !{i32 -2143393762}
!215 = !{i32 -2146963713}
!216 = !{i32 -2146963675}
!217 = !{i32 -2146355919, i32 -2146355880, i32 -2146355859, i32 -2146355822, i32 -2146355799, i32 -2146355929}
!218 = !{i32 -2143271273}
!219 = !{i32 -2143269272}
!220 = !{i32 -2143268565}
!221 = !{!151, !8, i64 76}
!222 = !{i32 -2143266617}
!223 = !{i32 -2143264672}
!224 = !{i32 -2143262711}
!225 = !{i32 -2143260737}
!226 = !{i32 -2143255406}
!227 = !{i32 -2143254550}
!228 = !{i32 -2143253633}
!229 = !{i32 -2143252693}
!230 = !{i32 -2143251753}
!231 = !{i32 -2143259459}
!232 = !{i32 -2143258514}
!233 = !{i32 -2143256735}
!234 = !{!151, !8, i64 0}
!235 = !{!11, !8, i64 2100}
!236 = !{!151, !8, i64 68}
!237 = !{!238, !3, i64 272}
!238 = !{!"user_element", !151, i64 0, !3, i64 272, !3, i64 280, !21, i64 288, !3, i64 296, !21, i64 304, !3, i64 312}
!239 = !{i64 0, i64 4, !47, i64 4, i64 4, !47, i64 8, i64 4, !47, i64 12, i64 4, !47, i64 16, i64 44, !49, i64 60, i64 4, !47, i64 64, i64 4, !47, i64 68, i64 4, !47, i64 72, i64 4, !47, i64 76, i64 4, !47, i64 80, i64 8, !104, i64 88, i64 8, !104, i64 96, i64 8, !104, i64 80, i64 8, !119, i64 88, i64 8, !119, i64 96, i64 8, !119, i64 80, i64 4, !47, i64 84, i64 4, !47, i64 88, i64 64, !49, i64 152, i64 8, !119, i64 160, i64 4, !47, i64 80, i64 128, !49, i64 208, i64 8, !49, i64 208, i64 8, !2, i64 216, i64 56, !49}
!240 = !{!238, !8, i64 68}
!241 = !{!238, !3, i64 280}
!242 = !{!238, !21, i64 288}
!243 = !{!238, !8, i64 64}
!244 = !{!238, !3, i64 296}
!245 = !{!238, !3, i64 312}
!246 = !{!238, !21, i64 304}
!247 = !{!248, !8, i64 0}
!248 = !{!"snd_ctl_elem_list", !8, i64 0, !8, i64 4, !8, i64 8, !8, i64 12, !3, i64 16, !4, i64 24}
!249 = !{!248, !8, i64 4}
!250 = !{!248, !8, i64 12}
!251 = !{!248, !8, i64 8}
!252 = !{!248, !3, i64 16}
!253 = !{!254, !8, i64 0}
!254 = !{!"snd_ctl_card_info", !8, i64 0, !8, i64 4, !4, i64 8, !4, i64 24, !4, i64 40, !4, i64 72, !4, i64 152, !4, i64 168, !4, i64 248}
!255 = !{i32 -2143413560}
!256 = !{i32 -2143411945}
!257 = !{!258, !8, i64 4}
!258 = !{!"snd_ctl_tlv", !8, i64 0, !8, i64 4, !4, i64 8}
!259 = !{!258, !8, i64 0}
!260 = !{!261, !3, i64 0}
!261 = !{!"poll_table_struct", !3, i64 0, !21, i64 8}
!262 = !{i32 547483, i32 547494, i32 -2146895663}
!263 = !{!264, !63, i64 64}
!264 = !{!"pci_dev", !12, i64 0, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !8, i64 56, !63, i64 60, !63, i64 62, !63, i64 64, !63, i64 66, !8, i64 68, !4, i64 72, !4, i64 73, !63, i64 74, !4, i64 76, !4, i64 77, !4, i64 78, !4, i64 79, !4, i64 80, !4, i64 81, !63, i64 82, !3, i64 88, !3, i64 96, !34, i64 104, !265, i64 112, !8, i64 128, !4, i64 132, !8, i64 133, !8, i64 133, !8, i64 133, !8, i64 133, !8, i64 134, !8, i64 134, !8, i64 134, !8, i64 134, !8, i64 134, !8, i64 134, !8, i64 134, !8, i64 134, !8, i64 135, !8, i64 135, !8, i64 136, !8, i64 140, !3, i64 144, !8, i64 152, !13, i64 160, !8, i64 1584, !8, i64 1588, !4, i64 1592, !31, i64 2680, !8, i64 2681, !8, i64 2681, !8, i64 2681, !8, i64 2681, !8, i64 2681, !8, i64 2681, !8, i64 2681, !8, i64 2681, !8, i64 2682, !8, i64 2682, !8, i64 2682, !8, i64 2682, !8, i64 2682, !8, i64 2682, !8, i64 2682, !8, i64 2683, !8, i64 2683, !8, i64 2683, !8, i64 2683, !8, i64 2683, !8, i64 2683, !8, i64 2683, !8, i64 2683, !8, i64 2684, !8, i64 2684, !8, i64 2684, !8, i64 2684, !63, i64 2686, !17, i64 2688, !4, i64 2692, !68, i64 2760, !3, i64 2768, !8, i64 2776, !4, i64 2784, !4, i64 2920, !8, i64 3056, !8, i64 3056, !4, i64 3057, !3, i64 3064, !3, i64 3072, !4, i64 3080, !63, i64 3088, !4, i64 3090, !17, i64 3092, !34, i64 3096, !21, i64 3104, !3, i64 3112}
!265 = !{!"device_dma_parameters", !8, i64 0, !21, i64 8}
!266 = !{!264, !63, i64 66}
!267 = !{!268, !63, i64 0}
!268 = !{!"snd_pci_quirk", !63, i64 0, !63, i64 2, !63, i64 4, !8, i64 8, !3, i64 16}
!269 = !{!268, !63, i64 2}
!270 = !{!268, !63, i64 4}
!271 = !{!272, !3, i64 0}
!272 = !{!"va_format", !3, i64 0, !3, i64 8}
!273 = !{!272, !3, i64 8}
!274 = !{!205, !4, i64 24}
!275 = !{!205, !3, i64 40}
!276 = !{!277, !3, i64 8}
!277 = !{!"snd_device_ops", !3, i64 0, !3, i64 8, !3, i64 16}
!278 = !{!277, !3, i64 0}
!279 = !{!205, !3, i64 16}
!280 = !{!277, !3, i64 16}
!281 = !{i32 -2147011991}
!282 = !{i32 -2147011953}
!283 = !{!205, !4, i64 28}
!284 = !{!205, !3, i64 8}
!285 = !{!126, !3, i64 48}
!286 = !{!126, !3, i64 88}
!287 = !{!126, !63, i64 8}
!288 = !{!126, !63, i64 24}
!289 = !{!126, !21, i64 16}
!290 = !{!291, !3, i64 248}
!291 = !{!"seq_file", !3, i64 0, !21, i64 8, !21, i64 16, !21, i64 24, !21, i64 32, !34, i64 40, !34, i64 48, !34, i64 56, !25, i64 64, !3, i64 224, !8, i64 232, !3, i64 240, !3, i64 248}
!292 = !{!293, !3, i64 16}
!293 = !{!"snd_info_private_data", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24}
!294 = !{!293, !3, i64 8}
!295 = !{!51, !8, i64 16}
!296 = !{!51, !8, i64 12}
!297 = !{!293, !3, i64 0}
!298 = !{!126, !3, i64 64}
!299 = !{!300, !3, i64 32}
!300 = !{!"snd_info_entry_ops", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56}
!301 = !{!293, !3, i64 24}
!302 = !{!55, !34, i64 296}
!303 = !{!300, !3, i64 16}
!304 = !{!300, !3, i64 24}
!305 = !{!300, !3, i64 40}
!306 = !{!300, !3, i64 48}
!307 = !{!300, !3, i64 56}
!308 = !{!300, !3, i64 0}
!309 = !{!300, !3, i64 8}
!310 = !{!55, !3, i64 32}
!311 = !{!126, !3, i64 272}
!312 = !{!126, !3, i64 80}
!313 = !{i32 -2147044998}
!314 = !{i32 -2147044960}
!315 = !{!51, !8, i64 20}
!316 = !{!51, !8, i64 24}
!317 = !{!51, !8, i64 8}
!318 = !{!11, !3, i64 2312}
!319 = !{i32 -2145060855}
!320 = !{i32 -2145060653}
!321 = !{!322, !8, i64 32}
!322 = !{!"link_master", !12, i64 0, !323, i64 16, !8, i64 32, !4, i64 36, !3, i64 56, !3, i64 64}
!323 = !{!"link_ctl_info", !8, i64 0, !8, i64 4, !8, i64 8, !8, i64 12}
!324 = !{!322, !3, i64 56}
!325 = !{!322, !3, i64 64}
!326 = !{!322, !8, i64 20}
!327 = !{i64 0, i64 4, !47, i64 4, i64 4, !47, i64 8, i64 4, !47, i64 12, i64 4, !47}
!328 = !{!322, !8, i64 28}
!329 = !{!330, !8, i64 28}
!330 = !{!"link_slave", !12, i64 0, !3, i64 16, !323, i64 24, !4, i64 40, !8, i64 48, !3, i64 56, !165, i64 64}
!331 = !{!330, !3, i64 16}
!332 = !{!330, !8, i64 24}
!333 = !{!330, !8, i64 32}
!334 = !{!330, !8, i64 36}
!335 = !{!330, !3, i64 168}
!336 = !{!330, !8, i64 48}
!337 = !{!330, !3, i64 152}
!338 = !{!330, !3, i64 160}
!339 = !{!322, !8, i64 16}
!340 = !{!322, !8, i64 24}
!341 = !{!330, !3, i64 0}
!342 = !{!330, !3, i64 56}
!343 = !{i64 0, i64 8, !2, i64 8, i64 8, !2}
!344 = !{i32 -2147005405}
!345 = !{i32 -2147005367}
!346 = !{i64 0, i64 8, !2, i64 8, i64 8, !2, i64 16, i64 4, !47, i64 20, i64 4, !47, i64 24, i64 4, !47, i64 28, i64 4, !47, i64 32, i64 44, !49, i64 76, i64 4, !47, i64 80, i64 4, !47, i64 88, i64 8, !2, i64 96, i64 8, !2, i64 104, i64 8, !2, i64 112, i64 8, !2, i64 112, i64 8, !2, i64 120, i64 8, !104, i64 128, i64 8, !2, i64 136, i64 8, !2, i64 144, i64 0, !49}
!347 = !{!330, !3, i64 200}
!348 = !{!349, !3, i64 16}
!349 = !{!"snd_jack", !12, i64 0, !3, i64 16, !3, i64 24, !3, i64 32, !8, i64 40, !8, i64 44, !4, i64 48, !4, i64 148, !3, i64 176, !3, i64 184}
!350 = !{!351, !3, i64 0}
!351 = !{!"snd_jack_kctl", !3, i64 0, !12, i64 8, !8, i64 24}
!352 = !{!351, !8, i64 24}
!353 = !{!349, !3, i64 32}
!354 = !{!349, !8, i64 44}
!355 = !{!349, !8, i64 40}
!356 = !{i32 565031}
!357 = !{!358, !3, i64 784}
!358 = !{!"input_dev", !3, i64 0, !3, i64 8, !3, i64 16, !359, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184, !4, i64 200, !8, i64 208, !8, i64 212, !8, i64 216, !3, i64 224, !3, i64 232, !3, i64 240, !3, i64 248, !8, i64 256, !23, i64 264, !4, i64 360, !3, i64 368, !3, i64 376, !4, i64 384, !4, i64 480, !4, i64 488, !4, i64 496, !3, i64 504, !3, i64 512, !3, i64 520, !3, i64 528, !3, i64 536, !26, i64 544, !25, i64 616, !8, i64 776, !31, i64 780, !13, i64 784, !12, i64 2208, !12, i64 2224, !8, i64 2240, !8, i64 2244, !3, i64 2248, !31, i64 2256}
!359 = !{!"input_id", !63, i64 0, !63, i64 2, !63, i64 4, !63, i64 6}
!360 = !{!349, !3, i64 24}
!361 = !{!358, !3, i64 8}
!362 = !{i32 -2147047081}
!363 = !{i32 -2147047043}
!364 = !{!351, !3, i64 8}
!365 = !{!349, !3, i64 184}
!366 = !{!358, !3, i64 0}
