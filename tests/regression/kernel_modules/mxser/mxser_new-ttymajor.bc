; ModuleID = 'tests/regression/kernel_modules/mxser/mxser_new-ttymajor.bc'
source_filename = "drivers/tty/mxser.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.49, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.5, i32 }
%union.anon.5 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.32, %union.anon.33, %union.anon.37, %union.anon.41, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%union.anon.32 = type { i64 }
%union.anon.33 = type { i64 }
%union.anon.37 = type { %struct.list_head }
%union.anon.41 = type { i64 }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct*, %struct.lockdep_map }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.7, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon.7 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type { %struct.kref, [128 x %struct.pidmap], %struct.callback_head, i32, i32, %struct.task_struct*, %struct.kmem_cache*, i32, %struct.pid_namespace*, %struct.vfsmount*, %struct.dentry*, %struct.dentry*, %struct.fs_pin*, %struct.user_namespace*, %struct.ucounts*, %struct.work_struct, %struct.kgid_t, i32, i32, %struct.ns_common }
%struct.pidmap = type { %struct.atomic_t, i8* }
%struct.kmem_cache = type opaque
%struct.fs_pin = type opaque
%struct.ucounts = type opaque
%struct.kgid_t = type { i32 }
%struct.ns_common = type { %struct.atomic64_t, %struct.proc_ns_operations*, i32 }
%struct.proc_ns_operations = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.cgroup_namespace* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.cgroup_namespace = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, %struct.tty_audit_buf*, i8, i16, i16, %struct.mm_struct*, %struct.mutex }
%struct.cpu_itimer = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic, i8, i8 }
%struct.task_cputime_atomic = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.tty_struct = type { i32, %struct.kref, %struct.device*, %struct.tty_driver*, %struct.tty_operations*, i32, %struct.ld_semaphore, %struct.tty_ldisc*, %struct.mutex, %struct.mutex, %struct.mutex, %struct.rw_semaphore, %struct.mutex, %struct.spinlock, %struct.spinlock, %struct.ktermios, %struct.ktermios, %struct.termiox*, [64 x i8], %struct.pid*, %struct.pid*, i64, i32, %struct.winsize, i8, i64, i32, i16, i56, i32, i32, %struct.tty_struct*, %struct.fasync_struct*, i32, %struct.__wait_queue_head, %struct.__wait_queue_head, %struct.work_struct, i8*, i8*, %struct.spinlock, %struct.list_head, i32, i8*, i32, %struct.work_struct, %struct.tty_port* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type opaque
%struct.fwnode_handle = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.tty_driver = type { i32, %struct.kref, %struct.cdev**, %struct.module*, i8*, i8*, i32, i32, i32, i32, i16, i16, %struct.ktermios, i64, %struct.proc_dir_entry*, %struct.tty_driver*, %struct.tty_struct**, %struct.tty_port**, %struct.ktermios**, i8*, %struct.tty_operations*, %struct.list_head }
%struct.cdev = type { %struct.kobject, %struct.module*, %struct.file_operations*, %struct.list_head, i32, i32 }
%struct.proc_dir_entry = type opaque
%struct.tty_operations = type { %struct.tty_struct* (%struct.tty_driver*, %struct.file*, i32)*, i32 (%struct.tty_driver*, %struct.tty_struct*)*, void (%struct.tty_driver*, %struct.tty_struct*)*, i32 (%struct.tty_struct*, %struct.file*)*, void (%struct.tty_struct*, %struct.file*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, i32 (%struct.tty_struct*, i8*, i32)*, i32 (%struct.tty_struct*, i8)*, void (%struct.tty_struct*)*, i32 (%struct.tty_struct*)*, i32 (%struct.tty_struct*)*, i32 (%struct.tty_struct*, i32, i64)*, i64 (%struct.tty_struct*, i32, i64)*, void (%struct.tty_struct*, %struct.ktermios*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, i32 (%struct.tty_struct*, i32)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*, i32)*, void (%struct.tty_struct*, i8)*, i32 (%struct.tty_struct*)*, i32 (%struct.tty_struct*, i32, i32)*, i32 (%struct.tty_struct*, %struct.winsize*)*, i32 (%struct.tty_struct*, %struct.termiox*)*, i32 (%struct.tty_struct*, %struct.serial_icounter_struct*)*, i32 (%struct.tty_driver*, i32, i8*)*, i32 (%struct.tty_driver*, i32)*, void (%struct.tty_driver*, i32, i8)*, %struct.file_operations* }
%struct.serial_icounter_struct = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [9 x i32] }
%struct.ld_semaphore = type { i64, %struct.raw_spinlock, i32, %struct.list_head, %struct.list_head, %struct.lockdep_map }
%struct.tty_ldisc = type { %struct.tty_ldisc_ops*, %struct.tty_struct* }
%struct.tty_ldisc_ops = type { i32, i8*, i32, i32, i32 (%struct.tty_struct*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, i64 (%struct.tty_struct*, %struct.file*, i8*, i64)*, i64 (%struct.tty_struct*, %struct.file*, i8*, i64)*, i32 (%struct.tty_struct*, %struct.file*, i32, i64)*, i64 (%struct.tty_struct*, %struct.file*, i32, i64)*, void (%struct.tty_struct*, %struct.ktermios*)*, i32 (%struct.tty_struct*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.tty_struct*)*, void (%struct.tty_struct*, i8*, i8*, i32)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*, i32)*, i32 (%struct.tty_struct*, i8*, i8*, i32)*, %struct.module*, i32 }
%struct.poll_table_struct = type opaque
%struct.ktermios = type { i32, i32, i32, i32, i8, [19 x i8], i32, i32 }
%struct.termiox = type { i16, i16, [5 x i16], i16 }
%struct.winsize = type { i16, i16, i16, i16 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.tty_port = type { %struct.tty_bufhead, %struct.tty_struct*, %struct.tty_struct*, %struct.tty_port_operations*, %struct.tty_port_client_operations*, %struct.spinlock, i32, i32, %struct.__wait_queue_head, %struct.__wait_queue_head, i64, i64, i8, %struct.mutex, %struct.mutex, i8*, i32, i32, i32, %struct.kref, i8* }
%struct.tty_bufhead = type { %struct.tty_buffer*, %struct.work_struct, %struct.mutex, %struct.atomic_t, %struct.tty_buffer, %struct.llist_head, %struct.atomic_t, i32, %struct.tty_buffer* }
%struct.tty_buffer = type { %union.anon.52, i32, i32, i32, i32, i32, [0 x i64] }
%union.anon.52 = type { %struct.tty_buffer* }
%struct.llist_head = type { %struct.llist_node* }
%struct.tty_port_operations = type { i32 (%struct.tty_port*)*, void (%struct.tty_port*, i32)*, void (%struct.tty_port*)*, i32 (%struct.tty_port*, %struct.tty_struct*)*, void (%struct.tty_port*)* }
%struct.tty_port_client_operations = type { i32 (%struct.tty_port*, i8*, i8*, i64)*, void (%struct.tty_port*)* }
%struct.autogroup = type opaque
%struct.seqlock_t = type { %struct.seqcount, %struct.spinlock }
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.12 }
%union.anon.12 = type { %struct.anon.16, [80 x i8] }
%struct.anon.16 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.22, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.22 = type { %struct.anon.23 }
%struct.anon.23 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.anon.29 }
%struct.anon.29 = type { i64, i64 }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.49 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.42, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.43, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.42 = type { i32 }
%struct.timespec = type { i64, i64 }
%struct.bdi_writeback = type opaque
%union.anon.43 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%union.anon.0 = type { %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.53, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.54, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i64, %union.anon.55, %union.anon.57, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.53 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.54 = type { i64 }
%union.anon.55 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.57 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, i64, %struct.atomic64_t, %struct.key*, %struct.key*, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %struct.pmd_t*, %struct.pud_t*, %struct.pte_t, %struct.page*, %struct.mem_cgroup*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%struct.pte_t = type { i64 }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head, i8*, %struct.lockdep_map }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.51 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.kparam_array = type { i32, i32, i32*, %struct.kernel_param_ops*, i8* }
%struct.mxser_board = type { i32, i32, %struct.mxser_cardinfo*, i64, i64, i32, i32, [8 x %struct.mxser_port] }
%struct.mxser_cardinfo = type { i8*, i32, i32 }
%struct.mxser_port = type { %struct.tty_port, %struct.mxser_board*, i64, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i8, i32, i8, %struct.async_icount, i32, i32, i32, i32, i32, i32, i32, i32, %struct.ktermios, %struct.mxser_mon, %struct.spinlock }
%struct.async_icount = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.mxser_mon = type { i64, i64, i64, i64, i32, i8 }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.pci_dynids }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i16, i8, i8, i8, i8, i8, i8, i16, [4 x i8], i64*, %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, [3 x i8], i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, i32, i8, i16, %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], i8, i8, [6 x i8], %struct.attribute_group**, %struct.pci_vpd*, %union.anon.59, i16, i8, i8, %struct.atomic_t, i64, i64, i8* }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, %struct.msi_controller*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*)*, void (%struct.pci_bus*)*, i8* (%struct.pci_bus*, i32, i32)*, i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.msi_controller = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.59 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*, i1)*, void (%struct.pci_dev*)* }
%struct.pci_dynids = type { %struct.spinlock, %struct.list_head }
%struct.ratelimit_state = type { %struct.raw_spinlock, i32, i32, i32, i32, i64, i64 }
%struct.mxser_log = type { i32, [32 x i64], [32 x i64] }
%struct.anon.60 = type { i32, i32, i32, i32, i32, i32, i32, i64 }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.serial_struct = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i8, [1 x i8], i32, i16, i16, i8*, i16, i32, i64 }

@mxser_pcibrds = internal global [27 x %struct.pci_device_id] [%struct.pci_device_id { i32 5011, i32 5760, i32 -1, i32 -1, i32 0, i32 0, i64 3 }, %struct.pci_device_id { i32 5011, i32 4160, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 5011, i32 4896, i32 -1, i32 -1, i32 0, i32 0, i64 8 }, %struct.pci_device_id { i32 5011, i32 4417, i32 -1, i32 -1, i32 0, i32 0, i64 9 }, %struct.pci_device_id { i32 5011, i32 4416, i32 -1, i32 -1, i32 0, i32 0, i64 10 }, %struct.pci_device_id { i32 5011, i32 4128, i32 -1, i32 -1, i32 0, i32 0, i64 11 }, %struct.pci_device_id { i32 5011, i32 4161, i32 -1, i32 -1, i32 0, i32 0, i64 12 }, %struct.pci_device_id { i32 5011, i32 5761, i32 -1, i32 -1, i32 0, i32 0, i64 13 }, %struct.pci_device_id { i32 5011, i32 4897, i32 -1, i32 -1, i32 0, i32 0, i64 14 }, %struct.pci_device_id { i32 5011, i32 4928, i32 -1, i32 -1, i32 0, i32 0, i64 15 }, %struct.pci_device_id { i32 5011, i32 4162, i32 -1, i32 -1, i32 0, i32 0, i64 16 }, %struct.pci_device_id { i32 5011, i32 1, i32 -1, i32 -1, i32 0, i32 0, i64 17 }, %struct.pci_device_id { i32 5011, i32 4480, i32 -1, i32 -1, i32 0, i32 0, i64 18 }, %struct.pci_device_id { i32 5011, i32 4129, i32 -1, i32 -1, i32 0, i32 0, i64 19 }, %struct.pci_device_id { i32 5011, i32 4130, i32 -1, i32 -1, i32 0, i32 0, i64 20 }, %struct.pci_device_id { i32 5011, i32 4481, i32 -1, i32 -1, i32 0, i32 0, i64 21 }, %struct.pci_device_id { i32 5011, i32 5762, i32 -1, i32 -1, i32 0, i32 0, i64 22 }, %struct.pci_device_id { i32 5011, i32 4163, i32 -1, i32 -1, i32 0, i32 0, i64 23 }, %struct.pci_device_id { i32 5011, i32 4224, i32 -1, i32 -1, i32 0, i32 0, i64 24 }, %struct.pci_device_id { i32 5011, i32 4418, i32 -1, i32 -1, i32 0, i32 0, i64 25 }, %struct.pci_device_id { i32 5011, i32 4929, i32 -1, i32 -1, i32 0, i32 0, i64 26 }, %struct.pci_device_id { i32 5011, i32 4992, i32 -1, i32 -1, i32 0, i32 0, i64 27 }, %struct.pci_device_id { i32 5011, i32 4164, i32 -1, i32 -1, i32 0, i32 0, i64 28 }, %struct.pci_device_id { i32 5011, i32 4419, i32 -1, i32 -1, i32 0, i32 0, i64 29 }, %struct.pci_device_id { i32 5011, i32 4131, i32 -1, i32 -1, i32 0, i32 0, i64 30 }, %struct.pci_device_id { i32 5011, i32 4384, i32 -1, i32 -1, i32 0, i32 0, i64 31 }, %struct.pci_device_id zeroinitializer], align 16
@__UNIQUE_ID_author12 = internal constant [19 x i8] c"author=Casper Yang\00", section ".modinfo", align 1
@__UNIQUE_ID_description13 = internal constant [71 x i8] c"description=MOXA Smartio/Industio Family Multiport Board Device Driver\00", section ".modinfo", align 1
@__param_str_ioaddr = internal constant [7 x i8] c"ioaddr\00", align 1
@__this_module = external global %struct.module, align 64
@param_array_ops = external constant %struct.kernel_param_ops, align 8
@__param_arr_ioaddr = internal constant %struct.kparam_array { i32 4, i32 8, i32* null, %struct.kernel_param_ops* @param_ops_ulong, i8* bitcast ([4 x i64]* @ioaddr to i8*) }, align 8
@__param_ioaddr = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_ioaddr, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_array_ops, i16 0, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_ioaddr } }, section "__param", align 8
@__UNIQUE_ID_ioaddrtype14 = internal constant [31 x i8] c"parmtype=ioaddr:array of ulong\00", section ".modinfo", align 1
@__UNIQUE_ID_ioaddr15 = internal constant [54 x i8] c"parm=ioaddr:ISA io addresses to look for a moxa board\00", section ".modinfo", align 1
@__param_str_ttymajor = internal constant [9 x i8] c"ttymajor\00", align 1
@param_ops_int = external constant %struct.kernel_param_ops, align 8
@ttymajor = internal global i32 174, align 4
@__param_ttymajor = internal constant %struct.kernel_param { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_ttymajor, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 0, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @ttymajor to i8*) } }, section "__param", align 8
@__UNIQUE_ID_ttymajortype16 = internal constant [22 x i8] c"parmtype=ttymajor:int\00", section ".modinfo", align 1
@__UNIQUE_ID_license17 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__param_str_allow_overlapping_vector = internal constant [25 x i8] c"allow_overlapping_vector\00", align 16
@param_ops_bool = external constant %struct.kernel_param_ops, align 8
@allow_overlapping_vector = internal global i8 0, align 1
@__param_allow_overlapping_vector = internal constant %struct.kernel_param { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__param_str_allow_overlapping_vector, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_bool, i16 292, i8 -1, i8 0, %union.anon.51 { i8* @allow_overlapping_vector } }, section "__param", align 8
@__UNIQUE_ID_allow_overlapping_vectortype22 = internal constant [39 x i8] c"parmtype=allow_overlapping_vector:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_allow_overlapping_vector23 = internal constant [122 x i8] c"parm=allow_overlapping_vector:whether we allow ISA cards to be configured such that vector overlabs IO ports (default=no)\00", section ".modinfo", align 1
@param_ops_ulong = external constant %struct.kernel_param_ops, align 8
@ioaddr = internal global [4 x i64] zeroinitializer, align 16
@mxvar_sdriver = internal global %struct.tty_driver* null, align 8
@.str = private unnamed_addr constant [50 x i8] c"\016MOXA Smartio/Industio family driver version %s\0A\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"2.0.5\00", align 1
@.str.2 = private unnamed_addr constant [6 x i8] c"ttyMI\00", align 1
@tty_std_termios = external global %struct.ktermios, align 4
@mxser_ops = internal constant %struct.tty_operations { %struct.tty_struct* (%struct.tty_driver*, %struct.file*, i32)* null, i32 (%struct.tty_driver*, %struct.tty_struct*)* null, void (%struct.tty_driver*, %struct.tty_struct*)* null, i32 (%struct.tty_struct*, %struct.file*)* @mxser_open, void (%struct.tty_struct*, %struct.file*)* @mxser_close, void (%struct.tty_struct*)* null, void (%struct.tty_struct*)* null, i32 (%struct.tty_struct*, i8*, i32)* @mxser_write, i32 (%struct.tty_struct*, i8)* @mxser_put_char, void (%struct.tty_struct*)* @mxser_flush_chars, i32 (%struct.tty_struct*)* @mxser_write_room, i32 (%struct.tty_struct*)* @mxser_chars_in_buffer, i32 (%struct.tty_struct*, i32, i64)* @mxser_ioctl, i64 (%struct.tty_struct*, i32, i64)* null, void (%struct.tty_struct*, %struct.ktermios*)* @mxser_set_termios, void (%struct.tty_struct*)* @mxser_throttle, void (%struct.tty_struct*)* @mxser_unthrottle, void (%struct.tty_struct*)* @mxser_stop, void (%struct.tty_struct*)* @mxser_start, void (%struct.tty_struct*)* @mxser_hangup, i32 (%struct.tty_struct*, i32)* @mxser_rs_break, void (%struct.tty_struct*)* @mxser_flush_buffer, void (%struct.tty_struct*)* null, void (%struct.tty_struct*, i32)* @mxser_wait_until_sent, void (%struct.tty_struct*, i8)* null, i32 (%struct.tty_struct*)* @mxser_tiocmget, i32 (%struct.tty_struct*, i32, i32)* @mxser_tiocmset, i32 (%struct.tty_struct*, %struct.winsize*)* null, i32 (%struct.tty_struct*, %struct.termiox*)* null, i32 (%struct.tty_struct*, %struct.serial_icounter_struct*)* @mxser_get_icount, i32 (%struct.tty_driver*, i32, i8*)* null, i32 (%struct.tty_driver*, i32)* null, void (%struct.tty_driver*, i32, i8)* null, %struct.file_operations* null }, align 8
@.str.3 = private unnamed_addr constant [62 x i8] c"\013Couldn't install MOXA Smartio/Industio family tty driver !\0A\00", align 1
@mxser_boards = internal global [4 x %struct.mxser_board] zeroinitializer, align 16
@.str.4 = private unnamed_addr constant [42 x i8] c"\016mxser: found MOXA %s board (CAP=0x%lx)\0A\00", align 1
@mxser_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([27 x %struct.pci_device_id], [27 x %struct.pci_device_id]* @mxser_pcibrds, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @mxser_probe, void (%struct.pci_dev*)* @mxser_remove, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, %struct.pci_error_handlers* null, %struct.device_driver zeroinitializer, %struct.pci_dynids zeroinitializer }, align 8
@.str.5 = private unnamed_addr constant [6 x i8] c"mxser\00", align 1
@.str.6 = private unnamed_addr constant [36 x i8] c"\013mxser: can't register pci driver\0A\00", align 1
@jiffies = external global i64, align 8
@mxser_ioctl.ModeMask = internal global [4 x i8] c"\FC\F3\CF?", align 1
@.str.7 = private unnamed_addr constant [20 x i8] c"drivers/tty/mxser.c\00", align 1
@mxser_set_baud_method = internal global [33 x i32] zeroinitializer, align 16
@mxser_ioctl_special._rs = internal global %struct.ratelimit_state { %struct.raw_spinlock { %struct.qspinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 0, i64 0 } }, i32 1250, i32 10, i32 0, i32 0, i64 0, i64 0 }, align 8
@.str.8 = private unnamed_addr constant [9 x i8] c"_rs.lock\00", align 1
@__func__.mxser_ioctl_special = private unnamed_addr constant [20 x i8] c"mxser_ioctl_special\00", align 1
@.str.9 = private unnamed_addr constant [72 x i8] c"\014mxser: '%s' uses deprecated ioctl %x (GET_MAJOR), fix your userspace\0A\00", align 1
@mxvar_log = internal global %struct.mxser_log zeroinitializer, align 8
@current_task = external global %struct.task_struct*, align 8
@.str.10 = private unnamed_addr constant [33 x i8] c"./arch/x86/include/asm/uaccess.h\00", align 1
@.str.11 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@Gpci_uart_info = internal constant [3 x %struct.anon.60] [%struct.anon.60 { i32 0, i32 16, i32 16, i32 16, i32 14, i32 14, i32 1, i64 921600 }, %struct.anon.60 { i32 1, i32 64, i32 64, i32 64, i32 48, i32 48, i32 16, i64 230400 }, %struct.anon.60 { i32 2, i32 128, i32 128, i32 128, i32 96, i32 96, i32 32, i64 921600 }], align 16
@mxser_get_msr.mxser_msr = internal global [33 x i8] zeroinitializer, align 16
@mxser_cards = internal constant [32 x %struct.mxser_cardinfo] [%struct.mxser_cardinfo { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.18, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.19, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.20, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.21, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.22, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0), i32 4, i32 2 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24, i32 0, i32 0), i32 4, i32 2 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.25, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.26, i32 0, i32 0), i32 2, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.27, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.28, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.29, i32 0, i32 0), i32 2, i32 1 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.31, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.32, i32 0, i32 0), i32 2, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.33, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.34, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.35, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.36, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.37, i32 0, i32 0), i32 2, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.38, i32 0, i32 0), i32 2, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.39, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.40, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.41, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.43, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.44, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.45, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.46, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.47, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.48, i32 0, i32 0), i32 2, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.49, i32 0, i32 0), i32 2, i32 0 }], align 16
@.str.12 = private unnamed_addr constant [33 x i8] c"\013mxser: interrupt number unset\0A\00", align 1
@.str.13 = private unnamed_addr constant [35 x i8] c"\013mxser: invalid interrupt vector\0A\00", align 1
@ioport_resource = external global %struct.resource, align 8
@.str.14 = private unnamed_addr constant [10 x i8] c"mxser(IO)\00", align 1
@.str.15 = private unnamed_addr constant [58 x i8] c"\013mxser: can't request ports I/O region: 0x%.8lx-0x%.8lx\0A\00", align 1
@.str.16 = private unnamed_addr constant [65 x i8] c"\013mxser: can't request interrupt vector region: 0x%.8lx-0x%.8lx\0A\00", align 1
@.str.17 = private unnamed_addr constant [35 x i8] c"\013mxser: invalid interrupt number\0A\00", align 1
@.str.18 = private unnamed_addr constant [12 x i8] c"C168 series\00", align 1
@.str.19 = private unnamed_addr constant [12 x i8] c"C104 series\00", align 1
@.str.20 = private unnamed_addr constant [15 x i8] c"CI-104J series\00", align 1
@.str.21 = private unnamed_addr constant [17 x i8] c"C168H/PCI series\00", align 1
@.str.22 = private unnamed_addr constant [17 x i8] c"C104H/PCI series\00", align 1
@.str.23 = private unnamed_addr constant [12 x i8] c"C102 series\00", align 1
@.str.24 = private unnamed_addr constant [14 x i8] c"CI-132 series\00", align 1
@.str.25 = private unnamed_addr constant [14 x i8] c"CI-134 series\00", align 1
@.str.26 = private unnamed_addr constant [14 x i8] c"CP-132 series\00", align 1
@.str.27 = private unnamed_addr constant [14 x i8] c"CP-114 series\00", align 1
@.str.28 = private unnamed_addr constant [14 x i8] c"CT-114 series\00", align 1
@.str.29 = private unnamed_addr constant [14 x i8] c"CP-102 series\00", align 1
@.str.30 = private unnamed_addr constant [15 x i8] c"CP-104U series\00", align 1
@.str.31 = private unnamed_addr constant [15 x i8] c"CP-168U series\00", align 1
@.str.32 = private unnamed_addr constant [15 x i8] c"CP-132U series\00", align 1
@.str.33 = private unnamed_addr constant [15 x i8] c"CP-134U series\00", align 1
@.str.34 = private unnamed_addr constant [16 x i8] c"CP-104JU series\00", align 1
@.str.35 = private unnamed_addr constant [19 x i8] c"Moxa UC7000 Serial\00", align 1
@.str.36 = private unnamed_addr constant [15 x i8] c"CP-118U series\00", align 1
@.str.37 = private unnamed_addr constant [16 x i8] c"CP-102UL series\00", align 1
@.str.38 = private unnamed_addr constant [15 x i8] c"CP-102U series\00", align 1
@.str.39 = private unnamed_addr constant [16 x i8] c"CP-118EL series\00", align 1
@.str.40 = private unnamed_addr constant [16 x i8] c"CP-168EL series\00", align 1
@.str.41 = private unnamed_addr constant [16 x i8] c"CP-104EL series\00", align 1
@.str.42 = private unnamed_addr constant [14 x i8] c"CB-108 series\00", align 1
@.str.43 = private unnamed_addr constant [14 x i8] c"CB-114 series\00", align 1
@.str.44 = private unnamed_addr constant [15 x i8] c"CB-134I series\00", align 1
@.str.45 = private unnamed_addr constant [15 x i8] c"CP-138U series\00", align 1
@.str.46 = private unnamed_addr constant [17 x i8] c"POS-104UL series\00", align 1
@.str.47 = private unnamed_addr constant [16 x i8] c"CP-114UL series\00", align 1
@.str.48 = private unnamed_addr constant [16 x i8] c"CP-102UF series\00", align 1
@.str.49 = private unnamed_addr constant [16 x i8] c"CP-112UL series\00", align 1
@.str.50 = private unnamed_addr constant [14 x i8] c"mxser(vector)\00", align 1
@.str.51 = private unnamed_addr constant [34 x i8] c"\016mxser: max. baud rate = %d bps\0A\00", align 1
@mxser_port_ops = internal constant %struct.tty_port_operations { i32 (%struct.tty_port*)* @mxser_carrier_raised, void (%struct.tty_port*, i32)* @mxser_dtr_rts, void (%struct.tty_port*)* @mxser_shutdown_port, i32 (%struct.tty_port*, %struct.tty_struct*)* @mxser_activate, void (%struct.tty_port*)* null }, align 8
@mxser_initbrd.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.52 = private unnamed_addr constant [23 x i8] c"&(&info->slock)->rlock\00", align 1
@.str.53 = private unnamed_addr constant [76 x i8] c"\013Board %s: Request irq failed, IRQ (%d) may conflict with another device.\0A\00", align 1
@.str.54 = private unnamed_addr constant [58 x i8] c"too many boards found (maximum %d), board not configured\0A\00", align 1
@.str.55 = private unnamed_addr constant [42 x i8] c"found MOXA %s board (BusNo=%d, DevNo=%d)\0A\00", align 1
@.str.56 = private unnamed_addr constant [19 x i8] c"PCI enable failed\0A\00", align 1
@llvm.used = appending global [11 x i8*] [i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_author12, i32 0, i32 0), i8* getelementptr inbounds ([71 x i8], [71 x i8]* @__UNIQUE_ID_description13, i32 0, i32 0), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_ioaddr to i8*), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_ioaddrtype14, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @__UNIQUE_ID_ioaddr15, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_ttymajor to i8*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__UNIQUE_ID_ttymajortype16, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license17, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_allow_overlapping_vector to i8*), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @__UNIQUE_ID_allow_overlapping_vectortype22, i32 0, i32 0), i8* getelementptr inbounds ([122 x i8], [122 x i8]* @__UNIQUE_ID_allow_overlapping_vector23, i32 0, i32 0)], section "llvm.metadata"

@__mod_pci__mxser_pcibrds_device_table = alias [27 x %struct.pci_device_id], [27 x %struct.pci_device_id]* @mxser_pcibrds
@cleanup_module = alias void (), void ()* @mxser_module_exit

; Function Attrs: nounwind uwtable
declare i32 @mxser_module_init() #0 section ".init.text"

; Function Attrs: nounwind uwtable
define internal void @mxser_module_exit() #0 section ".exit.text" {
entry:
  call void @pci_unregister_driver(%struct.pci_driver* @mxser_driver)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx, i32 0, i32 2
  %0 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !2
  %cmp1 = icmp ne %struct.mxser_cardinfo* %0, null
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %idxprom2 = zext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom2
  call void @mxser_board_remove(%struct.mxser_board* %arrayidx3)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %1 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !9
  %call = call i32 @tty_unregister_driver(%struct.tty_driver* %1)
  %2 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !9
  call void @put_tty_driver(%struct.tty_driver* %2)
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc15, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc16, %for.inc15 ]
  %cmp5 = icmp ult i32 %i.1, 4
  br i1 %cmp5, label %for.body6, label %for.end17

for.body6:                                        ; preds = %for.cond4
  %idxprom7 = zext i32 %i.1 to i64
  %arrayidx8 = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom7
  %info9 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx8, i32 0, i32 2
  %3 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info9, align 8, !tbaa !2
  %cmp10 = icmp ne %struct.mxser_cardinfo* %3, null
  br i1 %cmp10, label %if.then11, label %for.inc15

if.then11:                                        ; preds = %for.body6
  %idxprom12 = zext i32 %i.1 to i64
  %arrayidx13 = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom12
  call void @mxser_release_ISA_res(%struct.mxser_board* %arrayidx13)
  br label %for.inc15

for.inc15:                                        ; preds = %if.then11, %for.body6
  %inc16 = add i32 %i.1, 1
  br label %for.cond4

for.end17:                                        ; preds = %for.cond4
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @alloc_tty_driver(i32 %lines) #2 {
entry:
  %call = call %struct.tty_driver* @__tty_alloc_driver(i32 %lines, %struct.module* @__this_module, i64 0)
  %0 = bitcast %struct.tty_driver* %call to i8*
  %call1 = call zeroext i1 @IS_ERR(i8* %0)
  ret void
}

declare i32 @printk(i8*, ...) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #1

declare void @tty_set_operations(%struct.tty_driver*, %struct.tty_operations*) #3

declare i32 @tty_register_driver(%struct.tty_driver*) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_get_ISA_conf(i32 %cap, %struct.mxser_board* %brd) #0 section ".init.text" {
entry:
  %regs = alloca [16 x i16], align 16
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 5
  store i32 0, i32* %chip_flag, align 8, !tbaa !10
  %arraydecay = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i32 0, i32 0
  %call = call i32 @mxser_read_register(i32 %cap, i16* %arraydecay)
  %Pivot12 = icmp slt i32 %call, 4
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %call, 5
  br i1 %Pivot10, label %sw.bb7, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %call, 11
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %call, 11
  br i1 %SwitchLeaf6, label %sw.bb5, label %cleanup

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %call, 5
  br i1 %SwitchLeaf4, label %sw.bb3, label %cleanup

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %call, 2
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %call, 3
  %info2 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  br i1 %Pivot, label %sw.bb1, label %sw.bb9

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %call, 1
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 0), %struct.mxser_cardinfo** %info, align 8, !tbaa !2
  br label %sw.epilog

sw.bb1:                                           ; preds = %NodeBlock
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 1), %struct.mxser_cardinfo** %info2, align 8, !tbaa !2
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock3
  %info4 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 2), %struct.mxser_cardinfo** %info4, align 8, !tbaa !2
  br label %sw.epilog

sw.bb5:                                           ; preds = %LeafBlock5
  %info6 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 5), %struct.mxser_cardinfo** %info6, align 8, !tbaa !2
  br label %sw.epilog

sw.bb7:                                           ; preds = %NodeBlock9
  %info8 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 6), %struct.mxser_cardinfo** %info8, align 8, !tbaa !2
  br label %sw.epilog

sw.bb9:                                           ; preds = %NodeBlock
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 7), %struct.mxser_cardinfo** %info2, align 8, !tbaa !2
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb9, %sw.bb7, %sw.bb5, %sw.bb3, %sw.bb1, %sw.bb
  %info11 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %0 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info11, align 8, !tbaa !2
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %0, i32 0, i32 1
  %1 = load i32, i32* %nports, align 8, !tbaa !11
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %info12 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %2 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info12, align 8, !tbaa !2
  %flags = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %2, i32 0, i32 2
  %3 = load i32, i32* %flags, align 4, !tbaa !13
  %and = and i32 %3, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %sw.epilog
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %4 = load i16, i16* %arrayidx, align 2, !tbaa !14
  %conv = zext i16 %4 to i32
  %and13 = and i32 %conv, 61440
  %conv14 = trunc i32 %and13 to i16
  %conv15 = zext i16 %conv14 to i32
  %conv16 = zext i16 %conv14 to i32
  %shr = ashr i32 %conv16, 4
  %or = or i32 %conv15, %shr
  %conv17 = trunc i32 %or to i16
  %conv18 = zext i16 %conv17 to i32
  %arrayidx19 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %5 = load i16, i16* %arrayidx19, align 2, !tbaa !14
  %conv20 = zext i16 %5 to i32
  %and21 = and i32 %conv20, 65280
  %cmp22 = icmp ne i32 %conv18, %and21
  br i1 %cmp22, label %err_irqconflict, label %if.end86

if.else:                                          ; preds = %lor.lhs.false
  %info25 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %6 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info25, align 8, !tbaa !2
  %nports26 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %6, i32 0, i32 1
  %7 = load i32, i32* %nports26, align 8, !tbaa !11
  %cmp27 = icmp eq i32 %7, 4
  br i1 %cmp27, label %if.then29, label %if.else51

if.then29:                                        ; preds = %if.else
  %arrayidx30 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %8 = load i16, i16* %arrayidx30, align 2, !tbaa !14
  %conv31 = zext i16 %8 to i32
  %and32 = and i32 %conv31, 61440
  %conv33 = trunc i32 %and32 to i16
  %conv34 = zext i16 %conv33 to i32
  %conv35 = zext i16 %conv33 to i32
  %shr36 = ashr i32 %conv35, 4
  %or37 = or i32 %conv34, %shr36
  %conv38 = trunc i32 %or37 to i16
  %conv39 = zext i16 %conv38 to i32
  %conv40 = zext i16 %conv38 to i32
  %shr41 = ashr i32 %conv40, 8
  %or42 = or i32 %conv39, %shr41
  %conv43 = trunc i32 %or42 to i16
  %conv44 = zext i16 %conv43 to i32
  %arrayidx45 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %9 = load i16, i16* %arrayidx45, align 2, !tbaa !14
  %conv46 = zext i16 %9 to i32
  %cmp47 = icmp ne i32 %conv44, %conv46
  br i1 %cmp47, label %err_irqconflict, label %if.end86

if.else51:                                        ; preds = %if.else
  %info52 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %10 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info52, align 8, !tbaa !2
  %nports53 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %10, i32 0, i32 1
  %11 = load i32, i32* %nports53, align 8, !tbaa !11
  %cmp54 = icmp eq i32 %11, 8
  br i1 %cmp54, label %if.then56, label %if.end86

if.then56:                                        ; preds = %if.else51
  %arrayidx57 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %12 = load i16, i16* %arrayidx57, align 2, !tbaa !14
  %conv58 = zext i16 %12 to i32
  %and59 = and i32 %conv58, 61440
  %conv60 = trunc i32 %and59 to i16
  %conv61 = zext i16 %conv60 to i32
  %conv62 = zext i16 %conv60 to i32
  %shr63 = ashr i32 %conv62, 4
  %or64 = or i32 %conv61, %shr63
  %conv65 = trunc i32 %or64 to i16
  %conv66 = zext i16 %conv65 to i32
  %conv67 = zext i16 %conv65 to i32
  %shr68 = ashr i32 %conv67, 8
  %or69 = or i32 %conv66, %shr68
  %conv70 = trunc i32 %or69 to i16
  %conv71 = zext i16 %conv70 to i32
  %arrayidx72 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %13 = load i16, i16* %arrayidx72, align 2, !tbaa !14
  %conv73 = zext i16 %13 to i32
  %cmp74 = icmp ne i32 %conv71, %conv73
  br i1 %cmp74, label %err_irqconflict, label %lor.lhs.false76

lor.lhs.false76:                                  ; preds = %if.then56
  %conv77 = zext i16 %conv70 to i32
  %arrayidx78 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 10
  %14 = load i16, i16* %arrayidx78, align 4, !tbaa !14
  %conv79 = zext i16 %14 to i32
  %cmp80 = icmp ne i32 %conv77, %conv79
  br i1 %cmp80, label %err_irqconflict, label %if.end86

if.end86:                                         ; preds = %lor.lhs.false76, %if.else51, %if.then29, %if.then
  %irq.2 = phi i16 [ %conv17, %if.then ], [ %conv43, %if.then29 ], [ 0, %if.else51 ], [ %conv70, %lor.lhs.false76 ]
  %tobool87 = icmp ne i16 %irq.2, 0
  br i1 %tobool87, label %if.end90, label %if.then88

if.then88:                                        ; preds = %if.end86
  %15 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end90:                                         ; preds = %if.end86
  %conv91 = zext i16 %irq.2 to i32
  %and92 = and i32 %conv91, 61440
  %shr93 = ashr i32 %and92, 12
  %irq94 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 1
  store i32 %shr93, i32* %irq94, align 4, !tbaa !16
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end90
  %i.0 = phi i32 [ 0, %if.end90 ], [ %inc, %for.body ]
  %cmp95 = icmp slt i32 %i.0, 8
  br i1 %cmp95, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 %i.0, 1
  %idxprom = sext i32 %add to i64
  %arrayidx97 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 %idxprom
  %16 = load i16, i16* %arrayidx97, align 2, !tbaa !14
  %conv98 = zext i16 %16 to i32
  %and99 = and i32 %conv98, 65528
  %conv100 = sext i32 %and99 to i64
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom101 = sext i32 %i.0 to i64
  %arrayidx102 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom101
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx102, i32 0, i32 2
  store i64 %conv100, i64* %ioaddr, align 8, !tbaa !17
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arrayidx103 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 12
  %17 = load i16, i16* %arrayidx103, align 8, !tbaa !14
  %conv104 = zext i16 %17 to i32
  %and105 = and i32 %conv104, 128
  %cmp106 = icmp eq i32 %and105, 0
  br i1 %cmp106, label %if.then108, label %if.end110

if.then108:                                       ; preds = %for.end
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end110:                                        ; preds = %for.end
  %arrayidx111 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 11
  %19 = load i16, i16* %arrayidx111, align 2, !tbaa !14
  %conv112 = zext i16 %19 to i32
  %conv113 = sext i32 %conv112 to i64
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 3
  store i64 %conv113, i64* %vector, align 8, !tbaa !37
  %cmp114 = icmp eq i32 %call, 1
  %vector_mask = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 4
  %.sink = select i1 %cmp114, i64 255, i64 15
  store i64 %.sink, i64* %vector_mask, align 8, !tbaa !38
  br label %for.cond120

for.cond120:                                      ; preds = %for.body123, %if.end110
  %i.1 = phi i32 [ 7, %if.end110 ], [ %dec, %for.body123 ]
  %bits.0 = phi i32 [ 256, %if.end110 ], [ %shl, %for.body123 ]
  %cmp121 = icmp sge i32 %i.1, 0
  br i1 %cmp121, label %for.body123, label %for.end146

for.body123:                                      ; preds = %for.cond120
  %arrayidx124 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 12
  %20 = load i16, i16* %arrayidx124, align 8, !tbaa !14
  %conv125 = zext i16 %20 to i32
  %and126 = and i32 %conv125, %bits.0
  %tobool127 = icmp ne i32 %and126, 0
  %ports129 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom130 = sext i32 %i.1 to i64
  %arrayidx131 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports129, i64 0, i64 %idxprom130
  %baud_base = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx131, i32 0, i32 8
  %.sink14 = select i1 %tobool127, i32 921600, i32 115200
  store i32 %.sink14, i32* %baud_base, align 8, !tbaa !39
  %ports140 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom141 = sext i32 %i.1 to i64
  %arrayidx142 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports140, i64 0, i64 %idxprom141
  %max_baud143 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx142, i32 0, i32 4
  store i32 %.sink14, i32* %max_baud143, align 8, !tbaa !40
  %dec = add nsw i32 %i.1, -1
  %shl = shl i32 %bits.0, 1
  br label %for.cond120

for.end146:                                       ; preds = %for.cond120
  %add147 = add nsw i32 %cap, 3
  %call148 = call zeroext i8 @inb(i32 %add147)
  %conv149 = zext i8 %call148 to i32
  %and150 = and i32 %conv149, -129
  %conv151 = trunc i32 %and150 to i8
  %conv152 = zext i8 %conv151 to i32
  %or153 = or i32 %conv152, 128
  %conv154 = trunc i32 %or153 to i8
  %add155 = add nsw i32 %cap, 3
  call void @outb(i8 zeroext %conv154, i32 %add155)
  %add156 = add nsw i32 %cap, 2
  call void @outb(i8 zeroext 0, i32 %add156)
  %add157 = add nsw i32 %cap, 3
  call void @outb(i8 zeroext %conv151, i32 %add157)
  %add158 = add nsw i32 %cap, 2
  call void @outb(i8 zeroext 1, i32 %add158)
  %add159 = add nsw i32 %cap, 2
  %call160 = call zeroext i8 @inb(i32 %add159)
  %conv161 = zext i8 %call160 to i32
  %and162 = and i32 %conv161, 192
  %tobool163 = icmp ne i32 %and162, 0
  %uart_type = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 6
  %.sink15 = select i1 %tobool163, i32 4, i32 2
  store i32 %.sink15, i32* %uart_type, align 4, !tbaa !41
  %ports168 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %arrayidx169 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports168, i64 0, i64 0
  %ioaddr170 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx169, i32 0, i32 2
  %21 = load i64, i64* %ioaddr170, align 8, !tbaa !17
  %info171 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %22 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info171, align 8, !tbaa !2
  %nports172 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %22, i32 0, i32 1
  %23 = load i32, i32* %nports172, align 8, !tbaa !11
  %mul = mul i32 8, %23
  %conv173 = zext i32 %mul to i64
  %call174 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %21, i64 %conv173, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.14, i32 0, i32 0), i32 0)
  %tobool175 = icmp ne %struct.resource* %call174, null
  br i1 %tobool175, label %if.end189, label %if.then176

if.then176:                                       ; preds = %for.end146
  %24 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end189:                                        ; preds = %for.end146
  %call190 = call i32 @mxser_request_vector(%struct.mxser_board* %brd)
  %tobool191 = icmp ne i32 %call190, 0
  br i1 %tobool191, label %if.then192, label %if.end213

if.then192:                                       ; preds = %if.end189
  %ports193 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %arrayidx194 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports193, i64 0, i64 0
  %ioaddr195 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx194, i32 0, i32 2
  %25 = load i64, i64* %ioaddr195, align 8, !tbaa !17
  %info196 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %26 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info196, align 8, !tbaa !2
  %nports197 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %26, i32 0, i32 1
  %27 = load i32, i32* %nports197, align 8, !tbaa !11
  %mul198 = mul i32 8, %27
  %conv199 = zext i32 %mul198 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %25, i64 %conv199)
  %28 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end213:                                        ; preds = %if.end189
  br label %cleanup

err_irqconflict:                                  ; preds = %lor.lhs.false76, %if.then56, %if.then29, %if.then
  %29 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %err_irqconflict, %if.end213, %if.then192, %if.then176, %if.then108, %if.then88, %LeafBlock, %LeafBlock3, %LeafBlock5
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_initbrd(%struct.mxser_board* %brd) #4 {
entry:
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %info2 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %1 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info2, align 8, !tbaa !2
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %1, i32 0, i32 1
  %2 = load i32, i32* %nports, align 8, !tbaa !11
  %cmp = icmp ult i32 %i.0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports3 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom = zext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports3, i64 0, i64 %idxprom
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 0
  call void @tty_port_init(%struct.tty_port* %port)
  %port5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 0
  %ops = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port5, i32 0, i32 3
  store %struct.tty_port_operations* @mxser_port_ops, %struct.tty_port_operations** %ops, align 8, !tbaa !42
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 1
  store %struct.mxser_board* %brd, %struct.mxser_board** %board, align 8, !tbaa !43
  %stop_rx = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 13
  store i8 0, i8* %stop_rx, align 4, !tbaa !44
  %ldisc_stop_rx = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 14
  store i8 0, i8* %ldisc_stop_rx, align 1, !tbaa !45
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 5
  %3 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %cmp6 = icmp ne i32 %3, 0
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 2
  %4 = load i64, i64* %ioaddr, align 8, !tbaa !17
  call void @mxser_enable_must_enchance_mode(i64 %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %uart_type = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 6
  %5 = load i32, i32* %uart_type, align 4, !tbaa !41
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 9
  store i32 %5, i32* %type, align 4, !tbaa !46
  call void @process_txrx_fifo(%struct.mxser_port* %arrayidx4)
  %baud_base = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 8
  %6 = load i32, i32* %baud_base, align 8, !tbaa !39
  %mul = mul nsw i32 %6, 16
  %custom_divisor = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 15
  store i32 %mul, i32* %custom_divisor, align 8, !tbaa !47
  %port7 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 0
  %close_delay = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port7, i32 0, i32 16
  store i32 125, i32* %close_delay, align 8, !tbaa !48
  %port8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 0
  %closing_wait = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port8, i32 0, i32 17
  store i32 7500, i32* %closing_wait, align 4, !tbaa !49
  %normal_termios = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 26
  %7 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !9
  %init_termios = getelementptr inbounds %struct.tty_driver, %struct.tty_driver* %7, i32 0, i32 12
  %8 = bitcast %struct.ktermios* %normal_termios to i8*
  %9 = bitcast %struct.ktermios* %init_termios to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 44, i32 4, i1 false), !tbaa.struct !50
  %mon_data = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 27
  %10 = bitcast %struct.mxser_mon* %mon_data to i8*
  %call9 = call i8* @__memset(i8* %10, i32 0, i64 40)
  %err_shadow = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 16
  store i8 0, i8* %err_shadow, align 4, !tbaa !53
  %slock12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 28
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock12, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %11 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.52, i32 0, i32 0), %struct.lock_class_key* @mxser_initbrd.__key)
  %ioaddr15 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 2
  %12 = load i64, i64* %ioaddr15, align 8, !tbaa !17
  %add = add i64 %12, 1
  %conv = trunc i64 %add to i32
  %call16 = call zeroext i8 @inb(i32 %conv)
  %conv17 = zext i8 %call16 to i32
  %and = and i32 %conv17, 240
  %conv18 = trunc i32 %and to i8
  %ioaddr19 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 2
  %13 = load i64, i64* %ioaddr19, align 8, !tbaa !17
  %add20 = add i64 %13, 1
  %conv21 = trunc i64 %add20 to i32
  call void @outb(i8 zeroext %conv18, i32 %conv21)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %irq = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 1
  %14 = load i32, i32* %irq, align 4, !tbaa !16
  %15 = bitcast %struct.mxser_board* %brd to i8*
  %call22 = call i32 @request_irq(i32 %14, i32 (i32, i8*)* @mxser_interrupt, i64 128, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0), i8* %15)
  %tobool = icmp ne i32 %call22, 0
  br i1 %tobool, label %if.then23, label %if.end40

if.then23:                                        ; preds = %for.end
  br label %for.cond24

for.cond24:                                       ; preds = %for.body29, %if.then23
  %i.1 = phi i32 [ 0, %if.then23 ], [ %inc35, %for.body29 ]
  %info25 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %16 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info25, align 8, !tbaa !2
  %nports26 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %16, i32 0, i32 1
  %17 = load i32, i32* %nports26, align 8, !tbaa !11
  %cmp27 = icmp ult i32 %i.1, %17
  br i1 %cmp27, label %for.body29, label %for.end36

for.body29:                                       ; preds = %for.cond24
  %ports30 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom31 = zext i32 %i.1 to i64
  %arrayidx32 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports30, i64 0, i64 %idxprom31
  %port33 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 0
  call void @tty_port_destroy(%struct.tty_port* %port33)
  %inc35 = add i32 %i.1, 1
  br label %for.cond24

for.end36:                                        ; preds = %for.cond24
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end40

if.end40:                                         ; preds = %for.end36, %for.end
  ret i32 %call22
}

; Function Attrs: nounwind uwtable
define internal void @mxser_release_ISA_res(%struct.mxser_board* %brd) #4 {
entry:
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %arrayidx = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 0
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx, i32 0, i32 2
  %0 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %1 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !2
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %1, i32 0, i32 1
  %2 = load i32, i32* %nports, align 8, !tbaa !11
  %mul = mul i32 8, %2
  %conv = zext i32 %mul to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %0, i64 %conv)
  call void @mxser_release_vector(%struct.mxser_board* %brd)
  ret void
}

declare %struct.device* @tty_port_register_device(%struct.tty_port*, %struct.tty_driver*, i32, %struct.device*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

declare void @tty_unregister_device(%struct.tty_driver*, i32) #3

declare void @tty_port_destroy(%struct.tty_port*) #3

declare void @free_irq(i32, i8*) #3

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) #3

declare i32 @tty_unregister_driver(%struct.tty_driver*) #3

declare void @put_tty_driver(%struct.tty_driver*) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #1

declare %struct.tty_driver* @__tty_alloc_driver(i32, %struct.module*, i64) #3

; Function Attrs: nounwind uwtable
define internal i32 @mxser_open(%struct.tty_struct* %tty, %struct.file* %filp) #4 {
entry:
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %0 = load i32, i32* %index, align 8, !tbaa !54
  %cmp = icmp eq i32 %0, 32
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %div = sdiv i32 %0, 8
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx, i32 0, i32 7
  %rem = srem i32 %0, 8
  %idxprom1 = sext i32 %rem to i64
  %arrayidx2 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom1
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx2, i32 0, i32 2
  %1 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %2 = bitcast %struct.mxser_port* %arrayidx2 to i8*
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  store i8* %2, i8** %driver_data, align 8, !tbaa !61
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx2, i32 0, i32 0
  %call = call i32 @tty_port_open(%struct.tty_port* %port, %struct.tty_struct* %tty, %struct.file* %filp)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end4 ], [ 0, %entry ], [ -19, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @mxser_close(%struct.tty_struct* %tty, %struct.file* %filp) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %port1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %2 = load i32, i32* %index, align 8, !tbaa !54
  %cmp = icmp eq i32 %2, 32
  %cmp2 = icmp eq %struct.mxser_port* %1, null
  %or.cond = or i1 %cmp, %cmp2
  br i1 %or.cond, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @tty_port_close_start(%struct.tty_port* %port1, %struct.tty_struct* %tty, %struct.file* %filp)
  %cmp3 = icmp eq i32 %call, 0
  br i1 %cmp3, label %cleanup.cont, label %if.end5

if.end5:                                          ; preds = %if.end
  %closing = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 25
  store i32 1, i32* %closing, align 8, !tbaa !62
  %mutex = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  call void @mxser_close_port(%struct.tty_port* %port1)
  call void @mxser_flush_buffer(%struct.tty_struct* %tty)
  %call6 = call zeroext i1 @tty_port_initialized(%struct.tty_port* %port1)
  br i1 %call6, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.end5
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 2
  %3 = load i32, i32* %c_cflag, align 8, !tbaa !63
  %and = and i32 %3, 1024
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true
  call void @tty_port_lower_dtr_rts(%struct.tty_port* %port1)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %land.lhs.true, %if.end5
  call void @mxser_shutdown_port(%struct.tty_port* %port1)
  call void @tty_port_set_initialized(%struct.tty_port* %port1, i1 zeroext false)
  %mutex9 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_unlock(%struct.mutex* %mutex9)
  %closing10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 25
  store i32 0, i32* %closing10, align 8, !tbaa !62
  call void @tty_port_close_end(%struct.tty_port* %port1, %struct.tty_struct* %tty)
  call void @tty_port_tty_set(%struct.tty_port* %port1, %struct.tty_struct* null)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end8, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_write(%struct.tty_struct* %tty, i8* %buf, i32 %count) #4 {
entry:
  %__UNIQUE_ID_min1_20 = alloca i32, align 4
  %__UNIQUE_ID_min2_21 = alloca i32, align 4
  %__UNIQUE_ID_min1_18 = alloca i64, align 8
  %__UNIQUE_ID_min2_19 = alloca i64, align 8
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 15
  %2 = load i8*, i8** %xmit_buf, align 8, !tbaa !64
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end20, %if.end
  %total.0 = phi i32 [ 0, %if.end ], [ %add43, %if.end20 ]
  %count.addr.0 = phi i32 [ %count, %if.end ], [ %sub42, %if.end20 ]
  %buf.addr.0 = phi i8* [ %buf, %if.end ], [ %add.ptr41, %if.end20 ]
  store i32 %count.addr.0, i32* %__UNIQUE_ID_min1_20, align 4, !tbaa !51
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %3 = load i32, i32* %xmit_cnt, align 4, !tbaa !65
  %conv = sext i32 %3 to i64
  %sub = sub i64 4096, %conv
  %sub1 = sub i64 %sub, 1
  store i64 %sub1, i64* %__UNIQUE_ID_min1_18, align 8, !tbaa !66
  %xmit_head = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  %4 = load i32, i32* %xmit_head, align 4, !tbaa !67
  %conv2 = sext i32 %4 to i64
  %sub3 = sub i64 4096, %conv2
  store i64 %sub3, i64* %__UNIQUE_ID_min2_19, align 8, !tbaa !66
  %5 = load i64, i64* %__UNIQUE_ID_min1_18, align 8, !tbaa !66
  %6 = load i64, i64* %__UNIQUE_ID_min2_19, align 8, !tbaa !66
  %cmp5 = icmp ult i64 %5, %6
  %7 = load i64, i64* %__UNIQUE_ID_min1_18, align 8
  %8 = load i64, i64* %__UNIQUE_ID_min2_19, align 8
  %cond = select i1 %cmp5, i64 %7, i64 %8
  %conv7 = trunc i64 %cond to i32
  store i32 %conv7, i32* %__UNIQUE_ID_min2_21, align 4, !tbaa !51
  %9 = load i32, i32* %__UNIQUE_ID_min1_20, align 4, !tbaa !51
  %10 = load i32, i32* %__UNIQUE_ID_min2_21, align 4, !tbaa !51
  %cmp11 = icmp slt i32 %9, %10
  %11 = load i32, i32* %__UNIQUE_ID_min1_20, align 4
  %12 = load i32, i32* %__UNIQUE_ID_min2_21, align 4
  %cond16 = select i1 %cmp11, i32 %11, i32 %12
  %cmp17 = icmp sle i32 %cond16, 0
  br i1 %cmp17, label %while.end, label %if.end20

if.end20:                                         ; preds = %while.cond
  %port21 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf22 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port21, i32 0, i32 15
  %13 = load i8*, i8** %xmit_buf22, align 8, !tbaa !64
  %xmit_head23 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  %14 = load i32, i32* %xmit_head23, align 4, !tbaa !67
  %idx.ext = sext i32 %14 to i64
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 %idx.ext
  %conv24 = sext i32 %cond16 to i64
  %call = call i8* @__memcpy(i8* %add.ptr, i8* %buf.addr.0, i64 %conv24)
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %15 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %15 to %struct.raw_spinlock*
  %call30 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i1)
  %xmit_head33 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  %16 = load i32, i32* %xmit_head33, align 4, !tbaa !67
  %add = add nsw i32 %16, %cond16
  %conv34 = sext i32 %add to i64
  %and = and i64 %conv34, 4095
  %conv35 = trunc i64 %and to i32
  %xmit_head36 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  store i32 %conv35, i32* %xmit_head36, align 4, !tbaa !67
  %xmit_cnt37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %17 = load i32, i32* %xmit_cnt37, align 4, !tbaa !65
  %add38 = add nsw i32 %17, %cond16
  store i32 %add38, i32* %xmit_cnt37, align 4, !tbaa !65
  %slock39 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %18 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock39, i32 0, i32 0
  %rlock.i5 = bitcast %union.anon.1* %18 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i5, i64 %call30) #7
  %idx.ext40 = sext i32 %cond16 to i64
  %add.ptr41 = getelementptr inbounds i8, i8* %buf.addr.0, i64 %idx.ext40
  %sub42 = sub nsw i32 %count.addr.0, %cond16
  %add43 = add nsw i32 %total.0, %cond16
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %xmit_cnt44 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %19 = load i32, i32* %xmit_cnt44, align 4, !tbaa !65
  %tobool45 = icmp ne i32 %19, 0
  br i1 %tobool45, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %while.end
  %stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 24
  %bf.load = load i8, i8* %stopped, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i64
  %tobool46 = icmp ne i64 %bf.cast, 0
  br i1 %tobool46, label %cleanup, label %if.then47

if.then47:                                        ; preds = %land.lhs.true
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  %20 = load i32, i32* %hw_stopped, align 8, !tbaa !68
  %tobool48 = icmp ne i32 %20, 0
  br i1 %tobool48, label %lor.lhs.false, label %do.body55

lor.lhs.false:                                    ; preds = %if.then47
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %21 = load i32, i32* %type, align 4, !tbaa !46
  %cmp49 = icmp eq i32 %21, 4
  br i1 %cmp49, label %do.body55, label %lor.lhs.false51

lor.lhs.false51:                                  ; preds = %lor.lhs.false
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %22 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %22, i32 0, i32 5
  %23 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool52 = icmp ne i32 %23, 0
  br i1 %tobool52, label %do.body55, label %cleanup

do.body55:                                        ; preds = %lor.lhs.false51, %lor.lhs.false, %if.then47
  %slock61 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %24 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock61, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %24 to %struct.raw_spinlock*
  %call63 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %25 = load i32, i32* %IER, align 4, !tbaa !69
  %and68 = and i32 %25, -3
  %conv69 = trunc i32 %and68 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %26 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add70 = add i64 %26, 1
  %conv71 = trunc i64 %add70 to i32
  call void @outb(i8 zeroext %conv69, i32 %conv71)
  %IER72 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %27 = load i32, i32* %IER72, align 4, !tbaa !69
  %or = or i32 %27, 2
  store i32 %or, i32* %IER72, align 4, !tbaa !69
  %IER73 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %28 = load i32, i32* %IER73, align 4, !tbaa !69
  %conv74 = trunc i32 %28 to i8
  %ioaddr75 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %29 = load i64, i64* %ioaddr75, align 8, !tbaa !17
  %add76 = add i64 %29, 1
  %conv77 = trunc i64 %add76 to i32
  call void @outb(i8 zeroext %conv74, i32 %conv77)
  %slock78 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %30 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock78, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %30 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i2, i64 %call63) #7
  br label %cleanup

cleanup:                                          ; preds = %do.body55, %lor.lhs.false51, %land.lhs.true, %while.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %total.0, %lor.lhs.false51 ], [ %total.0, %do.body55 ], [ %total.0, %land.lhs.true ], [ %total.0, %while.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_put_char(%struct.tty_struct* %tty, i8 zeroext %ch) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 15
  %2 = load i8*, i8** %xmit_buf, align 8, !tbaa !64
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %3 = load i32, i32* %xmit_cnt, align 4, !tbaa !65
  %conv = sext i32 %3 to i64
  %cmp = icmp uge i64 %conv, 4095
  br i1 %cmp, label %cleanup, label %do.body4

do.body4:                                         ; preds = %if.end
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  %call7 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i1)
  %port10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf11 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port10, i32 0, i32 15
  %5 = load i8*, i8** %xmit_buf11, align 8, !tbaa !64
  %xmit_head = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  %6 = load i32, i32* %xmit_head, align 4, !tbaa !67
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %xmit_head, align 4, !tbaa !67
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds i8, i8* %5, i64 %idxprom
  store i8 %ch, i8* %arrayidx, align 1, !tbaa !52
  %xmit_head12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  %7 = load i32, i32* %xmit_head12, align 4, !tbaa !67
  %conv13 = sext i32 %7 to i64
  %and = and i64 %conv13, 4095
  %conv14 = trunc i64 %and to i32
  store i32 %conv14, i32* %xmit_head12, align 4, !tbaa !67
  %xmit_cnt15 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %8 = load i32, i32* %xmit_cnt15, align 4, !tbaa !65
  %inc16 = add nsw i32 %8, 1
  store i32 %inc16, i32* %xmit_cnt15, align 4, !tbaa !65
  %slock17 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %9 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock17, i32 0, i32 0
  %rlock.i5 = bitcast %union.anon.1* %9 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i5, i64 %call7) #7
  %stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 24
  %bf.load = load i8, i8* %stopped, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i64
  %tobool18 = icmp ne i64 %bf.cast, 0
  br i1 %tobool18, label %cleanup, label %if.then19

if.then19:                                        ; preds = %do.body4
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  %10 = load i32, i32* %hw_stopped, align 8, !tbaa !68
  %tobool20 = icmp ne i32 %10, 0
  br i1 %tobool20, label %lor.lhs.false, label %do.body27

lor.lhs.false:                                    ; preds = %if.then19
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %11 = load i32, i32* %type, align 4, !tbaa !46
  %cmp21 = icmp eq i32 %11, 4
  br i1 %cmp21, label %do.body27, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %lor.lhs.false
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %12 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %12, i32 0, i32 5
  %13 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool24 = icmp ne i32 %13, 0
  br i1 %tobool24, label %do.body27, label %cleanup

do.body27:                                        ; preds = %lor.lhs.false23, %lor.lhs.false, %if.then19
  %slock33 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %14 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock33, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %14 to %struct.raw_spinlock*
  %call35 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %15 = load i32, i32* %IER, align 4, !tbaa !69
  %and40 = and i32 %15, -3
  %conv41 = trunc i32 %and40 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %16 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %16, 1
  %conv42 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv41, i32 %conv42)
  %IER43 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %17 = load i32, i32* %IER43, align 4, !tbaa !69
  %or = or i32 %17, 2
  store i32 %or, i32* %IER43, align 4, !tbaa !69
  %IER44 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %18 = load i32, i32* %IER44, align 4, !tbaa !69
  %conv45 = trunc i32 %18 to i8
  %ioaddr46 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %19 = load i64, i64* %ioaddr46, align 8, !tbaa !17
  %add47 = add i64 %19, 1
  %conv48 = trunc i64 %add47 to i32
  call void @outb(i8 zeroext %conv45, i32 %conv48)
  %slock49 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %20 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock49, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %20 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i2, i64 %call35) #7
  br label %cleanup

cleanup:                                          ; preds = %do.body27, %lor.lhs.false23, %do.body4, %if.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 0, %if.end ], [ 1, %lor.lhs.false23 ], [ 1, %do.body27 ], [ 1, %do.body4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @mxser_flush_chars(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %2 = load i32, i32* %xmit_cnt, align 4, !tbaa !65
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %cleanup.cont, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 24
  %bf.load = load i8, i8* %stopped, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i64
  %conv = trunc i64 %bf.cast to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %cleanup.cont, label %lor.lhs.false1

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 15
  %3 = load i8*, i8** %xmit_buf, align 8, !tbaa !64
  %tobool2 = icmp ne i8* %3, null
  br i1 %tobool2, label %lor.lhs.false3, label %cleanup.cont

lor.lhs.false3:                                   ; preds = %lor.lhs.false1
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  %4 = load i32, i32* %hw_stopped, align 8, !tbaa !68
  %tobool4 = icmp ne i32 %4, 0
  br i1 %tobool4, label %land.lhs.true, label %do.body9

land.lhs.true:                                    ; preds = %lor.lhs.false3
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %5 = load i32, i32* %type, align 4, !tbaa !46
  %cmp5 = icmp ne i32 %5, 4
  br i1 %cmp5, label %land.lhs.true7, label %do.body9

land.lhs.true7:                                   ; preds = %land.lhs.true
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %6 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %6, i32 0, i32 5
  %7 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool8 = icmp ne i32 %7, 0
  br i1 %tobool8, label %do.body9, label %cleanup.cont

do.body9:                                         ; preds = %land.lhs.true7, %land.lhs.true, %lor.lhs.false3
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %8 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %8 to %struct.raw_spinlock*
  %call12 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %9 = load i32, i32* %IER, align 4, !tbaa !69
  %and = and i32 %9, -3
  %conv15 = trunc i32 %and to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %10 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %10, 1
  %conv16 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv15, i32 %conv16)
  %IER17 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %11 = load i32, i32* %IER17, align 4, !tbaa !69
  %or = or i32 %11, 2
  store i32 %or, i32* %IER17, align 4, !tbaa !69
  %IER18 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %12 = load i32, i32* %IER18, align 4, !tbaa !69
  %conv19 = trunc i32 %12 to i8
  %ioaddr20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %13 = load i64, i64* %ioaddr20, align 8, !tbaa !17
  %add21 = add i64 %13, 1
  %conv22 = trunc i64 %add21 to i32
  call void @outb(i8 zeroext %conv19, i32 %conv22)
  %slock23 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %14 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock23, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %14 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call12) #7
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.body9, %land.lhs.true7, %lor.lhs.false1, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_write_room(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %2 = load i32, i32* %xmit_cnt, align 4, !tbaa !65
  %conv = sext i32 %2 to i64
  %sub = sub i64 4096, %conv
  %sub1 = sub i64 %sub, 1
  %conv2 = trunc i64 %sub1 to i32
  %cmp = icmp slt i32 %conv2, 0
  %.conv2 = select i1 %cmp, i32 0, i32 %conv2
  ret i32 %.conv2
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_chars_in_buffer(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %2 = load i32, i32* %xmit_cnt, align 4, !tbaa !65
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_ioctl(%struct.tty_struct* %tty, i32 %cmd, i64 %arg) #4 {
entry:
  %cnow = alloca %struct.async_icount, align 4
  %__wait = alloca %struct.__wait_queue, align 8
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %port1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %2 = inttoptr i64 %arg to i8*
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %3 = load i32, i32* %index, align 8, !tbaa !54
  %cmp = icmp eq i32 %3, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @mxser_ioctl_special(i8* %2)
  br label %cleanup246

if.end:                                           ; preds = %entry
  switch i32 %cmd, label %land.lhs.true67 [
    i32 1090, label %if.then5
    i32 1091, label %if.then5
    i32 21534, label %NodeBlock27
    i32 21596, label %NodeBlock27
  ]

if.then5:                                         ; preds = %if.end, %if.end
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %4 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %4, i32 0, i32 5
  %5 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %cmp6 = icmp ne i32 %5, 2
  br i1 %cmp6, label %cleanup246, label %if.end8

if.end8:                                          ; preds = %if.then5
  %index9 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %6 = load i32, i32* %index9, align 8, !tbaa !54
  %rem = srem i32 %6, 4
  %cmp10 = icmp eq i32 %cmd, 1090
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end8
  call void @__might_fault(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.7, i32 0, i32 0), i32 1683)
  %7 = bitcast i8* %2 to i32*
  %8 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %7, i64 4, i8* undef) #7, !srcloc !70
  %asmresult = extractvalue { i32*, i64, i8* } %8, 0
  %asmresult12 = extractvalue { i32*, i64, i8* } %8, 1
  %9 = ptrtoint i32* %asmresult to i64
  %10 = trunc i64 %9 to i32
  %conv = trunc i64 %asmresult12 to i32
  %conv14 = sext i32 %conv to i64
  %conv15 = sext i32 %10 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool = icmp eq i64 %expval, 0
  %switch = icmp ult i64 %conv14, 4
  %or.cond = and i1 %tobool, %switch
  br i1 %or.cond, label %if.end29, label %cleanup246

if.end29:                                         ; preds = %if.then11
  %idxprom = sext i32 %rem to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* @mxser_ioctl.ModeMask, i64 0, i64 %idxprom
  %11 = load i8, i8* %arrayidx, align 1, !tbaa !52
  %mul = mul nsw i32 %rem, 2
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %12 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i6 = bitcast %union.anon.1* %12 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i6) #7
  %opmode_ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 3
  %13 = load i64, i64* %opmode_ioaddr, align 8, !tbaa !71
  %conv30 = trunc i64 %13 to i32
  %call31 = call zeroext i8 @inb(i32 %conv30)
  %conv32 = zext i8 %11 to i32
  %conv33 = zext i8 %call31 to i32
  %and = and i32 %conv33, %conv32
  %conv34 = trunc i32 %and to i8
  %sh_prom = zext i32 %mul to i64
  %shl = shl i64 %conv14, %sh_prom
  %conv35 = zext i8 %conv34 to i64
  %or = or i64 %conv35, %shl
  %conv36 = trunc i64 %or to i8
  %opmode_ioaddr37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 3
  %14 = load i64, i64* %opmode_ioaddr37, align 8, !tbaa !71
  %conv38 = trunc i64 %14 to i32
  call void @outb(i8 zeroext %conv36, i32 %conv38)
  %slock39 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %15 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock39, i32 0, i32 0
  %rlock.i11 = bitcast %union.anon.1* %15 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i11) #7
  br label %if.end56

if.else:                                          ; preds = %if.end8
  %mul40 = mul nsw i32 %rem, 2
  %slock41 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %16 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock41, i32 0, i32 0
  %rlock.i5 = bitcast %union.anon.1* %16 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i5) #7
  %opmode_ioaddr42 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 3
  %17 = load i64, i64* %opmode_ioaddr42, align 8, !tbaa !71
  %conv43 = trunc i64 %17 to i32
  %call44 = call zeroext i8 @inb(i32 %conv43)
  %conv45 = zext i8 %call44 to i32
  %shr = ashr i32 %conv45, %mul40
  %conv46 = sext i32 %shr to i64
  %slock47 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %18 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock47, i32 0, i32 0
  %rlock.i10 = bitcast %union.anon.1* %18 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i10) #7
  %and48 = and i64 %conv46, 3
  call void @__might_fault(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.7, i32 0, i32 0), i32 1704)
  %conv49 = trunc i64 %and48 to i32
  %19 = bitcast i8* %2 to i32*
  %20 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv49, i32* %19) #7, !srcloc !72
  %conv51 = sext i32 %20 to i64
  %expval52 = call i64 @llvm.expect.i64(i64 %conv51, i64 0)
  %tobool53 = icmp ne i64 %expval52, 0
  br i1 %tobool53, label %cleanup246, label %if.end56

if.end56:                                         ; preds = %if.else, %if.end29
  br label %cleanup246

land.lhs.true67:                                  ; preds = %if.end
  %call68 = call zeroext i1 @tty_io_error(%struct.tty_struct* %tty)
  br i1 %call68, label %cleanup246, label %NodeBlock27

NodeBlock27:                                      ; preds = %land.lhs.true67, %if.end, %if.end
  %Pivot28 = icmp slt i32 %cmd, 1100
  br i1 %Pivot28, label %NodeBlock9, label %NodeBlock25

NodeBlock25:                                      ; preds = %NodeBlock27
  %Pivot26 = icmp slt i32 %cmd, 21535
  br i1 %Pivot26, label %NodeBlock13, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %cmd, 21593
  br i1 %Pivot24, label %LeafBlock15, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %cmd, 21596
  br i1 %Pivot22, label %LeafBlock17, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %cmd, 21596
  br i1 %SwitchLeaf20, label %do.body81, label %cleanup246

LeafBlock17:                                      ; preds = %NodeBlock21
  %SwitchLeaf18 = icmp eq i32 %cmd, 21593
  br i1 %SwitchLeaf18, label %sw.bb78, label %cleanup246

LeafBlock15:                                      ; preds = %NodeBlock23
  %SwitchLeaf16 = icmp eq i32 %cmd, 21535
  br i1 %SwitchLeaf16, label %sw.bb74, label %cleanup246

NodeBlock13:                                      ; preds = %NodeBlock25
  %Pivot14 = icmp slt i32 %cmd, 21534
  br i1 %Pivot14, label %LeafBlock11, label %sw.bb

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %cmd, 1100
  br i1 %SwitchLeaf12, label %sw.bb222, label %cleanup246

NodeBlock9:                                       ; preds = %NodeBlock27
  %Pivot10 = icmp slt i32 %cmd, 1094
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %cmd, 1097
  br i1 %Pivot8, label %LeafBlock1, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %cmd, 1098
  br i1 %Pivot6, label %sw.bb149, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %cmd, 1098
  br i1 %SwitchLeaf4, label %sw.bb212, label %cleanup246

LeafBlock1:                                       ; preds = %NodeBlock7
  %SwitchLeaf2 = icmp eq i32 %cmd, 1094
  br i1 %SwitchLeaf2, label %sw.bb130, label %cleanup246

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %cmd, 1093
  br i1 %Pivot, label %LeafBlock, label %sw.bb126

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, 1085
  br i1 %SwitchLeaf, label %sw.bb117, label %cleanup246

sw.bb:                                            ; preds = %NodeBlock13
  %mutex = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  %21 = bitcast i8* %2 to %struct.serial_struct*
  %call72 = call i32 @mxser_get_serial_info(%struct.tty_struct* %tty, %struct.serial_struct* %21)
  %mutex73 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_unlock(%struct.mutex* %mutex73)
  br label %cleanup246

sw.bb74:                                          ; preds = %LeafBlock15
  %mutex75 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_lock_nested(%struct.mutex* %mutex75, i32 0)
  %22 = bitcast i8* %2 to %struct.serial_struct*
  %call76 = call i32 @mxser_set_serial_info(%struct.tty_struct* %tty, %struct.serial_struct* %22)
  %mutex77 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_unlock(%struct.mutex* %mutex77)
  br label %cleanup246

sw.bb78:                                          ; preds = %LeafBlock17
  %23 = bitcast i8* %2 to i32*
  %call79 = call i32 @mxser_get_lsr_info(%struct.mxser_port* %1, i32* %23)
  br label %cleanup246

do.body81:                                        ; preds = %LeafBlock19
  %slock85 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %24 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock85, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %24 to %struct.raw_spinlock*
  %call87 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %icount = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 17
  %25 = bitcast %struct.async_icount* %cnow to i8*
  %26 = bitcast %struct.async_icount* %icount to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %25, i8* %26, i64 44, i32 4, i1 false), !tbaa.struct !73
  %slock90 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %27 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock90, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %27 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call87) #7
  call void @__might_sleep(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.7, i32 0, i32 0), i32 1738, i32 0)
  %call97 = call i32 @mxser_cflags_changed(%struct.mxser_port* %1, i64 %arg, %struct.async_icount* %cnow)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %cleanup246, label %if.then99

if.then99:                                        ; preds = %do.body81
  call void @init_wait_entry(%struct.__wait_queue* %__wait, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.then99
  %__ret100.0 = phi i64 [ 0, %if.then99 ], [ %__ret100.1, %cleanup.cont ]
  %port101 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %delta_msr_wait = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port101, i32 0, i32 9
  %call102 = call i64 @prepare_to_wait_event(%struct.__wait_queue_head* %delta_msr_wait, %struct.__wait_queue* %__wait, i32 1)
  %call103 = call i32 @mxser_cflags_changed(%struct.mxser_port* %1, i64 %arg, %struct.async_icount* %cnow)
  %tobool104 = icmp ne i32 %call103, 0
  br i1 %tobool104, label %NodeBlock32, label %if.end106

if.end106:                                        ; preds = %for.cond
  %tobool107 = icmp ne i64 %call102, 0
  br i1 %tobool107, label %NodeBlock32, label %if.end109

if.end109:                                        ; preds = %if.end106
  call void @schedule()
  br label %NodeBlock32

NodeBlock32:                                      ; preds = %if.end109, %if.end106, %for.cond
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end109 ], [ 11, %for.cond ], [ 13, %if.end106 ]
  %__ret100.1 = phi i64 [ %__ret100.0, %if.end109 ], [ %__ret100.0, %for.cond ], [ %call102, %if.end106 ]
  %Pivot33 = icmp slt i32 %cleanup.dest.slot.0, 13
  br i1 %Pivot33, label %LeafBlock30, label %__out

LeafBlock30:                                      ; preds = %NodeBlock32
  %SwitchLeaf31 = icmp eq i32 %cleanup.dest.slot.0, 11
  br i1 %SwitchLeaf31, label %for.end, label %cleanup.cont

cleanup.cont:                                     ; preds = %LeafBlock30
  br label %for.cond

for.end:                                          ; preds = %LeafBlock30
  %port111 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %delta_msr_wait112 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port111, i32 0, i32 9
  call void @finish_wait(%struct.__wait_queue_head* %delta_msr_wait112, %struct.__wait_queue* %__wait)
  br label %__out

__out:                                            ; preds = %for.end, %NodeBlock32
  %conv114 = trunc i64 %__ret100.1 to i32
  br label %cleanup246

sw.bb117:                                         ; preds = %LeafBlock
  call void @__might_fault(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.7, i32 0, i32 0), i32 1740)
  %baud_base = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %28 = load i32, i32* %baud_base, align 8, !tbaa !39
  %cmp120 = icmp ne i32 %28, 115200
  %cond = select i1 %cmp120, i32 1, i32 0
  %29 = bitcast i8* %2 to i32*
  %30 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %cond, i32* %29) #7, !srcloc !74
  %conv123 = sext i32 %30 to i64
  %expval124 = call i64 @llvm.expect.i64(i64 %conv123, i64 0)
  %conv125 = trunc i64 %expval124 to i32
  br label %cleanup246

sw.bb126:                                         ; preds = %NodeBlock
  %slock127 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %31 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock127, i32 0, i32 0
  %rlock.i4 = bitcast %union.anon.1* %31 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i4) #7
  %mon_data = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %rxcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data, i32 0, i32 0
  store i64 0, i64* %rxcnt, align 8, !tbaa !75
  %mon_data128 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %txcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data128, i32 0, i32 1
  store i64 0, i64* %txcnt, align 8, !tbaa !76
  %slock129 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %32 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock129, i32 0, i32 0
  %rlock.i9 = bitcast %union.anon.1* %32 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i9) #7
  br label %cleanup246

sw.bb130:                                         ; preds = %LeafBlock1
  %call131 = call i32 @mxser_chars_in_buffer(%struct.tty_struct* %tty)
  %slock132 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %33 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock132, i32 0, i32 0
  %rlock.i3 = bitcast %union.anon.1* %33 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i3) #7
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %34 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %34, 5
  %conv133 = trunc i64 %add to i32
  %call134 = call zeroext i8 @inb(i32 %conv133)
  %conv135 = zext i8 %call134 to i32
  %and136 = and i32 %conv135, 32
  %slock137 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %35 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock137, i32 0, i32 0
  %rlock.i8 = bitcast %union.anon.1* %35 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i8) #7
  %tobool138 = icmp ne i32 %and136, 0
  %cond139 = select i1 %tobool138, i32 0, i32 1
  %add140 = add nsw i32 %call131, %cond139
  call void @__might_fault(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.7, i32 0, i32 0), i32 1757)
  %36 = bitcast i8* %2 to i32*
  %37 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %add140, i32* %36) #7, !srcloc !77
  %conv144 = sext i32 %37 to i64
  %expval145 = call i64 @llvm.expect.i64(i64 %conv144, i64 0)
  %conv146 = trunc i64 %expval145 to i32
  br label %cleanup246

sw.bb149:                                         ; preds = %NodeBlock5
  %slock150 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %38 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock150, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %38 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i2) #7
  %ioaddr151 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %39 = load i64, i64* %ioaddr151, align 8, !tbaa !17
  %conv152 = trunc i64 %39 to i32
  %index153 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %40 = load i32, i32* %index153, align 8, !tbaa !54
  %call154 = call zeroext i8 @mxser_get_msr(i32 %conv152, i32 1, i32 %40)
  %conv155 = zext i8 %call154 to i32
  call void @mxser_check_modem_status(%struct.tty_struct* %tty, %struct.mxser_port* %1, i32 %conv155)
  %ioaddr156 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %41 = load i64, i64* %ioaddr156, align 8, !tbaa !17
  %add157 = add i64 %41, 4
  %conv158 = trunc i64 %add157 to i32
  %call159 = call zeroext i8 @inb(i32 %conv158)
  %conv160 = zext i8 %call159 to i32
  %slock161 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %42 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock161, i32 0, i32 0
  %rlock.i7 = bitcast %union.anon.1* %42 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i7) #7
  %and162 = and i32 %conv160, 64
  %tobool163 = icmp ne i32 %and162, 0
  %mon_data165 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %hold_reason = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data165, i32 0, i32 5
  %43 = load i8, i8* %hold_reason, align 4, !tbaa !78
  %conv166 = zext i8 %43 to i32
  %or173 = or i32 %conv166, 8
  %and167 = and i32 %conv166, -9
  %or173.sink = select i1 %tobool163, i32 %and167, i32 %or173
  %conv174 = trunc i32 %or173.sink to i8
  store i8 %conv174, i8* %hold_reason, align 4, !tbaa !78
  %and176 = and i32 %conv160, 8
  %tobool177 = icmp ne i32 %and176, 0
  %mon_data179 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %hold_reason180 = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data179, i32 0, i32 5
  %44 = load i8, i8* %hold_reason180, align 4, !tbaa !78
  %conv181 = zext i8 %44 to i32
  %or188 = or i32 %conv181, 16
  %and182 = and i32 %conv181, -17
  %or188.sink = select i1 %tobool177, i32 %and182, i32 %or188
  %conv189 = trunc i32 %or188.sink to i8
  store i8 %conv189, i8* %hold_reason180, align 4, !tbaa !78
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  %45 = load i32, i32* %hw_stopped, align 8, !tbaa !68
  %tobool191 = icmp ne i32 %45, 0
  %mon_data193 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %hold_reason194 = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data193, i32 0, i32 5
  %46 = load i8, i8* %hold_reason194, align 4, !tbaa !78
  %conv195 = zext i8 %46 to i32
  %and202 = and i32 %conv195, -2
  %or196 = or i32 %conv195, 1
  %and202.sink = select i1 %tobool191, i32 %or196, i32 %and202
  %conv203 = trunc i32 %and202.sink to i8
  store i8 %conv203, i8* %hold_reason194, align 4, !tbaa !78
  %mon_data205 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %47 = bitcast %struct.mxser_mon* %mon_data205 to i8*
  %48 = call i64 @llvm.objectsize.i64.p0i8(i8* %47, i1 false, i1 true) #7
  %conv.i = trunc i64 %48 to i32
  call void @kasan_check_read(i8* %47, i32 40) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.10, i32 0, i32 0), i32 718) #7
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 40
  %49 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %49 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #7
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %sw.bb149
  call void @__check_object_size(i8* %47, i64 40, i1 zeroext true) #7
  %call.i = call i64 @_copy_to_user(i8* %2, i8* %47, i32 40) #7
  br label %copy_to_user.exit

if.else.i:                                        ; preds = %sw.bb149
  call void @copy_user_overflow(i32 %conv.i, i64 40) #7
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 40, %if.else.i ]
  %tobool207 = icmp ne i64 %n.addr.0.i, 0
  %. = select i1 %tobool207, i32 -14, i32 0
  br label %cleanup246

sw.bb212:                                         ; preds = %LeafBlock3
  call void @__might_fault(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.7, i32 0, i32 0), i32 1791)
  %err_shadow = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 16
  %50 = load i8, i8* %err_shadow, align 4, !tbaa !53
  %51 = zext i8 %50 to i32
  %52 = call i32 asm sideeffect "call __put_user_1", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %51, i8* %2) #7, !srcloc !79
  %conv216 = sext i32 %52 to i64
  %expval217 = call i64 @llvm.expect.i64(i64 %conv216, i64 0)
  %tobool218 = icmp ne i64 %expval217, 0
  br i1 %tobool218, label %cleanup246, label %if.end220

if.end220:                                        ; preds = %sw.bb212
  %err_shadow221 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 16
  store i8 0, i8* %err_shadow221, align 4, !tbaa !53
  br label %cleanup246

sw.bb222:                                         ; preds = %LeafBlock11
  call void @__might_fault(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.7, i32 0, i32 0), i32 1800)
  %53 = bitcast i8* %2 to i32*
  %54 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %53, i64 4, i8* undef) #7, !srcloc !80
  %asmresult226 = extractvalue { i32*, i64, i8* } %54, 0
  %asmresult227 = extractvalue { i32*, i64, i8* } %54, 1
  %55 = ptrtoint i32* %asmresult226 to i64
  %56 = trunc i64 %55 to i32
  %conv229 = trunc i64 %asmresult227 to i32
  %conv231 = sext i32 %56 to i64
  %expval232 = call i64 @llvm.expect.i64(i64 %conv231, i64 0)
  %tobool233 = icmp ne i64 %expval232, 0
  br i1 %tobool233, label %cleanup246, label %if.end235

if.end235:                                        ; preds = %sw.bb222
  %index236 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %57 = load i32, i32* %index236, align 8, !tbaa !54
  %idxprom237 = sext i32 %57 to i64
  %arrayidx238 = getelementptr inbounds [33 x i32], [33 x i32]* @mxser_set_baud_method, i64 0, i64 %idxprom237
  store i32 %conv229, i32* %arrayidx238, align 4, !tbaa !51
  call void @__might_fault(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.7, i32 0, i32 0), i32 1803)
  %58 = bitcast i8* %2 to i32*
  %59 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv229, i32* %58) #7, !srcloc !81
  %conv242 = sext i32 %59 to i64
  %expval243 = call i64 @llvm.expect.i64(i64 %conv242, i64 0)
  %conv244 = trunc i64 %expval243 to i32
  br label %cleanup246

cleanup246:                                       ; preds = %if.end235, %sw.bb222, %if.end220, %sw.bb212, %copy_to_user.exit, %sw.bb130, %sw.bb126, %sw.bb117, %__out, %do.body81, %sw.bb78, %sw.bb74, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock11, %LeafBlock15, %LeafBlock17, %LeafBlock19, %land.lhs.true67, %if.end56, %if.else, %if.then11, %if.then5, %if.then
  %retval.3 = phi i32 [ %call, %if.then ], [ %conv125, %sw.bb117 ], [ 0, %sw.bb126 ], [ %conv146, %sw.bb130 ], [ %., %copy_to_user.exit ], [ 0, %if.end220 ], [ %call72, %sw.bb ], [ %call76, %sw.bb74 ], [ %call79, %sw.bb78 ], [ 0, %if.end56 ], [ -14, %if.then5 ], [ -14, %if.then11 ], [ -14, %if.else ], [ -5, %land.lhs.true67 ], [ 0, %do.body81 ], [ %conv114, %__out ], [ -14, %sw.bb212 ], [ %conv244, %if.end235 ], [ -14, %sw.bb222 ], [ -515, %LeafBlock ], [ -515, %LeafBlock1 ], [ -515, %LeafBlock3 ], [ -515, %LeafBlock11 ], [ -515, %LeafBlock15 ], [ -515, %LeafBlock17 ], [ -515, %LeafBlock19 ]
  ret i32 %retval.3
}

; Function Attrs: nounwind uwtable
define internal void @mxser_set_termios(%struct.tty_struct* %tty, %struct.ktermios* %old_termios) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i1)
  call void @mxser_change_speed(%struct.tty_struct* %tty)
  %slock6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock6, i32 0, i32 0
  %rlock.i5 = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i5, i64 %call2) #7
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %old_termios, i32 0, i32 2
  %4 = load i32, i32* %c_cflag, align 4, !tbaa !82
  %and = and i32 %4, -2147483648
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_cflag7 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 2
  %5 = load i32, i32* %c_cflag7, align 8, !tbaa !63
  %and8 = and i32 %5, -2147483648
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  store i32 0, i32* %hw_stopped, align 8, !tbaa !68
  call void @mxser_start(%struct.tty_struct* %tty)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %c_iflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %old_termios, i32 0, i32 0
  %6 = load i32, i32* %c_iflag, align 4, !tbaa !83
  %and10 = and i32 %6, 1024
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %land.lhs.true12, label %if.end36

land.lhs.true12:                                  ; preds = %if.end
  %termios13 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_iflag14 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios13, i32 0, i32 0
  %7 = load i32, i32* %c_iflag14, align 8, !tbaa !84
  %and15 = and i32 %7, 1024
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.end36, label %if.then17

if.then17:                                        ; preds = %land.lhs.true12
  %stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 24
  %bf.load = load i8, i8* %stopped, align 4
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %stopped, align 4
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %8 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %8, i32 0, i32 5
  %9 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool18 = icmp ne i32 %9, 0
  br i1 %tobool18, label %do.body21, label %if.end35

do.body21:                                        ; preds = %if.then17
  %slock27 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %10 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock27, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %10 to %struct.raw_spinlock*
  %call29 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %11 = load i64, i64* %ioaddr, align 8, !tbaa !17
  call void @mxser_disable_must_rx_software_flow_control(i64 %11)
  %slock34 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %12 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock34, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %12 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i2, i64 %call29) #7
  br label %if.end35

if.end35:                                         ; preds = %do.body21, %if.then17
  call void @mxser_start(%struct.tty_struct* %tty)
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %land.lhs.true12, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_throttle(%struct.tty_struct* %tty) #4 {
entry:
  call void @mxser_stoprx(%struct.tty_struct* %tty)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_unthrottle(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %ldisc_stop_rx = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 14
  store i8 0, i8* %ldisc_stop_rx, align 1, !tbaa !45
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_iflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 0
  %2 = load i32, i32* %c_iflag, align 8, !tbaa !84
  %and = and i32 %2, 4096
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end23

if.then:                                          ; preds = %entry
  %x_char = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 10
  %3 = load i32, i32* %x_char, align 8, !tbaa !85
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %x_char3 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 10
  store i32 0, i32* %x_char3, align 8, !tbaa !85
  br label %if.end23

if.else:                                          ; preds = %if.then
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %4 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %4, i32 0, i32 5
  %5 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %6 = load i32, i32* %IER, align 4, !tbaa !69
  %or = or i32 %6, 17
  store i32 %or, i32* %IER, align 4, !tbaa !69
  %IER6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %7 = load i32, i32* %IER6, align 4, !tbaa !69
  %conv = trunc i32 %7 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %8 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %8, 1
  %conv7 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv, i32 %conv7)
  br label %if.end23

if.else8:                                         ; preds = %if.else
  %termios9 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_cc = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios9, i32 0, i32 5
  %arrayidx = getelementptr inbounds [19 x i8], [19 x i8]* %c_cc, i64 0, i64 8
  %9 = load i8, i8* %arrayidx, align 1, !tbaa !52
  %conv10 = zext i8 %9 to i32
  %x_char11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 10
  store i32 %conv10, i32* %x_char11, align 8, !tbaa !85
  %ioaddr12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %10 = load i64, i64* %ioaddr12, align 8, !tbaa !17
  %add13 = add i64 %10, 1
  %conv14 = trunc i64 %add13 to i32
  call void @outb(i8 zeroext 0, i32 %conv14)
  %IER15 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %11 = load i32, i32* %IER15, align 4, !tbaa !69
  %or16 = or i32 %11, 2
  store i32 %or16, i32* %IER15, align 4, !tbaa !69
  %IER17 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %12 = load i32, i32* %IER17, align 4, !tbaa !69
  %conv18 = trunc i32 %12 to i8
  %ioaddr19 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %13 = load i64, i64* %ioaddr19, align 8, !tbaa !17
  %add20 = add i64 %13, 1
  %conv21 = trunc i64 %add20 to i32
  call void @outb(i8 zeroext %conv18, i32 %conv21)
  br label %if.end23

if.end23:                                         ; preds = %if.else8, %if.then5, %if.then2, %entry
  %termios24 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios24, i32 0, i32 2
  %14 = load i32, i32* %c_cflag, align 8, !tbaa !63
  %and25 = and i32 %14, -2147483648
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then27, label %if.end34

if.then27:                                        ; preds = %if.end23
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %15 = load i32, i32* %MCR, align 8, !tbaa !86
  %or28 = or i32 %15, 2
  store i32 %or28, i32* %MCR, align 8, !tbaa !86
  %MCR29 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %16 = load i32, i32* %MCR29, align 8, !tbaa !86
  %conv30 = trunc i32 %16 to i8
  %ioaddr31 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %17 = load i64, i64* %ioaddr31, align 8, !tbaa !17
  %add32 = add i64 %17, 4
  %conv33 = trunc i64 %add32 to i32
  call void @outb(i8 zeroext %conv30, i32 %conv33)
  br label %if.end34

if.end34:                                         ; preds = %if.then27, %if.end23
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_stop(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %3 = load i32, i32* %IER, align 4, !tbaa !69
  %and = and i32 %3, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %IER5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %4 = load i32, i32* %IER5, align 4, !tbaa !69
  %and6 = and i32 %4, -3
  store i32 %and6, i32* %IER5, align 4, !tbaa !69
  %IER7 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %5 = load i32, i32* %IER7, align 4, !tbaa !69
  %conv8 = trunc i32 %5 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %6 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %6, 1
  %conv9 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv8, i32 %conv9)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %slock10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %7 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock10, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %7 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_start(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %3 = load i32, i32* %xmit_cnt, align 4, !tbaa !65
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 15
  %4 = load i8*, i8** %xmit_buf, align 8, !tbaa !64
  %tobool5 = icmp ne i8* %4, null
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %5 = load i32, i32* %IER, align 4, !tbaa !69
  %and = and i32 %5, -3
  %conv6 = trunc i32 %and to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %6 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %6, 1
  %conv7 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv6, i32 %conv7)
  %IER8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %7 = load i32, i32* %IER8, align 4, !tbaa !69
  %or = or i32 %7, 2
  store i32 %or, i32* %IER8, align 4, !tbaa !69
  %IER9 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %8 = load i32, i32* %IER9, align 4, !tbaa !69
  %conv10 = trunc i32 %8 to i8
  %ioaddr11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr11, align 8, !tbaa !17
  %add12 = add i64 %9, 1
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %conv10, i32 %conv13)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %slock14 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %10 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock14, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %10 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_hangup(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  call void @mxser_flush_buffer(%struct.tty_struct* %tty)
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  call void @tty_port_hangup(%struct.tty_port* %port)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_rs_break(%struct.tty_struct* %tty, i32 %break_state) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %cmp5 = icmp eq i32 %break_state, -1
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %3 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %3, 3
  %conv7 = trunc i64 %add to i32
  %call8 = call zeroext i8 @inb(i32 %conv7)
  %conv9 = zext i8 %call8 to i32
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %or = or i32 %conv9, 64
  %conv10 = trunc i32 %or to i8
  %ioaddr11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %4 = load i64, i64* %ioaddr11, align 8, !tbaa !17
  %add12 = add i64 %4, 3
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %conv10, i32 %conv13)
  br label %if.end

if.else:                                          ; preds = %entry
  %and = and i32 %conv9, -65
  %conv19 = trunc i32 %and to i8
  %ioaddr20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %5 = load i64, i64* %ioaddr20, align 8, !tbaa !17
  %add21 = add i64 %5, 3
  %conv22 = trunc i64 %add21 to i32
  call void @outb(i8 zeroext %conv19, i32 %conv22)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %slock23 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock23, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #7
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @mxser_flush_buffer(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %xmit_tail = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 23
  store i32 0, i32* %xmit_tail, align 8, !tbaa !87
  %xmit_head = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  store i32 0, i32* %xmit_head, align 4, !tbaa !67
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  store i32 0, i32* %xmit_cnt, align 4, !tbaa !65
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %3 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %3, 2
  %conv5 = trunc i64 %add to i32
  %call6 = call zeroext i8 @inb(i32 %conv5)
  %conv7 = sext i8 %call6 to i32
  %or = or i32 %conv7, 2
  %or8 = or i32 %or, 4
  %conv9 = trunc i32 %or8 to i8
  %ioaddr10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %4 = load i64, i64* %ioaddr10, align 8, !tbaa !17
  %add11 = add i64 %4, 2
  %conv12 = trunc i64 %add11 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv12)
  %ioaddr13 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %5 = load i64, i64* %ioaddr13, align 8, !tbaa !17
  %add14 = add i64 %5, 2
  %conv15 = trunc i64 %add14 to i32
  call void @outb(i8 zeroext %call6, i32 %conv15)
  %slock16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock16, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #7
  call void @tty_wakeup(%struct.tty_struct* %tty)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_wait_until_sent(%struct.tty_struct* %tty, i32 %timeout) #4 {
entry:
  %__ret = alloca i64, align 8
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %2 = load i32, i32* %type, align 4, !tbaa !46
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %xmit_fifo_size = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 21
  %3 = load i32, i32* %xmit_fifo_size, align 8, !tbaa !88
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %cleanup.cont, label %if.end3

if.end3:                                          ; preds = %if.end
  %4 = load volatile i64, i64* @jiffies, align 8, !tbaa !66
  %timeout4 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 18
  %5 = load i32, i32* %timeout4, align 4, !tbaa !89
  %sub = sub nsw i32 %5, 5
  %xmit_fifo_size5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 21
  %6 = load i32, i32* %xmit_fifo_size5, align 8, !tbaa !88
  %div = sdiv i32 %sub, %6
  %conv = sext i32 %div to i64
  %div6 = udiv i64 %conv, 5
  %cmp7 = icmp eq i64 %div6, 0
  %.div6 = select i1 %cmp7, i64 1, i64 %div6
  %tobool = icmp ne i32 %timeout, 0
  %conv11 = sext i32 %timeout to i64
  %cmp12 = icmp ult i64 %conv11, %.div6
  %or.cond = and i1 %tobool, %cmp12
  %conv15 = sext i32 %timeout to i64
  %char_time.1 = select i1 %or.cond, i64 %conv15, i64 %.div6
  %tobool17 = icmp ne i32 %timeout, 0
  br i1 %tobool17, label %lor.lhs.false, label %if.then21

lor.lhs.false:                                    ; preds = %if.end3
  %timeout18 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 18
  %7 = load i32, i32* %timeout18, align 4, !tbaa !89
  %mul = mul nsw i32 2, %7
  %cmp19 = icmp sgt i32 %timeout, %mul
  br i1 %cmp19, label %if.then21, label %do.body25

if.then21:                                        ; preds = %lor.lhs.false, %if.end3
  %timeout22 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 18
  %8 = load i32, i32* %timeout22, align 4, !tbaa !89
  %mul23 = mul nsw i32 2, %8
  br label %do.body25

do.body25:                                        ; preds = %if.then21, %lor.lhs.false
  %timeout.addr.0 = phi i32 [ %mul23, %if.then21 ], [ %timeout, %lor.lhs.false ]
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %9 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %9 to %struct.raw_spinlock*
  %call28 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i1)
  br label %while.cond

while.cond:                                       ; preds = %if.end78, %do.body25
  %flags.0 = phi i64 [ %call28, %do.body25 ], [ %call46, %if.end78 ]
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %10 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %10, 5
  %conv31 = trunc i64 %add to i32
  %call32 = call zeroext i8 @inb(i32 %conv31)
  %conv33 = zext i8 %call32 to i32
  %and = and i32 %conv33, 64
  %tobool34 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool34, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %slock35 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock35, i32 0, i32 0
  %rlock.i5 = bitcast %union.anon.1* %11 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i5, i64 %flags.0) #7
  %call36 = call i64 @schedule_timeout_interruptible(i64 %char_time.1)
  %slock44 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %12 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock44, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %12 to %struct.raw_spinlock*
  %call46 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %13 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !90
  %call52 = call i32 @signal_pending(%struct.task_struct* %13)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %while.end, label %if.end55

if.end55:                                         ; preds = %while.body
  %tobool56 = icmp ne i32 %timeout.addr.0, 0
  br i1 %tobool56, label %land.lhs.true57, label %if.end78

land.lhs.true57:                                  ; preds = %if.end55
  %tobool63 = icmp ne i32 1, 0
  br i1 %tobool63, label %land.lhs.true64, label %if.end78

land.lhs.true64:                                  ; preds = %land.lhs.true57
  %conv72 = sext i32 %timeout.addr.0 to i64
  %add73 = add i64 %4, %conv72
  %14 = load volatile i64, i64* @jiffies, align 8, !tbaa !66
  %sub74 = sub i64 %add73, %14
  %cmp75 = icmp slt i64 %sub74, 0
  br i1 %cmp75, label %while.end, label %if.end78

if.end78:                                         ; preds = %land.lhs.true64, %land.lhs.true57, %if.end55
  br label %while.cond

while.end:                                        ; preds = %land.lhs.true64, %while.body, %while.cond
  %flags.1 = phi i64 [ %call46, %while.body ], [ %call46, %land.lhs.true64 ], [ %flags.0, %while.cond ]
  %slock79 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %15 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock79, i32 0, i32 0
  %rlock.i2 = bitcast %union.anon.1* %15 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i2, i64 %flags.1) #7
  br label %__here

__here:                                           ; preds = %while.end
  %16 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !90
  %task_state_change = getelementptr inbounds %struct.task_struct, %struct.task_struct* %16, i32 0, i32 208
  store i64 ptrtoint (i8* blockaddress(@mxser_wait_until_sent, %__here) to i64), i64* %task_state_change, align 32, !tbaa !91
  store volatile i64 0, i64* %__ret, align 8, !tbaa !66
  %17 = load volatile i64, i64* %__ret, align 8, !tbaa !66
  %18 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !90
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %18, i32 0, i32 1
  %19 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state, i64 %17, i64* %state) #7, !srcloc !129
  store volatile i64 %19, i64* %__ret, align 8, !tbaa !66
  %20 = load volatile i64, i64* %__ret, align 8, !tbaa !66
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %__here, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_tiocmget(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %2 = load i32, i32* %index, align 8, !tbaa !54
  %cmp = icmp eq i32 %2, 32
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call zeroext i1 @tty_io_error(%struct.tty_struct* %tty)
  br i1 %call, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %3 = load i32, i32* %MCR, align 8, !tbaa !86
  %conv = trunc i32 %3 to i8
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %4 to %struct.raw_spinlock*
  %call7 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %5 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %5, 6
  %conv10 = trunc i64 %add to i32
  %call11 = call zeroext i8 @inb(i32 %conv10)
  %conv12 = zext i8 %call11 to i32
  %and = and i32 %conv12, 15
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end2
  %conv14 = zext i8 %call11 to i32
  call void @mxser_check_modem_status(%struct.tty_struct* %tty, %struct.mxser_port* %1, i32 %conv14)
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end2
  %slock16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock16, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call7) #7
  %conv17 = zext i8 %conv to i32
  %and18 = and i32 %conv17, 2
  %tobool19 = icmp ne i32 %and18, 0
  %cond = select i1 %tobool19, i32 4, i32 0
  %conv20 = zext i8 %conv to i32
  %and21 = and i32 %conv20, 1
  %tobool22 = icmp ne i32 %and21, 0
  %cond23 = select i1 %tobool22, i32 2, i32 0
  %or = or i32 %cond, %cond23
  %conv24 = zext i8 %call11 to i32
  %and25 = and i32 %conv24, 128
  %tobool26 = icmp ne i32 %and25, 0
  %cond27 = select i1 %tobool26, i32 64, i32 0
  %or28 = or i32 %or, %cond27
  %conv29 = zext i8 %call11 to i32
  %and30 = and i32 %conv29, 64
  %tobool31 = icmp ne i32 %and30, 0
  %cond32 = select i1 %tobool31, i32 128, i32 0
  %or33 = or i32 %or28, %cond32
  %conv34 = zext i8 %call11 to i32
  %and35 = and i32 %conv34, 32
  %tobool36 = icmp ne i32 %and35, 0
  %cond37 = select i1 %tobool36, i32 256, i32 0
  %or38 = or i32 %or33, %cond37
  %conv39 = zext i8 %call11 to i32
  %and40 = and i32 %conv39, 16
  %tobool41 = icmp ne i32 %and40, 0
  %cond42 = select i1 %tobool41, i32 32, i32 0
  %or43 = or i32 %or38, %cond42
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.end, %entry
  %retval.0 = phi i32 [ %or43, %if.end15 ], [ -515, %entry ], [ -5, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_tiocmset(%struct.tty_struct* %tty, i32 %set, i32 %clear) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %2 = load i32, i32* %index, align 8, !tbaa !54
  %cmp = icmp eq i32 %2, 32
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call zeroext i1 @tty_io_error(%struct.tty_struct* %tty)
  br i1 %call, label %cleanup, label %do.body3

do.body3:                                         ; preds = %if.end
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  %call6 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %and = and i32 %set, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then9, label %if.end10

if.then9:                                         ; preds = %do.body3
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %4 = load i32, i32* %MCR, align 8, !tbaa !86
  %or = or i32 %4, 2
  store i32 %or, i32* %MCR, align 8, !tbaa !86
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %do.body3
  %and11 = and i32 %set, 2
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end10
  %MCR14 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %5 = load i32, i32* %MCR14, align 8, !tbaa !86
  %or15 = or i32 %5, 1
  store i32 %or15, i32* %MCR14, align 8, !tbaa !86
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end10
  %and17 = and i32 %clear, 4
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.end16
  %MCR20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %6 = load i32, i32* %MCR20, align 8, !tbaa !86
  %and21 = and i32 %6, -3
  store i32 %and21, i32* %MCR20, align 8, !tbaa !86
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.end16
  %and23 = and i32 %clear, 2
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end28

if.then25:                                        ; preds = %if.end22
  %MCR26 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %7 = load i32, i32* %MCR26, align 8, !tbaa !86
  %and27 = and i32 %7, -2
  store i32 %and27, i32* %MCR26, align 8, !tbaa !86
  br label %if.end28

if.end28:                                         ; preds = %if.then25, %if.end22
  %MCR29 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %8 = load i32, i32* %MCR29, align 8, !tbaa !86
  %conv30 = trunc i32 %8 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %9, 4
  %conv31 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv30, i32 %conv31)
  %slock32 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %10 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock32, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %10 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call6) #7
  br label %cleanup

cleanup:                                          ; preds = %if.end28, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end28 ], [ -515, %entry ], [ -5, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_get_icount(%struct.tty_struct* %tty, %struct.serial_icounter_struct* %icount) #4 {
entry:
  %cnow = alloca %struct.async_icount, align 4
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %icount5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 17
  %3 = bitcast %struct.async_icount* %cnow to i8*
  %4 = bitcast %struct.async_icount* %icount5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 44, i32 4, i1 false), !tbaa.struct !73
  %slock6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock6, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %5 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #7
  %frame = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 6
  %6 = load i32, i32* %frame, align 4, !tbaa !130
  %frame7 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 6
  store i32 %6, i32* %frame7, align 4, !tbaa !131
  %brk = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 9
  %7 = load i32, i32* %brk, align 4, !tbaa !133
  %brk8 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 9
  store i32 %7, i32* %brk8, align 4, !tbaa !134
  %overrun = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 8
  %8 = load i32, i32* %overrun, align 4, !tbaa !135
  %overrun9 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 7
  store i32 %8, i32* %overrun9, align 4, !tbaa !136
  %buf_overrun = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 10
  %9 = load i32, i32* %buf_overrun, align 4, !tbaa !137
  %buf_overrun10 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 10
  store i32 %9, i32* %buf_overrun10, align 4, !tbaa !138
  %parity = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 7
  %10 = load i32, i32* %parity, align 4, !tbaa !139
  %parity11 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 8
  store i32 %10, i32* %parity11, align 4, !tbaa !140
  %rx = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 5
  %11 = load i32, i32* %rx, align 4, !tbaa !141
  %rx12 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 4
  store i32 %11, i32* %rx12, align 4, !tbaa !142
  %tx = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 4
  %12 = load i32, i32* %tx, align 4, !tbaa !143
  %tx13 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 5
  store i32 %12, i32* %tx13, align 4, !tbaa !144
  %cts = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 0
  %13 = load i32, i32* %cts, align 4, !tbaa !145
  %cts14 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 0
  store i32 %13, i32* %cts14, align 4, !tbaa !146
  %dsr = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 1
  %14 = load i32, i32* %dsr, align 4, !tbaa !147
  %dsr15 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 1
  store i32 %14, i32* %dsr15, align 4, !tbaa !148
  %rng = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 2
  %15 = load i32, i32* %rng, align 4, !tbaa !149
  %rng16 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 2
  store i32 %15, i32* %rng16, align 4, !tbaa !150
  %dcd = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 3
  %16 = load i32, i32* %dcd, align 4, !tbaa !151
  %dcd17 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 3
  store i32 %16, i32* %dcd17, align 4, !tbaa !152
  ret i32 0
}

declare i32 @tty_port_open(%struct.tty_port*, %struct.tty_struct*, %struct.file*) #3

declare i32 @tty_port_close_start(%struct.tty_port*, %struct.tty_struct*, %struct.file*) #3

declare void @mutex_lock_nested(%struct.mutex*, i32) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_close_port(%struct.tty_port* %port) #4 {
entry:
  %0 = bitcast %struct.tty_port* %port to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.mxser_port*
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %2 = load i32, i32* %IER, align 4, !tbaa !69
  %and = and i32 %2, -5
  store i32 %and, i32* %IER, align 4, !tbaa !69
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %3 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %3, i32 0, i32 5
  %4 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %IER1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %5 = load i32, i32* %IER1, align 4, !tbaa !69
  %and2 = and i32 %5, -18
  store i32 %and2, i32* %IER1, align 4, !tbaa !69
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %IER3 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %6 = load i32, i32* %IER3, align 4, !tbaa !69
  %conv = trunc i32 %6 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %7 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %7, 1
  %conv4 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv, i32 %conv4)
  %8 = load volatile i64, i64* @jiffies, align 8, !tbaa !66
  %add5 = add i64 %8, 250
  br label %while.cond

while.cond:                                       ; preds = %if.end26, %if.end
  %ioaddr6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr6, align 8, !tbaa !17
  %add7 = add i64 %9, 5
  %conv8 = trunc i64 %add7 to i32
  %call = call zeroext i8 @inb(i32 %conv8)
  %conv9 = zext i8 %call to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %lnot = xor i1 %tobool11, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call12 = call i64 @schedule_timeout_interruptible(i64 5)
  %tobool15 = icmp ne i32 1, 0
  br i1 %tobool15, label %land.lhs.true, label %if.end26

land.lhs.true:                                    ; preds = %while.body
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !66
  %sub = sub i64 %add5, %10
  %cmp23 = icmp slt i64 %sub, 0
  br i1 %cmp23, label %while.end, label %if.end26

if.end26:                                         ; preds = %land.lhs.true, %while.body
  br label %while.cond

while.end:                                        ; preds = %land.lhs.true, %while.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @tty_port_initialized(%struct.tty_port* %port) #2 {
entry:
  %iflags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 11
  %0 = load volatile i64, i64* %iflags, align 8, !tbaa !66
  %and1.i = and i64 1, %0
  %cmp.i = icmp ne i64 %and1.i, 0
  ret i1 %cmp.i
}

declare void @tty_port_lower_dtr_rts(%struct.tty_port*) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_shutdown_port(%struct.tty_port* %port) #4 {
entry:
  %0 = bitcast %struct.tty_port* %port to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %port6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %delta_msr_wait = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port6, i32 0, i32 9
  call void @__wake_up(%struct.__wait_queue_head* %delta_msr_wait, i32 1, i32 1, i8* null)
  %port7 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port7, i32 0, i32 15
  %3 = load i8*, i8** %xmit_buf, align 8, !tbaa !64
  %tobool = icmp ne i8* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %port8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf9 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port8, i32 0, i32 15
  %4 = load i8*, i8** %xmit_buf9, align 8, !tbaa !64
  %5 = ptrtoint i8* %4 to i64
  call void @free_pages(i64 %5, i32 0)
  %port10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf11 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port10, i32 0, i32 15
  store i8* null, i8** %xmit_buf11, align 8, !tbaa !64
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  store i32 0, i32* %IER, align 4, !tbaa !69
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %6 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %6, 1
  %conv12 = trunc i64 %add to i32
  call void @outb(i8 zeroext 0, i32 %conv12)
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %7 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %7, i32 0, i32 5
  %8 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool13 = icmp ne i32 %8, 0
  %ioaddr15 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr15, align 8, !tbaa !17
  %add16 = add i64 %9, 2
  %conv17 = trunc i64 %add16 to i32
  br i1 %tobool13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  call void @outb(i8 zeroext 38, i32 %conv17)
  br label %if.end21

if.else:                                          ; preds = %if.end
  call void @outb(i8 zeroext 6, i32 %conv17)
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then14
  %ioaddr22 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %10 = load i64, i64* %ioaddr22, align 8, !tbaa !17
  %add23 = add i64 %10, 0
  %conv24 = trunc i64 %add23 to i32
  %call25 = call zeroext i8 @inb(i32 %conv24)
  %board26 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %11 = load %struct.mxser_board*, %struct.mxser_board** %board26, align 8, !tbaa !43
  %chip_flag27 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %11, i32 0, i32 5
  %12 = load i32, i32* %chip_flag27, align 8, !tbaa !10
  %tobool28 = icmp ne i32 %12, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end21
  %ioaddr30 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %13 = load i64, i64* %ioaddr30, align 8, !tbaa !17
  call void @SET_MOXA_MUST_NO_SOFTWARE_FLOW_CONTROL(i64 %13)
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end21
  %slock32 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %14 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock32, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %14 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call3) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @tty_port_set_initialized(%struct.tty_port* %port, i1 zeroext %val) #2 {
entry:
  %frombool = zext i1 %val to i8
  %tobool = trunc i8 %frombool to i1
  %iflags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 11
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %iflags, i64 0, i64* %iflags) #7, !srcloc !153
  br label %if.end

if.else:                                          ; preds = %entry
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %iflags, i64 0, i64* %iflags) #7, !srcloc !154
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #3

declare void @tty_port_close_end(%struct.tty_port*, %struct.tty_struct*) #3

declare void @tty_port_tty_set(%struct.tty_port*, %struct.tty_struct*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #2 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #7, !srcloc !155
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #2 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #7, !srcloc !156
  ret i8 %0
}

declare i64 @schedule_timeout_interruptible(i64) #3

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #3 section ".spinlock.text"

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #3

declare void @free_pages(i64, i32) #3

; Function Attrs: nounwind uwtable
define internal void @SET_MOXA_MUST_NO_SOFTWARE_FLOW_CONTROL(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -16
  %conv7 = trunc i32 %and to i8
  %add8 = add i64 %baseio, 2
  %conv9 = trunc i64 %add8 to i32
  call void @outb(i8 zeroext %conv7, i32 %conv9)
  %add10 = add i64 %baseio, 3
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #3 section ".spinlock.text"

declare i8* @__memcpy(i8*, i8*, i64) #3

; Function Attrs: nounwind uwtable
define internal i32 @mxser_ioctl_special(i8* %argp) #4 {
entry:
  br label %if.end

if.end:                                           ; preds = %entry
  %0 = load i32, i32* @ttymajor, align 4, !tbaa !51
  %1 = bitcast i8* %argp to i32*
  %2 = call i32 @"simpll__inlineasm$0"(i32 %0, i32* %1)
  %conv = sext i32 %2 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv3 = trunc i64 %expval to i32
  br label %cleanup251

for.body9:                                        ; preds = %for.body9
  br label %for.body9

for.inc239:                                       ; preds = %for.inc239
  br label %for.inc239

cleanup251:                                       ; preds = %if.end
  ret i32 %conv3
}

declare void @__might_fault(i8*, i32) #3

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @tty_io_error(%struct.tty_struct* %tty) #2 {
entry:
  %flags = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %0 = load volatile i64, i64* %flags, align 8, !tbaa !66
  %and1.i = and i64 2, %0
  %cmp.i = icmp ne i64 %and1.i, 0
  ret i1 %cmp.i
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_get_serial_info(%struct.tty_struct* %tty, %struct.serial_struct* %retinfo) #4 {
entry:
  %tmp = alloca %struct.serial_struct, align 8
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %type = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 0
  %type1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %2 = load i32, i32* %type1, align 4, !tbaa !46
  store i32 %2, i32* %type, align 8, !tbaa !157
  %line = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 1
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %3 = load i32, i32* %index, align 8, !tbaa !54
  store i32 %3, i32* %line, align 4, !tbaa !159
  %port = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 2
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %4 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %conv = trunc i64 %4 to i32
  store i32 %conv, i32* %port, align 8, !tbaa !160
  %irq = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 3
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %5 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %irq2 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %5, i32 0, i32 1
  %6 = load i32, i32* %irq2, align 4, !tbaa !16
  store i32 %6, i32* %irq, align 4, !tbaa !161
  %flags = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 4
  %port3 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %flags4 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port3, i32 0, i32 10
  %7 = load i64, i64* %flags4, align 8, !tbaa !162
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, i32* %flags, align 8, !tbaa !163
  %xmit_fifo_size = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 5
  store i32 0, i32* %xmit_fifo_size, align 4, !tbaa !164
  %custom_divisor = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 6
  %custom_divisor6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 15
  %8 = load i32, i32* %custom_divisor6, align 8, !tbaa !47
  store i32 %8, i32* %custom_divisor, align 8, !tbaa !165
  %baud_base = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 7
  %baud_base7 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %9 = load i32, i32* %baud_base7, align 8, !tbaa !39
  store i32 %9, i32* %baud_base, align 4, !tbaa !166
  %close_delay = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 8
  %port8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %close_delay9 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port8, i32 0, i32 16
  %10 = load i32, i32* %close_delay9, align 8, !tbaa !48
  %conv10 = trunc i32 %10 to i16
  store i16 %conv10, i16* %close_delay, align 8, !tbaa !167
  %io_type = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 9
  store i8 0, i8* %io_type, align 2, !tbaa !168
  %reserved_char = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 10
  %11 = bitcast [1 x i8]* %reserved_char to i8*
  call void @llvm.memset.p0i8.i64(i8* %11, i8 0, i64 1, i32 1, i1 false)
  %hub6 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 11
  store i32 0, i32* %hub6, align 4, !tbaa !169
  %closing_wait = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 12
  %port11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %closing_wait12 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port11, i32 0, i32 17
  %12 = load i32, i32* %closing_wait12, align 4, !tbaa !49
  %conv13 = trunc i32 %12 to i16
  store i16 %conv13, i16* %closing_wait, align 8, !tbaa !170
  %closing_wait2 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 13
  store i16 0, i16* %closing_wait2, align 2, !tbaa !171
  %iomem_base = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 14
  store i8* null, i8** %iomem_base, align 8, !tbaa !172
  %iomem_reg_shift = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 15
  store i16 0, i16* %iomem_reg_shift, align 8, !tbaa !173
  %port_high = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 16
  store i32 0, i32* %port_high, align 4, !tbaa !174
  %iomap_base = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 17
  store i64 0, i64* %iomap_base, align 8, !tbaa !175
  %13 = bitcast %struct.serial_struct* %retinfo to i8*
  %14 = bitcast %struct.serial_struct* %tmp to i8*
  %15 = call i64 @llvm.objectsize.i64.p0i8(i8* %14, i1 false, i1 true) #7
  %conv.i = trunc i64 %15 to i32
  call void @kasan_check_read(i8* %14, i32 72) #7
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.10, i32 0, i32 0), i32 718) #7
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 72
  %16 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %16 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #7
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %entry
  call void @__check_object_size(i8* %14, i64 72, i1 zeroext true) #7
  %call.i = call i64 @_copy_to_user(i8* %13, i8* %14, i32 72) #7
  br label %copy_to_user.exit

if.else.i:                                        ; preds = %entry
  call void @copy_user_overflow(i32 %conv.i, i64 72) #7
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 72, %if.else.i ]
  %tobool = icmp ne i64 %n.addr.0.i, 0
  %. = select i1 %tobool, i32 -14, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_set_serial_info(%struct.tty_struct* %tty, %struct.serial_struct* %new_info) #4 {
entry:
  %new_serial = alloca %struct.serial_struct, align 8
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %port1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %tobool = icmp ne %struct.serial_struct* %new_info, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %tobool3 = icmp ne i64 %2, 0
  br i1 %tobool3, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %3 = bitcast %struct.serial_struct* %new_serial to i8*
  %4 = bitcast %struct.serial_struct* %new_info to i8*
  %5 = call i64 @llvm.objectsize.i64.p0i8(i8* %3, i1 false, i1 true) #7
  %conv.i = trunc i64 %5 to i32
  call void @__might_fault(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.10, i32 0, i32 0), i32 696) #7
  call void @kasan_check_write(i8* %3, i32 72) #7
  %cmp.i = icmp slt i32 %conv.i, 0
  %conv3.i = sext i32 %conv.i to i64
  %cmp4.i = icmp uge i64 %conv3.i, 72
  %6 = select i1 %cmp.i, i1 true, i1 %cmp4.i
  %lnot.ext.i = zext i1 %6 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  %expval.i = call i64 @llvm.expect.i64(i64 %conv7.i, i64 1) #7
  %tobool.i = icmp ne i64 %expval.i, 0
  br i1 %tobool.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.end
  call void @__check_object_size(i8* %3, i64 72, i1 zeroext false) #7
  %call.i = call i64 @_copy_from_user(i8* %3, i8* %4, i32 72) #7
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %if.end
  call void @copy_user_overflow(i32 %conv.i, i64 72) #7
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %n.addr.0.i = phi i64 [ %call.i, %if.then.i ], [ 72, %if.else.i ]
  %tobool4 = icmp ne i64 %n.addr.0.i, 0
  br i1 %tobool4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %copy_from_user.exit
  %irq = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 3
  %7 = load i32, i32* %irq, align 4, !tbaa !161
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %8 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %irq7 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %8, i32 0, i32 1
  %9 = load i32, i32* %irq7, align 4, !tbaa !16
  %cmp = icmp ne i32 %7, %9
  br i1 %cmp, label %cleanup, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %if.end6
  %port9 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 2
  %10 = load i32, i32* %port9, align 8, !tbaa !160
  %conv = zext i32 %10 to i64
  %ioaddr10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %11 = load i64, i64* %ioaddr10, align 8, !tbaa !17
  %cmp11 = icmp ne i64 %conv, %11
  br i1 %cmp11, label %cleanup, label %if.end14

if.end14:                                         ; preds = %lor.lhs.false8
  %flags15 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %12 = load i64, i64* %flags15, align 8, !tbaa !176
  %and = and i64 %12, 4144
  %conv16 = trunc i64 %and to i32
  %call17 = call zeroext i1 @capable(i32 21)
  br i1 %call17, label %if.else, label %if.then18

if.then18:                                        ; preds = %if.end14
  %baud_base = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 7
  %13 = load i32, i32* %baud_base, align 4, !tbaa !166
  %baud_base19 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %14 = load i32, i32* %baud_base19, align 8, !tbaa !39
  %cmp20 = icmp ne i32 %13, %14
  br i1 %cmp20, label %cleanup, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %if.then18
  %close_delay = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 8
  %15 = load i16, i16* %close_delay, align 8, !tbaa !167
  %conv23 = zext i16 %15 to i32
  %port24 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %close_delay25 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port24, i32 0, i32 16
  %16 = load i32, i32* %close_delay25, align 8, !tbaa !48
  %cmp26 = icmp ne i32 %conv23, %16
  br i1 %cmp26, label %cleanup, label %lor.lhs.false28

lor.lhs.false28:                                  ; preds = %lor.lhs.false22
  %flags29 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 4
  %17 = load i32, i32* %flags29, align 8, !tbaa !163
  %and30 = and i32 %17, -13361
  %conv31 = zext i32 %and30 to i64
  %port32 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %flags33 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port32, i32 0, i32 10
  %18 = load i64, i64* %flags33, align 8, !tbaa !162
  %and34 = and i64 %18, 4294953935
  %cmp35 = icmp ne i64 %conv31, %and34
  br i1 %cmp35, label %cleanup, label %if.end38

if.end38:                                         ; preds = %lor.lhs.false28
  %port39 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %flags40 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port39, i32 0, i32 10
  %19 = load i64, i64* %flags40, align 8, !tbaa !162
  %and41 = and i64 %19, 4294953935
  %flags42 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 4
  %20 = load i32, i32* %flags42, align 8, !tbaa !163
  %and43 = and i32 %20, 13360
  %conv44 = zext i32 %and43 to i64
  %or = or i64 %and41, %conv44
  %port45 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %flags46 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port45, i32 0, i32 10
  store i64 %or, i64* %flags46, align 8, !tbaa !162
  br label %if.end87

if.else:                                          ; preds = %if.end14
  %flags47 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %21 = load i64, i64* %flags47, align 8, !tbaa !176
  %and48 = and i64 %21, 4294836224
  %flags49 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 4
  %22 = load i32, i32* %flags49, align 8, !tbaa !163
  %and50 = and i32 %22, 131071
  %conv51 = zext i32 %and50 to i64
  %or52 = or i64 %and48, %conv51
  %flags53 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  store i64 %or52, i64* %flags53, align 8, !tbaa !176
  %close_delay54 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 8
  %23 = load i16, i16* %close_delay54, align 8, !tbaa !167
  %conv55 = zext i16 %23 to i32
  %mul = mul nsw i32 %conv55, 250
  %div = sdiv i32 %mul, 100
  %close_delay56 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 16
  store i32 %div, i32* %close_delay56, align 8, !tbaa !177
  %closing_wait = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 12
  %24 = load i16, i16* %closing_wait, align 8, !tbaa !170
  %conv57 = zext i16 %24 to i32
  %mul58 = mul nsw i32 %conv57, 250
  %div59 = sdiv i32 %mul58, 100
  %closing_wait60 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 17
  store i32 %div59, i32* %closing_wait60, align 4, !tbaa !178
  %flags61 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %25 = load i64, i64* %flags61, align 8, !tbaa !176
  %and62 = and i64 %25, 8192
  %tobool63 = icmp ne i64 %and62, 0
  %cond = select i1 %tobool63, i32 1, i32 0
  %conv64 = trunc i32 %cond to i8
  %low_latency = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 12
  %bf.load = load i8, i8* %low_latency, align 8
  %bf.value = and i8 %conv64, 1
  %bf.shl = shl i8 %bf.value, 1
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, i8* %low_latency, align 8
  %flags65 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %26 = load i64, i64* %flags65, align 8, !tbaa !176
  %and66 = and i64 %26, 4144
  %cmp67 = icmp eq i64 %and66, 48
  br i1 %cmp67, label %land.lhs.true, label %if.end87

land.lhs.true:                                    ; preds = %if.else
  %baud_base69 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 7
  %27 = load i32, i32* %baud_base69, align 4, !tbaa !166
  %baud_base70 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %28 = load i32, i32* %baud_base70, align 8, !tbaa !39
  %cmp71 = icmp ne i32 %27, %28
  br i1 %cmp71, label %if.then77, label %lor.lhs.false73

lor.lhs.false73:                                  ; preds = %land.lhs.true
  %custom_divisor = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 6
  %29 = load i32, i32* %custom_divisor, align 8, !tbaa !165
  %custom_divisor74 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 15
  %30 = load i32, i32* %custom_divisor74, align 8, !tbaa !47
  %cmp75 = icmp ne i32 %29, %30
  br i1 %cmp75, label %if.then77, label %if.end87

if.then77:                                        ; preds = %lor.lhs.false73, %land.lhs.true
  %custom_divisor78 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 6
  %31 = load i32, i32* %custom_divisor78, align 8, !tbaa !165
  %cmp79 = icmp eq i32 %31, 0
  br i1 %cmp79, label %cleanup, label %if.end82

if.end82:                                         ; preds = %if.then77
  %baud_base83 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 7
  %32 = load i32, i32* %baud_base83, align 4, !tbaa !166
  %custom_divisor84 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 6
  %33 = load i32, i32* %custom_divisor84, align 8, !tbaa !165
  %div85 = sdiv i32 %32, %33
  call void @tty_encode_baud_rate(%struct.tty_struct* %tty, i32 %div85, i32 %div85)
  br label %if.end87

if.end87:                                         ; preds = %if.end82, %lor.lhs.false73, %if.else, %if.end38
  %type = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 0
  %34 = load i32, i32* %type, align 8, !tbaa !157
  %type88 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  store i32 %34, i32* %type88, align 4, !tbaa !46
  call void @process_txrx_fifo(%struct.mxser_port* %1)
  %call89 = call zeroext i1 @tty_port_initialized(%struct.tty_port* %port1)
  br i1 %call89, label %if.then90, label %if.else107

if.then90:                                        ; preds = %if.end87
  %conv91 = zext i32 %conv16 to i64
  %flags92 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %35 = load i64, i64* %flags92, align 8, !tbaa !176
  %and93 = and i64 %35, 4144
  %cmp94 = icmp ne i64 %conv91, %and93
  br i1 %cmp94, label %do.body97, label %cleanup

do.body97:                                        ; preds = %if.then90
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %36 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %36 to %struct.raw_spinlock*
  %call101 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  call void @mxser_change_speed(%struct.tty_struct* %tty)
  %slock105 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %37 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock105, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %37 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call101) #7
  br label %cleanup

if.else107:                                       ; preds = %if.end87
  %call108 = call i32 @mxser_activate(%struct.tty_port* %port1, %struct.tty_struct* %tty)
  %cmp109 = icmp eq i32 %call108, 0
  br i1 %cmp109, label %if.then111, label %cleanup

if.then111:                                       ; preds = %if.else107
  call void @tty_port_set_initialized(%struct.tty_port* %port1, i1 zeroext true)
  br label %cleanup

cleanup:                                          ; preds = %if.then111, %if.else107, %do.body97, %if.then90, %if.then77, %lor.lhs.false28, %lor.lhs.false22, %if.then18, %lor.lhs.false8, %if.end6, %copy_from_user.exit, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ -19, %lor.lhs.false ], [ -19, %entry ], [ -14, %copy_from_user.exit ], [ -22, %lor.lhs.false8 ], [ -22, %if.end6 ], [ -1, %lor.lhs.false28 ], [ -1, %lor.lhs.false22 ], [ -1, %if.then18 ], [ -22, %if.then77 ], [ 0, %do.body97 ], [ 0, %if.then90 ], [ %call108, %if.then111 ], [ %call108, %if.else107 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_get_lsr_info(%struct.mxser_port* %info, i32* %value) #4 {
entry:
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 28
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %1 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %1, 5
  %conv5 = trunc i64 %add to i32
  %call6 = call zeroext i8 @inb(i32 %conv5)
  %slock7 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 28
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock7, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #7
  %conv8 = zext i8 %call6 to i32
  %and = and i32 %conv8, 64
  %tobool = icmp ne i32 %and, 0
  %cond = select i1 %tobool, i32 1, i32 0
  call void @__might_fault(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.7, i32 0, i32 0), i32 1317)
  %3 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %cond, i32* %value) #7, !srcloc !179
  %conv10 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %conv11 = trunc i64 %expval to i32
  ret i32 %conv11
}

declare void @__might_sleep(i8*, i32, i32) #3

; Function Attrs: nounwind uwtable
define internal i32 @mxser_cflags_changed(%struct.mxser_port* %info, i64 %arg, %struct.async_icount* %cprev) #4 {
entry:
  %cnow = alloca %struct.async_icount, align 4
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 28
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %icount = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 17
  %1 = bitcast %struct.async_icount* %cnow to i8*
  %2 = bitcast %struct.async_icount* %icount to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 44, i32 4, i1 false), !tbaa.struct !73
  %slock5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 28
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock5, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %3 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call2) #7
  %and = and i64 %arg, 128
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %rng = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 2
  %4 = load i32, i32* %rng, align 4, !tbaa !149
  %rng6 = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cprev, i32 0, i32 2
  %5 = load i32, i32* %rng6, align 4, !tbaa !149
  %cmp7 = icmp ne i32 %4, %5
  br i1 %cmp7, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %and9 = and i64 %arg, 256
  %tobool10 = icmp ne i64 %and9, 0
  br i1 %tobool10, label %land.lhs.true11, label %lor.lhs.false15

land.lhs.true11:                                  ; preds = %lor.lhs.false
  %dsr = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 1
  %6 = load i32, i32* %dsr, align 4, !tbaa !147
  %dsr12 = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cprev, i32 0, i32 1
  %7 = load i32, i32* %dsr12, align 4, !tbaa !147
  %cmp13 = icmp ne i32 %6, %7
  br i1 %cmp13, label %lor.end, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %land.lhs.true11, %lor.lhs.false
  %and16 = and i64 %arg, 64
  %tobool17 = icmp ne i64 %and16, 0
  br i1 %tobool17, label %land.lhs.true18, label %lor.rhs

land.lhs.true18:                                  ; preds = %lor.lhs.false15
  %dcd = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 3
  %8 = load i32, i32* %dcd, align 4, !tbaa !151
  %dcd19 = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cprev, i32 0, i32 3
  %9 = load i32, i32* %dcd19, align 4, !tbaa !151
  %cmp20 = icmp ne i32 %8, %9
  br i1 %cmp20, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true18, %lor.lhs.false15
  %and22 = and i64 %arg, 32
  %tobool23 = icmp ne i64 %and22, 0
  br i1 %tobool23, label %land.rhs, label %lor.end

land.rhs:                                         ; preds = %lor.rhs
  %cts = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 0
  %10 = load i32, i32* %cts, align 4, !tbaa !145
  %cts24 = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cprev, i32 0, i32 0
  %11 = load i32, i32* %cts24, align 4, !tbaa !145
  %cmp25 = icmp ne i32 %10, %11
  br label %lor.end

lor.end:                                          ; preds = %land.rhs, %lor.rhs, %land.lhs.true18, %land.lhs.true11, %land.lhs.true
  %12 = phi i1 [ true, %land.lhs.true18 ], [ true, %land.lhs.true11 ], [ true, %land.lhs.true ], [ false, %lor.rhs ], [ %cmp25, %land.rhs ]
  %lor.ext = zext i1 %12 to i32
  %13 = bitcast %struct.async_icount* %cprev to i8*
  %14 = bitcast %struct.async_icount* %cnow to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 44, i32 4, i1 false), !tbaa.struct !73
  ret i32 %lor.ext
}

declare void @init_wait_entry(%struct.__wait_queue*, i32) #3

declare i64 @prepare_to_wait_event(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #3

declare void @schedule() #3

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #3

; Function Attrs: nounwind uwtable
define internal zeroext i8 @mxser_get_msr(i32 %baseaddr, i32 %mode, i32 %port) #4 {
entry:
  %add = add nsw i32 %baseaddr, 6
  %call = call zeroext i8 @inb(i32 %add)
  %idxprom = sext i32 %port to i64
  %arrayidx = getelementptr inbounds [33 x i8], [33 x i8]* @mxser_get_msr.mxser_msr, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !52
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %arrayidx, align 1, !tbaa !52
  %conv2 = zext i8 %call to i32
  %idxprom3 = sext i32 %port to i64
  %arrayidx4 = getelementptr inbounds [33 x i8], [33 x i8]* @mxser_get_msr.mxser_msr, i64 0, i64 %idxprom3
  %1 = load i8, i8* %arrayidx4, align 1, !tbaa !52
  %conv5 = zext i8 %1 to i32
  %or = or i32 %conv5, %conv2
  %conv6 = trunc i32 %or to i8
  store i8 %conv6, i8* %arrayidx4, align 1, !tbaa !52
  %idxprom7 = sext i32 %port to i64
  %arrayidx8 = getelementptr inbounds [33 x i8], [33 x i8]* @mxser_get_msr.mxser_msr, i64 0, i64 %idxprom7
  %2 = load i8, i8* %arrayidx8, align 1, !tbaa !52
  %tobool = icmp ne i32 %mode, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %idxprom9 = sext i32 %port to i64
  %arrayidx10 = getelementptr inbounds [33 x i8], [33 x i8]* @mxser_get_msr.mxser_msr, i64 0, i64 %idxprom9
  store i8 0, i8* %arrayidx10, align 1, !tbaa !52
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i8 %2
}

; Function Attrs: nounwind uwtable
define internal void @mxser_check_modem_status(%struct.tty_struct* %tty, %struct.mxser_port* %port, i32 %status) #4 {
entry:
  %and = and i32 %status, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %icount = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %rng = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount, i32 0, i32 2
  %0 = load i32, i32* %rng, align 8, !tbaa !180
  %inc = add i32 %0, 1
  store i32 %inc, i32* %rng, align 8, !tbaa !180
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %and1 = and i32 %status, 2
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %icount4 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %dsr = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount4, i32 0, i32 1
  %1 = load i32, i32* %dsr, align 4, !tbaa !181
  %inc5 = add i32 %1, 1
  store i32 %inc5, i32* %dsr, align 4, !tbaa !181
  br label %if.end6

if.end6:                                          ; preds = %if.then3, %if.end
  %and7 = and i32 %status, 8
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end6
  %icount10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %dcd = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount10, i32 0, i32 3
  %2 = load i32, i32* %dcd, align 4, !tbaa !182
  %inc11 = add i32 %2, 1
  store i32 %inc11, i32* %dcd, align 4, !tbaa !182
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end6
  %and13 = and i32 %status, 1
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then15, label %if.end18

if.then15:                                        ; preds = %if.end12
  %icount16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %cts = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount16, i32 0, i32 0
  %3 = load i32, i32* %cts, align 8, !tbaa !183
  %inc17 = add i32 %3, 1
  store i32 %inc17, i32* %cts, align 8, !tbaa !183
  br label %if.end18

if.end18:                                         ; preds = %if.then15, %if.end12
  %mon_data = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 27
  %modem_status = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data, i32 0, i32 4
  store i32 %status, i32* %modem_status, align 8, !tbaa !184
  %port19 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %delta_msr_wait = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port19, i32 0, i32 9
  call void @__wake_up(%struct.__wait_queue_head* %delta_msr_wait, i32 1, i32 1, i8* null)
  %port20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %call = call zeroext i1 @tty_port_check_carrier(%struct.tty_port* %port20)
  %and21 = and i32 %status, 8
  %tobool22 = icmp ne i32 %and21, 0
  %or.cond = and i1 %call, %tobool22
  %and24 = and i32 %status, 128
  %tobool25 = icmp ne i32 %and24, 0
  %or.cond1 = and i1 %or.cond, %tobool25
  br i1 %or.cond1, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end18
  %port27 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %open_wait = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port27, i32 0, i32 8
  call void @__wake_up(%struct.__wait_queue_head* %open_wait, i32 1, i32 1, i8* null)
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end18
  %port30 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %call31 = call zeroext i1 @tty_port_cts_enabled(%struct.tty_port* %port30)
  br i1 %call31, label %if.then32, label %if.end74

if.then32:                                        ; preds = %if.end29
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  %4 = load i32, i32* %hw_stopped, align 8, !tbaa !68
  %tobool33 = icmp ne i32 %4, 0
  %and35 = and i32 %status, 16
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.then32
  br i1 %tobool36, label %if.then37, label %if.end74

if.then37:                                        ; preds = %if.then34
  %hw_stopped38 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  store i32 0, i32* %hw_stopped38, align 8, !tbaa !68
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 9
  %5 = load i32, i32* %type, align 4, !tbaa !46
  %cmp = icmp ne i32 %5, 4
  br i1 %cmp, label %land.lhs.true39, label %if.end50

land.lhs.true39:                                  ; preds = %if.then37
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %6 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %6, i32 0, i32 5
  %7 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool40 = icmp ne i32 %7, 0
  br i1 %tobool40, label %if.end50, label %if.then41

if.then41:                                        ; preds = %land.lhs.true39
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %8 = load i32, i32* %IER, align 4, !tbaa !69
  %and42 = and i32 %8, -3
  %conv = trunc i32 %and42 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %9 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %9, 1
  %conv43 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv, i32 %conv43)
  %IER44 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %10 = load i32, i32* %IER44, align 4, !tbaa !69
  %or = or i32 %10, 2
  store i32 %or, i32* %IER44, align 4, !tbaa !69
  %IER45 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %11 = load i32, i32* %IER45, align 4, !tbaa !69
  %conv46 = trunc i32 %11 to i8
  %ioaddr47 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %12 = load i64, i64* %ioaddr47, align 8, !tbaa !17
  %add48 = add i64 %12, 1
  %conv49 = trunc i64 %add48 to i32
  call void @outb(i8 zeroext %conv46, i32 %conv49)
  br label %if.end50

if.end50:                                         ; preds = %if.then41, %land.lhs.true39, %if.then37
  call void @tty_wakeup(%struct.tty_struct* %tty)
  br label %if.end74

if.else:                                          ; preds = %if.then32
  br i1 %tobool36, label %if.end74, label %if.then54

if.then54:                                        ; preds = %if.else
  %hw_stopped55 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  store i32 1, i32* %hw_stopped55, align 8, !tbaa !68
  %type56 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 9
  %13 = load i32, i32* %type56, align 4, !tbaa !46
  %cmp57 = icmp ne i32 %13, 4
  br i1 %cmp57, label %land.lhs.true59, label %if.end74

land.lhs.true59:                                  ; preds = %if.then54
  %board60 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %14 = load %struct.mxser_board*, %struct.mxser_board** %board60, align 8, !tbaa !43
  %chip_flag61 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %14, i32 0, i32 5
  %15 = load i32, i32* %chip_flag61, align 8, !tbaa !10
  %tobool62 = icmp ne i32 %15, 0
  br i1 %tobool62, label %if.end74, label %if.then63

if.then63:                                        ; preds = %land.lhs.true59
  %IER64 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %16 = load i32, i32* %IER64, align 4, !tbaa !69
  %and65 = and i32 %16, -3
  store i32 %and65, i32* %IER64, align 4, !tbaa !69
  %IER66 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %17 = load i32, i32* %IER66, align 4, !tbaa !69
  %conv67 = trunc i32 %17 to i8
  %ioaddr68 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %18 = load i64, i64* %ioaddr68, align 8, !tbaa !17
  %add69 = add i64 %18, 1
  %conv70 = trunc i64 %add69 to i32
  call void @outb(i8 zeroext %conv67, i32 %conv70)
  br label %if.end74

if.end74:                                         ; preds = %if.then63, %land.lhs.true59, %if.then54, %if.else, %if.end50, %if.then34, %if.end29
  ret void
}

declare i32 @___ratelimit(%struct.ratelimit_state*, i8*) #3

declare i8* @__memset(i8*, i32, i64) #3

declare %struct.tty_struct* @tty_port_tty_get(%struct.tty_port*) #3

declare void @tty_kref_put(%struct.tty_struct*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @kzalloc(i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call noalias i8* @__kmalloc(i64 %size, i32 %or) #7
  ret void
}

declare i32 @tty_termios_baud_rate(%struct.ktermios*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @tty_get_baud_rate(%struct.tty_struct* %tty) #2 {
entry:
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %call = call i32 @tty_termios_baud_rate(%struct.ktermios* %termios)
  ret i32 %call
}

declare void @kfree(i8*) #3

declare noalias i8* @__kmalloc(i64, i32) #3

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #3 section ".spinlock.text"

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #1

declare zeroext i1 @capable(i32) #3

declare void @tty_encode_baud_rate(%struct.tty_struct*, i32, i32) #3

; Function Attrs: nounwind uwtable
define internal void @process_txrx_fifo(%struct.mxser_port* %info) #4 {
entry:
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 9
  %0 = load i32, i32* %type, align 4, !tbaa !46
  %cmp = icmp eq i32 %0, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %type1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 9
  %1 = load i32, i32* %type1, align 4, !tbaa !46
  %cmp2 = icmp eq i32 %1, 1
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %rx_trigger = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 6
  store i32 1, i32* %rx_trigger, align 8, !tbaa !185
  %rx_high_water = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 5
  store i32 1, i32* %rx_high_water, align 4, !tbaa !186
  %rx_low_water = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 7
  store i32 1, i32* %rx_low_water, align 4, !tbaa !187
  br label %if.end25.sink.split

if.else:                                          ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %i.0 = phi i32 [ 0, %if.else ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp3 = icmp ult i64 %conv, 3
  br i1 %cmp3, label %for.body, label %if.end25

for.body:                                         ; preds = %for.cond
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 1
  %2 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %2, i32 0, i32 5
  %3 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.anon.60], [3 x %struct.anon.60]* @Gpci_uart_info, i64 0, i64 %idxprom
  %type5 = getelementptr inbounds %struct.anon.60, %struct.anon.60* %arrayidx, i32 0, i32 0
  %4 = load i32, i32* %type5, align 8, !tbaa !188
  %cmp6 = icmp eq i32 %3, %4
  br i1 %cmp6, label %if.then8, label %for.inc

if.then8:                                         ; preds = %for.body
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [3 x %struct.anon.60], [3 x %struct.anon.60]* @Gpci_uart_info, i64 0, i64 %idxprom9
  %rx_trigger11 = getelementptr inbounds %struct.anon.60, %struct.anon.60* %arrayidx10, i32 0, i32 5
  %5 = load i32, i32* %rx_trigger11, align 4, !tbaa !190
  %rx_trigger12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 6
  store i32 %5, i32* %rx_trigger12, align 8, !tbaa !185
  %idxprom13 = sext i32 %i.0 to i64
  %arrayidx14 = getelementptr inbounds [3 x %struct.anon.60], [3 x %struct.anon.60]* @Gpci_uart_info, i64 0, i64 %idxprom13
  %rx_low_water15 = getelementptr inbounds %struct.anon.60, %struct.anon.60* %arrayidx14, i32 0, i32 6
  %6 = load i32, i32* %rx_low_water15, align 8, !tbaa !191
  %rx_low_water16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 7
  store i32 %6, i32* %rx_low_water16, align 4, !tbaa !187
  %idxprom17 = sext i32 %i.0 to i64
  %arrayidx18 = getelementptr inbounds [3 x %struct.anon.60], [3 x %struct.anon.60]* @Gpci_uart_info, i64 0, i64 %idxprom17
  %rx_high_water19 = getelementptr inbounds %struct.anon.60, %struct.anon.60* %arrayidx18, i32 0, i32 4
  %7 = load i32, i32* %rx_high_water19, align 8, !tbaa !192
  %rx_high_water20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 5
  store i32 %7, i32* %rx_high_water20, align 4, !tbaa !186
  %idxprom21 = sext i32 %i.0 to i64
  %arrayidx22 = getelementptr inbounds [3 x %struct.anon.60], [3 x %struct.anon.60]* @Gpci_uart_info, i64 0, i64 %idxprom21
  %xmit_fifo_size23 = getelementptr inbounds %struct.anon.60, %struct.anon.60* %arrayidx22, i32 0, i32 3
  %8 = load i32, i32* %xmit_fifo_size23, align 4, !tbaa !193
  br label %if.end25.sink.split

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end25.sink.split:                              ; preds = %if.then8, %if.then
  %.sink = phi i32 [ %8, %if.then8 ], [ 1, %if.then ]
  %xmit_fifo_size24 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 21
  store i32 %.sink, i32* %xmit_fifo_size24, align 8, !tbaa !88
  br label %if.end25

if.end25:                                         ; preds = %if.end25.sink.split, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_change_speed(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 2
  %2 = load i32, i32* %c_cflag, align 8, !tbaa !63
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %3 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %4 = load i32, i32* %index, align 8, !tbaa !54
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [33 x i32], [33 x i32]* @mxser_set_baud_method, i64 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !51
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %call = call i32 @tty_get_baud_rate(%struct.tty_struct* %tty)
  %conv = zext i32 %call to i64
  call void @mxser_set_baud(%struct.tty_struct* %tty, i64 %conv)
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  %and = and i32 %2, 48
  %Pivot10 = icmp slt i32 %and, 32
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %if.end3
  %Pivot8 = icmp slt i32 %and, 48
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %and, 48
  br i1 %SwitchLeaf6, label %sw.epilog, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %and, 32
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

NodeBlock:                                        ; preds = %if.end3
  %Pivot = icmp slt i32 %and, 16
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 16
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %and, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %cval.0 = phi i32 [ 0, %sw.default ], [ 0, %LeafBlock ], [ 1, %LeafBlock1 ], [ 2, %LeafBlock3 ], [ 3, %LeafBlock5 ]
  %and7 = and i32 %2, 64
  %tobool8 = icmp ne i32 %and7, 0
  %or = or i32 %cval.0, 4
  %or.cval.0 = select i1 %tobool8, i32 %or, i32 %cval.0
  %and11 = and i32 %2, 256
  %tobool12 = icmp ne i32 %and11, 0
  %or14 = or i32 %or.cval.0, 8
  %cval.2 = select i1 %tobool12, i32 %or14, i32 %or.cval.0
  %and16 = and i32 %2, 512
  %tobool17 = icmp ne i32 %and16, 0
  %or19 = or i32 %cval.2, 16
  %cval.2.or19 = select i1 %tobool17, i32 %cval.2, i32 %or19
  %and21 = and i32 %2, 1073741824
  %tobool22 = icmp ne i32 %and21, 0
  %or24 = or i32 %cval.2.or19, 32
  %cval.4 = select i1 %tobool22, i32 %or24, i32 %cval.2.or19
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %6 = load i32, i32* %type, align 4, !tbaa !46
  %cmp26 = icmp eq i32 %6, 1
  br i1 %cmp26, label %if.then31, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %type28 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %7 = load i32, i32* %type28, align 4, !tbaa !46
  %cmp29 = icmp eq i32 %7, 2
  br i1 %cmp29, label %if.then31, label %if.else36

if.then31:                                        ; preds = %lor.lhs.false, %sw.epilog
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %8 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %8, i32 0, i32 5
  %9 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool32 = icmp ne i32 %9, 0
  br i1 %tobool32, label %if.then33, label %if.end52

if.then33:                                        ; preds = %if.then31
  %or34 = or i32 1, 32
  call void @mxser_set_must_fifo_value(%struct.mxser_port* %1)
  br label %if.end52

if.else36:                                        ; preds = %lor.lhs.false
  %board37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %10 = load %struct.mxser_board*, %struct.mxser_board** %board37, align 8, !tbaa !43
  %chip_flag38 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %10, i32 0, i32 5
  %11 = load i32, i32* %chip_flag38, align 8, !tbaa !10
  %tobool39 = icmp ne i32 %11, 0
  br i1 %tobool39, label %if.then40, label %if.else42

if.then40:                                        ; preds = %if.else36
  %or41 = or i32 1, 32
  call void @mxser_set_must_fifo_value(%struct.mxser_port* %1)
  br label %if.end52

if.else42:                                        ; preds = %if.else36
  %rx_trigger = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 6
  %12 = load i32, i32* %rx_trigger, align 8, !tbaa !185
  %Pivot21 = icmp slt i32 %12, 4
  br i1 %Pivot21, label %LeafBlock12, label %NodeBlock18

NodeBlock18:                                      ; preds = %if.else42
  %Pivot19 = icmp slt i32 %12, 8
  br i1 %Pivot19, label %LeafBlock14, label %LeafBlock16

LeafBlock16:                                      ; preds = %NodeBlock18
  %SwitchLeaf17 = icmp eq i32 %12, 8
  br i1 %SwitchLeaf17, label %sw.bb46, label %sw.default48

LeafBlock14:                                      ; preds = %NodeBlock18
  %SwitchLeaf15 = icmp eq i32 %12, 4
  br i1 %SwitchLeaf15, label %sw.bb44, label %sw.default48

LeafBlock12:                                      ; preds = %if.else42
  %SwitchLeaf13 = icmp eq i32 %12, 1
  br i1 %SwitchLeaf13, label %if.end52, label %sw.default48

sw.bb44:                                          ; preds = %LeafBlock14
  %or45 = or i32 1, 64
  br label %if.end52

sw.bb46:                                          ; preds = %LeafBlock16
  %or47 = or i32 1, 128
  br label %if.end52

sw.default48:                                     ; preds = %LeafBlock12, %LeafBlock14, %LeafBlock16
  %or49 = or i32 1, 192
  br label %if.end52

if.end52:                                         ; preds = %sw.default48, %sw.bb46, %sw.bb44, %LeafBlock12, %if.then40, %if.then33, %if.then31
  %fcr.3 = phi i32 [ %or34, %if.then33 ], [ 0, %if.then31 ], [ %or41, %if.then40 ], [ %or49, %sw.default48 ], [ %or45, %sw.bb44 ], [ %or47, %sw.bb46 ], [ 1, %LeafBlock12 ]
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %13 = load i32, i32* %IER, align 4, !tbaa !69
  %and53 = and i32 %13, -9
  store i32 %and53, i32* %IER, align 4, !tbaa !69
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %14 = load i32, i32* %MCR, align 8, !tbaa !86
  %and54 = and i32 %14, -33
  store i32 %and54, i32* %MCR, align 8, !tbaa !86
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %and55 = and i32 %2, -2147483648
  %tobool56 = icmp ne i32 %and55, 0
  call void @tty_port_set_cts_flow(%struct.tty_port* %port, i1 zeroext %tobool56)
  %and57 = and i32 %2, -2147483648
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.then59, label %if.end130

if.then59:                                        ; preds = %if.end52
  %IER60 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %15 = load i32, i32* %IER60, align 4, !tbaa !69
  %or61 = or i32 %15, 8
  store i32 %or61, i32* %IER60, align 4, !tbaa !69
  %type62 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %16 = load i32, i32* %type62, align 4, !tbaa !46
  %cmp63 = icmp eq i32 %16, 4
  br i1 %cmp63, label %if.then69, label %lor.lhs.false65

lor.lhs.false65:                                  ; preds = %if.then59
  %board66 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %17 = load %struct.mxser_board*, %struct.mxser_board** %board66, align 8, !tbaa !43
  %chip_flag67 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %17, i32 0, i32 5
  %18 = load i32, i32* %chip_flag67, align 8, !tbaa !10
  %tobool68 = icmp ne i32 %18, 0
  br i1 %tobool68, label %if.then69, label %if.else72

if.then69:                                        ; preds = %lor.lhs.false65, %if.then59
  %MCR70 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %19 = load i32, i32* %MCR70, align 8, !tbaa !86
  %or71 = or i32 %19, 32
  store i32 %or71, i32* %MCR70, align 8, !tbaa !86
  br label %if.end130

if.else72:                                        ; preds = %lor.lhs.false65
  %ioaddr73 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %20 = load i64, i64* %ioaddr73, align 8, !tbaa !17
  %add = add i64 %20, 6
  %conv74 = trunc i64 %add to i32
  %call75 = call zeroext i8 @inb(i32 %conv74)
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  %21 = load i32, i32* %hw_stopped, align 8, !tbaa !68
  %tobool76 = icmp ne i32 %21, 0
  %conv78 = zext i8 %call75 to i32
  %and79 = and i32 %conv78, 16
  %tobool80 = icmp ne i32 %and79, 0
  br i1 %tobool76, label %if.then77, label %if.else105

if.then77:                                        ; preds = %if.else72
  br i1 %tobool80, label %if.then81, label %if.end130

if.then81:                                        ; preds = %if.then77
  %hw_stopped82 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  store i32 0, i32* %hw_stopped82, align 8, !tbaa !68
  %type83 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %22 = load i32, i32* %type83, align 4, !tbaa !46
  %cmp84 = icmp ne i32 %22, 4
  br i1 %cmp84, label %land.lhs.true, label %if.end103

land.lhs.true:                                    ; preds = %if.then81
  %board86 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %23 = load %struct.mxser_board*, %struct.mxser_board** %board86, align 8, !tbaa !43
  %chip_flag87 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %23, i32 0, i32 5
  %24 = load i32, i32* %chip_flag87, align 8, !tbaa !10
  %tobool88 = icmp ne i32 %24, 0
  br i1 %tobool88, label %if.end103, label %if.then89

if.then89:                                        ; preds = %land.lhs.true
  %IER90 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %25 = load i32, i32* %IER90, align 4, !tbaa !69
  %and91 = and i32 %25, -3
  %conv92 = trunc i32 %and91 to i8
  %ioaddr93 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %26 = load i64, i64* %ioaddr93, align 8, !tbaa !17
  %add94 = add i64 %26, 1
  %conv95 = trunc i64 %add94 to i32
  call void @outb(i8 zeroext %conv92, i32 %conv95)
  %IER96 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %27 = load i32, i32* %IER96, align 4, !tbaa !69
  %or97 = or i32 %27, 2
  store i32 %or97, i32* %IER96, align 4, !tbaa !69
  %IER98 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %28 = load i32, i32* %IER98, align 4, !tbaa !69
  %conv99 = trunc i32 %28 to i8
  %ioaddr100 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %29 = load i64, i64* %ioaddr100, align 8, !tbaa !17
  %add101 = add i64 %29, 1
  %conv102 = trunc i64 %add101 to i32
  call void @outb(i8 zeroext %conv99, i32 %conv102)
  br label %if.end103

if.end103:                                        ; preds = %if.then89, %land.lhs.true, %if.then81
  call void @tty_wakeup(%struct.tty_struct* %tty)
  br label %if.end130

if.else105:                                       ; preds = %if.else72
  br i1 %tobool80, label %if.end130, label %if.then109

if.then109:                                       ; preds = %if.else105
  %hw_stopped110 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  store i32 1, i32* %hw_stopped110, align 8, !tbaa !68
  %type111 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %30 = load i32, i32* %type111, align 4, !tbaa !46
  %cmp112 = icmp ne i32 %30, 4
  br i1 %cmp112, label %land.lhs.true114, label %if.end130

land.lhs.true114:                                 ; preds = %if.then109
  %board115 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %31 = load %struct.mxser_board*, %struct.mxser_board** %board115, align 8, !tbaa !43
  %chip_flag116 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %31, i32 0, i32 5
  %32 = load i32, i32* %chip_flag116, align 8, !tbaa !10
  %tobool117 = icmp ne i32 %32, 0
  br i1 %tobool117, label %if.end130, label %if.then118

if.then118:                                       ; preds = %land.lhs.true114
  %IER119 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %33 = load i32, i32* %IER119, align 4, !tbaa !69
  %and120 = and i32 %33, -3
  store i32 %and120, i32* %IER119, align 4, !tbaa !69
  %IER121 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %34 = load i32, i32* %IER121, align 4, !tbaa !69
  %conv122 = trunc i32 %34 to i8
  %ioaddr123 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %35 = load i64, i64* %ioaddr123, align 8, !tbaa !17
  %add124 = add i64 %35, 1
  %conv125 = trunc i64 %add124 to i32
  call void @outb(i8 zeroext %conv122, i32 %conv125)
  br label %if.end130

if.end130:                                        ; preds = %if.then118, %land.lhs.true114, %if.then109, %if.else105, %if.end103, %if.then77, %if.then69, %if.end52
  %MCR131 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %36 = load i32, i32* %MCR131, align 8, !tbaa !86
  %conv132 = trunc i32 %36 to i8
  %ioaddr133 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %37 = load i64, i64* %ioaddr133, align 8, !tbaa !17
  %add134 = add i64 %37, 4
  %conv135 = trunc i64 %add134 to i32
  call void @outb(i8 zeroext %conv132, i32 %conv135)
  %port136 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %neg = xor i32 %2, -1
  %and137 = and i32 %neg, 2048
  %tobool138 = icmp ne i32 %and137, 0
  call void @tty_port_set_check_carrier(%struct.tty_port* %port136, i1 zeroext %tobool138)
  %neg139 = xor i32 %2, -1
  %and140 = and i32 %neg139, 2048
  %tobool141 = icmp ne i32 %and140, 0
  br i1 %tobool141, label %if.then142, label %if.end145

if.then142:                                       ; preds = %if.end130
  %IER143 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %38 = load i32, i32* %IER143, align 4, !tbaa !69
  %or144 = or i32 %38, 8
  store i32 %or144, i32* %IER143, align 4, !tbaa !69
  br label %if.end145

if.end145:                                        ; preds = %if.then142, %if.end130
  %IER146 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %39 = load i32, i32* %IER146, align 4, !tbaa !69
  %conv147 = trunc i32 %39 to i8
  %ioaddr148 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %40 = load i64, i64* %ioaddr148, align 8, !tbaa !17
  %add149 = add i64 %40, 1
  %conv150 = trunc i64 %add149 to i32
  call void @outb(i8 zeroext %conv147, i32 %conv150)
  %read_status_mask = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 19
  store i32 35, i32* %read_status_mask, align 8, !tbaa !194
  %termios151 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_iflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios151, i32 0, i32 0
  %41 = load i32, i32* %c_iflag, align 8, !tbaa !84
  %and152 = and i32 %41, 16
  %tobool153 = icmp ne i32 %and152, 0
  br i1 %tobool153, label %if.then154, label %if.end157

if.then154:                                       ; preds = %if.end145
  %read_status_mask155 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 19
  %42 = load i32, i32* %read_status_mask155, align 8, !tbaa !194
  %or156 = or i32 %42, 12
  store i32 %or156, i32* %read_status_mask155, align 8, !tbaa !194
  br label %if.end157

if.end157:                                        ; preds = %if.then154, %if.end145
  %termios158 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_iflag159 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios158, i32 0, i32 0
  %43 = load i32, i32* %c_iflag159, align 8, !tbaa !84
  %and160 = and i32 %43, 2
  %tobool161 = icmp ne i32 %and160, 0
  br i1 %tobool161, label %if.then167, label %lor.lhs.false162

lor.lhs.false162:                                 ; preds = %if.end157
  %termios163 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_iflag164 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios163, i32 0, i32 0
  %44 = load i32, i32* %c_iflag164, align 8, !tbaa !84
  %and165 = and i32 %44, 8
  %tobool166 = icmp ne i32 %and165, 0
  br i1 %tobool166, label %if.then167, label %if.end170

if.then167:                                       ; preds = %lor.lhs.false162, %if.end157
  %read_status_mask168 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 19
  %45 = load i32, i32* %read_status_mask168, align 8, !tbaa !194
  %or169 = or i32 %45, 16
  store i32 %or169, i32* %read_status_mask168, align 8, !tbaa !194
  br label %if.end170

if.end170:                                        ; preds = %if.then167, %lor.lhs.false162
  %ignore_status_mask = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 20
  store i32 0, i32* %ignore_status_mask, align 4, !tbaa !195
  %termios171 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_iflag172 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios171, i32 0, i32 0
  %46 = load i32, i32* %c_iflag172, align 8, !tbaa !84
  %and173 = and i32 %46, 1
  %tobool174 = icmp ne i32 %and173, 0
  br i1 %tobool174, label %if.then175, label %if.end190

if.then175:                                       ; preds = %if.end170
  %ignore_status_mask176 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 20
  %47 = load i32, i32* %ignore_status_mask176, align 4, !tbaa !195
  %or177 = or i32 %47, 16
  store i32 %or177, i32* %ignore_status_mask176, align 4, !tbaa !195
  %read_status_mask178 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 19
  %48 = load i32, i32* %read_status_mask178, align 8, !tbaa !194
  %or179 = or i32 %48, 16
  store i32 %or179, i32* %read_status_mask178, align 8, !tbaa !194
  %termios180 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_iflag181 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios180, i32 0, i32 0
  %49 = load i32, i32* %c_iflag181, align 8, !tbaa !84
  %and182 = and i32 %49, 4
  %tobool183 = icmp ne i32 %and182, 0
  br i1 %tobool183, label %if.then184, label %if.end190

if.then184:                                       ; preds = %if.then175
  %ignore_status_mask185 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 20
  %50 = load i32, i32* %ignore_status_mask185, align 4, !tbaa !195
  %or186 = or i32 %50, 14
  store i32 %or186, i32* %ignore_status_mask185, align 4, !tbaa !195
  %read_status_mask187 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 19
  %51 = load i32, i32* %read_status_mask187, align 8, !tbaa !194
  %or188 = or i32 %51, 14
  store i32 %or188, i32* %read_status_mask187, align 8, !tbaa !194
  br label %if.end190

if.end190:                                        ; preds = %if.then184, %if.then175, %if.end170
  %board191 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %52 = load %struct.mxser_board*, %struct.mxser_board** %board191, align 8, !tbaa !43
  %chip_flag192 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %52, i32 0, i32 5
  %53 = load i32, i32* %chip_flag192, align 8, !tbaa !10
  %tobool193 = icmp ne i32 %53, 0
  br i1 %tobool193, label %if.then194, label %if.end220

if.then194:                                       ; preds = %if.end190
  %ioaddr195 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %54 = load i64, i64* %ioaddr195, align 8, !tbaa !17
  %termios196 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_cc = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios196, i32 0, i32 5
  %arrayidx197 = getelementptr inbounds [19 x i8], [19 x i8]* %c_cc, i64 0, i64 8
  %55 = load i8, i8* %arrayidx197, align 1, !tbaa !52
  call void @mxser_set_must_xon1_value(i64 %54, i8 zeroext %55)
  %ioaddr198 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %56 = load i64, i64* %ioaddr198, align 8, !tbaa !17
  %termios199 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_cc200 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios199, i32 0, i32 5
  %arrayidx201 = getelementptr inbounds [19 x i8], [19 x i8]* %c_cc200, i64 0, i64 9
  %57 = load i8, i8* %arrayidx201, align 1, !tbaa !52
  call void @mxser_set_must_xoff1_value(i64 %56, i8 zeroext %57)
  %termios202 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_iflag203 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios202, i32 0, i32 0
  %58 = load i32, i32* %c_iflag203, align 8, !tbaa !84
  %and204 = and i32 %58, 1024
  %tobool205 = icmp ne i32 %and204, 0
  %ioaddr207 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %59 = load i64, i64* %ioaddr207, align 8, !tbaa !17
  br i1 %tobool205, label %if.then206, label %if.else208

if.then206:                                       ; preds = %if.then194
  call void @mxser_enable_must_rx_software_flow_control(i64 %59)
  br label %if.end210

if.else208:                                       ; preds = %if.then194
  call void @mxser_disable_must_rx_software_flow_control(i64 %59)
  br label %if.end210

if.end210:                                        ; preds = %if.else208, %if.then206
  %termios211 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_iflag212 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios211, i32 0, i32 0
  %60 = load i32, i32* %c_iflag212, align 8, !tbaa !84
  %and213 = and i32 %60, 4096
  %tobool214 = icmp ne i32 %and213, 0
  %ioaddr216 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %61 = load i64, i64* %ioaddr216, align 8, !tbaa !17
  br i1 %tobool214, label %if.then215, label %if.else217

if.then215:                                       ; preds = %if.end210
  call void @mxser_enable_must_tx_software_flow_control(i64 %61)
  br label %if.end220

if.else217:                                       ; preds = %if.end210
  call void @mxser_disable_must_tx_software_flow_control(i64 %61)
  br label %if.end220

if.end220:                                        ; preds = %if.else217, %if.then215, %if.end190
  %conv221 = trunc i32 %fcr.3 to i8
  %ioaddr222 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %62 = load i64, i64* %ioaddr222, align 8, !tbaa !17
  %add223 = add i64 %62, 2
  %conv224 = trunc i64 %add223 to i32
  call void @outb(i8 zeroext %conv221, i32 %conv224)
  %conv225 = trunc i32 %cval.4 to i8
  %ioaddr226 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %63 = load i64, i64* %ioaddr226, align 8, !tbaa !17
  %add227 = add i64 %63, 3
  %conv228 = trunc i64 %add227 to i32
  call void @outb(i8 zeroext %conv225, i32 %conv228)
  br label %cleanup

cleanup:                                          ; preds = %if.end220, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_activate(%struct.tty_port* %port, %struct.tty_struct* %tty) #4 {
entry:
  %0 = bitcast %struct.tty_port* %port to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.mxser_port*
  %call = call i64 @__get_free_pages(i32 20971712, i32 0)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %do.body1, label %cleanup

do.body1:                                         ; preds = %entry
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call4 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %3 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %tobool7 = icmp ne i64 %3, 0
  br i1 %tobool7, label %lor.lhs.false, label %if.then9

lor.lhs.false:                                    ; preds = %do.body1
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %4 = load i32, i32* %type, align 4, !tbaa !46
  %tobool8 = icmp ne i32 %4, 0
  br i1 %tobool8, label %if.end12, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false, %do.body1
  %flags10 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags10, i64 1, i64* %flags10) #7, !srcloc !153
  call void @free_pages(i64 %call, i32 0)
  %slock11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock11, i32 0, i32 0
  %rlock.i7 = bitcast %union.anon.1* %5 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i7, i64 %call4) #7
  br label %cleanup

if.end12:                                         ; preds = %lor.lhs.false
  %6 = inttoptr i64 %call to i8*
  %port13 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port13, i32 0, i32 15
  store i8* %6, i8** %xmit_buf, align 8, !tbaa !64
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %7 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %7, i32 0, i32 5
  %8 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool14 = icmp ne i32 %8, 0
  %ioaddr16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr16, align 8, !tbaa !17
  %add = add i64 %9, 2
  %conv17 = trunc i64 %add to i32
  br i1 %tobool14, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end12
  call void @outb(i8 zeroext 38, i32 %conv17)
  br label %if.end21

if.else:                                          ; preds = %if.end12
  call void @outb(i8 zeroext 6, i32 %conv17)
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then15
  %ioaddr22 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %10 = load i64, i64* %ioaddr22, align 8, !tbaa !17
  %add23 = add i64 %10, 5
  %conv24 = trunc i64 %add23 to i32
  %call25 = call zeroext i8 @inb(i32 %conv24)
  %conv26 = zext i8 %call25 to i32
  %cmp27 = icmp eq i32 %conv26, 255
  br i1 %cmp27, label %if.then29, label %if.end35

if.then29:                                        ; preds = %if.end21
  %slock30 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock30, i32 0, i32 0
  %rlock.i4 = bitcast %union.anon.1* %11 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i4, i64 %call4) #7
  %call31 = call zeroext i1 @capable(i32 21)
  br i1 %call31, label %if.then32, label %cleanup

if.then32:                                        ; preds = %if.then29
  %flags33 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags33, i64 1, i64* %flags33) #7, !srcloc !153
  br label %cleanup

if.end35:                                         ; preds = %if.end21
  %ioaddr36 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %12 = load i64, i64* %ioaddr36, align 8, !tbaa !17
  %add37 = add i64 %12, 5
  %conv38 = trunc i64 %add37 to i32
  %call39 = call zeroext i8 @inb(i32 %conv38)
  %ioaddr40 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %13 = load i64, i64* %ioaddr40, align 8, !tbaa !17
  %add41 = add i64 %13, 0
  %conv42 = trunc i64 %add41 to i32
  %call43 = call zeroext i8 @inb(i32 %conv42)
  %ioaddr44 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %14 = load i64, i64* %ioaddr44, align 8, !tbaa !17
  %add45 = add i64 %14, 2
  %conv46 = trunc i64 %add45 to i32
  %call47 = call zeroext i8 @inb(i32 %conv46)
  %ioaddr48 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %15 = load i64, i64* %ioaddr48, align 8, !tbaa !17
  %add49 = add i64 %15, 6
  %conv50 = trunc i64 %add49 to i32
  %call51 = call zeroext i8 @inb(i32 %conv50)
  %ioaddr52 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %16 = load i64, i64* %ioaddr52, align 8, !tbaa !17
  %add53 = add i64 %16, 3
  %conv54 = trunc i64 %add53 to i32
  call void @outb(i8 zeroext 3, i32 %conv54)
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  store i32 3, i32* %MCR, align 8, !tbaa !86
  %MCR55 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %17 = load i32, i32* %MCR55, align 8, !tbaa !86
  %conv56 = trunc i32 %17 to i8
  %ioaddr57 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %18 = load i64, i64* %ioaddr57, align 8, !tbaa !17
  %add58 = add i64 %18, 4
  %conv59 = trunc i64 %add58 to i32
  call void @outb(i8 zeroext %conv56, i32 %conv59)
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  store i32 13, i32* %IER, align 4, !tbaa !69
  %board60 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %19 = load %struct.mxser_board*, %struct.mxser_board** %board60, align 8, !tbaa !43
  %chip_flag61 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %19, i32 0, i32 5
  %20 = load i32, i32* %chip_flag61, align 8, !tbaa !10
  %tobool62 = icmp ne i32 %20, 0
  br i1 %tobool62, label %if.then63, label %if.end65

if.then63:                                        ; preds = %if.end35
  %IER64 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %21 = load i32, i32* %IER64, align 4, !tbaa !69
  %or = or i32 %21, 16
  store i32 %or, i32* %IER64, align 4, !tbaa !69
  br label %if.end65

if.end65:                                         ; preds = %if.then63, %if.end35
  %IER66 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %22 = load i32, i32* %IER66, align 4, !tbaa !69
  %conv67 = trunc i32 %22 to i8
  %ioaddr68 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %23 = load i64, i64* %ioaddr68, align 8, !tbaa !17
  %add69 = add i64 %23, 1
  %conv70 = trunc i64 %add69 to i32
  call void @outb(i8 zeroext %conv67, i32 %conv70)
  %ioaddr71 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %24 = load i64, i64* %ioaddr71, align 8, !tbaa !17
  %add72 = add i64 %24, 5
  %conv73 = trunc i64 %add72 to i32
  %call74 = call zeroext i8 @inb(i32 %conv73)
  %ioaddr75 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %25 = load i64, i64* %ioaddr75, align 8, !tbaa !17
  %add76 = add i64 %25, 0
  %conv77 = trunc i64 %add76 to i32
  %call78 = call zeroext i8 @inb(i32 %conv77)
  %ioaddr79 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %26 = load i64, i64* %ioaddr79, align 8, !tbaa !17
  %add80 = add i64 %26, 2
  %conv81 = trunc i64 %add80 to i32
  %call82 = call zeroext i8 @inb(i32 %conv81)
  %ioaddr83 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %27 = load i64, i64* %ioaddr83, align 8, !tbaa !17
  %add84 = add i64 %27, 6
  %conv85 = trunc i64 %add84 to i32
  %call86 = call zeroext i8 @inb(i32 %conv85)
  %flags87 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags87, i64 1, i64* %flags87) #7, !srcloc !154
  %xmit_tail = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 23
  store i32 0, i32* %xmit_tail, align 8, !tbaa !87
  %xmit_head = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  store i32 0, i32* %xmit_head, align 4, !tbaa !67
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  store i32 0, i32* %xmit_cnt, align 4, !tbaa !65
  call void @mxser_change_speed(%struct.tty_struct* %tty)
  %slock89 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %28 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock89, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %28 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call4) #7
  br label %cleanup

cleanup:                                          ; preds = %if.end65, %if.then32, %if.then29, %if.then9, %entry
  %retval.0 = phi i32 [ 0, %if.then32 ], [ 0, %if.end65 ], [ 0, %if.then9 ], [ -12, %entry ], [ -19, %if.then29 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #6

declare void @kasan_check_write(i8*, i32) #3

declare i64 @_copy_from_user(i8*, i8*, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @copy_user_overflow(i32 %size, i64 %count) #2 {
entry:
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.10, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.11, i32 0, i32 0), i32 %size, i64 %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @__check_object_size(i8*, i64, i1 zeroext) #3

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_set_baud(%struct.tty_struct* %tty, i64 %newspd) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %max_baud = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 4
  %3 = load i32, i32* %max_baud, align 8, !tbaa !40
  %conv = sext i32 %3 to i64
  %cmp = icmp sgt i64 %newspd, %conv
  br i1 %cmp, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  switch i64 %newspd, label %if.then8 [
    i64 134, label %if.then6
    i64 0, label %if.end21
  ]

if.then6:                                         ; preds = %if.end3
  %baud_base = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %4 = load i32, i32* %baud_base, align 8, !tbaa !39
  %mul = mul nsw i32 2, %4
  %div = sdiv i32 %mul, 269
  call void @tty_encode_baud_rate(%struct.tty_struct* %tty, i32 134, i32 134)
  br label %if.end21

if.then8:                                         ; preds = %if.end3
  %baud_base9 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %5 = load i32, i32* %baud_base9, align 8, !tbaa !39
  %conv10 = sext i32 %5 to i64
  %div11 = sdiv i64 %conv10, %newspd
  %conv12 = trunc i64 %div11 to i32
  %cmp13 = icmp eq i32 %conv12, 0
  %.conv12 = select i1 %cmp13, i32 1, i32 %conv12
  %baud_base17 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %6 = load i32, i32* %baud_base17, align 8, !tbaa !39
  %div18 = sdiv i32 %6, %.conv12
  call void @tty_encode_baud_rate(%struct.tty_struct* %tty, i32 %div18, i32 %div18)
  br label %if.end21

if.end21:                                         ; preds = %if.then8, %if.then6, %if.end3
  %quot.2 = phi i32 [ %div, %if.then6 ], [ %.conv12, %if.then8 ], [ 0, %if.end3 ]
  %xmit_fifo_size = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 21
  %7 = load i32, i32* %xmit_fifo_size, align 8, !tbaa !88
  %mul22 = mul nsw i32 %7, 250
  %mul23 = mul nsw i32 %mul22, 10
  %mul24 = mul nsw i32 %mul23, %quot.2
  %baud_base25 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %8 = load i32, i32* %baud_base25, align 8, !tbaa !39
  %div26 = sdiv i32 %mul24, %8
  %timeout = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 18
  store i32 %div26, i32* %timeout, align 4, !tbaa !89
  %timeout27 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 18
  %9 = load i32, i32* %timeout27, align 4, !tbaa !89
  %add = add nsw i32 %9, 5
  store i32 %add, i32* %timeout27, align 4, !tbaa !89
  %tobool28 = icmp ne i32 %quot.2, 0
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %10 = load i32, i32* %MCR, align 8, !tbaa !86
  br i1 %tobool28, label %if.then29, label %if.else35

if.then29:                                        ; preds = %if.end21
  %or = or i32 %10, 1
  store i32 %or, i32* %MCR, align 8, !tbaa !86
  %MCR30 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %11 = load i32, i32* %MCR30, align 8, !tbaa !86
  %conv31 = trunc i32 %11 to i8
  %ioaddr32 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %12 = load i64, i64* %ioaddr32, align 8, !tbaa !17
  %add33 = add i64 %12, 4
  %conv34 = trunc i64 %add33 to i32
  call void @outb(i8 zeroext %conv31, i32 %conv34)
  %ioaddr43 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %13 = load i64, i64* %ioaddr43, align 8, !tbaa !17
  %add44 = add i64 %13, 3
  %conv45 = trunc i64 %add44 to i32
  %call = call zeroext i8 @inb(i32 %conv45)
  %conv46 = zext i8 %call to i32
  %or47 = or i32 %conv46, 128
  %conv48 = trunc i32 %or47 to i8
  %ioaddr49 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %14 = load i64, i64* %ioaddr49, align 8, !tbaa !17
  %add50 = add i64 %14, 3
  %conv51 = trunc i64 %add50 to i32
  call void @outb(i8 zeroext %conv48, i32 %conv51)
  %and52 = and i32 %quot.2, 255
  %conv53 = trunc i32 %and52 to i8
  %ioaddr54 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %15 = load i64, i64* %ioaddr54, align 8, !tbaa !17
  %add55 = add i64 %15, 0
  %conv56 = trunc i64 %add55 to i32
  call void @outb(i8 zeroext %conv53, i32 %conv56)
  %shr = ashr i32 %quot.2, 8
  %conv57 = trunc i32 %shr to i8
  %ioaddr58 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %16 = load i64, i64* %ioaddr58, align 8, !tbaa !17
  %add59 = add i64 %16, 1
  %conv60 = trunc i64 %add59 to i32
  call void @outb(i8 zeroext %conv57, i32 %conv60)
  %ioaddr61 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %17 = load i64, i64* %ioaddr61, align 8, !tbaa !17
  %add62 = add i64 %17, 3
  %conv63 = trunc i64 %add62 to i32
  call void @outb(i8 zeroext %call, i32 %conv63)
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 2
  %18 = load i32, i32* %c_cflag, align 8, !tbaa !63
  %and64 = and i32 %18, 4111
  %cmp65 = icmp eq i32 %and64, 4096
  br i1 %cmp65, label %if.then67, label %if.else88

if.else35:                                        ; preds = %if.end21
  %and = and i32 %10, -2
  store i32 %and, i32* %MCR, align 8, !tbaa !86
  %MCR37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %19 = load i32, i32* %MCR37, align 8, !tbaa !86
  %conv38 = trunc i32 %19 to i8
  %ioaddr39 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %20 = load i64, i64* %ioaddr39, align 8, !tbaa !17
  %add40 = add i64 %20, 4
  %conv41 = trunc i64 %add40 to i32
  call void @outb(i8 zeroext %conv38, i32 %conv41)
  br label %cleanup

if.then67:                                        ; preds = %if.then29
  %baud_base68 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %21 = load i32, i32* %baud_base68, align 8, !tbaa !39
  %conv69 = sext i32 %21 to i64
  %rem = srem i64 %conv69, %newspd
  %conv70 = trunc i64 %rem to i32
  %mul71 = mul nsw i32 %conv70, 8
  %conv72 = sext i32 %mul71 to i64
  %rem73 = srem i64 %conv72, %newspd
  %div74 = sdiv i64 %newspd, 2
  %cmp75 = icmp sgt i64 %rem73, %div74
  %conv78 = sext i32 %mul71 to i64
  %div79 = sdiv i64 %conv78, %newspd
  %conv80 = trunc i64 %div79 to i32
  %inc = add nsw i32 %conv80, 1
  %quot.3 = select i1 %cmp75, i32 %inc, i32 %conv80
  %ioaddr86 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %22 = load i64, i64* %ioaddr86, align 8, !tbaa !17
  %conv87 = trunc i32 %quot.3 to i8
  call void @mxser_set_must_enum_value(i64 %22, i8 zeroext %conv87)
  br label %cleanup

if.else88:                                        ; preds = %if.then29
  %ioaddr89 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %23 = load i64, i64* %ioaddr89, align 8, !tbaa !17
  call void @mxser_set_must_enum_value(i64 %23, i8 zeroext 0)
  br label %cleanup

cleanup:                                          ; preds = %if.else88, %if.then67, %if.else35, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_set_must_fifo_value(%struct.mxser_port* %info) #4 {
entry:
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %0 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %0, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %ioaddr1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %1 = load i64, i64* %ioaddr1, align 8, !tbaa !17
  %add2 = add i64 %1, 3
  %conv3 = trunc i64 %add2 to i32
  call void @outb(i8 zeroext -65, i32 %conv3)
  %ioaddr4 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %2 = load i64, i64* %ioaddr4, align 8, !tbaa !17
  %add5 = add i64 %2, 2
  %conv6 = trunc i64 %add5 to i32
  %call7 = call zeroext i8 @inb(i32 %conv6)
  %conv8 = zext i8 %call7 to i32
  %and = and i32 %conv8, -193
  %conv9 = trunc i32 %and to i8
  %conv10 = zext i8 %conv9 to i32
  %or = or i32 %conv10, 64
  %conv11 = trunc i32 %or to i8
  %ioaddr12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %3 = load i64, i64* %ioaddr12, align 8, !tbaa !17
  %add13 = add i64 %3, 2
  %conv14 = trunc i64 %add13 to i32
  call void @outb(i8 zeroext %conv11, i32 %conv14)
  %rx_high_water = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 5
  %4 = load i32, i32* %rx_high_water, align 4, !tbaa !186
  %conv15 = trunc i32 %4 to i8
  %ioaddr16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %5 = load i64, i64* %ioaddr16, align 8, !tbaa !17
  %add17 = add i64 %5, 5
  %conv18 = trunc i64 %add17 to i32
  call void @outb(i8 zeroext %conv15, i32 %conv18)
  %rx_trigger = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 6
  %6 = load i32, i32* %rx_trigger, align 8, !tbaa !185
  %conv19 = trunc i32 %6 to i8
  %ioaddr20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %7 = load i64, i64* %ioaddr20, align 8, !tbaa !17
  %add21 = add i64 %7, 6
  %conv22 = trunc i64 %add21 to i32
  call void @outb(i8 zeroext %conv19, i32 %conv22)
  %rx_low_water = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 7
  %8 = load i32, i32* %rx_low_water, align 4, !tbaa !187
  %conv23 = trunc i32 %8 to i8
  %ioaddr24 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %9 = load i64, i64* %ioaddr24, align 8, !tbaa !17
  %add25 = add i64 %9, 4
  %conv26 = trunc i64 %add25 to i32
  call void @outb(i8 zeroext %conv23, i32 %conv26)
  %ioaddr27 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %10 = load i64, i64* %ioaddr27, align 8, !tbaa !17
  %add28 = add i64 %10, 3
  %conv29 = trunc i64 %add28 to i32
  call void @outb(i8 zeroext %call, i32 %conv29)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @tty_port_set_cts_flow(%struct.tty_port* %port, i1 zeroext %val) #2 {
entry:
  %frombool = zext i1 %val to i8
  %tobool = trunc i8 %frombool to i1
  %iflags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 11
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %iflags, i64 3, i64* %iflags) #7, !srcloc !153
  br label %if.end

if.else:                                          ; preds = %entry
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %iflags, i64 3, i64* %iflags) #7, !srcloc !154
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare void @tty_wakeup(%struct.tty_struct*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @tty_port_set_check_carrier(%struct.tty_port* %port, i1 zeroext %val) #2 {
entry:
  %frombool = zext i1 %val to i8
  %tobool = trunc i8 %frombool to i1
  %iflags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 11
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %iflags, i64 4, i64* %iflags) #7, !srcloc !153
  br label %if.end

if.else:                                          ; preds = %entry
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %iflags, i64 4, i64* %iflags) #7, !srcloc !154
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_set_must_xon1_value(i64 %baseio, i8 zeroext %value) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -193
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %conv9 = trunc i32 %conv8 to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 4
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %value, i32 %conv13)
  %add14 = add i64 %baseio, 3
  %conv15 = trunc i64 %add14 to i32
  call void @outb(i8 zeroext %call, i32 %conv15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_set_must_xoff1_value(i64 %baseio, i8 zeroext %value) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -193
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %conv9 = trunc i32 %conv8 to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 6
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %value, i32 %conv13)
  %add14 = add i64 %baseio, 3
  %conv15 = trunc i64 %add14 to i32
  call void @outb(i8 zeroext %call, i32 %conv15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_enable_must_rx_software_flow_control(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -4
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %or = or i32 %conv8, 2
  %conv9 = trunc i32 %or to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 3
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %call, i32 %conv13)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_disable_must_rx_software_flow_control(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -4
  %conv7 = trunc i32 %and to i8
  %add8 = add i64 %baseio, 2
  %conv9 = trunc i64 %add8 to i32
  call void @outb(i8 zeroext %conv7, i32 %conv9)
  %add10 = add i64 %baseio, 3
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_enable_must_tx_software_flow_control(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -13
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %or = or i32 %conv8, 8
  %conv9 = trunc i32 %or to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 3
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %call, i32 %conv13)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_disable_must_tx_software_flow_control(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -13
  %conv7 = trunc i32 %and to i8
  %add8 = add i64 %baseio, 2
  %conv9 = trunc i64 %add8 to i32
  call void @outb(i8 zeroext %conv7, i32 %conv9)
  %add10 = add i64 %baseio, 3
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_set_must_enum_value(i64 %baseio, i8 zeroext %value) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -193
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %or = or i32 %conv8, 128
  %conv9 = trunc i32 %or to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 4
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %value, i32 %conv13)
  %add14 = add i64 %baseio, 3
  %conv15 = trunc i64 %add14 to i32
  call void @outb(i8 zeroext %call, i32 %conv15)
  ret void
}

declare i64 @__get_free_pages(i32, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @tty_port_check_carrier(%struct.tty_port* %port) #2 {
entry:
  %iflags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 11
  %0 = load volatile i64, i64* %iflags, align 8, !tbaa !66
  %and1.i = and i64 16, %0
  %cmp.i = icmp ne i64 %and1.i, 0
  ret i1 %cmp.i
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @tty_port_cts_enabled(%struct.tty_port* %port) #2 {
entry:
  %iflags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 11
  %0 = load volatile i64, i64* %iflags, align 8, !tbaa !66
  %and1.i = and i64 8, %0
  %cmp.i = icmp ne i64 %and1.i, 0
  ret i1 %cmp.i
}

declare void @kasan_check_read(i8*, i32) #3

declare i64 @_copy_to_user(i8*, i8*, i32) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_stoprx(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 38
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %ldisc_stop_rx = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 14
  store i8 1, i8* %ldisc_stop_rx, align 1, !tbaa !45
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_iflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 0
  %2 = load i32, i32* %c_iflag, align 8, !tbaa !84
  %and = and i32 %2, 4096
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end17

if.then:                                          ; preds = %entry
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %3 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %3, i32 0, i32 5
  %4 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool1 = icmp ne i32 %4, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %5 = load i32, i32* %IER, align 4, !tbaa !69
  %and3 = and i32 %5, -18
  store i32 %and3, i32* %IER, align 4, !tbaa !69
  %IER4 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %6 = load i32, i32* %IER4, align 4, !tbaa !69
  %conv = trunc i32 %6 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %7 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %7, 1
  %conv5 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv, i32 %conv5)
  br label %if.end17

if.else:                                          ; preds = %if.then
  %termios6 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_cc = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios6, i32 0, i32 5
  %arrayidx = getelementptr inbounds [19 x i8], [19 x i8]* %c_cc, i64 0, i64 9
  %8 = load i8, i8* %arrayidx, align 1, !tbaa !52
  %conv7 = zext i8 %8 to i32
  %x_char = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 10
  store i32 %conv7, i32* %x_char, align 8, !tbaa !85
  %ioaddr8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr8, align 8, !tbaa !17
  %add9 = add i64 %9, 1
  %conv10 = trunc i64 %add9 to i32
  call void @outb(i8 zeroext 0, i32 %conv10)
  %IER11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %10 = load i32, i32* %IER11, align 4, !tbaa !69
  %or = or i32 %10, 2
  store i32 %or, i32* %IER11, align 4, !tbaa !69
  %IER12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %11 = load i32, i32* %IER12, align 4, !tbaa !69
  %conv13 = trunc i32 %11 to i8
  %ioaddr14 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %12 = load i64, i64* %ioaddr14, align 8, !tbaa !17
  %add15 = add i64 %12, 1
  %conv16 = trunc i64 %add15 to i32
  call void @outb(i8 zeroext %conv13, i32 %conv16)
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then2, %entry
  %termios18 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 15
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios18, i32 0, i32 2
  %13 = load i32, i32* %c_cflag, align 8, !tbaa !63
  %and19 = and i32 %13, -2147483648
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end28

if.then21:                                        ; preds = %if.end17
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %14 = load i32, i32* %MCR, align 8, !tbaa !86
  %and22 = and i32 %14, -3
  store i32 %and22, i32* %MCR, align 8, !tbaa !86
  %MCR23 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %15 = load i32, i32* %MCR23, align 8, !tbaa !86
  %conv24 = trunc i32 %15 to i8
  %ioaddr25 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %16 = load i64, i64* %ioaddr25, align 8, !tbaa !17
  %add26 = add i64 %16, 4
  %conv27 = trunc i64 %add26 to i32
  call void @outb(i8 zeroext %conv24, i32 %conv27)
  br label %if.end28

if.end28:                                         ; preds = %if.then21, %if.end17
  ret void
}

declare void @tty_port_hangup(%struct.tty_port*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #2 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #2 {
entry:
  %call = call %struct.thread_info* @task_thread_info(%struct.task_struct* %tsk)
  %call1 = call i32 @test_ti_thread_flag(%struct.thread_info* %call, i32 %flag)
  ret i32 %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #2 {
entry:
  %oldbit.i = alloca i8, align 1
  %conv = sext i32 %flag to i64
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 0
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %flags, i64 %conv) #7, !srcloc !196
  %0 = load i8, i8* %oldbit.i, align 1, !tbaa !197, !range !198
  %tobool.i = trunc i8 %0 to i1
  %conv1 = zext i1 %tobool.i to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @task_thread_info(%struct.task_struct* %task) #2 {
entry:
  %thread_info = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i32 0, i32 0
  ret %struct.thread_info* %thread_info
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_read_register(i32 %port, i16* %regs) #0 section ".init.text" {
entry:
  %call = call i32 @mxser_program_mode(i32 %port)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.end20, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc23, %for.end20 ]
  %cmp1 = icmp slt i32 %i.0, 14
  br i1 %cmp1, label %for.body, label %for.end24

for.body:                                         ; preds = %for.cond
  %and = and i32 %i.0, 63
  %or = or i32 %and, 384
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %j.0 = phi i32 [ 256, %for.body ], [ %shr, %for.inc ]
  %cmp3 = icmp ugt i32 %j.0, 0
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond2
  call void @outb(i8 zeroext 4, i32 %port)
  %and5 = and i32 %or, %j.0
  %tobool = icmp ne i32 %and5, 0
  br i1 %tobool, label %if.then6, label %if.else

if.then6:                                         ; preds = %for.body4
  call void @outb(i8 zeroext 6, i32 %port)
  call void @outb(i8 zeroext 7, i32 %port)
  br label %for.inc

if.else:                                          ; preds = %for.body4
  call void @outb(i8 zeroext 4, i32 %port)
  call void @outb(i8 zeroext 5, i32 %port)
  br label %for.inc

for.inc:                                          ; preds = %if.else, %if.then6
  %shr = lshr i32 %j.0, 1
  br label %for.cond2

for.end:                                          ; preds = %for.cond2
  %call8 = call zeroext i8 @inb(i32 %port)
  br label %for.cond9

for.cond9:                                        ; preds = %for.body11, %for.end
  %value.0 = phi i32 [ 0, %for.end ], [ %or16.value.0, %for.body11 ]
  %k.0 = phi i32 [ 0, %for.end ], [ %inc, %for.body11 ]
  %j.1 = phi i32 [ 32768, %for.end ], [ %shr19, %for.body11 ]
  %cmp10 = icmp slt i32 %k.0, 16
  br i1 %cmp10, label %for.body11, label %for.end20

for.body11:                                       ; preds = %for.cond9
  call void @outb(i8 zeroext 4, i32 %port)
  call void @outb(i8 zeroext 5, i32 %port)
  %call12 = call zeroext i8 @inb(i32 %port)
  %conv = zext i8 %call12 to i32
  %and13 = and i32 %conv, 8
  %tobool14 = icmp ne i32 %and13, 0
  %or16 = or i32 %value.0, %j.1
  %or16.value.0 = select i1 %tobool14, i32 %or16, i32 %value.0
  %inc = add nsw i32 %k.0, 1
  %shr19 = lshr i32 %j.1, 1
  br label %for.cond9

for.end20:                                        ; preds = %for.cond9
  %conv21 = trunc i32 %value.0 to i16
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i16, i16* %regs, i64 %idxprom
  store i16 %conv21, i16* %arrayidx, align 2, !tbaa !14
  call void @outb(i8 zeroext 0, i32 %port)
  %inc23 = add nsw i32 %i.0, 1
  br label %for.cond

for.end24:                                        ; preds = %for.cond
  call void @mxser_normal_mode(i32 %port)
  br label %cleanup

cleanup:                                          ; preds = %for.end24, %entry
  ret i32 %call
}

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #3

; Function Attrs: nounwind uwtable
define internal i32 @mxser_request_vector(%struct.mxser_board* %brd) #4 {
entry:
  %call = call zeroext i1 @mxser_overlapping_vector(%struct.mxser_board* %brd)
  br i1 %call, label %return, label %if.end

if.end:                                           ; preds = %entry
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 3
  %0 = load i64, i64* %vector, align 8, !tbaa !37
  %call1 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %0, i64 1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.50, i32 0, i32 0), i32 0)
  %tobool = icmp ne %struct.resource* %call1, null
  %cond = select i1 %tobool, i32 0, i32 -5
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %cond, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

declare void @__release_region(%struct.resource*, i64, i64) #3

; Function Attrs: nounwind uwtable
define internal i32 @mxser_program_mode(i32 %port) #0 section ".init.text" {
entry:
  call void @outb(i8 zeroext 0, i32 %port)
  call void @outb(i8 zeroext 0, i32 %port)
  call void @outb(i8 zeroext 0, i32 %port)
  %call = call zeroext i8 @inb(i32 %port)
  %call1 = call zeroext i8 @inb(i32 %port)
  call void @outb(i8 zeroext 0, i32 %port)
  %call2 = call zeroext i8 @inb(i32 %port)
  %add = add nsw i32 %port, 1
  %call3 = call zeroext i8 @inb(i32 %add)
  %conv = zext i8 %call3 to i32
  %and = and i32 %conv, 31
  switch i32 %and, label %cleanup [
    i32 1, label %if.end
    i32 2, label %if.end
    i32 11, label %if.end
    i32 4, label %if.end
    i32 3, label %if.end
    i32 5, label %if.end
  ]

if.end:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %j.0 = phi i32 [ 0, %if.end ], [ %j.1, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp19 = icmp slt i32 %i.0, 4
  br i1 %cmp19, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add21 = add nsw i32 %port, 2
  %call22 = call zeroext i8 @inb(i32 %add21)
  %conv23 = zext i8 %call22 to i32
  %cmp24 = icmp eq i32 %conv23, 77
  br i1 %cmp24, label %for.inc, label %if.else

if.else:                                          ; preds = %for.body
  %cmp27 = icmp eq i32 %j.0, 1
  %cmp30 = icmp eq i32 %conv23, 1
  %or.cond = and i1 %cmp27, %cmp30
  br i1 %or.cond, label %for.end, label %for.inc

for.inc:                                          ; preds = %if.else, %for.body
  %j.1 = phi i32 [ 1, %for.body ], [ 0, %if.else ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %j.2 = phi i32 [ 2, %if.else ], [ %j.0, %for.cond ]
  %cmp36 = icmp ne i32 %j.2, 2
  %.and = select i1 %cmp36, i32 -2, i32 %and
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i32 [ %.and, %for.end ], [ -1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @mxser_normal_mode(i32 %port) #0 section ".init.text" {
entry:
  %add = add nsw i32 %port, 1
  call void @outb(i8 zeroext -91, i32 %add)
  %add1 = add nsw i32 %port, 3
  call void @outb(i8 zeroext -128, i32 %add1)
  %add2 = add nsw i32 %port, 0
  call void @outb(i8 zeroext 12, i32 %add2)
  %add3 = add nsw i32 %port, 1
  call void @outb(i8 zeroext 0, i32 %add3)
  %add4 = add nsw i32 %port, 3
  call void @outb(i8 zeroext 3, i32 %add4)
  %add5 = add nsw i32 %port, 4
  call void @outb(i8 zeroext 19, i32 %add5)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add6 = add nsw i32 %port, 5
  %call = call zeroext i8 @inb(i32 %add6)
  %conv = zext i8 %call to i32
  %and = and i32 %conv, 97
  %cmp7 = icmp eq i32 %and, 96
  br i1 %cmp7, label %for.end, label %if.end

if.end:                                           ; preds = %for.body
  %and9 = and i32 %conv, 1
  %cmp10 = icmp eq i32 %and9, 1
  br i1 %cmp10, label %if.then12, label %for.inc

if.then12:                                        ; preds = %if.end
  %call13 = call zeroext i8 @inb(i32 %port)
  br label %for.inc

for.inc:                                          ; preds = %if.then12, %if.end
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %add15 = add nsw i32 %port, 4
  call void @outb(i8 zeroext 0, i32 %add15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mxser_overlapping_vector(%struct.mxser_board* %brd) #4 {
entry:
  %0 = load i8, i8* @allow_overlapping_vector, align 1, !tbaa !197, !range !198
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 3
  %1 = load i64, i64* %vector, align 8, !tbaa !37
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %arrayidx = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 0
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %cmp = icmp uge i64 %1, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %vector1 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 3
  %3 = load i64, i64* %vector1, align 8, !tbaa !37
  %ports2 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %arrayidx3 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports2, i64 0, i64 0
  %ioaddr4 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx3, i32 0, i32 2
  %4 = load i64, i64* %ioaddr4, align 8, !tbaa !17
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %5 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !2
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %5, i32 0, i32 1
  %6 = load i32, i32* %nports, align 8, !tbaa !11
  %mul = mul i32 8, %6
  %conv = zext i32 %mul to i64
  %add = add i64 %4, %conv
  %cmp5 = icmp ult i64 %3, %add
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %7 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp5, %land.rhs ]
  ret i1 %7
}

declare void @tty_port_init(%struct.tty_port*) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_enable_must_enchance_mode(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %or = or i32 %conv6, 16
  %conv7 = trunc i32 %or to i8
  %add8 = add i64 %baseio, 2
  %conv9 = trunc i64 %add8 to i32
  call void @outb(i8 zeroext %conv7, i32 %conv9)
  %add10 = add i64 %baseio, 3
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  ret void
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #2 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_interrupt(i32 %irq, i8* %dev_id) #4 {
entry:
  %status = alloca i32, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom
  %0 = bitcast %struct.mxser_board* %arrayidx to i8*
  %cmp1 = icmp eq i8* %dev_id, %0
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %1 = bitcast i8* %dev_id to %struct.mxser_board*
  br label %for.end

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %brd.0 = phi %struct.mxser_board* [ %1, %if.then ], [ null, %for.cond ]
  %cmp2 = icmp eq i32 %i.0, 4
  %cmp5 = icmp eq %struct.mxser_board* %brd.0, null
  %or.cond = or i1 %cmp2, %cmp5
  br i1 %or.cond, label %irq_stop, label %if.end7

if.end7:                                          ; preds = %for.end
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 2
  %2 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !2
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %2, i32 0, i32 1
  %3 = load i32, i32* %nports, align 8, !tbaa !11
  br label %while.cond

while.cond:                                       ; preds = %for.end150, %if.end7
  %pass_counter.0 = phi i32 [ 0, %if.end7 ], [ %inc8, %for.end150 ]
  %handled.0 = phi i32 [ 0, %if.end7 ], [ 1, %for.end150 ]
  %inc8 = add i32 %pass_counter.0, 1
  %cmp9 = icmp ult i32 %pass_counter.0, 100
  br i1 %cmp9, label %while.body, label %irq_stop

while.body:                                       ; preds = %while.cond
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 3
  %4 = load i64, i64* %vector, align 8, !tbaa !37
  %conv = trunc i64 %4 to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %conv10 = zext i8 %call to i64
  %vector_mask = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 4
  %5 = load i64, i64* %vector_mask, align 8, !tbaa !38
  %and = and i64 %conv10, %5
  %conv11 = trunc i64 %and to i32
  %conv12 = sext i32 %conv11 to i64
  %vector_mask13 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 4
  %6 = load i64, i64* %vector_mask13, align 8, !tbaa !38
  %cmp14 = icmp eq i64 %conv12, %6
  br i1 %cmp14, label %irq_stop, label %if.end17

if.end17:                                         ; preds = %while.body
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc147, %if.end17
  %irqbits.0 = phi i32 [ %conv11, %if.end17 ], [ %or149, %for.inc147 ]
  %bits.0 = phi i32 [ 1, %if.end17 ], [ %shl, %for.inc147 ]
  %i.1 = phi i32 [ 0, %if.end17 ], [ %inc148, %for.inc147 ]
  %cmp19 = icmp slt i32 %i.1, %3
  br i1 %cmp19, label %for.body21, label %for.end150

for.body21:                                       ; preds = %for.cond18
  %conv22 = sext i32 %irqbits.0 to i64
  %vector_mask23 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 4
  %7 = load i64, i64* %vector_mask23, align 8, !tbaa !38
  %cmp24 = icmp eq i64 %conv22, %7
  br i1 %cmp24, label %for.end150, label %if.end27

if.end27:                                         ; preds = %for.body21
  %and28 = and i32 %bits.0, %irqbits.0
  %tobool = icmp ne i32 %and28, 0
  br i1 %tobool, label %for.inc147, label %if.end30

if.end30:                                         ; preds = %if.end27
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 7
  %idxprom31 = sext i32 %i.1 to i64
  %arrayidx32 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom31
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 28
  %8 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %8 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #7
  br label %do.body

do.body:                                          ; preds = %if.end142, %if.end30
  %int_cnt.0 = phi i32 [ 0, %if.end30 ], [ %inc143, %if.end142 ]
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %9 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %9, 2
  %conv33 = trunc i64 %add to i32
  %call34 = call zeroext i8 @inb(i32 %conv33)
  %conv35 = zext i8 %call34 to i32
  %and36 = and i32 %conv35, 1
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %do.end, label %if.end39

if.end39:                                         ; preds = %do.body
  %and40 = and i32 %conv35, 62
  %port41 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 0
  %call42 = call %struct.tty_struct* @tty_port_tty_get(%struct.tty_port* %port41)
  %tobool43 = icmp ne %struct.tty_struct* %call42, null
  br i1 %tobool43, label %lor.lhs.false, label %if.then48

lor.lhs.false:                                    ; preds = %if.end39
  %closing = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 25
  %10 = load i32, i32* %closing, align 8, !tbaa !62
  %tobool44 = icmp ne i32 %10, 0
  br i1 %tobool44, label %if.then48, label %lor.lhs.false45

lor.lhs.false45:                                  ; preds = %lor.lhs.false
  %port46 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 0
  %call47 = call zeroext i1 @tty_port_initialized(%struct.tty_port* %port46)
  br i1 %call47, label %if.end61, label %if.then48

if.then48:                                        ; preds = %lor.lhs.false45, %lor.lhs.false, %if.end39
  %ioaddr49 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %11 = load i64, i64* %ioaddr49, align 8, !tbaa !17
  %add50 = add i64 %11, 5
  %conv51 = trunc i64 %add50 to i32
  %call52 = call zeroext i8 @inb(i32 %conv51)
  %conv53 = zext i8 %call52 to i32
  store i32 %conv53, i32* %status, align 4, !tbaa !51
  %ioaddr54 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %12 = load i64, i64* %ioaddr54, align 8, !tbaa !17
  %add55 = add i64 %12, 2
  %conv56 = trunc i64 %add55 to i32
  call void @outb(i8 zeroext 39, i32 %conv56)
  %ioaddr57 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %13 = load i64, i64* %ioaddr57, align 8, !tbaa !17
  %add58 = add i64 %13, 6
  %conv59 = trunc i64 %add58 to i32
  %call60 = call zeroext i8 @inb(i32 %conv59)
  call void @tty_kref_put(%struct.tty_struct* %call42)
  br label %do.end

if.end61:                                         ; preds = %lor.lhs.false45
  %ioaddr62 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %14 = load i64, i64* %ioaddr62, align 8, !tbaa !17
  %add63 = add i64 %14, 5
  %conv64 = trunc i64 %add63 to i32
  %call65 = call zeroext i8 @inb(i32 %conv64)
  %conv66 = zext i8 %call65 to i32
  store i32 %conv66, i32* %status, align 4, !tbaa !51
  %15 = load i32, i32* %status, align 4, !tbaa !51
  %and67 = and i32 %15, 4
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %if.then69, label %if.end72

if.then69:                                        ; preds = %if.end61
  %err_shadow = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 16
  %16 = load i8, i8* %err_shadow, align 4, !tbaa !53
  %conv70 = zext i8 %16 to i32
  %or = or i32 %conv70, 1
  %conv71 = trunc i32 %or to i8
  store i8 %conv71, i8* %err_shadow, align 4, !tbaa !53
  br label %if.end72

if.end72:                                         ; preds = %if.then69, %if.end61
  %17 = load i32, i32* %status, align 4, !tbaa !51
  %and73 = and i32 %17, 8
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %if.then75, label %if.end80

if.then75:                                        ; preds = %if.end72
  %err_shadow76 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 16
  %18 = load i8, i8* %err_shadow76, align 4, !tbaa !53
  %conv77 = zext i8 %18 to i32
  %or78 = or i32 %conv77, 2
  %conv79 = trunc i32 %or78 to i8
  store i8 %conv79, i8* %err_shadow76, align 4, !tbaa !53
  br label %if.end80

if.end80:                                         ; preds = %if.then75, %if.end72
  %19 = load i32, i32* %status, align 4, !tbaa !51
  %and81 = and i32 %19, 2
  %tobool82 = icmp ne i32 %and81, 0
  br i1 %tobool82, label %if.then83, label %if.end88

if.then83:                                        ; preds = %if.end80
  %err_shadow84 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 16
  %20 = load i8, i8* %err_shadow84, align 4, !tbaa !53
  %conv85 = zext i8 %20 to i32
  %or86 = or i32 %conv85, 4
  %conv87 = trunc i32 %or86 to i8
  store i8 %conv87, i8* %err_shadow84, align 4, !tbaa !53
  br label %if.end88

if.end88:                                         ; preds = %if.then83, %if.end80
  %21 = load i32, i32* %status, align 4, !tbaa !51
  %and89 = and i32 %21, 16
  %tobool90 = icmp ne i32 %and89, 0
  br i1 %tobool90, label %if.then91, label %if.end96

if.then91:                                        ; preds = %if.end88
  %err_shadow92 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 16
  %22 = load i8, i8* %err_shadow92, align 4, !tbaa !53
  %conv93 = zext i8 %22 to i32
  %or94 = or i32 %conv93, 16
  %conv95 = trunc i32 %or94 to i8
  store i8 %conv95, i8* %err_shadow92, align 4, !tbaa !53
  br label %if.end96

if.end96:                                         ; preds = %if.then91, %if.end88
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 1
  %23 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %23, i32 0, i32 5
  %24 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool97 = icmp ne i32 %24, 0
  br i1 %tobool97, label %if.then98, label %if.else

if.then98:                                        ; preds = %if.end96
  switch i32 %and40, label %if.end117 [
    i32 28, label %if.then110
    i32 4, label %if.then110
    i32 12, label %if.then110
    i32 6, label %if.then110
  ]

if.then110:                                       ; preds = %if.then98, %if.then98, %if.then98, %if.then98
  call void @mxser_receive_chars(%struct.tty_struct* %call42, %struct.mxser_port* %arrayidx32, i32* %status)
  br label %if.end117

if.else:                                          ; preds = %if.end96
  %read_status_mask = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 19
  %25 = load i32, i32* %read_status_mask, align 8, !tbaa !194
  %26 = load i32, i32* %status, align 4, !tbaa !51
  %and112 = and i32 %26, %25
  store i32 %and112, i32* %status, align 4, !tbaa !51
  %27 = load i32, i32* %status, align 4, !tbaa !51
  %and113 = and i32 %27, 1
  %tobool114 = icmp ne i32 %and113, 0
  br i1 %tobool114, label %if.then115, label %if.end117

if.then115:                                       ; preds = %if.else
  call void @mxser_receive_chars(%struct.tty_struct* %call42, %struct.mxser_port* %arrayidx32, i32* %status)
  br label %if.end117

if.end117:                                        ; preds = %if.then115, %if.else, %if.then110, %if.then98
  %ioaddr118 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %28 = load i64, i64* %ioaddr118, align 8, !tbaa !17
  %add119 = add i64 %28, 6
  %conv120 = trunc i64 %add119 to i32
  %call121 = call zeroext i8 @inb(i32 %conv120)
  %conv122 = zext i8 %call121 to i32
  %and123 = and i32 %conv122, 15
  %tobool124 = icmp ne i32 %and123, 0
  br i1 %tobool124, label %if.then125, label %if.end126

if.then125:                                       ; preds = %if.end117
  call void @mxser_check_modem_status(%struct.tty_struct* %call42, %struct.mxser_port* %arrayidx32, i32 %conv122)
  br label %if.end126

if.end126:                                        ; preds = %if.then125, %if.end117
  %board127 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 1
  %29 = load %struct.mxser_board*, %struct.mxser_board** %board127, align 8, !tbaa !43
  %chip_flag128 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %29, i32 0, i32 5
  %30 = load i32, i32* %chip_flag128, align 8, !tbaa !10
  %tobool129 = icmp ne i32 %30, 0
  br i1 %tobool129, label %if.then130, label %if.else137

if.then130:                                       ; preds = %if.end126
  %cmp131 = icmp eq i32 %and40, 2
  br i1 %cmp131, label %land.lhs.true, label %if.end142

land.lhs.true:                                    ; preds = %if.then130
  %31 = load i32, i32* %status, align 4, !tbaa !51
  %and133 = and i32 %31, 32
  %tobool134 = icmp ne i32 %and133, 0
  br i1 %tobool134, label %if.then135, label %if.end142

if.then135:                                       ; preds = %land.lhs.true
  call void @mxser_transmit_chars(%struct.tty_struct* %call42, %struct.mxser_port* %arrayidx32)
  br label %if.end142

if.else137:                                       ; preds = %if.end126
  %32 = load i32, i32* %status, align 4, !tbaa !51
  %and138 = and i32 %32, 32
  %tobool139 = icmp ne i32 %and138, 0
  br i1 %tobool139, label %if.then140, label %if.end142

if.then140:                                       ; preds = %if.else137
  call void @mxser_transmit_chars(%struct.tty_struct* %call42, %struct.mxser_port* %arrayidx32)
  br label %if.end142

if.end142:                                        ; preds = %if.then140, %if.else137, %if.then135, %land.lhs.true, %if.then130
  call void @tty_kref_put(%struct.tty_struct* %call42)
  %inc143 = add i32 %int_cnt.0, 1
  %cmp144 = icmp ult i32 %int_cnt.0, 100
  br i1 %cmp144, label %do.body, label %do.end

do.end:                                           ; preds = %if.end142, %if.then48, %do.body
  %slock146 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 28
  %33 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock146, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %33 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i1) #7
  br label %for.inc147

for.inc147:                                       ; preds = %do.end, %if.end27
  %inc148 = add nsw i32 %i.1, 1
  %or149 = or i32 %irqbits.0, %bits.0
  %shl = shl i32 %bits.0, 1
  br label %for.cond18

for.end150:                                       ; preds = %for.body21, %for.cond18
  br label %while.cond

irq_stop:                                         ; preds = %while.body, %while.cond, %for.end
  %handled.1 = phi i32 [ 0, %for.end ], [ %handled.0, %while.cond ], [ %handled.0, %while.body ]
  ret i32 %handled.1
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_carrier_raised(%struct.tty_port* %port) #4 {
entry:
  %0 = bitcast %struct.tty_port* %port to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.mxser_port*
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %2, 6
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 128
  %tobool = icmp ne i32 %and, 0
  %cond = select i1 %tobool, i32 1, i32 0
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal void @mxser_dtr_rts(%struct.tty_port* %port, i32 %on) #4 {
entry:
  %0 = bitcast %struct.tty_port* %port to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %2 to %struct.raw_spinlock*
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  %tobool = icmp ne i32 %on, 0
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %3 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %3, 4
  %conv6 = trunc i64 %add to i32
  %call7 = call zeroext i8 @inb(i32 %conv6)
  %conv8 = zext i8 %call7 to i32
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %or = or i32 %conv8, 1
  %or9 = or i32 %or, 2
  %conv10 = trunc i32 %or9 to i8
  %ioaddr11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %4 = load i64, i64* %ioaddr11, align 8, !tbaa !17
  %add12 = add i64 %4, 4
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %conv10, i32 %conv13)
  br label %if.end

if.else:                                          ; preds = %entry
  %and = and i32 %conv8, -4
  %conv19 = trunc i32 %and to i8
  %ioaddr20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %5 = load i64, i64* %ioaddr20, align 8, !tbaa !17
  %add21 = add i64 %5, 4
  %conv22 = trunc i64 %add21 to i32
  call void @outb(i8 zeroext %conv19, i32 %conv22)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %slock23 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 28
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock23, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %6 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i1, i64 %call3) #7
  ret void
}

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_receive_chars(%struct.tty_struct* %tty, %struct.mxser_port* %port, i32* %status) #4 {
entry:
  %receive_room = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 29
  %0 = load i32, i32* %receive_room, align 8, !tbaa !199
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %ldisc_stop_rx = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 14
  %1 = load i8, i8* %ldisc_stop_rx, align 1, !tbaa !45
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  call void @mxser_stoprx(%struct.tty_struct* %tty)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %2 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %2, i32 0, i32 5
  %3 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %cmp1 = icmp ne i32 %3, 0
  br i1 %cmp1, label %if.then2, label %intr_old

if.then2:                                         ; preds = %if.end
  %4 = load i32, i32* %status, align 4, !tbaa !51
  %and = and i32 %4, 30
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %intr_old, label %if.end5

if.end5:                                          ; preds = %if.then2
  %board6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %5 = load %struct.mxser_board*, %struct.mxser_board** %board6, align 8, !tbaa !43
  %chip_flag7 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %5, i32 0, i32 5
  %6 = load i32, i32* %chip_flag7, align 8, !tbaa !10
  %cmp8 = icmp eq i32 %6, 2
  br i1 %cmp8, label %land.lhs.true9, label %if.end13

land.lhs.true9:                                   ; preds = %if.end5
  %7 = load i32, i32* %status, align 4, !tbaa !51
  %and10 = and i32 %7, 128
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %intr_old, label %if.end13

if.end13:                                         ; preds = %land.lhs.true9, %if.end5
  %8 = load i32, i32* %status, align 4, !tbaa !51
  %and14 = and i32 %8, 128
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %intr_old, label %if.end17

if.end17:                                         ; preds = %if.end13
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %9 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %9, 7
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %board18 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %10 = load %struct.mxser_board*, %struct.mxser_board** %board18, align 8, !tbaa !43
  %chip_flag19 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %10, i32 0, i32 5
  %11 = load i32, i32* %chip_flag19, align 8, !tbaa !10
  %cmp20 = icmp eq i32 %11, 1
  %conv23 = zext i8 %call to i32
  %and24 = and i32 %conv23, 127
  %conv25 = trunc i32 %and24 to i8
  %gdl.0 = select i1 %cmp20, i8 %conv25, i8 %call
  %conv27 = zext i8 %gdl.0 to i32
  %cmp28 = icmp sge i32 %conv27, %0
  br i1 %cmp28, label %if.then30, label %if.end35

if.then30:                                        ; preds = %if.end17
  %ldisc_stop_rx31 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 14
  %12 = load i8, i8* %ldisc_stop_rx31, align 1, !tbaa !45
  %tobool32 = icmp ne i8 %12, 0
  br i1 %tobool32, label %if.end35, label %if.then33

if.then33:                                        ; preds = %if.then30
  call void @mxser_stoprx(%struct.tty_struct* %tty)
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.then30, %if.end17
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end35
  %cnt.0 = phi i32 [ 0, %if.end35 ], [ %inc, %while.body ]
  %gdl.1 = phi i8 [ %gdl.0, %if.end35 ], [ %dec, %while.body ]
  %dec = add i8 %gdl.1, -1
  %tobool36 = icmp ne i8 %gdl.1, 0
  br i1 %tobool36, label %while.body, label %end_intr

while.body:                                       ; preds = %while.cond
  %ioaddr37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %13 = load i64, i64* %ioaddr37, align 8, !tbaa !17
  %add38 = add i64 %13, 0
  %conv39 = trunc i64 %add38 to i32
  %call40 = call zeroext i8 @inb(i32 %conv39)
  %port41 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  call void @tty_insert_flip_char(%struct.tty_port* %port41, i8 zeroext %call40, i8 signext 0)
  %inc = add nsw i32 %cnt.0, 1
  br label %while.cond

intr_old:                                         ; preds = %if.end13, %land.lhs.true9, %if.then2, %if.end
  br label %do.body

do.body:                                          ; preds = %if.end125, %intr_old
  %cnt.1 = phi i32 [ 0, %intr_old ], [ %cnt.2, %if.end125 ]
  %ignored.0 = phi i32 [ 0, %intr_old ], [ %ignored.1, %if.end125 ]
  %max.0 = phi i32 [ 256, %intr_old ], [ %dec44, %if.end125 ]
  %dec44 = add nsw i32 %max.0, -1
  %cmp45 = icmp slt i32 %max.0, 0
  br i1 %cmp45, label %end_intr, label %if.end48

if.end48:                                         ; preds = %do.body
  %ioaddr49 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %14 = load i64, i64* %ioaddr49, align 8, !tbaa !17
  %add50 = add i64 %14, 0
  %conv51 = trunc i64 %add50 to i32
  %call52 = call zeroext i8 @inb(i32 %conv51)
  %board53 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %15 = load %struct.mxser_board*, %struct.mxser_board** %board53, align 8, !tbaa !43
  %chip_flag54 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %15, i32 0, i32 5
  %16 = load i32, i32* %chip_flag54, align 8, !tbaa !10
  %tobool55 = icmp ne i32 %16, 0
  br i1 %tobool55, label %land.lhs.true56, label %if.end63

land.lhs.true56:                                  ; preds = %if.end48
  %17 = load i32, i32* %status, align 4, !tbaa !51
  %and57 = and i32 %17, 2
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.then59, label %if.end63

if.then59:                                        ; preds = %land.lhs.true56
  %ioaddr60 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %18 = load i64, i64* %ioaddr60, align 8, !tbaa !17
  %add61 = add i64 %18, 2
  %conv62 = trunc i64 %add61 to i32
  call void @outb(i8 zeroext 35, i32 %conv62)
  br label %if.end63

if.end63:                                         ; preds = %if.then59, %land.lhs.true56, %if.end48
  %read_status_mask = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 19
  %19 = load i32, i32* %read_status_mask, align 8, !tbaa !194
  %20 = load i32, i32* %status, align 4, !tbaa !51
  %and64 = and i32 %20, %19
  store i32 %and64, i32* %status, align 4, !tbaa !51
  %21 = load i32, i32* %status, align 4, !tbaa !51
  %ignore_status_mask = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 20
  %22 = load i32, i32* %ignore_status_mask, align 4, !tbaa !195
  %and65 = and i32 %21, %22
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %if.then67, label %if.else

if.then67:                                        ; preds = %if.end63
  %inc68 = add nsw i32 %ignored.0, 1
  %cmp69 = icmp sgt i32 %inc68, 100
  br i1 %cmp69, label %end_intr, label %if.end120

if.else:                                          ; preds = %if.end63
  %23 = load i32, i32* %status, align 4, !tbaa !51
  %and73 = and i32 %23, 30
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %if.then75, label %if.end108

if.then75:                                        ; preds = %if.else
  %24 = load i32, i32* %status, align 4, !tbaa !51
  %and76 = and i32 %24, 16
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %if.then78, label %if.else85

if.then78:                                        ; preds = %if.then75
  %icount = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %brk = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount, i32 0, i32 9
  %25 = load i32, i32* %brk, align 4, !tbaa !200
  %inc79 = add i32 %25, 1
  store i32 %inc79, i32* %brk, align 4, !tbaa !200
  %port80 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %flags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port80, i32 0, i32 10
  %26 = load i64, i64* %flags, align 8, !tbaa !162
  %and81 = and i64 %26, 4
  %tobool82 = icmp ne i64 %and81, 0
  br i1 %tobool82, label %if.then83, label %if.end108

if.then83:                                        ; preds = %if.then78
  call void @do_SAK(%struct.tty_struct* %tty)
  br label %if.end108

if.else85:                                        ; preds = %if.then75
  %27 = load i32, i32* %status, align 4, !tbaa !51
  %and86 = and i32 %27, 4
  %tobool87 = icmp ne i32 %and86, 0
  br i1 %tobool87, label %if.then88, label %if.else91

if.then88:                                        ; preds = %if.else85
  %icount89 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %parity = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount89, i32 0, i32 7
  %28 = load i32, i32* %parity, align 4, !tbaa !201
  %inc90 = add i32 %28, 1
  store i32 %inc90, i32* %parity, align 4, !tbaa !201
  br label %if.end108

if.else91:                                        ; preds = %if.else85
  %29 = load i32, i32* %status, align 4, !tbaa !51
  %and92 = and i32 %29, 8
  %tobool93 = icmp ne i32 %and92, 0
  br i1 %tobool93, label %if.then94, label %if.else97

if.then94:                                        ; preds = %if.else91
  %icount95 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %frame = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount95, i32 0, i32 6
  %30 = load i32, i32* %frame, align 8, !tbaa !202
  %inc96 = add i32 %30, 1
  store i32 %inc96, i32* %frame, align 8, !tbaa !202
  br label %if.end108

if.else97:                                        ; preds = %if.else91
  %31 = load i32, i32* %status, align 4, !tbaa !51
  %and98 = and i32 %31, 2
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %if.then100, label %if.end108

if.then100:                                       ; preds = %if.else97
  %icount101 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %overrun = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount101, i32 0, i32 8
  %32 = load i32, i32* %overrun, align 8, !tbaa !203
  %inc102 = add i32 %32, 1
  store i32 %inc102, i32* %overrun, align 8, !tbaa !203
  br label %if.end108

if.end108:                                        ; preds = %if.then100, %if.else97, %if.then94, %if.then88, %if.then83, %if.then78, %if.else
  %flag.4 = phi i8 [ 0, %if.else ], [ 1, %if.then83 ], [ 1, %if.then78 ], [ 3, %if.then88 ], [ 2, %if.then94 ], [ 4, %if.then100 ], [ 1, %if.else97 ]
  %port109 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  call void @tty_insert_flip_char(%struct.tty_port* %port109, i8 zeroext %call52, i8 signext %flag.4)
  %inc111 = add nsw i32 %cnt.1, 1
  %cmp112 = icmp sge i32 %inc111, %0
  br i1 %cmp112, label %if.then114, label %LeafBlock

if.then114:                                       ; preds = %if.end108
  %ldisc_stop_rx115 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 14
  %33 = load i8, i8* %ldisc_stop_rx115, align 1, !tbaa !45
  %tobool116 = icmp ne i8 %33, 0
  br i1 %tobool116, label %LeafBlock, label %if.then117

if.then117:                                       ; preds = %if.then114
  call void @mxser_stoprx(%struct.tty_struct* %tty)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then117, %if.then114, %if.end108
  %cleanup.dest.slot.0 = phi i32 [ 6, %if.then117 ], [ 6, %if.then114 ], [ 0, %if.end108 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 6
  br i1 %SwitchLeaf, label %end_intr, label %if.end120

if.end120:                                        ; preds = %LeafBlock, %if.then67
  %cnt.2 = phi i32 [ %cnt.1, %if.then67 ], [ %inc111, %LeafBlock ]
  %ignored.1 = phi i32 [ %inc68, %if.then67 ], [ %ignored.0, %LeafBlock ]
  %board121 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %34 = load %struct.mxser_board*, %struct.mxser_board** %board121, align 8, !tbaa !43
  %chip_flag122 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %34, i32 0, i32 5
  %35 = load i32, i32* %chip_flag122, align 8, !tbaa !10
  %tobool123 = icmp ne i32 %35, 0
  br i1 %tobool123, label %end_intr, label %if.end125

if.end125:                                        ; preds = %if.end120
  %ioaddr126 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %36 = load i64, i64* %ioaddr126, align 8, !tbaa !17
  %add127 = add i64 %36, 5
  %conv128 = trunc i64 %add127 to i32
  %call129 = call zeroext i8 @inb(i32 %conv128)
  %conv130 = zext i8 %call129 to i32
  store i32 %conv130, i32* %status, align 4, !tbaa !51
  %37 = load i32, i32* %status, align 4, !tbaa !51
  %and131 = and i32 %37, 1
  %tobool132 = icmp ne i32 %and131, 0
  br i1 %tobool132, label %do.body, label %end_intr

end_intr:                                         ; preds = %if.end125, %if.end120, %LeafBlock, %if.then67, %do.body, %while.cond
  %cnt.4 = phi i32 [ %cnt.0, %while.cond ], [ %cnt.1, %do.body ], [ %cnt.1, %if.then67 ], [ %cnt.2, %if.end120 ], [ %inc111, %LeafBlock ], [ %cnt.2, %if.end125 ]
  %conv133 = sext i32 %cnt.4 to i64
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %38 = load i32, i32* %index, align 8, !tbaa !54
  %idxprom = sext i32 %38 to i64
  %arrayidx = getelementptr inbounds [32 x i64], [32 x i64]* getelementptr inbounds (%struct.mxser_log, %struct.mxser_log* @mxvar_log, i32 0, i32 1), i64 0, i64 %idxprom
  %39 = load i64, i64* %arrayidx, align 8, !tbaa !66
  %add134 = add i64 %39, %conv133
  store i64 %add134, i64* %arrayidx, align 8, !tbaa !66
  %conv135 = sext i32 %cnt.4 to i64
  %mon_data = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 27
  %rxcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data, i32 0, i32 0
  %40 = load i64, i64* %rxcnt, align 8, !tbaa !75
  %add136 = add i64 %40, %conv135
  store i64 %add136, i64* %rxcnt, align 8, !tbaa !75
  %conv137 = sext i32 %cnt.4 to i64
  %mon_data138 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 27
  %up_rxcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data138, i32 0, i32 2
  %41 = load i64, i64* %up_rxcnt, align 8, !tbaa !204
  %add139 = add i64 %41, %conv137
  store i64 %add139, i64* %up_rxcnt, align 8, !tbaa !204
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 28
  %42 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock, i32 0, i32 0
  %rlock.i1 = bitcast %union.anon.1* %42 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock.i1) #7
  %port140 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  call void @tty_flip_buffer_push(%struct.tty_port* %port140)
  %slock141 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 28
  %43 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock141, i32 0, i32 0
  %rlock.i = bitcast %union.anon.1* %43 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_transmit_chars(%struct.tty_struct* %tty, %struct.mxser_port* %port) #4 {
entry:
  %x_char = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 10
  %0 = load i32, i32* %x_char, align 8, !tbaa !85
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %x_char1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 10
  %1 = load i32, i32* %x_char1, align 8, !tbaa !85
  %conv = trunc i32 %1 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !17
  %add = add i64 %2, 0
  %conv2 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv, i32 %conv2)
  %x_char3 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 10
  store i32 0, i32* %x_char3, align 8, !tbaa !85
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %3 = load i32, i32* %index, align 8, !tbaa !54
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [32 x i64], [32 x i64]* getelementptr inbounds (%struct.mxser_log, %struct.mxser_log* @mxvar_log, i32 0, i32 2), i64 0, i64 %idxprom
  %4 = load i64, i64* %arrayidx, align 8, !tbaa !66
  %inc = add i64 %4, 1
  store i64 %inc, i64* %arrayidx, align 8, !tbaa !66
  %mon_data = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 27
  %txcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data, i32 0, i32 1
  %5 = load i64, i64* %txcnt, align 8, !tbaa !76
  %inc4 = add i64 %5, 1
  store i64 %inc4, i64* %txcnt, align 8, !tbaa !76
  %mon_data5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 27
  %up_txcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data5, i32 0, i32 3
  %6 = load i64, i64* %up_txcnt, align 8, !tbaa !205
  %inc6 = add i64 %6, 1
  store i64 %inc6, i64* %up_txcnt, align 8, !tbaa !205
  %icount = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %tx = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount, i32 0, i32 4
  %7 = load i32, i32* %tx, align 8, !tbaa !206
  %inc7 = add i32 %7, 1
  store i32 %inc7, i32* %tx, align 8, !tbaa !206
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %port8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port8, i32 0, i32 15
  %8 = load i8*, i8** %xmit_buf, align 8, !tbaa !64
  %cmp = icmp eq i8* %8, null
  br i1 %cmp, label %cleanup.cont, label %if.end11

if.end11:                                         ; preds = %if.end
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %9 = load i32, i32* %xmit_cnt, align 4, !tbaa !65
  %cmp12 = icmp sle i32 %9, 0
  br i1 %cmp12, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end11
  %stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 24
  %bf.load = load i8, i8* %stopped, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i64
  %conv14 = trunc i64 %bf.cast to i32
  %tobool15 = icmp ne i32 %conv14, 0
  br i1 %tobool15, label %if.then22, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %lor.lhs.false
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 26
  %10 = load i32, i32* %hw_stopped, align 8, !tbaa !68
  %tobool17 = icmp ne i32 %10, 0
  br i1 %tobool17, label %land.lhs.true, label %if.end28

land.lhs.true:                                    ; preds = %lor.lhs.false16
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 9
  %11 = load i32, i32* %type, align 4, !tbaa !46
  %cmp18 = icmp ne i32 %11, 4
  br i1 %cmp18, label %land.lhs.true20, label %if.end28

land.lhs.true20:                                  ; preds = %land.lhs.true
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %12 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !43
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %12, i32 0, i32 5
  %13 = load i32, i32* %chip_flag, align 8, !tbaa !10
  %tobool21 = icmp ne i32 %13, 0
  br i1 %tobool21, label %if.end28, label %if.then22

if.then22:                                        ; preds = %land.lhs.true20, %lor.lhs.false, %if.end11
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %14 = load i32, i32* %IER, align 4, !tbaa !69
  %and = and i32 %14, -3
  store i32 %and, i32* %IER, align 4, !tbaa !69
  %IER23 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %15 = load i32, i32* %IER23, align 4, !tbaa !69
  %conv24 = trunc i32 %15 to i8
  %ioaddr25 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %16 = load i64, i64* %ioaddr25, align 8, !tbaa !17
  %add26 = add i64 %16, 1
  %conv27 = trunc i64 %add26 to i32
  call void @outb(i8 zeroext %conv24, i32 %conv27)
  br label %cleanup.cont

if.end28:                                         ; preds = %land.lhs.true20, %land.lhs.true, %lor.lhs.false16
  %xmit_cnt29 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %17 = load i32, i32* %xmit_cnt29, align 4, !tbaa !65
  %xmit_fifo_size = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 21
  %18 = load i32, i32* %xmit_fifo_size, align 8, !tbaa !88
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end28
  %count.0 = phi i32 [ %18, %if.end28 ], [ %dec48, %do.cond ]
  %port30 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %xmit_buf31 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port30, i32 0, i32 15
  %19 = load i8*, i8** %xmit_buf31, align 8, !tbaa !64
  %xmit_tail = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 23
  %20 = load i32, i32* %xmit_tail, align 8, !tbaa !87
  %inc32 = add nsw i32 %20, 1
  store i32 %inc32, i32* %xmit_tail, align 8, !tbaa !87
  %idxprom33 = sext i32 %20 to i64
  %arrayidx34 = getelementptr inbounds i8, i8* %19, i64 %idxprom33
  %21 = load i8, i8* %arrayidx34, align 1, !tbaa !52
  %ioaddr35 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %22 = load i64, i64* %ioaddr35, align 8, !tbaa !17
  %add36 = add i64 %22, 0
  %conv37 = trunc i64 %add36 to i32
  call void @outb(i8 zeroext %21, i32 %conv37)
  %xmit_tail38 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 23
  %23 = load i32, i32* %xmit_tail38, align 8, !tbaa !87
  %conv39 = sext i32 %23 to i64
  %and40 = and i64 %conv39, 4095
  %conv41 = trunc i64 %and40 to i32
  %xmit_tail42 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 23
  store i32 %conv41, i32* %xmit_tail42, align 8, !tbaa !87
  %xmit_cnt43 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %24 = load i32, i32* %xmit_cnt43, align 4, !tbaa !65
  %dec = add nsw i32 %24, -1
  store i32 %dec, i32* %xmit_cnt43, align 4, !tbaa !65
  %cmp44 = icmp sle i32 %dec, 0
  br i1 %cmp44, label %do.end, label %do.cond

do.cond:                                          ; preds = %do.body
  %dec48 = add nsw i32 %count.0, -1
  %cmp49 = icmp sgt i32 %dec48, 0
  br i1 %cmp49, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond, %do.body
  %xmit_cnt51 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %25 = load i32, i32* %xmit_cnt51, align 4, !tbaa !65
  %sub = sub nsw i32 %17, %25
  %conv52 = sext i32 %sub to i64
  %index53 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %26 = load i32, i32* %index53, align 8, !tbaa !54
  %idxprom54 = sext i32 %26 to i64
  %arrayidx55 = getelementptr inbounds [32 x i64], [32 x i64]* getelementptr inbounds (%struct.mxser_log, %struct.mxser_log* @mxvar_log, i32 0, i32 2), i64 0, i64 %idxprom54
  %27 = load i64, i64* %arrayidx55, align 8, !tbaa !66
  %add56 = add i64 %27, %conv52
  store i64 %add56, i64* %arrayidx55, align 8, !tbaa !66
  %xmit_cnt57 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %28 = load i32, i32* %xmit_cnt57, align 4, !tbaa !65
  %sub58 = sub nsw i32 %17, %28
  %conv59 = sext i32 %sub58 to i64
  %mon_data60 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 27
  %txcnt61 = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data60, i32 0, i32 1
  %29 = load i64, i64* %txcnt61, align 8, !tbaa !76
  %add62 = add i64 %29, %conv59
  store i64 %add62, i64* %txcnt61, align 8, !tbaa !76
  %xmit_cnt63 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %30 = load i32, i32* %xmit_cnt63, align 4, !tbaa !65
  %sub64 = sub nsw i32 %17, %30
  %conv65 = sext i32 %sub64 to i64
  %mon_data66 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 27
  %up_txcnt67 = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data66, i32 0, i32 3
  %31 = load i64, i64* %up_txcnt67, align 8, !tbaa !205
  %add68 = add i64 %31, %conv65
  store i64 %add68, i64* %up_txcnt67, align 8, !tbaa !205
  %xmit_cnt69 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %32 = load i32, i32* %xmit_cnt69, align 4, !tbaa !65
  %sub70 = sub nsw i32 %17, %32
  %icount71 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %tx72 = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount71, i32 0, i32 4
  %33 = load i32, i32* %tx72, align 8, !tbaa !206
  %add73 = add i32 %33, %sub70
  store i32 %add73, i32* %tx72, align 8, !tbaa !206
  %xmit_cnt74 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %34 = load i32, i32* %xmit_cnt74, align 4, !tbaa !65
  %cmp75 = icmp slt i32 %34, 256
  br i1 %cmp75, label %if.then77, label %if.end78

if.then77:                                        ; preds = %do.end
  call void @tty_wakeup(%struct.tty_struct* %tty)
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %do.end
  %xmit_cnt79 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %35 = load i32, i32* %xmit_cnt79, align 4, !tbaa !65
  %cmp80 = icmp sle i32 %35, 0
  br i1 %cmp80, label %if.then82, label %cleanup.cont

if.then82:                                        ; preds = %if.end78
  %IER83 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %36 = load i32, i32* %IER83, align 4, !tbaa !69
  %and84 = and i32 %36, -3
  store i32 %and84, i32* %IER83, align 4, !tbaa !69
  %IER85 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %37 = load i32, i32* %IER85, align 4, !tbaa !69
  %conv86 = trunc i32 %37 to i8
  %ioaddr87 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %38 = load i64, i64* %ioaddr87, align 8, !tbaa !17
  %add88 = add i64 %38, 1
  %conv89 = trunc i64 %add88 to i32
  call void @outb(i8 zeroext %conv86, i32 %conv89)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then82, %if.end78, %if.then22, %if.end, %if.then
  ret void
}

declare void @_raw_spin_lock(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @tty_insert_flip_char(%struct.tty_port* %port, i8 zeroext %ch, i8 signext %flag) #2 {
entry:
  %ch.addr = alloca i8, align 1
  %flag.addr = alloca i8, align 1
  store i8 %ch, i8* %ch.addr, align 1, !tbaa !52
  store i8 %flag, i8* %flag.addr, align 1, !tbaa !52
  %buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 0
  %tail = getelementptr inbounds %struct.tty_bufhead, %struct.tty_bufhead* %buf, i32 0, i32 8
  %0 = load %struct.tty_buffer*, %struct.tty_buffer** %tail, align 8, !tbaa !207
  %flags = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 5
  %1 = load i32, i32* %flags, align 8, !tbaa !208
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  %2 = load i8, i8* %flag.addr, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  %3 = select i1 %tobool, i1 %cmp, i1 false
  %land.ext = zext i1 %3 to i32
  %tobool2 = icmp ne i32 %land.ext, 0
  br i1 %tobool2, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %used = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 1
  %4 = load i32, i32* %used, align 8, !tbaa !209
  %size = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 2
  %5 = load i32, i32* %size, align 4, !tbaa !210
  %cmp3 = icmp slt i32 %4, %5
  br i1 %cmp3, label %if.then, label %if.end12

if.then:                                          ; preds = %land.lhs.true
  %flags5 = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 5
  %6 = load i32, i32* %flags5, align 8, !tbaa !208
  %neg = xor i32 %6, -1
  %and6 = and i32 %neg, 1
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  %7 = load i8, i8* %flag.addr, align 1, !tbaa !52
  %used9 = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 1
  %8 = load i32, i32* %used9, align 8, !tbaa !209
  %call = call i8* @flag_buf_ptr(%struct.tty_buffer* %0, i32 %8)
  store i8 %7, i8* %call, align 1, !tbaa !52
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.then
  %9 = load i8, i8* %ch.addr, align 1, !tbaa !52
  %used10 = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 1
  %10 = load i32, i32* %used10, align 8, !tbaa !209
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %used10, align 8, !tbaa !209
  %call11 = call i8* @char_buf_ptr(%struct.tty_buffer* %0, i32 %10)
  store i8 %9, i8* %call11, align 1, !tbaa !52
  br label %cleanup

if.end12:                                         ; preds = %land.lhs.true, %entry
  %call13 = call i32 @tty_insert_flip_string_flags(%struct.tty_port* %port, i8* %ch.addr, i8* %flag.addr, i64 1)
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.end
  ret void
}

declare void @do_SAK(%struct.tty_struct*) #3

declare void @tty_flip_buffer_push(%struct.tty_port*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @flag_buf_ptr(%struct.tty_buffer* %b, i32 %ofs) #2 {
entry:
  %call = call i8* @char_buf_ptr(%struct.tty_buffer* %b, i32 %ofs)
  %size = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %b, i32 0, i32 2
  %0 = load i32, i32* %size, align 4, !tbaa !210
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr inbounds i8, i8* %call, i64 %idx.ext
  ret i8* %add.ptr
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @char_buf_ptr(%struct.tty_buffer* %b, i32 %ofs) #2 {
entry:
  %data = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %b, i32 0, i32 6
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %data, i32 0, i32 0
  %0 = bitcast i64* %arraydecay to i8*
  %idx.ext = sext i32 %ofs to i64
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %idx.ext
  ret i8* %add.ptr
}

declare i32 @tty_insert_flip_string_flags(%struct.tty_port*, i8*, i8*, i64) #3

declare void @_raw_spin_unlock(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @mxser_release_vector(%struct.mxser_board* %brd) #4 {
entry:
  %call = call zeroext i1 @mxser_overlapping_vector(%struct.mxser_board* %brd)
  br i1 %call, label %return, label %if.end

if.end:                                           ; preds = %entry
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 3
  %0 = load i64, i64* %vector, align 8, !tbaa !37
  call void @__release_region(%struct.resource* @ioport_resource, i64 %0, i64 1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_probe(%struct.pci_dev* %pdev, %struct.pci_device_id* %ent) #4 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx, i32 0, i32 2
  %0 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !2
  %cmp2 = icmp eq %struct.mxser_cardinfo* %0, null
  br i1 %cmp2, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %cmp3 = icmp uge i32 %i.0, 4
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %for.end
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end5:                                          ; preds = %for.end
  %idxprom6 = zext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom6
  %mul = mul i32 %i.0, 8
  %idx = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 0
  store i32 %mul, i32* %idx, align 8, !tbaa !211
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %call = call i32 @pci_enable_device(%struct.pci_dev* %pdev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end5
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end12:                                         ; preds = %if.end5
  %resource = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 38
  %arrayidx13 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource, i64 0, i64 2
  %start = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx13, i32 0, i32 0
  %1 = load i64, i64* %start, align 8, !tbaa !212
  %call14 = call i32 @pci_request_region(%struct.pci_dev* %pdev, i32 2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.14, i32 0, i32 0))
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %err_dis, label %if.end17

if.end17:                                         ; preds = %if.end12
  %driver_data18 = getelementptr inbounds %struct.pci_device_id, %struct.pci_device_id* %ent, i32 0, i32 6
  %2 = load i64, i64* %driver_data18, align 8, !tbaa !214
  %arrayidx19 = getelementptr inbounds [32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 %2
  %info20 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  store %struct.mxser_cardinfo* %arrayidx19, %struct.mxser_cardinfo** %info20, align 8, !tbaa !2
  br label %for.cond21

for.cond21:                                       ; preds = %for.body25, %if.end17
  %i.1 = phi i32 [ 0, %if.end17 ], [ %inc31, %for.body25 ]
  %info22 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %3 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info22, align 8, !tbaa !2
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %3, i32 0, i32 1
  %4 = load i32, i32* %nports, align 8, !tbaa !11
  %cmp23 = icmp ult i32 %i.1, %4
  br i1 %cmp23, label %for.body25, label %for.end32

for.body25:                                       ; preds = %for.cond21
  %mul26 = mul i32 8, %i.1
  %conv27 = zext i32 %mul26 to i64
  %add = add i64 %1, %conv27
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom28 = zext i32 %i.1 to i64
  %arrayidx29 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom28
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx29, i32 0, i32 2
  store i64 %add, i64* %ioaddr, align 8, !tbaa !17
  %inc31 = add i32 %i.1, 1
  br label %for.cond21

for.end32:                                        ; preds = %for.cond21
  %resource33 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 38
  %arrayidx34 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource33, i64 0, i64 3
  %start35 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx34, i32 0, i32 0
  %5 = load i64, i64* %start35, align 8, !tbaa !212
  %call36 = call i32 @pci_request_region(%struct.pci_dev* %pdev, i32 3, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.50, i32 0, i32 0))
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %err_zero, label %if.end39

if.end39:                                         ; preds = %for.end32
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 3
  store i64 %5, i64* %vector, align 8, !tbaa !37
  %irq = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 37
  %6 = load i32, i32* %irq, align 4, !tbaa !216
  %irq40 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 1
  store i32 %6, i32* %irq40, align 4, !tbaa !16
  %ports41 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %arrayidx42 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports41, i64 0, i64 0
  %ioaddr43 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx42, i32 0, i32 2
  %7 = load i64, i64* %ioaddr43, align 8, !tbaa !17
  %call44 = call i32 @CheckIsMoxaMust(i64 %7)
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 5
  store i32 %call44, i32* %chip_flag, align 8, !tbaa !10
  %uart_type = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 6
  store i32 4, i32* %uart_type, align 4, !tbaa !41
  %vector_mask = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 4
  store i64 0, i64* %vector_mask, align 8, !tbaa !38
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc82, %if.end39
  %i.2 = phi i32 [ 0, %if.end39 ], [ %inc83, %for.inc82 ]
  %info46 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %8 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info46, align 8, !tbaa !2
  %nports47 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %8, i32 0, i32 1
  %9 = load i32, i32* %nports47, align 8, !tbaa !11
  %cmp48 = icmp ult i32 %i.2, %9
  br i1 %cmp48, label %for.body50, label %for.end84

for.body50:                                       ; preds = %for.cond45
  br label %for.cond51

for.cond51:                                       ; preds = %for.inc79, %for.body50
  %j.0 = phi i32 [ 0, %for.body50 ], [ %inc80, %for.inc79 ]
  %conv52 = zext i32 %j.0 to i64
  %cmp53 = icmp ult i64 %conv52, 3
  br i1 %cmp53, label %for.body55, label %for.inc82

for.body55:                                       ; preds = %for.cond51
  %idxprom56 = zext i32 %j.0 to i64
  %arrayidx57 = getelementptr inbounds [3 x %struct.anon.60], [3 x %struct.anon.60]* @Gpci_uart_info, i64 0, i64 %idxprom56
  %type = getelementptr inbounds %struct.anon.60, %struct.anon.60* %arrayidx57, i32 0, i32 0
  %10 = load i32, i32* %type, align 8, !tbaa !188
  %chip_flag58 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 5
  %11 = load i32, i32* %chip_flag58, align 8, !tbaa !10
  %cmp59 = icmp eq i32 %10, %11
  br i1 %cmp59, label %if.then61, label %for.inc79

if.then61:                                        ; preds = %for.body55
  %idxprom62 = zext i32 %j.0 to i64
  %arrayidx63 = getelementptr inbounds [3 x %struct.anon.60], [3 x %struct.anon.60]* @Gpci_uart_info, i64 0, i64 %idxprom62
  %max_baud = getelementptr inbounds %struct.anon.60, %struct.anon.60* %arrayidx63, i32 0, i32 7
  %12 = load i64, i64* %max_baud, align 8, !tbaa !230
  %conv64 = trunc i64 %12 to i32
  %ports65 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom66 = zext i32 %i.2 to i64
  %arrayidx67 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports65, i64 0, i64 %idxprom66
  %max_baud68 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx67, i32 0, i32 4
  store i32 %conv64, i32* %max_baud68, align 8, !tbaa !40
  %info69 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %13 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info69, align 8, !tbaa !2
  %flags = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %13, i32 0, i32 2
  %14 = load i32, i32* %flags, align 4, !tbaa !13
  %and70 = and i32 %14, 1
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %if.then72, label %for.inc82

if.then72:                                        ; preds = %if.then61
  %ports73 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom74 = zext i32 %i.2 to i64
  %arrayidx75 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports73, i64 0, i64 %idxprom74
  %max_baud76 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx75, i32 0, i32 4
  store i32 921600, i32* %max_baud76, align 8, !tbaa !40
  br label %for.inc82

for.inc79:                                        ; preds = %for.body55
  %inc80 = add i32 %j.0, 1
  br label %for.cond51

for.inc82:                                        ; preds = %if.then72, %if.then61, %for.cond51
  %inc83 = add i32 %i.2, 1
  br label %for.cond45

for.end84:                                        ; preds = %for.cond45
  %chip_flag85 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 5
  %15 = load i32, i32* %chip_flag85, align 8, !tbaa !10
  %cmp86 = icmp eq i32 %15, 2
  br i1 %cmp86, label %if.then88, label %if.end115

if.then88:                                        ; preds = %for.end84
  br label %for.cond89

for.cond89:                                       ; preds = %for.body94, %if.then88
  %i.3 = phi i32 [ 0, %if.then88 ], [ %inc109, %for.body94 ]
  %info90 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %16 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info90, align 8, !tbaa !2
  %nports91 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %16, i32 0, i32 1
  %17 = load i32, i32* %nports91, align 8, !tbaa !11
  %cmp92 = icmp ult i32 %i.3, %17
  br i1 %cmp92, label %for.body94, label %for.end110

for.body94:                                       ; preds = %for.cond89
  %cmp95 = icmp ult i32 %i.3, 4
  %.sink = select i1 %cmp95, i64 4, i64 12
  %add102 = add i64 %5, %.sink
  %ports103 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom104 = zext i32 %i.3 to i64
  %arrayidx105 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports103, i64 0, i64 %idxprom104
  %opmode_ioaddr106 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx105, i32 0, i32 3
  store i64 %add102, i64* %opmode_ioaddr106, align 8, !tbaa !71
  %inc109 = add i32 %i.3, 1
  br label %for.cond89

for.end110:                                       ; preds = %for.cond89
  %add111 = add i64 %5, 4
  %conv112 = trunc i64 %add111 to i32
  call void @outb(i8 zeroext 0, i32 %conv112)
  %add113 = add i64 %5, 12
  %conv114 = trunc i64 %add113 to i32
  call void @outb(i8 zeroext 0, i32 %conv114)
  br label %if.end115

if.end115:                                        ; preds = %for.end110, %for.end84
  br label %for.cond116

for.cond116:                                      ; preds = %for.body121, %if.end115
  %i.4 = phi i32 [ 0, %if.end115 ], [ %inc128, %for.body121 ]
  %info117 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %18 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info117, align 8, !tbaa !2
  %nports118 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %18, i32 0, i32 1
  %19 = load i32, i32* %nports118, align 8, !tbaa !11
  %cmp119 = icmp ult i32 %i.4, %19
  br i1 %cmp119, label %for.body121, label %for.end129

for.body121:                                      ; preds = %for.cond116
  %shl = shl i32 1, %i.4
  %conv122 = sext i32 %shl to i64
  %vector_mask123 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 4
  %20 = load i64, i64* %vector_mask123, align 8, !tbaa !38
  %or = or i64 %20, %conv122
  store i64 %or, i64* %vector_mask123, align 8, !tbaa !38
  %ports124 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom125 = zext i32 %i.4 to i64
  %arrayidx126 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports124, i64 0, i64 %idxprom125
  %baud_base = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx126, i32 0, i32 8
  store i32 921600, i32* %baud_base, align 8, !tbaa !39
  %inc128 = add i32 %i.4, 1
  br label %for.cond116

for.end129:                                       ; preds = %for.cond116
  %call130 = call i32 @mxser_initbrd(%struct.mxser_board* %arrayidx7)
  %tobool131 = icmp ne i32 %call130, 0
  br i1 %tobool131, label %err_rel3, label %if.end133

if.end133:                                        ; preds = %for.end129
  br label %for.cond134

for.cond134:                                      ; preds = %for.inc160, %if.end133
  %i.5 = phi i32 [ 0, %if.end133 ], [ %inc161, %for.inc160 ]
  %info135 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %21 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info135, align 8, !tbaa !2
  %nports136 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %21, i32 0, i32 1
  %22 = load i32, i32* %nports136, align 8, !tbaa !11
  %cmp137 = icmp ult i32 %i.5, %22
  br i1 %cmp137, label %for.body139, label %for.end162

for.body139:                                      ; preds = %for.cond134
  %ports140 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom141 = zext i32 %i.5 to i64
  %arrayidx142 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports140, i64 0, i64 %idxprom141
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx142, i32 0, i32 0
  %23 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !9
  %idx143 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 0
  %24 = load i32, i32* %idx143, align 8, !tbaa !211
  %add144 = add i32 %24, %i.5
  %dev145 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %call146 = call %struct.device* @tty_port_register_device(%struct.tty_port* %port, %struct.tty_driver* %23, i32 %add144, %struct.device* %dev145)
  %25 = bitcast %struct.device* %call146 to i8*
  %call147 = call zeroext i1 @IS_ERR(i8* %25)
  br i1 %call147, label %if.then148, label %for.inc160

if.then148:                                       ; preds = %for.body139
  %26 = bitcast %struct.device* %call146 to i8*
  %call149 = call i64 @PTR_ERR(i8* %26)
  %conv150 = trunc i64 %call149 to i32
  br label %for.cond151

for.cond151:                                      ; preds = %for.body154, %if.then148
  %i.6 = phi i32 [ %i.5, %if.then148 ], [ %dec, %for.body154 ]
  %cmp152 = icmp ugt i32 %i.6, 0
  br i1 %cmp152, label %for.body154, label %err_relbrd

for.body154:                                      ; preds = %for.cond151
  %27 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !9
  %idx155 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 0
  %28 = load i32, i32* %idx155, align 8, !tbaa !211
  %add156 = add i32 %28, %i.6
  %sub = sub i32 %add156, 1
  call void @tty_unregister_device(%struct.tty_driver* %27, i32 %sub)
  %dec = add i32 %i.6, -1
  br label %for.cond151

for.inc160:                                       ; preds = %for.body139
  %inc161 = add i32 %i.5, 1
  br label %for.cond134

for.end162:                                       ; preds = %for.cond134
  %29 = bitcast %struct.mxser_board* %arrayidx7 to i8*
  call void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %29)
  br label %cleanup

err_relbrd:                                       ; preds = %for.cond151
  br label %for.cond163

for.cond163:                                      ; preds = %for.body168, %err_relbrd
  %i.7 = phi i32 [ 0, %err_relbrd ], [ %inc174, %for.body168 ]
  %info164 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %30 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info164, align 8, !tbaa !2
  %nports165 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %30, i32 0, i32 1
  %31 = load i32, i32* %nports165, align 8, !tbaa !11
  %cmp166 = icmp ult i32 %i.7, %31
  br i1 %cmp166, label %for.body168, label %for.end175

for.body168:                                      ; preds = %for.cond163
  %ports169 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom170 = zext i32 %i.7 to i64
  %arrayidx171 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports169, i64 0, i64 %idxprom170
  %port172 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx171, i32 0, i32 0
  call void @tty_port_destroy(%struct.tty_port* %port172)
  %inc174 = add i32 %i.7, 1
  br label %for.cond163

for.end175:                                       ; preds = %for.cond163
  %irq176 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 1
  %32 = load i32, i32* %irq176, align 4, !tbaa !16
  %33 = bitcast %struct.mxser_board* %arrayidx7 to i8*
  call void @free_irq(i32 %32, i8* %33)
  br label %err_rel3

err_rel3:                                         ; preds = %for.end175, %for.end129
  %retval1.0 = phi i32 [ %conv150, %for.end175 ], [ %call130, %for.end129 ]
  call void @pci_release_region(%struct.pci_dev* %pdev, i32 3)
  br label %err_zero

err_zero:                                         ; preds = %err_rel3, %for.end32
  %retval1.1 = phi i32 [ %retval1.0, %err_rel3 ], [ %call36, %for.end32 ]
  %info177 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  store %struct.mxser_cardinfo* null, %struct.mxser_cardinfo** %info177, align 8, !tbaa !2
  call void @pci_release_region(%struct.pci_dev* %pdev, i32 2)
  br label %err_dis

err_dis:                                          ; preds = %err_zero, %if.end12
  %retval1.2 = phi i32 [ %retval1.1, %err_zero ], [ %call14, %if.end12 ]
  call void @pci_disable_device(%struct.pci_dev* %pdev)
  br label %cleanup

cleanup:                                          ; preds = %err_dis, %for.end162, %if.then10, %if.then4
  %retval.0 = phi i32 [ 0, %for.end162 ], [ -22, %if.then4 ], [ %call, %if.then10 ], [ %retval1.2, %err_dis ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @mxser_remove(%struct.pci_dev* %pdev) #4 {
entry:
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %pdev)
  %0 = bitcast i8* %call to %struct.mxser_board*
  call void @mxser_board_remove(%struct.mxser_board* %0)
  call void @pci_release_region(%struct.pci_dev* %pdev, i32 2)
  call void @pci_release_region(%struct.pci_dev* %pdev, i32 3)
  call void @pci_disable_device(%struct.pci_dev* %pdev)
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %0, i32 0, i32 2
  store %struct.mxser_cardinfo* null, %struct.mxser_cardinfo** %info, align 8, !tbaa !2
  ret void
}

declare void @dev_err(%struct.device*, i8*, ...) #3

declare void @_dev_info(%struct.device*, i8*, ...) #3

declare i32 @pci_enable_device(%struct.pci_dev*) #3

declare i32 @pci_request_region(%struct.pci_dev*, i32, i8*) #3

; Function Attrs: nounwind uwtable
define internal i32 @CheckIsMoxaMust(i64 %io) #4 {
entry:
  %hwid = alloca i8, align 1
  %add = add i64 %io, 3
  %conv = trunc i64 %add to i32
  call void @outb(i8 zeroext 0, i32 %conv)
  call void @mxser_disable_must_enchance_mode(i64 %io)
  %add1 = add i64 %io, 4
  %conv2 = trunc i64 %add1 to i32
  %call = call zeroext i8 @inb(i32 %conv2)
  %add3 = add i64 %io, 4
  %conv4 = trunc i64 %add3 to i32
  call void @outb(i8 zeroext 0, i32 %conv4)
  call void @mxser_set_must_xon1_value(i64 %io, i8 zeroext 17)
  %add5 = add i64 %io, 4
  %conv6 = trunc i64 %add5 to i32
  %call7 = call zeroext i8 @inb(i32 %conv6)
  store i8 %call7, i8* %hwid, align 1, !tbaa !52
  %conv8 = zext i8 %call7 to i32
  %cmp = icmp ne i32 %conv8, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %add10 = add i64 %io, 4
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @mxser_get_must_hardware_id(i64 %io, i8* %hwid)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 1, %if.end ], [ %inc, %for.inc ]
  %conv12 = sext i32 %i.0 to i64
  %cmp13 = icmp ult i64 %conv12, 3
  br i1 %cmp13, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %0 = load i8, i8* %hwid, align 1, !tbaa !52
  %conv15 = zext i8 %0 to i32
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.anon.60], [3 x %struct.anon.60]* @Gpci_uart_info, i64 0, i64 %idxprom
  %type = getelementptr inbounds %struct.anon.60, %struct.anon.60* %arrayidx, i32 0, i32 0
  %1 = load i32, i32* %type, align 8, !tbaa !188
  %cmp16 = icmp eq i32 %conv15, %1
  br i1 %cmp16, label %if.then18, label %for.inc

if.then18:                                        ; preds = %for.body
  %2 = load i8, i8* %hwid, align 1, !tbaa !52
  %conv19 = zext i8 %2 to i32
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then18, %for.cond, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %conv19, %if.then18 ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %data) #2 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

declare void @pci_release_region(%struct.pci_dev*, i32) #3

declare void @pci_disable_device(%struct.pci_dev*) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_disable_must_enchance_mode(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -17
  %conv7 = trunc i32 %and to i8
  %add8 = add i64 %baseio, 2
  %conv9 = trunc i64 %add8 to i32
  call void @outb(i8 zeroext %conv7, i32 %conv9)
  %add10 = add i64 %baseio, 3
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_get_must_hardware_id(i64 %baseio, i8* %pId) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -193
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %or = or i32 %conv8, 128
  %conv9 = trunc i32 %or to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 5
  %conv13 = trunc i64 %add12 to i32
  %call14 = call zeroext i8 @inb(i32 %conv13)
  store i8 %call14, i8* %pId, align 1, !tbaa !52
  %add15 = add i64 %baseio, 3
  %conv16 = trunc i64 %add15 to i32
  call void @outb(i8 zeroext %call, i32 %conv16)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #2 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !231
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_get_drvdata(%struct.pci_dev* %pdev) #2 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 35
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal void @mxser_board_remove(%struct.mxser_board* %brd) #4 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %0 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !2
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %0, i32 0, i32 1
  %1 = load i32, i32* %nports, align 8, !tbaa !11
  %cmp = icmp ult i32 %i.0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !9
  %idx = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 0
  %3 = load i32, i32* %idx, align 8, !tbaa !211
  %add = add i32 %3, %i.0
  call void @tty_unregister_device(%struct.tty_driver* %2, i32 %add)
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx, i32 0, i32 0
  call void @tty_port_destroy(%struct.tty_port* %port)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %irq = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 1
  %4 = load i32, i32* %irq, align 4, !tbaa !16
  %5 = bitcast %struct.mxser_board* %brd to i8*
  call void @free_irq(i32 %4, i8* %5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #2 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !231
  ret i8* %0
}

declare void @pci_unregister_driver(%struct.pci_driver*) #3

declare i32 @"simpll__inlineasm$0"(i32, i32*)

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !7, i64 8}
!3 = !{!"mxser_board", !4, i64 0, !4, i64 4, !7, i64 8, !8, i64 16, !8, i64 24, !4, i64 32, !4, i64 36, !5, i64 40}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"any pointer", !5, i64 0}
!8 = !{!"long", !5, i64 0}
!9 = !{!7, !7, i64 0}
!10 = !{!3, !4, i64 32}
!11 = !{!12, !4, i64 8}
!12 = !{!"mxser_cardinfo", !7, i64 0, !4, i64 8, !4, i64 12}
!13 = !{!12, !4, i64 12}
!14 = !{!15, !15, i64 0}
!15 = !{!"short", !5, i64 0}
!16 = !{!3, !4, i64 4}
!17 = !{!18, !8, i64 984}
!18 = !{!"mxser_port", !19, i64 0, !7, i64 976, !8, i64 984, !8, i64 992, !4, i64 1000, !4, i64 1004, !4, i64 1008, !4, i64 1012, !4, i64 1016, !4, i64 1020, !4, i64 1024, !4, i64 1028, !4, i64 1032, !5, i64 1036, !5, i64 1037, !4, i64 1040, !5, i64 1044, !34, i64 1048, !4, i64 1092, !4, i64 1096, !4, i64 1100, !4, i64 1104, !4, i64 1108, !4, i64 1112, !4, i64 1116, !4, i64 1120, !35, i64 1124, !36, i64 1168, !26, i64 1208}
!19 = !{!"tty_port", !20, i64 0, !7, i64 312, !7, i64 320, !7, i64 328, !7, i64 336, !26, i64 344, !4, i64 416, !4, i64 420, !31, i64 424, !31, i64 512, !8, i64 600, !8, i64 608, !5, i64 616, !5, i64 616, !25, i64 624, !25, i64 784, !7, i64 944, !4, i64 952, !4, i64 956, !4, i64 960, !32, i64 964, !7, i64 968}
!20 = !{!"tty_bufhead", !7, i64 0, !21, i64 8, !25, i64 88, !28, i64 248, !29, i64 256, !30, i64 288, !28, i64 296, !4, i64 300, !7, i64 304}
!21 = !{!"work_struct", !22, i64 0, !23, i64 8, !7, i64 24, !24, i64 32}
!22 = !{!"", !8, i64 0}
!23 = !{!"list_head", !7, i64 0, !7, i64 8}
!24 = !{!"lockdep_map", !7, i64 0, !5, i64 8, !7, i64 24, !4, i64 32, !8, i64 40}
!25 = !{!"mutex", !22, i64 0, !26, i64 8, !27, i64 80, !23, i64 88, !7, i64 104, !24, i64 112}
!26 = !{!"spinlock", !5, i64 0}
!27 = !{!"optimistic_spin_queue", !28, i64 0}
!28 = !{!"", !4, i64 0}
!29 = !{!"tty_buffer", !5, i64 0, !4, i64 8, !4, i64 12, !4, i64 16, !4, i64 20, !4, i64 24, !5, i64 32}
!30 = !{!"llist_head", !7, i64 0}
!31 = !{!"__wait_queue_head", !26, i64 0, !23, i64 72}
!32 = !{!"kref", !33, i64 0}
!33 = !{!"refcount_struct", !28, i64 0}
!34 = !{!"async_icount", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12, !4, i64 16, !4, i64 20, !4, i64 24, !4, i64 28, !4, i64 32, !4, i64 36, !4, i64 40}
!35 = !{!"ktermios", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12, !5, i64 16, !5, i64 17, !4, i64 36, !4, i64 40}
!36 = !{!"mxser_mon", !8, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !4, i64 32, !5, i64 36}
!37 = !{!3, !8, i64 16}
!38 = !{!3, !8, i64 24}
!39 = !{!18, !4, i64 1016}
!40 = !{!18, !4, i64 1000}
!41 = !{!3, !4, i64 36}
!42 = !{!18, !7, i64 328}
!43 = !{!18, !7, i64 976}
!44 = !{!18, !5, i64 1036}
!45 = !{!18, !5, i64 1037}
!46 = !{!18, !4, i64 1020}
!47 = !{!18, !4, i64 1040}
!48 = !{!18, !4, i64 952}
!49 = !{!18, !4, i64 956}
!50 = !{i64 0, i64 4, !51, i64 4, i64 4, !51, i64 8, i64 4, !51, i64 12, i64 4, !51, i64 16, i64 1, !52, i64 17, i64 19, !52, i64 36, i64 4, !51, i64 40, i64 4, !51}
!51 = !{!4, !4, i64 0}
!52 = !{!5, !5, i64 0}
!53 = !{!18, !5, i64 1044}
!54 = !{!55, !4, i64 32}
!55 = !{!"tty_struct", !4, i64 0, !32, i64 4, !7, i64 8, !7, i64 16, !7, i64 24, !4, i64 32, !56, i64 40, !7, i64 208, !25, i64 216, !25, i64 376, !25, i64 536, !59, i64 696, !25, i64 856, !26, i64 1016, !26, i64 1088, !35, i64 1160, !35, i64 1204, !7, i64 1248, !5, i64 1256, !7, i64 1320, !7, i64 1328, !8, i64 1336, !4, i64 1344, !60, i64 1348, !8, i64 1356, !8, i64 1356, !8, i64 1360, !4, i64 1368, !8, i64 1372, !8, i64 1373, !8, i64 1376, !4, i64 1384, !4, i64 1388, !7, i64 1392, !7, i64 1400, !4, i64 1408, !31, i64 1416, !31, i64 1504, !21, i64 1592, !7, i64 1672, !7, i64 1680, !26, i64 1688, !23, i64 1760, !4, i64 1776, !7, i64 1784, !4, i64 1792, !21, i64 1800, !7, i64 1880}
!56 = !{!"ld_semaphore", !8, i64 0, !57, i64 8, !4, i64 80, !23, i64 88, !23, i64 104, !24, i64 120}
!57 = !{!"raw_spinlock", !58, i64 0, !4, i64 4, !4, i64 8, !7, i64 16, !24, i64 24}
!58 = !{!"qspinlock", !28, i64 0}
!59 = !{!"rw_semaphore", !22, i64 0, !23, i64 8, !57, i64 24, !27, i64 96, !7, i64 104, !24, i64 112}
!60 = !{!"winsize", !15, i64 0, !15, i64 2, !15, i64 4, !15, i64 6}
!61 = !{!55, !7, i64 1680}
!62 = !{!18, !4, i64 1120}
!63 = !{!55, !4, i64 1168}
!64 = !{!18, !7, i64 944}
!65 = !{!18, !4, i64 1116}
!66 = !{!8, !8, i64 0}
!67 = !{!18, !4, i64 1108}
!68 = !{!55, !4, i64 1368}
!69 = !{!18, !4, i64 1028}
!70 = !{i32 -2142443367}
!71 = !{!18, !8, i64 992}
!72 = !{i32 -2142441471}
!73 = !{i64 0, i64 4, !51, i64 4, i64 4, !51, i64 8, i64 4, !51, i64 12, i64 4, !51, i64 16, i64 4, !51, i64 20, i64 4, !51, i64 24, i64 4, !51, i64 28, i64 4, !51, i64 32, i64 4, !51, i64 36, i64 4, !51, i64 40, i64 4, !51}
!74 = !{i32 -2142437826}
!75 = !{!18, !8, i64 1168}
!76 = !{!18, !8, i64 1176}
!77 = !{i32 -2142436001}
!78 = !{!18, !5, i64 1204}
!79 = !{i32 -2142434391}
!80 = !{i32 -2142433135}
!81 = !{i32 -2142431258}
!82 = !{!35, !4, i64 8}
!83 = !{!35, !4, i64 0}
!84 = !{!55, !4, i64 1160}
!85 = !{!18, !4, i64 1024}
!86 = !{!18, !4, i64 1032}
!87 = !{!18, !4, i64 1112}
!88 = !{!18, !4, i64 1104}
!89 = !{!18, !4, i64 1092}
!90 = !{i32 -2146599579}
!91 = !{!92, !8, i64 11680}
!92 = !{!"task_struct", !93, i64 0, !8, i64 8, !7, i64 16, !28, i64 24, !4, i64 28, !4, i64 32, !94, i64 40, !4, i64 48, !4, i64 52, !4, i64 56, !8, i64 64, !7, i64 72, !4, i64 80, !4, i64 84, !4, i64 88, !4, i64 92, !4, i64 96, !4, i64 100, !7, i64 104, !95, i64 128, !101, i64 576, !7, i64 648, !102, i64 656, !105, i64 808, !4, i64 816, !4, i64 820, !4, i64 824, !106, i64 832, !8, i64 1856, !107, i64 1864, !23, i64 1872, !4, i64 1888, !108, i64 1896, !23, i64 1928, !109, i64 1944, !97, i64 1984, !7, i64 2008, !7, i64 2016, !110, i64 2024, !111, i64 2064, !4, i64 2084, !4, i64 2088, !4, i64 2092, !4, i64 2096, !8, i64 2104, !4, i64 2112, !4, i64 2116, !4, i64 2116, !4, i64 2116, !4, i64 2116, !4, i64 2120, !4, i64 2120, !4, i64 2120, !4, i64 2120, !4, i64 2120, !4, i64 2120, !4, i64 2120, !4, i64 2120, !8, i64 2128, !112, i64 2136, !4, i64 2184, !4, i64 2188, !7, i64 2192, !7, i64 2200, !23, i64 2208, !23, i64 2224, !7, i64 2240, !23, i64 2248, !23, i64 2264, !5, i64 2280, !23, i64 2352, !23, i64 2368, !7, i64 2384, !7, i64 2392, !7, i64 2400, !98, i64 2408, !98, i64 2416, !98, i64 2424, !113, i64 2432, !8, i64 2520, !8, i64 2528, !98, i64 2536, !98, i64 2544, !8, i64 2552, !8, i64 2560, !114, i64 2568, !5, i64 2592, !7, i64 2640, !7, i64 2648, !7, i64 2656, !5, i64 2664, !7, i64 2680, !115, i64 2688, !116, i64 2696, !8, i64 2712, !7, i64 2720, !7, i64 2728, !7, i64 2736, !7, i64 2744, !7, i64 2752, !117, i64 2760, !117, i64 2768, !117, i64 2776, !118, i64 2784, !8, i64 2808, !8, i64 2816, !4, i64 2824, !7, i64 2832, !7, i64 2840, !28, i64 2848, !4, i64 2852, !119, i64 2856, !4, i64 2872, !4, i64 2876, !26, i64 2880, !57, i64 2952, !120, i64 3024, !121, i64 3032, !7, i64 3040, !7, i64 3048, !7, i64 3056, !4, i64 3064, !8, i64 3072, !8, i64 3080, !4, i64 3088, !4, i64 3092, !4, i64 3096, !4, i64 3100, !8, i64 3104, !8, i64 3112, !4, i64 3120, !4, i64 3124, !4, i64 3128, !4, i64 3132, !98, i64 3136, !4, i64 3144, !4, i64 3148, !5, i64 3152, !4, i64 5840, !4, i64 5844, !7, i64 5848, !7, i64 5856, !7, i64 5864, !7, i64 5872, !7, i64 5880, !7, i64 5888, !8, i64 5896, !7, i64 5904, !122, i64 5912, !98, i64 5968, !98, i64 5976, !98, i64 5984, !117, i64 5992, !123, i64 6120, !4, i64 6176, !4, i64 6180, !7, i64 6184, !23, i64 6192, !4, i64 6208, !7, i64 6216, !7, i64 6224, !23, i64 6232, !7, i64 6248, !5, i64 6256, !25, i64 6272, !23, i64 6432, !7, i64 6448, !15, i64 6456, !15, i64 6458, !4, i64 6460, !4, i64 6464, !4, i64 6468, !4, i64 6472, !8, i64 6480, !98, i64 6488, !98, i64 6496, !98, i64 6504, !124, i64 6512, !23, i64 6528, !7, i64 6544, !7, i64 6552, !8, i64 6560, !5, i64 6568, !8, i64 6592, !125, i64 6600, !124, i64 7632, !7, i64 7648, !126, i64 7656, !7, i64 7672, !4, i64 7680, !4, i64 7684, !4, i64 7688, !8, i64 7696, !4, i64 7704, !5, i64 7712, !98, i64 11552, !98, i64 11560, !4, i64 11568, !4, i64 11572, !7, i64 11576, !98, i64 11584, !28, i64 11592, !28, i64 11596, !8, i64 11600, !8, i64 11608, !5, i64 11616, !4, i64 11620, !7, i64 11624, !7, i64 11632, !7, i64 11640, !4, i64 11648, !4, i64 11652, !4, i64 11656, !7, i64 11664, !4, i64 11672, !4, i64 11676, !8, i64 11680, !4, i64 11688, !7, i64 11696, !28, i64 11704, !127, i64 11712}
!93 = !{!"thread_info", !8, i64 0}
!94 = !{!"llist_node", !7, i64 0}
!95 = !{!"sched_entity", !96, i64 0, !97, i64 16, !23, i64 40, !4, i64 56, !98, i64 64, !98, i64 72, !98, i64 80, !98, i64 88, !98, i64 96, !99, i64 104, !4, i64 320, !7, i64 328, !7, i64 336, !7, i64 344, !100, i64 384}
!96 = !{!"load_weight", !8, i64 0, !4, i64 8}
!97 = !{!"rb_node", !8, i64 0, !7, i64 8, !7, i64 16}
!98 = !{!"long long", !5, i64 0}
!99 = !{!"sched_statistics", !98, i64 0, !98, i64 8, !98, i64 16, !98, i64 24, !98, i64 32, !98, i64 40, !98, i64 48, !98, i64 56, !98, i64 64, !98, i64 72, !98, i64 80, !98, i64 88, !98, i64 96, !98, i64 104, !98, i64 112, !98, i64 120, !98, i64 128, !98, i64 136, !98, i64 144, !98, i64 152, !98, i64 160, !98, i64 168, !98, i64 176, !98, i64 184, !98, i64 192, !98, i64 200, !98, i64 208}
!100 = !{!"sched_avg", !98, i64 0, !98, i64 8, !4, i64 16, !4, i64 20, !8, i64 24, !8, i64 32}
!101 = !{!"sched_rt_entity", !23, i64 0, !8, i64 16, !8, i64 24, !4, i64 32, !15, i64 36, !15, i64 38, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64}
!102 = !{!"sched_dl_entity", !97, i64 0, !98, i64 24, !98, i64 32, !98, i64 40, !98, i64 48, !98, i64 56, !98, i64 64, !4, i64 72, !4, i64 76, !4, i64 80, !4, i64 84, !103, i64 88}
!103 = !{!"hrtimer", !104, i64 0, !98, i64 32, !7, i64 40, !7, i64 48, !5, i64 56, !5, i64 57}
!104 = !{!"timerqueue_node", !97, i64 0, !98, i64 24}
!105 = !{!"hlist_head", !7, i64 0}
!106 = !{!"cpumask", !5, i64 0}
!107 = !{!"_Bool", !5, i64 0}
!108 = !{!"sched_info", !8, i64 0, !98, i64 8, !98, i64 16, !98, i64 24}
!109 = !{!"plist_node", !4, i64 0, !23, i64 8, !23, i64 24}
!110 = !{!"vmacache", !4, i64 0, !5, i64 8}
!111 = !{!"task_rss_stat", !4, i64 0, !5, i64 4}
!112 = !{!"restart_block", !7, i64 0, !5, i64 8}
!113 = !{!"prev_cputime", !98, i64 0, !98, i64 8, !57, i64 16}
!114 = !{!"task_cputime", !98, i64 0, !98, i64 8, !98, i64 16}
!115 = !{!"sysv_sem", !7, i64 0}
!116 = !{!"sysv_shm", !23, i64 0}
!117 = !{!"", !5, i64 0}
!118 = !{!"sigpending", !23, i64 0, !117, i64 16}
!119 = !{!"seccomp", !4, i64 0, !7, i64 8}
!120 = !{!"wake_q_node", !7, i64 0}
!121 = !{!"rb_root", !7, i64 0}
!122 = !{!"task_io_accounting", !98, i64 0, !98, i64 8, !98, i64 16, !98, i64 24, !98, i64 32, !98, i64 40, !98, i64 48}
!123 = !{!"seqcount", !4, i64 0, !24, i64 8}
!124 = !{!"callback_head", !7, i64 0, !7, i64 8}
!125 = !{!"tlbflush_unmap_batch", !106, i64 0, !107, i64 1024, !107, i64 1025}
!126 = !{!"page_frag", !7, i64 0, !4, i64 8, !4, i64 12}
!127 = !{!"thread_struct", !5, i64 0, !8, i64 24, !8, i64 32, !15, i64 40, !15, i64 42, !15, i64 44, !15, i64 46, !4, i64 48, !8, i64 56, !8, i64 64, !5, i64 72, !8, i64 104, !8, i64 112, !8, i64 120, !8, i64 128, !8, i64 136, !7, i64 144, !8, i64 152, !4, i64 160, !22, i64 168, !4, i64 176, !4, i64 176, !128, i64 192}
!128 = !{!"fpu", !4, i64 0, !5, i64 4, !5, i64 5, !5, i64 64}
!129 = !{i32 -2142425597}
!130 = !{!34, !4, i64 24}
!131 = !{!132, !4, i64 24}
!132 = !{!"serial_icounter_struct", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12, !4, i64 16, !4, i64 20, !4, i64 24, !4, i64 28, !4, i64 32, !4, i64 36, !4, i64 40, !5, i64 44}
!133 = !{!34, !4, i64 36}
!134 = !{!132, !4, i64 36}
!135 = !{!34, !4, i64 32}
!136 = !{!132, !4, i64 28}
!137 = !{!34, !4, i64 40}
!138 = !{!132, !4, i64 40}
!139 = !{!34, !4, i64 28}
!140 = !{!132, !4, i64 32}
!141 = !{!34, !4, i64 20}
!142 = !{!132, !4, i64 16}
!143 = !{!34, !4, i64 16}
!144 = !{!132, !4, i64 20}
!145 = !{!34, !4, i64 0}
!146 = !{!132, !4, i64 0}
!147 = !{!34, !4, i64 4}
!148 = !{!132, !4, i64 4}
!149 = !{!34, !4, i64 8}
!150 = !{!132, !4, i64 8}
!151 = !{!34, !4, i64 12}
!152 = !{!132, !4, i64 12}
!153 = !{i32 -2146875939, i32 -2146875900, i32 -2146875879, i32 -2146875842, i32 -2146875819, i32 -2146875949}
!154 = !{i32 -2146875193, i32 -2146875154, i32 -2146875133, i32 -2146875096, i32 -2146875073, i32 -2146875203}
!155 = !{i32 -2145102697}
!156 = !{i32 -2145102495}
!157 = !{!158, !4, i64 0}
!158 = !{!"serial_struct", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12, !4, i64 16, !4, i64 20, !4, i64 24, !4, i64 28, !15, i64 32, !5, i64 34, !5, i64 35, !4, i64 36, !15, i64 40, !15, i64 42, !7, i64 48, !15, i64 56, !4, i64 60, !8, i64 64}
!159 = !{!158, !4, i64 4}
!160 = !{!158, !4, i64 8}
!161 = !{!158, !4, i64 12}
!162 = !{!18, !8, i64 600}
!163 = !{!158, !4, i64 16}
!164 = !{!158, !4, i64 20}
!165 = !{!158, !4, i64 24}
!166 = !{!158, !4, i64 28}
!167 = !{!158, !15, i64 32}
!168 = !{!158, !5, i64 34}
!169 = !{!158, !4, i64 36}
!170 = !{!158, !15, i64 40}
!171 = !{!158, !15, i64 42}
!172 = !{!158, !7, i64 48}
!173 = !{!158, !15, i64 56}
!174 = !{!158, !4, i64 60}
!175 = !{!158, !8, i64 64}
!176 = !{!19, !8, i64 600}
!177 = !{!19, !4, i64 952}
!178 = !{!19, !4, i64 956}
!179 = !{i32 -2142451695}
!180 = !{!18, !4, i64 1056}
!181 = !{!18, !4, i64 1052}
!182 = !{!18, !4, i64 1060}
!183 = !{!18, !4, i64 1048}
!184 = !{!18, !4, i64 1200}
!185 = !{!18, !4, i64 1008}
!186 = !{!18, !4, i64 1004}
!187 = !{!18, !4, i64 1012}
!188 = !{!189, !4, i64 0}
!189 = !{!"", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12, !4, i64 16, !4, i64 20, !4, i64 24, !8, i64 32}
!190 = !{!189, !4, i64 20}
!191 = !{!189, !4, i64 24}
!192 = !{!189, !4, i64 16}
!193 = !{!189, !4, i64 12}
!194 = !{!18, !4, i64 1096}
!195 = !{!18, !4, i64 1100}
!196 = !{i32 577267, i32 577278, i32 -2146865879}
!197 = !{!107, !107, i64 0}
!198 = !{i8 0, i8 2}
!199 = !{!55, !4, i64 1384}
!200 = !{!18, !4, i64 1084}
!201 = !{!18, !4, i64 1076}
!202 = !{!18, !4, i64 1072}
!203 = !{!18, !4, i64 1080}
!204 = !{!18, !8, i64 1184}
!205 = !{!18, !8, i64 1192}
!206 = !{!18, !4, i64 1064}
!207 = !{!19, !7, i64 304}
!208 = !{!29, !4, i64 24}
!209 = !{!29, !4, i64 8}
!210 = !{!29, !4, i64 12}
!211 = !{!3, !4, i64 0}
!212 = !{!213, !98, i64 0}
!213 = !{!"resource", !98, i64 0, !98, i64 8, !7, i64 16, !8, i64 24, !8, i64 32, !7, i64 40, !7, i64 48, !7, i64 56}
!214 = !{!215, !8, i64 24}
!215 = !{!"pci_device_id", !4, i64 0, !4, i64 4, !4, i64 8, !4, i64 12, !4, i64 16, !4, i64 20, !8, i64 24}
!216 = !{!217, !4, i64 1588}
!217 = !{!"pci_dev", !23, i64 0, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !4, i64 56, !15, i64 60, !15, i64 62, !15, i64 64, !15, i64 66, !4, i64 68, !5, i64 72, !5, i64 73, !15, i64 74, !5, i64 76, !5, i64 77, !5, i64 78, !5, i64 79, !5, i64 80, !5, i64 81, !15, i64 82, !7, i64 88, !7, i64 96, !98, i64 104, !218, i64 112, !4, i64 128, !5, i64 132, !4, i64 133, !4, i64 133, !4, i64 133, !4, i64 133, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 135, !4, i64 135, !4, i64 136, !4, i64 140, !7, i64 144, !4, i64 152, !219, i64 160, !4, i64 1584, !4, i64 1588, !5, i64 1592, !107, i64 2680, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2681, !4, i64 2682, !4, i64 2682, !4, i64 2682, !4, i64 2682, !4, i64 2682, !4, i64 2682, !4, i64 2682, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2683, !4, i64 2684, !4, i64 2684, !4, i64 2684, !4, i64 2684, !15, i64 2686, !28, i64 2688, !5, i64 2692, !105, i64 2760, !7, i64 2768, !4, i64 2776, !5, i64 2784, !5, i64 2920, !4, i64 3056, !4, i64 3056, !5, i64 3057, !7, i64 3064, !7, i64 3072, !5, i64 3080, !15, i64 3088, !5, i64 3090, !28, i64 3092, !98, i64 3096, !8, i64 3104, !7, i64 3112}
!218 = !{!"device_dma_parameters", !4, i64 0, !8, i64 8}
!219 = !{!"device", !7, i64 0, !7, i64 8, !220, i64 16, !7, i64 280, !7, i64 288, !25, i64 296, !7, i64 456, !7, i64 464, !7, i64 472, !7, i64 480, !224, i64 488, !225, i64 528, !7, i64 1104, !7, i64 1112, !7, i64 1120, !23, i64 1128, !4, i64 1144, !7, i64 1152, !7, i64 1160, !98, i64 1168, !8, i64 1176, !7, i64 1184, !23, i64 1192, !7, i64 1208, !7, i64 1216, !228, i64 1224, !7, i64 1232, !7, i64 1240, !4, i64 1248, !4, i64 1252, !26, i64 1256, !23, i64 1328, !229, i64 1344, !7, i64 1376, !7, i64 1384, !7, i64 1392, !7, i64 1400, !7, i64 1408, !107, i64 1416, !107, i64 1416}
!220 = !{!"kobject", !7, i64 0, !23, i64 8, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !32, i64 56, !221, i64 64, !4, i64 256, !4, i64 256, !4, i64 256, !4, i64 256, !4, i64 256}
!221 = !{!"delayed_work", !21, i64 0, !222, i64 80, !7, i64 176, !4, i64 184}
!222 = !{!"timer_list", !223, i64 0, !8, i64 16, !7, i64 24, !8, i64 32, !4, i64 40, !24, i64 48}
!223 = !{!"hlist_node", !7, i64 0, !7, i64 8}
!224 = !{!"dev_links_info", !23, i64 0, !23, i64 16, !5, i64 32}
!225 = !{!"dev_pm_info", !226, i64 0, !4, i64 4, !4, i64 4, !107, i64 4, !107, i64 4, !107, i64 4, !107, i64 4, !107, i64 4, !107, i64 4, !107, i64 5, !26, i64 8, !23, i64 80, !227, i64 96, !7, i64 192, !107, i64 200, !107, i64 200, !107, i64 200, !222, i64 208, !8, i64 304, !21, i64 312, !31, i64 392, !7, i64 480, !28, i64 488, !28, i64 492, !4, i64 496, !4, i64 496, !4, i64 496, !4, i64 496, !4, i64 496, !4, i64 496, !107, i64 497, !4, i64 497, !4, i64 497, !4, i64 497, !4, i64 497, !4, i64 497, !4, i64 500, !5, i64 504, !5, i64 508, !4, i64 512, !4, i64 516, !8, i64 520, !8, i64 528, !8, i64 536, !8, i64 544, !7, i64 552, !7, i64 560, !7, i64 568}
!226 = !{!"pm_message", !4, i64 0}
!227 = !{!"completion", !4, i64 0, !31, i64 8}
!228 = !{!"dev_archdata", !7, i64 0}
!229 = !{!"klist_node", !7, i64 0, !23, i64 8, !32, i64 24}
!230 = !{!189, !8, i64 32}
!231 = !{!219, !7, i64 480}
