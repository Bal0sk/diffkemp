; ModuleID = 'tests/regression/kernel_modules/mxser/mxser_old-ttymajor.bc'
source_filename = "drivers/tty/mxser.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.44 }
%union.anon.44 = type { i8* }
%struct.kparam_array = type { i32, i32, i32*, %struct.kernel_param_ops*, i8* }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, %struct.memcg_batch_info, i32, %struct.atomic_t, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.atomic64_t = type { i64 }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file = type { %union.anon.37, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%union.anon.37 = type { %struct.list_head }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.40, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.38, i8* }
%union.anon.38 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.35, i32 }
%union.anon.35 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%union.anon.40 = type { %struct.list_head }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.33, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.34, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.36, i32, i32, %struct.hlist_head, %struct.atomic_t, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.33 = type { i32 }
%union.anon.34 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.42 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.42 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.32, i32 }
%union.anon.32 = type { i8* }
%struct.swap_info_struct = type opaque
%union.anon.36 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t, i32, i32, i8*, %struct.lockdep_map }
%union.arch_rwlock_t = type { i64 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.3, %union.anon.9, %union.anon.11, i64 }
%struct.anon.3 = type { %union.anon.4, %union.anon.5 }
%union.anon.4 = type { i64 }
%union.anon.5 = type { i64 }
%union.anon.9 = type { %struct.list_head }
%union.anon.11 = type { i64 }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %struct.atomic_t, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.12, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.13, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.14, %union.anon.15 }
%union.anon.12 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.13 = type { i64 }
%union.anon.14 = type { %struct.list_head }
%union.anon.15 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.16 }
%union.anon.16 = type { %struct.anon.17 }
%struct.anon.17 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.19, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.22 }
%union.anon.19 = type { %struct.anon.20 }
%struct.anon.20 = type { i64, i64 }
%union.anon.22 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type { i32, %struct.kref, %struct.device*, %struct.tty_driver*, %struct.tty_operations*, i32, %struct.mutex, %struct.tty_ldisc*, %struct.mutex, %struct.mutex, %struct.mutex, %struct.spinlock, %struct.ktermios, %struct.ktermios, %struct.termiox*, [64 x i8], %struct.pid*, %struct.pid*, i64, i32, %struct.winsize, i8, i8, i32, i32, %struct.tty_struct*, %struct.fasync_struct*, i32, %struct.__wait_queue_head, %struct.__wait_queue_head, %struct.work_struct, i8*, i8*, %struct.list_head, i8, i16, i8*, i32, %struct.work_struct, %struct.tty_port* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.dma_attrs*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.dma_attrs = type { [1 x i64] }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.tty_driver = type { i32, %struct.kref, %struct.cdev*, %struct.module*, i8*, i8*, i32, i32, i32, i32, i16, i16, %struct.ktermios, i64, %struct.proc_dir_entry*, %struct.tty_driver*, %struct.tty_struct**, %struct.tty_port**, %struct.ktermios**, i8*, %struct.tty_operations*, %struct.list_head }
%struct.cdev = type { %struct.kobject, %struct.module*, %struct.file_operations*, %struct.list_head, i32, i32 }
%struct.proc_dir_entry = type opaque
%struct.tty_operations = type { %struct.tty_struct* (%struct.tty_driver*, %struct.inode*, i32)*, i32 (%struct.tty_driver*, %struct.tty_struct*)*, void (%struct.tty_driver*, %struct.tty_struct*)*, i32 (%struct.tty_struct*, %struct.file*)*, void (%struct.tty_struct*, %struct.file*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, i32 (%struct.tty_struct*, i8*, i32)*, i32 (%struct.tty_struct*, i8)*, void (%struct.tty_struct*)*, i32 (%struct.tty_struct*)*, i32 (%struct.tty_struct*)*, i32 (%struct.tty_struct*, i32, i64)*, i64 (%struct.tty_struct*, i32, i64)*, void (%struct.tty_struct*, %struct.ktermios*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, i32 (%struct.tty_struct*, i32)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*, i32)*, void (%struct.tty_struct*, i8)*, i32 (%struct.tty_struct*)*, i32 (%struct.tty_struct*, i32, i32)*, i32 (%struct.tty_struct*, %struct.winsize*)*, i32 (%struct.tty_struct*, %struct.termiox*)*, i32 (%struct.tty_struct*, %struct.serial_icounter_struct*)*, i32 (%struct.tty_driver*, i32, i8*)*, i32 (%struct.tty_driver*, i32)*, void (%struct.tty_driver*, i32, i8)*, %struct.file_operations* }
%struct.serial_icounter_struct = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [9 x i32] }
%struct.tty_ldisc = type { %struct.tty_ldisc_ops*, %struct.atomic_t, %struct.__wait_queue_head }
%struct.tty_ldisc_ops = type { i32, i8*, i32, i32, i32 (%struct.tty_struct*)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*)*, i64 (%struct.tty_struct*)*, i64 (%struct.tty_struct*, %struct.file*, i8*, i64)*, i64 (%struct.tty_struct*, %struct.file*, i8*, i64)*, i32 (%struct.tty_struct*, %struct.file*, i32, i64)*, i64 (%struct.tty_struct*, %struct.file*, i32, i64)*, void (%struct.tty_struct*, %struct.ktermios*)*, i32 (%struct.tty_struct*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.tty_struct*)*, void (%struct.tty_struct*, i8*, i8*, i32)*, void (%struct.tty_struct*)*, void (%struct.tty_struct*, i32)*, %struct.module*, i32 }
%struct.ktermios = type { i32, i32, i32, i32, i8, [19 x i8], i32, i32 }
%struct.termiox = type { i16, i16, [5 x i16], i16 }
%struct.winsize = type { i16, i16, i16, i16 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.tty_port = type { %struct.tty_bufhead, %struct.tty_struct*, %struct.tty_struct*, %struct.tty_port_operations*, %struct.spinlock, i32, i32, %struct.__wait_queue_head, %struct.__wait_queue_head, %struct.__wait_queue_head, i64, i64, i8, %struct.mutex, %struct.mutex, i8*, i32, i32, i32, %struct.kref }
%struct.tty_bufhead = type { %struct.work_struct, %struct.spinlock, %struct.tty_buffer*, %struct.tty_buffer*, %struct.tty_buffer*, i32 }
%struct.tty_buffer = type { %struct.tty_buffer*, i8*, i8*, i32, i32, i32, i32, [0 x i64] }
%struct.tty_port_operations = type { i32 (%struct.tty_port*)*, void (%struct.tty_port*, i32)*, void (%struct.tty_port*)*, void (%struct.tty_port*)*, i32 (%struct.tty_port*, %struct.tty_struct*)*, void (%struct.tty_port*)* }
%struct.autogroup = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i32 }
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.24 }
%union.anon.24 = type { %struct.anon.28, [80 x i8] }
%struct.anon.28 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.atomic_t = type { i32 }
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.mxser_board = type { i32, i32, %struct.mxser_cardinfo*, i64, i64, i32, i32, [8 x %struct.mxser_port] }
%struct.mxser_cardinfo = type { i8*, i32, i32 }
%struct.mxser_port = type { %struct.tty_port, %struct.mxser_board*, i64, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i8, i32, i8, %struct.async_icount, i32, i32, i32, i32, i32, i32, i32, %struct.ktermios, %struct.mxser_mon, %struct.spinlock }
%struct.async_icount = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.mxser_mon = type { i64, i64, i64, i64, i32, i8 }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.pci_dynids }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, [6 x i8], %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, i16, i8, i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, [3 x i8], i16, [2 x i8], %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], %struct.list_head, %struct.kset*, %struct.pci_vpd*, %union.anon.47, %struct.pci_ats*, i64, i64 }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.47 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_ats = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)* }
%struct.pci_dynids = type { %struct.spinlock, %struct.list_head }
%struct.ratelimit_state = type { %struct.raw_spinlock, i32, i32, i32, i32, i64 }
%struct.mxser_log = type { i32, [32 x i64], [32 x i64] }
%struct.anon.48 = type { i32, i32, i32, i32, i32, i32, i32, i64 }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.serial_struct = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i8, [1 x i8], i32, i16, i16, i8*, i16, i32, i64 }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.mm_segment_t, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.map_segment = type opaque
%struct.mm_segment_t = type { i64 }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.49 }
%union.anon.49 = type { %struct.anon.50 }
%struct.anon.50 = type { i32*, i32, i32, i32, i64, i32* }

@__UNIQUE_ID_author184 = internal constant [19 x i8] c"author=Casper Yang\00", section ".modinfo", align 1
@__UNIQUE_ID_description185 = internal constant [71 x i8] c"description=MOXA Smartio/Industio Family Multiport Board Device Driver\00", section ".modinfo", align 1
@__param_str_ioaddr = internal constant [7 x i8] c"ioaddr\00", align 1
@param_array_ops = external global %struct.kernel_param_ops, align 8
@__param_arr_ioaddr = internal constant %struct.kparam_array { i32 4, i32 8, i32* null, %struct.kernel_param_ops* @param_ops_ulong, i8* bitcast ([4 x i64]* @ioaddr to i8*) }, align 8
@__param_ioaddr = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_ioaddr, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_ioaddr } }, section "__param", align 8
@__UNIQUE_ID_ioaddrtype186 = internal constant [31 x i8] c"parmtype=ioaddr:array of ulong\00", section ".modinfo", align 1
@__UNIQUE_ID_ioaddr187 = internal constant [54 x i8] c"parm=ioaddr:ISA io addresses to look for a moxa board\00", section ".modinfo", align 1
@__param_str_ttymajor = internal constant [9 x i8] c"ttymajor\00", align 1
@param_ops_int = external global %struct.kernel_param_ops, align 8
@ttymajor = internal global i32 174, align 4
@__param_ttymajor = internal constant %struct.kernel_param { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_ttymajor, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 0, i16 -1, %union.anon.44 { i8* bitcast (i32* @ttymajor to i8*) } }, section "__param", align 8
@__UNIQUE_ID_ttymajortype188 = internal constant [22 x i8] c"parmtype=ttymajor:int\00", section ".modinfo", align 1
@__UNIQUE_ID_license189 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__param_str_allow_overlapping_vector = internal constant [25 x i8] c"allow_overlapping_vector\00", align 16
@param_ops_bool = external global %struct.kernel_param_ops, align 8
@allow_overlapping_vector = internal global i8 0, align 1
@__param_allow_overlapping_vector = internal constant %struct.kernel_param { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__param_str_allow_overlapping_vector, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 292, i16 -1, %union.anon.44 { i8* @allow_overlapping_vector } }, section "__param", align 8
@__UNIQUE_ID_allow_overlapping_vectortype2352 = internal constant [39 x i8] c"parmtype=allow_overlapping_vector:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_allow_overlapping_vector2353 = internal constant [122 x i8] c"parm=allow_overlapping_vector:whether we allow ISA cards to be configured such that vector overlabs IO ports (default=no)\00", section ".modinfo", align 1
@smp_ops = external global %struct.smp_ops, align 8
@mxser_pcibrds = internal global [27 x %struct.pci_device_id] [%struct.pci_device_id { i32 5011, i32 5760, i32 -1, i32 -1, i32 0, i32 0, i64 3 }, %struct.pci_device_id { i32 5011, i32 4160, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 5011, i32 4896, i32 -1, i32 -1, i32 0, i32 0, i64 8 }, %struct.pci_device_id { i32 5011, i32 4417, i32 -1, i32 -1, i32 0, i32 0, i64 9 }, %struct.pci_device_id { i32 5011, i32 4416, i32 -1, i32 -1, i32 0, i32 0, i64 10 }, %struct.pci_device_id { i32 5011, i32 4128, i32 -1, i32 -1, i32 0, i32 0, i64 11 }, %struct.pci_device_id { i32 5011, i32 4161, i32 -1, i32 -1, i32 0, i32 0, i64 12 }, %struct.pci_device_id { i32 5011, i32 5761, i32 -1, i32 -1, i32 0, i32 0, i64 13 }, %struct.pci_device_id { i32 5011, i32 4897, i32 -1, i32 -1, i32 0, i32 0, i64 14 }, %struct.pci_device_id { i32 5011, i32 4928, i32 -1, i32 -1, i32 0, i32 0, i64 15 }, %struct.pci_device_id { i32 5011, i32 4162, i32 -1, i32 -1, i32 0, i32 0, i64 16 }, %struct.pci_device_id { i32 5011, i32 1, i32 -1, i32 -1, i32 0, i32 0, i64 17 }, %struct.pci_device_id { i32 5011, i32 4480, i32 -1, i32 -1, i32 0, i32 0, i64 18 }, %struct.pci_device_id { i32 5011, i32 4129, i32 -1, i32 -1, i32 0, i32 0, i64 19 }, %struct.pci_device_id { i32 5011, i32 4130, i32 -1, i32 -1, i32 0, i32 0, i64 20 }, %struct.pci_device_id { i32 5011, i32 4481, i32 -1, i32 -1, i32 0, i32 0, i64 21 }, %struct.pci_device_id { i32 5011, i32 5762, i32 -1, i32 -1, i32 0, i32 0, i64 22 }, %struct.pci_device_id { i32 5011, i32 4163, i32 -1, i32 -1, i32 0, i32 0, i64 23 }, %struct.pci_device_id { i32 5011, i32 4224, i32 -1, i32 -1, i32 0, i32 0, i64 24 }, %struct.pci_device_id { i32 5011, i32 4418, i32 -1, i32 -1, i32 0, i32 0, i64 25 }, %struct.pci_device_id { i32 5011, i32 4929, i32 -1, i32 -1, i32 0, i32 0, i64 26 }, %struct.pci_device_id { i32 5011, i32 4992, i32 -1, i32 -1, i32 0, i32 0, i64 27 }, %struct.pci_device_id { i32 5011, i32 4164, i32 -1, i32 -1, i32 0, i32 0, i64 28 }, %struct.pci_device_id { i32 5011, i32 4419, i32 -1, i32 -1, i32 0, i32 0, i64 29 }, %struct.pci_device_id { i32 5011, i32 4131, i32 -1, i32 -1, i32 0, i32 0, i64 30 }, %struct.pci_device_id { i32 5011, i32 4384, i32 -1, i32 -1, i32 0, i32 0, i64 31 }, %struct.pci_device_id zeroinitializer], align 16
@param_ops_ulong = external global %struct.kernel_param_ops, align 8
@ioaddr = internal global [4 x i64] zeroinitializer, align 16
@mxvar_sdriver = internal global %struct.tty_driver* null, align 8
@.str = private unnamed_addr constant [50 x i8] c"\016MOXA Smartio/Industio family driver version %s\0A\00", align 1
@.str.2 = private unnamed_addr constant [6 x i8] c"2.0.5\00", align 1
@.str.3 = private unnamed_addr constant [6 x i8] c"ttyMI\00", align 1
@tty_std_termios = external global %struct.ktermios, align 4
@mxser_ops = internal constant %struct.tty_operations { %struct.tty_struct* (%struct.tty_driver*, %struct.inode*, i32)* null, i32 (%struct.tty_driver*, %struct.tty_struct*)* null, void (%struct.tty_driver*, %struct.tty_struct*)* null, i32 (%struct.tty_struct*, %struct.file*)* @mxser_open, void (%struct.tty_struct*, %struct.file*)* @mxser_close, void (%struct.tty_struct*)* null, void (%struct.tty_struct*)* null, i32 (%struct.tty_struct*, i8*, i32)* @mxser_write, i32 (%struct.tty_struct*, i8)* @mxser_put_char, void (%struct.tty_struct*)* @mxser_flush_chars, i32 (%struct.tty_struct*)* @mxser_write_room, i32 (%struct.tty_struct*)* @mxser_chars_in_buffer, i32 (%struct.tty_struct*, i32, i64)* @mxser_ioctl, i64 (%struct.tty_struct*, i32, i64)* null, void (%struct.tty_struct*, %struct.ktermios*)* @mxser_set_termios, void (%struct.tty_struct*)* @mxser_throttle, void (%struct.tty_struct*)* @mxser_unthrottle, void (%struct.tty_struct*)* @mxser_stop, void (%struct.tty_struct*)* @mxser_start, void (%struct.tty_struct*)* @mxser_hangup, i32 (%struct.tty_struct*, i32)* @mxser_rs_break, void (%struct.tty_struct*)* @mxser_flush_buffer, void (%struct.tty_struct*)* null, void (%struct.tty_struct*, i32)* @mxser_wait_until_sent, void (%struct.tty_struct*, i8)* null, i32 (%struct.tty_struct*)* @mxser_tiocmget, i32 (%struct.tty_struct*, i32, i32)* @mxser_tiocmset, i32 (%struct.tty_struct*, %struct.winsize*)* null, i32 (%struct.tty_struct*, %struct.termiox*)* null, i32 (%struct.tty_struct*, %struct.serial_icounter_struct*)* @mxser_get_icount, i32 (%struct.tty_driver*, i32, i8*)* null, i32 (%struct.tty_driver*, i32)* null, void (%struct.tty_driver*, i32, i8)* null, %struct.file_operations* null }, align 8
@.str.4 = private unnamed_addr constant [62 x i8] c"\013Couldn't install MOXA Smartio/Industio family tty driver !\0A\00", align 1
@mxser_boards = internal global [4 x %struct.mxser_board] zeroinitializer, align 16
@.str.5 = private unnamed_addr constant [42 x i8] c"\016mxser: found MOXA %s board (CAP=0x%lx)\0A\00", align 1
@mxser_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([27 x %struct.pci_device_id], [27 x %struct.pci_device_id]* @mxser_pcibrds, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @mxser_probe, void (%struct.pci_dev*)* @mxser_remove, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, %struct.pci_error_handlers* null, %struct.device_driver zeroinitializer, %struct.pci_dynids zeroinitializer }, align 8
@__this_module = external global %struct.module, align 8
@.str.6 = private unnamed_addr constant [6 x i8] c"mxser\00", align 1
@.str.7 = private unnamed_addr constant [36 x i8] c"\013mxser: can't register pci driver\0A\00", align 1
@jiffies = external global i64, align 8
@mxser_ioctl.ModeMask = internal global [4 x i8] c"\FC\F3\CF?", align 1
@mxser_set_baud_method = internal global [33 x i32] zeroinitializer, align 16
@mxser_ioctl_special._rs = internal global %struct.ratelimit_state { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i32 0, i64 0 } }, i32 1250, i32 10, i32 0, i32 0, i64 0 }, align 8
@.str.8 = private unnamed_addr constant [9 x i8] c"_rs.lock\00", align 1
@__func__.mxser_ioctl_special = private unnamed_addr constant [20 x i8] c"mxser_ioctl_special\00", align 1
@.str.9 = private unnamed_addr constant [72 x i8] c"\014mxser: '%s' uses deprecated ioctl %x (GET_MAJOR), fix your userspace\0A\00", align 1
@mxvar_log = internal global %struct.mxser_log zeroinitializer, align 8
@.str.10 = private unnamed_addr constant [62 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/uaccess_64.h\00", align 1
@.str.11 = private unnamed_addr constant [27 x i8] c"Buffer overflow detected!\0A\00", align 1
@Gpci_uart_info = internal constant [3 x %struct.anon.48] [%struct.anon.48 { i32 0, i32 16, i32 16, i32 16, i32 14, i32 14, i32 1, i64 921600 }, %struct.anon.48 { i32 1, i32 64, i32 64, i32 64, i32 48, i32 48, i32 16, i64 230400 }, %struct.anon.48 { i32 2, i32 128, i32 128, i32 128, i32 96, i32 96, i32 32, i64 921600 }], align 16
@current_task = external global %struct.task_struct*, align 8
@mxser_get_msr.mxser_msr = internal global [33 x i8] zeroinitializer, align 16
@mxser_cards = internal constant [32 x %struct.mxser_cardinfo] [%struct.mxser_cardinfo { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.18, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.19, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.20, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.21, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.22, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0), i32 4, i32 2 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24, i32 0, i32 0), i32 4, i32 2 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.25, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.26, i32 0, i32 0), i32 2, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.27, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.28, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.29, i32 0, i32 0), i32 2, i32 1 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.31, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.32, i32 0, i32 0), i32 2, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.33, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.34, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.35, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.36, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.37, i32 0, i32 0), i32 2, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.38, i32 0, i32 0), i32 2, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.39, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.40, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.41, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.42, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.43, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.44, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.45, i32 0, i32 0), i32 8, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.46, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.47, i32 0, i32 0), i32 4, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.48, i32 0, i32 0), i32 2, i32 0 }, %struct.mxser_cardinfo { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.49, i32 0, i32 0), i32 2, i32 0 }], align 16
@.str.12 = private unnamed_addr constant [33 x i8] c"\013mxser: interrupt number unset\0A\00", align 1
@.str.13 = private unnamed_addr constant [35 x i8] c"\013mxser: invalid interrupt vector\0A\00", align 1
@ioport_resource = external global %struct.resource, align 8
@.str.14 = private unnamed_addr constant [10 x i8] c"mxser(IO)\00", align 1
@.str.15 = private unnamed_addr constant [58 x i8] c"\013mxser: can't request ports I/O region: 0x%.8lx-0x%.8lx\0A\00", align 1
@.str.16 = private unnamed_addr constant [65 x i8] c"\013mxser: can't request interrupt vector region: 0x%.8lx-0x%.8lx\0A\00", align 1
@.str.17 = private unnamed_addr constant [35 x i8] c"\013mxser: invalid interrupt number\0A\00", align 1
@.str.18 = private unnamed_addr constant [12 x i8] c"C168 series\00", align 1
@.str.19 = private unnamed_addr constant [12 x i8] c"C104 series\00", align 1
@.str.20 = private unnamed_addr constant [15 x i8] c"CI-104J series\00", align 1
@.str.21 = private unnamed_addr constant [17 x i8] c"C168H/PCI series\00", align 1
@.str.22 = private unnamed_addr constant [17 x i8] c"C104H/PCI series\00", align 1
@.str.23 = private unnamed_addr constant [12 x i8] c"C102 series\00", align 1
@.str.24 = private unnamed_addr constant [14 x i8] c"CI-132 series\00", align 1
@.str.25 = private unnamed_addr constant [14 x i8] c"CI-134 series\00", align 1
@.str.26 = private unnamed_addr constant [14 x i8] c"CP-132 series\00", align 1
@.str.27 = private unnamed_addr constant [14 x i8] c"CP-114 series\00", align 1
@.str.28 = private unnamed_addr constant [14 x i8] c"CT-114 series\00", align 1
@.str.29 = private unnamed_addr constant [14 x i8] c"CP-102 series\00", align 1
@.str.30 = private unnamed_addr constant [15 x i8] c"CP-104U series\00", align 1
@.str.31 = private unnamed_addr constant [15 x i8] c"CP-168U series\00", align 1
@.str.32 = private unnamed_addr constant [15 x i8] c"CP-132U series\00", align 1
@.str.33 = private unnamed_addr constant [15 x i8] c"CP-134U series\00", align 1
@.str.34 = private unnamed_addr constant [16 x i8] c"CP-104JU series\00", align 1
@.str.35 = private unnamed_addr constant [19 x i8] c"Moxa UC7000 Serial\00", align 1
@.str.36 = private unnamed_addr constant [15 x i8] c"CP-118U series\00", align 1
@.str.37 = private unnamed_addr constant [16 x i8] c"CP-102UL series\00", align 1
@.str.38 = private unnamed_addr constant [15 x i8] c"CP-102U series\00", align 1
@.str.39 = private unnamed_addr constant [16 x i8] c"CP-118EL series\00", align 1
@.str.40 = private unnamed_addr constant [16 x i8] c"CP-168EL series\00", align 1
@.str.41 = private unnamed_addr constant [16 x i8] c"CP-104EL series\00", align 1
@.str.42 = private unnamed_addr constant [14 x i8] c"CB-108 series\00", align 1
@.str.43 = private unnamed_addr constant [14 x i8] c"CB-114 series\00", align 1
@.str.44 = private unnamed_addr constant [15 x i8] c"CB-134I series\00", align 1
@.str.45 = private unnamed_addr constant [15 x i8] c"CP-138U series\00", align 1
@.str.46 = private unnamed_addr constant [17 x i8] c"POS-104UL series\00", align 1
@.str.47 = private unnamed_addr constant [16 x i8] c"CP-114UL series\00", align 1
@.str.48 = private unnamed_addr constant [16 x i8] c"CP-102UF series\00", align 1
@.str.49 = private unnamed_addr constant [16 x i8] c"CP-112UL series\00", align 1
@.str.50 = private unnamed_addr constant [14 x i8] c"mxser(vector)\00", align 1
@.str.51 = private unnamed_addr constant [34 x i8] c"\016mxser: max. baud rate = %d bps\0A\00", align 1
@mxser_port_ops = internal global %struct.tty_port_operations { i32 (%struct.tty_port*)* @mxser_carrier_raised, void (%struct.tty_port*, i32)* @mxser_dtr_rts, void (%struct.tty_port*)* @mxser_shutdown_port, void (%struct.tty_port*)* null, i32 (%struct.tty_port*, %struct.tty_struct*)* @mxser_activate, void (%struct.tty_port*)* null }, align 8
@mxser_initbrd.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.52 = private unnamed_addr constant [23 x i8] c"&(&info->slock)->rlock\00", align 1
@.str.53 = private unnamed_addr constant [76 x i8] c"\013Board %s: Request irq failed, IRQ (%d) may conflict with another device.\0A\00", align 1
@.str.54 = private unnamed_addr constant [58 x i8] c"too many boards found (maximum %d), board not configured\0A\00", align 1
@.str.55 = private unnamed_addr constant [42 x i8] c"found MOXA %s board (BusNo=%d, DevNo=%d)\0A\00", align 1
@.str.56 = private unnamed_addr constant [19 x i8] c"PCI enable failed\0A\00", align 1
@llvm.used = appending global [11 x i8*] [i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_author184, i32 0, i32 0), i8* getelementptr inbounds ([71 x i8], [71 x i8]* @__UNIQUE_ID_description185, i32 0, i32 0), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_ioaddr to i8*), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__UNIQUE_ID_ioaddrtype186, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @__UNIQUE_ID_ioaddr187, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_ttymajor to i8*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__UNIQUE_ID_ttymajortype188, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license189, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_allow_overlapping_vector to i8*), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @__UNIQUE_ID_allow_overlapping_vectortype2352, i32 0, i32 0), i8* getelementptr inbounds ([122 x i8], [122 x i8]* @__UNIQUE_ID_allow_overlapping_vector2353, i32 0, i32 0)], section "llvm.metadata"

@__mod_pci_device_table = alias %struct.pci_device_id, getelementptr inbounds ([27 x %struct.pci_device_id], [27 x %struct.pci_device_id]* @mxser_pcibrds, i32 0, i32 0)
@cleanup_module = alias void (), void ()* @mxser_module_exit

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: nounwind uwtable
declare i32 @mxser_module_init() #1 section ".init.text"

; Function Attrs: nounwind uwtable
define internal void @mxser_module_exit() #1 section ".exit.text" {
entry:
  call void @pci_unregister_driver(%struct.pci_driver* @mxser_driver)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx, i32 0, i32 2
  %0 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !12
  %cmp1 = icmp ne %struct.mxser_cardinfo* %0, null
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %idxprom2 = zext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom2
  call void @mxser_board_remove(%struct.mxser_board* %arrayidx3)
  br label %for.inc

for.inc:                                          ; preds = %if.then, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %1 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !16
  %call = call i32 @tty_unregister_driver(%struct.tty_driver* %1)
  %2 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !16
  call void @put_tty_driver(%struct.tty_driver* %2)
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc15, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc16, %for.inc15 ]
  %cmp5 = icmp ult i32 %i.1, 4
  br i1 %cmp5, label %for.body6, label %for.end17

for.body6:                                        ; preds = %for.cond4
  %idxprom7 = zext i32 %i.1 to i64
  %arrayidx8 = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom7
  %info9 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx8, i32 0, i32 2
  %3 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info9, align 8, !tbaa !12
  %cmp10 = icmp ne %struct.mxser_cardinfo* %3, null
  br i1 %cmp10, label %if.then11, label %for.inc15

if.then11:                                        ; preds = %for.body6
  %idxprom12 = zext i32 %i.1 to i64
  %arrayidx13 = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom12
  call void @mxser_release_ISA_res(%struct.mxser_board* %arrayidx13)
  br label %for.inc15

for.inc15:                                        ; preds = %if.then11, %for.body6
  %inc16 = add i32 %i.1, 1
  br label %for.cond4

for.end17:                                        ; preds = %for.cond4
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @alloc_tty_driver(i32 %lines) #0 {
entry:
  %call = call %struct.tty_driver* @__tty_alloc_driver(i32 %lines, %struct.module* @__this_module, i64 0)
  %0 = bitcast %struct.tty_driver* %call to i8*
  %call1 = call i64 @IS_ERR(i8* %0)
  ret void
}

declare i32 @printk(i8*, ...) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

declare void @tty_set_operations(%struct.tty_driver*, %struct.tty_operations*) #3

declare i32 @tty_register_driver(%struct.tty_driver*) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_get_ISA_conf(i32 %cap, %struct.mxser_board* %brd) #1 section ".init.text" {
entry:
  %regs = alloca [16 x i16], align 16
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 5
  store i32 0, i32* %chip_flag, align 8, !tbaa !17
  %arraydecay = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i32 0, i32 0
  %call = call i32 @mxser_read_register(i32 %cap, i16* %arraydecay)
  %Pivot12 = icmp slt i32 %call, 4
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %call, 5
  br i1 %Pivot10, label %sw.bb7, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %call, 11
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %call, 11
  br i1 %SwitchLeaf6, label %sw.bb5, label %cleanup

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %call, 5
  br i1 %SwitchLeaf4, label %sw.bb3, label %cleanup

NodeBlock1:                                       ; preds = %entry
  %Pivot2 = icmp slt i32 %call, 2
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %call, 3
  %info2 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  br i1 %Pivot, label %sw.bb1, label %sw.bb9

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %call, 1
  br i1 %SwitchLeaf, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %LeafBlock
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 0), %struct.mxser_cardinfo** %info, align 8, !tbaa !12
  br label %sw.epilog

sw.bb1:                                           ; preds = %NodeBlock
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 1), %struct.mxser_cardinfo** %info2, align 8, !tbaa !12
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock3
  %info4 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 2), %struct.mxser_cardinfo** %info4, align 8, !tbaa !12
  br label %sw.epilog

sw.bb5:                                           ; preds = %LeafBlock5
  %info6 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 5), %struct.mxser_cardinfo** %info6, align 8, !tbaa !12
  br label %sw.epilog

sw.bb7:                                           ; preds = %NodeBlock9
  %info8 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 6), %struct.mxser_cardinfo** %info8, align 8, !tbaa !12
  br label %sw.epilog

sw.bb9:                                           ; preds = %NodeBlock
  store %struct.mxser_cardinfo* getelementptr inbounds ([32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 7), %struct.mxser_cardinfo** %info2, align 8, !tbaa !12
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb9, %sw.bb7, %sw.bb5, %sw.bb3, %sw.bb1, %sw.bb
  %info11 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %0 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info11, align 8, !tbaa !12
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %0, i32 0, i32 1
  %1 = load i32, i32* %nports, align 8, !tbaa !18
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %info12 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %2 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info12, align 8, !tbaa !12
  %flags = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %2, i32 0, i32 2
  %3 = load i32, i32* %flags, align 4, !tbaa !20
  %and = and i32 %3, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %sw.epilog
  %arrayidx = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %4 = load i16, i16* %arrayidx, align 2, !tbaa !21
  %conv = zext i16 %4 to i32
  %and13 = and i32 %conv, 61440
  %conv14 = trunc i32 %and13 to i16
  %conv15 = zext i16 %conv14 to i32
  %conv16 = zext i16 %conv14 to i32
  %shr = ashr i32 %conv16, 4
  %or = or i32 %conv15, %shr
  %conv17 = trunc i32 %or to i16
  %conv18 = zext i16 %conv17 to i32
  %arrayidx19 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %5 = load i16, i16* %arrayidx19, align 2, !tbaa !21
  %conv20 = zext i16 %5 to i32
  %and21 = and i32 %conv20, 65280
  %cmp22 = icmp ne i32 %conv18, %and21
  br i1 %cmp22, label %err_irqconflict, label %if.end86

if.else:                                          ; preds = %lor.lhs.false
  %info25 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %6 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info25, align 8, !tbaa !12
  %nports26 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %6, i32 0, i32 1
  %7 = load i32, i32* %nports26, align 8, !tbaa !18
  %cmp27 = icmp eq i32 %7, 4
  br i1 %cmp27, label %if.then29, label %if.else51

if.then29:                                        ; preds = %if.else
  %arrayidx30 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %8 = load i16, i16* %arrayidx30, align 2, !tbaa !21
  %conv31 = zext i16 %8 to i32
  %and32 = and i32 %conv31, 61440
  %conv33 = trunc i32 %and32 to i16
  %conv34 = zext i16 %conv33 to i32
  %conv35 = zext i16 %conv33 to i32
  %shr36 = ashr i32 %conv35, 4
  %or37 = or i32 %conv34, %shr36
  %conv38 = trunc i32 %or37 to i16
  %conv39 = zext i16 %conv38 to i32
  %conv40 = zext i16 %conv38 to i32
  %shr41 = ashr i32 %conv40, 8
  %or42 = or i32 %conv39, %shr41
  %conv43 = trunc i32 %or42 to i16
  %conv44 = zext i16 %conv43 to i32
  %arrayidx45 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %9 = load i16, i16* %arrayidx45, align 2, !tbaa !21
  %conv46 = zext i16 %9 to i32
  %cmp47 = icmp ne i32 %conv44, %conv46
  br i1 %cmp47, label %err_irqconflict, label %if.end86

if.else51:                                        ; preds = %if.else
  %info52 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %10 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info52, align 8, !tbaa !12
  %nports53 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %10, i32 0, i32 1
  %11 = load i32, i32* %nports53, align 8, !tbaa !18
  %cmp54 = icmp eq i32 %11, 8
  br i1 %cmp54, label %if.then56, label %if.end86

if.then56:                                        ; preds = %if.else51
  %arrayidx57 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %12 = load i16, i16* %arrayidx57, align 2, !tbaa !21
  %conv58 = zext i16 %12 to i32
  %and59 = and i32 %conv58, 61440
  %conv60 = trunc i32 %and59 to i16
  %conv61 = zext i16 %conv60 to i32
  %conv62 = zext i16 %conv60 to i32
  %shr63 = ashr i32 %conv62, 4
  %or64 = or i32 %conv61, %shr63
  %conv65 = trunc i32 %or64 to i16
  %conv66 = zext i16 %conv65 to i32
  %conv67 = zext i16 %conv65 to i32
  %shr68 = ashr i32 %conv67, 8
  %or69 = or i32 %conv66, %shr68
  %conv70 = trunc i32 %or69 to i16
  %conv71 = zext i16 %conv70 to i32
  %arrayidx72 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 9
  %13 = load i16, i16* %arrayidx72, align 2, !tbaa !21
  %conv73 = zext i16 %13 to i32
  %cmp74 = icmp ne i32 %conv71, %conv73
  br i1 %cmp74, label %err_irqconflict, label %lor.lhs.false76

lor.lhs.false76:                                  ; preds = %if.then56
  %conv77 = zext i16 %conv70 to i32
  %arrayidx78 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 10
  %14 = load i16, i16* %arrayidx78, align 4, !tbaa !21
  %conv79 = zext i16 %14 to i32
  %cmp80 = icmp ne i32 %conv77, %conv79
  br i1 %cmp80, label %err_irqconflict, label %if.end86

if.end86:                                         ; preds = %lor.lhs.false76, %if.else51, %if.then29, %if.then
  %irq.2 = phi i16 [ %conv17, %if.then ], [ %conv43, %if.then29 ], [ 0, %if.else51 ], [ %conv70, %lor.lhs.false76 ]
  %tobool87 = icmp ne i16 %irq.2, 0
  br i1 %tobool87, label %if.end90, label %if.then88

if.then88:                                        ; preds = %if.end86
  %15 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end90:                                         ; preds = %if.end86
  %conv91 = zext i16 %irq.2 to i32
  %and92 = and i32 %conv91, 61440
  %shr93 = ashr i32 %and92, 12
  %irq94 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 1
  store i32 %shr93, i32* %irq94, align 4, !tbaa !23
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end90
  %i.0 = phi i32 [ 0, %if.end90 ], [ %inc, %for.body ]
  %cmp95 = icmp slt i32 %i.0, 8
  br i1 %cmp95, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 %i.0, 1
  %idxprom = sext i32 %add to i64
  %arrayidx97 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 %idxprom
  %16 = load i16, i16* %arrayidx97, align 2, !tbaa !21
  %conv98 = zext i16 %16 to i32
  %and99 = and i32 %conv98, 65528
  %conv100 = sext i32 %and99 to i64
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom101 = sext i32 %i.0 to i64
  %arrayidx102 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom101
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx102, i32 0, i32 2
  store i64 %conv100, i64* %ioaddr, align 8, !tbaa !24
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arrayidx103 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 12
  %17 = load i16, i16* %arrayidx103, align 8, !tbaa !21
  %conv104 = zext i16 %17 to i32
  %and105 = and i32 %conv104, 128
  %cmp106 = icmp eq i32 %and105, 0
  br i1 %cmp106, label %if.then108, label %if.end110

if.then108:                                       ; preds = %for.end
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end110:                                        ; preds = %for.end
  %arrayidx111 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 11
  %19 = load i16, i16* %arrayidx111, align 2, !tbaa !21
  %conv112 = zext i16 %19 to i32
  %conv113 = sext i32 %conv112 to i64
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 3
  store i64 %conv113, i64* %vector, align 8, !tbaa !40
  %cmp114 = icmp eq i32 %call, 1
  %vector_mask = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 4
  %.sink = select i1 %cmp114, i64 255, i64 15
  store i64 %.sink, i64* %vector_mask, align 8, !tbaa !41
  br label %for.cond120

for.cond120:                                      ; preds = %for.body123, %if.end110
  %i.1 = phi i32 [ 7, %if.end110 ], [ %dec, %for.body123 ]
  %bits.0 = phi i32 [ 256, %if.end110 ], [ %shl, %for.body123 ]
  %cmp121 = icmp sge i32 %i.1, 0
  br i1 %cmp121, label %for.body123, label %for.end146

for.body123:                                      ; preds = %for.cond120
  %arrayidx124 = getelementptr inbounds [16 x i16], [16 x i16]* %regs, i64 0, i64 12
  %20 = load i16, i16* %arrayidx124, align 8, !tbaa !21
  %conv125 = zext i16 %20 to i32
  %and126 = and i32 %conv125, %bits.0
  %tobool127 = icmp ne i32 %and126, 0
  %ports129 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom130 = sext i32 %i.1 to i64
  %arrayidx131 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports129, i64 0, i64 %idxprom130
  %baud_base = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx131, i32 0, i32 8
  %.sink14 = select i1 %tobool127, i32 921600, i32 115200
  store i32 %.sink14, i32* %baud_base, align 8, !tbaa !42
  %ports140 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom141 = sext i32 %i.1 to i64
  %arrayidx142 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports140, i64 0, i64 %idxprom141
  %max_baud143 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx142, i32 0, i32 4
  store i32 %.sink14, i32* %max_baud143, align 8, !tbaa !43
  %dec = add nsw i32 %i.1, -1
  %shl = shl i32 %bits.0, 1
  br label %for.cond120

for.end146:                                       ; preds = %for.cond120
  %add147 = add nsw i32 %cap, 3
  %call148 = call zeroext i8 @inb(i32 %add147)
  %conv149 = zext i8 %call148 to i32
  %and150 = and i32 %conv149, -129
  %conv151 = trunc i32 %and150 to i8
  %conv152 = zext i8 %conv151 to i32
  %or153 = or i32 %conv152, 128
  %conv154 = trunc i32 %or153 to i8
  %add155 = add nsw i32 %cap, 3
  call void @outb(i8 zeroext %conv154, i32 %add155)
  %add156 = add nsw i32 %cap, 2
  call void @outb(i8 zeroext 0, i32 %add156)
  %add157 = add nsw i32 %cap, 3
  call void @outb(i8 zeroext %conv151, i32 %add157)
  %add158 = add nsw i32 %cap, 2
  call void @outb(i8 zeroext 1, i32 %add158)
  %add159 = add nsw i32 %cap, 2
  %call160 = call zeroext i8 @inb(i32 %add159)
  %conv161 = zext i8 %call160 to i32
  %and162 = and i32 %conv161, 192
  %tobool163 = icmp ne i32 %and162, 0
  %uart_type = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 6
  %.sink15 = select i1 %tobool163, i32 4, i32 2
  store i32 %.sink15, i32* %uart_type, align 4, !tbaa !44
  %ports168 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %arrayidx169 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports168, i64 0, i64 0
  %ioaddr170 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx169, i32 0, i32 2
  %21 = load i64, i64* %ioaddr170, align 8, !tbaa !24
  %info171 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %22 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info171, align 8, !tbaa !12
  %nports172 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %22, i32 0, i32 1
  %23 = load i32, i32* %nports172, align 8, !tbaa !18
  %mul = mul i32 8, %23
  %conv173 = zext i32 %mul to i64
  %call174 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %21, i64 %conv173, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.14, i32 0, i32 0), i32 0)
  %tobool175 = icmp ne %struct.resource* %call174, null
  br i1 %tobool175, label %if.end189, label %if.then176

if.then176:                                       ; preds = %for.end146
  %24 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end189:                                        ; preds = %for.end146
  %call190 = call i32 @mxser_request_vector(%struct.mxser_board* %brd)
  %tobool191 = icmp ne i32 %call190, 0
  br i1 %tobool191, label %if.then192, label %if.end213

if.then192:                                       ; preds = %if.end189
  %ports193 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %arrayidx194 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports193, i64 0, i64 0
  %ioaddr195 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx194, i32 0, i32 2
  %25 = load i64, i64* %ioaddr195, align 8, !tbaa !24
  %info196 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %26 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info196, align 8, !tbaa !12
  %nports197 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %26, i32 0, i32 1
  %27 = load i32, i32* %nports197, align 8, !tbaa !18
  %mul198 = mul i32 8, %27
  %conv199 = zext i32 %mul198 to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %25, i64 %conv199)
  %28 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

if.end213:                                        ; preds = %if.end189
  br label %cleanup

err_irqconflict:                                  ; preds = %lor.lhs.false76, %if.then56, %if.then29, %if.then
  %29 = call i32 (i8*, ...) @printk(i8* null)
  br label %cleanup

cleanup:                                          ; preds = %err_irqconflict, %if.end213, %if.then192, %if.then176, %if.then108, %if.then88, %LeafBlock, %LeafBlock3, %LeafBlock5
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_initbrd(%struct.mxser_board* %brd) #4 {
entry:
  %0 = call i32 (i8*, ...) @printk(i8* null)
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %info2 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %1 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info2, align 8, !tbaa !12
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %1, i32 0, i32 1
  %2 = load i32, i32* %nports, align 8, !tbaa !18
  %cmp = icmp ult i32 %i.0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ports3 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom = zext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports3, i64 0, i64 %idxprom
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 0
  call void @tty_port_init(%struct.tty_port* %port)
  %port5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 0
  %ops = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port5, i32 0, i32 3
  store %struct.tty_port_operations* @mxser_port_ops, %struct.tty_port_operations** %ops, align 8, !tbaa !45
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 1
  store %struct.mxser_board* %brd, %struct.mxser_board** %board, align 8, !tbaa !46
  %stop_rx = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 13
  store i8 0, i8* %stop_rx, align 4, !tbaa !47
  %ldisc_stop_rx = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 14
  store i8 0, i8* %ldisc_stop_rx, align 1, !tbaa !48
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 5
  %3 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %cmp6 = icmp ne i32 %3, 0
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 2
  %4 = load i64, i64* %ioaddr, align 8, !tbaa !24
  call void @mxser_enable_must_enchance_mode(i64 %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %port7 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 0
  %flags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port7, i32 0, i32 10
  store i64 16777216, i64* %flags, align 8, !tbaa !49
  %uart_type = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 6
  %5 = load i32, i32* %uart_type, align 4, !tbaa !44
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 9
  store i32 %5, i32* %type, align 4, !tbaa !50
  call void @process_txrx_fifo(%struct.mxser_port* %arrayidx4)
  %baud_base = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 8
  %6 = load i32, i32* %baud_base, align 8, !tbaa !42
  %mul = mul nsw i32 %6, 16
  %custom_divisor = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 15
  store i32 %mul, i32* %custom_divisor, align 8, !tbaa !51
  %port8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 0
  %close_delay = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port8, i32 0, i32 16
  store i32 125, i32* %close_delay, align 8, !tbaa !52
  %port9 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 0
  %closing_wait = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port9, i32 0, i32 17
  store i32 7500, i32* %closing_wait, align 4, !tbaa !53
  %normal_termios = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 25
  %7 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !16
  %init_termios = getelementptr inbounds %struct.tty_driver, %struct.tty_driver* %7, i32 0, i32 12
  %8 = bitcast %struct.ktermios* %normal_termios to i8*
  %9 = bitcast %struct.ktermios* %init_termios to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 44, i32 4, i1 false), !tbaa.struct !54
  %mon_data = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 26
  %10 = bitcast %struct.mxser_mon* %mon_data to i8*
  call void @llvm.memset.p0i8.i64(i8* %10, i8 0, i64 40, i32 8, i1 false)
  %err_shadow = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 16
  store i8 0, i8* %err_shadow, align 4, !tbaa !57
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 27
  %call10 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %slock12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 27
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %slock12, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %11 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.52, i32 0, i32 0), %struct.lock_class_key* @mxser_initbrd.__key)
  %ioaddr15 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 2
  %12 = load i64, i64* %ioaddr15, align 8, !tbaa !24
  %add = add i64 %12, 1
  %conv = trunc i64 %add to i32
  %call16 = call zeroext i8 @inb(i32 %conv)
  %conv17 = zext i8 %call16 to i32
  %and = and i32 %conv17, 240
  %conv18 = trunc i32 %and to i8
  %ioaddr19 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx4, i32 0, i32 2
  %13 = load i64, i64* %ioaddr19, align 8, !tbaa !24
  %add20 = add i64 %13, 1
  %conv21 = trunc i64 %add20 to i32
  call void @outb(i8 zeroext %conv18, i32 %conv21)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %irq = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 1
  %14 = load i32, i32* %irq, align 4, !tbaa !23
  %15 = bitcast %struct.mxser_board* %brd to i8*
  %call22 = call i32 @request_irq(i32 %14, i32 (i32, i8*)* @mxser_interrupt, i64 128, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6, i32 0, i32 0), i8* %15)
  %tobool = icmp ne i32 %call22, 0
  br i1 %tobool, label %if.then23, label %if.end40

if.then23:                                        ; preds = %for.end
  br label %for.cond24

for.cond24:                                       ; preds = %for.body29, %if.then23
  %i.1 = phi i32 [ 0, %if.then23 ], [ %inc35, %for.body29 ]
  %info25 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %16 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info25, align 8, !tbaa !12
  %nports26 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %16, i32 0, i32 1
  %17 = load i32, i32* %nports26, align 8, !tbaa !18
  %cmp27 = icmp ult i32 %i.1, %17
  br i1 %cmp27, label %for.body29, label %for.end36

for.body29:                                       ; preds = %for.cond24
  %ports30 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom31 = zext i32 %i.1 to i64
  %arrayidx32 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports30, i64 0, i64 %idxprom31
  %port33 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 0
  call void @tty_port_destroy(%struct.tty_port* %port33)
  %inc35 = add i32 %i.1, 1
  br label %for.cond24

for.end36:                                        ; preds = %for.cond24
  %18 = call i32 (i8*, ...) @printk(i8* null)
  br label %if.end40

if.end40:                                         ; preds = %for.end36, %for.end
  ret i32 %call22
}

; Function Attrs: nounwind uwtable
define internal void @mxser_release_ISA_res(%struct.mxser_board* %brd) #4 {
entry:
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %arrayidx = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 0
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx, i32 0, i32 2
  %0 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %1 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !12
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %1, i32 0, i32 1
  %2 = load i32, i32* %nports, align 8, !tbaa !18
  %mul = mul i32 8, %2
  %conv = zext i32 %mul to i64
  call void @__release_region(%struct.resource* @ioport_resource, i64 %0, i64 %conv)
  call void @mxser_release_vector(%struct.mxser_board* %brd)
  ret void
}

declare %struct.device* @tty_port_register_device(%struct.tty_port*, %struct.tty_driver*, i32, %struct.device*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

declare void @tty_unregister_device(%struct.tty_driver*, i32) #3

declare void @tty_port_destroy(%struct.tty_port*) #3

declare void @free_irq(i32, i8*) #3

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) #3

declare i32 @tty_unregister_driver(%struct.tty_driver*) #3

declare void @put_tty_driver(%struct.tty_driver*) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

declare %struct.tty_driver* @__tty_alloc_driver(i32, %struct.module*, i64) #3

; Function Attrs: nounwind uwtable
define internal i32 @mxser_open(%struct.tty_struct* %tty, %struct.file* %filp) #4 {
entry:
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %0 = load i32, i32* %index, align 8, !tbaa !58
  %cmp = icmp eq i32 %0, 32
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %div = sdiv i32 %0, 8
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx, i32 0, i32 7
  %rem = srem i32 %0, 8
  %idxprom1 = sext i32 %rem to i64
  %arrayidx2 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom1
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx2, i32 0, i32 2
  %1 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %2 = bitcast %struct.mxser_port* %arrayidx2 to i8*
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  store i8* %2, i8** %driver_data, align 8, !tbaa !61
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx2, i32 0, i32 0
  %call = call i32 @tty_port_open(%struct.tty_port* %port, %struct.tty_struct* %tty, %struct.file* %filp)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.end4 ], [ 0, %entry ], [ -19, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @mxser_close(%struct.tty_struct* %tty, %struct.file* %filp) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %port1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %2 = load i32, i32* %index, align 8, !tbaa !58
  %cmp = icmp eq i32 %2, 32
  %cmp2 = icmp eq %struct.mxser_port* %1, null
  %or.cond = or i1 %cmp, %cmp2
  br i1 %or.cond, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @tty_port_close_start(%struct.tty_port* %port1, %struct.tty_struct* %tty, %struct.file* %filp)
  %cmp3 = icmp eq i32 %call, 0
  br i1 %cmp3, label %cleanup.cont, label %if.end5

if.end5:                                          ; preds = %if.end
  %mutex = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  call void @mxser_close_port(%struct.tty_port* %port1)
  call void @mxser_flush_buffer(%struct.tty_struct* %tty)
  %flags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %3 = load volatile i64, i64* %flags, align 8, !tbaa !62
  %and.i = and i64 2147483648, %3
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end5
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 2
  %4 = load i32, i32* %c_cflag, align 8, !tbaa !63
  %and = and i32 %4, 1024
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.then10
  call void @tty_port_lower_dtr_rts(%struct.tty_port* %port1)
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.then10, %if.end5
  call void @mxser_shutdown_port(%struct.tty_port* %port1)
  %flags15 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags15, i32 31, i64* %flags15) #7, !srcloc !64
  %mutex16 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_unlock(%struct.mutex* %mutex16)
  call void @tty_port_close_end(%struct.tty_port* %port1, %struct.tty_struct* %tty)
  call void @tty_port_tty_set(%struct.tty_port* %port1, %struct.tty_struct* null)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end14, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_write(%struct.tty_struct* %tty, i8* %buf, i32 %count) #4 {
entry:
  %_min1 = alloca i64, align 8
  %_min2 = alloca i64, align 8
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 15
  %2 = load i8*, i8** %xmit_buf, align 8, !tbaa !65
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end18, %if.end
  %total.0 = phi i32 [ 0, %if.end ], [ %add41, %if.end18 ]
  %count.addr.0 = phi i32 [ %count, %if.end ], [ %sub40, %if.end18 ]
  %buf.addr.0 = phi i8* [ %buf, %if.end ], [ %add.ptr39, %if.end18 ]
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %3 = load i32, i32* %xmit_cnt, align 4, !tbaa !66
  %conv = sext i32 %3 to i64
  %sub = sub i64 4096, %conv
  %sub1 = sub i64 %sub, 1
  store i64 %sub1, i64* %_min1, align 8, !tbaa !62
  %xmit_head = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  %4 = load i32, i32* %xmit_head, align 4, !tbaa !67
  %conv2 = sext i32 %4 to i64
  %sub3 = sub i64 4096, %conv2
  store i64 %sub3, i64* %_min2, align 8, !tbaa !62
  %5 = load i64, i64* %_min1, align 8, !tbaa !62
  %6 = load i64, i64* %_min2, align 8, !tbaa !62
  %cmp5 = icmp ult i64 %5, %6
  %7 = load i64, i64* %_min1, align 8
  %8 = load i64, i64* %_min2, align 8
  %cond = select i1 %cmp5, i64 %7, i64 %8
  %conv7 = trunc i64 %cond to i32
  %cmp9 = icmp slt i32 %count.addr.0, %conv7
  %count.addr.0.conv7 = select i1 %cmp9, i32 %count.addr.0, i32 %conv7
  %cmp15 = icmp sle i32 %count.addr.0.conv7, 0
  br i1 %cmp15, label %while.end, label %if.end18

if.end18:                                         ; preds = %while.cond
  %conv19 = sext i32 %count.addr.0.conv7 to i64
  %port20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf21 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port20, i32 0, i32 15
  %9 = load i8*, i8** %xmit_buf21, align 8, !tbaa !65
  %xmit_head22 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  %10 = load i32, i32* %xmit_head22, align 4, !tbaa !67
  %idx.ext = sext i32 %10 to i64
  %add.ptr = getelementptr inbounds i8, i8* %9, i64 %idx.ext
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr, i8* %buf.addr.0, i64 %conv19, i32 1, i1 false)
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call28 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %xmit_head31 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  %11 = load i32, i32* %xmit_head31, align 4, !tbaa !67
  %add = add nsw i32 %11, %count.addr.0.conv7
  %conv32 = sext i32 %add to i64
  %and = and i64 %conv32, 4095
  %conv33 = trunc i64 %and to i32
  %xmit_head34 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  store i32 %conv33, i32* %xmit_head34, align 4, !tbaa !67
  %xmit_cnt35 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %12 = load i32, i32* %xmit_cnt35, align 4, !tbaa !66
  %add36 = add nsw i32 %12, %count.addr.0.conv7
  store i32 %add36, i32* %xmit_cnt35, align 4, !tbaa !66
  %slock37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock37, i64 %call28)
  %idx.ext38 = sext i32 %count.addr.0.conv7 to i64
  %add.ptr39 = getelementptr inbounds i8, i8* %buf.addr.0, i64 %idx.ext38
  %sub40 = sub nsw i32 %count.addr.0, %count.addr.0.conv7
  %add41 = add nsw i32 %total.0, %count.addr.0.conv7
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %xmit_cnt42 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %13 = load i32, i32* %xmit_cnt42, align 4, !tbaa !66
  %tobool43 = icmp ne i32 %13, 0
  br i1 %tobool43, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %while.end
  %stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load = load i8, i8* %stopped, align 4
  %bf.clear = and i8 %bf.load, 1
  %tobool44 = icmp ne i8 %bf.clear, 0
  br i1 %tobool44, label %cleanup, label %if.then45

if.then45:                                        ; preds = %land.lhs.true
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load46 = load i8, i8* %hw_stopped, align 4
  %bf.lshr = lshr i8 %bf.load46, 1
  %bf.clear47 = and i8 %bf.lshr, 1
  %tobool48 = icmp ne i8 %bf.clear47, 0
  br i1 %tobool48, label %lor.lhs.false, label %do.body55

lor.lhs.false:                                    ; preds = %if.then45
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %14 = load i32, i32* %type, align 4, !tbaa !50
  %cmp49 = icmp eq i32 %14, 4
  br i1 %cmp49, label %do.body55, label %lor.lhs.false51

lor.lhs.false51:                                  ; preds = %lor.lhs.false
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %15 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %15, i32 0, i32 5
  %16 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool52 = icmp ne i32 %16, 0
  br i1 %tobool52, label %do.body55, label %cleanup

do.body55:                                        ; preds = %lor.lhs.false51, %lor.lhs.false, %if.then45
  %slock61 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call62 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock61)
  %call63 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call62)
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %17 = load i32, i32* %IER, align 4, !tbaa !68
  %and68 = and i32 %17, -3
  %conv69 = trunc i32 %and68 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %18 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add70 = add i64 %18, 1
  %conv71 = trunc i64 %add70 to i32
  call void @outb(i8 zeroext %conv69, i32 %conv71)
  %IER72 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %19 = load i32, i32* %IER72, align 4, !tbaa !68
  %or = or i32 %19, 2
  store i32 %or, i32* %IER72, align 4, !tbaa !68
  %IER73 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %20 = load i32, i32* %IER73, align 4, !tbaa !68
  %conv74 = trunc i32 %20 to i8
  %ioaddr75 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %21 = load i64, i64* %ioaddr75, align 8, !tbaa !24
  %add76 = add i64 %21, 1
  %conv77 = trunc i64 %add76 to i32
  call void @outb(i8 zeroext %conv74, i32 %conv77)
  %slock78 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock78, i64 %call63)
  br label %cleanup

cleanup:                                          ; preds = %do.body55, %lor.lhs.false51, %land.lhs.true, %while.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ %total.0, %lor.lhs.false51 ], [ %total.0, %do.body55 ], [ %total.0, %land.lhs.true ], [ %total.0, %while.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_put_char(%struct.tty_struct* %tty, i8 zeroext %ch) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 15
  %2 = load i8*, i8** %xmit_buf, align 8, !tbaa !65
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %3 = load i32, i32* %xmit_cnt, align 4, !tbaa !66
  %conv = sext i32 %3 to i64
  %cmp = icmp uge i64 %conv, 4095
  br i1 %cmp, label %cleanup, label %do.body4

do.body4:                                         ; preds = %if.end
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call7 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %port10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf11 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port10, i32 0, i32 15
  %4 = load i8*, i8** %xmit_buf11, align 8, !tbaa !65
  %xmit_head = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  %5 = load i32, i32* %xmit_head, align 4, !tbaa !67
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %xmit_head, align 4, !tbaa !67
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  store i8 %ch, i8* %arrayidx, align 1, !tbaa !56
  %xmit_head12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  %6 = load i32, i32* %xmit_head12, align 4, !tbaa !67
  %conv13 = sext i32 %6 to i64
  %and = and i64 %conv13, 4095
  %conv14 = trunc i64 %and to i32
  store i32 %conv14, i32* %xmit_head12, align 4, !tbaa !67
  %xmit_cnt15 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %7 = load i32, i32* %xmit_cnt15, align 4, !tbaa !66
  %inc16 = add nsw i32 %7, 1
  store i32 %inc16, i32* %xmit_cnt15, align 4, !tbaa !66
  %slock17 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock17, i64 %call7)
  %stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load = load i8, i8* %stopped, align 4
  %bf.clear = and i8 %bf.load, 1
  %tobool18 = icmp ne i8 %bf.clear, 0
  br i1 %tobool18, label %cleanup, label %if.then19

if.then19:                                        ; preds = %do.body4
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load20 = load i8, i8* %hw_stopped, align 4
  %bf.lshr = lshr i8 %bf.load20, 1
  %bf.clear21 = and i8 %bf.lshr, 1
  %tobool22 = icmp ne i8 %bf.clear21, 0
  br i1 %tobool22, label %lor.lhs.false, label %do.body29

lor.lhs.false:                                    ; preds = %if.then19
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %8 = load i32, i32* %type, align 4, !tbaa !50
  %cmp23 = icmp eq i32 %8, 4
  br i1 %cmp23, label %do.body29, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %lor.lhs.false
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %9 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %9, i32 0, i32 5
  %10 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool26 = icmp ne i32 %10, 0
  br i1 %tobool26, label %do.body29, label %cleanup

do.body29:                                        ; preds = %lor.lhs.false25, %lor.lhs.false, %if.then19
  %slock35 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call36 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock35)
  %call37 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call36)
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %11 = load i32, i32* %IER, align 4, !tbaa !68
  %and42 = and i32 %11, -3
  %conv43 = trunc i32 %and42 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %12 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %12, 1
  %conv44 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv43, i32 %conv44)
  %IER45 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %13 = load i32, i32* %IER45, align 4, !tbaa !68
  %or = or i32 %13, 2
  store i32 %or, i32* %IER45, align 4, !tbaa !68
  %IER46 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %14 = load i32, i32* %IER46, align 4, !tbaa !68
  %conv47 = trunc i32 %14 to i8
  %ioaddr48 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %15 = load i64, i64* %ioaddr48, align 8, !tbaa !24
  %add49 = add i64 %15, 1
  %conv50 = trunc i64 %add49 to i32
  call void @outb(i8 zeroext %conv47, i32 %conv50)
  %slock51 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock51, i64 %call37)
  br label %cleanup

cleanup:                                          ; preds = %do.body29, %lor.lhs.false25, %do.body4, %if.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 0, %if.end ], [ 1, %lor.lhs.false25 ], [ 1, %do.body29 ], [ 1, %do.body4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @mxser_flush_chars(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %2 = load i32, i32* %xmit_cnt, align 4, !tbaa !66
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %cleanup.cont, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load = load i8, i8* %stopped, align 4
  %bf.clear = and i8 %bf.load, 1
  %conv = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %cleanup.cont, label %lor.lhs.false1

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 15
  %3 = load i8*, i8** %xmit_buf, align 8, !tbaa !65
  %tobool2 = icmp ne i8* %3, null
  br i1 %tobool2, label %lor.lhs.false3, label %cleanup.cont

lor.lhs.false3:                                   ; preds = %lor.lhs.false1
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load4 = load i8, i8* %hw_stopped, align 4
  %bf.lshr = lshr i8 %bf.load4, 1
  %bf.clear5 = and i8 %bf.lshr, 1
  %conv6 = zext i8 %bf.clear5 to i32
  %tobool7 = icmp ne i32 %conv6, 0
  br i1 %tobool7, label %land.lhs.true, label %do.body12

land.lhs.true:                                    ; preds = %lor.lhs.false3
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %4 = load i32, i32* %type, align 4, !tbaa !50
  %cmp8 = icmp ne i32 %4, 4
  br i1 %cmp8, label %land.lhs.true10, label %do.body12

land.lhs.true10:                                  ; preds = %land.lhs.true
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %5 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %5, i32 0, i32 5
  %6 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool11 = icmp ne i32 %6, 0
  br i1 %tobool11, label %do.body12, label %cleanup.cont

do.body12:                                        ; preds = %land.lhs.true10, %land.lhs.true, %lor.lhs.false3
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call15 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %7 = load i32, i32* %IER, align 4, !tbaa !68
  %and = and i32 %7, -3
  %conv18 = trunc i32 %and to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %8 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %8, 1
  %conv19 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv18, i32 %conv19)
  %IER20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %9 = load i32, i32* %IER20, align 4, !tbaa !68
  %or = or i32 %9, 2
  store i32 %or, i32* %IER20, align 4, !tbaa !68
  %IER21 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %10 = load i32, i32* %IER21, align 4, !tbaa !68
  %conv22 = trunc i32 %10 to i8
  %ioaddr23 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %11 = load i64, i64* %ioaddr23, align 8, !tbaa !24
  %add24 = add i64 %11, 1
  %conv25 = trunc i64 %add24 to i32
  call void @outb(i8 zeroext %conv22, i32 %conv25)
  %slock26 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock26, i64 %call15)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.body12, %land.lhs.true10, %lor.lhs.false1, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_write_room(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %2 = load i32, i32* %xmit_cnt, align 4, !tbaa !66
  %conv = sext i32 %2 to i64
  %sub = sub i64 4096, %conv
  %sub1 = sub i64 %sub, 1
  %conv2 = trunc i64 %sub1 to i32
  %cmp = icmp slt i32 %conv2, 0
  %.conv2 = select i1 %cmp, i32 0, i32 %conv2
  ret i32 %.conv2
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_chars_in_buffer(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %2 = load i32, i32* %xmit_cnt, align 4, !tbaa !66
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_ioctl(%struct.tty_struct* %tty, i32 %cmd, i64 %arg) #4 {
entry:
  %cnow = alloca %struct.async_icount, align 4
  %__wait = alloca %struct.__wait_queue, align 8
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %port1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %2 = inttoptr i64 %arg to i8*
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %3 = load i32, i32* %index, align 8, !tbaa !58
  %cmp = icmp eq i32 %3, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @mxser_ioctl_special(i8* %2)
  br label %cleanup229

if.end:                                           ; preds = %entry
  switch i32 %cmd, label %cond.true [
    i32 1090, label %if.then5
    i32 1091, label %if.then5
    i32 21534, label %NodeBlock27
    i32 21596, label %NodeBlock27
  ]

if.then5:                                         ; preds = %if.end, %if.end
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %4 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %4, i32 0, i32 5
  %5 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %cmp6 = icmp ne i32 %5, 2
  br i1 %cmp6, label %cleanup229, label %if.end8

if.end8:                                          ; preds = %if.then5
  %index9 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %6 = load i32, i32* %index9, align 8, !tbaa !58
  %rem = srem i32 %6, 4
  %cmp10 = icmp eq i32 %cmd, 1090
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end8
  call void @might_fault()
  %7 = bitcast i8* %2 to i32*
  %8 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %7, i64 4) #7, !srcloc !69
  %asmresult = extractvalue { i32*, i64 } %8, 0
  %asmresult12 = extractvalue { i32*, i64 } %8, 1
  %9 = ptrtoint i32* %asmresult to i64
  %10 = trunc i64 %9 to i32
  %conv = trunc i64 %asmresult12 to i32
  %conv13 = sext i32 %conv to i64
  %tobool = icmp eq i32 %10, 0
  %switch = icmp ult i64 %conv13, 4
  %or.cond = and i1 %tobool, %switch
  br i1 %or.cond, label %if.end27, label %cleanup229

if.end27:                                         ; preds = %if.then11
  %idxprom = sext i32 %rem to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* @mxser_ioctl.ModeMask, i64 0, i64 %idxprom
  %11 = load i8, i8* %arrayidx, align 1, !tbaa !56
  %mul = mul nsw i32 %rem, 2
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_lock_irq(%struct.spinlock* %slock)
  %opmode_ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 3
  %12 = load i64, i64* %opmode_ioaddr, align 8, !tbaa !70
  %conv28 = trunc i64 %12 to i32
  %call29 = call zeroext i8 @inb(i32 %conv28)
  %conv30 = zext i8 %11 to i32
  %conv31 = zext i8 %call29 to i32
  %and = and i32 %conv31, %conv30
  %conv32 = trunc i32 %and to i8
  %sh_prom = zext i32 %mul to i64
  %shl = shl i64 %conv13, %sh_prom
  %conv33 = zext i8 %conv32 to i64
  %or = or i64 %conv33, %shl
  %conv34 = trunc i64 %or to i8
  %opmode_ioaddr35 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 3
  %13 = load i64, i64* %opmode_ioaddr35, align 8, !tbaa !70
  %conv36 = trunc i64 %13 to i32
  call void @outb(i8 zeroext %conv34, i32 %conv36)
  %slock37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irq(%struct.spinlock* %slock37)
  br label %if.end52

if.else:                                          ; preds = %if.end8
  %mul38 = mul nsw i32 %rem, 2
  %slock39 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_lock_irq(%struct.spinlock* %slock39)
  %opmode_ioaddr40 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 3
  %14 = load i64, i64* %opmode_ioaddr40, align 8, !tbaa !70
  %conv41 = trunc i64 %14 to i32
  %call42 = call zeroext i8 @inb(i32 %conv41)
  %conv43 = zext i8 %call42 to i32
  %shr = ashr i32 %conv43, %mul38
  %conv44 = sext i32 %shr to i64
  %slock45 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irq(%struct.spinlock* %slock45)
  %and46 = and i64 %conv44, 3
  call void @might_fault()
  %conv47 = trunc i64 %and46 to i32
  %15 = bitcast i8* %2 to i32*
  %16 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv47, i32* %15) #7, !srcloc !71
  %tobool49 = icmp ne i32 %16, 0
  br i1 %tobool49, label %cleanup229, label %if.end52

if.end52:                                         ; preds = %if.else, %if.end27
  br label %cleanup229

cond.true:                                        ; preds = %if.end
  %flags64 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 18
  %17 = load volatile i64, i64* %flags64, align 8, !tbaa !62
  %and.i = and i64 2, %17
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool66 = icmp ne i32 %conv.i, 0
  br i1 %tobool66, label %cleanup229, label %NodeBlock27

NodeBlock27:                                      ; preds = %cond.true, %if.end, %if.end
  %Pivot28 = icmp slt i32 %cmd, 1100
  br i1 %Pivot28, label %NodeBlock9, label %NodeBlock25

NodeBlock25:                                      ; preds = %NodeBlock27
  %Pivot26 = icmp slt i32 %cmd, 21535
  br i1 %Pivot26, label %NodeBlock13, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %cmd, 21593
  br i1 %Pivot24, label %LeafBlock15, label %NodeBlock21

NodeBlock21:                                      ; preds = %NodeBlock23
  %Pivot22 = icmp slt i32 %cmd, 21596
  br i1 %Pivot22, label %LeafBlock17, label %LeafBlock19

LeafBlock19:                                      ; preds = %NodeBlock21
  %SwitchLeaf20 = icmp eq i32 %cmd, 21596
  br i1 %SwitchLeaf20, label %do.body81, label %cleanup229

LeafBlock17:                                      ; preds = %NodeBlock21
  %SwitchLeaf18 = icmp eq i32 %cmd, 21593
  br i1 %SwitchLeaf18, label %sw.bb78, label %cleanup229

LeafBlock15:                                      ; preds = %NodeBlock23
  %SwitchLeaf16 = icmp eq i32 %cmd, 21535
  br i1 %SwitchLeaf16, label %sw.bb74, label %cleanup229

NodeBlock13:                                      ; preds = %NodeBlock25
  %Pivot14 = icmp slt i32 %cmd, 21534
  br i1 %Pivot14, label %LeafBlock11, label %sw.bb

LeafBlock11:                                      ; preds = %NodeBlock13
  %SwitchLeaf12 = icmp eq i32 %cmd, 1100
  br i1 %SwitchLeaf12, label %sw.bb212, label %cleanup229

NodeBlock9:                                       ; preds = %NodeBlock27
  %Pivot10 = icmp slt i32 %cmd, 1094
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %cmd, 1097
  br i1 %Pivot8, label %LeafBlock1, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %cmd, 1098
  br i1 %Pivot6, label %sw.bb141, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %cmd, 1098
  br i1 %SwitchLeaf4, label %sw.bb204, label %cleanup229

LeafBlock1:                                       ; preds = %NodeBlock7
  %SwitchLeaf2 = icmp eq i32 %cmd, 1094
  br i1 %SwitchLeaf2, label %sw.bb125, label %cleanup229

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %cmd, 1093
  br i1 %Pivot, label %LeafBlock, label %sw.bb121

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, 1085
  br i1 %SwitchLeaf, label %sw.bb115, label %cleanup229

sw.bb:                                            ; preds = %NodeBlock13
  %mutex = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_lock_nested(%struct.mutex* %mutex, i32 0)
  %18 = bitcast i8* %2 to %struct.serial_struct*
  %call72 = call i32 @mxser_get_serial_info(%struct.tty_struct* %tty, %struct.serial_struct* %18)
  %mutex73 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_unlock(%struct.mutex* %mutex73)
  br label %cleanup229

sw.bb74:                                          ; preds = %LeafBlock15
  %mutex75 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_lock_nested(%struct.mutex* %mutex75, i32 0)
  %19 = bitcast i8* %2 to %struct.serial_struct*
  %call76 = call i32 @mxser_set_serial_info(%struct.tty_struct* %tty, %struct.serial_struct* %19)
  %mutex77 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 13
  call void @mutex_unlock(%struct.mutex* %mutex77)
  br label %cleanup229

sw.bb78:                                          ; preds = %LeafBlock17
  %20 = bitcast i8* %2 to i32*
  %call79 = call i32 @mxser_get_lsr_info(%struct.mxser_port* %1, i32* %20)
  br label %cleanup229

do.body81:                                        ; preds = %LeafBlock19
  %slock85 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call86 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock85)
  %call87 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call86)
  %icount = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 17
  %21 = bitcast %struct.async_icount* %cnow to i8*
  %22 = bitcast %struct.async_icount* %icount to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 44, i32 4, i1 false), !tbaa.struct !72
  %slock90 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock90, i64 %call87)
  %call91 = call i32 @mxser_cflags_changed(%struct.mxser_port* %1, i64 %arg, %struct.async_icount* %cnow)
  %tobool92 = icmp ne i32 %call91, 0
  br i1 %tobool92, label %cleanup229, label %do.body94

do.body94:                                        ; preds = %do.body81
  %flags95 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags95, align 8, !tbaa !73
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %23 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !75
  %24 = bitcast %struct.task_struct* %23 to i8*
  store i8* %24, i8** %private, align 8, !tbaa !76
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !77
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list97 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list97, %struct.list_head** %next, align 8, !tbaa !78
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list98 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list98, %struct.list_head** %prev, align 8, !tbaa !79
  br label %for.cond

for.cond:                                         ; preds = %if.then107, %do.body94
  %port99 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %delta_msr_wait = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port99, i32 0, i32 9
  call void @prepare_to_wait(%struct.__wait_queue_head* %delta_msr_wait, %struct.__wait_queue* %__wait, i32 1)
  %call100 = call i32 @mxser_cflags_changed(%struct.mxser_port* %1, i64 %arg, %struct.async_icount* %cnow)
  %tobool101 = icmp ne i32 %call100, 0
  br i1 %tobool101, label %for.end, label %if.end103

if.end103:                                        ; preds = %for.cond
  %25 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !75
  %call105 = call i32 @signal_pending(%struct.task_struct* %25)
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %for.end, label %if.then107

if.then107:                                       ; preds = %if.end103
  call void @schedule()
  br label %for.cond

for.end:                                          ; preds = %if.end103, %for.cond
  %__ret.0 = phi i32 [ 0, %for.cond ], [ -512, %if.end103 ]
  %port109 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %delta_msr_wait110 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port109, i32 0, i32 9
  call void @finish_wait(%struct.__wait_queue_head* %delta_msr_wait110, %struct.__wait_queue* %__wait)
  br label %cleanup229

sw.bb115:                                         ; preds = %LeafBlock
  call void @might_fault()
  %baud_base = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %26 = load i32, i32* %baud_base, align 8, !tbaa !42
  %cmp118 = icmp ne i32 %26, 115200
  %cond = select i1 %cmp118, i32 1, i32 0
  %27 = bitcast i8* %2 to i32*
  %28 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %cond, i32* %27) #7, !srcloc !80
  br label %cleanup229

sw.bb121:                                         ; preds = %NodeBlock
  %slock122 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_lock_irq(%struct.spinlock* %slock122)
  %mon_data = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 26
  %rxcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data, i32 0, i32 0
  store i64 0, i64* %rxcnt, align 8, !tbaa !81
  %mon_data123 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 26
  %txcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data123, i32 0, i32 1
  store i64 0, i64* %txcnt, align 8, !tbaa !82
  %slock124 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irq(%struct.spinlock* %slock124)
  br label %cleanup229

sw.bb125:                                         ; preds = %LeafBlock1
  %call126 = call i32 @mxser_chars_in_buffer(%struct.tty_struct* %tty)
  %slock127 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_lock_irq(%struct.spinlock* %slock127)
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %29 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %29, 5
  %conv128 = trunc i64 %add to i32
  %call129 = call zeroext i8 @inb(i32 %conv128)
  %conv130 = zext i8 %call129 to i32
  %and131 = and i32 %conv130, 32
  %slock132 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irq(%struct.spinlock* %slock132)
  %tobool133 = icmp ne i32 %and131, 0
  %cond134 = select i1 %tobool133, i32 0, i32 1
  %add135 = add nsw i32 %call126, %cond134
  call void @might_fault()
  %30 = bitcast i8* %2 to i32*
  %31 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %add135, i32* %30) #7, !srcloc !83
  br label %cleanup229

sw.bb141:                                         ; preds = %NodeBlock5
  %slock142 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_lock_irq(%struct.spinlock* %slock142)
  %ioaddr143 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %32 = load i64, i64* %ioaddr143, align 8, !tbaa !24
  %conv144 = trunc i64 %32 to i32
  %index145 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %33 = load i32, i32* %index145, align 8, !tbaa !58
  %call146 = call zeroext i8 @mxser_get_msr(i32 %conv144, i32 1, i32 %33)
  %conv147 = zext i8 %call146 to i32
  call void @mxser_check_modem_status(%struct.tty_struct* %tty, %struct.mxser_port* %1, i32 %conv147)
  %ioaddr148 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %34 = load i64, i64* %ioaddr148, align 8, !tbaa !24
  %add149 = add i64 %34, 4
  %conv150 = trunc i64 %add149 to i32
  %call151 = call zeroext i8 @inb(i32 %conv150)
  %conv152 = zext i8 %call151 to i32
  %slock153 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irq(%struct.spinlock* %slock153)
  %and154 = and i32 %conv152, 64
  %tobool155 = icmp ne i32 %and154, 0
  %mon_data157 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 26
  %hold_reason = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data157, i32 0, i32 5
  %35 = load i8, i8* %hold_reason, align 4, !tbaa !84
  %conv158 = zext i8 %35 to i32
  %or165 = or i32 %conv158, 8
  %and159 = and i32 %conv158, -9
  %or165.sink = select i1 %tobool155, i32 %and159, i32 %or165
  %conv166 = trunc i32 %or165.sink to i8
  store i8 %conv166, i8* %hold_reason, align 4, !tbaa !84
  %and168 = and i32 %conv152, 8
  %tobool169 = icmp ne i32 %and168, 0
  %mon_data171 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 26
  %hold_reason172 = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data171, i32 0, i32 5
  %36 = load i8, i8* %hold_reason172, align 4, !tbaa !84
  %conv173 = zext i8 %36 to i32
  %or180 = or i32 %conv173, 16
  %and174 = and i32 %conv173, -17
  %or180.sink = select i1 %tobool169, i32 %and174, i32 %or180
  %conv181 = trunc i32 %or180.sink to i8
  store i8 %conv181, i8* %hold_reason172, align 4, !tbaa !84
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load = load i8, i8* %hw_stopped, align 4
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %tobool183 = icmp ne i8 %bf.clear, 0
  %mon_data185 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 26
  %hold_reason186 = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data185, i32 0, i32 5
  %37 = load i8, i8* %hold_reason186, align 4, !tbaa !84
  %conv187 = zext i8 %37 to i32
  %and194 = and i32 %conv187, -2
  %or188 = or i32 %conv187, 1
  %and194.sink = select i1 %tobool183, i32 %or188, i32 %and194
  %conv195 = trunc i32 %and194.sink to i8
  store i8 %conv195, i8* %hold_reason186, align 4, !tbaa !84
  %mon_data197 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 26
  %38 = bitcast %struct.mxser_mon* %mon_data197 to i8*
  call void @might_fault() #7
  %call.i = call i64 @_copy_to_user(i8* %2, i8* %38, i32 40) #7
  %conv.i1 = trunc i64 %call.i to i32
  %tobool199 = icmp ne i32 %conv.i1, 0
  %. = select i1 %tobool199, i32 -14, i32 0
  br label %cleanup229

sw.bb204:                                         ; preds = %LeafBlock3
  call void @might_fault()
  %err_shadow = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 16
  %39 = load i8, i8* %err_shadow, align 4, !tbaa !57
  %40 = zext i8 %39 to i32
  %41 = call i32 asm sideeffect "call __put_user_1", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %40, i8* %2) #7, !srcloc !85
  %tobool208 = icmp ne i32 %41, 0
  br i1 %tobool208, label %cleanup229, label %if.end210

if.end210:                                        ; preds = %sw.bb204
  %err_shadow211 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 16
  store i8 0, i8* %err_shadow211, align 4, !tbaa !57
  br label %cleanup229

sw.bb212:                                         ; preds = %LeafBlock11
  call void @might_fault()
  %42 = bitcast i8* %2 to i32*
  %43 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %42, i64 4) #7, !srcloc !86
  %asmresult215 = extractvalue { i32*, i64 } %43, 0
  %asmresult216 = extractvalue { i32*, i64 } %43, 1
  %44 = ptrtoint i32* %asmresult215 to i64
  %45 = trunc i64 %44 to i32
  %conv217 = trunc i64 %asmresult216 to i32
  %tobool219 = icmp ne i32 %45, 0
  br i1 %tobool219, label %cleanup229, label %if.end221

if.end221:                                        ; preds = %sw.bb212
  %index222 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %46 = load i32, i32* %index222, align 8, !tbaa !58
  %idxprom223 = sext i32 %46 to i64
  %arrayidx224 = getelementptr inbounds [33 x i32], [33 x i32]* @mxser_set_baud_method, i64 0, i64 %idxprom223
  store i32 %conv217, i32* %arrayidx224, align 4, !tbaa !55
  call void @might_fault()
  %47 = bitcast i8* %2 to i32*
  %48 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv217, i32* %47) #7, !srcloc !87
  br label %cleanup229

cleanup229:                                       ; preds = %if.end221, %sw.bb212, %if.end210, %sw.bb204, %sw.bb141, %sw.bb125, %sw.bb121, %sw.bb115, %for.end, %do.body81, %sw.bb78, %sw.bb74, %sw.bb, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock11, %LeafBlock15, %LeafBlock17, %LeafBlock19, %cond.true, %if.end52, %if.else, %if.then11, %if.then5, %if.then
  %retval.3 = phi i32 [ %call, %if.then ], [ %28, %sw.bb115 ], [ 0, %sw.bb121 ], [ %31, %sw.bb125 ], [ %., %sw.bb141 ], [ 0, %if.end210 ], [ %call72, %sw.bb ], [ %call76, %sw.bb74 ], [ %call79, %sw.bb78 ], [ 0, %if.end52 ], [ -14, %if.then5 ], [ -14, %if.then11 ], [ -14, %if.else ], [ -5, %cond.true ], [ 0, %do.body81 ], [ %__ret.0, %for.end ], [ -14, %sw.bb204 ], [ %48, %if.end221 ], [ -14, %sw.bb212 ], [ -515, %LeafBlock ], [ -515, %LeafBlock1 ], [ -515, %LeafBlock3 ], [ -515, %LeafBlock11 ], [ -515, %LeafBlock15 ], [ -515, %LeafBlock17 ], [ -515, %LeafBlock19 ]
  ret i32 %retval.3
}

; Function Attrs: nounwind uwtable
define internal void @mxser_set_termios(%struct.tty_struct* %tty, %struct.ktermios* %old_termios) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  call void @mxser_change_speed(%struct.tty_struct* %tty)
  %slock6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock6, i64 %call2)
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %old_termios, i32 0, i32 2
  %2 = load i32, i32* %c_cflag, align 4, !tbaa !88
  %and = and i32 %2, -2147483648
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_cflag7 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 2
  %3 = load i32, i32* %c_cflag7, align 8, !tbaa !63
  %and8 = and i32 %3, -2147483648
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load = load i8, i8* %hw_stopped, align 4
  %bf.clear = and i8 %bf.load, -3
  store i8 %bf.clear, i8* %hw_stopped, align 4
  call void @mxser_start(%struct.tty_struct* %tty)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %c_iflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %old_termios, i32 0, i32 0
  %4 = load i32, i32* %c_iflag, align 4, !tbaa !89
  %and10 = and i32 %4, 1024
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %land.lhs.true12, label %if.end38

land.lhs.true12:                                  ; preds = %if.end
  %termios13 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_iflag14 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios13, i32 0, i32 0
  %5 = load i32, i32* %c_iflag14, align 8, !tbaa !90
  %and15 = and i32 %5, 1024
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.end38, label %if.then17

if.then17:                                        ; preds = %land.lhs.true12
  %stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load18 = load i8, i8* %stopped, align 4
  %bf.clear19 = and i8 %bf.load18, -2
  store i8 %bf.clear19, i8* %stopped, align 4
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %6 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %6, i32 0, i32 5
  %7 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool20 = icmp ne i32 %7, 0
  br i1 %tobool20, label %do.body23, label %if.end37

do.body23:                                        ; preds = %if.then17
  %slock29 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call30 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock29)
  %call31 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call30)
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %8 = load i64, i64* %ioaddr, align 8, !tbaa !24
  call void @mxser_disable_must_rx_software_flow_control(i64 %8)
  %slock36 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock36, i64 %call31)
  br label %if.end37

if.end37:                                         ; preds = %do.body23, %if.then17
  call void @mxser_start(%struct.tty_struct* %tty)
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %land.lhs.true12, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_throttle(%struct.tty_struct* %tty) #4 {
entry:
  call void @mxser_stoprx(%struct.tty_struct* %tty)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_unthrottle(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %ldisc_stop_rx = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 14
  store i8 0, i8* %ldisc_stop_rx, align 1, !tbaa !48
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_iflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 0
  %2 = load i32, i32* %c_iflag, align 8, !tbaa !90
  %and = and i32 %2, 4096
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end23

if.then:                                          ; preds = %entry
  %x_char = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 10
  %3 = load i32, i32* %x_char, align 8, !tbaa !91
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %x_char3 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 10
  store i32 0, i32* %x_char3, align 8, !tbaa !91
  br label %if.end23

if.else:                                          ; preds = %if.then
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %4 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %4, i32 0, i32 5
  %5 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %6 = load i32, i32* %IER, align 4, !tbaa !68
  %or = or i32 %6, 17
  store i32 %or, i32* %IER, align 4, !tbaa !68
  %IER6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %7 = load i32, i32* %IER6, align 4, !tbaa !68
  %conv = trunc i32 %7 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %8 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %8, 1
  %conv7 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv, i32 %conv7)
  br label %if.end23

if.else8:                                         ; preds = %if.else
  %termios9 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_cc = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios9, i32 0, i32 5
  %arrayidx = getelementptr inbounds [19 x i8], [19 x i8]* %c_cc, i64 0, i64 8
  %9 = load i8, i8* %arrayidx, align 1, !tbaa !56
  %conv10 = zext i8 %9 to i32
  %x_char11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 10
  store i32 %conv10, i32* %x_char11, align 8, !tbaa !91
  %ioaddr12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %10 = load i64, i64* %ioaddr12, align 8, !tbaa !24
  %add13 = add i64 %10, 1
  %conv14 = trunc i64 %add13 to i32
  call void @outb(i8 zeroext 0, i32 %conv14)
  %IER15 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %11 = load i32, i32* %IER15, align 4, !tbaa !68
  %or16 = or i32 %11, 2
  store i32 %or16, i32* %IER15, align 4, !tbaa !68
  %IER17 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %12 = load i32, i32* %IER17, align 4, !tbaa !68
  %conv18 = trunc i32 %12 to i8
  %ioaddr19 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %13 = load i64, i64* %ioaddr19, align 8, !tbaa !24
  %add20 = add i64 %13, 1
  %conv21 = trunc i64 %add20 to i32
  call void @outb(i8 zeroext %conv18, i32 %conv21)
  br label %if.end23

if.end23:                                         ; preds = %if.else8, %if.then5, %if.then2, %entry
  %termios24 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios24, i32 0, i32 2
  %14 = load i32, i32* %c_cflag, align 8, !tbaa !63
  %and25 = and i32 %14, -2147483648
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then27, label %if.end34

if.then27:                                        ; preds = %if.end23
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %15 = load i32, i32* %MCR, align 8, !tbaa !92
  %or28 = or i32 %15, 2
  store i32 %or28, i32* %MCR, align 8, !tbaa !92
  %MCR29 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %16 = load i32, i32* %MCR29, align 8, !tbaa !92
  %conv30 = trunc i32 %16 to i8
  %ioaddr31 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %17 = load i64, i64* %ioaddr31, align 8, !tbaa !24
  %add32 = add i64 %17, 4
  %conv33 = trunc i64 %add32 to i32
  call void @outb(i8 zeroext %conv30, i32 %conv33)
  br label %if.end34

if.end34:                                         ; preds = %if.then27, %if.end23
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_stop(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %2 = load i32, i32* %IER, align 4, !tbaa !68
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %IER5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %3 = load i32, i32* %IER5, align 4, !tbaa !68
  %and6 = and i32 %3, -3
  store i32 %and6, i32* %IER5, align 4, !tbaa !68
  %IER7 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %4 = load i32, i32* %IER7, align 4, !tbaa !68
  %conv8 = trunc i32 %4 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %5 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %5, 1
  %conv9 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv8, i32 %conv9)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %slock10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock10, i64 %call2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_start(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  %2 = load i32, i32* %xmit_cnt, align 4, !tbaa !66
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 15
  %3 = load i8*, i8** %xmit_buf, align 8, !tbaa !65
  %tobool5 = icmp ne i8* %3, null
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %4 = load i32, i32* %IER, align 4, !tbaa !68
  %and = and i32 %4, -3
  %conv6 = trunc i32 %and to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %5 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %5, 1
  %conv7 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv6, i32 %conv7)
  %IER8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %6 = load i32, i32* %IER8, align 4, !tbaa !68
  %or = or i32 %6, 2
  store i32 %or, i32* %IER8, align 4, !tbaa !68
  %IER9 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %7 = load i32, i32* %IER9, align 4, !tbaa !68
  %conv10 = trunc i32 %7 to i8
  %ioaddr11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %8 = load i64, i64* %ioaddr11, align 8, !tbaa !24
  %add12 = add i64 %8, 1
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %conv10, i32 %conv13)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %slock14 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock14, i64 %call2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_hangup(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  call void @mxser_flush_buffer(%struct.tty_struct* %tty)
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  call void @tty_port_hangup(%struct.tty_port* %port)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_rs_break(%struct.tty_struct* %tty, i32 %break_state) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %cmp5 = icmp eq i32 %break_state, -1
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %2, 3
  %conv7 = trunc i64 %add to i32
  %call8 = call zeroext i8 @inb(i32 %conv7)
  %conv9 = zext i8 %call8 to i32
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %or = or i32 %conv9, 64
  %conv10 = trunc i32 %or to i8
  %ioaddr11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %3 = load i64, i64* %ioaddr11, align 8, !tbaa !24
  %add12 = add i64 %3, 3
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %conv10, i32 %conv13)
  br label %if.end

if.else:                                          ; preds = %entry
  %and = and i32 %conv9, -65
  %conv19 = trunc i32 %and to i8
  %ioaddr20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %4 = load i64, i64* %ioaddr20, align 8, !tbaa !24
  %add21 = add i64 %4, 3
  %conv22 = trunc i64 %add21 to i32
  call void @outb(i8 zeroext %conv19, i32 %conv22)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %slock23 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock23, i64 %call2)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @mxser_flush_buffer(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %xmit_tail = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 23
  store i32 0, i32* %xmit_tail, align 8, !tbaa !93
  %xmit_head = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  store i32 0, i32* %xmit_head, align 4, !tbaa !67
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  store i32 0, i32* %xmit_cnt, align 4, !tbaa !66
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %2, 2
  %conv5 = trunc i64 %add to i32
  %call6 = call zeroext i8 @inb(i32 %conv5)
  %conv7 = sext i8 %call6 to i32
  %or = or i32 %conv7, 2
  %or8 = or i32 %or, 4
  %conv9 = trunc i32 %or8 to i8
  %ioaddr10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %3 = load i64, i64* %ioaddr10, align 8, !tbaa !24
  %add11 = add i64 %3, 2
  %conv12 = trunc i64 %add11 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv12)
  %ioaddr13 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %4 = load i64, i64* %ioaddr13, align 8, !tbaa !24
  %add14 = add i64 %4, 2
  %conv15 = trunc i64 %add14 to i32
  call void @outb(i8 zeroext %call6, i32 %conv15)
  %slock16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock16, i64 %call2)
  call void @tty_wakeup(%struct.tty_struct* %tty)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_wait_until_sent(%struct.tty_struct* %tty, i32 %timeout) #4 {
entry:
  %__ret = alloca i64, align 8
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %2 = load i32, i32* %type, align 4, !tbaa !50
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %xmit_fifo_size = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 21
  %3 = load i32, i32* %xmit_fifo_size, align 8, !tbaa !94
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %cleanup.cont, label %if.end3

if.end3:                                          ; preds = %if.end
  %4 = load volatile i64, i64* @jiffies, align 8, !tbaa !62
  %timeout4 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 18
  %5 = load i32, i32* %timeout4, align 4, !tbaa !95
  %sub = sub nsw i32 %5, 5
  %xmit_fifo_size5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 21
  %6 = load i32, i32* %xmit_fifo_size5, align 8, !tbaa !94
  %div = sdiv i32 %sub, %6
  %conv = sext i32 %div to i64
  %div6 = udiv i64 %conv, 5
  %cmp7 = icmp eq i64 %div6, 0
  %.div6 = select i1 %cmp7, i64 1, i64 %div6
  %tobool = icmp ne i32 %timeout, 0
  %conv11 = sext i32 %timeout to i64
  %cmp12 = icmp ult i64 %conv11, %.div6
  %or.cond = and i1 %tobool, %cmp12
  %conv15 = sext i32 %timeout to i64
  %char_time.1 = select i1 %or.cond, i64 %conv15, i64 %.div6
  %tobool17 = icmp ne i32 %timeout, 0
  br i1 %tobool17, label %lor.lhs.false, label %if.then21

lor.lhs.false:                                    ; preds = %if.end3
  %timeout18 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 18
  %7 = load i32, i32* %timeout18, align 4, !tbaa !95
  %mul = mul nsw i32 2, %7
  %cmp19 = icmp sgt i32 %timeout, %mul
  br i1 %cmp19, label %if.then21, label %do.body25

if.then21:                                        ; preds = %lor.lhs.false, %if.end3
  %timeout22 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 18
  %8 = load i32, i32* %timeout22, align 4, !tbaa !95
  %mul23 = mul nsw i32 2, %8
  br label %do.body25

do.body25:                                        ; preds = %if.then21, %lor.lhs.false
  %timeout.addr.0 = phi i32 [ %mul23, %if.then21 ], [ %timeout, %lor.lhs.false ]
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call28 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  br label %while.cond

while.cond:                                       ; preds = %if.end78, %do.body25
  %flags.0 = phi i64 [ %call28, %do.body25 ], [ %call46, %if.end78 ]
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %9, 5
  %conv31 = trunc i64 %add to i32
  %call32 = call zeroext i8 @inb(i32 %conv31)
  %conv33 = zext i8 %call32 to i32
  %and = and i32 %conv33, 64
  %tobool34 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool34, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %slock35 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock35, i64 %flags.0)
  %call36 = call i64 @schedule_timeout_interruptible(i64 %char_time.1)
  %slock44 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call45 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock44)
  %call46 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call45)
  %10 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !75
  %call52 = call i32 @signal_pending(%struct.task_struct* %10)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %while.end, label %if.end55

if.end55:                                         ; preds = %while.body
  %tobool56 = icmp ne i32 %timeout.addr.0, 0
  br i1 %tobool56, label %land.lhs.true57, label %if.end78

land.lhs.true57:                                  ; preds = %if.end55
  %tobool63 = icmp ne i32 1, 0
  br i1 %tobool63, label %land.lhs.true64, label %if.end78

land.lhs.true64:                                  ; preds = %land.lhs.true57
  %conv72 = sext i32 %timeout.addr.0 to i64
  %add73 = add i64 %4, %conv72
  %11 = load volatile i64, i64* @jiffies, align 8, !tbaa !62
  %sub74 = sub nsw i64 %add73, %11
  %cmp75 = icmp slt i64 %sub74, 0
  br i1 %cmp75, label %while.end, label %if.end78

if.end78:                                         ; preds = %land.lhs.true64, %land.lhs.true57, %if.end55
  br label %while.cond

while.end:                                        ; preds = %land.lhs.true64, %while.body, %while.cond
  %flags.1 = phi i64 [ %call46, %while.body ], [ %call46, %land.lhs.true64 ], [ %flags.0, %while.cond ]
  %slock79 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock79, i64 %flags.1)
  store volatile i64 0, i64* %__ret, align 8, !tbaa !62
  %12 = load volatile i64, i64* %__ret, align 8, !tbaa !62
  %13 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !75
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %13, i32 0, i32 0
  %14 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state, i64 %12, i64* %state) #7, !srcloc !96
  store volatile i64 %14, i64* %__ret, align 8, !tbaa !62
  %15 = load volatile i64, i64* %__ret, align 8, !tbaa !62
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %while.end, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_tiocmget(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %2 = load i32, i32* %index, align 8, !tbaa !58
  %cmp = icmp eq i32 %2, 32
  br i1 %cmp, label %cleanup, label %cond.true

cond.true:                                        ; preds = %entry
  %flags1 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 18
  %3 = load volatile i64, i64* %flags1, align 8, !tbaa !62
  %and.i = and i64 2, %3
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %cleanup, label %if.end6

if.end6:                                          ; preds = %cond.true
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %4 = load i32, i32* %MCR, align 8, !tbaa !92
  %conv = trunc i32 %4 to i8
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call10 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call11 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call10)
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %5 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %5, 6
  %conv14 = trunc i64 %add to i32
  %call15 = call zeroext i8 @inb(i32 %conv14)
  %conv16 = zext i8 %call15 to i32
  %and = and i32 %conv16, 15
  %tobool17 = icmp ne i32 %and, 0
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end6
  %conv19 = zext i8 %call15 to i32
  call void @mxser_check_modem_status(%struct.tty_struct* %tty, %struct.mxser_port* %1, i32 %conv19)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end6
  %slock21 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock21, i64 %call11)
  %conv22 = zext i8 %conv to i32
  %and23 = and i32 %conv22, 2
  %tobool24 = icmp ne i32 %and23, 0
  %cond = select i1 %tobool24, i32 4, i32 0
  %conv25 = zext i8 %conv to i32
  %and26 = and i32 %conv25, 1
  %tobool27 = icmp ne i32 %and26, 0
  %cond28 = select i1 %tobool27, i32 2, i32 0
  %or = or i32 %cond, %cond28
  %conv29 = zext i8 %call15 to i32
  %and30 = and i32 %conv29, 128
  %tobool31 = icmp ne i32 %and30, 0
  %cond32 = select i1 %tobool31, i32 64, i32 0
  %or33 = or i32 %or, %cond32
  %conv34 = zext i8 %call15 to i32
  %and35 = and i32 %conv34, 64
  %tobool36 = icmp ne i32 %and35, 0
  %cond37 = select i1 %tobool36, i32 128, i32 0
  %or38 = or i32 %or33, %cond37
  %conv39 = zext i8 %call15 to i32
  %and40 = and i32 %conv39, 32
  %tobool41 = icmp ne i32 %and40, 0
  %cond42 = select i1 %tobool41, i32 256, i32 0
  %or43 = or i32 %or38, %cond42
  %conv44 = zext i8 %call15 to i32
  %and45 = and i32 %conv44, 16
  %tobool46 = icmp ne i32 %and45, 0
  %cond47 = select i1 %tobool46, i32 32, i32 0
  %or48 = or i32 %or43, %cond47
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %cond.true, %entry
  %retval.0 = phi i32 [ %or48, %if.end20 ], [ -515, %entry ], [ -5, %cond.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_tiocmset(%struct.tty_struct* %tty, i32 %set, i32 %clear) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %2 = load i32, i32* %index, align 8, !tbaa !58
  %cmp = icmp eq i32 %2, 32
  br i1 %cmp, label %cleanup, label %cond.true

cond.true:                                        ; preds = %entry
  %flags1 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 18
  %3 = load volatile i64, i64* %flags1, align 8, !tbaa !62
  %and.i = and i64 2, %3
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %cleanup, label %do.body7

do.body7:                                         ; preds = %cond.true
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call9 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call10 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call9)
  %and = and i32 %set, 4
  %tobool13 = icmp ne i32 %and, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %do.body7
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %4 = load i32, i32* %MCR, align 8, !tbaa !92
  %or = or i32 %4, 2
  store i32 %or, i32* %MCR, align 8, !tbaa !92
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %do.body7
  %and16 = and i32 %set, 2
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.end15
  %MCR19 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %5 = load i32, i32* %MCR19, align 8, !tbaa !92
  %or20 = or i32 %5, 1
  store i32 %or20, i32* %MCR19, align 8, !tbaa !92
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %if.end15
  %and22 = and i32 %clear, 4
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end27

if.then24:                                        ; preds = %if.end21
  %MCR25 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %6 = load i32, i32* %MCR25, align 8, !tbaa !92
  %and26 = and i32 %6, -3
  store i32 %and26, i32* %MCR25, align 8, !tbaa !92
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %if.end21
  %and28 = and i32 %clear, 2
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then30, label %if.end33

if.then30:                                        ; preds = %if.end27
  %MCR31 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %7 = load i32, i32* %MCR31, align 8, !tbaa !92
  %and32 = and i32 %7, -2
  store i32 %and32, i32* %MCR31, align 8, !tbaa !92
  br label %if.end33

if.end33:                                         ; preds = %if.then30, %if.end27
  %MCR34 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %8 = load i32, i32* %MCR34, align 8, !tbaa !92
  %conv35 = trunc i32 %8 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %9, 4
  %conv36 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv35, i32 %conv36)
  %slock37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock37, i64 %call10)
  br label %cleanup

cleanup:                                          ; preds = %if.end33, %cond.true, %entry
  %retval.0 = phi i32 [ 0, %if.end33 ], [ -515, %entry ], [ -5, %cond.true ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_get_icount(%struct.tty_struct* %tty, %struct.serial_icounter_struct* %icount) #4 {
entry:
  %cnow = alloca %struct.async_icount, align 4
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %icount5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 17
  %2 = bitcast %struct.async_icount* %cnow to i8*
  %3 = bitcast %struct.async_icount* %icount5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 44, i32 4, i1 false), !tbaa.struct !72
  %slock6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock6, i64 %call2)
  %frame = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 6
  %4 = load i32, i32* %frame, align 4, !tbaa !97
  %frame7 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 6
  store i32 %4, i32* %frame7, align 4, !tbaa !98
  %brk = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 9
  %5 = load i32, i32* %brk, align 4, !tbaa !100
  %brk8 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 9
  store i32 %5, i32* %brk8, align 4, !tbaa !101
  %overrun = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 8
  %6 = load i32, i32* %overrun, align 4, !tbaa !102
  %overrun9 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 7
  store i32 %6, i32* %overrun9, align 4, !tbaa !103
  %buf_overrun = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 10
  %7 = load i32, i32* %buf_overrun, align 4, !tbaa !104
  %buf_overrun10 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 10
  store i32 %7, i32* %buf_overrun10, align 4, !tbaa !105
  %parity = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 7
  %8 = load i32, i32* %parity, align 4, !tbaa !106
  %parity11 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 8
  store i32 %8, i32* %parity11, align 4, !tbaa !107
  %rx = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 5
  %9 = load i32, i32* %rx, align 4, !tbaa !108
  %rx12 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 4
  store i32 %9, i32* %rx12, align 4, !tbaa !109
  %tx = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 4
  %10 = load i32, i32* %tx, align 4, !tbaa !110
  %tx13 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 5
  store i32 %10, i32* %tx13, align 4, !tbaa !111
  %cts = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 0
  %11 = load i32, i32* %cts, align 4, !tbaa !112
  %cts14 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 0
  store i32 %11, i32* %cts14, align 4, !tbaa !113
  %dsr = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 1
  %12 = load i32, i32* %dsr, align 4, !tbaa !114
  %dsr15 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 1
  store i32 %12, i32* %dsr15, align 4, !tbaa !115
  %rng = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 2
  %13 = load i32, i32* %rng, align 4, !tbaa !116
  %rng16 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 2
  store i32 %13, i32* %rng16, align 4, !tbaa !117
  %dcd = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 3
  %14 = load i32, i32* %dcd, align 4, !tbaa !118
  %dcd17 = getelementptr inbounds %struct.serial_icounter_struct, %struct.serial_icounter_struct* %icount, i32 0, i32 3
  store i32 %14, i32* %dcd17, align 4, !tbaa !119
  ret i32 0
}

declare i32 @tty_port_open(%struct.tty_port*, %struct.tty_struct*, %struct.file*) #3

declare i32 @tty_port_close_start(%struct.tty_port*, %struct.tty_struct*, %struct.file*) #3

declare void @mutex_lock_nested(%struct.mutex*, i32) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_close_port(%struct.tty_port* %port) #4 {
entry:
  %0 = bitcast %struct.tty_port* %port to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.mxser_port*
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %2 = load i32, i32* %IER, align 4, !tbaa !68
  %and = and i32 %2, -5
  store i32 %and, i32* %IER, align 4, !tbaa !68
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %3 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %3, i32 0, i32 5
  %4 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %IER1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %5 = load i32, i32* %IER1, align 4, !tbaa !68
  %and2 = and i32 %5, -18
  store i32 %and2, i32* %IER1, align 4, !tbaa !68
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %IER3 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %6 = load i32, i32* %IER3, align 4, !tbaa !68
  %conv = trunc i32 %6 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %7 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %7, 1
  %conv4 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv, i32 %conv4)
  %8 = load volatile i64, i64* @jiffies, align 8, !tbaa !62
  %add5 = add i64 %8, 250
  br label %while.cond

while.cond:                                       ; preds = %if.end26, %if.end
  %ioaddr6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr6, align 8, !tbaa !24
  %add7 = add i64 %9, 5
  %conv8 = trunc i64 %add7 to i32
  %call = call zeroext i8 @inb(i32 %conv8)
  %conv9 = zext i8 %call to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %lnot = xor i1 %tobool11, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call12 = call i64 @schedule_timeout_interruptible(i64 5)
  %tobool15 = icmp ne i32 1, 0
  br i1 %tobool15, label %land.lhs.true, label %if.end26

land.lhs.true:                                    ; preds = %while.body
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !62
  %sub = sub nsw i64 %add5, %10
  %cmp23 = icmp slt i64 %sub, 0
  br i1 %cmp23, label %while.end, label %if.end26

if.end26:                                         ; preds = %land.lhs.true, %while.body
  br label %while.cond

while.end:                                        ; preds = %land.lhs.true, %while.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #0 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #7, !srcloc !120
  ret i32 %0
}

declare void @tty_port_lower_dtr_rts(%struct.tty_port*) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_shutdown_port(%struct.tty_port* %port) #4 {
entry:
  %0 = bitcast %struct.tty_port* %port to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %port6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %delta_msr_wait = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port6, i32 0, i32 9
  call void @__wake_up(%struct.__wait_queue_head* %delta_msr_wait, i32 1, i32 1, i8* null)
  %port7 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port7, i32 0, i32 15
  %2 = load i8*, i8** %xmit_buf, align 8, !tbaa !65
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %port8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf9 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port8, i32 0, i32 15
  %3 = load i8*, i8** %xmit_buf9, align 8, !tbaa !65
  %4 = ptrtoint i8* %3 to i64
  call void @free_pages(i64 %4, i32 0)
  %port10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf11 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port10, i32 0, i32 15
  store i8* null, i8** %xmit_buf11, align 8, !tbaa !65
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  store i32 0, i32* %IER, align 4, !tbaa !68
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %5 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %5, 1
  %conv12 = trunc i64 %add to i32
  call void @outb(i8 zeroext 0, i32 %conv12)
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %6 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %6, i32 0, i32 5
  %7 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool13 = icmp ne i32 %7, 0
  %ioaddr15 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %8 = load i64, i64* %ioaddr15, align 8, !tbaa !24
  %add16 = add i64 %8, 2
  %conv17 = trunc i64 %add16 to i32
  br i1 %tobool13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  call void @outb(i8 zeroext 38, i32 %conv17)
  br label %if.end21

if.else:                                          ; preds = %if.end
  call void @outb(i8 zeroext 6, i32 %conv17)
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then14
  %ioaddr22 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr22, align 8, !tbaa !24
  %add23 = add i64 %9, 0
  %conv24 = trunc i64 %add23 to i32
  %call25 = call zeroext i8 @inb(i32 %conv24)
  %board26 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %10 = load %struct.mxser_board*, %struct.mxser_board** %board26, align 8, !tbaa !46
  %chip_flag27 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %10, i32 0, i32 5
  %11 = load i32, i32* %chip_flag27, align 8, !tbaa !17
  %tobool28 = icmp ne i32 %11, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end21
  %ioaddr30 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %12 = load i64, i64* %ioaddr30, align 8, !tbaa !24
  call void @SET_MOXA_MUST_NO_SOFTWARE_FLOW_CONTROL(i64 %12)
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end21
  %slock32 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock32, i64 %call3)
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #3

declare void @tty_port_close_end(%struct.tty_port*, %struct.tty_struct*) #3

declare void @tty_port_tty_set(%struct.tty_port*, %struct.tty_struct*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #0 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #7, !srcloc !121
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #0 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #7, !srcloc !122
  ret i8 %0
}

declare i64 @schedule_timeout_interruptible(i64) #3

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #3

declare void @free_pages(i64, i32) #3

; Function Attrs: nounwind uwtable
define internal void @SET_MOXA_MUST_NO_SOFTWARE_FLOW_CONTROL(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -16
  %conv7 = trunc i32 %and to i8
  %add8 = add i64 %baseio, 2
  %conv9 = trunc i64 %add8 to i32
  call void @outb(i8 zeroext %conv7, i32 %conv9)
  %add10 = add i64 %baseio, 3
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #3 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal i32 @mxser_ioctl_special(i8* %argp) #4 {
entry:
  br label %if.end

if.end:                                           ; preds = %entry
  %0 = load i32, i32* @ttymajor, align 4, !tbaa !55
  %1 = bitcast i8* %argp to i32*
  %2 = call i32 @simpll__inlineasm_0(i32 %0, i32* %1)
  br label %cleanup243

for.cond:                                         ; No predecessors!
  br label %for.cond4

for.cond4:                                        ; preds = %for.body6, %for.cond
  %j.0 = phi i32 [ %inc, %for.body6 ], [ 0, %for.cond ]
  %result.1 = phi i32 [ %result.2, %for.body6 ], [ %result.1, %for.cond ]
  br label %for.body6

for.body6:                                        ; preds = %for.cond4
  %idxprom = zext i32 undef to i64
  %arrayidx = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx, i32 0, i32 7
  %idxprom7 = zext i32 %j.0 to i64
  %arrayidx8 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom7
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx8, i32 0, i32 2
  %3 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %tobool9 = icmp ne i64 %3, 0
  %shl = shl i32 1, undef
  %or = or i32 %result.1, %shl
  %result.2 = select i1 %tobool9, i32 %or, i32 %result.1
  %inc = add i32 %j.0, 1
  br label %for.cond4

for.inc231:                                       ; preds = %for.inc231
  br label %for.inc231

cleanup243:                                       ; preds = %if.end
  ret i32 %2
}

declare void @might_fault() #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_irq(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irq(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_get_serial_info(%struct.tty_struct* %tty, %struct.serial_struct* %retinfo) #4 {
entry:
  %tmp = alloca %struct.serial_struct, align 8
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %type = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 0
  %type1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %2 = load i32, i32* %type1, align 4, !tbaa !50
  store i32 %2, i32* %type, align 8, !tbaa !123
  %line = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 1
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %3 = load i32, i32* %index, align 8, !tbaa !58
  store i32 %3, i32* %line, align 4, !tbaa !125
  %port = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 2
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %4 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %conv = trunc i64 %4 to i32
  store i32 %conv, i32* %port, align 8, !tbaa !126
  %irq = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 3
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %5 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %irq2 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %5, i32 0, i32 1
  %6 = load i32, i32* %irq2, align 4, !tbaa !23
  store i32 %6, i32* %irq, align 4, !tbaa !127
  %flags = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 4
  %port3 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %flags4 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port3, i32 0, i32 10
  %7 = load i64, i64* %flags4, align 8, !tbaa !49
  %conv5 = trunc i64 %7 to i32
  store i32 %conv5, i32* %flags, align 8, !tbaa !128
  %xmit_fifo_size = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 5
  store i32 0, i32* %xmit_fifo_size, align 4, !tbaa !129
  %custom_divisor = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 6
  %custom_divisor6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 15
  %8 = load i32, i32* %custom_divisor6, align 8, !tbaa !51
  store i32 %8, i32* %custom_divisor, align 8, !tbaa !130
  %baud_base = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 7
  %baud_base7 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %9 = load i32, i32* %baud_base7, align 8, !tbaa !42
  store i32 %9, i32* %baud_base, align 4, !tbaa !131
  %close_delay = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 8
  %port8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %close_delay9 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port8, i32 0, i32 16
  %10 = load i32, i32* %close_delay9, align 8, !tbaa !52
  %conv10 = trunc i32 %10 to i16
  store i16 %conv10, i16* %close_delay, align 8, !tbaa !132
  %io_type = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 9
  store i8 0, i8* %io_type, align 2, !tbaa !133
  %reserved_char = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 10
  %11 = bitcast [1 x i8]* %reserved_char to i8*
  call void @llvm.memset.p0i8.i64(i8* %11, i8 0, i64 1, i32 1, i1 false)
  %hub6 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 11
  store i32 0, i32* %hub6, align 4, !tbaa !134
  %closing_wait = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 12
  %port11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %closing_wait12 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port11, i32 0, i32 17
  %12 = load i32, i32* %closing_wait12, align 4, !tbaa !53
  %conv13 = trunc i32 %12 to i16
  store i16 %conv13, i16* %closing_wait, align 8, !tbaa !135
  %closing_wait2 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 13
  store i16 0, i16* %closing_wait2, align 2, !tbaa !136
  %iomem_base = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 14
  store i8* null, i8** %iomem_base, align 8, !tbaa !137
  %iomem_reg_shift = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 15
  store i16 0, i16* %iomem_reg_shift, align 8, !tbaa !138
  %port_high = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 16
  store i32 0, i32* %port_high, align 4, !tbaa !139
  %iomap_base = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %tmp, i32 0, i32 17
  store i64 0, i64* %iomap_base, align 8, !tbaa !140
  %13 = bitcast %struct.serial_struct* %retinfo to i8*
  %14 = bitcast %struct.serial_struct* %tmp to i8*
  call void @might_fault() #7
  %call.i = call i64 @_copy_to_user(i8* %13, i8* %14, i32 72) #7
  %conv.i = trunc i64 %call.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  %. = select i1 %tobool, i32 -14, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_set_serial_info(%struct.tty_struct* %tty, %struct.serial_struct* %new_info) #4 {
entry:
  %new_serial = alloca %struct.serial_struct, align 8
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %port1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %tobool = icmp ne %struct.serial_struct* %new_info, null
  br i1 %tobool, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %tobool3 = icmp ne i64 %2, 0
  br i1 %tobool3, label %if.end, label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %3 = bitcast %struct.serial_struct* %new_serial to i8*
  %4 = bitcast %struct.serial_struct* %new_info to i8*
  %call = call i64 @copy_from_user(i8* %3, i8* %4, i64 72)
  %tobool4 = icmp ne i64 %call, 0
  br i1 %tobool4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %irq = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 3
  %5 = load i32, i32* %irq, align 4, !tbaa !127
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %6 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %irq7 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %6, i32 0, i32 1
  %7 = load i32, i32* %irq7, align 4, !tbaa !23
  %cmp = icmp ne i32 %5, %7
  br i1 %cmp, label %cleanup, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %if.end6
  %port9 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 2
  %8 = load i32, i32* %port9, align 8, !tbaa !126
  %conv = zext i32 %8 to i64
  %ioaddr10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr10, align 8, !tbaa !24
  %cmp11 = icmp ne i64 %conv, %9
  br i1 %cmp11, label %cleanup, label %if.end14

if.end14:                                         ; preds = %lor.lhs.false8
  %flags15 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %10 = load i64, i64* %flags15, align 8, !tbaa !141
  %and = and i64 %10, 4144
  %conv16 = trunc i64 %and to i32
  %call17 = call zeroext i1 @capable(i32 21)
  br i1 %call17, label %if.else, label %if.then18

if.then18:                                        ; preds = %if.end14
  %baud_base = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 7
  %11 = load i32, i32* %baud_base, align 4, !tbaa !131
  %baud_base19 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %12 = load i32, i32* %baud_base19, align 8, !tbaa !42
  %cmp20 = icmp ne i32 %11, %12
  br i1 %cmp20, label %cleanup, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %if.then18
  %close_delay = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 8
  %13 = load i16, i16* %close_delay, align 8, !tbaa !132
  %conv23 = zext i16 %13 to i32
  %port24 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %close_delay25 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port24, i32 0, i32 16
  %14 = load i32, i32* %close_delay25, align 8, !tbaa !52
  %cmp26 = icmp ne i32 %conv23, %14
  br i1 %cmp26, label %cleanup, label %lor.lhs.false28

lor.lhs.false28:                                  ; preds = %lor.lhs.false22
  %flags29 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 4
  %15 = load i32, i32* %flags29, align 8, !tbaa !128
  %and30 = and i32 %15, -13361
  %conv31 = zext i32 %and30 to i64
  %port32 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %flags33 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port32, i32 0, i32 10
  %16 = load i64, i64* %flags33, align 8, !tbaa !49
  %and34 = and i64 %16, 4294953935
  %cmp35 = icmp ne i64 %conv31, %and34
  br i1 %cmp35, label %cleanup, label %if.end38

if.end38:                                         ; preds = %lor.lhs.false28
  %port39 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %flags40 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port39, i32 0, i32 10
  %17 = load i64, i64* %flags40, align 8, !tbaa !49
  %and41 = and i64 %17, 4294953935
  %flags42 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 4
  %18 = load i32, i32* %flags42, align 8, !tbaa !128
  %and43 = and i32 %18, 13360
  %conv44 = zext i32 %and43 to i64
  %or = or i64 %and41, %conv44
  %port45 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %flags46 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port45, i32 0, i32 10
  store i64 %or, i64* %flags46, align 8, !tbaa !49
  br label %if.end87

if.else:                                          ; preds = %if.end14
  %flags47 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %19 = load i64, i64* %flags47, align 8, !tbaa !141
  %and48 = and i64 %19, 4294901760
  %flags49 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 4
  %20 = load i32, i32* %flags49, align 8, !tbaa !128
  %and50 = and i32 %20, 65535
  %conv51 = zext i32 %and50 to i64
  %or52 = or i64 %and48, %conv51
  %flags53 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  store i64 %or52, i64* %flags53, align 8, !tbaa !141
  %close_delay54 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 8
  %21 = load i16, i16* %close_delay54, align 8, !tbaa !132
  %conv55 = zext i16 %21 to i32
  %mul = mul nsw i32 %conv55, 250
  %div = sdiv i32 %mul, 100
  %close_delay56 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 16
  store i32 %div, i32* %close_delay56, align 8, !tbaa !142
  %closing_wait = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 12
  %22 = load i16, i16* %closing_wait, align 8, !tbaa !135
  %conv57 = zext i16 %22 to i32
  %mul58 = mul nsw i32 %conv57, 250
  %div59 = sdiv i32 %mul58, 100
  %closing_wait60 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 17
  store i32 %div59, i32* %closing_wait60, align 4, !tbaa !143
  %flags61 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %23 = load i64, i64* %flags61, align 8, !tbaa !141
  %and62 = and i64 %23, 8192
  %tobool63 = icmp ne i64 %and62, 0
  %cond = select i1 %tobool63, i32 1, i32 0
  %conv64 = trunc i32 %cond to i8
  %low_latency = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 12
  %bf.load = load i8, i8* %low_latency, align 8
  %bf.value = and i8 %conv64, 1
  %bf.shl = shl i8 %bf.value, 1
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, i8* %low_latency, align 8
  %flags65 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %24 = load i64, i64* %flags65, align 8, !tbaa !141
  %and66 = and i64 %24, 4144
  %cmp67 = icmp eq i64 %and66, 48
  br i1 %cmp67, label %land.lhs.true, label %if.end87

land.lhs.true:                                    ; preds = %if.else
  %baud_base69 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 7
  %25 = load i32, i32* %baud_base69, align 4, !tbaa !131
  %baud_base70 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %26 = load i32, i32* %baud_base70, align 8, !tbaa !42
  %cmp71 = icmp ne i32 %25, %26
  br i1 %cmp71, label %if.then77, label %lor.lhs.false73

lor.lhs.false73:                                  ; preds = %land.lhs.true
  %custom_divisor = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 6
  %27 = load i32, i32* %custom_divisor, align 8, !tbaa !130
  %custom_divisor74 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 15
  %28 = load i32, i32* %custom_divisor74, align 8, !tbaa !51
  %cmp75 = icmp ne i32 %27, %28
  br i1 %cmp75, label %if.then77, label %if.end87

if.then77:                                        ; preds = %lor.lhs.false73, %land.lhs.true
  %custom_divisor78 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 6
  %29 = load i32, i32* %custom_divisor78, align 8, !tbaa !130
  %cmp79 = icmp eq i32 %29, 0
  br i1 %cmp79, label %cleanup, label %if.end82

if.end82:                                         ; preds = %if.then77
  %baud_base83 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 7
  %30 = load i32, i32* %baud_base83, align 4, !tbaa !131
  %custom_divisor84 = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 6
  %31 = load i32, i32* %custom_divisor84, align 8, !tbaa !130
  %div85 = sdiv i32 %30, %31
  call void @tty_encode_baud_rate(%struct.tty_struct* %tty, i32 %div85, i32 %div85)
  br label %if.end87

if.end87:                                         ; preds = %if.end82, %lor.lhs.false73, %if.else, %if.end38
  %type = getelementptr inbounds %struct.serial_struct, %struct.serial_struct* %new_serial, i32 0, i32 0
  %32 = load i32, i32* %type, align 8, !tbaa !123
  %type88 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  store i32 %32, i32* %type88, align 4, !tbaa !50
  call void @process_txrx_fifo(%struct.mxser_port* %1)
  %flags89 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %33 = load volatile i64, i64* %flags89, align 8, !tbaa !62
  %and.i = and i64 2147483648, %33
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool91 = icmp ne i32 %conv.i, 0
  br i1 %tobool91, label %if.then95, label %if.else112

if.then95:                                        ; preds = %if.end87
  %conv96 = zext i32 %conv16 to i64
  %flags97 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  %34 = load i64, i64* %flags97, align 8, !tbaa !141
  %and98 = and i64 %34, 4144
  %cmp99 = icmp ne i64 %conv96, %and98
  br i1 %cmp99, label %do.body102, label %cleanup

do.body102:                                       ; preds = %if.then95
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call105 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call106 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call105)
  call void @mxser_change_speed(%struct.tty_struct* %tty)
  %slock110 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock110, i64 %call106)
  br label %cleanup

if.else112:                                       ; preds = %if.end87
  %call113 = call i32 @mxser_activate(%struct.tty_port* %port1, %struct.tty_struct* %tty)
  %cmp114 = icmp eq i32 %call113, 0
  br i1 %cmp114, label %if.then116, label %cleanup

if.then116:                                       ; preds = %if.else112
  %flags117 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port1, i32 0, i32 10
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags117, i32 31, i64* %flags117) #7, !srcloc !144
  br label %cleanup

cleanup:                                          ; preds = %if.then116, %if.else112, %do.body102, %if.then95, %if.then77, %lor.lhs.false28, %lor.lhs.false22, %if.then18, %lor.lhs.false8, %if.end6, %if.end, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ -19, %lor.lhs.false ], [ -19, %entry ], [ -14, %if.end ], [ -22, %lor.lhs.false8 ], [ -22, %if.end6 ], [ -1, %lor.lhs.false28 ], [ -1, %lor.lhs.false22 ], [ -1, %if.then18 ], [ -22, %if.then77 ], [ 0, %do.body102 ], [ 0, %if.then95 ], [ %call113, %if.then116 ], [ %call113, %if.else112 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_get_lsr_info(%struct.mxser_port* %info, i32* %value) #4 {
entry:
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %0 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %0, 5
  %conv5 = trunc i64 %add to i32
  %call6 = call zeroext i8 @inb(i32 %conv5)
  %slock7 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock7, i64 %call2)
  %conv8 = zext i8 %call6 to i32
  %and = and i32 %conv8, 64
  %tobool = icmp ne i32 %and, 0
  %cond = select i1 %tobool, i32 1, i32 0
  call void @might_fault()
  %1 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %cond, i32* %value) #7, !srcloc !145
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_cflags_changed(%struct.mxser_port* %info, i64 %arg, %struct.async_icount* %cprev) #4 {
entry:
  %cnow = alloca %struct.async_icount, align 4
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %icount = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 17
  %0 = bitcast %struct.async_icount* %cnow to i8*
  %1 = bitcast %struct.async_icount* %icount to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 44, i32 4, i1 false), !tbaa.struct !72
  %slock5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock5, i64 %call2)
  %and = and i64 %arg, 128
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %rng = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 2
  %2 = load i32, i32* %rng, align 4, !tbaa !116
  %rng6 = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cprev, i32 0, i32 2
  %3 = load i32, i32* %rng6, align 4, !tbaa !116
  %cmp7 = icmp ne i32 %2, %3
  br i1 %cmp7, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %and9 = and i64 %arg, 256
  %tobool10 = icmp ne i64 %and9, 0
  br i1 %tobool10, label %land.lhs.true11, label %lor.lhs.false15

land.lhs.true11:                                  ; preds = %lor.lhs.false
  %dsr = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 1
  %4 = load i32, i32* %dsr, align 4, !tbaa !114
  %dsr12 = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cprev, i32 0, i32 1
  %5 = load i32, i32* %dsr12, align 4, !tbaa !114
  %cmp13 = icmp ne i32 %4, %5
  br i1 %cmp13, label %lor.end, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %land.lhs.true11, %lor.lhs.false
  %and16 = and i64 %arg, 64
  %tobool17 = icmp ne i64 %and16, 0
  br i1 %tobool17, label %land.lhs.true18, label %lor.rhs

land.lhs.true18:                                  ; preds = %lor.lhs.false15
  %dcd = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 3
  %6 = load i32, i32* %dcd, align 4, !tbaa !118
  %dcd19 = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cprev, i32 0, i32 3
  %7 = load i32, i32* %dcd19, align 4, !tbaa !118
  %cmp20 = icmp ne i32 %6, %7
  br i1 %cmp20, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true18, %lor.lhs.false15
  %and22 = and i64 %arg, 32
  %tobool23 = icmp ne i64 %and22, 0
  br i1 %tobool23, label %land.rhs, label %lor.end

land.rhs:                                         ; preds = %lor.rhs
  %cts = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cnow, i32 0, i32 0
  %8 = load i32, i32* %cts, align 4, !tbaa !112
  %cts24 = getelementptr inbounds %struct.async_icount, %struct.async_icount* %cprev, i32 0, i32 0
  %9 = load i32, i32* %cts24, align 4, !tbaa !112
  %cmp25 = icmp ne i32 %8, %9
  br label %lor.end

lor.end:                                          ; preds = %land.rhs, %lor.rhs, %land.lhs.true18, %land.lhs.true11, %land.lhs.true
  %10 = phi i1 [ true, %land.lhs.true18 ], [ true, %land.lhs.true11 ], [ true, %land.lhs.true ], [ false, %lor.rhs ], [ %cmp25, %land.rhs ]
  %lor.ext = zext i1 %10 to i32
  %11 = bitcast %struct.async_icount* %cprev to i8*
  %12 = bitcast %struct.async_icount* %cnow to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 44, i32 4, i1 false), !tbaa.struct !72
  ret i32 %lor.ext
}

declare i32 @autoremove_wake_function(%struct.__wait_queue*, i32, i32, i8*) #3

declare void @prepare_to_wait(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #0 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

declare void @schedule() #3

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #3

; Function Attrs: nounwind uwtable
define internal zeroext i8 @mxser_get_msr(i32 %baseaddr, i32 %mode, i32 %port) #4 {
entry:
  %add = add nsw i32 %baseaddr, 6
  %call = call zeroext i8 @inb(i32 %add)
  %idxprom = sext i32 %port to i64
  %arrayidx = getelementptr inbounds [33 x i8], [33 x i8]* @mxser_get_msr.mxser_msr, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !56
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %arrayidx, align 1, !tbaa !56
  %conv2 = zext i8 %call to i32
  %idxprom3 = sext i32 %port to i64
  %arrayidx4 = getelementptr inbounds [33 x i8], [33 x i8]* @mxser_get_msr.mxser_msr, i64 0, i64 %idxprom3
  %1 = load i8, i8* %arrayidx4, align 1, !tbaa !56
  %conv5 = zext i8 %1 to i32
  %or = or i32 %conv5, %conv2
  %conv6 = trunc i32 %or to i8
  store i8 %conv6, i8* %arrayidx4, align 1, !tbaa !56
  %idxprom7 = sext i32 %port to i64
  %arrayidx8 = getelementptr inbounds [33 x i8], [33 x i8]* @mxser_get_msr.mxser_msr, i64 0, i64 %idxprom7
  %2 = load i8, i8* %arrayidx8, align 1, !tbaa !56
  %tobool = icmp ne i32 %mode, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %idxprom9 = sext i32 %port to i64
  %arrayidx10 = getelementptr inbounds [33 x i8], [33 x i8]* @mxser_get_msr.mxser_msr, i64 0, i64 %idxprom9
  store i8 0, i8* %arrayidx10, align 1, !tbaa !56
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i8 %2
}

; Function Attrs: nounwind uwtable
define internal void @mxser_check_modem_status(%struct.tty_struct* %tty, %struct.mxser_port* %port, i32 %status) #4 {
entry:
  %and = and i32 %status, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %icount = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %rng = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount, i32 0, i32 2
  %0 = load i32, i32* %rng, align 8, !tbaa !146
  %inc = add i32 %0, 1
  store i32 %inc, i32* %rng, align 8, !tbaa !146
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %and1 = and i32 %status, 2
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %icount4 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %dsr = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount4, i32 0, i32 1
  %1 = load i32, i32* %dsr, align 4, !tbaa !147
  %inc5 = add i32 %1, 1
  store i32 %inc5, i32* %dsr, align 4, !tbaa !147
  br label %if.end6

if.end6:                                          ; preds = %if.then3, %if.end
  %and7 = and i32 %status, 8
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end6
  %icount10 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %dcd = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount10, i32 0, i32 3
  %2 = load i32, i32* %dcd, align 4, !tbaa !148
  %inc11 = add i32 %2, 1
  store i32 %inc11, i32* %dcd, align 4, !tbaa !148
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end6
  %and13 = and i32 %status, 1
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then15, label %if.end18

if.then15:                                        ; preds = %if.end12
  %icount16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %cts = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount16, i32 0, i32 0
  %3 = load i32, i32* %cts, align 8, !tbaa !149
  %inc17 = add i32 %3, 1
  store i32 %inc17, i32* %cts, align 8, !tbaa !149
  br label %if.end18

if.end18:                                         ; preds = %if.then15, %if.end12
  %mon_data = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 26
  %modem_status = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data, i32 0, i32 4
  store i32 %status, i32* %modem_status, align 8, !tbaa !150
  %port19 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %delta_msr_wait = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port19, i32 0, i32 9
  call void @__wake_up(%struct.__wait_queue_head* %delta_msr_wait, i32 1, i32 1, i8* null)
  %port20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %flags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port20, i32 0, i32 10
  %4 = load i64, i64* %flags, align 8, !tbaa !49
  %and21 = and i64 %4, 33554432
  %tobool22 = icmp ne i64 %and21, 0
  %and23 = and i32 %status, 8
  %tobool24 = icmp ne i32 %and23, 0
  %or.cond = and i1 %tobool22, %tobool24
  %and26 = and i32 %status, 128
  %tobool27 = icmp ne i32 %and26, 0
  %or.cond1 = and i1 %or.cond, %tobool27
  br i1 %or.cond1, label %if.then28, label %if.end31

if.then28:                                        ; preds = %if.end18
  %port29 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %open_wait = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port29, i32 0, i32 7
  call void @__wake_up(%struct.__wait_queue_head* %open_wait, i32 1, i32 1, i8* null)
  br label %if.end31

if.end31:                                         ; preds = %if.then28, %if.end18
  %port32 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %call = call zeroext i1 @tty_port_cts_enabled(%struct.tty_port* %port32)
  br i1 %call, label %if.then33, label %if.end79

if.then33:                                        ; preds = %if.end31
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load = load i8, i8* %hw_stopped, align 4
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %tobool34 = icmp ne i8 %bf.clear, 0
  %and36 = and i32 %status, 16
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool34, label %if.then35, label %if.else

if.then35:                                        ; preds = %if.then33
  br i1 %tobool37, label %if.then38, label %if.end79

if.then38:                                        ; preds = %if.then35
  %hw_stopped39 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load40 = load i8, i8* %hw_stopped39, align 4
  %bf.clear41 = and i8 %bf.load40, -3
  store i8 %bf.clear41, i8* %hw_stopped39, align 4
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 9
  %5 = load i32, i32* %type, align 4, !tbaa !50
  %cmp = icmp ne i32 %5, 4
  br i1 %cmp, label %land.lhs.true42, label %if.end53

land.lhs.true42:                                  ; preds = %if.then38
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %6 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %6, i32 0, i32 5
  %7 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool43 = icmp ne i32 %7, 0
  br i1 %tobool43, label %if.end53, label %if.then44

if.then44:                                        ; preds = %land.lhs.true42
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %8 = load i32, i32* %IER, align 4, !tbaa !68
  %and45 = and i32 %8, -3
  %conv = trunc i32 %and45 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %9 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %9, 1
  %conv46 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv, i32 %conv46)
  %IER47 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %10 = load i32, i32* %IER47, align 4, !tbaa !68
  %or = or i32 %10, 2
  store i32 %or, i32* %IER47, align 4, !tbaa !68
  %IER48 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %11 = load i32, i32* %IER48, align 4, !tbaa !68
  %conv49 = trunc i32 %11 to i8
  %ioaddr50 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %12 = load i64, i64* %ioaddr50, align 8, !tbaa !24
  %add51 = add i64 %12, 1
  %conv52 = trunc i64 %add51 to i32
  call void @outb(i8 zeroext %conv49, i32 %conv52)
  br label %if.end53

if.end53:                                         ; preds = %if.then44, %land.lhs.true42, %if.then38
  call void @tty_wakeup(%struct.tty_struct* %tty)
  br label %if.end79

if.else:                                          ; preds = %if.then33
  br i1 %tobool37, label %if.end79, label %if.then57

if.then57:                                        ; preds = %if.else
  %hw_stopped58 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load59 = load i8, i8* %hw_stopped58, align 4
  %bf.clear60 = and i8 %bf.load59, -3
  %bf.set = or i8 %bf.clear60, 2
  store i8 %bf.set, i8* %hw_stopped58, align 4
  %type61 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 9
  %13 = load i32, i32* %type61, align 4, !tbaa !50
  %cmp62 = icmp ne i32 %13, 4
  br i1 %cmp62, label %land.lhs.true64, label %if.end79

land.lhs.true64:                                  ; preds = %if.then57
  %board65 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %14 = load %struct.mxser_board*, %struct.mxser_board** %board65, align 8, !tbaa !46
  %chip_flag66 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %14, i32 0, i32 5
  %15 = load i32, i32* %chip_flag66, align 8, !tbaa !17
  %tobool67 = icmp ne i32 %15, 0
  br i1 %tobool67, label %if.end79, label %if.then68

if.then68:                                        ; preds = %land.lhs.true64
  %IER69 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %16 = load i32, i32* %IER69, align 4, !tbaa !68
  %and70 = and i32 %16, -3
  store i32 %and70, i32* %IER69, align 4, !tbaa !68
  %IER71 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %17 = load i32, i32* %IER71, align 4, !tbaa !68
  %conv72 = trunc i32 %17 to i8
  %ioaddr73 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %18 = load i64, i64* %ioaddr73, align 8, !tbaa !24
  %add74 = add i64 %18, 1
  %conv75 = trunc i64 %add74 to i32
  call void @outb(i8 zeroext %conv72, i32 %conv75)
  br label %if.end79

if.end79:                                         ; preds = %if.then68, %land.lhs.true64, %if.then57, %if.else, %if.end53, %if.then35, %if.end31
  ret void
}

declare i32 @___ratelimit(%struct.ratelimit_state*, i8*) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

declare %struct.tty_struct* @tty_port_tty_get(%struct.tty_port*) #3

declare void @tty_kref_put(%struct.tty_struct*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @kzalloc(i64 %size, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call.i = call i8* @__kmalloc(i64 %size, i32 %or) #7
  ret void
}

declare i32 @tty_termios_baud_rate(%struct.ktermios*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @tty_get_baud_rate(%struct.tty_struct* %tty) #0 {
entry:
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %call = call i32 @tty_termios_baud_rate(%struct.ktermios* %termios)
  ret i32 %call
}

declare void @kfree(i8*) #3

declare i8* @__kmalloc(i64, i32) #3

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #3 section ".spinlock.text"

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #0 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.10, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.11, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

declare zeroext i1 @capable(i32) #3

declare void @tty_encode_baud_rate(%struct.tty_struct*, i32, i32) #3

; Function Attrs: nounwind uwtable
define internal void @process_txrx_fifo(%struct.mxser_port* %info) #4 {
entry:
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 9
  %0 = load i32, i32* %type, align 4, !tbaa !50
  %cmp = icmp eq i32 %0, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %type1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 9
  %1 = load i32, i32* %type1, align 4, !tbaa !50
  %cmp2 = icmp eq i32 %1, 1
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %rx_trigger = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 6
  store i32 1, i32* %rx_trigger, align 8, !tbaa !151
  %rx_high_water = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 5
  store i32 1, i32* %rx_high_water, align 4, !tbaa !152
  %rx_low_water = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 7
  store i32 1, i32* %rx_low_water, align 4, !tbaa !153
  br label %if.end25.sink.split

if.else:                                          ; preds = %lor.lhs.false
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %i.0 = phi i32 [ 0, %if.else ], [ %inc, %for.inc ]
  %conv = sext i32 %i.0 to i64
  %cmp3 = icmp ult i64 %conv, 3
  br i1 %cmp3, label %for.body, label %if.end25

for.body:                                         ; preds = %for.cond
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 1
  %2 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %2, i32 0, i32 5
  %3 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.anon.48], [3 x %struct.anon.48]* @Gpci_uart_info, i64 0, i64 %idxprom
  %type5 = getelementptr inbounds %struct.anon.48, %struct.anon.48* %arrayidx, i32 0, i32 0
  %4 = load i32, i32* %type5, align 8, !tbaa !154
  %cmp6 = icmp eq i32 %3, %4
  br i1 %cmp6, label %if.then8, label %for.inc

if.then8:                                         ; preds = %for.body
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [3 x %struct.anon.48], [3 x %struct.anon.48]* @Gpci_uart_info, i64 0, i64 %idxprom9
  %rx_trigger11 = getelementptr inbounds %struct.anon.48, %struct.anon.48* %arrayidx10, i32 0, i32 5
  %5 = load i32, i32* %rx_trigger11, align 4, !tbaa !156
  %rx_trigger12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 6
  store i32 %5, i32* %rx_trigger12, align 8, !tbaa !151
  %idxprom13 = sext i32 %i.0 to i64
  %arrayidx14 = getelementptr inbounds [3 x %struct.anon.48], [3 x %struct.anon.48]* @Gpci_uart_info, i64 0, i64 %idxprom13
  %rx_low_water15 = getelementptr inbounds %struct.anon.48, %struct.anon.48* %arrayidx14, i32 0, i32 6
  %6 = load i32, i32* %rx_low_water15, align 8, !tbaa !157
  %rx_low_water16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 7
  store i32 %6, i32* %rx_low_water16, align 4, !tbaa !153
  %idxprom17 = sext i32 %i.0 to i64
  %arrayidx18 = getelementptr inbounds [3 x %struct.anon.48], [3 x %struct.anon.48]* @Gpci_uart_info, i64 0, i64 %idxprom17
  %rx_high_water19 = getelementptr inbounds %struct.anon.48, %struct.anon.48* %arrayidx18, i32 0, i32 4
  %7 = load i32, i32* %rx_high_water19, align 8, !tbaa !158
  %rx_high_water20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 5
  store i32 %7, i32* %rx_high_water20, align 4, !tbaa !152
  %idxprom21 = sext i32 %i.0 to i64
  %arrayidx22 = getelementptr inbounds [3 x %struct.anon.48], [3 x %struct.anon.48]* @Gpci_uart_info, i64 0, i64 %idxprom21
  %xmit_fifo_size23 = getelementptr inbounds %struct.anon.48, %struct.anon.48* %arrayidx22, i32 0, i32 3
  %8 = load i32, i32* %xmit_fifo_size23, align 4, !tbaa !159
  br label %if.end25.sink.split

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end25.sink.split:                              ; preds = %if.then8, %if.then
  %.sink = phi i32 [ %8, %if.then8 ], [ 1, %if.then ]
  %xmit_fifo_size24 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 21
  store i32 %.sink, i32* %xmit_fifo_size24, align 8, !tbaa !94
  br label %if.end25

if.end25:                                         ; preds = %if.end25.sink.split, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_change_speed(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 2
  %2 = load i32, i32* %c_cflag, align 8, !tbaa !63
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %3 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %4 = load i32, i32* %index, align 8, !tbaa !58
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [33 x i32], [33 x i32]* @mxser_set_baud_method, i64 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4, !tbaa !55
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %call = call i32 @tty_get_baud_rate(%struct.tty_struct* %tty)
  %conv = zext i32 %call to i64
  call void @mxser_set_baud(%struct.tty_struct* %tty, i64 %conv)
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  %and = and i32 %2, 48
  %Pivot10 = icmp slt i32 %and, 32
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %if.end3
  %Pivot8 = icmp slt i32 %and, 48
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %and, 48
  br i1 %SwitchLeaf6, label %sw.epilog, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %and, 32
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

NodeBlock:                                        ; preds = %if.end3
  %Pivot = icmp slt i32 %and, 16
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 16
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %and, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %cval.0 = phi i32 [ 0, %sw.default ], [ 0, %LeafBlock ], [ 1, %LeafBlock1 ], [ 2, %LeafBlock3 ], [ 3, %LeafBlock5 ]
  %and7 = and i32 %2, 64
  %tobool8 = icmp ne i32 %and7, 0
  %or = or i32 %cval.0, 4
  %or.cval.0 = select i1 %tobool8, i32 %or, i32 %cval.0
  %and11 = and i32 %2, 256
  %tobool12 = icmp ne i32 %and11, 0
  %or14 = or i32 %or.cval.0, 8
  %cval.2 = select i1 %tobool12, i32 %or14, i32 %or.cval.0
  %and16 = and i32 %2, 512
  %tobool17 = icmp ne i32 %and16, 0
  %or19 = or i32 %cval.2, 16
  %cval.2.or19 = select i1 %tobool17, i32 %cval.2, i32 %or19
  %and21 = and i32 %2, 1073741824
  %tobool22 = icmp ne i32 %and21, 0
  %or24 = or i32 %cval.2.or19, 32
  %cval.4 = select i1 %tobool22, i32 %or24, i32 %cval.2.or19
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %6 = load i32, i32* %type, align 4, !tbaa !50
  %cmp26 = icmp eq i32 %6, 1
  br i1 %cmp26, label %if.then31, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %type28 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %7 = load i32, i32* %type28, align 4, !tbaa !50
  %cmp29 = icmp eq i32 %7, 2
  br i1 %cmp29, label %if.then31, label %if.else36

if.then31:                                        ; preds = %lor.lhs.false, %sw.epilog
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %8 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %8, i32 0, i32 5
  %9 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool32 = icmp ne i32 %9, 0
  br i1 %tobool32, label %if.then33, label %if.end52

if.then33:                                        ; preds = %if.then31
  %or34 = or i32 1, 32
  call void @mxser_set_must_fifo_value(%struct.mxser_port* %1)
  br label %if.end52

if.else36:                                        ; preds = %lor.lhs.false
  %board37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %10 = load %struct.mxser_board*, %struct.mxser_board** %board37, align 8, !tbaa !46
  %chip_flag38 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %10, i32 0, i32 5
  %11 = load i32, i32* %chip_flag38, align 8, !tbaa !17
  %tobool39 = icmp ne i32 %11, 0
  br i1 %tobool39, label %if.then40, label %if.else42

if.then40:                                        ; preds = %if.else36
  %or41 = or i32 1, 32
  call void @mxser_set_must_fifo_value(%struct.mxser_port* %1)
  br label %if.end52

if.else42:                                        ; preds = %if.else36
  %rx_trigger = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 6
  %12 = load i32, i32* %rx_trigger, align 8, !tbaa !151
  %Pivot21 = icmp slt i32 %12, 4
  br i1 %Pivot21, label %LeafBlock12, label %NodeBlock18

NodeBlock18:                                      ; preds = %if.else42
  %Pivot19 = icmp slt i32 %12, 8
  br i1 %Pivot19, label %LeafBlock14, label %LeafBlock16

LeafBlock16:                                      ; preds = %NodeBlock18
  %SwitchLeaf17 = icmp eq i32 %12, 8
  br i1 %SwitchLeaf17, label %sw.bb46, label %sw.default48

LeafBlock14:                                      ; preds = %NodeBlock18
  %SwitchLeaf15 = icmp eq i32 %12, 4
  br i1 %SwitchLeaf15, label %sw.bb44, label %sw.default48

LeafBlock12:                                      ; preds = %if.else42
  %SwitchLeaf13 = icmp eq i32 %12, 1
  br i1 %SwitchLeaf13, label %if.end52, label %sw.default48

sw.bb44:                                          ; preds = %LeafBlock14
  %or45 = or i32 1, 64
  br label %if.end52

sw.bb46:                                          ; preds = %LeafBlock16
  %or47 = or i32 1, 128
  br label %if.end52

sw.default48:                                     ; preds = %LeafBlock12, %LeafBlock14, %LeafBlock16
  %or49 = or i32 1, 192
  br label %if.end52

if.end52:                                         ; preds = %sw.default48, %sw.bb46, %sw.bb44, %LeafBlock12, %if.then40, %if.then33, %if.then31
  %fcr.3 = phi i32 [ %or34, %if.then33 ], [ 0, %if.then31 ], [ %or41, %if.then40 ], [ %or49, %sw.default48 ], [ %or45, %sw.bb44 ], [ %or47, %sw.bb46 ], [ 1, %LeafBlock12 ]
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %13 = load i32, i32* %IER, align 4, !tbaa !68
  %and53 = and i32 %13, -9
  store i32 %and53, i32* %IER, align 4, !tbaa !68
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %14 = load i32, i32* %MCR, align 8, !tbaa !92
  %and54 = and i32 %14, -33
  store i32 %and54, i32* %MCR, align 8, !tbaa !92
  %and55 = and i32 %2, -2147483648
  %tobool56 = icmp ne i32 %and55, 0
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %flags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 10
  %15 = load i64, i64* %flags, align 8, !tbaa !49
  br i1 %tobool56, label %if.then57, label %if.else133

if.then57:                                        ; preds = %if.end52
  %or58 = or i64 %15, 67108864
  store i64 %or58, i64* %flags, align 8, !tbaa !49
  %IER59 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %16 = load i32, i32* %IER59, align 4, !tbaa !68
  %or60 = or i32 %16, 8
  store i32 %or60, i32* %IER59, align 4, !tbaa !68
  %type61 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %17 = load i32, i32* %type61, align 4, !tbaa !50
  %cmp62 = icmp eq i32 %17, 4
  br i1 %cmp62, label %if.then68, label %lor.lhs.false64

lor.lhs.false64:                                  ; preds = %if.then57
  %board65 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %18 = load %struct.mxser_board*, %struct.mxser_board** %board65, align 8, !tbaa !46
  %chip_flag66 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %18, i32 0, i32 5
  %19 = load i32, i32* %chip_flag66, align 8, !tbaa !17
  %tobool67 = icmp ne i32 %19, 0
  br i1 %tobool67, label %if.then68, label %if.else71

if.then68:                                        ; preds = %lor.lhs.false64, %if.then57
  %MCR69 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %20 = load i32, i32* %MCR69, align 8, !tbaa !92
  %or70 = or i32 %20, 32
  store i32 %or70, i32* %MCR69, align 8, !tbaa !92
  br label %if.end137

if.else71:                                        ; preds = %lor.lhs.false64
  %ioaddr72 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %21 = load i64, i64* %ioaddr72, align 8, !tbaa !24
  %add = add i64 %21, 6
  %conv73 = trunc i64 %add to i32
  %call74 = call zeroext i8 @inb(i32 %conv73)
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load = load i8, i8* %hw_stopped, align 4
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %tobool75 = icmp ne i8 %bf.clear, 0
  %conv77 = zext i8 %call74 to i32
  %and78 = and i32 %conv77, 16
  %tobool79 = icmp ne i32 %and78, 0
  br i1 %tobool75, label %if.then76, label %if.else106

if.then76:                                        ; preds = %if.else71
  br i1 %tobool79, label %if.then80, label %if.end137

if.then80:                                        ; preds = %if.then76
  %hw_stopped81 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load82 = load i8, i8* %hw_stopped81, align 4
  %bf.clear83 = and i8 %bf.load82, -3
  store i8 %bf.clear83, i8* %hw_stopped81, align 4
  %type84 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %22 = load i32, i32* %type84, align 4, !tbaa !50
  %cmp85 = icmp ne i32 %22, 4
  br i1 %cmp85, label %land.lhs.true, label %if.end104

land.lhs.true:                                    ; preds = %if.then80
  %board87 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %23 = load %struct.mxser_board*, %struct.mxser_board** %board87, align 8, !tbaa !46
  %chip_flag88 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %23, i32 0, i32 5
  %24 = load i32, i32* %chip_flag88, align 8, !tbaa !17
  %tobool89 = icmp ne i32 %24, 0
  br i1 %tobool89, label %if.end104, label %if.then90

if.then90:                                        ; preds = %land.lhs.true
  %IER91 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %25 = load i32, i32* %IER91, align 4, !tbaa !68
  %and92 = and i32 %25, -3
  %conv93 = trunc i32 %and92 to i8
  %ioaddr94 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %26 = load i64, i64* %ioaddr94, align 8, !tbaa !24
  %add95 = add i64 %26, 1
  %conv96 = trunc i64 %add95 to i32
  call void @outb(i8 zeroext %conv93, i32 %conv96)
  %IER97 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %27 = load i32, i32* %IER97, align 4, !tbaa !68
  %or98 = or i32 %27, 2
  store i32 %or98, i32* %IER97, align 4, !tbaa !68
  %IER99 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %28 = load i32, i32* %IER99, align 4, !tbaa !68
  %conv100 = trunc i32 %28 to i8
  %ioaddr101 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %29 = load i64, i64* %ioaddr101, align 8, !tbaa !24
  %add102 = add i64 %29, 1
  %conv103 = trunc i64 %add102 to i32
  call void @outb(i8 zeroext %conv100, i32 %conv103)
  br label %if.end104

if.end104:                                        ; preds = %if.then90, %land.lhs.true, %if.then80
  call void @tty_wakeup(%struct.tty_struct* %tty)
  br label %if.end137

if.else106:                                       ; preds = %if.else71
  br i1 %tobool79, label %if.end137, label %if.then110

if.then110:                                       ; preds = %if.else106
  %hw_stopped111 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load112 = load i8, i8* %hw_stopped111, align 4
  %bf.clear113 = and i8 %bf.load112, -3
  %bf.set = or i8 %bf.clear113, 2
  store i8 %bf.set, i8* %hw_stopped111, align 4
  %type114 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %30 = load i32, i32* %type114, align 4, !tbaa !50
  %cmp115 = icmp ne i32 %30, 4
  br i1 %cmp115, label %land.lhs.true117, label %if.end137

land.lhs.true117:                                 ; preds = %if.then110
  %board118 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %31 = load %struct.mxser_board*, %struct.mxser_board** %board118, align 8, !tbaa !46
  %chip_flag119 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %31, i32 0, i32 5
  %32 = load i32, i32* %chip_flag119, align 8, !tbaa !17
  %tobool120 = icmp ne i32 %32, 0
  br i1 %tobool120, label %if.end137, label %if.then121

if.then121:                                       ; preds = %land.lhs.true117
  %IER122 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %33 = load i32, i32* %IER122, align 4, !tbaa !68
  %and123 = and i32 %33, -3
  store i32 %and123, i32* %IER122, align 4, !tbaa !68
  %IER124 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %34 = load i32, i32* %IER124, align 4, !tbaa !68
  %conv125 = trunc i32 %34 to i8
  %ioaddr126 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %35 = load i64, i64* %ioaddr126, align 8, !tbaa !24
  %add127 = add i64 %35, 1
  %conv128 = trunc i64 %add127 to i32
  call void @outb(i8 zeroext %conv125, i32 %conv128)
  br label %if.end137

if.else133:                                       ; preds = %if.end52
  %and136 = and i64 %15, 4227858431
  store i64 %and136, i64* %flags, align 8, !tbaa !49
  br label %if.end137

if.end137:                                        ; preds = %if.else133, %if.then121, %land.lhs.true117, %if.then110, %if.else106, %if.end104, %if.then76, %if.then68
  %MCR138 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %36 = load i32, i32* %MCR138, align 8, !tbaa !92
  %conv139 = trunc i32 %36 to i8
  %ioaddr140 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %37 = load i64, i64* %ioaddr140, align 8, !tbaa !24
  %add141 = add i64 %37, 4
  %conv142 = trunc i64 %add141 to i32
  call void @outb(i8 zeroext %conv139, i32 %conv142)
  %and143 = and i32 %2, 2048
  %tobool144 = icmp ne i32 %and143, 0
  %port146 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %flags147 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port146, i32 0, i32 10
  %38 = load i64, i64* %flags147, align 8, !tbaa !49
  br i1 %tobool144, label %if.then145, label %if.else149

if.then145:                                       ; preds = %if.end137
  %and148 = and i64 %38, 4261412863
  store i64 %and148, i64* %flags147, align 8, !tbaa !49
  br label %if.end155

if.else149:                                       ; preds = %if.end137
  %or152 = or i64 %38, 33554432
  store i64 %or152, i64* %flags147, align 8, !tbaa !49
  %IER153 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %39 = load i32, i32* %IER153, align 4, !tbaa !68
  %or154 = or i32 %39, 8
  store i32 %or154, i32* %IER153, align 4, !tbaa !68
  br label %if.end155

if.end155:                                        ; preds = %if.else149, %if.then145
  %IER156 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %40 = load i32, i32* %IER156, align 4, !tbaa !68
  %conv157 = trunc i32 %40 to i8
  %ioaddr158 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %41 = load i64, i64* %ioaddr158, align 8, !tbaa !24
  %add159 = add i64 %41, 1
  %conv160 = trunc i64 %add159 to i32
  call void @outb(i8 zeroext %conv157, i32 %conv160)
  %read_status_mask = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 19
  store i32 35, i32* %read_status_mask, align 8, !tbaa !160
  %termios161 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_iflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios161, i32 0, i32 0
  %42 = load i32, i32* %c_iflag, align 8, !tbaa !90
  %and162 = and i32 %42, 16
  %tobool163 = icmp ne i32 %and162, 0
  br i1 %tobool163, label %if.then164, label %if.end167

if.then164:                                       ; preds = %if.end155
  %read_status_mask165 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 19
  %43 = load i32, i32* %read_status_mask165, align 8, !tbaa !160
  %or166 = or i32 %43, 12
  store i32 %or166, i32* %read_status_mask165, align 8, !tbaa !160
  br label %if.end167

if.end167:                                        ; preds = %if.then164, %if.end155
  %termios168 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_iflag169 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios168, i32 0, i32 0
  %44 = load i32, i32* %c_iflag169, align 8, !tbaa !90
  %and170 = and i32 %44, 2
  %tobool171 = icmp ne i32 %and170, 0
  br i1 %tobool171, label %if.then177, label %lor.lhs.false172

lor.lhs.false172:                                 ; preds = %if.end167
  %termios173 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_iflag174 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios173, i32 0, i32 0
  %45 = load i32, i32* %c_iflag174, align 8, !tbaa !90
  %and175 = and i32 %45, 8
  %tobool176 = icmp ne i32 %and175, 0
  br i1 %tobool176, label %if.then177, label %if.end180

if.then177:                                       ; preds = %lor.lhs.false172, %if.end167
  %read_status_mask178 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 19
  %46 = load i32, i32* %read_status_mask178, align 8, !tbaa !160
  %or179 = or i32 %46, 16
  store i32 %or179, i32* %read_status_mask178, align 8, !tbaa !160
  br label %if.end180

if.end180:                                        ; preds = %if.then177, %lor.lhs.false172
  %ignore_status_mask = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 20
  store i32 0, i32* %ignore_status_mask, align 4, !tbaa !161
  %termios181 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_iflag182 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios181, i32 0, i32 0
  %47 = load i32, i32* %c_iflag182, align 8, !tbaa !90
  %and183 = and i32 %47, 1
  %tobool184 = icmp ne i32 %and183, 0
  br i1 %tobool184, label %if.then185, label %if.end200

if.then185:                                       ; preds = %if.end180
  %ignore_status_mask186 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 20
  %48 = load i32, i32* %ignore_status_mask186, align 4, !tbaa !161
  %or187 = or i32 %48, 16
  store i32 %or187, i32* %ignore_status_mask186, align 4, !tbaa !161
  %read_status_mask188 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 19
  %49 = load i32, i32* %read_status_mask188, align 8, !tbaa !160
  %or189 = or i32 %49, 16
  store i32 %or189, i32* %read_status_mask188, align 8, !tbaa !160
  %termios190 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_iflag191 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios190, i32 0, i32 0
  %50 = load i32, i32* %c_iflag191, align 8, !tbaa !90
  %and192 = and i32 %50, 4
  %tobool193 = icmp ne i32 %and192, 0
  br i1 %tobool193, label %if.then194, label %if.end200

if.then194:                                       ; preds = %if.then185
  %ignore_status_mask195 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 20
  %51 = load i32, i32* %ignore_status_mask195, align 4, !tbaa !161
  %or196 = or i32 %51, 14
  store i32 %or196, i32* %ignore_status_mask195, align 4, !tbaa !161
  %read_status_mask197 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 19
  %52 = load i32, i32* %read_status_mask197, align 8, !tbaa !160
  %or198 = or i32 %52, 14
  store i32 %or198, i32* %read_status_mask197, align 8, !tbaa !160
  br label %if.end200

if.end200:                                        ; preds = %if.then194, %if.then185, %if.end180
  %board201 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %53 = load %struct.mxser_board*, %struct.mxser_board** %board201, align 8, !tbaa !46
  %chip_flag202 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %53, i32 0, i32 5
  %54 = load i32, i32* %chip_flag202, align 8, !tbaa !17
  %tobool203 = icmp ne i32 %54, 0
  br i1 %tobool203, label %if.then204, label %if.end230

if.then204:                                       ; preds = %if.end200
  %ioaddr205 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %55 = load i64, i64* %ioaddr205, align 8, !tbaa !24
  %termios206 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_cc = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios206, i32 0, i32 5
  %arrayidx207 = getelementptr inbounds [19 x i8], [19 x i8]* %c_cc, i64 0, i64 8
  %56 = load i8, i8* %arrayidx207, align 1, !tbaa !56
  call void @mxser_set_must_xon1_value(i64 %55, i8 zeroext %56)
  %ioaddr208 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %57 = load i64, i64* %ioaddr208, align 8, !tbaa !24
  %termios209 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_cc210 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios209, i32 0, i32 5
  %arrayidx211 = getelementptr inbounds [19 x i8], [19 x i8]* %c_cc210, i64 0, i64 9
  %58 = load i8, i8* %arrayidx211, align 1, !tbaa !56
  call void @mxser_set_must_xoff1_value(i64 %57, i8 zeroext %58)
  %termios212 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_iflag213 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios212, i32 0, i32 0
  %59 = load i32, i32* %c_iflag213, align 8, !tbaa !90
  %and214 = and i32 %59, 1024
  %tobool215 = icmp ne i32 %and214, 0
  %ioaddr217 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %60 = load i64, i64* %ioaddr217, align 8, !tbaa !24
  br i1 %tobool215, label %if.then216, label %if.else218

if.then216:                                       ; preds = %if.then204
  call void @mxser_enable_must_rx_software_flow_control(i64 %60)
  br label %if.end220

if.else218:                                       ; preds = %if.then204
  call void @mxser_disable_must_rx_software_flow_control(i64 %60)
  br label %if.end220

if.end220:                                        ; preds = %if.else218, %if.then216
  %termios221 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_iflag222 = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios221, i32 0, i32 0
  %61 = load i32, i32* %c_iflag222, align 8, !tbaa !90
  %and223 = and i32 %61, 4096
  %tobool224 = icmp ne i32 %and223, 0
  %ioaddr226 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %62 = load i64, i64* %ioaddr226, align 8, !tbaa !24
  br i1 %tobool224, label %if.then225, label %if.else227

if.then225:                                       ; preds = %if.end220
  call void @mxser_enable_must_tx_software_flow_control(i64 %62)
  br label %if.end230

if.else227:                                       ; preds = %if.end220
  call void @mxser_disable_must_tx_software_flow_control(i64 %62)
  br label %if.end230

if.end230:                                        ; preds = %if.else227, %if.then225, %if.end200
  %conv231 = trunc i32 %fcr.3 to i8
  %ioaddr232 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %63 = load i64, i64* %ioaddr232, align 8, !tbaa !24
  %add233 = add i64 %63, 2
  %conv234 = trunc i64 %add233 to i32
  call void @outb(i8 zeroext %conv231, i32 %conv234)
  %conv235 = trunc i32 %cval.4 to i8
  %ioaddr236 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %64 = load i64, i64* %ioaddr236, align 8, !tbaa !24
  %add237 = add i64 %64, 3
  %conv238 = trunc i64 %add237 to i32
  call void @outb(i8 zeroext %conv235, i32 %conv238)
  br label %cleanup

cleanup:                                          ; preds = %if.end230, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_activate(%struct.tty_port* %port, %struct.tty_struct* %tty) #4 {
entry:
  %0 = bitcast %struct.tty_port* %port to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.mxser_port*
  %call = call i64 @__get_free_pages(i32 208, i32 0)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %do.body1, label %cleanup

do.body1:                                         ; preds = %entry
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call3 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call4 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call3)
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %tobool7 = icmp ne i64 %2, 0
  br i1 %tobool7, label %lor.lhs.false, label %if.then9

lor.lhs.false:                                    ; preds = %do.body1
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 9
  %3 = load i32, i32* %type, align 4, !tbaa !50
  %tobool8 = icmp ne i32 %3, 0
  br i1 %tobool8, label %if.end12, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false, %do.body1
  %flags10 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags10, i32 1, i64* %flags10) #7, !srcloc !144
  call void @free_pages(i64 %call, i32 0)
  %slock11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock11, i64 %call4)
  br label %cleanup

if.end12:                                         ; preds = %lor.lhs.false
  %4 = inttoptr i64 %call to i8*
  %port13 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port13, i32 0, i32 15
  store i8* %4, i8** %xmit_buf, align 8, !tbaa !65
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %5 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %5, i32 0, i32 5
  %6 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool14 = icmp ne i32 %6, 0
  %ioaddr16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %7 = load i64, i64* %ioaddr16, align 8, !tbaa !24
  %add = add i64 %7, 2
  %conv17 = trunc i64 %add to i32
  br i1 %tobool14, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end12
  call void @outb(i8 zeroext 38, i32 %conv17)
  br label %if.end21

if.else:                                          ; preds = %if.end12
  call void @outb(i8 zeroext 6, i32 %conv17)
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then15
  %ioaddr22 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %8 = load i64, i64* %ioaddr22, align 8, !tbaa !24
  %add23 = add i64 %8, 5
  %conv24 = trunc i64 %add23 to i32
  %call25 = call zeroext i8 @inb(i32 %conv24)
  %conv26 = zext i8 %call25 to i32
  %cmp27 = icmp eq i32 %conv26, 255
  br i1 %cmp27, label %if.then29, label %if.end35

if.then29:                                        ; preds = %if.end21
  %slock30 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock30, i64 %call4)
  %call31 = call zeroext i1 @capable(i32 21)
  br i1 %call31, label %if.then32, label %cleanup

if.then32:                                        ; preds = %if.then29
  %flags33 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags33, i32 1, i64* %flags33) #7, !srcloc !144
  br label %cleanup

if.end35:                                         ; preds = %if.end21
  %ioaddr36 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr36, align 8, !tbaa !24
  %add37 = add i64 %9, 5
  %conv38 = trunc i64 %add37 to i32
  %call39 = call zeroext i8 @inb(i32 %conv38)
  %ioaddr40 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %10 = load i64, i64* %ioaddr40, align 8, !tbaa !24
  %add41 = add i64 %10, 0
  %conv42 = trunc i64 %add41 to i32
  %call43 = call zeroext i8 @inb(i32 %conv42)
  %ioaddr44 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %11 = load i64, i64* %ioaddr44, align 8, !tbaa !24
  %add45 = add i64 %11, 2
  %conv46 = trunc i64 %add45 to i32
  %call47 = call zeroext i8 @inb(i32 %conv46)
  %ioaddr48 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %12 = load i64, i64* %ioaddr48, align 8, !tbaa !24
  %add49 = add i64 %12, 6
  %conv50 = trunc i64 %add49 to i32
  %call51 = call zeroext i8 @inb(i32 %conv50)
  %ioaddr52 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %13 = load i64, i64* %ioaddr52, align 8, !tbaa !24
  %add53 = add i64 %13, 3
  %conv54 = trunc i64 %add53 to i32
  call void @outb(i8 zeroext 3, i32 %conv54)
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  store i32 3, i32* %MCR, align 8, !tbaa !92
  %MCR55 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %14 = load i32, i32* %MCR55, align 8, !tbaa !92
  %conv56 = trunc i32 %14 to i8
  %ioaddr57 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %15 = load i64, i64* %ioaddr57, align 8, !tbaa !24
  %add58 = add i64 %15, 4
  %conv59 = trunc i64 %add58 to i32
  call void @outb(i8 zeroext %conv56, i32 %conv59)
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  store i32 13, i32* %IER, align 4, !tbaa !68
  %board60 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %16 = load %struct.mxser_board*, %struct.mxser_board** %board60, align 8, !tbaa !46
  %chip_flag61 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %16, i32 0, i32 5
  %17 = load i32, i32* %chip_flag61, align 8, !tbaa !17
  %tobool62 = icmp ne i32 %17, 0
  br i1 %tobool62, label %if.then63, label %if.end65

if.then63:                                        ; preds = %if.end35
  %IER64 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %18 = load i32, i32* %IER64, align 4, !tbaa !68
  %or = or i32 %18, 16
  store i32 %or, i32* %IER64, align 4, !tbaa !68
  br label %if.end65

if.end65:                                         ; preds = %if.then63, %if.end35
  %IER66 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %19 = load i32, i32* %IER66, align 4, !tbaa !68
  %conv67 = trunc i32 %19 to i8
  %ioaddr68 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %20 = load i64, i64* %ioaddr68, align 8, !tbaa !24
  %add69 = add i64 %20, 1
  %conv70 = trunc i64 %add69 to i32
  call void @outb(i8 zeroext %conv67, i32 %conv70)
  %ioaddr71 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %21 = load i64, i64* %ioaddr71, align 8, !tbaa !24
  %add72 = add i64 %21, 5
  %conv73 = trunc i64 %add72 to i32
  %call74 = call zeroext i8 @inb(i32 %conv73)
  %ioaddr75 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %22 = load i64, i64* %ioaddr75, align 8, !tbaa !24
  %add76 = add i64 %22, 0
  %conv77 = trunc i64 %add76 to i32
  %call78 = call zeroext i8 @inb(i32 %conv77)
  %ioaddr79 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %23 = load i64, i64* %ioaddr79, align 8, !tbaa !24
  %add80 = add i64 %23, 2
  %conv81 = trunc i64 %add80 to i32
  %call82 = call zeroext i8 @inb(i32 %conv81)
  %ioaddr83 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %24 = load i64, i64* %ioaddr83, align 8, !tbaa !24
  %add84 = add i64 %24, 6
  %conv85 = trunc i64 %add84 to i32
  %call86 = call zeroext i8 @inb(i32 %conv85)
  %flags87 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 18
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %flags87, i32 1, i64* %flags87) #7, !srcloc !64
  %xmit_tail = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 23
  store i32 0, i32* %xmit_tail, align 8, !tbaa !93
  %xmit_head = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 22
  store i32 0, i32* %xmit_head, align 4, !tbaa !67
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 24
  store i32 0, i32* %xmit_cnt, align 4, !tbaa !66
  call void @mxser_change_speed(%struct.tty_struct* %tty)
  %slock89 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock89, i64 %call4)
  br label %cleanup

cleanup:                                          ; preds = %if.end65, %if.then32, %if.then29, %if.then9, %entry
  %retval.0 = phi i32 [ 0, %if.then32 ], [ 0, %if.end65 ], [ 0, %if.then9 ], [ -12, %entry ], [ -19, %if.then29 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #5

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #6

declare i64 @_copy_from_user(i8*, i8*, i32) #3

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_set_baud(%struct.tty_struct* %tty, i64 %newspd) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %max_baud = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 4
  %3 = load i32, i32* %max_baud, align 8, !tbaa !43
  %conv = sext i32 %3 to i64
  %cmp = icmp sgt i64 %newspd, %conv
  br i1 %cmp, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  switch i64 %newspd, label %if.then8 [
    i64 134, label %if.then6
    i64 0, label %if.end21
  ]

if.then6:                                         ; preds = %if.end3
  %baud_base = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %4 = load i32, i32* %baud_base, align 8, !tbaa !42
  %mul = mul nsw i32 2, %4
  %div = sdiv i32 %mul, 269
  call void @tty_encode_baud_rate(%struct.tty_struct* %tty, i32 134, i32 134)
  br label %if.end21

if.then8:                                         ; preds = %if.end3
  %baud_base9 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %5 = load i32, i32* %baud_base9, align 8, !tbaa !42
  %conv10 = sext i32 %5 to i64
  %div11 = sdiv i64 %conv10, %newspd
  %conv12 = trunc i64 %div11 to i32
  %cmp13 = icmp eq i32 %conv12, 0
  %.conv12 = select i1 %cmp13, i32 1, i32 %conv12
  %baud_base17 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %6 = load i32, i32* %baud_base17, align 8, !tbaa !42
  %div18 = sdiv i32 %6, %.conv12
  call void @tty_encode_baud_rate(%struct.tty_struct* %tty, i32 %div18, i32 %div18)
  br label %if.end21

if.end21:                                         ; preds = %if.then8, %if.then6, %if.end3
  %quot.2 = phi i32 [ %div, %if.then6 ], [ %.conv12, %if.then8 ], [ 0, %if.end3 ]
  %xmit_fifo_size = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 21
  %7 = load i32, i32* %xmit_fifo_size, align 8, !tbaa !94
  %mul22 = mul nsw i32 %7, 250
  %mul23 = mul nsw i32 %mul22, 10
  %mul24 = mul nsw i32 %mul23, %quot.2
  %baud_base25 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %8 = load i32, i32* %baud_base25, align 8, !tbaa !42
  %div26 = sdiv i32 %mul24, %8
  %timeout = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 18
  store i32 %div26, i32* %timeout, align 4, !tbaa !95
  %timeout27 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 18
  %9 = load i32, i32* %timeout27, align 4, !tbaa !95
  %add = add nsw i32 %9, 5
  store i32 %add, i32* %timeout27, align 4, !tbaa !95
  %tobool28 = icmp ne i32 %quot.2, 0
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %10 = load i32, i32* %MCR, align 8, !tbaa !92
  br i1 %tobool28, label %if.then29, label %if.else35

if.then29:                                        ; preds = %if.end21
  %or = or i32 %10, 1
  store i32 %or, i32* %MCR, align 8, !tbaa !92
  %MCR30 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %11 = load i32, i32* %MCR30, align 8, !tbaa !92
  %conv31 = trunc i32 %11 to i8
  %ioaddr32 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %12 = load i64, i64* %ioaddr32, align 8, !tbaa !24
  %add33 = add i64 %12, 4
  %conv34 = trunc i64 %add33 to i32
  call void @outb(i8 zeroext %conv31, i32 %conv34)
  %ioaddr43 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %13 = load i64, i64* %ioaddr43, align 8, !tbaa !24
  %add44 = add i64 %13, 3
  %conv45 = trunc i64 %add44 to i32
  %call = call zeroext i8 @inb(i32 %conv45)
  %conv46 = zext i8 %call to i32
  %or47 = or i32 %conv46, 128
  %conv48 = trunc i32 %or47 to i8
  %ioaddr49 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %14 = load i64, i64* %ioaddr49, align 8, !tbaa !24
  %add50 = add i64 %14, 3
  %conv51 = trunc i64 %add50 to i32
  call void @outb(i8 zeroext %conv48, i32 %conv51)
  %and52 = and i32 %quot.2, 255
  %conv53 = trunc i32 %and52 to i8
  %ioaddr54 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %15 = load i64, i64* %ioaddr54, align 8, !tbaa !24
  %add55 = add i64 %15, 0
  %conv56 = trunc i64 %add55 to i32
  call void @outb(i8 zeroext %conv53, i32 %conv56)
  %shr = ashr i32 %quot.2, 8
  %conv57 = trunc i32 %shr to i8
  %ioaddr58 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %16 = load i64, i64* %ioaddr58, align 8, !tbaa !24
  %add59 = add i64 %16, 1
  %conv60 = trunc i64 %add59 to i32
  call void @outb(i8 zeroext %conv57, i32 %conv60)
  %ioaddr61 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %17 = load i64, i64* %ioaddr61, align 8, !tbaa !24
  %add62 = add i64 %17, 3
  %conv63 = trunc i64 %add62 to i32
  call void @outb(i8 zeroext %call, i32 %conv63)
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 2
  %18 = load i32, i32* %c_cflag, align 8, !tbaa !63
  %and64 = and i32 %18, 4111
  %cmp65 = icmp eq i32 %and64, 4096
  br i1 %cmp65, label %if.then67, label %if.else88

if.else35:                                        ; preds = %if.end21
  %and = and i32 %10, -2
  store i32 %and, i32* %MCR, align 8, !tbaa !92
  %MCR37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %19 = load i32, i32* %MCR37, align 8, !tbaa !92
  %conv38 = trunc i32 %19 to i8
  %ioaddr39 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %20 = load i64, i64* %ioaddr39, align 8, !tbaa !24
  %add40 = add i64 %20, 4
  %conv41 = trunc i64 %add40 to i32
  call void @outb(i8 zeroext %conv38, i32 %conv41)
  br label %cleanup

if.then67:                                        ; preds = %if.then29
  %baud_base68 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 8
  %21 = load i32, i32* %baud_base68, align 8, !tbaa !42
  %conv69 = sext i32 %21 to i64
  %rem = srem i64 %conv69, %newspd
  %conv70 = trunc i64 %rem to i32
  %mul71 = mul nsw i32 %conv70, 8
  %conv72 = sext i32 %mul71 to i64
  %rem73 = srem i64 %conv72, %newspd
  %div74 = sdiv i64 %newspd, 2
  %cmp75 = icmp sgt i64 %rem73, %div74
  %conv78 = sext i32 %mul71 to i64
  %div79 = sdiv i64 %conv78, %newspd
  %conv80 = trunc i64 %div79 to i32
  %inc = add nsw i32 %conv80, 1
  %quot.3 = select i1 %cmp75, i32 %inc, i32 %conv80
  %ioaddr86 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %22 = load i64, i64* %ioaddr86, align 8, !tbaa !24
  %conv87 = trunc i32 %quot.3 to i8
  call void @mxser_set_must_enum_value(i64 %22, i8 zeroext %conv87)
  br label %cleanup

if.else88:                                        ; preds = %if.then29
  %ioaddr89 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %23 = load i64, i64* %ioaddr89, align 8, !tbaa !24
  call void @mxser_set_must_enum_value(i64 %23, i8 zeroext 0)
  br label %cleanup

cleanup:                                          ; preds = %if.else88, %if.then67, %if.else35, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_set_must_fifo_value(%struct.mxser_port* %info) #4 {
entry:
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %0 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %0, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %ioaddr1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %1 = load i64, i64* %ioaddr1, align 8, !tbaa !24
  %add2 = add i64 %1, 3
  %conv3 = trunc i64 %add2 to i32
  call void @outb(i8 zeroext -65, i32 %conv3)
  %ioaddr4 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %2 = load i64, i64* %ioaddr4, align 8, !tbaa !24
  %add5 = add i64 %2, 2
  %conv6 = trunc i64 %add5 to i32
  %call7 = call zeroext i8 @inb(i32 %conv6)
  %conv8 = zext i8 %call7 to i32
  %and = and i32 %conv8, -193
  %conv9 = trunc i32 %and to i8
  %conv10 = zext i8 %conv9 to i32
  %or = or i32 %conv10, 64
  %conv11 = trunc i32 %or to i8
  %ioaddr12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %3 = load i64, i64* %ioaddr12, align 8, !tbaa !24
  %add13 = add i64 %3, 2
  %conv14 = trunc i64 %add13 to i32
  call void @outb(i8 zeroext %conv11, i32 %conv14)
  %rx_high_water = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 5
  %4 = load i32, i32* %rx_high_water, align 4, !tbaa !152
  %conv15 = trunc i32 %4 to i8
  %ioaddr16 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %5 = load i64, i64* %ioaddr16, align 8, !tbaa !24
  %add17 = add i64 %5, 5
  %conv18 = trunc i64 %add17 to i32
  call void @outb(i8 zeroext %conv15, i32 %conv18)
  %rx_trigger = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 6
  %6 = load i32, i32* %rx_trigger, align 8, !tbaa !151
  %conv19 = trunc i32 %6 to i8
  %ioaddr20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %7 = load i64, i64* %ioaddr20, align 8, !tbaa !24
  %add21 = add i64 %7, 6
  %conv22 = trunc i64 %add21 to i32
  call void @outb(i8 zeroext %conv19, i32 %conv22)
  %rx_low_water = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 7
  %8 = load i32, i32* %rx_low_water, align 4, !tbaa !153
  %conv23 = trunc i32 %8 to i8
  %ioaddr24 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %9 = load i64, i64* %ioaddr24, align 8, !tbaa !24
  %add25 = add i64 %9, 4
  %conv26 = trunc i64 %add25 to i32
  call void @outb(i8 zeroext %conv23, i32 %conv26)
  %ioaddr27 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %info, i32 0, i32 2
  %10 = load i64, i64* %ioaddr27, align 8, !tbaa !24
  %add28 = add i64 %10, 3
  %conv29 = trunc i64 %add28 to i32
  call void @outb(i8 zeroext %call, i32 %conv29)
  ret void
}

declare void @tty_wakeup(%struct.tty_struct*) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_set_must_xon1_value(i64 %baseio, i8 zeroext %value) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -193
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %conv9 = trunc i32 %conv8 to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 4
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %value, i32 %conv13)
  %add14 = add i64 %baseio, 3
  %conv15 = trunc i64 %add14 to i32
  call void @outb(i8 zeroext %call, i32 %conv15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_set_must_xoff1_value(i64 %baseio, i8 zeroext %value) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -193
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %conv9 = trunc i32 %conv8 to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 6
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %value, i32 %conv13)
  %add14 = add i64 %baseio, 3
  %conv15 = trunc i64 %add14 to i32
  call void @outb(i8 zeroext %call, i32 %conv15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_enable_must_rx_software_flow_control(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -4
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %or = or i32 %conv8, 2
  %conv9 = trunc i32 %or to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 3
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %call, i32 %conv13)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_disable_must_rx_software_flow_control(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -4
  %conv7 = trunc i32 %and to i8
  %add8 = add i64 %baseio, 2
  %conv9 = trunc i64 %add8 to i32
  call void @outb(i8 zeroext %conv7, i32 %conv9)
  %add10 = add i64 %baseio, 3
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_enable_must_tx_software_flow_control(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -13
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %or = or i32 %conv8, 8
  %conv9 = trunc i32 %or to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 3
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %call, i32 %conv13)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_disable_must_tx_software_flow_control(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -13
  %conv7 = trunc i32 %and to i8
  %add8 = add i64 %baseio, 2
  %conv9 = trunc i64 %add8 to i32
  call void @outb(i8 zeroext %conv7, i32 %conv9)
  %add10 = add i64 %baseio, 3
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_set_must_enum_value(i64 %baseio, i8 zeroext %value) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -193
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %or = or i32 %conv8, 128
  %conv9 = trunc i32 %or to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 4
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %value, i32 %conv13)
  %add14 = add i64 %baseio, 3
  %conv15 = trunc i64 %add14 to i32
  call void @outb(i8 zeroext %call, i32 %conv15)
  ret void
}

declare i64 @__get_free_pages(i32, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #0 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !162
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #0 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @tty_port_cts_enabled(%struct.tty_port* %port) #0 {
entry:
  %flags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 10
  %0 = load i64, i64* %flags, align 8, !tbaa !141
  %and = and i64 %0, 67108864
  %tobool = icmp ne i64 %and, 0
  ret i1 %tobool
}

declare i64 @_copy_to_user(i8*, i8*, i32) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_stoprx(%struct.tty_struct* %tty) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 32
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !61
  %1 = bitcast i8* %0 to %struct.mxser_port*
  %ldisc_stop_rx = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 14
  store i8 1, i8* %ldisc_stop_rx, align 1, !tbaa !48
  %termios = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_iflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios, i32 0, i32 0
  %2 = load i32, i32* %c_iflag, align 8, !tbaa !90
  %and = and i32 %2, 4096
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end17

if.then:                                          ; preds = %entry
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 1
  %3 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %3, i32 0, i32 5
  %4 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool1 = icmp ne i32 %4, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %5 = load i32, i32* %IER, align 4, !tbaa !68
  %and3 = and i32 %5, -18
  store i32 %and3, i32* %IER, align 4, !tbaa !68
  %IER4 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %6 = load i32, i32* %IER4, align 4, !tbaa !68
  %conv = trunc i32 %6 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %7 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %7, 1
  %conv5 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv, i32 %conv5)
  br label %if.end17

if.else:                                          ; preds = %if.then
  %termios6 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_cc = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios6, i32 0, i32 5
  %arrayidx = getelementptr inbounds [19 x i8], [19 x i8]* %c_cc, i64 0, i64 9
  %8 = load i8, i8* %arrayidx, align 1, !tbaa !56
  %conv7 = zext i8 %8 to i32
  %x_char = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 10
  store i32 %conv7, i32* %x_char, align 8, !tbaa !91
  %ioaddr8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %9 = load i64, i64* %ioaddr8, align 8, !tbaa !24
  %add9 = add i64 %9, 1
  %conv10 = trunc i64 %add9 to i32
  call void @outb(i8 zeroext 0, i32 %conv10)
  %IER11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %10 = load i32, i32* %IER11, align 4, !tbaa !68
  %or = or i32 %10, 2
  store i32 %or, i32* %IER11, align 4, !tbaa !68
  %IER12 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 11
  %11 = load i32, i32* %IER12, align 4, !tbaa !68
  %conv13 = trunc i32 %11 to i8
  %ioaddr14 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %12 = load i64, i64* %ioaddr14, align 8, !tbaa !24
  %add15 = add i64 %12, 1
  %conv16 = trunc i64 %add15 to i32
  call void @outb(i8 zeroext %conv13, i32 %conv16)
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then2, %entry
  %termios18 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 12
  %c_cflag = getelementptr inbounds %struct.ktermios, %struct.ktermios* %termios18, i32 0, i32 2
  %13 = load i32, i32* %c_cflag, align 8, !tbaa !63
  %and19 = and i32 %13, -2147483648
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end28

if.then21:                                        ; preds = %if.end17
  %MCR = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %14 = load i32, i32* %MCR, align 8, !tbaa !92
  %and22 = and i32 %14, -3
  store i32 %and22, i32* %MCR, align 8, !tbaa !92
  %MCR23 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 12
  %15 = load i32, i32* %MCR23, align 8, !tbaa !92
  %conv24 = trunc i32 %15 to i8
  %ioaddr25 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %16 = load i64, i64* %ioaddr25, align 8, !tbaa !24
  %add26 = add i64 %16, 4
  %conv27 = trunc i64 %add26 to i32
  call void @outb(i8 zeroext %conv24, i32 %conv27)
  br label %if.end28

if.end28:                                         ; preds = %if.then21, %if.end17
  ret void
}

declare void @tty_port_hangup(%struct.tty_port*) #3

; Function Attrs: nounwind uwtable
define internal i32 @mxser_read_register(i32 %port, i16* %regs) #1 section ".init.text" {
entry:
  %call = call i32 @mxser_program_mode(i32 %port)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.end20, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc23, %for.end20 ]
  %cmp1 = icmp slt i32 %i.0, 14
  br i1 %cmp1, label %for.body, label %for.end24

for.body:                                         ; preds = %for.cond
  %and = and i32 %i.0, 63
  %or = or i32 %and, 384
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %j.0 = phi i32 [ 256, %for.body ], [ %shr, %for.inc ]
  %cmp3 = icmp ugt i32 %j.0, 0
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond2
  call void @outb(i8 zeroext 4, i32 %port)
  %and5 = and i32 %or, %j.0
  %tobool = icmp ne i32 %and5, 0
  br i1 %tobool, label %if.then6, label %if.else

if.then6:                                         ; preds = %for.body4
  call void @outb(i8 zeroext 6, i32 %port)
  call void @outb(i8 zeroext 7, i32 %port)
  br label %for.inc

if.else:                                          ; preds = %for.body4
  call void @outb(i8 zeroext 4, i32 %port)
  call void @outb(i8 zeroext 5, i32 %port)
  br label %for.inc

for.inc:                                          ; preds = %if.else, %if.then6
  %shr = lshr i32 %j.0, 1
  br label %for.cond2

for.end:                                          ; preds = %for.cond2
  %call8 = call zeroext i8 @inb(i32 %port)
  br label %for.cond9

for.cond9:                                        ; preds = %for.body11, %for.end
  %value.0 = phi i32 [ 0, %for.end ], [ %or16.value.0, %for.body11 ]
  %k.0 = phi i32 [ 0, %for.end ], [ %inc, %for.body11 ]
  %j.1 = phi i32 [ 32768, %for.end ], [ %shr19, %for.body11 ]
  %cmp10 = icmp slt i32 %k.0, 16
  br i1 %cmp10, label %for.body11, label %for.end20

for.body11:                                       ; preds = %for.cond9
  call void @outb(i8 zeroext 4, i32 %port)
  call void @outb(i8 zeroext 5, i32 %port)
  %call12 = call zeroext i8 @inb(i32 %port)
  %conv = zext i8 %call12 to i32
  %and13 = and i32 %conv, 8
  %tobool14 = icmp ne i32 %and13, 0
  %or16 = or i32 %value.0, %j.1
  %or16.value.0 = select i1 %tobool14, i32 %or16, i32 %value.0
  %inc = add nsw i32 %k.0, 1
  %shr19 = lshr i32 %j.1, 1
  br label %for.cond9

for.end20:                                        ; preds = %for.cond9
  %conv21 = trunc i32 %value.0 to i16
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i16, i16* %regs, i64 %idxprom
  store i16 %conv21, i16* %arrayidx, align 2, !tbaa !21
  call void @outb(i8 zeroext 0, i32 %port)
  %inc23 = add nsw i32 %i.0, 1
  br label %for.cond

for.end24:                                        ; preds = %for.cond
  call void @mxser_normal_mode(i32 %port)
  br label %cleanup

cleanup:                                          ; preds = %for.end24, %entry
  ret i32 %call
}

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #3

; Function Attrs: nounwind uwtable
define internal i32 @mxser_request_vector(%struct.mxser_board* %brd) #4 {
entry:
  %call = call zeroext i1 @mxser_overlapping_vector(%struct.mxser_board* %brd)
  br i1 %call, label %return, label %if.end

if.end:                                           ; preds = %entry
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 3
  %0 = load i64, i64* %vector, align 8, !tbaa !40
  %call1 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 %0, i64 1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.50, i32 0, i32 0), i32 0)
  %tobool = icmp ne %struct.resource* %call1, null
  %cond = select i1 %tobool, i32 0, i32 -5
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %cond, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

declare void @__release_region(%struct.resource*, i64, i64) #3

; Function Attrs: nounwind uwtable
define internal i32 @mxser_program_mode(i32 %port) #1 section ".init.text" {
entry:
  call void @outb(i8 zeroext 0, i32 %port)
  call void @outb(i8 zeroext 0, i32 %port)
  call void @outb(i8 zeroext 0, i32 %port)
  %call = call zeroext i8 @inb(i32 %port)
  %call1 = call zeroext i8 @inb(i32 %port)
  call void @outb(i8 zeroext 0, i32 %port)
  %call2 = call zeroext i8 @inb(i32 %port)
  %add = add nsw i32 %port, 1
  %call3 = call zeroext i8 @inb(i32 %add)
  %conv = zext i8 %call3 to i32
  %and = and i32 %conv, 31
  switch i32 %and, label %cleanup [
    i32 1, label %if.end
    i32 2, label %if.end
    i32 11, label %if.end
    i32 4, label %if.end
    i32 3, label %if.end
    i32 5, label %if.end
  ]

if.end:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %j.0 = phi i32 [ 0, %if.end ], [ %j.1, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp19 = icmp slt i32 %i.0, 4
  br i1 %cmp19, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add21 = add nsw i32 %port, 2
  %call22 = call zeroext i8 @inb(i32 %add21)
  %conv23 = zext i8 %call22 to i32
  %cmp24 = icmp eq i32 %conv23, 77
  br i1 %cmp24, label %for.inc, label %if.else

if.else:                                          ; preds = %for.body
  %cmp27 = icmp eq i32 %j.0, 1
  %cmp30 = icmp eq i32 %conv23, 1
  %or.cond = and i1 %cmp27, %cmp30
  br i1 %or.cond, label %for.end, label %for.inc

for.inc:                                          ; preds = %if.else, %for.body
  %j.1 = phi i32 [ 1, %for.body ], [ 0, %if.else ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.else, %for.cond
  %j.2 = phi i32 [ 2, %if.else ], [ %j.0, %for.cond ]
  %cmp36 = icmp ne i32 %j.2, 2
  %.and = select i1 %cmp36, i32 -2, i32 %and
  br label %cleanup

cleanup:                                          ; preds = %for.end, %entry
  %retval.0 = phi i32 [ %.and, %for.end ], [ -1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @mxser_normal_mode(i32 %port) #1 section ".init.text" {
entry:
  %add = add nsw i32 %port, 1
  call void @outb(i8 zeroext -91, i32 %add)
  %add1 = add nsw i32 %port, 3
  call void @outb(i8 zeroext -128, i32 %add1)
  %add2 = add nsw i32 %port, 0
  call void @outb(i8 zeroext 12, i32 %add2)
  %add3 = add nsw i32 %port, 1
  call void @outb(i8 zeroext 0, i32 %add3)
  %add4 = add nsw i32 %port, 3
  call void @outb(i8 zeroext 3, i32 %add4)
  %add5 = add nsw i32 %port, 4
  call void @outb(i8 zeroext 19, i32 %add5)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add6 = add nsw i32 %port, 5
  %call = call zeroext i8 @inb(i32 %add6)
  %conv = zext i8 %call to i32
  %and = and i32 %conv, 97
  %cmp7 = icmp eq i32 %and, 96
  br i1 %cmp7, label %for.end, label %if.end

if.end:                                           ; preds = %for.body
  %and9 = and i32 %conv, 1
  %cmp10 = icmp eq i32 %and9, 1
  br i1 %cmp10, label %if.then12, label %for.inc

if.then12:                                        ; preds = %if.end
  %call13 = call zeroext i8 @inb(i32 %port)
  br label %for.inc

for.inc:                                          ; preds = %if.then12, %if.end
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %add15 = add nsw i32 %port, 4
  call void @outb(i8 zeroext 0, i32 %add15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @mxser_overlapping_vector(%struct.mxser_board* %brd) #4 {
entry:
  %0 = load i8, i8* @allow_overlapping_vector, align 1, !tbaa !193, !range !195
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 3
  %1 = load i64, i64* %vector, align 8, !tbaa !40
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %arrayidx = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 0
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %cmp = icmp uge i64 %1, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %vector1 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 3
  %3 = load i64, i64* %vector1, align 8, !tbaa !40
  %ports2 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %arrayidx3 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports2, i64 0, i64 0
  %ioaddr4 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx3, i32 0, i32 2
  %4 = load i64, i64* %ioaddr4, align 8, !tbaa !24
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %5 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !12
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %5, i32 0, i32 1
  %6 = load i32, i32* %nports, align 8, !tbaa !18
  %mul = mul i32 8, %6
  %conv = zext i32 %mul to i64
  %add = add i64 %4, %conv
  %cmp5 = icmp ult i64 %3, %add
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %7 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp5, %land.rhs ]
  ret i1 %7
}

declare void @tty_port_init(%struct.tty_port*) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_enable_must_enchance_mode(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %or = or i32 %conv6, 16
  %conv7 = trunc i32 %or to i8
  %add8 = add i64 %baseio, 2
  %conv9 = trunc i64 %add8 to i32
  call void @outb(i8 zeroext %conv7, i32 %conv9)
  %add10 = add i64 %baseio, 3
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  ret void
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #0 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_interrupt(i32 %irq, i8* %dev_id) #4 {
entry:
  %status = alloca i32, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom
  %0 = bitcast %struct.mxser_board* %arrayidx to i8*
  %cmp1 = icmp eq i8* %dev_id, %0
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %1 = bitcast i8* %dev_id to %struct.mxser_board*
  br label %for.end

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %brd.0 = phi %struct.mxser_board* [ %1, %if.then ], [ null, %for.cond ]
  %cmp2 = icmp eq i32 %i.0, 4
  %cmp5 = icmp eq %struct.mxser_board* %brd.0, null
  %or.cond = or i1 %cmp2, %cmp5
  br i1 %or.cond, label %irq_stop, label %if.end7

if.end7:                                          ; preds = %for.end
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 2
  %2 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !12
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %2, i32 0, i32 1
  %3 = load i32, i32* %nports, align 8, !tbaa !18
  br label %while.cond

while.cond:                                       ; preds = %for.end154, %if.end7
  %pass_counter.0 = phi i32 [ 0, %if.end7 ], [ %inc8, %for.end154 ]
  %handled.0 = phi i32 [ 0, %if.end7 ], [ 1, %for.end154 ]
  %inc8 = add i32 %pass_counter.0, 1
  %cmp9 = icmp ult i32 %pass_counter.0, 100
  br i1 %cmp9, label %while.body, label %irq_stop

while.body:                                       ; preds = %while.cond
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 3
  %4 = load i64, i64* %vector, align 8, !tbaa !40
  %conv = trunc i64 %4 to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %conv10 = zext i8 %call to i64
  %vector_mask = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 4
  %5 = load i64, i64* %vector_mask, align 8, !tbaa !41
  %and = and i64 %conv10, %5
  %conv11 = trunc i64 %and to i32
  %conv12 = sext i32 %conv11 to i64
  %vector_mask13 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 4
  %6 = load i64, i64* %vector_mask13, align 8, !tbaa !41
  %cmp14 = icmp eq i64 %conv12, %6
  br i1 %cmp14, label %irq_stop, label %if.end17

if.end17:                                         ; preds = %while.body
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc151, %if.end17
  %irqbits.0 = phi i32 [ %conv11, %if.end17 ], [ %or153, %for.inc151 ]
  %bits.0 = phi i32 [ 1, %if.end17 ], [ %shl, %for.inc151 ]
  %i.1 = phi i32 [ 0, %if.end17 ], [ %inc152, %for.inc151 ]
  %cmp19 = icmp slt i32 %i.1, %3
  br i1 %cmp19, label %for.body21, label %for.end154

for.body21:                                       ; preds = %for.cond18
  %conv22 = sext i32 %irqbits.0 to i64
  %vector_mask23 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 4
  %7 = load i64, i64* %vector_mask23, align 8, !tbaa !41
  %cmp24 = icmp eq i64 %conv22, %7
  br i1 %cmp24, label %for.end154, label %if.end27

if.end27:                                         ; preds = %for.body21
  %and28 = and i32 %bits.0, %irqbits.0
  %tobool = icmp ne i32 %and28, 0
  br i1 %tobool, label %for.inc151, label %if.end30

if.end30:                                         ; preds = %if.end27
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd.0, i32 0, i32 7
  %idxprom31 = sext i32 %i.1 to i64
  %arrayidx32 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom31
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 27
  call void @spin_lock(%struct.spinlock* %slock)
  br label %do.body

do.body:                                          ; preds = %if.end146, %if.end30
  %int_cnt.0 = phi i32 [ 0, %if.end30 ], [ %inc147, %if.end146 ]
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %8 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %8, 2
  %conv33 = trunc i64 %add to i32
  %call34 = call zeroext i8 @inb(i32 %conv33)
  %conv35 = zext i8 %call34 to i32
  %and36 = and i32 %conv35, 1
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %do.end, label %if.end39

if.end39:                                         ; preds = %do.body
  %and40 = and i32 %conv35, 62
  %port41 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 0
  %call42 = call %struct.tty_struct* @tty_port_tty_get(%struct.tty_port* %port41)
  %tobool43 = icmp ne %struct.tty_struct* %call42, null
  br i1 %tobool43, label %lor.lhs.false, label %if.then52

lor.lhs.false:                                    ; preds = %if.end39
  %port44 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 0
  %flags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port44, i32 0, i32 10
  %9 = load i64, i64* %flags, align 8, !tbaa !49
  %and45 = and i64 %9, 134217728
  %tobool46 = icmp ne i64 %and45, 0
  br i1 %tobool46, label %if.then52, label %lor.lhs.false47

lor.lhs.false47:                                  ; preds = %lor.lhs.false
  %port48 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 0
  %flags49 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port48, i32 0, i32 10
  %10 = load i64, i64* %flags49, align 8, !tbaa !49
  %and50 = and i64 %10, 2147483648
  %tobool51 = icmp ne i64 %and50, 0
  br i1 %tobool51, label %if.end65, label %if.then52

if.then52:                                        ; preds = %lor.lhs.false47, %lor.lhs.false, %if.end39
  %ioaddr53 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %11 = load i64, i64* %ioaddr53, align 8, !tbaa !24
  %add54 = add i64 %11, 5
  %conv55 = trunc i64 %add54 to i32
  %call56 = call zeroext i8 @inb(i32 %conv55)
  %conv57 = zext i8 %call56 to i32
  store i32 %conv57, i32* %status, align 4, !tbaa !55
  %ioaddr58 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %12 = load i64, i64* %ioaddr58, align 8, !tbaa !24
  %add59 = add i64 %12, 2
  %conv60 = trunc i64 %add59 to i32
  call void @outb(i8 zeroext 39, i32 %conv60)
  %ioaddr61 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %13 = load i64, i64* %ioaddr61, align 8, !tbaa !24
  %add62 = add i64 %13, 6
  %conv63 = trunc i64 %add62 to i32
  %call64 = call zeroext i8 @inb(i32 %conv63)
  call void @tty_kref_put(%struct.tty_struct* %call42)
  br label %do.end

if.end65:                                         ; preds = %lor.lhs.false47
  %ioaddr66 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %14 = load i64, i64* %ioaddr66, align 8, !tbaa !24
  %add67 = add i64 %14, 5
  %conv68 = trunc i64 %add67 to i32
  %call69 = call zeroext i8 @inb(i32 %conv68)
  %conv70 = zext i8 %call69 to i32
  store i32 %conv70, i32* %status, align 4, !tbaa !55
  %15 = load i32, i32* %status, align 4, !tbaa !55
  %and71 = and i32 %15, 4
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %if.then73, label %if.end76

if.then73:                                        ; preds = %if.end65
  %err_shadow = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 16
  %16 = load i8, i8* %err_shadow, align 4, !tbaa !57
  %conv74 = zext i8 %16 to i32
  %or = or i32 %conv74, 1
  %conv75 = trunc i32 %or to i8
  store i8 %conv75, i8* %err_shadow, align 4, !tbaa !57
  br label %if.end76

if.end76:                                         ; preds = %if.then73, %if.end65
  %17 = load i32, i32* %status, align 4, !tbaa !55
  %and77 = and i32 %17, 8
  %tobool78 = icmp ne i32 %and77, 0
  br i1 %tobool78, label %if.then79, label %if.end84

if.then79:                                        ; preds = %if.end76
  %err_shadow80 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 16
  %18 = load i8, i8* %err_shadow80, align 4, !tbaa !57
  %conv81 = zext i8 %18 to i32
  %or82 = or i32 %conv81, 2
  %conv83 = trunc i32 %or82 to i8
  store i8 %conv83, i8* %err_shadow80, align 4, !tbaa !57
  br label %if.end84

if.end84:                                         ; preds = %if.then79, %if.end76
  %19 = load i32, i32* %status, align 4, !tbaa !55
  %and85 = and i32 %19, 2
  %tobool86 = icmp ne i32 %and85, 0
  br i1 %tobool86, label %if.then87, label %if.end92

if.then87:                                        ; preds = %if.end84
  %err_shadow88 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 16
  %20 = load i8, i8* %err_shadow88, align 4, !tbaa !57
  %conv89 = zext i8 %20 to i32
  %or90 = or i32 %conv89, 4
  %conv91 = trunc i32 %or90 to i8
  store i8 %conv91, i8* %err_shadow88, align 4, !tbaa !57
  br label %if.end92

if.end92:                                         ; preds = %if.then87, %if.end84
  %21 = load i32, i32* %status, align 4, !tbaa !55
  %and93 = and i32 %21, 16
  %tobool94 = icmp ne i32 %and93, 0
  br i1 %tobool94, label %if.then95, label %if.end100

if.then95:                                        ; preds = %if.end92
  %err_shadow96 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 16
  %22 = load i8, i8* %err_shadow96, align 4, !tbaa !57
  %conv97 = zext i8 %22 to i32
  %or98 = or i32 %conv97, 16
  %conv99 = trunc i32 %or98 to i8
  store i8 %conv99, i8* %err_shadow96, align 4, !tbaa !57
  br label %if.end100

if.end100:                                        ; preds = %if.then95, %if.end92
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 1
  %23 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %23, i32 0, i32 5
  %24 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool101 = icmp ne i32 %24, 0
  br i1 %tobool101, label %if.then102, label %if.else

if.then102:                                       ; preds = %if.end100
  switch i32 %and40, label %if.end121 [
    i32 28, label %if.then114
    i32 4, label %if.then114
    i32 12, label %if.then114
    i32 6, label %if.then114
  ]

if.then114:                                       ; preds = %if.then102, %if.then102, %if.then102, %if.then102
  call void @mxser_receive_chars(%struct.tty_struct* %call42, %struct.mxser_port* %arrayidx32, i32* %status)
  br label %if.end121

if.else:                                          ; preds = %if.end100
  %read_status_mask = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 19
  %25 = load i32, i32* %read_status_mask, align 8, !tbaa !160
  %26 = load i32, i32* %status, align 4, !tbaa !55
  %and116 = and i32 %26, %25
  store i32 %and116, i32* %status, align 4, !tbaa !55
  %27 = load i32, i32* %status, align 4, !tbaa !55
  %and117 = and i32 %27, 1
  %tobool118 = icmp ne i32 %and117, 0
  br i1 %tobool118, label %if.then119, label %if.end121

if.then119:                                       ; preds = %if.else
  call void @mxser_receive_chars(%struct.tty_struct* %call42, %struct.mxser_port* %arrayidx32, i32* %status)
  br label %if.end121

if.end121:                                        ; preds = %if.then119, %if.else, %if.then114, %if.then102
  %ioaddr122 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  %28 = load i64, i64* %ioaddr122, align 8, !tbaa !24
  %add123 = add i64 %28, 6
  %conv124 = trunc i64 %add123 to i32
  %call125 = call zeroext i8 @inb(i32 %conv124)
  %conv126 = zext i8 %call125 to i32
  %and127 = and i32 %conv126, 15
  %tobool128 = icmp ne i32 %and127, 0
  br i1 %tobool128, label %if.then129, label %if.end130

if.then129:                                       ; preds = %if.end121
  call void @mxser_check_modem_status(%struct.tty_struct* %call42, %struct.mxser_port* %arrayidx32, i32 %conv126)
  br label %if.end130

if.end130:                                        ; preds = %if.then129, %if.end121
  %board131 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 1
  %29 = load %struct.mxser_board*, %struct.mxser_board** %board131, align 8, !tbaa !46
  %chip_flag132 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %29, i32 0, i32 5
  %30 = load i32, i32* %chip_flag132, align 8, !tbaa !17
  %tobool133 = icmp ne i32 %30, 0
  br i1 %tobool133, label %if.then134, label %if.else141

if.then134:                                       ; preds = %if.end130
  %cmp135 = icmp eq i32 %and40, 2
  br i1 %cmp135, label %land.lhs.true, label %if.end146

land.lhs.true:                                    ; preds = %if.then134
  %31 = load i32, i32* %status, align 4, !tbaa !55
  %and137 = and i32 %31, 32
  %tobool138 = icmp ne i32 %and137, 0
  br i1 %tobool138, label %if.then139, label %if.end146

if.then139:                                       ; preds = %land.lhs.true
  call void @mxser_transmit_chars(%struct.tty_struct* %call42, %struct.mxser_port* %arrayidx32)
  br label %if.end146

if.else141:                                       ; preds = %if.end130
  %32 = load i32, i32* %status, align 4, !tbaa !55
  %and142 = and i32 %32, 32
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %if.then144, label %if.end146

if.then144:                                       ; preds = %if.else141
  call void @mxser_transmit_chars(%struct.tty_struct* %call42, %struct.mxser_port* %arrayidx32)
  br label %if.end146

if.end146:                                        ; preds = %if.then144, %if.else141, %if.then139, %land.lhs.true, %if.then134
  call void @tty_kref_put(%struct.tty_struct* %call42)
  %inc147 = add i32 %int_cnt.0, 1
  %cmp148 = icmp ult i32 %int_cnt.0, 100
  br i1 %cmp148, label %do.body, label %do.end

do.end:                                           ; preds = %if.end146, %if.then52, %do.body
  %slock150 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 27
  call void @spin_unlock(%struct.spinlock* %slock150)
  br label %for.inc151

for.inc151:                                       ; preds = %do.end, %if.end27
  %inc152 = add nsw i32 %i.1, 1
  %or153 = or i32 %irqbits.0, %bits.0
  %shl = shl i32 %bits.0, 1
  br label %for.cond18

for.end154:                                       ; preds = %for.body21, %for.cond18
  br label %while.cond

irq_stop:                                         ; preds = %while.body, %while.cond, %for.end
  %handled.1 = phi i32 [ 0, %for.end ], [ %handled.0, %while.cond ], [ %handled.0, %while.body ]
  ret i32 %handled.1
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_carrier_raised(%struct.tty_port* %port) #4 {
entry:
  %0 = bitcast %struct.tty_port* %port to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.mxser_port*
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %2, 6
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %conv1 = zext i8 %call to i32
  %and = and i32 %conv1, 128
  %tobool = icmp ne i32 %and, 0
  %cond = select i1 %tobool, i32 1, i32 0
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal void @mxser_dtr_rts(%struct.tty_port* %port, i32 %on) #4 {
entry:
  %0 = bitcast %struct.tty_port* %port to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.mxser_port*
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %slock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %tobool = icmp ne i32 %on, 0
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %2, 4
  %conv6 = trunc i64 %add to i32
  %call7 = call zeroext i8 @inb(i32 %conv6)
  %conv8 = zext i8 %call7 to i32
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %or = or i32 %conv8, 1
  %or9 = or i32 %or, 2
  %conv10 = trunc i32 %or9 to i8
  %ioaddr11 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %3 = load i64, i64* %ioaddr11, align 8, !tbaa !24
  %add12 = add i64 %3, 4
  %conv13 = trunc i64 %add12 to i32
  call void @outb(i8 zeroext %conv10, i32 %conv13)
  br label %if.end

if.else:                                          ; preds = %entry
  %and = and i32 %conv8, -4
  %conv19 = trunc i32 %and to i8
  %ioaddr20 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 2
  %4 = load i64, i64* %ioaddr20, align 8, !tbaa !24
  %add21 = add i64 %4, 4
  %conv22 = trunc i64 %add21 to i32
  call void @outb(i8 zeroext %conv19, i32 %conv22)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %slock23 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %1, i32 0, i32 27
  call void @spin_unlock_irqrestore(%struct.spinlock* %slock23, i64 %call3)
  ret void
}

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_receive_chars(%struct.tty_struct* %tty, %struct.mxser_port* %port, i32* %status) #4 {
entry:
  %receive_room = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 23
  %0 = load i32, i32* %receive_room, align 8, !tbaa !196
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %ldisc_stop_rx = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 14
  %1 = load i8, i8* %ldisc_stop_rx, align 1, !tbaa !48
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  call void @mxser_stoprx(%struct.tty_struct* %tty)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %2 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %2, i32 0, i32 5
  %3 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %cmp1 = icmp ne i32 %3, 0
  br i1 %cmp1, label %if.then2, label %intr_old

if.then2:                                         ; preds = %if.end
  %4 = load i32, i32* %status, align 4, !tbaa !55
  %and = and i32 %4, 30
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %intr_old, label %if.end5

if.end5:                                          ; preds = %if.then2
  %board6 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %5 = load %struct.mxser_board*, %struct.mxser_board** %board6, align 8, !tbaa !46
  %chip_flag7 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %5, i32 0, i32 5
  %6 = load i32, i32* %chip_flag7, align 8, !tbaa !17
  %cmp8 = icmp eq i32 %6, 2
  br i1 %cmp8, label %land.lhs.true9, label %if.end13

land.lhs.true9:                                   ; preds = %if.end5
  %7 = load i32, i32* %status, align 4, !tbaa !55
  %and10 = and i32 %7, 128
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %intr_old, label %if.end13

if.end13:                                         ; preds = %land.lhs.true9, %if.end5
  %8 = load i32, i32* %status, align 4, !tbaa !55
  %and14 = and i32 %8, 128
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %intr_old, label %if.end17

if.end17:                                         ; preds = %if.end13
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %9 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %9, 7
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %board18 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %10 = load %struct.mxser_board*, %struct.mxser_board** %board18, align 8, !tbaa !46
  %chip_flag19 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %10, i32 0, i32 5
  %11 = load i32, i32* %chip_flag19, align 8, !tbaa !17
  %cmp20 = icmp eq i32 %11, 1
  %conv23 = zext i8 %call to i32
  %and24 = and i32 %conv23, 127
  %conv25 = trunc i32 %and24 to i8
  %gdl.0 = select i1 %cmp20, i8 %conv25, i8 %call
  %conv27 = zext i8 %gdl.0 to i32
  %cmp28 = icmp sge i32 %conv27, %0
  br i1 %cmp28, label %if.then30, label %if.end35

if.then30:                                        ; preds = %if.end17
  %ldisc_stop_rx31 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 14
  %12 = load i8, i8* %ldisc_stop_rx31, align 1, !tbaa !48
  %tobool32 = icmp ne i8 %12, 0
  br i1 %tobool32, label %if.end35, label %if.then33

if.then33:                                        ; preds = %if.then30
  call void @mxser_stoprx(%struct.tty_struct* %tty)
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.then30, %if.end17
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end35
  %cnt.0 = phi i32 [ 0, %if.end35 ], [ %inc, %while.body ]
  %gdl.1 = phi i8 [ %gdl.0, %if.end35 ], [ %dec, %while.body ]
  %dec = add i8 %gdl.1, -1
  %tobool36 = icmp ne i8 %gdl.1, 0
  br i1 %tobool36, label %while.body, label %end_intr

while.body:                                       ; preds = %while.cond
  %ioaddr37 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %13 = load i64, i64* %ioaddr37, align 8, !tbaa !24
  %add38 = add i64 %13, 0
  %conv39 = trunc i64 %add38 to i32
  %call40 = call zeroext i8 @inb(i32 %conv39)
  %port41 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  call void @tty_insert_flip_char(%struct.tty_port* %port41, i8 zeroext %call40, i8 signext 0)
  %inc = add nsw i32 %cnt.0, 1
  br label %while.cond

intr_old:                                         ; preds = %if.end13, %land.lhs.true9, %if.then2, %if.end
  br label %do.body

do.body:                                          ; preds = %if.end125, %intr_old
  %cnt.1 = phi i32 [ 0, %intr_old ], [ %cnt.2, %if.end125 ]
  %ignored.0 = phi i32 [ 0, %intr_old ], [ %ignored.1, %if.end125 ]
  %max.0 = phi i32 [ 256, %intr_old ], [ %dec44, %if.end125 ]
  %dec44 = add nsw i32 %max.0, -1
  %cmp45 = icmp slt i32 %max.0, 0
  br i1 %cmp45, label %end_intr, label %if.end48

if.end48:                                         ; preds = %do.body
  %ioaddr49 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %14 = load i64, i64* %ioaddr49, align 8, !tbaa !24
  %add50 = add i64 %14, 0
  %conv51 = trunc i64 %add50 to i32
  %call52 = call zeroext i8 @inb(i32 %conv51)
  %board53 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %15 = load %struct.mxser_board*, %struct.mxser_board** %board53, align 8, !tbaa !46
  %chip_flag54 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %15, i32 0, i32 5
  %16 = load i32, i32* %chip_flag54, align 8, !tbaa !17
  %tobool55 = icmp ne i32 %16, 0
  br i1 %tobool55, label %land.lhs.true56, label %if.end63

land.lhs.true56:                                  ; preds = %if.end48
  %17 = load i32, i32* %status, align 4, !tbaa !55
  %and57 = and i32 %17, 2
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.then59, label %if.end63

if.then59:                                        ; preds = %land.lhs.true56
  %ioaddr60 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %18 = load i64, i64* %ioaddr60, align 8, !tbaa !24
  %add61 = add i64 %18, 2
  %conv62 = trunc i64 %add61 to i32
  call void @outb(i8 zeroext 35, i32 %conv62)
  br label %if.end63

if.end63:                                         ; preds = %if.then59, %land.lhs.true56, %if.end48
  %read_status_mask = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 19
  %19 = load i32, i32* %read_status_mask, align 8, !tbaa !160
  %20 = load i32, i32* %status, align 4, !tbaa !55
  %and64 = and i32 %20, %19
  store i32 %and64, i32* %status, align 4, !tbaa !55
  %21 = load i32, i32* %status, align 4, !tbaa !55
  %ignore_status_mask = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 20
  %22 = load i32, i32* %ignore_status_mask, align 4, !tbaa !161
  %and65 = and i32 %21, %22
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %if.then67, label %if.else

if.then67:                                        ; preds = %if.end63
  %inc68 = add nsw i32 %ignored.0, 1
  %cmp69 = icmp sgt i32 %inc68, 100
  br i1 %cmp69, label %end_intr, label %if.end120

if.else:                                          ; preds = %if.end63
  %23 = load i32, i32* %status, align 4, !tbaa !55
  %and73 = and i32 %23, 30
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %if.then75, label %if.end108

if.then75:                                        ; preds = %if.else
  %24 = load i32, i32* %status, align 4, !tbaa !55
  %and76 = and i32 %24, 16
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %if.then78, label %if.else85

if.then78:                                        ; preds = %if.then75
  %icount = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %brk = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount, i32 0, i32 9
  %25 = load i32, i32* %brk, align 4, !tbaa !197
  %inc79 = add i32 %25, 1
  store i32 %inc79, i32* %brk, align 4, !tbaa !197
  %port80 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %flags = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port80, i32 0, i32 10
  %26 = load i64, i64* %flags, align 8, !tbaa !49
  %and81 = and i64 %26, 4
  %tobool82 = icmp ne i64 %and81, 0
  br i1 %tobool82, label %if.then83, label %if.end108

if.then83:                                        ; preds = %if.then78
  call void @do_SAK(%struct.tty_struct* %tty)
  br label %if.end108

if.else85:                                        ; preds = %if.then75
  %27 = load i32, i32* %status, align 4, !tbaa !55
  %and86 = and i32 %27, 4
  %tobool87 = icmp ne i32 %and86, 0
  br i1 %tobool87, label %if.then88, label %if.else91

if.then88:                                        ; preds = %if.else85
  %icount89 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %parity = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount89, i32 0, i32 7
  %28 = load i32, i32* %parity, align 4, !tbaa !198
  %inc90 = add i32 %28, 1
  store i32 %inc90, i32* %parity, align 4, !tbaa !198
  br label %if.end108

if.else91:                                        ; preds = %if.else85
  %29 = load i32, i32* %status, align 4, !tbaa !55
  %and92 = and i32 %29, 8
  %tobool93 = icmp ne i32 %and92, 0
  br i1 %tobool93, label %if.then94, label %if.else97

if.then94:                                        ; preds = %if.else91
  %icount95 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %frame = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount95, i32 0, i32 6
  %30 = load i32, i32* %frame, align 8, !tbaa !199
  %inc96 = add i32 %30, 1
  store i32 %inc96, i32* %frame, align 8, !tbaa !199
  br label %if.end108

if.else97:                                        ; preds = %if.else91
  %31 = load i32, i32* %status, align 4, !tbaa !55
  %and98 = and i32 %31, 2
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %if.then100, label %if.end108

if.then100:                                       ; preds = %if.else97
  %icount101 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %overrun = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount101, i32 0, i32 8
  %32 = load i32, i32* %overrun, align 8, !tbaa !200
  %inc102 = add i32 %32, 1
  store i32 %inc102, i32* %overrun, align 8, !tbaa !200
  br label %if.end108

if.end108:                                        ; preds = %if.then100, %if.else97, %if.then94, %if.then88, %if.then83, %if.then78, %if.else
  %flag.4 = phi i8 [ 0, %if.else ], [ 1, %if.then83 ], [ 1, %if.then78 ], [ 3, %if.then88 ], [ 2, %if.then94 ], [ 4, %if.then100 ], [ 1, %if.else97 ]
  %port109 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  call void @tty_insert_flip_char(%struct.tty_port* %port109, i8 zeroext %call52, i8 signext %flag.4)
  %inc111 = add nsw i32 %cnt.1, 1
  %cmp112 = icmp sge i32 %inc111, %0
  br i1 %cmp112, label %if.then114, label %LeafBlock

if.then114:                                       ; preds = %if.end108
  %ldisc_stop_rx115 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 14
  %33 = load i8, i8* %ldisc_stop_rx115, align 1, !tbaa !48
  %tobool116 = icmp ne i8 %33, 0
  br i1 %tobool116, label %LeafBlock, label %if.then117

if.then117:                                       ; preds = %if.then114
  call void @mxser_stoprx(%struct.tty_struct* %tty)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.then117, %if.then114, %if.end108
  %cleanup.dest.slot.0 = phi i32 [ 6, %if.then117 ], [ 6, %if.then114 ], [ 0, %if.end108 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 6
  br i1 %SwitchLeaf, label %end_intr, label %if.end120

if.end120:                                        ; preds = %LeafBlock, %if.then67
  %cnt.2 = phi i32 [ %cnt.1, %if.then67 ], [ %inc111, %LeafBlock ]
  %ignored.1 = phi i32 [ %inc68, %if.then67 ], [ %ignored.0, %LeafBlock ]
  %board121 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %34 = load %struct.mxser_board*, %struct.mxser_board** %board121, align 8, !tbaa !46
  %chip_flag122 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %34, i32 0, i32 5
  %35 = load i32, i32* %chip_flag122, align 8, !tbaa !17
  %tobool123 = icmp ne i32 %35, 0
  br i1 %tobool123, label %end_intr, label %if.end125

if.end125:                                        ; preds = %if.end120
  %ioaddr126 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %36 = load i64, i64* %ioaddr126, align 8, !tbaa !24
  %add127 = add i64 %36, 5
  %conv128 = trunc i64 %add127 to i32
  %call129 = call zeroext i8 @inb(i32 %conv128)
  %conv130 = zext i8 %call129 to i32
  store i32 %conv130, i32* %status, align 4, !tbaa !55
  %37 = load i32, i32* %status, align 4, !tbaa !55
  %and131 = and i32 %37, 1
  %tobool132 = icmp ne i32 %and131, 0
  br i1 %tobool132, label %do.body, label %end_intr

end_intr:                                         ; preds = %if.end125, %if.end120, %LeafBlock, %if.then67, %do.body, %while.cond
  %cnt.4 = phi i32 [ %cnt.0, %while.cond ], [ %cnt.1, %do.body ], [ %cnt.1, %if.then67 ], [ %cnt.2, %if.end120 ], [ %inc111, %LeafBlock ], [ %cnt.2, %if.end125 ]
  %conv133 = sext i32 %cnt.4 to i64
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %38 = load i32, i32* %index, align 8, !tbaa !58
  %idxprom = sext i32 %38 to i64
  %arrayidx = getelementptr inbounds [32 x i64], [32 x i64]* getelementptr inbounds (%struct.mxser_log, %struct.mxser_log* @mxvar_log, i32 0, i32 1), i64 0, i64 %idxprom
  %39 = load i64, i64* %arrayidx, align 8, !tbaa !62
  %add134 = add i64 %39, %conv133
  store i64 %add134, i64* %arrayidx, align 8, !tbaa !62
  %conv135 = sext i32 %cnt.4 to i64
  %mon_data = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 26
  %rxcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data, i32 0, i32 0
  %40 = load i64, i64* %rxcnt, align 8, !tbaa !81
  %add136 = add i64 %40, %conv135
  store i64 %add136, i64* %rxcnt, align 8, !tbaa !81
  %conv137 = sext i32 %cnt.4 to i64
  %mon_data138 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 26
  %up_rxcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data138, i32 0, i32 2
  %41 = load i64, i64* %up_rxcnt, align 8, !tbaa !201
  %add139 = add i64 %41, %conv137
  store i64 %add139, i64* %up_rxcnt, align 8, !tbaa !201
  %slock = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 27
  call void @spin_unlock(%struct.spinlock* %slock)
  %port140 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  call void @tty_flip_buffer_push(%struct.tty_port* %port140)
  %slock141 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 27
  call void @spin_lock(%struct.spinlock* %slock141)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_transmit_chars(%struct.tty_struct* %tty, %struct.mxser_port* %port) #4 {
entry:
  %x_char = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 10
  %0 = load i32, i32* %x_char, align 8, !tbaa !91
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %x_char1 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 10
  %1 = load i32, i32* %x_char1, align 8, !tbaa !91
  %conv = trunc i32 %1 to i8
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %2 = load i64, i64* %ioaddr, align 8, !tbaa !24
  %add = add i64 %2, 0
  %conv2 = trunc i64 %add to i32
  call void @outb(i8 zeroext %conv, i32 %conv2)
  %x_char3 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 10
  store i32 0, i32* %x_char3, align 8, !tbaa !91
  %index = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %3 = load i32, i32* %index, align 8, !tbaa !58
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [32 x i64], [32 x i64]* getelementptr inbounds (%struct.mxser_log, %struct.mxser_log* @mxvar_log, i32 0, i32 2), i64 0, i64 %idxprom
  %4 = load i64, i64* %arrayidx, align 8, !tbaa !62
  %inc = add i64 %4, 1
  store i64 %inc, i64* %arrayidx, align 8, !tbaa !62
  %mon_data = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 26
  %txcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data, i32 0, i32 1
  %5 = load i64, i64* %txcnt, align 8, !tbaa !82
  %inc4 = add i64 %5, 1
  store i64 %inc4, i64* %txcnt, align 8, !tbaa !82
  %mon_data5 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 26
  %up_txcnt = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data5, i32 0, i32 3
  %6 = load i64, i64* %up_txcnt, align 8, !tbaa !202
  %inc6 = add i64 %6, 1
  store i64 %inc6, i64* %up_txcnt, align 8, !tbaa !202
  %icount = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %tx = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount, i32 0, i32 4
  %7 = load i32, i32* %tx, align 8, !tbaa !203
  %inc7 = add i32 %7, 1
  store i32 %inc7, i32* %tx, align 8, !tbaa !203
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %port8 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %xmit_buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port8, i32 0, i32 15
  %8 = load i8*, i8** %xmit_buf, align 8, !tbaa !65
  %cmp = icmp eq i8* %8, null
  br i1 %cmp, label %cleanup.cont, label %if.end11

if.end11:                                         ; preds = %if.end
  %xmit_cnt = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %9 = load i32, i32* %xmit_cnt, align 4, !tbaa !66
  %cmp12 = icmp sle i32 %9, 0
  br i1 %cmp12, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end11
  %stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load = load i8, i8* %stopped, align 4
  %bf.clear = and i8 %bf.load, 1
  %conv14 = zext i8 %bf.clear to i32
  %tobool15 = icmp ne i32 %conv14, 0
  br i1 %tobool15, label %if.then25, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %lor.lhs.false
  %hw_stopped = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 21
  %bf.load17 = load i8, i8* %hw_stopped, align 4
  %bf.lshr = lshr i8 %bf.load17, 1
  %bf.clear18 = and i8 %bf.lshr, 1
  %conv19 = zext i8 %bf.clear18 to i32
  %tobool20 = icmp ne i32 %conv19, 0
  br i1 %tobool20, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %lor.lhs.false16
  %type = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 9
  %10 = load i32, i32* %type, align 4, !tbaa !50
  %cmp21 = icmp ne i32 %10, 4
  br i1 %cmp21, label %land.lhs.true23, label %if.end31

land.lhs.true23:                                  ; preds = %land.lhs.true
  %board = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 1
  %11 = load %struct.mxser_board*, %struct.mxser_board** %board, align 8, !tbaa !46
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %11, i32 0, i32 5
  %12 = load i32, i32* %chip_flag, align 8, !tbaa !17
  %tobool24 = icmp ne i32 %12, 0
  br i1 %tobool24, label %if.end31, label %if.then25

if.then25:                                        ; preds = %land.lhs.true23, %lor.lhs.false, %if.end11
  %IER = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %13 = load i32, i32* %IER, align 4, !tbaa !68
  %and = and i32 %13, -3
  store i32 %and, i32* %IER, align 4, !tbaa !68
  %IER26 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %14 = load i32, i32* %IER26, align 4, !tbaa !68
  %conv27 = trunc i32 %14 to i8
  %ioaddr28 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %15 = load i64, i64* %ioaddr28, align 8, !tbaa !24
  %add29 = add i64 %15, 1
  %conv30 = trunc i64 %add29 to i32
  call void @outb(i8 zeroext %conv27, i32 %conv30)
  br label %cleanup.cont

if.end31:                                         ; preds = %land.lhs.true23, %land.lhs.true, %lor.lhs.false16
  %xmit_cnt32 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %16 = load i32, i32* %xmit_cnt32, align 4, !tbaa !66
  %xmit_fifo_size = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 21
  %17 = load i32, i32* %xmit_fifo_size, align 8, !tbaa !94
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end31
  %count.0 = phi i32 [ %17, %if.end31 ], [ %dec51, %do.cond ]
  %port33 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 0
  %xmit_buf34 = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port33, i32 0, i32 15
  %18 = load i8*, i8** %xmit_buf34, align 8, !tbaa !65
  %xmit_tail = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 23
  %19 = load i32, i32* %xmit_tail, align 8, !tbaa !93
  %inc35 = add nsw i32 %19, 1
  store i32 %inc35, i32* %xmit_tail, align 8, !tbaa !93
  %idxprom36 = sext i32 %19 to i64
  %arrayidx37 = getelementptr inbounds i8, i8* %18, i64 %idxprom36
  %20 = load i8, i8* %arrayidx37, align 1, !tbaa !56
  %ioaddr38 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %21 = load i64, i64* %ioaddr38, align 8, !tbaa !24
  %add39 = add i64 %21, 0
  %conv40 = trunc i64 %add39 to i32
  call void @outb(i8 zeroext %20, i32 %conv40)
  %xmit_tail41 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 23
  %22 = load i32, i32* %xmit_tail41, align 8, !tbaa !93
  %conv42 = sext i32 %22 to i64
  %and43 = and i64 %conv42, 4095
  %conv44 = trunc i64 %and43 to i32
  %xmit_tail45 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 23
  store i32 %conv44, i32* %xmit_tail45, align 8, !tbaa !93
  %xmit_cnt46 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %23 = load i32, i32* %xmit_cnt46, align 4, !tbaa !66
  %dec = add nsw i32 %23, -1
  store i32 %dec, i32* %xmit_cnt46, align 4, !tbaa !66
  %cmp47 = icmp sle i32 %dec, 0
  br i1 %cmp47, label %do.end, label %do.cond

do.cond:                                          ; preds = %do.body
  %dec51 = add nsw i32 %count.0, -1
  %cmp52 = icmp sgt i32 %dec51, 0
  br i1 %cmp52, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond, %do.body
  %xmit_cnt54 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %24 = load i32, i32* %xmit_cnt54, align 4, !tbaa !66
  %sub = sub nsw i32 %16, %24
  %conv55 = sext i32 %sub to i64
  %index56 = getelementptr inbounds %struct.tty_struct, %struct.tty_struct* %tty, i32 0, i32 5
  %25 = load i32, i32* %index56, align 8, !tbaa !58
  %idxprom57 = sext i32 %25 to i64
  %arrayidx58 = getelementptr inbounds [32 x i64], [32 x i64]* getelementptr inbounds (%struct.mxser_log, %struct.mxser_log* @mxvar_log, i32 0, i32 2), i64 0, i64 %idxprom57
  %26 = load i64, i64* %arrayidx58, align 8, !tbaa !62
  %add59 = add i64 %26, %conv55
  store i64 %add59, i64* %arrayidx58, align 8, !tbaa !62
  %xmit_cnt60 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %27 = load i32, i32* %xmit_cnt60, align 4, !tbaa !66
  %sub61 = sub nsw i32 %16, %27
  %conv62 = sext i32 %sub61 to i64
  %mon_data63 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 26
  %txcnt64 = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data63, i32 0, i32 1
  %28 = load i64, i64* %txcnt64, align 8, !tbaa !82
  %add65 = add i64 %28, %conv62
  store i64 %add65, i64* %txcnt64, align 8, !tbaa !82
  %xmit_cnt66 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %29 = load i32, i32* %xmit_cnt66, align 4, !tbaa !66
  %sub67 = sub nsw i32 %16, %29
  %conv68 = sext i32 %sub67 to i64
  %mon_data69 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 26
  %up_txcnt70 = getelementptr inbounds %struct.mxser_mon, %struct.mxser_mon* %mon_data69, i32 0, i32 3
  %30 = load i64, i64* %up_txcnt70, align 8, !tbaa !202
  %add71 = add i64 %30, %conv68
  store i64 %add71, i64* %up_txcnt70, align 8, !tbaa !202
  %xmit_cnt72 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %31 = load i32, i32* %xmit_cnt72, align 4, !tbaa !66
  %sub73 = sub nsw i32 %16, %31
  %icount74 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 17
  %tx75 = getelementptr inbounds %struct.async_icount, %struct.async_icount* %icount74, i32 0, i32 4
  %32 = load i32, i32* %tx75, align 8, !tbaa !203
  %add76 = add i32 %32, %sub73
  store i32 %add76, i32* %tx75, align 8, !tbaa !203
  %xmit_cnt77 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %33 = load i32, i32* %xmit_cnt77, align 4, !tbaa !66
  %cmp78 = icmp slt i32 %33, 256
  br i1 %cmp78, label %if.then80, label %if.end81

if.then80:                                        ; preds = %do.end
  call void @tty_wakeup(%struct.tty_struct* %tty)
  br label %if.end81

if.end81:                                         ; preds = %if.then80, %do.end
  %xmit_cnt82 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 24
  %34 = load i32, i32* %xmit_cnt82, align 4, !tbaa !66
  %cmp83 = icmp sle i32 %34, 0
  br i1 %cmp83, label %if.then85, label %cleanup.cont

if.then85:                                        ; preds = %if.end81
  %IER86 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %35 = load i32, i32* %IER86, align 4, !tbaa !68
  %and87 = and i32 %35, -3
  store i32 %and87, i32* %IER86, align 4, !tbaa !68
  %IER88 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 11
  %36 = load i32, i32* %IER88, align 4, !tbaa !68
  %conv89 = trunc i32 %36 to i8
  %ioaddr90 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %port, i32 0, i32 2
  %37 = load i64, i64* %ioaddr90, align 8, !tbaa !24
  %add91 = add i64 %37, 1
  %conv92 = trunc i64 %add91 to i32
  call void @outb(i8 zeroext %conv89, i32 %conv92)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then85, %if.end81, %if.then25, %if.end, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @_raw_spin_lock(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @tty_insert_flip_char(%struct.tty_port* %port, i8 zeroext %ch, i8 signext %flag) #0 {
entry:
  %ch.addr = alloca i8, align 1
  %flag.addr = alloca i8, align 1
  store i8 %ch, i8* %ch.addr, align 1, !tbaa !56
  store i8 %flag, i8* %flag.addr, align 1, !tbaa !56
  %buf = getelementptr inbounds %struct.tty_port, %struct.tty_port* %port, i32 0, i32 0
  %tail = getelementptr inbounds %struct.tty_bufhead, %struct.tty_bufhead* %buf, i32 0, i32 3
  %0 = load %struct.tty_buffer*, %struct.tty_buffer** %tail, align 8, !tbaa !204
  %tobool = icmp ne %struct.tty_buffer* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %used = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 3
  %1 = load i32, i32* %used, align 8, !tbaa !205
  %size = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 4
  %2 = load i32, i32* %size, align 4, !tbaa !207
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %3 = load i8, i8* %flag.addr, align 1, !tbaa !56
  %flag_buf_ptr = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 2
  %4 = load i8*, i8** %flag_buf_ptr, align 8, !tbaa !208
  %used1 = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 3
  %5 = load i32, i32* %used1, align 8, !tbaa !205
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  store i8 %3, i8* %arrayidx, align 1, !tbaa !56
  %6 = load i8, i8* %ch.addr, align 1, !tbaa !56
  %char_buf_ptr = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 1
  %7 = load i8*, i8** %char_buf_ptr, align 8, !tbaa !209
  %used2 = getelementptr inbounds %struct.tty_buffer, %struct.tty_buffer* %0, i32 0, i32 3
  %8 = load i32, i32* %used2, align 8, !tbaa !205
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %used2, align 8, !tbaa !205
  %idxprom3 = sext i32 %8 to i64
  %arrayidx4 = getelementptr inbounds i8, i8* %7, i64 %idxprom3
  store i8 %6, i8* %arrayidx4, align 1, !tbaa !56
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true, %entry
  %call = call i32 @tty_insert_flip_string_flags(%struct.tty_port* %port, i8* %ch.addr, i8* %flag.addr, i64 1)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  ret void
}

declare void @do_SAK(%struct.tty_struct*) #3

declare void @tty_flip_buffer_push(%struct.tty_port*) #3

declare i32 @tty_insert_flip_string_flags(%struct.tty_port*, i8*, i8*, i64) #3

declare void @_raw_spin_unlock(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @mxser_release_vector(%struct.mxser_board* %brd) #4 {
entry:
  %call = call zeroext i1 @mxser_overlapping_vector(%struct.mxser_board* %brd)
  br i1 %call, label %return, label %if.end

if.end:                                           ; preds = %entry
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 3
  %0 = load i64, i64* %vector, align 8, !tbaa !40
  call void @__release_region(%struct.resource* @ioport_resource, i64 %0, i64 1)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @mxser_probe(%struct.pci_dev* %pdev, %struct.pci_device_id* %ent) #4 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx, i32 0, i32 2
  %0 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !12
  %cmp2 = icmp eq %struct.mxser_cardinfo* %0, null
  br i1 %cmp2, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %cmp3 = icmp uge i32 %i.0, 4
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %for.end
  %1 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end5:                                          ; preds = %for.end
  %idxprom6 = zext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [4 x %struct.mxser_board], [4 x %struct.mxser_board]* @mxser_boards, i64 0, i64 %idxprom6
  %mul = mul i32 %i.0, 8
  %idx = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 0
  store i32 %mul, i32* %idx, align 8, !tbaa !210
  %2 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* null, i8* null)
  %call11 = call i32 @pci_enable_device(%struct.pci_dev* %pdev)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end5
  %3 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end15:                                         ; preds = %if.end5
  %resource = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 37
  %arrayidx16 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource, i64 0, i64 2
  %start = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx16, i32 0, i32 0
  %4 = load i64, i64* %start, align 8, !tbaa !211
  %call17 = call i32 @pci_request_region(%struct.pci_dev* %pdev, i32 2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.14, i32 0, i32 0))
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %err_dis, label %if.end20

if.end20:                                         ; preds = %if.end15
  %driver_data21 = getelementptr inbounds %struct.pci_device_id, %struct.pci_device_id* %ent, i32 0, i32 6
  %5 = load i64, i64* %driver_data21, align 8, !tbaa !213
  %arrayidx22 = getelementptr inbounds [32 x %struct.mxser_cardinfo], [32 x %struct.mxser_cardinfo]* @mxser_cards, i64 0, i64 %5
  %info23 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  store %struct.mxser_cardinfo* %arrayidx22, %struct.mxser_cardinfo** %info23, align 8, !tbaa !12
  br label %for.cond24

for.cond24:                                       ; preds = %for.body28, %if.end20
  %i.1 = phi i32 [ 0, %if.end20 ], [ %inc34, %for.body28 ]
  %info25 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %6 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info25, align 8, !tbaa !12
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %6, i32 0, i32 1
  %7 = load i32, i32* %nports, align 8, !tbaa !18
  %cmp26 = icmp ult i32 %i.1, %7
  br i1 %cmp26, label %for.body28, label %for.end35

for.body28:                                       ; preds = %for.cond24
  %mul29 = mul i32 8, %i.1
  %conv30 = zext i32 %mul29 to i64
  %add = add i64 %4, %conv30
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom31 = zext i32 %i.1 to i64
  %arrayidx32 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom31
  %ioaddr = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx32, i32 0, i32 2
  store i64 %add, i64* %ioaddr, align 8, !tbaa !24
  %inc34 = add i32 %i.1, 1
  br label %for.cond24

for.end35:                                        ; preds = %for.cond24
  %resource36 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 37
  %arrayidx37 = getelementptr inbounds [17 x %struct.resource], [17 x %struct.resource]* %resource36, i64 0, i64 3
  %start38 = getelementptr inbounds %struct.resource, %struct.resource* %arrayidx37, i32 0, i32 0
  %8 = load i64, i64* %start38, align 8, !tbaa !211
  %call39 = call i32 @pci_request_region(%struct.pci_dev* %pdev, i32 3, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.50, i32 0, i32 0))
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %err_zero, label %if.end42

if.end42:                                         ; preds = %for.end35
  %vector = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 3
  store i64 %8, i64* %vector, align 8, !tbaa !40
  %irq = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 36
  %9 = load i32, i32* %irq, align 4, !tbaa !215
  %irq43 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 1
  store i32 %9, i32* %irq43, align 4, !tbaa !23
  %ports44 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %arrayidx45 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports44, i64 0, i64 0
  %ioaddr46 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx45, i32 0, i32 2
  %10 = load i64, i64* %ioaddr46, align 8, !tbaa !24
  %call47 = call i32 @CheckIsMoxaMust(i64 %10)
  %chip_flag = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 5
  store i32 %call47, i32* %chip_flag, align 8, !tbaa !17
  %uart_type = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 6
  store i32 4, i32* %uart_type, align 4, !tbaa !44
  %vector_mask = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 4
  store i64 0, i64* %vector_mask, align 8, !tbaa !41
  br label %for.cond48

for.cond48:                                       ; preds = %for.inc85, %if.end42
  %i.2 = phi i32 [ 0, %if.end42 ], [ %inc86, %for.inc85 ]
  %info49 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %11 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info49, align 8, !tbaa !12
  %nports50 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %11, i32 0, i32 1
  %12 = load i32, i32* %nports50, align 8, !tbaa !18
  %cmp51 = icmp ult i32 %i.2, %12
  br i1 %cmp51, label %for.body53, label %for.end87

for.body53:                                       ; preds = %for.cond48
  br label %for.cond54

for.cond54:                                       ; preds = %for.inc82, %for.body53
  %j.0 = phi i32 [ 0, %for.body53 ], [ %inc83, %for.inc82 ]
  %conv55 = zext i32 %j.0 to i64
  %cmp56 = icmp ult i64 %conv55, 3
  br i1 %cmp56, label %for.body58, label %for.inc85

for.body58:                                       ; preds = %for.cond54
  %idxprom59 = zext i32 %j.0 to i64
  %arrayidx60 = getelementptr inbounds [3 x %struct.anon.48], [3 x %struct.anon.48]* @Gpci_uart_info, i64 0, i64 %idxprom59
  %type = getelementptr inbounds %struct.anon.48, %struct.anon.48* %arrayidx60, i32 0, i32 0
  %13 = load i32, i32* %type, align 8, !tbaa !154
  %chip_flag61 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 5
  %14 = load i32, i32* %chip_flag61, align 8, !tbaa !17
  %cmp62 = icmp eq i32 %13, %14
  br i1 %cmp62, label %if.then64, label %for.inc82

if.then64:                                        ; preds = %for.body58
  %idxprom65 = zext i32 %j.0 to i64
  %arrayidx66 = getelementptr inbounds [3 x %struct.anon.48], [3 x %struct.anon.48]* @Gpci_uart_info, i64 0, i64 %idxprom65
  %max_baud = getelementptr inbounds %struct.anon.48, %struct.anon.48* %arrayidx66, i32 0, i32 7
  %15 = load i64, i64* %max_baud, align 8, !tbaa !227
  %conv67 = trunc i64 %15 to i32
  %ports68 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom69 = zext i32 %i.2 to i64
  %arrayidx70 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports68, i64 0, i64 %idxprom69
  %max_baud71 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx70, i32 0, i32 4
  store i32 %conv67, i32* %max_baud71, align 8, !tbaa !43
  %info72 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %16 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info72, align 8, !tbaa !12
  %flags = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %16, i32 0, i32 2
  %17 = load i32, i32* %flags, align 4, !tbaa !20
  %and73 = and i32 %17, 1
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %if.then75, label %for.inc85

if.then75:                                        ; preds = %if.then64
  %ports76 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom77 = zext i32 %i.2 to i64
  %arrayidx78 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports76, i64 0, i64 %idxprom77
  %max_baud79 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx78, i32 0, i32 4
  store i32 921600, i32* %max_baud79, align 8, !tbaa !43
  br label %for.inc85

for.inc82:                                        ; preds = %for.body58
  %inc83 = add i32 %j.0, 1
  br label %for.cond54

for.inc85:                                        ; preds = %if.then75, %if.then64, %for.cond54
  %inc86 = add i32 %i.2, 1
  br label %for.cond48

for.end87:                                        ; preds = %for.cond48
  %chip_flag88 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 5
  %18 = load i32, i32* %chip_flag88, align 8, !tbaa !17
  %cmp89 = icmp eq i32 %18, 2
  br i1 %cmp89, label %if.then91, label %if.end118

if.then91:                                        ; preds = %for.end87
  br label %for.cond92

for.cond92:                                       ; preds = %for.body97, %if.then91
  %i.3 = phi i32 [ 0, %if.then91 ], [ %inc112, %for.body97 ]
  %info93 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %19 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info93, align 8, !tbaa !12
  %nports94 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %19, i32 0, i32 1
  %20 = load i32, i32* %nports94, align 8, !tbaa !18
  %cmp95 = icmp ult i32 %i.3, %20
  br i1 %cmp95, label %for.body97, label %for.end113

for.body97:                                       ; preds = %for.cond92
  %cmp98 = icmp ult i32 %i.3, 4
  %.sink = select i1 %cmp98, i64 4, i64 12
  %add105 = add i64 %8, %.sink
  %ports106 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom107 = zext i32 %i.3 to i64
  %arrayidx108 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports106, i64 0, i64 %idxprom107
  %opmode_ioaddr109 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx108, i32 0, i32 3
  store i64 %add105, i64* %opmode_ioaddr109, align 8, !tbaa !70
  %inc112 = add i32 %i.3, 1
  br label %for.cond92

for.end113:                                       ; preds = %for.cond92
  %add114 = add i64 %8, 4
  %conv115 = trunc i64 %add114 to i32
  call void @outb(i8 zeroext 0, i32 %conv115)
  %add116 = add i64 %8, 12
  %conv117 = trunc i64 %add116 to i32
  call void @outb(i8 zeroext 0, i32 %conv117)
  br label %if.end118

if.end118:                                        ; preds = %for.end113, %for.end87
  br label %for.cond119

for.cond119:                                      ; preds = %for.body124, %if.end118
  %i.4 = phi i32 [ 0, %if.end118 ], [ %inc131, %for.body124 ]
  %info120 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %21 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info120, align 8, !tbaa !12
  %nports121 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %21, i32 0, i32 1
  %22 = load i32, i32* %nports121, align 8, !tbaa !18
  %cmp122 = icmp ult i32 %i.4, %22
  br i1 %cmp122, label %for.body124, label %for.end132

for.body124:                                      ; preds = %for.cond119
  %shl = shl i32 1, %i.4
  %conv125 = sext i32 %shl to i64
  %vector_mask126 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 4
  %23 = load i64, i64* %vector_mask126, align 8, !tbaa !41
  %or = or i64 %23, %conv125
  store i64 %or, i64* %vector_mask126, align 8, !tbaa !41
  %ports127 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom128 = zext i32 %i.4 to i64
  %arrayidx129 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports127, i64 0, i64 %idxprom128
  %baud_base = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx129, i32 0, i32 8
  store i32 921600, i32* %baud_base, align 8, !tbaa !42
  %inc131 = add i32 %i.4, 1
  br label %for.cond119

for.end132:                                       ; preds = %for.cond119
  %call133 = call i32 @mxser_initbrd(%struct.mxser_board* %arrayidx7)
  %tobool134 = icmp ne i32 %call133, 0
  br i1 %tobool134, label %err_rel3, label %if.end136

if.end136:                                        ; preds = %for.end132
  br label %for.cond137

for.cond137:                                      ; preds = %for.inc164, %if.end136
  %i.5 = phi i32 [ 0, %if.end136 ], [ %inc165, %for.inc164 ]
  %info138 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %24 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info138, align 8, !tbaa !12
  %nports139 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %24, i32 0, i32 1
  %25 = load i32, i32* %nports139, align 8, !tbaa !18
  %cmp140 = icmp ult i32 %i.5, %25
  br i1 %cmp140, label %for.body142, label %for.end166

for.body142:                                      ; preds = %for.cond137
  %ports143 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom144 = zext i32 %i.5 to i64
  %arrayidx145 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports143, i64 0, i64 %idxprom144
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx145, i32 0, i32 0
  %26 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !16
  %idx146 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 0
  %27 = load i32, i32* %idx146, align 8, !tbaa !210
  %add147 = add i32 %27, %i.5
  %dev148 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %call149 = call %struct.device* @tty_port_register_device(%struct.tty_port* %port, %struct.tty_driver* %26, i32 %add147, %struct.device* %dev148)
  %28 = bitcast %struct.device* %call149 to i8*
  %call150 = call i64 @IS_ERR(i8* %28)
  %tobool151 = icmp ne i64 %call150, 0
  br i1 %tobool151, label %if.then152, label %for.inc164

if.then152:                                       ; preds = %for.body142
  %29 = bitcast %struct.device* %call149 to i8*
  %call153 = call i64 @PTR_ERR(i8* %29)
  %conv154 = trunc i64 %call153 to i32
  br label %for.cond155

for.cond155:                                      ; preds = %for.body158, %if.then152
  %i.6 = phi i32 [ %i.5, %if.then152 ], [ %dec, %for.body158 ]
  %cmp156 = icmp ugt i32 %i.6, 0
  br i1 %cmp156, label %for.body158, label %err_relbrd

for.body158:                                      ; preds = %for.cond155
  %30 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !16
  %idx159 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 0
  %31 = load i32, i32* %idx159, align 8, !tbaa !210
  %add160 = add i32 %31, %i.6
  %sub = sub i32 %add160, 1
  call void @tty_unregister_device(%struct.tty_driver* %30, i32 %sub)
  %dec = add i32 %i.6, -1
  br label %for.cond155

for.inc164:                                       ; preds = %for.body142
  %inc165 = add i32 %i.5, 1
  br label %for.cond137

for.end166:                                       ; preds = %for.cond137
  %32 = bitcast %struct.mxser_board* %arrayidx7 to i8*
  call void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %32)
  br label %cleanup

err_relbrd:                                       ; preds = %for.cond155
  br label %for.cond167

for.cond167:                                      ; preds = %for.body172, %err_relbrd
  %i.7 = phi i32 [ 0, %err_relbrd ], [ %inc178, %for.body172 ]
  %info168 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  %33 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info168, align 8, !tbaa !12
  %nports169 = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %33, i32 0, i32 1
  %34 = load i32, i32* %nports169, align 8, !tbaa !18
  %cmp170 = icmp ult i32 %i.7, %34
  br i1 %cmp170, label %for.body172, label %for.end179

for.body172:                                      ; preds = %for.cond167
  %ports173 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 7
  %idxprom174 = zext i32 %i.7 to i64
  %arrayidx175 = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports173, i64 0, i64 %idxprom174
  %port176 = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx175, i32 0, i32 0
  call void @tty_port_destroy(%struct.tty_port* %port176)
  %inc178 = add i32 %i.7, 1
  br label %for.cond167

for.end179:                                       ; preds = %for.cond167
  %irq180 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 1
  %35 = load i32, i32* %irq180, align 4, !tbaa !23
  %36 = bitcast %struct.mxser_board* %arrayidx7 to i8*
  call void @free_irq(i32 %35, i8* %36)
  br label %err_rel3

err_rel3:                                         ; preds = %for.end179, %for.end132
  %retval1.0 = phi i32 [ %conv154, %for.end179 ], [ %call133, %for.end132 ]
  call void @pci_release_region(%struct.pci_dev* %pdev, i32 3)
  br label %err_zero

err_zero:                                         ; preds = %err_rel3, %for.end35
  %retval1.1 = phi i32 [ %retval1.0, %err_rel3 ], [ %call39, %for.end35 ]
  %info181 = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %arrayidx7, i32 0, i32 2
  store %struct.mxser_cardinfo* null, %struct.mxser_cardinfo** %info181, align 8, !tbaa !12
  call void @pci_release_region(%struct.pci_dev* %pdev, i32 2)
  br label %err_dis

err_dis:                                          ; preds = %err_zero, %if.end15
  %retval1.2 = phi i32 [ %retval1.1, %err_zero ], [ %call17, %if.end15 ]
  call void @pci_disable_device(%struct.pci_dev* %pdev)
  br label %cleanup

cleanup:                                          ; preds = %err_dis, %for.end166, %if.then12, %if.then4
  %retval.0 = phi i32 [ 0, %for.end166 ], [ -22, %if.then4 ], [ %call11, %if.then12 ], [ %retval1.2, %err_dis ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @mxser_remove(%struct.pci_dev* %pdev) #4 {
entry:
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %pdev)
  %0 = bitcast i8* %call to %struct.mxser_board*
  call void @mxser_board_remove(%struct.mxser_board* %0)
  call void @pci_release_region(%struct.pci_dev* %pdev, i32 2)
  call void @pci_release_region(%struct.pci_dev* %pdev, i32 3)
  call void @pci_disable_device(%struct.pci_dev* %pdev)
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %0, i32 0, i32 2
  store %struct.mxser_cardinfo* null, %struct.mxser_cardinfo** %info, align 8, !tbaa !12
  ret void
}

declare i32 @dev_err(%struct.device*, i8*, ...) #3

declare i32 @_dev_info(%struct.device*, i8*, ...) #3

declare i32 @pci_enable_device(%struct.pci_dev*) #3

declare i32 @pci_request_region(%struct.pci_dev*, i32, i8*) #3

; Function Attrs: nounwind uwtable
define internal i32 @CheckIsMoxaMust(i64 %io) #4 {
entry:
  %hwid = alloca i8, align 1
  %add = add i64 %io, 3
  %conv = trunc i64 %add to i32
  call void @outb(i8 zeroext 0, i32 %conv)
  call void @mxser_disable_must_enchance_mode(i64 %io)
  %add1 = add i64 %io, 4
  %conv2 = trunc i64 %add1 to i32
  %call = call zeroext i8 @inb(i32 %conv2)
  %add3 = add i64 %io, 4
  %conv4 = trunc i64 %add3 to i32
  call void @outb(i8 zeroext 0, i32 %conv4)
  call void @mxser_set_must_xon1_value(i64 %io, i8 zeroext 17)
  %add5 = add i64 %io, 4
  %conv6 = trunc i64 %add5 to i32
  %call7 = call zeroext i8 @inb(i32 %conv6)
  store i8 %call7, i8* %hwid, align 1, !tbaa !56
  %conv8 = zext i8 %call7 to i32
  %cmp = icmp ne i32 %conv8, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %add10 = add i64 %io, 4
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @mxser_get_must_hardware_id(i64 %io, i8* %hwid)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 1, %if.end ], [ %inc, %for.inc ]
  %conv12 = sext i32 %i.0 to i64
  %cmp13 = icmp ult i64 %conv12, 3
  br i1 %cmp13, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %0 = load i8, i8* %hwid, align 1, !tbaa !56
  %conv15 = zext i8 %0 to i32
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.anon.48], [3 x %struct.anon.48]* @Gpci_uart_info, i64 0, i64 %idxprom
  %type = getelementptr inbounds %struct.anon.48, %struct.anon.48* %arrayidx, i32 0, i32 0
  %1 = load i32, i32* %type, align 8, !tbaa !154
  %cmp16 = icmp eq i32 %conv15, %1
  br i1 %cmp16, label %if.then18, label %for.inc

if.then18:                                        ; preds = %for.body
  %2 = load i8, i8* %hwid, align 1, !tbaa !56
  %conv19 = zext i8 %2 to i32
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.then18, %for.cond, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %conv19, %if.then18 ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %data) #0 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

declare void @pci_release_region(%struct.pci_dev*, i32) #3

declare void @pci_disable_device(%struct.pci_dev*) #3

; Function Attrs: nounwind uwtable
define internal void @mxser_disable_must_enchance_mode(i64 %baseio) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -17
  %conv7 = trunc i32 %and to i8
  %add8 = add i64 %baseio, 2
  %conv9 = trunc i64 %add8 to i32
  call void @outb(i8 zeroext %conv7, i32 %conv9)
  %add10 = add i64 %baseio, 3
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %call, i32 %conv11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @mxser_get_must_hardware_id(i64 %baseio, i8* %pId) #4 {
entry:
  %add = add i64 %baseio, 3
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @inb(i32 %conv)
  %add1 = add i64 %baseio, 3
  %conv2 = trunc i64 %add1 to i32
  call void @outb(i8 zeroext -65, i32 %conv2)
  %add3 = add i64 %baseio, 2
  %conv4 = trunc i64 %add3 to i32
  %call5 = call zeroext i8 @inb(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and = and i32 %conv6, -193
  %conv7 = trunc i32 %and to i8
  %conv8 = zext i8 %conv7 to i32
  %or = or i32 %conv8, 128
  %conv9 = trunc i32 %or to i8
  %add10 = add i64 %baseio, 2
  %conv11 = trunc i64 %add10 to i32
  call void @outb(i8 zeroext %conv9, i32 %conv11)
  %add12 = add i64 %baseio, 5
  %conv13 = trunc i64 %add12 to i32
  %call14 = call zeroext i8 @inb(i32 %conv13)
  store i8 %call14, i8* %pId, align 1, !tbaa !56
  %add15 = add i64 %baseio, 3
  %conv16 = trunc i64 %add15 to i32
  call void @outb(i8 zeroext %call, i32 %conv16)
  ret void
}

declare i32 @dev_set_drvdata(%struct.device*, i8*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_get_drvdata(%struct.pci_dev* %pdev) #0 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal void @mxser_board_remove(%struct.mxser_board* %brd) #4 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %info = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 2
  %0 = load %struct.mxser_cardinfo*, %struct.mxser_cardinfo** %info, align 8, !tbaa !12
  %nports = getelementptr inbounds %struct.mxser_cardinfo, %struct.mxser_cardinfo* %0, i32 0, i32 1
  %1 = load i32, i32* %nports, align 8, !tbaa !18
  %cmp = icmp ult i32 %i.0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.tty_driver*, %struct.tty_driver** @mxvar_sdriver, align 8, !tbaa !16
  %idx = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 0
  %3 = load i32, i32* %idx, align 8, !tbaa !210
  %add = add i32 %3, %i.0
  call void @tty_unregister_device(%struct.tty_driver* %2, i32 %add)
  %ports = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 7
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [8 x %struct.mxser_port], [8 x %struct.mxser_port]* %ports, i64 0, i64 %idxprom
  %port = getelementptr inbounds %struct.mxser_port, %struct.mxser_port* %arrayidx, i32 0, i32 0
  call void @tty_port_destroy(%struct.tty_port* %port)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %irq = getelementptr inbounds %struct.mxser_board, %struct.mxser_board* %brd, i32 0, i32 1
  %4 = load i32, i32* %irq, align 4, !tbaa !23
  %5 = bitcast %struct.mxser_board* %brd to i8*
  call void @free_irq(i32 %4, i8* %5)
  ret void
}

declare i8* @dev_get_drvdata(%struct.device*) #3

declare void @pci_unregister_driver(%struct.pci_driver*) #3

declare i32 @simpll__inlineasm_0(i32, i32*)

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone speculatable }
attributes #6 = { nounwind readnone }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !4, i64 8}
!13 = !{!"mxser_board", !14, i64 0, !14, i64 4, !4, i64 8, !15, i64 16, !15, i64 24, !14, i64 32, !14, i64 36, !5, i64 40}
!14 = !{!"int", !5, i64 0}
!15 = !{!"long", !5, i64 0}
!16 = !{!4, !4, i64 0}
!17 = !{!13, !14, i64 32}
!18 = !{!19, !14, i64 8}
!19 = !{!"mxser_cardinfo", !4, i64 0, !14, i64 8, !14, i64 12}
!20 = !{!19, !14, i64 12}
!21 = !{!22, !22, i64 0}
!22 = !{!"short", !5, i64 0}
!23 = !{!13, !14, i64 4}
!24 = !{!25, !15, i64 944}
!25 = !{!"mxser_port", !26, i64 0, !4, i64 936, !15, i64 944, !15, i64 952, !14, i64 960, !14, i64 964, !14, i64 968, !14, i64 972, !14, i64 976, !14, i64 980, !14, i64 984, !14, i64 988, !14, i64 992, !5, i64 996, !5, i64 997, !14, i64 1000, !5, i64 1004, !37, i64 1008, !14, i64 1052, !14, i64 1056, !14, i64 1060, !14, i64 1064, !14, i64 1068, !14, i64 1072, !14, i64 1076, !38, i64 1080, !39, i64 1128, !32, i64 1168}
!26 = !{!"tty_port", !27, i64 0, !4, i64 184, !4, i64 192, !4, i64 200, !32, i64 208, !14, i64 280, !14, i64 284, !33, i64 288, !33, i64 376, !33, i64 464, !15, i64 552, !15, i64 560, !5, i64 568, !5, i64 568, !34, i64 576, !34, i64 744, !4, i64 912, !14, i64 920, !14, i64 924, !14, i64 928, !36, i64 932}
!27 = !{!"tty_bufhead", !28, i64 0, !32, i64 80, !4, i64 152, !4, i64 160, !4, i64 168, !14, i64 176}
!28 = !{!"work_struct", !29, i64 0, !30, i64 8, !4, i64 24, !31, i64 32}
!29 = !{!"", !15, i64 0}
!30 = !{!"list_head", !4, i64 0, !4, i64 8}
!31 = !{!"lockdep_map", !4, i64 0, !5, i64 8, !4, i64 24, !14, i64 32, !15, i64 40}
!32 = !{!"spinlock", !5, i64 0}
!33 = !{!"__wait_queue_head", !32, i64 0, !30, i64 72}
!34 = !{!"mutex", !35, i64 0, !32, i64 8, !30, i64 80, !4, i64 96, !4, i64 104, !4, i64 112, !31, i64 120}
!35 = !{!"", !14, i64 0}
!36 = !{!"kref", !35, i64 0}
!37 = !{!"async_icount", !14, i64 0, !14, i64 4, !14, i64 8, !14, i64 12, !14, i64 16, !14, i64 20, !14, i64 24, !14, i64 28, !14, i64 32, !14, i64 36, !14, i64 40}
!38 = !{!"ktermios", !14, i64 0, !14, i64 4, !14, i64 8, !14, i64 12, !5, i64 16, !5, i64 17, !14, i64 36, !14, i64 40}
!39 = !{!"mxser_mon", !15, i64 0, !15, i64 8, !15, i64 16, !15, i64 24, !14, i64 32, !5, i64 36}
!40 = !{!13, !15, i64 16}
!41 = !{!13, !15, i64 24}
!42 = !{!25, !14, i64 976}
!43 = !{!25, !14, i64 960}
!44 = !{!13, !14, i64 36}
!45 = !{!25, !4, i64 200}
!46 = !{!25, !4, i64 936}
!47 = !{!25, !5, i64 996}
!48 = !{!25, !5, i64 997}
!49 = !{!25, !15, i64 552}
!50 = !{!25, !14, i64 980}
!51 = !{!25, !14, i64 1000}
!52 = !{!25, !14, i64 920}
!53 = !{!25, !14, i64 924}
!54 = !{i64 0, i64 4, !55, i64 4, i64 4, !55, i64 8, i64 4, !55, i64 12, i64 4, !55, i64 16, i64 1, !56, i64 17, i64 19, !56, i64 36, i64 4, !55, i64 40, i64 4, !55}
!55 = !{!14, !14, i64 0}
!56 = !{!5, !5, i64 0}
!57 = !{!25, !5, i64 1004}
!58 = !{!59, !14, i64 32}
!59 = !{!"tty_struct", !14, i64 0, !36, i64 4, !4, i64 8, !4, i64 16, !4, i64 24, !14, i64 32, !34, i64 40, !4, i64 208, !34, i64 216, !34, i64 384, !34, i64 552, !32, i64 720, !38, i64 792, !38, i64 836, !4, i64 880, !5, i64 888, !4, i64 952, !4, i64 960, !15, i64 968, !14, i64 976, !60, i64 980, !5, i64 988, !5, i64 988, !5, i64 988, !5, i64 988, !5, i64 989, !14, i64 992, !14, i64 996, !4, i64 1000, !4, i64 1008, !14, i64 1016, !33, i64 1024, !33, i64 1112, !28, i64 1200, !4, i64 1280, !4, i64 1288, !30, i64 1296, !5, i64 1312, !22, i64 1314, !4, i64 1320, !14, i64 1328, !28, i64 1336, !4, i64 1416}
!60 = !{!"winsize", !22, i64 0, !22, i64 2, !22, i64 4, !22, i64 6}
!61 = !{!59, !4, i64 1288}
!62 = !{!15, !15, i64 0}
!63 = !{!59, !14, i64 800}
!64 = !{i32 -2146986396, i32 -2146986357, i32 -2146986336, i32 -2146986299, i32 -2146986276, i32 -2146986406}
!65 = !{!25, !4, i64 912}
!66 = !{!25, !14, i64 1076}
!67 = !{!25, !14, i64 1068}
!68 = !{!25, !14, i64 988}
!69 = !{i32 -2143471954}
!70 = !{!25, !15, i64 952}
!71 = !{i32 -2143470414}
!72 = !{i64 0, i64 4, !55, i64 4, i64 4, !55, i64 8, i64 4, !55, i64 12, i64 4, !55, i64 16, i64 4, !55, i64 20, i64 4, !55, i64 24, i64 4, !55, i64 28, i64 4, !55, i64 32, i64 4, !55, i64 36, i64 4, !55, i64 40, i64 4, !55}
!73 = !{!74, !14, i64 0}
!74 = !{!"__wait_queue", !14, i64 0, !4, i64 8, !4, i64 16, !30, i64 24}
!75 = !{i32 -2146690840}
!76 = !{!74, !4, i64 8}
!77 = !{!74, !4, i64 16}
!78 = !{!30, !4, i64 0}
!79 = !{!30, !4, i64 8}
!80 = !{i32 -2143467008}
!81 = !{!25, !15, i64 1128}
!82 = !{!25, !15, i64 1136}
!83 = !{i32 -2143465263}
!84 = !{!25, !5, i64 1164}
!85 = !{i32 -2143463733}
!86 = !{i32 -2143462521}
!87 = !{i32 -2143461000}
!88 = !{!38, !14, i64 8}
!89 = !{!38, !14, i64 0}
!90 = !{!59, !14, i64 792}
!91 = !{!25, !14, i64 984}
!92 = !{!25, !14, i64 992}
!93 = !{!25, !14, i64 1072}
!94 = !{!25, !14, i64 1064}
!95 = !{!25, !14, i64 1052}
!96 = !{i32 -2143455855}
!97 = !{!37, !14, i64 24}
!98 = !{!99, !14, i64 24}
!99 = !{!"serial_icounter_struct", !14, i64 0, !14, i64 4, !14, i64 8, !14, i64 12, !14, i64 16, !14, i64 20, !14, i64 24, !14, i64 28, !14, i64 32, !14, i64 36, !14, i64 40, !5, i64 44}
!100 = !{!37, !14, i64 36}
!101 = !{!99, !14, i64 36}
!102 = !{!37, !14, i64 32}
!103 = !{!99, !14, i64 28}
!104 = !{!37, !14, i64 40}
!105 = !{!99, !14, i64 40}
!106 = !{!37, !14, i64 28}
!107 = !{!99, !14, i64 32}
!108 = !{!37, !14, i64 20}
!109 = !{!99, !14, i64 16}
!110 = !{!37, !14, i64 16}
!111 = !{!99, !14, i64 20}
!112 = !{!37, !14, i64 0}
!113 = !{!99, !14, i64 0}
!114 = !{!37, !14, i64 4}
!115 = !{!99, !14, i64 4}
!116 = !{!37, !14, i64 8}
!117 = !{!99, !14, i64 8}
!118 = !{!37, !14, i64 12}
!119 = !{!99, !14, i64 12}
!120 = !{i32 452784, i32 452795}
!121 = !{i32 -2145504444}
!122 = !{i32 -2145504242}
!123 = !{!124, !14, i64 0}
!124 = !{!"serial_struct", !14, i64 0, !14, i64 4, !14, i64 8, !14, i64 12, !14, i64 16, !14, i64 20, !14, i64 24, !14, i64 28, !22, i64 32, !5, i64 34, !5, i64 35, !14, i64 36, !22, i64 40, !22, i64 42, !4, i64 48, !22, i64 56, !14, i64 60, !15, i64 64}
!125 = !{!124, !14, i64 4}
!126 = !{!124, !14, i64 8}
!127 = !{!124, !14, i64 12}
!128 = !{!124, !14, i64 16}
!129 = !{!124, !14, i64 20}
!130 = !{!124, !14, i64 24}
!131 = !{!124, !14, i64 28}
!132 = !{!124, !22, i64 32}
!133 = !{!124, !5, i64 34}
!134 = !{!124, !14, i64 36}
!135 = !{!124, !22, i64 40}
!136 = !{!124, !22, i64 42}
!137 = !{!124, !4, i64 48}
!138 = !{!124, !22, i64 56}
!139 = !{!124, !14, i64 60}
!140 = !{!124, !15, i64 64}
!141 = !{!26, !15, i64 552}
!142 = !{!26, !14, i64 920}
!143 = !{!26, !14, i64 924}
!144 = !{i32 -2146987104, i32 -2146987065, i32 -2146987044, i32 -2146987007, i32 -2146986984, i32 -2146987114}
!145 = !{i32 -2143480120}
!146 = !{!25, !14, i64 1016}
!147 = !{!25, !14, i64 1012}
!148 = !{!25, !14, i64 1020}
!149 = !{!25, !14, i64 1008}
!150 = !{!25, !14, i64 1160}
!151 = !{!25, !14, i64 968}
!152 = !{!25, !14, i64 964}
!153 = !{!25, !14, i64 972}
!154 = !{!155, !14, i64 0}
!155 = !{!"", !14, i64 0, !14, i64 4, !14, i64 8, !14, i64 12, !14, i64 16, !14, i64 20, !14, i64 24, !15, i64 32}
!156 = !{!155, !14, i64 20}
!157 = !{!155, !14, i64 24}
!158 = !{!155, !14, i64 16}
!159 = !{!155, !14, i64 12}
!160 = !{!25, !14, i64 1056}
!161 = !{!25, !14, i64 1060}
!162 = !{!163, !4, i64 8}
!163 = !{!"task_struct", !15, i64 0, !4, i64 8, !35, i64 16, !14, i64 20, !14, i64 24, !164, i64 32, !14, i64 40, !14, i64 44, !14, i64 48, !14, i64 52, !14, i64 56, !14, i64 60, !4, i64 64, !165, i64 72, !171, i64 448, !4, i64 520, !172, i64 528, !5, i64 536, !14, i64 540, !14, i64 544, !14, i64 548, !173, i64 552, !174, i64 1064, !30, i64 1096, !175, i64 1112, !4, i64 1152, !4, i64 1160, !14, i64 1168, !14, i64 1172, !14, i64 1176, !14, i64 1180, !14, i64 1184, !14, i64 1188, !14, i64 1192, !14, i64 1196, !14, i64 1196, !14, i64 1196, !14, i64 1196, !14, i64 1196, !14, i64 1196, !14, i64 1200, !14, i64 1204, !15, i64 1208, !4, i64 1216, !4, i64 1224, !30, i64 1232, !30, i64 1248, !4, i64 1264, !30, i64 1272, !30, i64 1288, !5, i64 1304, !30, i64 1376, !4, i64 1392, !4, i64 1400, !4, i64 1408, !15, i64 1416, !15, i64 1424, !15, i64 1432, !15, i64 1440, !15, i64 1448, !176, i64 1456, !15, i64 1472, !15, i64 1480, !177, i64 1488, !177, i64 1504, !15, i64 1520, !15, i64 1528, !178, i64 1536, !5, i64 1560, !4, i64 1608, !4, i64 1616, !5, i64 1624, !14, i64 1640, !14, i64 1644, !179, i64 1648, !15, i64 1656, !180, i64 1664, !4, i64 1848, !4, i64 1856, !4, i64 1864, !4, i64 1872, !4, i64 1880, !182, i64 1888, !182, i64 1896, !182, i64 1904, !183, i64 1912, !15, i64 1936, !15, i64 1944, !4, i64 1952, !4, i64 1960, !4, i64 1968, !4, i64 1976, !4, i64 1984, !14, i64 1992, !14, i64 1996, !184, i64 2000, !14, i64 2016, !14, i64 2020, !32, i64 2024, !185, i64 2096, !187, i64 2168, !4, i64 2184, !4, i64 2192, !14, i64 2200, !15, i64 2208, !15, i64 2216, !14, i64 2224, !14, i64 2228, !14, i64 2232, !14, i64 2236, !15, i64 2240, !15, i64 2248, !14, i64 2256, !14, i64 2260, !14, i64 2264, !14, i64 2268, !168, i64 2272, !14, i64 2280, !14, i64 2284, !5, i64 2288, !14, i64 4976, !4, i64 4984, !4, i64 4992, !4, i64 5000, !4, i64 5008, !4, i64 5016, !4, i64 5024, !15, i64 5032, !4, i64 5040, !188, i64 5048, !168, i64 5104, !168, i64 5112, !15, i64 5120, !182, i64 5128, !189, i64 5256, !14, i64 5260, !14, i64 5264, !4, i64 5272, !30, i64 5280, !4, i64 5296, !4, i64 5304, !30, i64 5312, !4, i64 5328, !5, i64 5336, !34, i64 5352, !30, i64 5520, !4, i64 5536, !22, i64 5544, !22, i64 5546, !14, i64 5548, !14, i64 5552, !14, i64 5556, !168, i64 5560, !190, i64 5568, !190, i64 5584, !4, i64 5600, !191, i64 5608, !4, i64 5624, !14, i64 5632, !14, i64 5636, !14, i64 5640, !15, i64 5648, !14, i64 5656, !5, i64 5664, !15, i64 9504, !15, i64 9512, !14, i64 9520, !4, i64 9528, !168, i64 9536, !35, i64 9544, !35, i64 9548, !15, i64 9552, !15, i64 9560, !192, i64 9568, !14, i64 9600, !35, i64 9604, !4, i64 9608, !14, i64 9616, !14, i64 9620}
!164 = !{!"llist_node", !4, i64 0}
!165 = !{!"sched_entity", !166, i64 0, !167, i64 16, !30, i64 40, !14, i64 56, !168, i64 64, !168, i64 72, !168, i64 80, !168, i64 88, !168, i64 96, !169, i64 104, !4, i64 320, !4, i64 328, !4, i64 336, !170, i64 344}
!166 = !{!"load_weight", !15, i64 0, !15, i64 8}
!167 = !{!"rb_node", !15, i64 0, !4, i64 8, !4, i64 16}
!168 = !{!"long long", !5, i64 0}
!169 = !{!"sched_statistics", !168, i64 0, !168, i64 8, !168, i64 16, !168, i64 24, !168, i64 32, !168, i64 40, !168, i64 48, !168, i64 56, !168, i64 64, !168, i64 72, !168, i64 80, !168, i64 88, !168, i64 96, !168, i64 104, !168, i64 112, !168, i64 120, !168, i64 128, !168, i64 136, !168, i64 144, !168, i64 152, !168, i64 160, !168, i64 168, !168, i64 176, !168, i64 184, !168, i64 192, !168, i64 200, !168, i64 208}
!170 = !{!"sched_avg", !14, i64 0, !14, i64 4, !168, i64 8, !168, i64 16, !15, i64 24}
!171 = !{!"sched_rt_entity", !30, i64 0, !15, i64 16, !15, i64 24, !14, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64}
!172 = !{!"hlist_head", !4, i64 0}
!173 = !{!"cpumask", !5, i64 0}
!174 = !{!"sched_info", !15, i64 0, !168, i64 8, !168, i64 16, !168, i64 24}
!175 = !{!"plist_node", !14, i64 0, !30, i64 8, !30, i64 24}
!176 = !{!"cputime", !15, i64 0, !15, i64 8}
!177 = !{!"timespec", !15, i64 0, !15, i64 8}
!178 = !{!"task_cputime", !15, i64 0, !15, i64 8, !168, i64 16}
!179 = !{!"sysv_sem", !4, i64 0}
!180 = !{!"thread_struct", !5, i64 0, !15, i64 24, !15, i64 32, !15, i64 40, !22, i64 48, !22, i64 50, !22, i64 52, !22, i64 54, !15, i64 56, !15, i64 64, !5, i64 72, !15, i64 104, !15, i64 112, !15, i64 120, !15, i64 128, !15, i64 136, !181, i64 144, !4, i64 160, !15, i64 168, !14, i64 176}
!181 = !{!"fpu", !14, i64 0, !14, i64 4, !4, i64 8}
!182 = !{!"", !5, i64 0}
!183 = !{!"sigpending", !30, i64 0, !182, i64 16}
!184 = !{!"seccomp", !14, i64 0, !4, i64 8}
!185 = !{!"raw_spinlock", !186, i64 0, !14, i64 4, !14, i64 8, !4, i64 16, !31, i64 24}
!186 = !{!"arch_spinlock", !5, i64 0}
!187 = !{!"plist_head", !30, i64 0}
!188 = !{!"task_io_accounting", !168, i64 0, !168, i64 8, !168, i64 16, !168, i64 24, !168, i64 32, !168, i64 40, !168, i64 48}
!189 = !{!"seqcount", !14, i64 0}
!190 = !{!"callback_head", !4, i64 0, !4, i64 8}
!191 = !{!"page_frag", !4, i64 0, !14, i64 8, !14, i64 12}
!192 = !{!"memcg_batch_info", !14, i64 0, !4, i64 8, !15, i64 16, !15, i64 24}
!193 = !{!194, !194, i64 0}
!194 = !{!"_Bool", !5, i64 0}
!195 = !{i8 0, i8 2}
!196 = !{!59, !14, i64 992}
!197 = !{!25, !14, i64 1044}
!198 = !{!25, !14, i64 1036}
!199 = !{!25, !14, i64 1032}
!200 = !{!25, !14, i64 1040}
!201 = !{!25, !15, i64 1144}
!202 = !{!25, !15, i64 1152}
!203 = !{!25, !14, i64 1024}
!204 = !{!26, !4, i64 160}
!205 = !{!206, !14, i64 24}
!206 = !{!"tty_buffer", !4, i64 0, !4, i64 8, !4, i64 16, !14, i64 24, !14, i64 28, !14, i64 32, !14, i64 36, !5, i64 40}
!207 = !{!206, !14, i64 28}
!208 = !{!206, !4, i64 16}
!209 = !{!206, !4, i64 8}
!210 = !{!13, !14, i64 0}
!211 = !{!212, !168, i64 0}
!212 = !{!"resource", !168, i64 0, !168, i64 8, !4, i64 16, !15, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!213 = !{!214, !15, i64 24}
!214 = !{!"pci_device_id", !14, i64 0, !14, i64 4, !14, i64 8, !14, i64 12, !14, i64 16, !14, i64 20, !15, i64 24}
!215 = !{!216, !14, i64 1292}
!216 = !{!"pci_dev", !30, i64 0, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !14, i64 56, !22, i64 60, !22, i64 62, !22, i64 64, !22, i64 66, !14, i64 68, !5, i64 72, !5, i64 73, !5, i64 74, !5, i64 75, !5, i64 76, !5, i64 77, !5, i64 78, !5, i64 79, !22, i64 80, !4, i64 88, !168, i64 96, !217, i64 104, !14, i64 120, !5, i64 124, !14, i64 125, !14, i64 125, !14, i64 125, !14, i64 125, !14, i64 126, !14, i64 126, !14, i64 126, !14, i64 126, !14, i64 126, !14, i64 126, !14, i64 126, !14, i64 128, !14, i64 132, !4, i64 136, !14, i64 144, !218, i64 152, !14, i64 1288, !14, i64 1292, !5, i64 1296, !194, i64 2248, !14, i64 2249, !14, i64 2249, !14, i64 2249, !14, i64 2249, !14, i64 2249, !14, i64 2249, !14, i64 2249, !14, i64 2249, !14, i64 2250, !14, i64 2250, !14, i64 2250, !14, i64 2250, !14, i64 2250, !14, i64 2250, !14, i64 2250, !14, i64 2251, !14, i64 2251, !14, i64 2251, !14, i64 2251, !14, i64 2251, !14, i64 2251, !14, i64 2251, !14, i64 2251, !22, i64 2252, !35, i64 2256, !5, i64 2260, !172, i64 2328, !4, i64 2336, !14, i64 2344, !5, i64 2352, !5, i64 2488, !30, i64 2624, !4, i64 2640, !4, i64 2648, !5, i64 2656, !4, i64 2664, !168, i64 2672, !15, i64 2680}
!217 = !{!"device_dma_parameters", !14, i64 0, !15, i64 8}
!218 = !{!"device", !4, i64 0, !4, i64 8, !219, i64 16, !4, i64 80, !4, i64 88, !34, i64 96, !4, i64 264, !4, i64 272, !4, i64 280, !220, i64 288, !4, i64 880, !14, i64 888, !4, i64 896, !168, i64 904, !4, i64 912, !30, i64 920, !4, i64 936, !224, i64 944, !4, i64 960, !225, i64 968, !14, i64 976, !14, i64 980, !32, i64 984, !30, i64 1056, !226, i64 1072, !4, i64 1104, !4, i64 1112, !4, i64 1120, !4, i64 1128}
!219 = !{!"kobject", !4, i64 0, !30, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !36, i64 56, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60}
!220 = !{!"dev_pm_info", !221, i64 0, !14, i64 4, !14, i64 4, !194, i64 4, !194, i64 4, !194, i64 4, !194, i64 4, !32, i64 8, !30, i64 80, !222, i64 96, !4, i64 192, !194, i64 200, !194, i64 200, !223, i64 208, !15, i64 336, !28, i64 344, !33, i64 424, !35, i64 512, !35, i64 516, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 521, !14, i64 521, !14, i64 521, !14, i64 521, !14, i64 521, !5, i64 524, !5, i64 528, !14, i64 532, !14, i64 536, !15, i64 544, !15, i64 552, !15, i64 560, !15, i64 568, !4, i64 576, !4, i64 584}
!221 = !{!"pm_message", !14, i64 0}
!222 = !{!"completion", !14, i64 0, !33, i64 8}
!223 = !{!"timer_list", !30, i64 0, !15, i64 16, !4, i64 24, !4, i64 32, !15, i64 40, !14, i64 48, !14, i64 52, !4, i64 56, !5, i64 64, !31, i64 80}
!224 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!225 = !{!"acpi_dev_node", !4, i64 0}
!226 = !{!"klist_node", !4, i64 0, !30, i64 8, !36, i64 24}
!227 = !{!155, !15, i64 32}
