; ModuleID = 'tests/regression/kernel_modules/i2c-algo-bit/i2c-algo-bit_old-bit_test.bc'
source_filename = "drivers/i2c/algos/i2c-algo-bit.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.32 }
%union.anon.32 = type { i8* }
%struct.i2c_adapter = type { %struct.module*, i32, %struct.i2c_algorithm*, i8*, %struct.rt_mutex, i32, i32, %struct.device, i32, [48 x i8], %struct.completion, %struct.mutex, %struct.list_head, %struct.i2c_bus_recovery_info* }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i32 }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, %struct.memcg_batch_info, i32, %struct.atomic_t, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type opaque
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.atomic64_t = type { i64 }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.file = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.3, %union.anon.9, %union.anon.11, i64 }
%struct.address_space = type opaque
%struct.anon.3 = type { %union.anon.4, %union.anon.5 }
%union.anon.4 = type { i64 }
%union.anon.5 = type { i64 }
%union.anon.9 = type { %struct.list_head }
%union.anon.11 = type { i64 }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %struct.atomic_t, i64*, %struct.page*, i64 }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.12, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.13, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.14, %union.anon.15 }
%union.anon.12 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.13 = type { i64 }
%union.anon.14 = type { %struct.list_head }
%union.anon.15 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.16 }
%union.anon.16 = type { %struct.anon.17 }
%struct.anon.17 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.19, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.22 }
%union.anon.19 = type { %struct.anon.20 }
%struct.anon.20 = type { i64, i64 }
%union.anon.22 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.24 }
%union.anon.24 = type { %struct.anon.28, [80 x i8] }
%struct.anon.28 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.module_ref = type { i64, i64 }
%struct.i2c_algorithm = type { {}*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }
%struct.rt_mutex = type { %struct.raw_spinlock, %struct.plist_head, %struct.task_struct*, i32, i8*, i8*, i32, i8* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.proc_dir_entry*, %struct.kref, i64, i8* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32 }
%struct.proc_dir_entry = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.i2c_bus_recovery_info = type { i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*, i32)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_bus_recovery_info*)*, void (%struct.i2c_bus_recovery_info*)*, i32, i32 }
%struct.i2c_msg = type { i16, i16, i16, i8* }
%union.i2c_smbus_data = type { i16, [32 x i8] }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.i2c_algo_bit_data = type { i8*, void (i8*, i32)*, void (i8*, i32)*, i32 (i8*)*, i32 (i8*)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)*, i32, i32 }
%struct._ddebug = type { i8*, i8*, i8*, i8*, i32 }

@__param_str_bit_test = internal constant [9 x i8] c"bit_test\00", align 1
@param_ops_int = external global %struct.kernel_param_ops, align 8
@bit_test = internal global i32 0, align 4
@__param_bit_test = internal constant %struct.kernel_param { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_bit_test, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.32 { i8* bitcast (i32* @bit_test to i8*) } }, section "__param", align 8
@__UNIQUE_ID_bit_testtype51 = internal constant [22 x i8] c"parmtype=bit_test:int\00", section ".modinfo", align 1
@__UNIQUE_ID_bit_test52 = internal constant [63 x i8] c"parm=bit_test:lines testing - 0 off; 1 report; 2 fail if stuck\00", section ".modinfo", align 1
@__param_str_i2c_debug = internal constant [10 x i8] c"i2c_debug\00", align 1
@i2c_debug = internal global i32 1, align 4
@__param_i2c_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_i2c_debug, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 420, i16 -1, %union.anon.32 { i8* bitcast (i32* @i2c_debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_i2c_debugtype56 = internal constant [23 x i8] c"parmtype=i2c_debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_i2c_debug58 = internal constant [72 x i8] c"parm=i2c_debug:debug level - 0 off; 1 normal; 2 verbose; 3 very verbose\00", section ".modinfo", align 1
@i2c_bit_algo = constant { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* } { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)* @bit_xfer, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)* null, i32 (%struct.i2c_adapter*)* @bit_func }, align 8
@__crc_i2c_bit_algo = extern_weak global i8*, align 8
@__kcrctab_i2c_bit_algo = internal constant i64 ptrtoint (i8** @__crc_i2c_bit_algo to i64), section "___kcrctab+i2c_bit_algo", align 8
@__kstrtab_i2c_bit_algo = internal constant [13 x i8] c"i2c_bit_algo\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_algo = internal constant %struct.kernel_symbol { i64 ptrtoint ({ i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }* @i2c_bit_algo to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_i2c_bit_algo, i32 0, i32 0) }, section "___ksymtab+i2c_bit_algo", align 8
@__crc_i2c_bit_add_bus = extern_weak global i8*, align 8
@__kcrctab_i2c_bit_add_bus = internal constant i64 ptrtoint (i8** @__crc_i2c_bit_add_bus to i64), section "___kcrctab+i2c_bit_add_bus", align 8
@__kstrtab_i2c_bit_add_bus = internal constant [16 x i8] c"i2c_bit_add_bus\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_add_bus = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.i2c_adapter*)* @i2c_bit_add_bus to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_i2c_bit_add_bus, i32 0, i32 0) }, section "___ksymtab+i2c_bit_add_bus", align 8
@__crc_i2c_bit_add_numbered_bus = extern_weak global i8*, align 8
@__kcrctab_i2c_bit_add_numbered_bus = internal constant i64 ptrtoint (i8** @__crc_i2c_bit_add_numbered_bus to i64), section "___kcrctab+i2c_bit_add_numbered_bus", align 8
@__kstrtab_i2c_bit_add_numbered_bus = internal constant [25 x i8] c"i2c_bit_add_numbered_bus\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_add_numbered_bus = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.i2c_adapter*)* @i2c_bit_add_numbered_bus to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_i2c_bit_add_numbered_bus, i32 0, i32 0) }, section "___ksymtab+i2c_bit_add_numbered_bus", align 8
@__UNIQUE_ID_author669 = internal constant [47 x i8] c"author=Simon G. Vogl <simon@tk.uni-linz.ac.at>\00", section ".modinfo", align 1
@__UNIQUE_ID_description670 = internal constant [42 x i8] c"description=I2C-Bus bit-banging algorithm\00", section ".modinfo", align 1
@__UNIQUE_ID_license671 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@smp_ops = external global %struct.smp_ops, align 8
@bit_xfer.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), i8 43, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str = private unnamed_addr constant [13 x i8] c"i2c_algo_bit\00", align 1
@__func__.bit_xfer = private unnamed_addr constant [9 x i8] c"bit_xfer\00", align 1
@.str.1 = private unnamed_addr constant [33 x i8] c"drivers/i2c/algos/i2c-algo-bit.c\00", align 1
@.str.2 = private unnamed_addr constant [26 x i8] c"emitting start condition\0A\00", align 1
@bit_xfer.descriptor.3 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0), i8 51, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.4 = private unnamed_addr constant [35 x i8] c"emitting repeated start condition\0A\00", align 1
@bit_xfer.descriptor.5 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.6, i32 0, i32 0), i8 58, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.6 = private unnamed_addr constant [37 x i8] c"NAK from device addr 0x%02x msg #%d\0A\00", align 1
@bit_xfer.descriptor.7 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8, i32 0, i32 0), i8 67, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.8 = private unnamed_addr constant [16 x i8] c"read %d byte%s\0A\00", align 1
@.str.9 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.10 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@bit_xfer.descriptor.11 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.12, i32 0, i32 0), i8 78, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.12 = private unnamed_addr constant [17 x i8] c"wrote %d byte%s\0A\00", align 1
@bit_xfer.descriptor.13 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14, i32 0, i32 0), i8 89, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.14 = private unnamed_addr constant [25 x i8] c"emitting stop condition\0A\00", align 1
@jiffies = external global i64, align 8
@sclhi.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__func__.sclhi, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.15, i32 0, i32 0), i8 120, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@__func__.sclhi = private unnamed_addr constant [6 x i8] c"sclhi\00", align 1
@.str.15 = private unnamed_addr constant [53 x i8] c"i2c-algo-bit: needed %ld jiffies for SCL to go high\0A\00", align 1
@bit_doAddress.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.bit_doAddress, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.16, i32 0, i32 0), i8 -13, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@__func__.bit_doAddress = private unnamed_addr constant [14 x i8] c"bit_doAddress\00", align 1
@.str.16 = private unnamed_addr constant [11 x i8] c"addr0: %d\0A\00", align 1
@.str.17 = private unnamed_addr constant [31 x i8] c"died at extended address code\0A\00", align 1
@.str.18 = private unnamed_addr constant [26 x i8] c"died at 2nd address code\0A\00", align 1
@bit_doAddress.descriptor.19 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.bit_doAddress, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0), i8 4, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.20 = private unnamed_addr constant [31 x i8] c"died at repeated address code\0A\00", align 1
@try_address.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.try_address, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14, i32 0, i32 0), i8 97, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@__func__.try_address = private unnamed_addr constant [12 x i8] c"try_address\00", align 1
@try_address.descriptor.21 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.try_address, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), i8 101, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@try_address.descriptor.22 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.try_address, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.23, i32 0, i32 0), i8 108, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@.str.23 = private unnamed_addr constant [42 x i8] c"Used %d tries to %s client at 0x%02x: %s\0A\00", align 1
@.str.24 = private unnamed_addr constant [10 x i8] c"read from\00", align 1
@.str.25 = private unnamed_addr constant [9 x i8] c"write to\00", align 1
@.str.26 = private unnamed_addr constant [8 x i8] c"success\00", align 1
@.str.27 = private unnamed_addr constant [17 x i8] c"failed, timeout?\00", align 1
@i2c_outb.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.i2c_outb, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.28, i32 0, i32 0), i8 -75, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@__func__.i2c_outb = private unnamed_addr constant [9 x i8] c"i2c_outb\00", align 1
@.str.28 = private unnamed_addr constant [38 x i8] c"i2c_outb: 0x%02x, timeout at bit #%d\0A\00", align 1
@i2c_outb.descriptor.29 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.i2c_outb, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.30, i32 0, i32 0), i8 -61, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.30 = private unnamed_addr constant [34 x i8] c"i2c_outb: 0x%02x, timeout at ack\0A\00", align 1
@i2c_outb.descriptor.31 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.i2c_outb, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.32, i32 0, i32 0), i8 -52, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.32 = private unnamed_addr constant [21 x i8] c"i2c_outb: 0x%02x %s\0A\00", align 1
@.str.33 = private unnamed_addr constant [2 x i8] c"A\00", align 1
@.str.34 = private unnamed_addr constant [3 x i8] c"NA\00", align 1
@.str.35 = private unnamed_addr constant [38 x i8] c"readbytes: invalid block length (%d)\0A\00", align 1
@readbytes.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__func__.readbytes, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.36, i32 0, i32 0), i8 -46, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@__func__.readbytes = private unnamed_addr constant [10 x i8] c"readbytes\00", align 1
@.str.36 = private unnamed_addr constant [22 x i8] c"readbytes: 0x%02x %s\0A\00", align 1
@.str.37 = private unnamed_addr constant [13 x i8] c"(no ack/nak)\00", align 1
@i2c_inb.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @__func__.i2c_inb, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.38, i32 0, i32 0), i8 -31, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@__func__.i2c_inb = private unnamed_addr constant [8 x i8] c"i2c_inb\00", align 1
@.str.38 = private unnamed_addr constant [29 x i8] c"i2c_inb: timeout at bit #%d\0A\00", align 1
@.str.39 = private unnamed_addr constant [28 x i8] c"readbytes: ack/nak timeout\0A\00", align 1
@.str.40 = private unnamed_addr constant [25 x i8] c"sendbytes: NAK bailout.\0A\00", align 1
@.str.41 = private unnamed_addr constant [21 x i8] c"sendbytes: error %d\0A\00", align 1
@.str.42 = private unnamed_addr constant [35 x i8] c"Not I2C compliant: can't read SCL\0A\00", align 1
@.str.43 = private unnamed_addr constant [23 x i8] c"Bus may be unreliable\0A\00", align 1
@.str.44 = private unnamed_addr constant [45 x i8] c"\016%s: Testing SDA only, SCL is not readable\0A\00", align 1
@.str.45 = private unnamed_addr constant [45 x i8] c"\014%s: bus seems to be busy (scl=%d, sda=%d)\0A\00", align 1
@.str.46 = private unnamed_addr constant [23 x i8] c"\014%s: SDA stuck high!\0A\00", align 1
@.str.47 = private unnamed_addr constant [49 x i8] c"\014%s: SCL unexpected low while pulling SDA low!\0A\00", align 1
@.str.48 = private unnamed_addr constant [22 x i8] c"\014%s: SDA stuck low!\0A\00", align 1
@.str.49 = private unnamed_addr constant [50 x i8] c"\014%s: SCL unexpected low while pulling SDA high!\0A\00", align 1
@.str.50 = private unnamed_addr constant [23 x i8] c"\014%s: SCL stuck high!\0A\00", align 1
@.str.51 = private unnamed_addr constant [49 x i8] c"\014%s: SDA unexpected low while pulling SCL low!\0A\00", align 1
@.str.52 = private unnamed_addr constant [22 x i8] c"\014%s: SCL stuck low!\0A\00", align 1
@.str.53 = private unnamed_addr constant [50 x i8] c"\014%s: SDA unexpected low while pulling SCL high!\0A\00", align 1
@.str.54 = private unnamed_addr constant [15 x i8] c"\016%s: Test OK\0A\00", align 1
@llvm.used = appending global [15 x i8*] [i8* bitcast (%struct.kernel_param* @__param_bit_test to i8*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__UNIQUE_ID_bit_testtype51, i32 0, i32 0), i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__UNIQUE_ID_bit_test52, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_i2c_debug to i8*), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__UNIQUE_ID_i2c_debugtype56, i32 0, i32 0), i8* getelementptr inbounds ([72 x i8], [72 x i8]* @__UNIQUE_ID_i2c_debug58, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_i2c_bit_algo to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_algo to i8*), i8* bitcast (i64* @__kcrctab_i2c_bit_add_bus to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_add_bus to i8*), i8* bitcast (i64* @__kcrctab_i2c_bit_add_numbered_bus to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_add_numbered_bus to i8*), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @__UNIQUE_ID_author669, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @__UNIQUE_ID_description670, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license671, i32 0, i32 0)], section "llvm.metadata"

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bit_xfer(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msgs, i32 %num) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %pre_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %2 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer, align 8, !tbaa !40
  %tobool = icmp ne i32 (%struct.i2c_adapter*)* %2, null
  br i1 %tobool, label %if.then, label %do.body

if.then:                                          ; preds = %entry
  %pre_xfer1 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %3 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer1, align 8, !tbaa !40
  %call = call i32 %3(%struct.i2c_adapter* %i2c_adap)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %do.body

do.body:                                          ; preds = %if.then, %entry
  %4 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp4 = icmp sge i32 %4, 3
  br i1 %cmp4, label %do.body7, label %do.end18

do.body7:                                         ; preds = %do.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %do.end18

if.then11:                                        ; preds = %do.body7
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call12 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0))
  br label %do.end18

do.end18:                                         ; preds = %if.then11, %do.body7, %do.body
  call void @i2c_start(%struct.i2c_algo_bit_data* %1)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end18
  %i.0 = phi i32 [ 0, %do.end18 ], [ %inc, %for.inc ]
  %cmp19 = icmp slt i32 %i.0, %num
  br i1 %cmp19, label %for.body, label %do.body198

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msgs, i64 %idxprom
  %flags = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %5 = load i16, i16* %flags, align 2, !tbaa !43
  %conv21 = zext i16 %5 to i32
  %and22 = and i32 %conv21, 4096
  %conv23 = trunc i32 %and22 to i16
  %flags24 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %6 = load i16, i16* %flags24, align 2, !tbaa !43
  %conv25 = zext i16 %6 to i32
  %and26 = and i32 %conv25, 16384
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.end99, label %if.then28

if.then28:                                        ; preds = %for.body
  %tobool29 = icmp ne i32 %i.0, 0
  br i1 %tobool29, label %do.body31, label %if.end60

do.body31:                                        ; preds = %if.then28
  %7 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp32 = icmp sge i32 %7, 3
  br i1 %cmp32, label %do.body36, label %do.end59

do.body36:                                        ; preds = %do.body31
  %bf.load37 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.3 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr38 = lshr i32 %bf.load37, 18
  %bf.clear39 = and i32 %bf.lshr38, 255
  %and40 = and i32 %bf.clear39, 1
  %tobool41 = icmp ne i32 %and40, 0
  %lnot42 = xor i1 %tobool41, true
  %lnot44 = xor i1 %lnot42, true
  %lnot.ext45 = zext i1 %lnot44 to i32
  %conv46 = sext i32 %lnot.ext45 to i64
  %expval47 = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool48 = icmp ne i64 %expval47, 0
  br i1 %tobool48, label %if.then49, label %do.end59

if.then49:                                        ; preds = %do.body36
  %dev50 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call51 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.3 to %struct._ddebug*), %struct.device* %dev50, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0))
  br label %do.end59

do.end59:                                         ; preds = %if.then49, %do.body36, %do.body31
  call void @i2c_repstart(%struct.i2c_algo_bit_data* %1)
  br label %if.end60

if.end60:                                         ; preds = %do.end59, %if.then28
  %call61 = call i32 @bit_doAddress(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp62 = icmp eq i32 %call61, 0
  %tobool64 = icmp ne i16 %conv23, 0
  %or.cond = or i1 %cmp62, %tobool64
  br i1 %or.cond, label %if.end99, label %do.body66

do.body66:                                        ; preds = %if.end60
  %8 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp67 = icmp sge i32 %8, 1
  br i1 %cmp67, label %do.body71, label %do.body198

do.body71:                                        ; preds = %do.body66
  %bf.load72 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.5 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr73 = lshr i32 %bf.load72, 18
  %bf.clear74 = and i32 %bf.lshr73, 255
  %and75 = and i32 %bf.clear74, 1
  %tobool76 = icmp ne i32 %and75, 0
  %lnot77 = xor i1 %tobool76, true
  %lnot79 = xor i1 %lnot77, true
  %lnot.ext80 = zext i1 %lnot79 to i32
  %conv81 = sext i32 %lnot.ext80 to i64
  %expval82 = call i64 @llvm.expect.i64(i64 %conv81, i64 0)
  %tobool83 = icmp ne i64 %expval82, 0
  br i1 %tobool83, label %if.then84, label %do.body198

if.then84:                                        ; preds = %do.body71
  %dev85 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %idxprom86 = sext i32 %i.0 to i64
  %arrayidx87 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msgs, i64 %idxprom86
  %addr = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx87, i32 0, i32 0
  %9 = load i16, i16* %addr, align 8, !tbaa !46
  %conv88 = zext i16 %9 to i32
  %call89 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.5 to %struct._ddebug*), %struct.device* %dev85, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.6, i32 0, i32 0), i32 %conv88, i32 %i.0)
  br label %do.body198

if.end99:                                         ; preds = %if.end60, %for.body
  %flags100 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %10 = load i16, i16* %flags100, align 2, !tbaa !43
  %conv101 = zext i16 %10 to i32
  %and102 = and i32 %conv101, 1
  %tobool103 = icmp ne i32 %and102, 0
  br i1 %tobool103, label %if.then104, label %if.else

if.then104:                                       ; preds = %if.end99
  %call105 = call i32 @readbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp106 = icmp sge i32 %call105, 1
  %11 = load i32, i32* @i2c_debug, align 4
  %cmp110 = icmp sge i32 %11, 2
  %or.cond1 = and i1 %cmp106, %cmp110
  br i1 %or.cond1, label %do.body114, label %if.end140

do.body114:                                       ; preds = %if.then104
  %bf.load115 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.7 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr116 = lshr i32 %bf.load115, 18
  %bf.clear117 = and i32 %bf.lshr116, 255
  %and118 = and i32 %bf.clear117, 1
  %tobool119 = icmp ne i32 %and118, 0
  %lnot120 = xor i1 %tobool119, true
  %lnot122 = xor i1 %lnot120, true
  %lnot.ext123 = zext i1 %lnot122 to i32
  %conv124 = sext i32 %lnot.ext123 to i64
  %expval125 = call i64 @llvm.expect.i64(i64 %conv124, i64 0)
  %tobool126 = icmp ne i64 %expval125, 0
  br i1 %tobool126, label %if.then127, label %if.end140

if.then127:                                       ; preds = %do.body114
  %dev128 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %cmp129 = icmp eq i32 %call105, 1
  %cond = select i1 %cmp129, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.10, i32 0, i32 0)
  %call131 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.7 to %struct._ddebug*), %struct.device* %dev128, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8, i32 0, i32 0), i32 %call105, i8* %cond)
  br label %if.end140

if.end140:                                        ; preds = %if.then127, %do.body114, %if.then104
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 2
  %12 = load i16, i16* %len, align 4, !tbaa !47
  %conv141 = zext i16 %12 to i32
  %cmp142 = icmp slt i32 %call105, %conv141
  br i1 %cmp142, label %if.then144, label %for.inc

if.then144:                                       ; preds = %if.end140
  %cmp145 = icmp sge i32 %call105, 0
  %.call105 = select i1 %cmp145, i32 -5, i32 %call105
  br label %do.body198

if.else:                                          ; preds = %if.end99
  %call150 = call i32 @sendbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp151 = icmp sge i32 %call150, 1
  %13 = load i32, i32* @i2c_debug, align 4
  %cmp155 = icmp sge i32 %13, 2
  %or.cond2 = and i1 %cmp151, %cmp155
  br i1 %or.cond2, label %do.body159, label %if.end186

do.body159:                                       ; preds = %if.else
  %bf.load160 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.11 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr161 = lshr i32 %bf.load160, 18
  %bf.clear162 = and i32 %bf.lshr161, 255
  %and163 = and i32 %bf.clear162, 1
  %tobool164 = icmp ne i32 %and163, 0
  %lnot165 = xor i1 %tobool164, true
  %lnot167 = xor i1 %lnot165, true
  %lnot.ext168 = zext i1 %lnot167 to i32
  %conv169 = sext i32 %lnot.ext168 to i64
  %expval170 = call i64 @llvm.expect.i64(i64 %conv169, i64 0)
  %tobool171 = icmp ne i64 %expval170, 0
  br i1 %tobool171, label %if.then172, label %if.end186

if.then172:                                       ; preds = %do.body159
  %dev173 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %cmp174 = icmp eq i32 %call150, 1
  %cond176 = select i1 %cmp174, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.10, i32 0, i32 0)
  %call177 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.11 to %struct._ddebug*), %struct.device* %dev173, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.12, i32 0, i32 0), i32 %call150, i8* %cond176)
  br label %if.end186

if.end186:                                        ; preds = %if.then172, %do.body159, %if.else
  %len187 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 2
  %14 = load i16, i16* %len187, align 4, !tbaa !47
  %conv188 = zext i16 %14 to i32
  %cmp189 = icmp slt i32 %call150, %conv188
  br i1 %cmp189, label %if.then191, label %for.inc

if.then191:                                       ; preds = %if.end186
  %cmp192 = icmp sge i32 %call150, 0
  %.call150 = select i1 %cmp192, i32 -5, i32 %call150
  br label %do.body198

for.inc:                                          ; preds = %if.end186, %if.end140
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

do.body198:                                       ; preds = %if.then191, %if.then144, %if.then84, %do.body71, %do.body66, %for.cond
  %ret.2 = phi i32 [ %.call105, %if.then144 ], [ %.call150, %if.then191 ], [ %call61, %do.body71 ], [ %call61, %if.then84 ], [ %call61, %do.body66 ], [ %i.0, %for.cond ]
  %15 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp199 = icmp sge i32 %15, 3
  br i1 %cmp199, label %do.body203, label %do.end226

do.body203:                                       ; preds = %do.body198
  %bf.load204 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.13 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr205 = lshr i32 %bf.load204, 18
  %bf.clear206 = and i32 %bf.lshr205, 255
  %and207 = and i32 %bf.clear206, 1
  %tobool208 = icmp ne i32 %and207, 0
  %lnot209 = xor i1 %tobool208, true
  %lnot211 = xor i1 %lnot209, true
  %lnot.ext212 = zext i1 %lnot211 to i32
  %conv213 = sext i32 %lnot.ext212 to i64
  %expval214 = call i64 @llvm.expect.i64(i64 %conv213, i64 0)
  %tobool215 = icmp ne i64 %expval214, 0
  br i1 %tobool215, label %if.then216, label %do.end226

if.then216:                                       ; preds = %do.body203
  %dev217 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call218 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.13 to %struct._ddebug*), %struct.device* %dev217, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14, i32 0, i32 0))
  br label %do.end226

do.end226:                                        ; preds = %if.then216, %do.body203, %do.body198
  call void @i2c_stop(%struct.i2c_algo_bit_data* %1)
  %post_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %16 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer, align 8, !tbaa !48
  %tobool227 = icmp ne void (%struct.i2c_adapter*)* %16, null
  br i1 %tobool227, label %if.then228, label %cleanup

if.then228:                                       ; preds = %do.end226
  %post_xfer229 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %17 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer229, align 8, !tbaa !48
  call void %17(%struct.i2c_adapter* %i2c_adap)
  br label %cleanup

cleanup:                                          ; preds = %if.then228, %do.end226, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %ret.2, %if.then228 ], [ %ret.2, %do.end226 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @bit_func(%struct.i2c_adapter* %adap) #1 {
entry:
  ret i32 268402719
}

; Function Attrs: nounwind uwtable
define i32 @i2c_bit_add_bus(%struct.i2c_adapter* %adap) #1 {
entry:
  %call = call i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* @i2c_add_adapter)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
declare i32 @__i2c_bit_add_bus(%struct.i2c_adapter*, i32 (%struct.i2c_adapter*)*) #1

declare i32 @i2c_add_adapter(%struct.i2c_adapter*) #2

; Function Attrs: nounwind uwtable
define i32 @i2c_bit_add_numbered_bus(%struct.i2c_adapter* %adap) #1 {
entry:
  %call = call i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* @i2c_add_numbered_adapter)
  ret i32 %call
}

declare i32 @i2c_add_numbered_adapter(%struct.i2c_adapter*) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #4

declare i32 @__dynamic_dev_dbg(%struct._ddebug*, %struct.device*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal void @i2c_start(%struct.i2c_algo_bit_data* %adap) #1 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !49
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !50
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !51
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  call void @scllo(%struct.i2c_algo_bit_data* %adap)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @i2c_repstart(%struct.i2c_algo_bit_data* %adap) #1 {
entry:
  call void @sdahi(%struct.i2c_algo_bit_data* %adap)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %adap)
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !49
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !50
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !51
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  call void @scllo(%struct.i2c_algo_bit_data* %adap)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bit_doAddress(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #1 {
entry:
  %flags1 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %0 = load i16, i16* %flags1, align 2, !tbaa !43
  %flags2 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %1 = load i16, i16* %flags2, align 2, !tbaa !43
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 4096
  %conv3 = trunc i32 %and to i16
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %2 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %3 = bitcast i8* %2 to %struct.i2c_algo_bit_data*
  %conv4 = zext i16 %conv3 to i32
  %tobool = icmp ne i32 %conv4, 0
  br i1 %tobool, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %retries5 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 6
  %4 = load i32, i32* %retries5, align 4, !tbaa !52
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %entry
  %cond = phi i32 [ %4, %cond.false ], [ 0, %entry ]
  %conv6 = zext i16 %0 to i32
  %and7 = and i32 %conv6, 16
  %tobool8 = icmp ne i32 %and7, 0
  %addr9 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 0
  %5 = load i16, i16* %addr9, align 8, !tbaa !46
  %conv10 = zext i16 %5 to i32
  br i1 %tobool8, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %shr = ashr i32 %conv10, 7
  %and11 = and i32 %shr, 6
  %or = or i32 240, %and11
  %conv12 = trunc i32 %or to i8
  %6 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp = icmp sge i32 %6, 2
  br i1 %cmp, label %do.body16, label %do.end28

do.body16:                                        ; preds = %if.then
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_doAddress.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and17 = and i32 %bf.clear, 1
  %tobool18 = icmp ne i32 %and17, 0
  %lnot = xor i1 %tobool18, true
  %lnot19 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot19 to i32
  %conv20 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv20, i64 0)
  %tobool21 = icmp ne i64 %expval, 0
  br i1 %tobool21, label %if.then22, label %do.end28

if.then22:                                        ; preds = %do.body16
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %conv23 = zext i8 %conv12 to i32
  %call = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_doAddress.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.16, i32 0, i32 0), i32 %conv23)
  br label %do.end28

do.end28:                                         ; preds = %if.then22, %do.body16, %if.then
  %call29 = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv12, i32 %cond)
  %cmp30 = icmp eq i32 %call29, 1
  %tobool32 = icmp ne i16 %conv3, 0
  %or.cond = or i1 %cmp30, %tobool32
  br i1 %or.cond, label %if.end36, label %if.then33

if.then33:                                        ; preds = %do.end28
  %7 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end36:                                         ; preds = %do.end28
  %addr37 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 0
  %8 = load i16, i16* %addr37, align 8, !tbaa !46
  %conv38 = zext i16 %8 to i32
  %and39 = and i32 %conv38, 255
  %conv40 = trunc i32 %and39 to i8
  %call41 = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv40)
  %cmp42 = icmp eq i32 %call41, 1
  %tobool45 = icmp ne i16 %conv3, 0
  %or.cond1 = or i1 %cmp42, %tobool45
  br i1 %or.cond1, label %if.end49, label %if.then46

if.then46:                                        ; preds = %if.end36
  %9 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end49:                                         ; preds = %if.end36
  %conv50 = zext i16 %0 to i32
  %and51 = and i32 %conv50, 1
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %do.body54, label %if.end121

do.body54:                                        ; preds = %if.end49
  %10 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp55 = icmp sge i32 %10, 3
  br i1 %cmp55, label %do.body59, label %do.end82

do.body59:                                        ; preds = %do.body54
  %bf.load60 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_doAddress.descriptor.19 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr61 = lshr i32 %bf.load60, 18
  %bf.clear62 = and i32 %bf.lshr61, 255
  %and63 = and i32 %bf.clear62, 1
  %tobool64 = icmp ne i32 %and63, 0
  %lnot65 = xor i1 %tobool64, true
  %lnot67 = xor i1 %lnot65, true
  %lnot.ext68 = zext i1 %lnot67 to i32
  %conv69 = sext i32 %lnot.ext68 to i64
  %expval70 = call i64 @llvm.expect.i64(i64 %conv69, i64 0)
  %tobool71 = icmp ne i64 %expval70, 0
  br i1 %tobool71, label %if.then72, label %do.end82

if.then72:                                        ; preds = %do.body59
  %dev73 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call74 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_doAddress.descriptor.19 to %struct._ddebug*), %struct.device* %dev73, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0))
  br label %do.end82

do.end82:                                         ; preds = %if.then72, %do.body59, %do.body54
  call void @i2c_repstart(%struct.i2c_algo_bit_data* %3)
  %conv83 = zext i8 %conv12 to i32
  %or84 = or i32 %conv83, 1
  %conv85 = trunc i32 %or84 to i8
  %call86 = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv85, i32 %cond)
  %cmp87 = icmp eq i32 %call86, 1
  %tobool90 = icmp ne i16 %conv3, 0
  %or.cond2 = or i1 %cmp87, %tobool90
  br i1 %or.cond2, label %if.end121, label %if.then91

if.then91:                                        ; preds = %do.end82
  %11 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.else:                                          ; preds = %cond.end
  %shl = shl i32 %conv10, 1
  %conv98 = trunc i32 %shl to i8
  %conv99 = zext i16 %0 to i32
  %and100 = and i32 %conv99, 1
  %tobool101 = icmp ne i32 %and100, 0
  %conv103 = zext i8 %conv98 to i32
  %or104 = or i32 %conv103, 1
  %conv105 = trunc i32 %or104 to i8
  %addr.0 = select i1 %tobool101, i8 %conv105, i8 %conv98
  %conv107 = zext i16 %0 to i32
  %and108 = and i32 %conv107, 8192
  %tobool109 = icmp ne i32 %and108, 0
  %conv111 = zext i8 %addr.0 to i32
  %xor = xor i32 %conv111, 1
  %conv112 = trunc i32 %xor to i8
  %addr.1 = select i1 %tobool109, i8 %conv112, i8 %addr.0
  %call114 = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr.1, i32 %cond)
  %cmp115 = icmp eq i32 %call114, 1
  %tobool118 = icmp ne i16 %conv3, 0
  %or.cond3 = or i1 %cmp115, %tobool118
  br i1 %or.cond3, label %if.end121, label %cleanup

if.end121:                                        ; preds = %if.else, %do.end82, %if.end49
  br label %cleanup

cleanup:                                          ; preds = %if.end121, %if.else, %if.then91, %if.then46, %if.then33
  %retval.0 = phi i32 [ 0, %if.end121 ], [ -5, %if.then91 ], [ -6, %if.then46 ], [ -6, %if.then33 ], [ -6, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @readbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #1 {
entry:
  %buf = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 3
  %0 = load i8*, i8** %buf, align 8, !tbaa !53
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %1 = load i16, i16* %len, align 4, !tbaa !47
  %conv = zext i16 %1 to i32
  %flags1 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %2 = load i16, i16* %flags1, align 2, !tbaa !43
  %conv2 = zext i16 %2 to i32
  br label %while.cond

while.cond:                                       ; preds = %if.end58, %entry
  %temp.0 = phi i8* [ %0, %entry ], [ %incdec.ptr, %if.end58 ]
  %rdcount.0 = phi i32 [ 0, %entry ], [ %inc, %if.end58 ]
  %count.0 = phi i32 [ %conv, %entry ], [ %count.1, %if.end58 ]
  %cmp = icmp sgt i32 %count.0, 0
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %call = call i32 @i2c_inb(%struct.i2c_adapter* %i2c_adap)
  %cmp4 = icmp sge i32 %call, 0
  br i1 %cmp4, label %if.then, label %cleanup

if.then:                                          ; preds = %while.body
  %conv6 = trunc i32 %call to i8
  store i8 %conv6, i8* %temp.0, align 1, !tbaa !54
  %inc = add nsw i32 %rdcount.0, 1
  %incdec.ptr = getelementptr inbounds i8, i8* %temp.0, i32 1
  %dec = add nsw i32 %count.0, -1
  %cmp7 = icmp eq i32 %inc, 1
  %and = and i32 %conv2, 1024
  %tobool = icmp ne i32 %and, 0
  %or.cond = and i1 %cmp7, %tobool
  br i1 %or.cond, label %if.then9, label %do.body

if.then9:                                         ; preds = %if.then
  %cmp10 = icmp sle i32 %call, 0
  %cmp12 = icmp sgt i32 %call, 32
  %or.cond1 = or i1 %cmp10, %cmp12
  br i1 %or.cond1, label %if.then14, label %if.end21

if.then14:                                        ; preds = %if.then9
  %and15 = and i32 %conv2, 2048
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.then14
  %call18 = call i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 0)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.then14
  %3 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end21:                                         ; preds = %if.then9
  %add = add nsw i32 %dec, %call
  %len22 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %4 = load i16, i16* %len22, align 4, !tbaa !47
  %conv23 = zext i16 %4 to i32
  %add24 = add nsw i32 %conv23, %call
  %conv25 = trunc i32 %add24 to i16
  store i16 %conv25, i16* %len22, align 4, !tbaa !47
  br label %do.body

do.body:                                          ; preds = %if.end21, %if.then
  %count.1 = phi i32 [ %add, %if.end21 ], [ %dec, %if.then ]
  %5 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp27 = icmp sge i32 %5, 2
  br i1 %cmp27, label %do.body31, label %do.end49

do.body31:                                        ; preds = %do.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @readbytes.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and32 = and i32 %bf.clear, 1
  %tobool33 = icmp ne i32 %and32, 0
  %lnot = xor i1 %tobool33, true
  %lnot34 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot34 to i32
  %conv35 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv35, i64 0)
  %tobool36 = icmp ne i64 %expval, 0
  br i1 %tobool36, label %if.then37, label %do.end49

if.then37:                                        ; preds = %do.body31
  %dev38 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %and39 = and i32 %conv2, 2048
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.then37
  %tobool41 = icmp ne i32 %count.1, 0
  %cond = select i1 %tobool41, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.34, i32 0, i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.then37
  %cond42 = phi i8* [ %cond, %cond.false ], [ getelementptr inbounds ([13 x i8], [13 x i8]* @.str.37, i32 0, i32 0), %if.then37 ]
  %call43 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @readbytes.descriptor to %struct._ddebug*), %struct.device* %dev38, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.36, i32 0, i32 0), i32 %call, i8* %cond42)
  br label %do.end49

do.end49:                                         ; preds = %cond.end, %do.body31, %do.body
  %and50 = and i32 %conv2, 2048
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %if.end58, label %if.then52

if.then52:                                        ; preds = %do.end49
  %call53 = call i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 %count.1)
  %cmp54 = icmp slt i32 %call53, 0
  br i1 %cmp54, label %cleanup, label %if.end58

if.end58:                                         ; preds = %if.then52, %do.end49
  br label %while.cond

cleanup:                                          ; preds = %if.then52, %if.end19, %while.body, %while.cond
  %retval.0 = phi i32 [ -71, %if.end19 ], [ %call53, %if.then52 ], [ %rdcount.0, %while.cond ], [ %rdcount.0, %while.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sendbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #1 {
entry:
  %buf = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 3
  %0 = load i8*, i8** %buf, align 8, !tbaa !53
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %1 = load i16, i16* %len, align 4, !tbaa !47
  %conv = zext i16 %1 to i32
  %flags = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %2 = load i16, i16* %flags, align 2, !tbaa !43
  %conv1 = zext i16 %2 to i32
  %and = and i32 %conv1, 4096
  %conv2 = trunc i32 %and to i16
  br label %while.cond

while.cond:                                       ; preds = %if.then, %entry
  %count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.then ]
  %temp.0 = phi i8* [ %0, %entry ], [ %incdec.ptr, %if.then ]
  %wrcount.0 = phi i32 [ 0, %entry ], [ %inc, %if.then ]
  %cmp = icmp sgt i32 %count.0, 0
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %3 = load i8, i8* %temp.0, align 1, !tbaa !54
  %call = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %3)
  %cmp5 = icmp sgt i32 %call, 0
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %conv7 = zext i16 %conv2 to i32
  %tobool = icmp ne i32 %conv7, 0
  %cmp8 = icmp eq i32 %call, 0
  %or.cond = and i1 %tobool, %cmp8
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %while.body
  %dec = add nsw i32 %count.0, -1
  %incdec.ptr = getelementptr inbounds i8, i8* %temp.0, i32 1
  %inc = add nsw i32 %wrcount.0, 1
  br label %while.cond

if.else:                                          ; preds = %lor.lhs.false
  %cmp10 = icmp eq i32 %call, 0
  br i1 %cmp10, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.else
  %4 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.else14:                                        ; preds = %if.else
  %5 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

cleanup:                                          ; preds = %if.else14, %if.then12, %while.cond
  %retval.0 = phi i32 [ -5, %if.then12 ], [ %call, %if.else14 ], [ %wrcount.0, %while.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @i2c_stop(%struct.i2c_algo_bit_data* %adap) #1 {
entry:
  call void @sdalo(%struct.i2c_algo_bit_data* %adap)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %adap)
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !49
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !50
  call void %0(i8* %1, i32 1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !51
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

declare void @__udelay(i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @scllo(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 2
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !55
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !50
  call void @simpll__indirect_0(i8* %1, i32 0, void (i8*, i32)* %0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !51
  %div = sdiv i32 %2, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sdahi(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !49
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !50
  call void @simpll__indirect_0(i8* %1, i32 1, void (i8*, i32)* %0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !51
  %add = add nsw i32 %2, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sclhi(%struct.i2c_algo_bit_data* %adap) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy5 = alloca i64, align 8
  %__dummy26 = alloca i64, align 8
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 2
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !55
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !50
  call void @simpll__indirect_0(i8* %1, i32 1, void (i8*, i32)* %0)
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %2 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !56
  %tobool = icmp ne i32 (i8*)* %2, null
  br i1 %tobool, label %if.end, label %done

if.end:                                           ; preds = %entry
  %3 = load volatile i64, i64* @jiffies, align 8, !tbaa !57
  br label %while.cond

while.cond:                                       ; preds = %if.end22, %if.end
  %getscl1 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %4 = load i32 (i8*)*, i32 (i8*)** %getscl1, align 8, !tbaa !56
  %data2 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %5 = load i8*, i8** %data2, align 8, !tbaa !50
  %6 = call i32 @simpll__indirect_1(i8* %5, i32 (i8*)* %4)
  %tobool3 = icmp ne i32 %6, 0
  %lnot = xor i1 %tobool3, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = bitcast i64* %__dummy to i8*
  %8 = bitcast i64* %__dummy2 to i8*
  %9 = bitcast i64* %__dummy2 to i8*
  %10 = bitcast i64* %__dummy to i8*
  %tobool4 = icmp ne i32 1, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %while.body
  %11 = bitcast i64* %__dummy5 to i8*
  %12 = bitcast i64* %__dummy26 to i8*
  %13 = bitcast i64* %__dummy26 to i8*
  %14 = bitcast i64* %__dummy5 to i8*
  %timeout = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 8
  %15 = load i32, i32* %timeout, align 4, !tbaa !58
  %conv12 = sext i32 %15 to i64
  %add = add i64 %3, %conv12
  %16 = load volatile i64, i64* @jiffies, align 8, !tbaa !57
  %sub = sub nsw i64 %add, %16
  %cmp13 = icmp slt i64 %sub, 0
  br i1 %cmp13, label %if.then15, label %if.end22

if.then15:                                        ; preds = %land.lhs.true
  %getscl16 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %17 = load i32 (i8*)*, i32 (i8*)** %getscl16, align 8, !tbaa !56
  %data17 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %18 = load i8*, i8** %data17, align 8, !tbaa !50
  %19 = call i32 @simpll__indirect_1(i8* %18, i32 (i8*)* %17)
  %tobool19 = icmp ne i32 %19, 0
  br i1 %tobool19, label %while.end, label %cleanup

if.end22:                                         ; preds = %land.lhs.true, %while.body
  call void @cpu_relax()
  br label %while.cond

while.end:                                        ; preds = %if.then15, %while.cond
  %20 = load volatile i64, i64* @jiffies, align 8, !tbaa !57
  %cmp23 = icmp ne i64 %20, %3
  %21 = load i32, i32* @i2c_debug, align 4
  %cmp26 = icmp sge i32 %21, 3
  %or.cond = and i1 %cmp23, %cmp26
  br i1 %or.cond, label %do.body, label %done

do.body:                                          ; preds = %while.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @sclhi.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool29 = icmp ne i32 %and, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot31 = xor i1 %lnot30, true
  %lnot.ext = zext i1 %lnot31 to i32
  %conv32 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool33 = icmp ne i64 %expval, 0
  br i1 %tobool33, label %if.then34, label %done

if.then34:                                        ; preds = %do.body
  %22 = load volatile i64, i64* @jiffies, align 8, !tbaa !57
  %sub35 = sub i64 %22, %3
  call void (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @sclhi.descriptor to %struct._ddebug*), i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.15, i32 0, i32 0), i64 %sub35)
  br label %done

done:                                             ; preds = %if.then34, %do.body, %while.end, %entry
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %23 = load i32, i32* %udelay, align 8, !tbaa !51
  %conv39 = sext i32 %23 to i64
  call void @__udelay(i64 %conv39)
  br label %cleanup

cleanup:                                          ; preds = %done, %if.then15
  %retval.0 = phi i32 [ 0, %done ], [ -110, %if.then15 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @cpu_relax() #0 {
entry:
  call void @rep_nop()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rep_nop() #0 {
entry:
  call void @simpll__inlineasm_2()
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr, i32 %retries) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  br label %for.cond

for.cond:                                         ; preds = %do.end46, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %do.end46 ]
  %ret.0 = phi i32 [ 0, %entry ], [ %call, %do.end46 ]
  %cmp = icmp sle i32 %i.0, %retries
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr)
  %cmp1 = icmp eq i32 %call, 1
  %cmp2 = icmp eq i32 %i.0, %retries
  %or.cond = or i1 %cmp1, %cmp2
  br i1 %or.cond, label %for.end, label %do.body

do.body:                                          ; preds = %for.body
  %2 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp3 = icmp sge i32 %2, 3
  br i1 %cmp3, label %do.body6, label %do.end16

do.body6:                                         ; preds = %do.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then9, label %do.end16

if.then9:                                         ; preds = %do.body6
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call10 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14, i32 0, i32 0))
  br label %do.end16

do.end16:                                         ; preds = %if.then9, %do.body6, %do.body
  call void @i2c_stop(%struct.i2c_algo_bit_data* %1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %3 = load i32, i32* %udelay, align 8, !tbaa !51
  %conv17 = sext i32 %3 to i64
  call void @__udelay(i64 %conv17)
  call void @yield()
  %4 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp19 = icmp sge i32 %4, 3
  br i1 %cmp19, label %do.body23, label %do.end46

do.body23:                                        ; preds = %do.end16
  %bf.load24 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor.21 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr25 = lshr i32 %bf.load24, 18
  %bf.clear26 = and i32 %bf.lshr25, 255
  %and27 = and i32 %bf.clear26, 1
  %tobool28 = icmp ne i32 %and27, 0
  %lnot29 = xor i1 %tobool28, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  %expval34 = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool35 = icmp ne i64 %expval34, 0
  br i1 %tobool35, label %if.then36, label %do.end46

if.then36:                                        ; preds = %do.body23
  %dev37 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call38 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor.21 to %struct._ddebug*), %struct.device* %dev37, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0))
  br label %do.end46

do.end46:                                         ; preds = %if.then36, %do.body23, %do.end16
  call void @i2c_start(%struct.i2c_algo_bit_data* %1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %ret.1 = phi i32 [ %call, %for.body ], [ %ret.0, %for.cond ]
  %tobool47 = icmp ne i32 %i.0, 0
  %tobool48 = icmp ne i32 %ret.1, 0
  %or.cond1 = and i1 %tobool47, %tobool48
  %5 = load i32, i32* @i2c_debug, align 4
  %cmp51 = icmp sge i32 %5, 1
  %or.cond2 = and i1 %or.cond1, %cmp51
  br i1 %or.cond2, label %do.body55, label %if.end86

do.body55:                                        ; preds = %for.end
  %bf.load56 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor.22 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr57 = lshr i32 %bf.load56, 18
  %bf.clear58 = and i32 %bf.lshr57, 255
  %and59 = and i32 %bf.clear58, 1
  %tobool60 = icmp ne i32 %and59, 0
  %lnot61 = xor i1 %tobool60, true
  %lnot63 = xor i1 %lnot61, true
  %lnot.ext64 = zext i1 %lnot63 to i32
  %conv65 = sext i32 %lnot.ext64 to i64
  %expval66 = call i64 @llvm.expect.i64(i64 %conv65, i64 0)
  %tobool67 = icmp ne i64 %expval66, 0
  br i1 %tobool67, label %if.then68, label %if.end86

if.then68:                                        ; preds = %do.body55
  %dev69 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %add = add nsw i32 %i.0, 1
  %conv70 = zext i8 %addr to i32
  %and71 = and i32 %conv70, 1
  %tobool72 = icmp ne i32 %and71, 0
  %cond = select i1 %tobool72, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.25, i32 0, i32 0)
  %conv73 = zext i8 %addr to i32
  %shr = ashr i32 %conv73, 1
  %cmp74 = icmp eq i32 %ret.1, 1
  %cond76 = select i1 %cmp74, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)
  %call77 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor.22 to %struct._ddebug*), %struct.device* %dev69, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.23, i32 0, i32 0), i32 %add, i8* %cond, i32 %shr, i8* %cond76)
  br label %if.end86

if.end86:                                         ; preds = %if.then68, %do.body55, %for.end
  ret i32 %ret.1
}

declare i32 @dev_err(%struct.device*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %c) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  br label %for.cond

for.cond:                                         ; preds = %if.end21, %entry
  %i.0 = phi i32 [ 7, %entry ], [ %dec, %if.end21 ]
  %cmp = icmp sge i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %conv = zext i8 %c to i32
  %shr = ashr i32 %conv, %i.0
  %and = and i32 %shr, 1
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 1
  %2 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !49
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %3 = load i8*, i8** %data, align 8, !tbaa !50
  call void %2(i8* %3, i32 %and)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %4 = load i32, i32* %udelay, align 8, !tbaa !51
  %add = add nsw i32 %4, 1
  %div = sdiv i32 %add, 2
  %conv1 = sext i32 %div to i64
  call void @__udelay(i64 %conv1)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %do.body, label %if.end21

do.body:                                          ; preds = %for.body
  %5 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp4 = icmp sge i32 %5, 1
  br i1 %cmp4, label %do.body8, label %cleanup

do.body8:                                         ; preds = %do.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and9 = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and9, 0
  %lnot = xor i1 %tobool, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %cleanup

if.then13:                                        ; preds = %do.body8
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %conv14 = zext i8 %c to i32
  %call15 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.28, i32 0, i32 0), i32 %conv14, i32 %i.0)
  br label %cleanup

if.end21:                                         ; preds = %for.body
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  %dec = add nsw i32 %i.0, -1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %call22 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp23 = icmp slt i32 %call22, 0
  br i1 %cmp23, label %do.body26, label %if.end56

do.body26:                                        ; preds = %for.end
  %6 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp27 = icmp sge i32 %6, 1
  br i1 %cmp27, label %do.body31, label %cleanup

do.body31:                                        ; preds = %do.body26
  %bf.load32 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor.29 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr33 = lshr i32 %bf.load32, 18
  %bf.clear34 = and i32 %bf.lshr33, 255
  %and35 = and i32 %bf.clear34, 1
  %tobool36 = icmp ne i32 %and35, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %expval42 = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %tobool43 = icmp ne i64 %expval42, 0
  br i1 %tobool43, label %if.then44, label %cleanup

if.then44:                                        ; preds = %do.body31
  %dev45 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %conv46 = zext i8 %c to i32
  %call47 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor.29 to %struct._ddebug*), %struct.device* %dev45, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.30, i32 0, i32 0), i32 %conv46)
  br label %cleanup

if.end56:                                         ; preds = %for.end
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %7 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !59
  %data57 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %8 = load i8*, i8** %data57, align 8, !tbaa !50
  %call58 = call i32 %7(i8* %8)
  %tobool59 = icmp ne i32 %call58, 0
  %lnot60 = xor i1 %tobool59, true
  %lnot.ext61 = zext i1 %lnot60 to i32
  %9 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp63 = icmp sge i32 %9, 2
  br i1 %cmp63, label %do.body67, label %do.end92

do.body67:                                        ; preds = %if.end56
  %bf.load68 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor.31 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr69 = lshr i32 %bf.load68, 18
  %bf.clear70 = and i32 %bf.lshr69, 255
  %and71 = and i32 %bf.clear70, 1
  %tobool72 = icmp ne i32 %and71, 0
  %lnot73 = xor i1 %tobool72, true
  %lnot75 = xor i1 %lnot73, true
  %lnot.ext76 = zext i1 %lnot75 to i32
  %conv77 = sext i32 %lnot.ext76 to i64
  %expval78 = call i64 @llvm.expect.i64(i64 %conv77, i64 0)
  %tobool79 = icmp ne i64 %expval78, 0
  br i1 %tobool79, label %if.then80, label %do.end92

if.then80:                                        ; preds = %do.body67
  %dev81 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %conv82 = zext i8 %c to i32
  %tobool83 = icmp ne i32 %lnot.ext61, 0
  %cond = select i1 %tobool83, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.34, i32 0, i32 0)
  %call84 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor.31 to %struct._ddebug*), %struct.device* %dev81, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.32, i32 0, i32 0), i32 %conv82, i8* %cond)
  br label %do.end92

do.end92:                                         ; preds = %if.then80, %do.body67, %if.end56
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  br label %cleanup

cleanup:                                          ; preds = %do.end92, %if.then44, %do.body31, %do.body26, %if.then13, %do.body8, %do.body
  %retval.0 = phi i32 [ %lnot.ext61, %do.end92 ], [ -110, %do.body8 ], [ -110, %if.then13 ], [ -110, %do.body ], [ -110, %do.body31 ], [ -110, %if.then44 ], [ -110, %do.body26 ]
  ret i32 %retval.0
}

declare void @yield() #2

; Function Attrs: nounwind uwtable
define internal i32 @i2c_inb(%struct.i2c_adapter* %i2c_adap) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  br label %for.cond

for.cond:                                         ; preds = %if.end15, %entry
  %indata.0 = phi i8 [ 0, %entry ], [ %indata.1, %if.end15 ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end15 ]
  %cmp = icmp slt i32 %i.0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %do.body, label %if.end15

do.body:                                          ; preds = %for.body
  %2 = load i32, i32* @i2c_debug, align 4, !tbaa !42
  %cmp2 = icmp sge i32 %2, 1
  br i1 %cmp2, label %do.body5, label %cleanup

do.body5:                                         ; preds = %do.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_inb.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then8, label %cleanup

if.then8:                                         ; preds = %do.body5
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %sub = sub nsw i32 7, %i.0
  %call9 = call i32 (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_inb.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.38, i32 0, i32 0), i32 %sub)
  br label %cleanup

if.end15:                                         ; preds = %for.body
  %conv16 = zext i8 %indata.0 to i32
  %mul = mul nsw i32 %conv16, 2
  %conv17 = trunc i32 %mul to i8
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %3 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !59
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %4 = load i8*, i8** %data, align 8, !tbaa !50
  %call18 = call i32 %3(i8* %4)
  %tobool19 = icmp ne i32 %call18, 0
  %conv21 = zext i8 %conv17 to i32
  %or = or i32 %conv21, 1
  %conv22 = trunc i32 %or to i8
  %indata.1 = select i1 %tobool19, i8 %conv22, i8 %conv17
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 2
  %5 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !55
  %data24 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %6 = load i8*, i8** %data24, align 8, !tbaa !50
  call void %5(i8* %6, i32 0)
  %cmp25 = icmp eq i32 %i.0, 7
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %7 = load i32, i32* %udelay, align 8, !tbaa !51
  %div = sdiv i32 %7, 2
  %cond = select i1 %cmp25, i32 %div, i32 %7
  %conv28 = sext i32 %cond to i64
  call void @__udelay(i64 %conv28)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %conv29 = zext i8 %indata.0 to i32
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then8, %do.body5, %do.body
  %retval.0 = phi i32 [ %conv29, %for.end ], [ -110, %do.body5 ], [ -110, %if.then8 ], [ -110, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 %is_ack) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %tobool = icmp ne i32 %is_ack, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 1
  %2 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !49
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %3 = load i8*, i8** %data, align 8, !tbaa !50
  call void %2(i8* %3, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %4 = load i32, i32* %udelay, align 8, !tbaa !51
  %add = add nsw i32 %4, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %5 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* null, i8* null)
  br label %cleanup

if.end4:                                          ; preds = %if.end
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.then2
  %retval.0 = phi i32 [ -110, %if.then2 ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sdalo(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !49
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !50
  call void @simpll__indirect_0(i8* %1, i32 0, void (i8*, i32)* %0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !51
  %add = add nsw i32 %2, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @test_bus(%struct.i2c_adapter* %i2c_adap) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %pre_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %2 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer, align 8, !tbaa !40
  %tobool = icmp ne i32 (%struct.i2c_adapter*)* %2, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %pre_xfer2 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %3 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer2, align 8, !tbaa !40
  %4 = call i32 @simpll__indirect_3(%struct.i2c_adapter* %i2c_adap, i32 (%struct.i2c_adapter*)* %3)
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.then, %entry
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %5 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !56
  %cmp5 = icmp eq i32 (i8*)* %5, null
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  call void (i8*, ...) @printk(i8* null)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %6 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !59
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %7 = load i8*, i8** %data, align 8, !tbaa !50
  %8 = call i32 @simpll__indirect_1(i8* %7, i32 (i8*)* %6)
  %getscl10 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %9 = load i32 (i8*)*, i32 (i8*)** %getscl10, align 8, !tbaa !56
  %cmp11 = icmp eq i32 (i8*)* %9, null
  br i1 %cmp11, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end8
  %getscl12 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %10 = load i32 (i8*)*, i32 (i8*)** %getscl12, align 8, !tbaa !56
  %data13 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %11 = load i8*, i8** %data13, align 8, !tbaa !50
  %12 = call i32 @simpll__indirect_1(i8* %11, i32 (i8*)* %10)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end8
  %cond = phi i32 [ %12, %cond.false ], [ 1, %if.end8 ]
  %tobool15 = icmp ne i32 %cond, 0
  %tobool16 = icmp ne i32 %8, 0
  %or.cond = and i1 %tobool15, %tobool16
  br i1 %or.cond, label %if.end19, label %if.then17

if.then17:                                        ; preds = %cond.end
  call void (i8*, ...) @printk(i8* null)
  br label %bailout

if.end19:                                         ; preds = %cond.end
  call void @sdalo(%struct.i2c_algo_bit_data* %1)
  %getsda20 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %13 = load i32 (i8*)*, i32 (i8*)** %getsda20, align 8, !tbaa !59
  %data21 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %14 = load i8*, i8** %data21, align 8, !tbaa !50
  %15 = call i32 @simpll__indirect_1(i8* %14, i32 (i8*)* %13)
  %getscl23 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %16 = load i32 (i8*)*, i32 (i8*)** %getscl23, align 8, !tbaa !56
  %cmp24 = icmp eq i32 (i8*)* %16, null
  br i1 %cmp24, label %cond.end30, label %cond.false26

cond.false26:                                     ; preds = %if.end19
  %getscl27 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %17 = load i32 (i8*)*, i32 (i8*)** %getscl27, align 8, !tbaa !56
  %data28 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %18 = load i8*, i8** %data28, align 8, !tbaa !50
  %19 = call i32 @simpll__indirect_1(i8* %18, i32 (i8*)* %17)
  br label %cond.end30

cond.end30:                                       ; preds = %cond.false26, %if.end19
  %cond31 = phi i32 [ %19, %cond.false26 ], [ 1, %if.end19 ]
  %tobool32 = icmp ne i32 %15, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %cond.end30
  call void (i8*, ...) @printk(i8* null)
  br label %bailout

if.end35:                                         ; preds = %cond.end30
  %tobool36 = icmp ne i32 %cond31, 0
  br i1 %tobool36, label %if.end39, label %if.then37

if.then37:                                        ; preds = %if.end35
  call void (i8*, ...) @printk(i8* null)
  br label %bailout

if.end39:                                         ; preds = %if.end35
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %getsda40 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %20 = load i32 (i8*)*, i32 (i8*)** %getsda40, align 8, !tbaa !59
  %data41 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %21 = load i8*, i8** %data41, align 8, !tbaa !50
  %22 = call i32 @simpll__indirect_1(i8* %21, i32 (i8*)* %20)
  %getscl43 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %23 = load i32 (i8*)*, i32 (i8*)** %getscl43, align 8, !tbaa !56
  %cmp44 = icmp eq i32 (i8*)* %23, null
  br i1 %cmp44, label %cond.end50, label %cond.false46

cond.false46:                                     ; preds = %if.end39
  %getscl47 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %24 = load i32 (i8*)*, i32 (i8*)** %getscl47, align 8, !tbaa !56
  %data48 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %25 = load i8*, i8** %data48, align 8, !tbaa !50
  %26 = call i32 @simpll__indirect_1(i8* %25, i32 (i8*)* %24)
  br label %cond.end50

cond.end50:                                       ; preds = %cond.false46, %if.end39
  %cond51 = phi i32 [ %26, %cond.false46 ], [ 1, %if.end39 ]
  %tobool52 = icmp ne i32 %22, 0
  br i1 %tobool52, label %if.end55, label %if.then53

if.then53:                                        ; preds = %cond.end50
  call void (i8*, ...) @printk(i8* null)
  br label %bailout

if.end55:                                         ; preds = %cond.end50
  %tobool56 = icmp ne i32 %cond51, 0
  br i1 %tobool56, label %if.end59, label %if.then57

if.then57:                                        ; preds = %if.end55
  call void (i8*, ...) @printk(i8* null)
  br label %bailout

if.end59:                                         ; preds = %if.end55
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  %getsda60 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %27 = load i32 (i8*)*, i32 (i8*)** %getsda60, align 8, !tbaa !59
  %data61 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %28 = load i8*, i8** %data61, align 8, !tbaa !50
  %29 = call i32 @simpll__indirect_1(i8* %28, i32 (i8*)* %27)
  %getscl63 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %30 = load i32 (i8*)*, i32 (i8*)** %getscl63, align 8, !tbaa !56
  %cmp64 = icmp eq i32 (i8*)* %30, null
  br i1 %cmp64, label %cond.end70, label %cond.false66

cond.false66:                                     ; preds = %if.end59
  %getscl67 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %31 = load i32 (i8*)*, i32 (i8*)** %getscl67, align 8, !tbaa !56
  %data68 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %32 = load i8*, i8** %data68, align 8, !tbaa !50
  %33 = call i32 @simpll__indirect_1(i8* %32, i32 (i8*)* %31)
  br label %cond.end70

cond.end70:                                       ; preds = %cond.false66, %if.end59
  %cond71 = phi i32 [ %33, %cond.false66 ], [ 0, %if.end59 ]
  %tobool72 = icmp ne i32 %cond71, 0
  br i1 %tobool72, label %if.then73, label %if.end75

if.then73:                                        ; preds = %cond.end70
  call void (i8*, ...) @printk(i8* null)
  br label %bailout

if.end75:                                         ; preds = %cond.end70
  %tobool76 = icmp ne i32 %29, 0
  br i1 %tobool76, label %if.end79, label %if.then77

if.then77:                                        ; preds = %if.end75
  call void (i8*, ...) @printk(i8* null)
  br label %bailout

if.end79:                                         ; preds = %if.end75
  %call80 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %getsda81 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %34 = load i32 (i8*)*, i32 (i8*)** %getsda81, align 8, !tbaa !59
  %data82 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %35 = load i8*, i8** %data82, align 8, !tbaa !50
  %36 = call i32 @simpll__indirect_1(i8* %35, i32 (i8*)* %34)
  %getscl84 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %37 = load i32 (i8*)*, i32 (i8*)** %getscl84, align 8, !tbaa !56
  %cmp85 = icmp eq i32 (i8*)* %37, null
  br i1 %cmp85, label %cond.end91, label %cond.false87

cond.false87:                                     ; preds = %if.end79
  %getscl88 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %38 = load i32 (i8*)*, i32 (i8*)** %getscl88, align 8, !tbaa !56
  %data89 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %39 = load i8*, i8** %data89, align 8, !tbaa !50
  %40 = call i32 @simpll__indirect_1(i8* %39, i32 (i8*)* %38)
  br label %cond.end91

cond.end91:                                       ; preds = %cond.false87, %if.end79
  %cond92 = phi i32 [ %40, %cond.false87 ], [ 1, %if.end79 ]
  %tobool93 = icmp ne i32 %cond92, 0
  br i1 %tobool93, label %if.end96, label %if.then94

if.then94:                                        ; preds = %cond.end91
  call void (i8*, ...) @printk(i8* null)
  br label %bailout

if.end96:                                         ; preds = %cond.end91
  %tobool97 = icmp ne i32 %36, 0
  br i1 %tobool97, label %if.end100, label %if.then98

if.then98:                                        ; preds = %if.end96
  call void (i8*, ...) @printk(i8* null)
  br label %bailout

if.end100:                                        ; preds = %if.end96
  %post_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %41 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer, align 8, !tbaa !48
  %tobool101 = icmp ne void (%struct.i2c_adapter*)* %41, null
  br i1 %tobool101, label %if.then102, label %if.end104

if.then102:                                       ; preds = %if.end100
  %post_xfer103 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %42 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer103, align 8, !tbaa !48
  call void @simpll__indirect_4(%struct.i2c_adapter* %i2c_adap, void (%struct.i2c_adapter*)* %42)
  br label %if.end104

if.end104:                                        ; preds = %if.then102, %if.end100
  call void (i8*, ...) @printk(i8* null)
  br label %cleanup

bailout:                                          ; preds = %if.then98, %if.then94, %if.then77, %if.then73, %if.then57, %if.then53, %if.then37, %if.then33, %if.then17
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %call106 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %post_xfer107 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %43 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer107, align 8, !tbaa !48
  %tobool108 = icmp ne void (%struct.i2c_adapter*)* %43, null
  br i1 %tobool108, label %if.then109, label %cleanup

if.then109:                                       ; preds = %bailout
  %post_xfer110 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %44 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer110, align 8, !tbaa !48
  call void @simpll__indirect_4(%struct.i2c_adapter* %i2c_adap, void (%struct.i2c_adapter*)* %44)
  br label %cleanup

cleanup:                                          ; preds = %if.then109, %bailout, %if.end104, %if.then
  %retval.0 = phi i32 [ 0, %if.end104 ], [ -19, %if.then ], [ -19, %if.then109 ], [ -19, %bailout ]
  ret void
}

declare i32 @dev_warn(%struct.device*, i8*, ...) #2

declare void @__dynamic_pr_debug(%struct._ddebug*, i8*, ...) #2

declare void @printk(i8*, ...) #2

declare void @simpll__indirect_0(i8*, i32, void (i8*, i32)*)

declare i32 @simpll__indirect_1(i8*, i32 (i8*)*)

declare void @simpll__inlineasm_2()

declare i32 @simpll__indirect_3(%struct.i2c_adapter*, i32 (%struct.i2c_adapter*)*)

declare void @simpll__indirect_4(%struct.i2c_adapter*, void (%struct.i2c_adapter*)*)

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind readnone }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !4, i64 24}
!13 = !{!"i2c_adapter", !4, i64 0, !14, i64 8, !4, i64 16, !4, i64 24, !15, i64 32, !14, i64 168, !14, i64 172, !22, i64 176, !14, i64 1312, !5, i64 1316, !31, i64 1368, !26, i64 1464, !21, i64 1632, !4, i64 1648}
!14 = !{!"int", !5, i64 0}
!15 = !{!"rt_mutex", !16, i64 0, !20, i64 72, !4, i64 88, !14, i64 96, !4, i64 104, !4, i64 112, !14, i64 120, !4, i64 128}
!16 = !{!"raw_spinlock", !17, i64 0, !14, i64 4, !14, i64 8, !4, i64 16, !18, i64 24}
!17 = !{!"arch_spinlock", !5, i64 0}
!18 = !{!"lockdep_map", !4, i64 0, !5, i64 8, !4, i64 24, !14, i64 32, !19, i64 40}
!19 = !{!"long", !5, i64 0}
!20 = !{!"plist_head", !21, i64 0}
!21 = !{!"list_head", !4, i64 0, !4, i64 8}
!22 = !{!"device", !4, i64 0, !4, i64 8, !23, i64 16, !4, i64 80, !4, i64 88, !26, i64 96, !4, i64 264, !4, i64 272, !4, i64 280, !28, i64 288, !4, i64 880, !14, i64 888, !4, i64 896, !36, i64 904, !4, i64 912, !21, i64 920, !4, i64 936, !37, i64 944, !4, i64 960, !38, i64 968, !14, i64 976, !14, i64 980, !27, i64 984, !21, i64 1056, !39, i64 1072, !4, i64 1104, !4, i64 1112, !4, i64 1120, !4, i64 1128}
!23 = !{!"kobject", !4, i64 0, !21, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !24, i64 56, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60}
!24 = !{!"kref", !25, i64 0}
!25 = !{!"", !14, i64 0}
!26 = !{!"mutex", !25, i64 0, !27, i64 8, !21, i64 80, !4, i64 96, !4, i64 104, !4, i64 112, !18, i64 120}
!27 = !{!"spinlock", !5, i64 0}
!28 = !{!"dev_pm_info", !29, i64 0, !14, i64 4, !14, i64 4, !30, i64 4, !30, i64 4, !30, i64 4, !30, i64 4, !27, i64 8, !21, i64 80, !31, i64 96, !4, i64 192, !30, i64 200, !30, i64 200, !33, i64 208, !19, i64 336, !34, i64 344, !32, i64 424, !25, i64 512, !25, i64 516, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 520, !14, i64 521, !14, i64 521, !14, i64 521, !14, i64 521, !14, i64 521, !5, i64 524, !5, i64 528, !14, i64 532, !14, i64 536, !19, i64 544, !19, i64 552, !19, i64 560, !19, i64 568, !4, i64 576, !4, i64 584}
!29 = !{!"pm_message", !14, i64 0}
!30 = !{!"_Bool", !5, i64 0}
!31 = !{!"completion", !14, i64 0, !32, i64 8}
!32 = !{!"__wait_queue_head", !27, i64 0, !21, i64 72}
!33 = !{!"timer_list", !21, i64 0, !19, i64 16, !4, i64 24, !4, i64 32, !19, i64 40, !14, i64 48, !14, i64 52, !4, i64 56, !5, i64 64, !18, i64 80}
!34 = !{!"work_struct", !35, i64 0, !21, i64 8, !4, i64 24, !18, i64 32}
!35 = !{!"", !19, i64 0}
!36 = !{!"long long", !5, i64 0}
!37 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!38 = !{!"acpi_dev_node", !4, i64 0}
!39 = !{!"klist_node", !4, i64 0, !21, i64 8, !24, i64 24}
!40 = !{!41, !4, i64 40}
!41 = !{!"i2c_algo_bit_data", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !14, i64 56, !14, i64 60}
!42 = !{!14, !14, i64 0}
!43 = !{!44, !45, i64 2}
!44 = !{!"i2c_msg", !45, i64 0, !45, i64 2, !45, i64 4, !4, i64 8}
!45 = !{!"short", !5, i64 0}
!46 = !{!44, !45, i64 0}
!47 = !{!44, !45, i64 4}
!48 = !{!41, !4, i64 48}
!49 = !{!41, !4, i64 8}
!50 = !{!41, !4, i64 0}
!51 = !{!41, !14, i64 56}
!52 = !{!13, !14, i64 172}
!53 = !{!44, !4, i64 8}
!54 = !{!5, !5, i64 0}
!55 = !{!41, !4, i64 16}
!56 = !{!41, !4, i64 32}
!57 = !{!19, !19, i64 0}
!58 = !{!41, !14, i64 60}
!59 = !{!41, !4, i64 24}
