; ModuleID = 'drivers/memstick/core/memstick.bc'
source_filename = "drivers/memstick/core/memstick.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon }
%union.anon = type { i8* }
%struct.workqueue_struct = type opaque
%struct.kernel_symbol = type { i64, i8* }
%struct.lock_class_key = type {}
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i16 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.exception_table_entry = type opaque
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.task_struct = type opaque
%struct.module_ref = type { i64, i64 }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%union.ktime = type { i64 }
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.list_head }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.22, %struct.list_head, %struct.hlist_node }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [28 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.5, %union.anon.11, %union.anon.13, [8 x i8] }
%struct.anon.5 = type { %union.anon.6, %union.anon.7 }
%union.anon.6 = type { i64 }
%union.anon.7 = type { i64 }
%union.anon.11 = type { %struct.list_head }
%union.anon.13 = type { i64 }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.14, i32 }
%union.anon.14 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%union.anon.22 = type { %struct.list_head }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.15, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.16, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.21, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.15 = type { i32 }
%struct.timespec = type { i64, i64 }
%union.anon.16 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.19 }
%struct.files_struct = type opaque
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.19 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.rb_root = type { %struct.rb_node* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.4, i32 }
%union.anon.4 = type { i8* }
%struct.swap_info_struct = type opaque
%union.anon.21 = type { %struct.pipe_inode_info* }
%struct.pipe_inode_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type opaque
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon.17, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.file*, %struct.uprobes_state }
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.cpumask = type { [1 x i64] }
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.uprobes_state = type {}
%struct.pgprot = type { i64 }
%union.anon.17 = type { %struct.anon.18 }
%struct.anon.18 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.nodemask_t = type { [1 x i64] }
%struct.mempolicy = type opaque
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t }
%union.arch_rwlock_t = type { i32 }
%struct.cred = type opaque
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.subsys_private = type opaque
%struct.idr = type { %struct.idr_layer*, %struct.idr_layer*, %struct.idr_layer*, i32, i32, i32, %struct.spinlock }
%struct.idr_layer = type { i32, [4 x i64], [256 x %struct.idr_layer*], i32, i32, %struct.callback_head }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.memstick_host = type { %struct.mutex, i32, i32, %struct.work_struct, %struct.device, %struct.memstick_dev*, i32, {}*, i32 (%struct.memstick_host*, i32, i32)*, [24 x i8], [0 x i64] }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.memstick_dev = type { %struct.memstick_device_id, %struct.memstick_host*, %struct.ms_register_addr, %struct.completion, %struct.memstick_request, i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*, %struct.memstick_request**)*, void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)*, %struct.device }
%struct.memstick_device_id = type { i8, i8, i8, i8 }
%struct.ms_register_addr = type { i8, i8, i8, i8 }
%struct.memstick_request = type { i8, i8, i8, i32, %union.anon.23 }
%union.anon.23 = type { %struct.scatterlist }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.anon.24 = type { i8, [15 x i8] }
%struct.memstick_driver = type { %struct.memstick_device_id*, i32 (%struct.memstick_dev*)*, void (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*, i32)*, i32 (%struct.memstick_dev*)*, %struct.device_driver }
%struct.ms_id_register = type { i8, i8, i8, i8 }
%struct.__raw_tickets = type { i8, i8 }

@__param_str_cmd_retries = internal constant [21 x i8] c"memstick.cmd_retries\00", align 16
@param_ops_uint = external global %struct.kernel_param_ops, align 8
@cmd_retries = internal global i32 3, align 4
@__param_cmd_retries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__param_str_cmd_retries, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_uint, i16 420, i16 -1, %union.anon { i8* bitcast (i32* @cmd_retries to i8*) } }, section "__param", align 8
@workqueue = internal global %struct.workqueue_struct* null, align 8
@__kstrtab_memstick_detect_change = internal constant [23 x i8] c"memstick_detect_change\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_detect_change = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_detect_change to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_memstick_detect_change, i32 0, i32 0) }, section "___ksymtab+memstick_detect_change", align 8
@__kstrtab_memstick_next_req = internal constant [18 x i8] c"memstick_next_req\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_next_req = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.memstick_host*, %struct.memstick_request**)* @memstick_next_req to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_memstick_next_req, i32 0, i32 0) }, section "___ksymtab+memstick_next_req", align 8
@__kstrtab_memstick_new_req = internal constant [17 x i8] c"memstick_new_req\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_new_req = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_new_req to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_memstick_new_req, i32 0, i32 0) }, section "___ksymtab+memstick_new_req", align 8
@__kstrtab_memstick_init_req_sg = internal constant [21 x i8] c"memstick_init_req_sg\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_init_req_sg = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_request*, i8, %struct.scatterlist*)* @memstick_init_req_sg to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_memstick_init_req_sg, i32 0, i32 0) }, section "___ksymtab+memstick_init_req_sg", align 8
@__kstrtab_memstick_init_req = internal constant [18 x i8] c"memstick_init_req\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_init_req = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_request*, i8, i8*, i64)* @memstick_init_req to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_memstick_init_req, i32 0, i32 0) }, section "___ksymtab+memstick_init_req", align 8
@__kstrtab_memstick_set_rw_addr = internal constant [21 x i8] c"memstick_set_rw_addr\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_set_rw_addr = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.memstick_dev*)* @memstick_set_rw_addr to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_memstick_set_rw_addr, i32 0, i32 0) }, section "___ksymtab+memstick_set_rw_addr", align 8
@memstick_alloc_host.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str = private unnamed_addr constant [12 x i8] c"&host->lock\00", align 1
@memstick_host_class = internal global %struct.class { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.4, i32 0, i32 0), %struct.module* null, %struct.class_attribute* null, %struct.device_attribute* null, %struct.bin_attribute* null, %struct.kobject* null, i32 (%struct.device*, %struct.kobj_uevent_env*)* null, i8* (%struct.device*, i16*)* null, void (%struct.class*)* null, void (%struct.device*)* @memstick_free, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.kobj_ns_type_operations* null, i8* (%struct.device*)* null, %struct.dev_pm_ops* null, %struct.subsys_private* null }, align 8
@__kstrtab_memstick_alloc_host = internal constant [20 x i8] c"memstick_alloc_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_alloc_host = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.memstick_host* (i32, %struct.device*)* @memstick_alloc_host to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_memstick_alloc_host, i32 0, i32 0) }, section "___ksymtab+memstick_alloc_host", align 8
@memstick_host_lock = internal global %struct.spinlock zeroinitializer, align 2
@memstick_host_idr = internal global %struct.idr zeroinitializer, align 8
@.str.1 = private unnamed_addr constant [11 x i8] c"memstick%u\00", align 1
@__kstrtab_memstick_add_host = internal constant [18 x i8] c"memstick_add_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_add_host = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.memstick_host*)* @memstick_add_host to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_memstick_add_host, i32 0, i32 0) }, section "___ksymtab+memstick_add_host", align 8
@__kstrtab_memstick_remove_host = internal constant [21 x i8] c"memstick_remove_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_remove_host = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_remove_host to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_memstick_remove_host, i32 0, i32 0) }, section "___ksymtab+memstick_remove_host", align 8
@__kstrtab_memstick_free_host = internal constant [19 x i8] c"memstick_free_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_free_host = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_free_host to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_memstick_free_host, i32 0, i32 0) }, section "___ksymtab+memstick_free_host", align 8
@__kstrtab_memstick_suspend_host = internal constant [22 x i8] c"memstick_suspend_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_suspend_host = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_suspend_host to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_memstick_suspend_host, i32 0, i32 0) }, section "___ksymtab+memstick_suspend_host", align 8
@__kstrtab_memstick_resume_host = internal constant [21 x i8] c"memstick_resume_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_resume_host = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_resume_host to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_memstick_resume_host, i32 0, i32 0) }, section "___ksymtab+memstick_resume_host", align 8
@memstick_bus_type = internal global %struct.bus_type { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.5, i32 0, i32 0), i8* null, %struct.device* null, %struct.bus_attribute* null, %struct.device_attribute* getelementptr inbounds ([4 x %struct.device_attribute], [4 x %struct.device_attribute]* @memstick_dev_attrs, i32 0, i32 0), %struct.driver_attribute* null, i32 (%struct.device*, %struct.device_driver*)* @memstick_bus_match, i32 (%struct.device*, %struct.kobj_uevent_env*)* @memstick_uevent, i32 (%struct.device*)* @memstick_device_probe, i32 (%struct.device*)* @memstick_device_remove, void (%struct.device*)* null, i32 (%struct.device*, i32)* @memstick_device_suspend, i32 (%struct.device*)* @memstick_device_resume, %struct.dev_pm_ops* null, %struct.iommu_ops* null, %struct.subsys_private* null, %struct.lock_class_key zeroinitializer }, align 8
@__kstrtab_memstick_register_driver = internal constant [25 x i8] c"memstick_register_driver\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_register_driver = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.memstick_driver*)* @memstick_register_driver to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_memstick_register_driver, i32 0, i32 0) }, section "___ksymtab+memstick_register_driver", align 8
@__kstrtab_memstick_unregister_driver = internal constant [27 x i8] c"memstick_unregister_driver\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_unregister_driver = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_driver*)* @memstick_unregister_driver to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_memstick_unregister_driver, i32 0, i32 0) }, section "___ksymtab+memstick_unregister_driver", align 8
@__initcall_memstick_init6 = internal global i32 ()* @memstick_init, section ".initcall6.init", align 8
@__exitcall_memstick_exit = internal global void ()* @memstick_exit, section ".exitcall.exit", align 8
@smp_ops = external global %struct.smp_ops, align 8
@.str.2 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@init_completion.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.3 = private unnamed_addr constant [9 x i8] c"&x->wait\00", align 1
@.str.4 = private unnamed_addr constant [14 x i8] c"memstick_host\00", align 1
@.str.5 = private unnamed_addr constant [9 x i8] c"memstick\00", align 1
@memstick_dev_attrs = internal global [4 x %struct.device_attribute] [%struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.6, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @type_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.7, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @category_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.8, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @class_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute zeroinitializer], align 16
@.str.6 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.7 = private unnamed_addr constant [9 x i8] c"category\00", align 1
@.str.8 = private unnamed_addr constant [6 x i8] c"class\00", align 1
@.str.9 = private unnamed_addr constant [5 x i8] c"%02X\00", align 1
@.str.10 = private unnamed_addr constant [19 x i8] c"MEMSTICK_TYPE=%02X\00", align 1
@.str.11 = private unnamed_addr constant [23 x i8] c"MEMSTICK_CATEGORY=%02X\00", align 1
@.str.12 = private unnamed_addr constant [20 x i8] c"MEMSTICK_CLASS=%02X\00", align 1
@.str.13 = private unnamed_addr constant [10 x i8] c"kmemstick\00", align 1
@memstick_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@llvm.used = appending global [18 x i8*] [i8* bitcast (%struct.kernel_param* @__param_cmd_retries to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_detect_change to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_next_req to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_new_req to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_init_req_sg to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_init_req to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_set_rw_addr to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_alloc_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_add_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_remove_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_free_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_suspend_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_resume_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_register_driver to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_unregister_driver to i8*), i8* bitcast (void ()* @memstick_exit to i8*), i8* bitcast (i32 ()** @__initcall_memstick_init6 to i8*), i8* bitcast (void ()** @__exitcall_memstick_exit to i8*)], section "llvm.metadata"

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: nounwind uwtable
define void @memstick_detect_change(%struct.memstick_host* %host) #1 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @workqueue, align 8, !tbaa !12
  %media_checker = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 3
  %call = call zeroext i1 @queue_work(%struct.workqueue_struct* %0, %struct.work_struct* %media_checker)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @queue_work(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #0 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 64, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define i32 @memstick_next_req(%struct.memstick_host* %host, %struct.memstick_request** %mrq) #1 {
entry:
  %0 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !12
  %tobool = icmp ne %struct.memstick_request* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !12
  %error = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %1, i32 0, i32 3
  %2 = load i32, i32* %error, align 4, !tbaa !13
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %retries = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 6
  %3 = load i32, i32* %retries, align 16, !tbaa !16
  %tobool3 = icmp ne i32 %3, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true2
  %4 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !12
  %error4 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %4, i32 0, i32 3
  store i32 -6, i32* %error4, align 4, !tbaa !13
  %retries5 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 6
  %5 = load i32, i32* %retries5, align 16, !tbaa !16
  %dec = add i32 %5, -1
  store i32 %dec, i32* %retries5, align 16, !tbaa !16
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true2, %land.lhs.true, %entry
  %card = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %6 = load %struct.memstick_dev*, %struct.memstick_dev** %card, align 8, !tbaa !37
  %tobool6 = icmp ne %struct.memstick_dev* %6, null
  br i1 %tobool6, label %land.lhs.true7, label %if.end14

land.lhs.true7:                                   ; preds = %if.end
  %card8 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %7 = load %struct.memstick_dev*, %struct.memstick_dev** %card8, align 8, !tbaa !37
  %next_request = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %7, i32 0, i32 6
  %8 = load i32 (%struct.memstick_dev*, %struct.memstick_request**)*, i32 (%struct.memstick_dev*, %struct.memstick_request**)** %next_request, align 8, !tbaa !38
  %tobool9 = icmp ne i32 (%struct.memstick_dev*, %struct.memstick_request**)* %8, null
  br i1 %tobool9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %land.lhs.true7
  %card11 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %9 = load %struct.memstick_dev*, %struct.memstick_dev** %card11, align 8, !tbaa !37
  %next_request12 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %9, i32 0, i32 6
  %10 = load i32 (%struct.memstick_dev*, %struct.memstick_request**)*, i32 (%struct.memstick_dev*, %struct.memstick_request**)** %next_request12, align 8, !tbaa !38
  %card13 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %11 = load %struct.memstick_dev*, %struct.memstick_dev** %card13, align 8, !tbaa !37
  %call = call i32 %10(%struct.memstick_dev* %11, %struct.memstick_request** %mrq)
  br label %if.end14

if.end14:                                         ; preds = %if.then10, %land.lhs.true7, %if.end
  %rc.0 = phi i32 [ %call, %if.then10 ], [ -6, %land.lhs.true7 ], [ -6, %if.end ]
  %tobool15 = icmp ne i32 %rc.0, 0
  br i1 %tobool15, label %if.else, label %if.then16

if.then16:                                        ; preds = %if.end14
  %12 = load i32, i32* @cmd_retries, align 4, !tbaa !42
  %cmp = icmp ugt i32 %12, 1
  %13 = load i32, i32* @cmd_retries, align 4
  %sub = sub i32 %13, 1
  %cond = select i1 %cmp, i32 %sub, i32 1
  %retries17 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 6
  store i32 %cond, i32* %retries17, align 16, !tbaa !16
  br label %cleanup

if.else:                                          ; preds = %if.end14
  store %struct.memstick_request* null, %struct.memstick_request** %mrq, align 8, !tbaa !12
  br label %cleanup

cleanup:                                          ; preds = %if.then16, %if.else, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %rc.0, %if.else ], [ %rc.0, %if.then16 ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

; Function Attrs: nounwind uwtable
define void @memstick_new_req(%struct.memstick_host* %host) #1 {
entry:
  %card = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %0 = load %struct.memstick_dev*, %struct.memstick_dev** %card, align 8, !tbaa !37
  %tobool = icmp ne %struct.memstick_dev* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, i32* @cmd_retries, align 4, !tbaa !42
  %retries = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 6
  store i32 %1, i32* %retries, align 16, !tbaa !16
  %card1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %2 = load %struct.memstick_dev*, %struct.memstick_dev** %card1, align 8, !tbaa !37
  %mrq_complete = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %2, i32 0, i32 3
  %done = getelementptr inbounds %struct.completion, %struct.completion* %mrq_complete, i32 0, i32 0
  store i32 0, i32* %done, align 8, !tbaa !43
  %request = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 7
  %request2 = bitcast {}** %request to void (%struct.memstick_host*)**
  %3 = load void (%struct.memstick_host*)*, void (%struct.memstick_host*)** %request2, align 8, !tbaa !44
  call void %3(%struct.memstick_host* %host)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @memstick_init_req_sg(%struct.memstick_request* %mrq, i8 zeroext %tpc, %struct.scatterlist* %sg) #1 {
entry:
  %tpc1 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 0
  store i8 %tpc, i8* %tpc1, align 8, !tbaa !45
  %conv = zext i8 %tpc to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  %data_dir = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load = load i8, i8* %data_dir, align 1
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  %bf.clear.sink = select i1 %tobool, i8 %bf.set, i8 %bf.clear
  store i8 %bf.clear.sink, i8* %data_dir, align 1
  %0 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 4
  %sg5 = bitcast %union.anon.23* %0 to %struct.scatterlist*
  %1 = bitcast %struct.scatterlist* %sg5 to i8*
  %2 = bitcast %struct.scatterlist* %sg to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 32, i32 8, i1 false), !tbaa.struct !46
  %long_data = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load6 = load i8, i8* %long_data, align 1
  %bf.clear7 = and i8 %bf.load6, -5
  %bf.set8 = or i8 %bf.clear7, 4
  store i8 %bf.set8, i8* %long_data, align 1
  %conv9 = zext i8 %tpc to i32
  %cmp = icmp eq i32 %conv9, 14
  %conv11 = zext i8 %tpc to i32
  %cmp12 = icmp eq i32 %conv11, 9
  %or.cond = or i1 %cmp, %cmp12
  %need_card_int = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load15 = load i8, i8* %need_card_int, align 1
  %bf.clear16 = and i8 %bf.load15, -3
  %bf.set17 = or i8 %bf.clear16, 2
  %bf.clear16.sink = select i1 %or.cond, i8 %bf.set17, i8 %bf.clear16
  store i8 %bf.clear16.sink, i8* %need_card_int, align 1
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define void @memstick_init_req(%struct.memstick_request* %mrq, i8 zeroext %tpc, i8* %buf, i64 %length) #1 {
entry:
  %tpc1 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 0
  store i8 %tpc, i8* %tpc1, align 8, !tbaa !45
  %conv = zext i8 %tpc to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  %data_dir = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load = load i8, i8* %data_dir, align 1
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  %bf.clear.sink = select i1 %tobool, i8 %bf.set, i8 %bf.clear
  store i8 %bf.clear.sink, i8* %data_dir, align 1
  %cmp = icmp ugt i64 %length, 15
  %.length = select i1 %cmp, i64 15, i64 %length
  %conv6 = trunc i64 %.length to i8
  %0 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 4
  %1 = bitcast %union.anon.23* %0 to %struct.anon.24*
  %data_len = getelementptr inbounds %struct.anon.24, %struct.anon.24* %1, i32 0, i32 0
  store i8 %conv6, i8* %data_len, align 8, !tbaa !49
  %data_dir7 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load8 = load i8, i8* %data_dir7, align 1
  %bf.clear9 = and i8 %bf.load8, 1
  %conv10 = zext i8 %bf.clear9 to i32
  %cmp11 = icmp eq i32 %conv10, 1
  br i1 %cmp11, label %if.then13, label %if.end16

if.then13:                                        ; preds = %entry
  %2 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 4
  %3 = bitcast %union.anon.23* %2 to %struct.anon.24*
  %data_len14 = getelementptr inbounds %struct.anon.24, %struct.anon.24* %3, i32 0, i32 0
  %4 = load i8, i8* %data_len14, align 8, !tbaa !49
  %conv15 = zext i8 %4 to i64
  %5 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 4
  %6 = bitcast %union.anon.23* %5 to %struct.anon.24*
  %data = getelementptr inbounds %struct.anon.24, %struct.anon.24* %6, i32 0, i32 1
  %arraydecay = getelementptr inbounds [15 x i8], [15 x i8]* %data, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %buf, i64 %conv15, i32 1, i1 false)
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %entry
  %long_data = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load17 = load i8, i8* %long_data, align 1
  %bf.clear18 = and i8 %bf.load17, -5
  store i8 %bf.clear18, i8* %long_data, align 1
  %conv19 = zext i8 %tpc to i32
  %cmp20 = icmp eq i32 %conv19, 14
  %conv22 = zext i8 %tpc to i32
  %cmp23 = icmp eq i32 %conv22, 9
  %or.cond = or i1 %cmp20, %cmp23
  %need_card_int = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load26 = load i8, i8* %need_card_int, align 1
  %bf.clear27 = and i8 %bf.load26, -3
  %bf.set28 = or i8 %bf.clear27, 2
  %bf.clear27.sink = select i1 %or.cond, i8 %bf.set28, i8 %bf.clear27
  store i8 %bf.clear27.sink, i8* %need_card_int, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @memstick_set_rw_addr(%struct.memstick_dev* %card) #1 {
entry:
  %next_request = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 6
  store i32 (%struct.memstick_dev*, %struct.memstick_request**)* @h_memstick_set_rw_addr, i32 (%struct.memstick_dev*, %struct.memstick_request**)** %next_request, align 8, !tbaa !38
  %host = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 1
  %0 = load %struct.memstick_host*, %struct.memstick_host** %host, align 8, !tbaa !50
  call void @memstick_new_req(%struct.memstick_host* %0)
  %mrq_complete = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 3
  call void @wait_for_completion(%struct.completion* %mrq_complete)
  %current_mrq = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 4
  %error = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %current_mrq, i32 0, i32 3
  %1 = load i32, i32* %error, align 4, !tbaa !51
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define internal i32 @h_memstick_set_rw_addr(%struct.memstick_dev* %card, %struct.memstick_request** %mrq) #1 {
entry:
  %0 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !12
  %tobool = icmp ne %struct.memstick_request* %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %current_mrq = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 4
  %reg_addr = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 2
  %1 = bitcast %struct.ms_register_addr* %reg_addr to i8*
  call void @memstick_init_req(%struct.memstick_request* %current_mrq, i8 zeroext 8, i8* %1, i64 4)
  %current_mrq1 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 4
  store %struct.memstick_request* %current_mrq1, %struct.memstick_request** %mrq, align 8, !tbaa !12
  br label %return

if.else:                                          ; preds = %entry
  %mrq_complete = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 3
  call void @complete(%struct.completion* %mrq_complete)
  br label %return

return:                                           ; preds = %if.else, %if.then
  %retval.0 = phi i32 [ -11, %if.else ], [ 0, %if.then ]
  ret i32 %retval.0
}

declare void @wait_for_completion(%struct.completion*) #3

; Function Attrs: nounwind uwtable
define %struct.memstick_host* @memstick_alloc_host(i32 %extra, %struct.device* %dev) #1 {
entry:
  %.compoundliteral = alloca %struct.atomic64_t, align 8
  %conv = zext i32 %extra to i64
  %add = add i64 576, %conv
  %call = call i8* @kzalloc(i64 %add, i32 208)
  %0 = bitcast i8* %call to %struct.memstick_host*
  %tobool = icmp ne %struct.memstick_host* %0, null
  br i1 %tobool, label %do.body, label %if.end

do.body:                                          ; preds = %entry
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 0
  call void @__mutex_init(%struct.mutex* %lock, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0), %struct.lock_class_key* @memstick_alloc_host.__key)
  %media_checker = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 3
  call void @__init_work(%struct.work_struct* %media_checker, i32 0)
  %media_checker3 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 3
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %media_checker3, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral, i32 0, i32 0
  store i64 68719476704, i64* %counter, align 8, !tbaa !52
  %1 = bitcast %struct.atomic64_t* %data to i8*
  %2 = bitcast %struct.atomic64_t* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 8, i32 8, i1 false), !tbaa.struct !53
  %media_checker4 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 3
  %entry5 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %media_checker4, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry5)
  %media_checker7 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 3
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %media_checker7, i32 0, i32 2
  store void (%struct.work_struct*)* @memstick_check, void (%struct.work_struct*)** %func, align 8, !tbaa !54
  %dev14 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 4
  %class = getelementptr inbounds %struct.device, %struct.device* %dev14, i32 0, i32 25
  store %struct.class* @memstick_host_class, %struct.class** %class, align 8, !tbaa !55
  %dev15 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 4
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev15, i32 0, i32 0
  store %struct.device* %dev, %struct.device** %parent, align 16, !tbaa !56
  %dev16 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 4
  call void @device_initialize(%struct.device* %dev16)
  br label %if.end

if.end:                                           ; preds = %do.body, %entry
  ret %struct.memstick_host* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @__init_work(%struct.work_struct* %work, i32 %onstack) #0 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #0 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !57
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !58
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @memstick_check(%struct.work_struct* %work) #1 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -48
  %1 = bitcast i8* %add.ptr to %struct.memstick_host*
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 0
  call void @mutex_lock(%struct.mutex* %lock)
  %card2 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %2 = load %struct.memstick_dev*, %struct.memstick_dev** %card2, align 8, !tbaa !37
  %tobool = icmp ne %struct.memstick_dev* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @memstick_power_on(%struct.memstick_host* %1)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %out_power_off, label %if.end12

if.else:                                          ; preds = %entry
  %card5 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %3 = load %struct.memstick_dev*, %struct.memstick_dev** %card5, align 8, !tbaa !37
  %stop = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %3, i32 0, i32 7
  %4 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %stop, align 8, !tbaa !59
  %tobool6 = icmp ne void (%struct.memstick_dev*)* %4, null
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.else
  %card8 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %5 = load %struct.memstick_dev*, %struct.memstick_dev** %card8, align 8, !tbaa !37
  %stop9 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %5, i32 0, i32 7
  %6 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %stop9, align 8, !tbaa !59
  %card10 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %7 = load %struct.memstick_dev*, %struct.memstick_dev** %card10, align 8, !tbaa !37
  call void %6(%struct.memstick_dev* %7)
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then7, %if.then
  %call13 = call %struct.memstick_dev* @memstick_alloc_card(%struct.memstick_host* %1)
  %tobool14 = icmp ne %struct.memstick_dev* %call13, null
  %card24 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %8 = load %struct.memstick_dev*, %struct.memstick_dev** %card24, align 8, !tbaa !37
  %tobool25 = icmp ne %struct.memstick_dev* %8, null
  br i1 %tobool14, label %if.else22, label %if.then15

if.then15:                                        ; preds = %if.end12
  br i1 %tobool25, label %if.then18, label %out_power_off

if.then18:                                        ; preds = %if.then15
  %card19 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %9 = load %struct.memstick_dev*, %struct.memstick_dev** %card19, align 8, !tbaa !37
  %dev = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %9, i32 0, i32 9
  call void @device_unregister(%struct.device* %dev)
  %card20 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  store %struct.memstick_dev* null, %struct.memstick_dev** %card20, align 8, !tbaa !37
  br label %out_power_off

if.else22:                                        ; preds = %if.end12
  br i1 %tobool25, label %if.then26, label %if.end51

if.then26:                                        ; preds = %if.else22
  %card27 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %10 = load %struct.memstick_dev*, %struct.memstick_dev** %card27, align 8, !tbaa !37
  %call28 = call i32 @memstick_set_rw_addr(%struct.memstick_dev* %10)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then38, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then26
  %card30 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %11 = load %struct.memstick_dev*, %struct.memstick_dev** %card30, align 8, !tbaa !37
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %call13, i32 0, i32 0
  %call31 = call i32 @memstick_dev_match(%struct.memstick_dev* %11, %struct.memstick_device_id* %id)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %lor.lhs.false33, label %if.then38

lor.lhs.false33:                                  ; preds = %lor.lhs.false
  %card34 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %12 = load %struct.memstick_dev*, %struct.memstick_dev** %card34, align 8, !tbaa !37
  %check = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %12, i32 0, i32 5
  %13 = load i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*)** %check, align 8, !tbaa !60
  %card35 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %14 = load %struct.memstick_dev*, %struct.memstick_dev** %card35, align 8, !tbaa !37
  %call36 = call i32 %13(%struct.memstick_dev* %14)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.else42, label %if.then38

if.then38:                                        ; preds = %lor.lhs.false33, %lor.lhs.false, %if.then26
  %card39 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %15 = load %struct.memstick_dev*, %struct.memstick_dev** %card39, align 8, !tbaa !37
  %dev40 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %15, i32 0, i32 9
  call void @device_unregister(%struct.device* %dev40)
  %card41 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  store %struct.memstick_dev* null, %struct.memstick_dev** %card41, align 8, !tbaa !37
  br label %if.end51

if.else42:                                        ; preds = %lor.lhs.false33
  %card43 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %16 = load %struct.memstick_dev*, %struct.memstick_dev** %card43, align 8, !tbaa !37
  %start = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %16, i32 0, i32 8
  %17 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %start, align 8, !tbaa !61
  %tobool44 = icmp ne void (%struct.memstick_dev*)* %17, null
  br i1 %tobool44, label %if.then45, label %if.end51

if.then45:                                        ; preds = %if.else42
  %card46 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %18 = load %struct.memstick_dev*, %struct.memstick_dev** %card46, align 8, !tbaa !37
  %start47 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %18, i32 0, i32 8
  %19 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %start47, align 8, !tbaa !61
  %card48 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %20 = load %struct.memstick_dev*, %struct.memstick_dev** %card48, align 8, !tbaa !37
  call void %19(%struct.memstick_dev* %20)
  br label %if.end51

if.end51:                                         ; preds = %if.then38, %if.then45, %if.else42, %if.else22
  %card52 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %21 = load %struct.memstick_dev*, %struct.memstick_dev** %card52, align 8, !tbaa !37
  %tobool53 = icmp ne %struct.memstick_dev* %21, null
  br i1 %tobool53, label %if.else64, label %if.then54

if.then54:                                        ; preds = %if.end51
  %card55 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  store %struct.memstick_dev* %call13, %struct.memstick_dev** %card55, align 8, !tbaa !37
  %dev56 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %call13, i32 0, i32 9
  %call57 = call i32 @device_register(%struct.device* %dev56)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.then59, label %out_power_off

if.then59:                                        ; preds = %if.then54
  %dev60 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %call13, i32 0, i32 9
  call void @put_device(%struct.device* %dev60)
  %card61 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %22 = load %struct.memstick_dev*, %struct.memstick_dev** %card61, align 8, !tbaa !37
  %23 = bitcast %struct.memstick_dev* %22 to i8*
  call void @kfree(i8* %23)
  %card62 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  store %struct.memstick_dev* null, %struct.memstick_dev** %card62, align 8, !tbaa !37
  br label %out_power_off

if.else64:                                        ; preds = %if.end51
  %24 = bitcast %struct.memstick_dev* %call13 to i8*
  call void @kfree(i8* %24)
  br label %out_power_off

out_power_off:                                    ; preds = %if.then18, %if.then15, %if.then54, %if.then59, %if.else64, %if.then
  %card67 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %25 = load %struct.memstick_dev*, %struct.memstick_dev** %card67, align 8, !tbaa !37
  %tobool68 = icmp ne %struct.memstick_dev* %25, null
  br i1 %tobool68, label %if.end71, label %if.then69

if.then69:                                        ; preds = %out_power_off
  %set_param = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 8
  %26 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param, align 32, !tbaa !62
  %call70 = call i32 %26(%struct.memstick_host* %1, i32 1, i32 0)
  br label %if.end71

if.end71:                                         ; preds = %if.then69, %out_power_off
  %lock72 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 0
  call void @mutex_unlock(%struct.mutex* %lock72)
  ret void
}

declare void @device_initialize(%struct.device*) #3

; Function Attrs: nounwind uwtable
define i32 @memstick_add_host(%struct.memstick_host* %host) #1 {
entry:
  call void @idr_preload(i32 208)
  call void @spin_lock(%struct.spinlock* @memstick_host_lock)
  %0 = bitcast %struct.memstick_host* %host to i8*
  %call = call i32 @idr_alloc(%struct.idr* @memstick_host_idr, i8* %0, i32 0, i32 0, i32 0)
  %cmp = icmp sge i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %id = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 1
  store i32 %call, i32* %id, align 8, !tbaa !63
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @spin_unlock(%struct.spinlock* @memstick_host_lock)
  call void @idr_preload_end()
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %dev = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  %id4 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 1
  %1 = load i32, i32* %id4, align 8, !tbaa !63
  %call5 = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i32 0, i32 0), i32 %1)
  %dev6 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  %call7 = call i32 @device_add(%struct.device* %dev6)
  %tobool = icmp ne i32 %call7, 0
  br i1 %tobool, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end3
  call void @spin_lock(%struct.spinlock* @memstick_host_lock)
  %id9 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 1
  %2 = load i32, i32* %id9, align 8, !tbaa !63
  call void @idr_remove(%struct.idr* @memstick_host_idr, i32 %2)
  call void @spin_unlock(%struct.spinlock* @memstick_host_lock)
  br label %cleanup

if.end10:                                         ; preds = %if.end3
  %set_param = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 8
  %3 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param, align 32, !tbaa !62
  %call11 = call i32 %3(%struct.memstick_host* %host, i32 1, i32 0)
  call void @memstick_detect_change(%struct.memstick_host* %host)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.end10, %if.then8
  %retval.0 = phi i32 [ %call7, %if.then8 ], [ 0, %if.end10 ], [ %call, %if.end ]
  ret i32 %retval.0
}

declare void @idr_preload(i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

declare i32 @idr_alloc(%struct.idr*, i8*, i32, i32, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @idr_preload_end() #0 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !64
  ret void
}

declare i32 @dev_set_name(%struct.device*, i8*, ...) #3

declare i32 @device_add(%struct.device*) #3

declare void @idr_remove(%struct.idr*, i32) #3

; Function Attrs: nounwind uwtable
define void @memstick_remove_host(%struct.memstick_host* %host) #1 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @workqueue, align 8, !tbaa !12
  call void @flush_workqueue(%struct.workqueue_struct* %0)
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_lock(%struct.mutex* %lock)
  %card = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %1 = load %struct.memstick_dev*, %struct.memstick_dev** %card, align 8, !tbaa !37
  %tobool = icmp ne %struct.memstick_dev* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %card1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %2 = load %struct.memstick_dev*, %struct.memstick_dev** %card1, align 8, !tbaa !37
  %dev = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %2, i32 0, i32 9
  call void @device_unregister(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %card2 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  store %struct.memstick_dev* null, %struct.memstick_dev** %card2, align 8, !tbaa !37
  %set_param = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 8
  %3 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param, align 32, !tbaa !62
  %call = call i32 %3(%struct.memstick_host* %host, i32 1, i32 0)
  %lock3 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_unlock(%struct.mutex* %lock3)
  call void @spin_lock(%struct.spinlock* @memstick_host_lock)
  %id = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 1
  %4 = load i32, i32* %id, align 8, !tbaa !63
  call void @idr_remove(%struct.idr* @memstick_host_idr, i32 %4)
  call void @spin_unlock(%struct.spinlock* @memstick_host_lock)
  %dev4 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  call void @device_del(%struct.device* %dev4)
  ret void
}

declare void @flush_workqueue(%struct.workqueue_struct*) #3

declare void @mutex_lock(%struct.mutex*) #3

declare void @device_unregister(%struct.device*) #3

declare void @mutex_unlock(%struct.mutex*) #3

declare void @device_del(%struct.device*) #3

; Function Attrs: nounwind uwtable
define void @memstick_free_host(%struct.memstick_host* %host) #1 {
entry:
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_destroy(%struct.mutex* %lock)
  %dev = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  call void @put_device(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @mutex_destroy(%struct.mutex* %lock) #0 {
entry:
  ret void
}

declare void @put_device(%struct.device*) #3

; Function Attrs: nounwind uwtable
define void @memstick_suspend_host(%struct.memstick_host* %host) #1 {
entry:
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_lock(%struct.mutex* %lock)
  %set_param = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 8
  %0 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param, align 32, !tbaa !62
  %call = call i32 %0(%struct.memstick_host* %host, i32 1, i32 0)
  %lock1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_unlock(%struct.mutex* %lock1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @memstick_resume_host(%struct.memstick_host* %host) #1 {
entry:
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_lock(%struct.mutex* %lock)
  %card = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %0 = load %struct.memstick_dev*, %struct.memstick_dev** %card, align 8, !tbaa !37
  %tobool = icmp ne %struct.memstick_dev* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @memstick_power_on(%struct.memstick_host* %host)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rc.0 = phi i32 [ %call, %if.then ], [ 0, %entry ]
  %lock1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_unlock(%struct.mutex* %lock1)
  %tobool2 = icmp ne i32 %rc.0, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  call void @memstick_detect_change(%struct.memstick_host* %host)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_power_on(%struct.memstick_host* %host) #1 {
entry:
  %set_param = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 8
  %0 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param, align 32, !tbaa !62
  %call = call i32 %0(%struct.memstick_host* %host, i32 1, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %set_param1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 8
  %1 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param1, align 32, !tbaa !62
  %call2 = call i32 %1(%struct.memstick_host* %host, i32 2, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rc.0 = phi i32 [ %call, %entry ], [ %call2, %if.then ]
  ret i32 %rc.0
}

; Function Attrs: nounwind uwtable
define i32 @memstick_register_driver(%struct.memstick_driver* %drv) #1 {
entry:
  %driver = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %drv, i32 0, i32 5
  %bus = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver, i32 0, i32 1
  store %struct.bus_type* @memstick_bus_type, %struct.bus_type** %bus, align 8, !tbaa !65
  %driver1 = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %drv, i32 0, i32 5
  %call = call i32 @driver_register(%struct.device_driver* %driver1)
  ret i32 %call
}

declare i32 @driver_register(%struct.device_driver*) #3

; Function Attrs: nounwind uwtable
define void @memstick_unregister_driver(%struct.memstick_driver* %drv) #1 {
entry:
  %driver = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %drv, i32 0, i32 5
  call void @driver_unregister(%struct.device_driver* %driver)
  ret void
}

declare void @driver_unregister(%struct.device_driver*) #3

; Function Attrs: nounwind uwtable
define internal void @memstick_exit() #1 section ".exit.text" {
entry:
  call void @class_unregister(%struct.class* @memstick_host_class)
  call void @bus_unregister(%struct.bus_type* @memstick_bus_type)
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @workqueue, align 8, !tbaa !12
  call void @destroy_workqueue(%struct.workqueue_struct* %0)
  call void @idr_destroy(%struct.idr* @memstick_host_idr)
  ret void
}

declare void @class_unregister(%struct.class*) #3

declare void @bus_unregister(%struct.bus_type*) #3

declare void @destroy_workqueue(%struct.workqueue_struct*) #3

declare void @idr_destroy(%struct.idr*) #3

; Function Attrs: nounwind uwtable
define internal i32 @memstick_init() #1 section ".init.text" {
entry:
  %call = call %struct.workqueue_struct* (i8*, i32, i32, %struct.lock_class_key*, i8*, ...) @__alloc_workqueue_key(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.13, i32 0, i32 0), i32 14, i32 1, %struct.lock_class_key* null, i8* null)
  store %struct.workqueue_struct* %call, %struct.workqueue_struct** @workqueue, align 8, !tbaa !12
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @workqueue, align 8, !tbaa !12
  %tobool = icmp ne %struct.workqueue_struct* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @bus_register(%struct.bus_type* @memstick_bus_type)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %call4 = call i32 @__class_register(%struct.class* @memstick_host_class, %struct.lock_class_key* @memstick_init.__key)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %rc.0 = phi i32 [ %call1, %if.end ], [ %call4, %if.then3 ]
  %tobool6 = icmp ne i32 %rc.0, 0
  br i1 %tobool6, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.end5
  call void @bus_unregister(%struct.bus_type* @memstick_bus_type)
  %1 = load %struct.workqueue_struct*, %struct.workqueue_struct** @workqueue, align 8, !tbaa !12
  call void @destroy_workqueue(%struct.workqueue_struct* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %entry, %if.end8
  %retval.0 = phi i32 [ %rc.0, %if.end8 ], [ -12, %entry ], [ 0, %if.end5 ]
  ret i32 %retval.0
}

declare zeroext i1 @queue_work_on(i32, %struct.workqueue_struct*, %struct.work_struct*) #3

declare void @complete(%struct.completion*) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #4 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare i8* @__kmalloc(i64, i32) #3

; Function Attrs: nounwind uwtable
define internal %struct.memstick_dev* @memstick_alloc_card(%struct.memstick_host* %host) #1 {
entry:
  %call = call i8* @kzalloc(i64 568, i32 208)
  %0 = bitcast i8* %call to %struct.memstick_dev*
  %card1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %1 = load %struct.memstick_dev*, %struct.memstick_dev** %card1, align 8, !tbaa !37
  %tobool = icmp ne %struct.memstick_dev* %0, null
  br i1 %tobool, label %if.then, label %if.end21

if.then:                                          ; preds = %entry
  %host2 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 1
  store %struct.memstick_host* %host, %struct.memstick_host** %host2, align 8, !tbaa !50
  %dev = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 9
  %dev3 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  %call4 = call i8* @dev_name(%struct.device* %dev3)
  %call5 = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i32 0, i32 0), i8* %call4)
  %dev6 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  %dev7 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 9
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev7, i32 0, i32 0
  store %struct.device* %dev6, %struct.device** %parent, align 8, !tbaa !68
  %dev8 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 9
  %bus = getelementptr inbounds %struct.device, %struct.device* %dev8, i32 0, i32 6
  store %struct.bus_type* @memstick_bus_type, %struct.bus_type** %bus, align 8, !tbaa !69
  %dev9 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 9
  %release = getelementptr inbounds %struct.device, %struct.device* %dev9, i32 0, i32 27
  store void (%struct.device*)* @memstick_free_card, void (%struct.device*)** %release, align 8, !tbaa !70
  %check = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 5
  store i32 (%struct.memstick_dev*)* @memstick_dummy_check, i32 (%struct.memstick_dev*)** %check, align 8, !tbaa !60
  %reg_addr = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 2
  %r_offset = getelementptr inbounds %struct.ms_register_addr, %struct.ms_register_addr* %reg_addr, i32 0, i32 0
  store i8 4, i8* %r_offset, align 8, !tbaa !71
  %reg_addr10 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 2
  %r_length = getelementptr inbounds %struct.ms_register_addr, %struct.ms_register_addr* %reg_addr10, i32 0, i32 1
  store i8 4, i8* %r_length, align 1, !tbaa !72
  %reg_addr11 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 2
  %w_offset = getelementptr inbounds %struct.ms_register_addr, %struct.ms_register_addr* %reg_addr11, i32 0, i32 2
  store i8 4, i8* %w_offset, align 2, !tbaa !73
  %reg_addr12 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 2
  %w_length = getelementptr inbounds %struct.ms_register_addr, %struct.ms_register_addr* %reg_addr12, i32 0, i32 3
  store i8 4, i8* %w_length, align 1, !tbaa !74
  %mrq_complete = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 3
  call void @init_completion(%struct.completion* %mrq_complete)
  %card13 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  store %struct.memstick_dev* %0, %struct.memstick_dev** %card13, align 8, !tbaa !37
  %call14 = call i32 @memstick_set_rw_addr(%struct.memstick_dev* %0)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %err_out, label %if.end

if.end:                                           ; preds = %if.then
  %next_request = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 6
  store i32 (%struct.memstick_dev*, %struct.memstick_request**)* @h_memstick_read_dev_id, i32 (%struct.memstick_dev*, %struct.memstick_request**)** %next_request, align 8, !tbaa !38
  call void @memstick_new_req(%struct.memstick_host* %host)
  %mrq_complete17 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 3
  call void @wait_for_completion(%struct.completion* %mrq_complete17)
  %current_mrq = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 4
  %error = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %current_mrq, i32 0, i32 3
  %2 = load i32, i32* %error, align 4, !tbaa !51
  %tobool18 = icmp ne i32 %2, 0
  br i1 %tobool18, label %err_out, label %if.end21

if.end21:                                         ; preds = %if.end, %entry
  %card22 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  store %struct.memstick_dev* %1, %struct.memstick_dev** %card22, align 8, !tbaa !37
  br label %cleanup

err_out:                                          ; preds = %if.end, %if.then
  %card23 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  store %struct.memstick_dev* %1, %struct.memstick_dev** %card23, align 8, !tbaa !37
  %3 = bitcast %struct.memstick_dev* %0 to i8*
  call void @kfree(i8* %3)
  br label %cleanup

cleanup:                                          ; preds = %err_out, %if.end21
  %retval.0 = phi %struct.memstick_dev* [ null, %err_out ], [ %0, %if.end21 ]
  ret %struct.memstick_dev* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_dev_match(%struct.memstick_dev* %card, %struct.memstick_device_id* %id) #1 {
entry:
  %match_flags = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 0
  %0 = load i8, i8* %match_flags, align 1, !tbaa !75
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end20

if.then:                                          ; preds = %entry
  %type = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 1
  %1 = load i8, i8* %type, align 1, !tbaa !76
  %conv1 = zext i8 %1 to i32
  %id2 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %type3 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id2, i32 0, i32 1
  %2 = load i8, i8* %type3, align 1, !tbaa !77
  %conv4 = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv1, %conv4
  br i1 %cmp, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.then
  %category = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 2
  %3 = load i8, i8* %category, align 1, !tbaa !78
  %conv6 = zext i8 %3 to i32
  %id7 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %category8 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id7, i32 0, i32 2
  %4 = load i8, i8* %category8, align 2, !tbaa !79
  %conv9 = zext i8 %4 to i32
  %cmp10 = icmp eq i32 %conv6, %conv9
  br i1 %cmp10, label %land.lhs.true12, label %if.end20

land.lhs.true12:                                  ; preds = %land.lhs.true
  %class = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 3
  %5 = load i8, i8* %class, align 1, !tbaa !80
  %conv13 = zext i8 %5 to i32
  %id14 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %class15 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id14, i32 0, i32 3
  %6 = load i8, i8* %class15, align 1, !tbaa !81
  %conv16 = zext i8 %6 to i32
  %cmp17 = icmp eq i32 %conv13, %conv16
  br i1 %cmp17, label %return, label %if.end20

if.end20:                                         ; preds = %if.then, %land.lhs.true, %land.lhs.true12, %entry
  br label %return

return:                                           ; preds = %land.lhs.true12, %if.end20
  %retval.0 = phi i32 [ 0, %if.end20 ], [ 1, %land.lhs.true12 ]
  ret i32 %retval.0
}

declare i32 @device_register(%struct.device*) #3

declare void @kfree(i8*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name(%struct.device* %dev) #0 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !82
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !82
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @memstick_free_card(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %2 = bitcast %struct.memstick_dev* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_dummy_check(%struct.memstick_dev* %card) #1 {
entry:
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_completion(%struct.completion* %x) #0 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 0
  store i32 0, i32* %done, align 8, !tbaa !83
  %wait = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 1
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.3, i32 0, i32 0), %struct.lock_class_key* @init_completion.__key)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @h_memstick_read_dev_id(%struct.memstick_dev* %card, %struct.memstick_request** %mrq) #1 {
entry:
  %id_reg = alloca %struct.ms_id_register, align 1
  %0 = bitcast %struct.ms_id_register* %id_reg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #5
  %1 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !12
  %tobool = icmp ne %struct.memstick_request* %1, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %current_mrq = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 4
  call void @memstick_init_req(%struct.memstick_request* %current_mrq, i8 zeroext 4, i8* null, i64 4)
  %current_mrq1 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 4
  store %struct.memstick_request* %current_mrq1, %struct.memstick_request** %mrq, align 8, !tbaa !12
  br label %cleanup

if.else:                                          ; preds = %entry
  %2 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !12
  %error = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %2, i32 0, i32 3
  %3 = load i32, i32* %error, align 4, !tbaa !13
  %tobool2 = icmp ne i32 %3, 0
  br i1 %tobool2, label %if.end15, label %if.then3

if.then3:                                         ; preds = %if.else
  %cmp = icmp uge i64 4, 64
  %4 = bitcast %struct.ms_id_register* %id_reg to i8*
  %5 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !12
  %6 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %5, i32 0, i32 4
  %7 = bitcast %union.anon.23* %6 to %struct.anon.24*
  %data = getelementptr inbounds %struct.anon.24, %struct.anon.24* %7, i32 0, i32 1
  %arraydecay = getelementptr inbounds [15 x i8], [15 x i8]* %data, i32 0, i32 0
  br i1 %cmp, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.then3
  %call = call i8* @__memcpy(i8* %4, i8* %arraydecay, i64 4)
  br label %if.end

if.else5:                                         ; preds = %if.then3
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %arraydecay, i64 4, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else5, %if.then4
  %__ret.0 = phi i8* [ %call, %if.then4 ], [ %4, %if.else5 ]
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %match_flags = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 0
  store i8 1, i8* %match_flags, align 8, !tbaa !84
  %type = getelementptr inbounds %struct.ms_id_register, %struct.ms_id_register* %id_reg, i32 0, i32 0
  %8 = load i8, i8* %type, align 1, !tbaa !85
  %id8 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %type9 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id8, i32 0, i32 1
  store i8 %8, i8* %type9, align 1, !tbaa !77
  %category = getelementptr inbounds %struct.ms_id_register, %struct.ms_id_register* %id_reg, i32 0, i32 2
  %9 = load i8, i8* %category, align 1, !tbaa !87
  %id10 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %category11 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id10, i32 0, i32 2
  store i8 %9, i8* %category11, align 2, !tbaa !79
  %class = getelementptr inbounds %struct.ms_id_register, %struct.ms_id_register* %id_reg, i32 0, i32 3
  %10 = load i8, i8* %class, align 1, !tbaa !88
  %id12 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %class13 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id12, i32 0, i32 3
  store i8 %10, i8* %class13, align 1, !tbaa !81
  br label %if.end15

if.end15:                                         ; preds = %if.end, %if.else
  %mrq_complete = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 3
  call void @complete(%struct.completion* %mrq_complete)
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then
  %retval.0 = phi i32 [ -11, %if.end15 ], [ 0, %if.then ]
  %11 = bitcast %struct.ms_id_register* %id_reg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %11) #5
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name(%struct.kobject* %kobj) #0 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !89
  ret i8* %0
}

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #3

declare i8* @__memcpy(i8*, i8*, i64) #3

; Function Attrs: nounwind uwtable
define internal void @memstick_free(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -80
  %1 = bitcast i8* %add.ptr to %struct.memstick_host*
  %2 = bitcast %struct.memstick_host* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

declare void @_raw_spin_lock(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @__raw_spin_unlock(%struct.raw_spinlock* %lock) #0 {
entry:
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %lock)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !90
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @do_raw_spin_unlock(%struct.raw_spinlock* %lock) #0 {
entry:
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %lock, i32 0, i32 0
  call void @arch_spin_unlock(%struct.arch_spinlock* %raw_lock)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @arch_spin_unlock(%struct.arch_spinlock* %lock) #4 {
entry:
  call void @__ticket_spin_unlock(%struct.arch_spinlock* %lock)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__ticket_spin_unlock(%struct.arch_spinlock* %lock) #4 {
entry:
  %0 = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %lock, i32 0, i32 0
  %tickets = bitcast %union.anon.1* %0 to %struct.__raw_tickets*
  %head = getelementptr inbounds %struct.__raw_tickets, %struct.__raw_tickets* %tickets, i32 0, i32 0
  call void asm sideeffect "addb ${1:b}, $0\0A", "=*m,qi,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i8* %head, i32 1, i8* %head) #5, !srcloc !91
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_bus_match(%struct.device* %dev, %struct.device_driver* %drv) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %2 = bitcast %struct.device_driver* %drv to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 -40
  %3 = bitcast i8* %add.ptr3 to %struct.memstick_driver*
  %id_table = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %3, i32 0, i32 0
  %4 = load %struct.memstick_device_id*, %struct.memstick_device_id** %id_table, align 8, !tbaa !92
  %tobool = icmp ne %struct.memstick_device_id* %4, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then
  %ids.0 = phi %struct.memstick_device_id* [ %4, %if.then ], [ %incdec.ptr, %if.end ]
  %match_flags = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %ids.0, i32 0, i32 0
  %5 = load i8, i8* %match_flags, align 1, !tbaa !75
  %tobool4 = icmp ne i8 %5, 0
  br i1 %tobool4, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %call = call i32 @memstick_dev_match(%struct.memstick_dev* %1, %struct.memstick_device_id* %ids.0)
  %tobool5 = icmp ne i32 %call, 0
  br i1 %tobool5, label %cleanup, label %if.end

if.end:                                           ; preds = %while.body
  %incdec.ptr = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %ids.0, i32 1
  br label %while.cond

cleanup:                                          ; preds = %entry, %while.cond, %while.body
  %retval.0 = phi i32 [ 1, %while.body ], [ 0, %while.cond ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %type = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 1
  %2 = load i8, i8* %type, align 1, !tbaa !77
  %conv = zext i8 %2 to i32
  %call = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.10, i32 0, i32 0), i32 %conv)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %id1 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %category = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id1, i32 0, i32 2
  %3 = load i8, i8* %category, align 2, !tbaa !79
  %conv2 = zext i8 %3 to i32
  %call3 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11, i32 0, i32 0), i32 %conv2)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %id7 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %class = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id7, i32 0, i32 3
  %4 = load i8, i8* %class, align 1, !tbaa !81
  %conv8 = zext i8 %4 to i32
  %call9 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.12, i32 0, i32 0), i32 %conv8)
  %tobool10 = icmp ne i32 %call9, 0
  %. = select i1 %tobool10, i32 -12, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ -12, %if.end ], [ %., %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_device_probe(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !93
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.memstick_driver*
  %driver4 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver4, align 8, !tbaa !93
  %tobool = icmp ne %struct.device_driver* %5, null
  br i1 %tobool, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %entry
  %probe = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 1
  %6 = load i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*)** %probe, align 8, !tbaa !94
  %tobool5 = icmp ne i32 (%struct.memstick_dev*)* %6, null
  br i1 %tobool5, label %if.then, label %if.end10

if.then:                                          ; preds = %land.lhs.true
  %probe6 = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 1
  %7 = load i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*)** %probe6, align 8, !tbaa !94
  %call = call i32 %7(%struct.memstick_dev* %1)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.then
  %call9 = call %struct.device* @get_device(%struct.device* %dev)
  br label %if.end10

if.end10:                                         ; preds = %if.then, %if.then8, %land.lhs.true, %entry
  %rc.0 = phi i32 [ -19, %land.lhs.true ], [ -19, %entry ], [ %call, %if.then8 ], [ %call, %if.then ]
  ret i32 %rc.0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_device_remove(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !93
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.memstick_driver*
  %driver4 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver4, align 8, !tbaa !93
  %tobool = icmp ne %struct.device_driver* %5, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %remove = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 2
  %6 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %remove, align 8, !tbaa !95
  %tobool5 = icmp ne void (%struct.memstick_dev*)* %6, null
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %remove6 = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 2
  %7 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %remove6, align 8, !tbaa !95
  call void %7(%struct.memstick_dev* %1)
  %dev7 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 9
  %driver8 = getelementptr inbounds %struct.device, %struct.device* %dev7, i32 0, i32 7
  store %struct.device_driver* null, %struct.device_driver** %driver8, align 8, !tbaa !96
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  call void @put_device(%struct.device* %dev)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_device_suspend(%struct.device* %dev, i32 %state.coerce) #1 {
entry:
  %state = alloca %struct.pm_message, align 4
  %coerce.dive = getelementptr inbounds %struct.pm_message, %struct.pm_message* %state, i32 0, i32 0
  store i32 %state.coerce, i32* %coerce.dive, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !93
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.memstick_driver*
  %driver4 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver4, align 8, !tbaa !93
  %tobool = icmp ne %struct.device_driver* %5, null
  br i1 %tobool, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %entry
  %suspend = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 3
  %6 = load i32 (%struct.memstick_dev*, i32)*, i32 (%struct.memstick_dev*, i32)** %suspend, align 8, !tbaa !97
  %tobool5 = icmp ne i32 (%struct.memstick_dev*, i32)* %6, null
  br i1 %tobool5, label %if.then, label %cleanup

if.then:                                          ; preds = %land.lhs.true
  %suspend6 = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 3
  %7 = load i32 (%struct.memstick_dev*, i32)*, i32 (%struct.memstick_dev*, i32)** %suspend6, align 8, !tbaa !97
  %coerce.dive7 = getelementptr inbounds %struct.pm_message, %struct.pm_message* %state, i32 0, i32 0
  %8 = load i32, i32* %coerce.dive7, align 4
  %call = call i32 %7(%struct.memstick_dev* %1, i32 %8)
  br label %cleanup

cleanup:                                          ; preds = %entry, %land.lhs.true, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_device_resume(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !93
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.memstick_driver*
  %driver4 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver4, align 8, !tbaa !93
  %tobool = icmp ne %struct.device_driver* %5, null
  br i1 %tobool, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %entry
  %resume = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 4
  %6 = load i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*)** %resume, align 8, !tbaa !98
  %tobool5 = icmp ne i32 (%struct.memstick_dev*)* %6, null
  br i1 %tobool5, label %if.then, label %cleanup

if.then:                                          ; preds = %land.lhs.true
  %resume6 = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 4
  %7 = load i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*)** %resume6, align 8, !tbaa !98
  %call = call i32 %7(%struct.memstick_dev* %1)
  br label %cleanup

cleanup:                                          ; preds = %entry, %land.lhs.true, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @type_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %type = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 1
  %2 = load i8, i8* %type, align 1, !tbaa !77
  %conv = zext i8 %2 to i32
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @category_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %category = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 2
  %2 = load i8, i8* %category, align 2, !tbaa !79
  %conv = zext i8 %2 to i32
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @class_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %class = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 3
  %2 = load i8, i8* %class, align 1, !tbaa !81
  %conv = zext i8 %2 to i32
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  ret i64 %conv1
}

declare i32 @sprintf(i8*, i8*, ...) #3

declare i32 @add_uevent_var(%struct.kobj_uevent_env*, i8*, ...) #3

declare %struct.device* @get_device(%struct.device*) #3

declare %struct.workqueue_struct* @__alloc_workqueue_key(i8*, i32, i32, %struct.lock_class_key*, i8*, ...) #3

declare i32 @bus_register(%struct.bus_type*) #3

declare i32 @__class_register(%struct.class*, %struct.lock_class_key*) #3

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!4, !4, i64 0}
!13 = !{!14, !15, i64 4}
!14 = !{!"memstick_request", !5, i64 0, !5, i64 1, !5, i64 1, !5, i64 1, !5, i64 2, !15, i64 4, !5, i64 8}
!15 = !{!"int", !5, i64 0}
!16 = !{!17, !15, i64 528}
!17 = !{!"memstick_host", !18, i64 0, !15, i64 40, !15, i64 44, !22, i64 48, !25, i64 80, !4, i64 520, !15, i64 528, !4, i64 536, !4, i64 544, !5, i64 576}
!18 = !{!"mutex", !19, i64 0, !20, i64 4, !21, i64 8, !4, i64 24, !4, i64 32}
!19 = !{!"", !15, i64 0}
!20 = !{!"spinlock", !5, i64 0}
!21 = !{!"list_head", !4, i64 0, !4, i64 8}
!22 = !{!"work_struct", !23, i64 0, !21, i64 8, !4, i64 24}
!23 = !{!"", !24, i64 0}
!24 = !{!"long", !5, i64 0}
!25 = !{!"device", !4, i64 0, !4, i64 8, !26, i64 16, !4, i64 80, !4, i64 88, !18, i64 96, !4, i64 136, !4, i64 144, !4, i64 152, !28, i64 160, !4, i64 248, !15, i64 256, !4, i64 264, !33, i64 272, !4, i64 280, !21, i64 288, !4, i64 304, !34, i64 312, !4, i64 328, !35, i64 336, !15, i64 344, !15, i64 348, !20, i64 352, !21, i64 360, !36, i64 376, !4, i64 408, !4, i64 416, !4, i64 424, !4, i64 432}
!26 = !{!"kobject", !4, i64 0, !21, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !27, i64 56, !15, i64 60, !15, i64 60, !15, i64 60, !15, i64 60, !15, i64 60}
!27 = !{!"kref", !19, i64 0}
!28 = !{!"dev_pm_info", !29, i64 0, !15, i64 4, !15, i64 4, !30, i64 4, !30, i64 4, !30, i64 4, !30, i64 4, !20, i64 6, !21, i64 8, !31, i64 24, !4, i64 56, !30, i64 64, !30, i64 64, !4, i64 72, !4, i64 80}
!29 = !{!"pm_message", !15, i64 0}
!30 = !{!"_Bool", !5, i64 0}
!31 = !{!"completion", !15, i64 0, !32, i64 8}
!32 = !{!"__wait_queue_head", !20, i64 0, !21, i64 8}
!33 = !{!"long long", !5, i64 0}
!34 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!35 = !{!"acpi_dev_node", !4, i64 0}
!36 = !{!"klist_node", !4, i64 0, !21, i64 8, !27, i64 24}
!37 = !{!17, !4, i64 520}
!38 = !{!39, !4, i64 104}
!39 = !{!"memstick_dev", !40, i64 0, !4, i64 8, !41, i64 16, !31, i64 24, !14, i64 56, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !25, i64 128}
!40 = !{!"memstick_device_id", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3}
!41 = !{!"ms_register_addr", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3}
!42 = !{!15, !15, i64 0}
!43 = !{!39, !15, i64 24}
!44 = !{!17, !4, i64 536}
!45 = !{!14, !5, i64 0}
!46 = !{i64 0, i64 8, !47, i64 8, i64 4, !42, i64 12, i64 4, !42, i64 16, i64 8, !48, i64 24, i64 4, !42}
!47 = !{!24, !24, i64 0}
!48 = !{!33, !33, i64 0}
!49 = !{!5, !5, i64 0}
!50 = !{!39, !4, i64 8}
!51 = !{!39, !15, i64 60}
!52 = !{!23, !24, i64 0}
!53 = !{i64 0, i64 8, !47}
!54 = !{!22, !4, i64 24}
!55 = !{!17, !4, i64 488}
!56 = !{!17, !4, i64 80}
!57 = !{!21, !4, i64 0}
!58 = !{!21, !4, i64 8}
!59 = !{!39, !4, i64 112}
!60 = !{!39, !4, i64 96}
!61 = !{!39, !4, i64 120}
!62 = !{!17, !4, i64 544}
!63 = !{!17, !15, i64 40}
!64 = !{i32 -2145561800}
!65 = !{!66, !4, i64 48}
!66 = !{!"memstick_driver", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !67, i64 40}
!67 = !{!"device_driver", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !30, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112}
!68 = !{!39, !4, i64 128}
!69 = !{!39, !4, i64 264}
!70 = !{!39, !4, i64 552}
!71 = !{!39, !5, i64 16}
!72 = !{!39, !5, i64 17}
!73 = !{!39, !5, i64 18}
!74 = !{!39, !5, i64 19}
!75 = !{!40, !5, i64 0}
!76 = !{!40, !5, i64 1}
!77 = !{!39, !5, i64 1}
!78 = !{!40, !5, i64 2}
!79 = !{!39, !5, i64 2}
!80 = !{!40, !5, i64 3}
!81 = !{!39, !5, i64 3}
!82 = !{!25, !4, i64 80}
!83 = !{!31, !15, i64 0}
!84 = !{!39, !5, i64 0}
!85 = !{!86, !5, i64 0}
!86 = !{!"ms_id_register", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3}
!87 = !{!86, !5, i64 2}
!88 = !{!86, !5, i64 3}
!89 = !{!26, !4, i64 0}
!90 = !{i32 -2146663089}
!91 = !{i32 -2146678264}
!92 = !{!66, !4, i64 0}
!93 = !{!25, !4, i64 144}
!94 = !{!66, !4, i64 8}
!95 = !{!66, !4, i64 16}
!96 = !{!39, !4, i64 272}
!97 = !{!66, !4, i64 24}
!98 = !{!66, !4, i64 32}
