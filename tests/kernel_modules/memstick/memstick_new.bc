; ModuleID = 'drivers/memstick/core/memstick.bc'
source_filename = "drivers/memstick/core/memstick.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.46 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, [12 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %struct.atomic_t }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.44, %struct.list_head, %struct.list_head, %union.anon.45 }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.42 }
%union.anon.42 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, [56 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.4, i32 }
%union.anon.4 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.5, %union.anon.28, %union.anon.29, %union.anon.33, %union.anon.36, [8 x i8] }
%union.anon.5 = type { %struct.address_space* }
%union.anon.28 = type { i64 }
%union.anon.29 = type { i64 }
%union.anon.33 = type { %struct.list_head }
%union.anon.36 = type { i64 }
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.mem_cgroup = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct* }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, i32, %struct.task_struct*, %struct.vm_struct*, %struct.atomic_t, [28 x i8], %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.6, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon.6 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type {}
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type {}
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.7 }
%union.anon.7 = type { %struct.anon.8 }
%struct.anon.8 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.11 }
%union.anon.11 = type { %struct.anon.15, [80 x i8] }
%struct.anon.15 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.vm_struct = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.21 }
%union.anon.21 = type { %struct.anon.22 }
%struct.anon.22 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.24, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.27 }
%union.anon.24 = type { %struct.anon.25 }
%struct.anon.25 = type { i64, i64 }
%union.anon.27 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, [32 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%union.anon.44 = type { %struct.list_head }
%union.anon.45 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.37, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.38, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.41, i32, i32, %struct.hlist_head, i8* }
%struct.kgid_t = type { i32 }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.37 = type { i32 }
%struct.timespec = type { i64, i64 }
%union.anon.38 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%union.anon.0 = type { %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.41 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type opaque
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.39 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.39 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type opaque
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %struct.pmd_t*, %struct.pud_t*, %struct.pte_t, %struct.page*, %struct.mem_cgroup*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%struct.pte_t = type { i64 }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%union.anon.46 = type { i8* }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dma_map_ops = type opaque
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type opaque
%struct.fwnode_handle = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.subsys_private = type opaque
%struct.idr = type { %struct.radix_tree_root, i32 }
%struct.memstick_host = type { %struct.mutex, i32, i32, %struct.work_struct, %struct.device, %struct.memstick_dev*, i32, {}*, i32 (%struct.memstick_host*, i32, i32)*, [0 x i64] }
%struct.memstick_dev = type { %struct.memstick_device_id, %struct.memstick_host*, %struct.ms_register_addr, %struct.completion, %struct.memstick_request, i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*, %struct.memstick_request**)*, void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)*, %struct.device }
%struct.memstick_device_id = type { i8, i8, i8, i8 }
%struct.ms_register_addr = type { i8, i8, i8, i8 }
%struct.memstick_request = type { i8, i8, i8, i32, %union.anon.47 }
%union.anon.47 = type { %struct.scatterlist }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.anon.48 = type { i8, [15 x i8] }
%union.anon.49 = type { %struct.list_head* }
%struct.memstick_driver = type { %struct.memstick_device_id*, i32 (%struct.memstick_dev*)*, void (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*, i32)*, i32 (%struct.memstick_dev*)*, %struct.device_driver }
%struct.ms_id_register = type { i8, i8, i8, i8 }
%union.anon.50 = type { i8 }

@__param_str_cmd_retries = internal constant [21 x i8] c"memstick.cmd_retries\00", align 16
@param_ops_uint = external constant %struct.kernel_param_ops, align 8
@cmd_retries = internal global i32 3, align 4
@__param_cmd_retries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__param_str_cmd_retries, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.46 { i8* bitcast (i32* @cmd_retries to i8*) } }, section "__param", align 8
@workqueue = internal global %struct.workqueue_struct* null, align 8
@__kstrtab_memstick_detect_change = internal constant [23 x i8] c"memstick_detect_change\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_detect_change = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_detect_change to i64), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__kstrtab_memstick_detect_change, i32 0, i32 0) }, section "___ksymtab+memstick_detect_change", align 8
@__kstrtab_memstick_next_req = internal constant [18 x i8] c"memstick_next_req\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_next_req = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.memstick_host*, %struct.memstick_request**)* @memstick_next_req to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_memstick_next_req, i32 0, i32 0) }, section "___ksymtab+memstick_next_req", align 8
@__kstrtab_memstick_new_req = internal constant [17 x i8] c"memstick_new_req\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_new_req = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_new_req to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_memstick_new_req, i32 0, i32 0) }, section "___ksymtab+memstick_new_req", align 8
@__kstrtab_memstick_init_req_sg = internal constant [21 x i8] c"memstick_init_req_sg\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_init_req_sg = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_request*, i8, %struct.scatterlist*)* @memstick_init_req_sg to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_memstick_init_req_sg, i32 0, i32 0) }, section "___ksymtab+memstick_init_req_sg", align 8
@__kstrtab_memstick_init_req = internal constant [18 x i8] c"memstick_init_req\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_init_req = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_request*, i8, i8*, i64)* @memstick_init_req to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_memstick_init_req, i32 0, i32 0) }, section "___ksymtab+memstick_init_req", align 8
@__kstrtab_memstick_set_rw_addr = internal constant [21 x i8] c"memstick_set_rw_addr\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_set_rw_addr = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.memstick_dev*)* @memstick_set_rw_addr to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_memstick_set_rw_addr, i32 0, i32 0) }, section "___ksymtab+memstick_set_rw_addr", align 8
@memstick_alloc_host.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str = private unnamed_addr constant [12 x i8] c"&host->lock\00", align 1
@memstick_host_class = internal global %struct.class { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.4, i32 0, i32 0), %struct.module* null, %struct.class_attribute* null, %struct.attribute_group** null, %struct.attribute_group** null, %struct.kobject* null, i32 (%struct.device*, %struct.kobj_uevent_env*)* null, i8* (%struct.device*, i16*)* null, void (%struct.class*)* null, void (%struct.device*)* @memstick_free, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.kobj_ns_type_operations* null, i8* (%struct.device*)* null, %struct.dev_pm_ops* null, %struct.subsys_private* null }, align 8
@__kstrtab_memstick_alloc_host = internal constant [20 x i8] c"memstick_alloc_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_alloc_host = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.memstick_host* (i32, %struct.device*)* @memstick_alloc_host to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_memstick_alloc_host, i32 0, i32 0) }, section "___ksymtab+memstick_alloc_host", align 8
@memstick_host_lock = internal global %struct.spinlock zeroinitializer, align 4
@memstick_host_idr = internal global %struct.idr { %struct.radix_tree_root { i32 100663296, %struct.radix_tree_node* null }, i32 0 }, align 8
@.str.1 = private unnamed_addr constant [11 x i8] c"memstick%u\00", align 1
@__kstrtab_memstick_add_host = internal constant [18 x i8] c"memstick_add_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_add_host = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.memstick_host*)* @memstick_add_host to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_memstick_add_host, i32 0, i32 0) }, section "___ksymtab+memstick_add_host", align 8
@__kstrtab_memstick_remove_host = internal constant [21 x i8] c"memstick_remove_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_remove_host = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_remove_host to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_memstick_remove_host, i32 0, i32 0) }, section "___ksymtab+memstick_remove_host", align 8
@__kstrtab_memstick_free_host = internal constant [19 x i8] c"memstick_free_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_free_host = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_free_host to i64), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__kstrtab_memstick_free_host, i32 0, i32 0) }, section "___ksymtab+memstick_free_host", align 8
@__kstrtab_memstick_suspend_host = internal constant [22 x i8] c"memstick_suspend_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_suspend_host = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_suspend_host to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_memstick_suspend_host, i32 0, i32 0) }, section "___ksymtab+memstick_suspend_host", align 8
@__kstrtab_memstick_resume_host = internal constant [21 x i8] c"memstick_resume_host\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_resume_host = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_host*)* @memstick_resume_host to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_memstick_resume_host, i32 0, i32 0) }, section "___ksymtab+memstick_resume_host", align 8
@memstick_bus_type = internal global %struct.bus_type { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.5, i32 0, i32 0), i8* null, %struct.device* null, %struct.device_attribute* null, %struct.attribute_group** null, %struct.attribute_group** getelementptr inbounds ([2 x %struct.attribute_group*], [2 x %struct.attribute_group*]* @memstick_dev_groups, i32 0, i32 0), %struct.attribute_group** null, i32 (%struct.device*, %struct.device_driver*)* @memstick_bus_match, i32 (%struct.device*, %struct.kobj_uevent_env*)* @memstick_uevent, i32 (%struct.device*)* @memstick_device_probe, i32 (%struct.device*)* @memstick_device_remove, void (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*, i32)* @memstick_device_suspend, i32 (%struct.device*)* @memstick_device_resume, i32 (%struct.device*)* null, %struct.dev_pm_ops* null, %struct.iommu_ops* null, %struct.subsys_private* null, %struct.lock_class_key zeroinitializer }, align 8
@__kstrtab_memstick_register_driver = internal constant [25 x i8] c"memstick_register_driver\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_register_driver = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.memstick_driver*)* @memstick_register_driver to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_memstick_register_driver, i32 0, i32 0) }, section "___ksymtab+memstick_register_driver", align 8
@__kstrtab_memstick_unregister_driver = internal constant [27 x i8] c"memstick_unregister_driver\00", section "__ksymtab_strings", align 1
@__ksymtab_memstick_unregister_driver = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.memstick_driver*)* @memstick_unregister_driver to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_memstick_unregister_driver, i32 0, i32 0) }, section "___ksymtab+memstick_unregister_driver", align 8
@__initcall_memstick_init6 = internal global i32 ()* @memstick_init, section ".initcall6.init", align 8
@__exitcall_memstick_exit = internal global void ()* @memstick_exit, section ".exitcall.exit", align 8
@.str.2 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@init_completion.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.3 = private unnamed_addr constant [9 x i8] c"&x->wait\00", align 1
@.str.4 = private unnamed_addr constant [14 x i8] c"memstick_host\00", align 1
@.str.5 = private unnamed_addr constant [9 x i8] c"memstick\00", align 1
@memstick_dev_groups = internal global [2 x %struct.attribute_group*] [%struct.attribute_group* @memstick_dev_group, %struct.attribute_group* null], align 16
@memstick_dev_group = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([4 x %struct.attribute*], [4 x %struct.attribute*]* @memstick_dev_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@memstick_dev_attrs = internal global [4 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_type, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_category, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_class, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_type = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.6, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @type_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_category = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @category_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_class = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @class_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.6 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.7 = private unnamed_addr constant [5 x i8] c"%02X\00", align 1
@.str.8 = private unnamed_addr constant [9 x i8] c"category\00", align 1
@.str.9 = private unnamed_addr constant [6 x i8] c"class\00", align 1
@.str.10 = private unnamed_addr constant [19 x i8] c"MEMSTICK_TYPE=%02X\00", align 1
@.str.11 = private unnamed_addr constant [23 x i8] c"MEMSTICK_CATEGORY=%02X\00", align 1
@.str.12 = private unnamed_addr constant [20 x i8] c"MEMSTICK_CLASS=%02X\00", align 1
@.str.13 = private unnamed_addr constant [10 x i8] c"kmemstick\00", align 1
@memstick_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@llvm.used = appending global [18 x i8*] [i8* bitcast (%struct.kernel_param* @__param_cmd_retries to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_detect_change to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_next_req to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_new_req to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_init_req_sg to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_init_req to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_set_rw_addr to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_alloc_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_add_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_remove_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_free_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_suspend_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_resume_host to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_register_driver to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_memstick_unregister_driver to i8*), i8* bitcast (void ()* @memstick_exit to i8*), i8* bitcast (i32 ()** @__initcall_memstick_init6 to i8*), i8* bitcast (void ()** @__exitcall_memstick_exit to i8*)], section "llvm.metadata"

; Function Attrs: nounwind uwtable
define void @memstick_detect_change(%struct.memstick_host* %host) #0 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @workqueue, align 8, !tbaa !2
  %media_checker = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 3
  %call = call zeroext i1 @queue_work(%struct.workqueue_struct* %0, %struct.work_struct* %media_checker)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @queue_work(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #1 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 64, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define i32 @memstick_next_req(%struct.memstick_host* %host, %struct.memstick_request** %mrq) #0 {
entry:
  %0 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !2
  %tobool = icmp ne %struct.memstick_request* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !2
  %error = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %1, i32 0, i32 3
  %2 = load i32, i32* %error, align 4, !tbaa !6
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %retries = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 6
  %3 = load i32, i32* %retries, align 8, !tbaa !9
  %tobool3 = icmp ne i32 %3, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true2
  %4 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !2
  %error4 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %4, i32 0, i32 3
  store i32 -6, i32* %error4, align 4, !tbaa !6
  %retries5 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 6
  %5 = load i32, i32* %retries5, align 8, !tbaa !9
  %dec = add i32 %5, -1
  store i32 %dec, i32* %retries5, align 8, !tbaa !9
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true2, %land.lhs.true, %entry
  %card = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %6 = load %struct.memstick_dev*, %struct.memstick_dev** %card, align 32, !tbaa !34
  %tobool6 = icmp ne %struct.memstick_dev* %6, null
  br i1 %tobool6, label %land.lhs.true7, label %if.end14

land.lhs.true7:                                   ; preds = %if.end
  %card8 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %7 = load %struct.memstick_dev*, %struct.memstick_dev** %card8, align 32, !tbaa !34
  %next_request = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %7, i32 0, i32 6
  %8 = load i32 (%struct.memstick_dev*, %struct.memstick_request**)*, i32 (%struct.memstick_dev*, %struct.memstick_request**)** %next_request, align 8, !tbaa !35
  %tobool9 = icmp ne i32 (%struct.memstick_dev*, %struct.memstick_request**)* %8, null
  br i1 %tobool9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %land.lhs.true7
  %card11 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %9 = load %struct.memstick_dev*, %struct.memstick_dev** %card11, align 32, !tbaa !34
  %next_request12 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %9, i32 0, i32 6
  %10 = load i32 (%struct.memstick_dev*, %struct.memstick_request**)*, i32 (%struct.memstick_dev*, %struct.memstick_request**)** %next_request12, align 8, !tbaa !35
  %card13 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %11 = load %struct.memstick_dev*, %struct.memstick_dev** %card13, align 32, !tbaa !34
  %call = call i32 %10(%struct.memstick_dev* %11, %struct.memstick_request** %mrq)
  br label %if.end14

if.end14:                                         ; preds = %if.then10, %land.lhs.true7, %if.end
  %rc.0 = phi i32 [ %call, %if.then10 ], [ -6, %land.lhs.true7 ], [ -6, %if.end ]
  %tobool15 = icmp ne i32 %rc.0, 0
  br i1 %tobool15, label %if.else, label %if.then16

if.then16:                                        ; preds = %if.end14
  %12 = load i32, i32* @cmd_retries, align 4, !tbaa !39
  %cmp = icmp ugt i32 %12, 1
  %13 = load i32, i32* @cmd_retries, align 4
  %sub = sub i32 %13, 1
  %cond = select i1 %cmp, i32 %sub, i32 1
  %retries17 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 6
  store i32 %cond, i32* %retries17, align 8, !tbaa !9
  br label %cleanup

if.else:                                          ; preds = %if.end14
  store %struct.memstick_request* null, %struct.memstick_request** %mrq, align 8, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.then16, %if.else, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ %rc.0, %if.else ], [ %rc.0, %if.then16 ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

; Function Attrs: nounwind uwtable
define void @memstick_new_req(%struct.memstick_host* %host) #0 {
entry:
  %card = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %0 = load %struct.memstick_dev*, %struct.memstick_dev** %card, align 32, !tbaa !34
  %tobool = icmp ne %struct.memstick_dev* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, i32* @cmd_retries, align 4, !tbaa !39
  %retries = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 6
  store i32 %1, i32* %retries, align 8, !tbaa !9
  %card1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %2 = load %struct.memstick_dev*, %struct.memstick_dev** %card1, align 32, !tbaa !34
  %mrq_complete = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %2, i32 0, i32 3
  call void @reinit_completion(%struct.completion* %mrq_complete)
  %request = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 7
  %request2 = bitcast {}** %request to void (%struct.memstick_host*)**
  %3 = load void (%struct.memstick_host*)*, void (%struct.memstick_host*)** %request2, align 16, !tbaa !40
  call void %3(%struct.memstick_host* %host)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @reinit_completion(%struct.completion* %x) #1 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 0
  store i32 0, i32* %done, align 8, !tbaa !41
  ret void
}

; Function Attrs: nounwind uwtable
define void @memstick_init_req_sg(%struct.memstick_request* %mrq, i8 zeroext %tpc, %struct.scatterlist* %sg) #0 {
entry:
  %tpc1 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 0
  store i8 %tpc, i8* %tpc1, align 8, !tbaa !42
  %conv = zext i8 %tpc to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  %data_dir = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load = load i8, i8* %data_dir, align 1
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  %bf.clear.sink = select i1 %tobool, i8 %bf.set, i8 %bf.clear
  store i8 %bf.clear.sink, i8* %data_dir, align 1
  %0 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 4
  %sg5 = bitcast %union.anon.47* %0 to %struct.scatterlist*
  %1 = bitcast %struct.scatterlist* %sg5 to i8*
  %2 = bitcast %struct.scatterlist* %sg to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 32, i32 8, i1 false), !tbaa.struct !43
  %long_data = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load6 = load i8, i8* %long_data, align 1
  %bf.clear7 = and i8 %bf.load6, -5
  %bf.set8 = or i8 %bf.clear7, 4
  store i8 %bf.set8, i8* %long_data, align 1
  %conv9 = zext i8 %tpc to i32
  %cmp = icmp eq i32 %conv9, 14
  %conv11 = zext i8 %tpc to i32
  %cmp12 = icmp eq i32 %conv11, 9
  %or.cond = or i1 %cmp, %cmp12
  %need_card_int = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load15 = load i8, i8* %need_card_int, align 1
  %bf.clear16 = and i8 %bf.load15, -3
  %bf.set17 = or i8 %bf.clear16, 2
  %bf.clear16.sink = select i1 %or.cond, i8 %bf.set17, i8 %bf.clear16
  store i8 %bf.clear16.sink, i8* %need_card_int, align 1
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define void @memstick_init_req(%struct.memstick_request* %mrq, i8 zeroext %tpc, i8* %buf, i64 %length) #0 {
entry:
  %tpc1 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 0
  store i8 %tpc, i8* %tpc1, align 8, !tbaa !42
  %conv = zext i8 %tpc to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  %data_dir = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load = load i8, i8* %data_dir, align 1
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  %bf.clear.sink = select i1 %tobool, i8 %bf.set, i8 %bf.clear
  store i8 %bf.clear.sink, i8* %data_dir, align 1
  %cmp = icmp ugt i64 %length, 15
  %.length = select i1 %cmp, i64 15, i64 %length
  %conv6 = trunc i64 %.length to i8
  %0 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 4
  %1 = bitcast %union.anon.47* %0 to %struct.anon.48*
  %data_len = getelementptr inbounds %struct.anon.48, %struct.anon.48* %1, i32 0, i32 0
  store i8 %conv6, i8* %data_len, align 8, !tbaa !46
  %data_dir7 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load8 = load i8, i8* %data_dir7, align 1
  %bf.clear9 = and i8 %bf.load8, 1
  %conv10 = zext i8 %bf.clear9 to i32
  %cmp11 = icmp eq i32 %conv10, 1
  br i1 %cmp11, label %if.then13, label %if.end16

if.then13:                                        ; preds = %entry
  %2 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 4
  %3 = bitcast %union.anon.47* %2 to %struct.anon.48*
  %data_len14 = getelementptr inbounds %struct.anon.48, %struct.anon.48* %3, i32 0, i32 0
  %4 = load i8, i8* %data_len14, align 8, !tbaa !46
  %conv15 = zext i8 %4 to i64
  %5 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 4
  %6 = bitcast %union.anon.47* %5 to %struct.anon.48*
  %data = getelementptr inbounds %struct.anon.48, %struct.anon.48* %6, i32 0, i32 1
  %arraydecay = getelementptr inbounds [15 x i8], [15 x i8]* %data, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %buf, i64 %conv15, i32 1, i1 false)
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %entry
  %long_data = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load17 = load i8, i8* %long_data, align 1
  %bf.clear18 = and i8 %bf.load17, -5
  store i8 %bf.clear18, i8* %long_data, align 1
  %conv19 = zext i8 %tpc to i32
  %cmp20 = icmp eq i32 %conv19, 14
  %conv22 = zext i8 %tpc to i32
  %cmp23 = icmp eq i32 %conv22, 9
  %or.cond = or i1 %cmp20, %cmp23
  %need_card_int = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %mrq, i32 0, i32 1
  %bf.load26 = load i8, i8* %need_card_int, align 1
  %bf.clear27 = and i8 %bf.load26, -3
  %bf.set28 = or i8 %bf.clear27, 2
  %bf.clear27.sink = select i1 %or.cond, i8 %bf.set28, i8 %bf.clear27
  store i8 %bf.clear27.sink, i8* %need_card_int, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @memstick_set_rw_addr(%struct.memstick_dev* %card) #0 {
entry:
  %next_request = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 6
  store i32 (%struct.memstick_dev*, %struct.memstick_request**)* @h_memstick_set_rw_addr, i32 (%struct.memstick_dev*, %struct.memstick_request**)** %next_request, align 8, !tbaa !35
  %host = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 1
  %0 = load %struct.memstick_host*, %struct.memstick_host** %host, align 8, !tbaa !47
  call void @memstick_new_req(%struct.memstick_host* %0)
  %mrq_complete = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 3
  call void @wait_for_completion(%struct.completion* %mrq_complete)
  %current_mrq = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 4
  %error = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %current_mrq, i32 0, i32 3
  %1 = load i32, i32* %error, align 4, !tbaa !48
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define internal i32 @h_memstick_set_rw_addr(%struct.memstick_dev* %card, %struct.memstick_request** %mrq) #0 {
entry:
  %0 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !2
  %tobool = icmp ne %struct.memstick_request* %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %current_mrq = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 4
  %reg_addr = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 2
  %1 = bitcast %struct.ms_register_addr* %reg_addr to i8*
  call void @memstick_init_req(%struct.memstick_request* %current_mrq, i8 zeroext 8, i8* %1, i64 4)
  %current_mrq1 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 4
  store %struct.memstick_request* %current_mrq1, %struct.memstick_request** %mrq, align 8, !tbaa !2
  br label %return

if.else:                                          ; preds = %entry
  %mrq_complete = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 3
  call void @complete(%struct.completion* %mrq_complete)
  br label %return

return:                                           ; preds = %if.else, %if.then
  %retval.0 = phi i32 [ -11, %if.else ], [ 0, %if.then ]
  ret i32 %retval.0
}

declare void @wait_for_completion(%struct.completion*) #3

; Function Attrs: nounwind uwtable
define %struct.memstick_host* @memstick_alloc_host(i32 %extra, %struct.device* %dev) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic64_t, align 8
  %conv = zext i32 %extra to i64
  %add = add i64 832, %conv
  %call = call i8* @kzalloc(i64 %add, i32 20971712)
  %0 = bitcast i8* %call to %struct.memstick_host*
  %tobool = icmp ne %struct.memstick_host* %0, null
  br i1 %tobool, label %do.body, label %if.end

do.body:                                          ; preds = %entry
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 0
  call void @__mutex_init(%struct.mutex* %lock, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0), %struct.lock_class_key* @memstick_alloc_host.__key)
  %media_checker = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 3
  call void @__init_work(%struct.work_struct* %media_checker, i32 0)
  %media_checker2 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 3
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %media_checker2, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral, i32 0, i32 0
  store i64 68719476704, i64* %counter, align 8, !tbaa !49
  %1 = bitcast %struct.atomic64_t* %data to i8*
  %2 = bitcast %struct.atomic64_t* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 8, i32 8, i1 false), !tbaa.struct !50
  %media_checker3 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 3
  %entry4 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %media_checker3, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry4)
  %media_checker5 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 3
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %media_checker5, i32 0, i32 2
  store void (%struct.work_struct*)* @memstick_check, void (%struct.work_struct*)** %func, align 8, !tbaa !51
  %dev8 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 4
  %class = getelementptr inbounds %struct.device, %struct.device* %dev8, i32 0, i32 31
  store %struct.class* @memstick_host_class, %struct.class** %class, align 8, !tbaa !52
  %dev9 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 4
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev9, i32 0, i32 0
  store %struct.device* %dev, %struct.device** %parent, align 8, !tbaa !53
  %dev10 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %0, i32 0, i32 4
  call void @device_initialize(%struct.device* %dev10)
  br label %if.end

if.end:                                           ; preds = %do.body, %entry
  ret %struct.memstick_host* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @__init_work(%struct.work_struct* %work, i32 %onstack) #1 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #1 {
entry:
  %__u = alloca %union.anon.49, align 8
  %0 = bitcast %union.anon.49* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %__val = bitcast %union.anon.49* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !46
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.49* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.49* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !46
  %3 = bitcast %union.anon.49* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #5
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !54
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @memstick_check(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -40
  %1 = bitcast i8* %add.ptr to %struct.memstick_host*
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 0
  call void @mutex_lock(%struct.mutex* %lock)
  %card1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %2 = load %struct.memstick_dev*, %struct.memstick_dev** %card1, align 32, !tbaa !34
  %tobool = icmp ne %struct.memstick_dev* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call i32 @memstick_power_on(%struct.memstick_host* %1)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %out_power_off, label %if.end11

if.else:                                          ; preds = %entry
  %card4 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %3 = load %struct.memstick_dev*, %struct.memstick_dev** %card4, align 32, !tbaa !34
  %stop = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %3, i32 0, i32 7
  %4 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %stop, align 8, !tbaa !55
  %tobool5 = icmp ne void (%struct.memstick_dev*)* %4, null
  br i1 %tobool5, label %if.then6, label %if.end11

if.then6:                                         ; preds = %if.else
  %card7 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %5 = load %struct.memstick_dev*, %struct.memstick_dev** %card7, align 32, !tbaa !34
  %stop8 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %5, i32 0, i32 7
  %6 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %stop8, align 8, !tbaa !55
  %card9 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %7 = load %struct.memstick_dev*, %struct.memstick_dev** %card9, align 32, !tbaa !34
  call void %6(%struct.memstick_dev* %7)
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then6, %if.then
  %call12 = call %struct.memstick_dev* @memstick_alloc_card(%struct.memstick_host* %1)
  %tobool13 = icmp ne %struct.memstick_dev* %call12, null
  %card22 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %8 = load %struct.memstick_dev*, %struct.memstick_dev** %card22, align 32, !tbaa !34
  %tobool23 = icmp ne %struct.memstick_dev* %8, null
  br i1 %tobool13, label %if.else21, label %if.then14

if.then14:                                        ; preds = %if.end11
  br i1 %tobool23, label %if.then17, label %out_power_off

if.then17:                                        ; preds = %if.then14
  %card18 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %9 = load %struct.memstick_dev*, %struct.memstick_dev** %card18, align 32, !tbaa !34
  %dev = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %9, i32 0, i32 9
  call void @device_unregister(%struct.device* %dev)
  %card19 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  store %struct.memstick_dev* null, %struct.memstick_dev** %card19, align 32, !tbaa !34
  br label %out_power_off

if.else21:                                        ; preds = %if.end11
  br i1 %tobool23, label %if.then24, label %if.end49

if.then24:                                        ; preds = %if.else21
  %card25 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %10 = load %struct.memstick_dev*, %struct.memstick_dev** %card25, align 32, !tbaa !34
  %call26 = call i32 @memstick_set_rw_addr(%struct.memstick_dev* %10)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.then36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then24
  %card28 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %11 = load %struct.memstick_dev*, %struct.memstick_dev** %card28, align 32, !tbaa !34
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %call12, i32 0, i32 0
  %call29 = call i32 @memstick_dev_match(%struct.memstick_dev* %11, %struct.memstick_device_id* %id)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %lor.lhs.false31, label %if.then36

lor.lhs.false31:                                  ; preds = %lor.lhs.false
  %card32 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %12 = load %struct.memstick_dev*, %struct.memstick_dev** %card32, align 32, !tbaa !34
  %check = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %12, i32 0, i32 5
  %13 = load i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*)** %check, align 8, !tbaa !56
  %card33 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %14 = load %struct.memstick_dev*, %struct.memstick_dev** %card33, align 32, !tbaa !34
  %call34 = call i32 %13(%struct.memstick_dev* %14)
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.else40, label %if.then36

if.then36:                                        ; preds = %lor.lhs.false31, %lor.lhs.false, %if.then24
  %card37 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %15 = load %struct.memstick_dev*, %struct.memstick_dev** %card37, align 32, !tbaa !34
  %dev38 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %15, i32 0, i32 9
  call void @device_unregister(%struct.device* %dev38)
  %card39 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  store %struct.memstick_dev* null, %struct.memstick_dev** %card39, align 32, !tbaa !34
  br label %if.end49

if.else40:                                        ; preds = %lor.lhs.false31
  %card41 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %16 = load %struct.memstick_dev*, %struct.memstick_dev** %card41, align 32, !tbaa !34
  %start = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %16, i32 0, i32 8
  %17 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %start, align 8, !tbaa !57
  %tobool42 = icmp ne void (%struct.memstick_dev*)* %17, null
  br i1 %tobool42, label %if.then43, label %if.end49

if.then43:                                        ; preds = %if.else40
  %card44 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %18 = load %struct.memstick_dev*, %struct.memstick_dev** %card44, align 32, !tbaa !34
  %start45 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %18, i32 0, i32 8
  %19 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %start45, align 8, !tbaa !57
  %card46 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %20 = load %struct.memstick_dev*, %struct.memstick_dev** %card46, align 32, !tbaa !34
  call void %19(%struct.memstick_dev* %20)
  br label %if.end49

if.end49:                                         ; preds = %if.then36, %if.then43, %if.else40, %if.else21
  %card50 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %21 = load %struct.memstick_dev*, %struct.memstick_dev** %card50, align 32, !tbaa !34
  %tobool51 = icmp ne %struct.memstick_dev* %21, null
  br i1 %tobool51, label %if.else62, label %if.then52

if.then52:                                        ; preds = %if.end49
  %card53 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  store %struct.memstick_dev* %call12, %struct.memstick_dev** %card53, align 32, !tbaa !34
  %dev54 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %call12, i32 0, i32 9
  %call55 = call i32 @device_register(%struct.device* %dev54)
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %if.then57, label %out_power_off

if.then57:                                        ; preds = %if.then52
  %dev58 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %call12, i32 0, i32 9
  call void @put_device(%struct.device* %dev58)
  %card59 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %22 = load %struct.memstick_dev*, %struct.memstick_dev** %card59, align 32, !tbaa !34
  %23 = bitcast %struct.memstick_dev* %22 to i8*
  call void @kfree(i8* %23)
  %card60 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  store %struct.memstick_dev* null, %struct.memstick_dev** %card60, align 32, !tbaa !34
  br label %out_power_off

if.else62:                                        ; preds = %if.end49
  %24 = bitcast %struct.memstick_dev* %call12 to i8*
  call void @kfree(i8* %24)
  br label %out_power_off

out_power_off:                                    ; preds = %if.then17, %if.then14, %if.then52, %if.then57, %if.else62, %if.then
  %card65 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 5
  %25 = load %struct.memstick_dev*, %struct.memstick_dev** %card65, align 32, !tbaa !34
  %tobool66 = icmp ne %struct.memstick_dev* %25, null
  br i1 %tobool66, label %if.end69, label %if.then67

if.then67:                                        ; preds = %out_power_off
  %set_param = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 8
  %26 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param, align 8, !tbaa !58
  %call68 = call i32 %26(%struct.memstick_host* %1, i32 1, i32 0)
  br label %if.end69

if.end69:                                         ; preds = %if.then67, %out_power_off
  %lock70 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %1, i32 0, i32 0
  call void @mutex_unlock(%struct.mutex* %lock70)
  ret void
}

declare void @device_initialize(%struct.device*) #3

; Function Attrs: nounwind uwtable
define i32 @memstick_add_host(%struct.memstick_host* %host) #0 {
entry:
  call void @idr_preload(i32 20971712)
  call void @spin_lock(%struct.spinlock* @memstick_host_lock)
  %0 = bitcast %struct.memstick_host* %host to i8*
  %call = call i32 @idr_alloc(%struct.idr* @memstick_host_idr, i8* %0, i32 0, i32 0, i32 16777216)
  %cmp = icmp sge i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %id = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 1
  store i32 %call, i32* %id, align 32, !tbaa !59
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @spin_unlock(%struct.spinlock* @memstick_host_lock)
  call void @idr_preload_end()
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %dev = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  %id4 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 1
  %1 = load i32, i32* %id4, align 32, !tbaa !59
  %call5 = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i32 0, i32 0), i32 %1)
  %dev6 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  %call7 = call i32 @device_add(%struct.device* %dev6)
  %tobool = icmp ne i32 %call7, 0
  br i1 %tobool, label %if.then8, label %if.end11

if.then8:                                         ; preds = %if.end3
  call void @spin_lock(%struct.spinlock* @memstick_host_lock)
  %id9 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 1
  %2 = load i32, i32* %id9, align 32, !tbaa !59
  %call10 = call i8* @idr_remove(%struct.idr* @memstick_host_idr, i32 %2)
  call void @spin_unlock(%struct.spinlock* @memstick_host_lock)
  br label %cleanup

if.end11:                                         ; preds = %if.end3
  %set_param = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 8
  %3 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param, align 8, !tbaa !58
  %call12 = call i32 %3(%struct.memstick_host* %host, i32 1, i32 0)
  call void @memstick_detect_change(%struct.memstick_host* %host)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.end11, %if.then8
  %retval.0 = phi i32 [ %call7, %if.then8 ], [ 0, %if.end11 ], [ %call, %if.end ]
  ret i32 %retval.0
}

declare void @idr_preload(i32) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #4 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

declare i32 @idr_alloc(%struct.idr*, i8*, i32, i32, i32) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #4 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.1* %0 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @idr_preload_end() #1 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !60
  ret void
}

declare i32 @dev_set_name(%struct.device*, i8*, ...) #3

declare i32 @device_add(%struct.device*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @idr_remove(%struct.idr* %idr, i32 %id) #1 {
entry:
  %idr_rt = getelementptr inbounds %struct.idr, %struct.idr* %idr, i32 0, i32 0
  %conv = sext i32 %id to i64
  %call = call i8* @radix_tree_delete_item(%struct.radix_tree_root* %idr_rt, i64 %conv, i8* null)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define void @memstick_remove_host(%struct.memstick_host* %host) #0 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @workqueue, align 8, !tbaa !2
  call void @flush_workqueue(%struct.workqueue_struct* %0)
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_lock(%struct.mutex* %lock)
  %card = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %1 = load %struct.memstick_dev*, %struct.memstick_dev** %card, align 32, !tbaa !34
  %tobool = icmp ne %struct.memstick_dev* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %card1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %2 = load %struct.memstick_dev*, %struct.memstick_dev** %card1, align 32, !tbaa !34
  %dev = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %2, i32 0, i32 9
  call void @device_unregister(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %card2 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  store %struct.memstick_dev* null, %struct.memstick_dev** %card2, align 32, !tbaa !34
  %set_param = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 8
  %3 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param, align 8, !tbaa !58
  %call = call i32 %3(%struct.memstick_host* %host, i32 1, i32 0)
  %lock3 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_unlock(%struct.mutex* %lock3)
  call void @spin_lock(%struct.spinlock* @memstick_host_lock)
  %id = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 1
  %4 = load i32, i32* %id, align 32, !tbaa !59
  %call4 = call i8* @idr_remove(%struct.idr* @memstick_host_idr, i32 %4)
  call void @spin_unlock(%struct.spinlock* @memstick_host_lock)
  %dev5 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  call void @device_del(%struct.device* %dev5)
  ret void
}

declare void @flush_workqueue(%struct.workqueue_struct*) #3

declare void @mutex_lock(%struct.mutex*) #3

declare void @device_unregister(%struct.device*) #3

declare void @mutex_unlock(%struct.mutex*) #3

declare void @device_del(%struct.device*) #3

; Function Attrs: nounwind uwtable
define void @memstick_free_host(%struct.memstick_host* %host) #0 {
entry:
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_destroy(%struct.mutex* %lock)
  %dev = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  call void @put_device(%struct.device* %dev)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @mutex_destroy(%struct.mutex* %lock) #1 {
entry:
  ret void
}

declare void @put_device(%struct.device*) #3

; Function Attrs: nounwind uwtable
define void @memstick_suspend_host(%struct.memstick_host* %host) #0 {
entry:
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_lock(%struct.mutex* %lock)
  %set_param = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 8
  %0 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param, align 8, !tbaa !58
  %call = call i32 %0(%struct.memstick_host* %host, i32 1, i32 0)
  %lock1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_unlock(%struct.mutex* %lock1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @memstick_resume_host(%struct.memstick_host* %host) #0 {
entry:
  %lock = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_lock(%struct.mutex* %lock)
  %card = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %0 = load %struct.memstick_dev*, %struct.memstick_dev** %card, align 32, !tbaa !34
  %tobool = icmp ne %struct.memstick_dev* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @memstick_power_on(%struct.memstick_host* %host)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rc.0 = phi i32 [ %call, %if.then ], [ 0, %entry ]
  %lock1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 0
  call void @mutex_unlock(%struct.mutex* %lock1)
  %tobool2 = icmp ne i32 %rc.0, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  call void @memstick_detect_change(%struct.memstick_host* %host)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_power_on(%struct.memstick_host* %host) #0 {
entry:
  %set_param = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 8
  %0 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param, align 8, !tbaa !58
  %call = call i32 %0(%struct.memstick_host* %host, i32 1, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %set_param1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 8
  %1 = load i32 (%struct.memstick_host*, i32, i32)*, i32 (%struct.memstick_host*, i32, i32)** %set_param1, align 8, !tbaa !58
  %call2 = call i32 %1(%struct.memstick_host* %host, i32 2, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rc.0 = phi i32 [ %call, %entry ], [ %call2, %if.then ]
  ret i32 %rc.0
}

; Function Attrs: nounwind uwtable
define i32 @memstick_register_driver(%struct.memstick_driver* %drv) #0 {
entry:
  %driver = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %drv, i32 0, i32 5
  %bus = getelementptr inbounds %struct.device_driver, %struct.device_driver* %driver, i32 0, i32 1
  store %struct.bus_type* @memstick_bus_type, %struct.bus_type** %bus, align 8, !tbaa !61
  %driver1 = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %drv, i32 0, i32 5
  %call = call i32 @driver_register(%struct.device_driver* %driver1)
  ret i32 %call
}

declare i32 @driver_register(%struct.device_driver*) #3

; Function Attrs: nounwind uwtable
define void @memstick_unregister_driver(%struct.memstick_driver* %drv) #0 {
entry:
  %driver = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %drv, i32 0, i32 5
  call void @driver_unregister(%struct.device_driver* %driver)
  ret void
}

declare void @driver_unregister(%struct.device_driver*) #3

; Function Attrs: nounwind uwtable
define internal void @memstick_exit() #0 section ".exit.text" {
entry:
  call void @class_unregister(%struct.class* @memstick_host_class)
  call void @bus_unregister(%struct.bus_type* @memstick_bus_type)
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @workqueue, align 8, !tbaa !2
  call void @destroy_workqueue(%struct.workqueue_struct* %0)
  call void @idr_destroy(%struct.idr* @memstick_host_idr)
  ret void
}

declare void @class_unregister(%struct.class*) #3

declare void @bus_unregister(%struct.bus_type*) #3

declare void @destroy_workqueue(%struct.workqueue_struct*) #3

declare void @idr_destroy(%struct.idr*) #3

; Function Attrs: nounwind uwtable
define internal i32 @memstick_init() #0 section ".init.text" {
entry:
  %call = call %struct.workqueue_struct* (i8*, i32, i32, %struct.lock_class_key*, i8*, ...) @__alloc_workqueue_key(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i32 0, i32 0), i32 262158, i32 1, %struct.lock_class_key* null, i8* null, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.13, i32 0, i32 0))
  store %struct.workqueue_struct* %call, %struct.workqueue_struct** @workqueue, align 8, !tbaa !2
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @workqueue, align 8, !tbaa !2
  %tobool = icmp ne %struct.workqueue_struct* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @bus_register(%struct.bus_type* @memstick_bus_type)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %call4 = call i32 @__class_register(%struct.class* @memstick_host_class, %struct.lock_class_key* @memstick_init.__key)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %rc.0 = phi i32 [ %call1, %if.end ], [ %call4, %if.then3 ]
  %tobool6 = icmp ne i32 %rc.0, 0
  br i1 %tobool6, label %if.end8, label %cleanup

if.end8:                                          ; preds = %if.end5
  call void @bus_unregister(%struct.bus_type* @memstick_bus_type)
  %1 = load %struct.workqueue_struct*, %struct.workqueue_struct** @workqueue, align 8, !tbaa !2
  call void @destroy_workqueue(%struct.workqueue_struct* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %entry, %if.end8
  %retval.0 = phi i32 [ %rc.0, %if.end8 ], [ -12, %entry ], [ 0, %if.end5 ]
  ret i32 %retval.0
}

declare zeroext i1 @queue_work_on(i32, %struct.workqueue_struct*, %struct.work_struct*) #3

declare void @complete(%struct.completion*) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #4 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare noalias i8* @__kmalloc(i64, i32) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size(i8* %p, i8* %res, i32 %size) #4 {
entry:
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !46
  store volatile i8 %0, i8* %p, align 1, !tbaa !46
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !64
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !64
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !39
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !39
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !45
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !45
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !66
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !67
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.memstick_dev* @memstick_alloc_card(%struct.memstick_host* %host) #0 {
entry:
  %call = call i8* @kzalloc(i64 856, i32 20971712)
  %0 = bitcast i8* %call to %struct.memstick_dev*
  %card1 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  %1 = load %struct.memstick_dev*, %struct.memstick_dev** %card1, align 32, !tbaa !34
  %tobool = icmp ne %struct.memstick_dev* %0, null
  br i1 %tobool, label %if.then, label %if.end21

if.then:                                          ; preds = %entry
  %host2 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 1
  store %struct.memstick_host* %host, %struct.memstick_host** %host2, align 8, !tbaa !47
  %dev = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 9
  %dev3 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  %call4 = call i8* @dev_name(%struct.device* %dev3)
  %call5 = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i32 0, i32 0), i8* %call4)
  %dev6 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 4
  %dev7 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 9
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev7, i32 0, i32 0
  store %struct.device* %dev6, %struct.device** %parent, align 8, !tbaa !68
  %dev8 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 9
  %bus = getelementptr inbounds %struct.device, %struct.device* %dev8, i32 0, i32 6
  store %struct.bus_type* @memstick_bus_type, %struct.bus_type** %bus, align 8, !tbaa !69
  %dev9 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 9
  %release = getelementptr inbounds %struct.device, %struct.device* %dev9, i32 0, i32 33
  store void (%struct.device*)* @memstick_free_card, void (%struct.device*)** %release, align 8, !tbaa !70
  %check = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 5
  store i32 (%struct.memstick_dev*)* @memstick_dummy_check, i32 (%struct.memstick_dev*)** %check, align 8, !tbaa !56
  %reg_addr = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 2
  %r_offset = getelementptr inbounds %struct.ms_register_addr, %struct.ms_register_addr* %reg_addr, i32 0, i32 0
  store i8 4, i8* %r_offset, align 8, !tbaa !71
  %reg_addr10 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 2
  %r_length = getelementptr inbounds %struct.ms_register_addr, %struct.ms_register_addr* %reg_addr10, i32 0, i32 1
  store i8 4, i8* %r_length, align 1, !tbaa !72
  %reg_addr11 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 2
  %w_offset = getelementptr inbounds %struct.ms_register_addr, %struct.ms_register_addr* %reg_addr11, i32 0, i32 2
  store i8 4, i8* %w_offset, align 2, !tbaa !73
  %reg_addr12 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 2
  %w_length = getelementptr inbounds %struct.ms_register_addr, %struct.ms_register_addr* %reg_addr12, i32 0, i32 3
  store i8 4, i8* %w_length, align 1, !tbaa !74
  %mrq_complete = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 3
  call void @init_completion(%struct.completion* %mrq_complete)
  %card13 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  store %struct.memstick_dev* %0, %struct.memstick_dev** %card13, align 32, !tbaa !34
  %call14 = call i32 @memstick_set_rw_addr(%struct.memstick_dev* %0)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %err_out, label %if.end

if.end:                                           ; preds = %if.then
  %next_request = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 6
  store i32 (%struct.memstick_dev*, %struct.memstick_request**)* @h_memstick_read_dev_id, i32 (%struct.memstick_dev*, %struct.memstick_request**)** %next_request, align 8, !tbaa !35
  call void @memstick_new_req(%struct.memstick_host* %host)
  %mrq_complete17 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 3
  call void @wait_for_completion(%struct.completion* %mrq_complete17)
  %current_mrq = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %0, i32 0, i32 4
  %error = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %current_mrq, i32 0, i32 3
  %2 = load i32, i32* %error, align 4, !tbaa !48
  %tobool18 = icmp ne i32 %2, 0
  br i1 %tobool18, label %err_out, label %if.end21

if.end21:                                         ; preds = %if.end, %entry
  %card22 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  store %struct.memstick_dev* %1, %struct.memstick_dev** %card22, align 32, !tbaa !34
  br label %cleanup

err_out:                                          ; preds = %if.end, %if.then
  %card23 = getelementptr inbounds %struct.memstick_host, %struct.memstick_host* %host, i32 0, i32 5
  store %struct.memstick_dev* %1, %struct.memstick_dev** %card23, align 32, !tbaa !34
  %3 = bitcast %struct.memstick_dev* %0 to i8*
  call void @kfree(i8* %3)
  br label %cleanup

cleanup:                                          ; preds = %err_out, %if.end21
  %retval.0 = phi %struct.memstick_dev* [ null, %err_out ], [ %0, %if.end21 ]
  ret %struct.memstick_dev* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_dev_match(%struct.memstick_dev* %card, %struct.memstick_device_id* %id) #0 {
entry:
  %match_flags = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 0
  %0 = load i8, i8* %match_flags, align 1, !tbaa !75
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end20

if.then:                                          ; preds = %entry
  %type = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 1
  %1 = load i8, i8* %type, align 1, !tbaa !76
  %conv1 = zext i8 %1 to i32
  %id2 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %type3 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id2, i32 0, i32 1
  %2 = load i8, i8* %type3, align 1, !tbaa !77
  %conv4 = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv1, %conv4
  br i1 %cmp, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.then
  %category = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 2
  %3 = load i8, i8* %category, align 1, !tbaa !78
  %conv6 = zext i8 %3 to i32
  %id7 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %category8 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id7, i32 0, i32 2
  %4 = load i8, i8* %category8, align 2, !tbaa !79
  %conv9 = zext i8 %4 to i32
  %cmp10 = icmp eq i32 %conv6, %conv9
  br i1 %cmp10, label %land.lhs.true12, label %if.end20

land.lhs.true12:                                  ; preds = %land.lhs.true
  %class = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 3
  %5 = load i8, i8* %class, align 1, !tbaa !80
  %conv13 = zext i8 %5 to i32
  %id14 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %class15 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id14, i32 0, i32 3
  %6 = load i8, i8* %class15, align 1, !tbaa !81
  %conv16 = zext i8 %6 to i32
  %cmp17 = icmp eq i32 %conv13, %conv16
  br i1 %cmp17, label %return, label %if.end20

if.end20:                                         ; preds = %if.then, %land.lhs.true, %land.lhs.true12, %entry
  br label %return

return:                                           ; preds = %land.lhs.true12, %if.end20
  %retval.0 = phi i32 [ 0, %if.end20 ], [ 1, %land.lhs.true12 ]
  ret i32 %retval.0
}

declare i32 @device_register(%struct.device*) #3

declare void @kfree(i8*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name(%struct.device* %dev) #1 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !82
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !82
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @memstick_free_card(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %2 = bitcast %struct.memstick_dev* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_dummy_check(%struct.memstick_dev* %card) #0 {
entry:
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @init_completion(%struct.completion* %x) #1 {
entry:
  %done = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 0
  store i32 0, i32* %done, align 8, !tbaa !41
  %wait = getelementptr inbounds %struct.completion, %struct.completion* %x, i32 0, i32 1
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.3, i32 0, i32 0), %struct.lock_class_key* @init_completion.__key)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @h_memstick_read_dev_id(%struct.memstick_dev* %card, %struct.memstick_request** %mrq) #0 {
entry:
  %id_reg = alloca %struct.ms_id_register, align 1
  %0 = bitcast %struct.ms_id_register* %id_reg to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #5
  %1 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !2
  %tobool = icmp ne %struct.memstick_request* %1, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %current_mrq = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 4
  %2 = bitcast %struct.ms_id_register* %id_reg to i8*
  call void @memstick_init_req(%struct.memstick_request* %current_mrq, i8 zeroext 4, i8* %2, i64 4)
  %current_mrq1 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 4
  store %struct.memstick_request* %current_mrq1, %struct.memstick_request** %mrq, align 8, !tbaa !2
  br label %cleanup

if.else:                                          ; preds = %entry
  %3 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !2
  %error = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %3, i32 0, i32 3
  %4 = load i32, i32* %error, align 4, !tbaa !6
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.end14, label %if.then3

if.then3:                                         ; preds = %if.else
  %cmp = icmp uge i64 4, 64
  %5 = bitcast %struct.ms_id_register* %id_reg to i8*
  %6 = load %struct.memstick_request*, %struct.memstick_request** %mrq, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.memstick_request, %struct.memstick_request* %6, i32 0, i32 4
  %8 = bitcast %union.anon.47* %7 to %struct.anon.48*
  %data = getelementptr inbounds %struct.anon.48, %struct.anon.48* %8, i32 0, i32 1
  %arraydecay = getelementptr inbounds [15 x i8], [15 x i8]* %data, i32 0, i32 0
  br i1 %cmp, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.then3
  %call = call i8* @__memcpy(i8* %5, i8* %arraydecay, i64 4)
  br label %if.end

if.else5:                                         ; preds = %if.then3
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %arraydecay, i64 4, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else5, %if.then4
  %__ret.0 = phi i8* [ %call, %if.then4 ], [ %5, %if.else5 ]
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %match_flags = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 0
  store i8 1, i8* %match_flags, align 8, !tbaa !83
  %type = getelementptr inbounds %struct.ms_id_register, %struct.ms_id_register* %id_reg, i32 0, i32 0
  %9 = load i8, i8* %type, align 1, !tbaa !84
  %id8 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %type9 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id8, i32 0, i32 1
  store i8 %9, i8* %type9, align 1, !tbaa !77
  %category = getelementptr inbounds %struct.ms_id_register, %struct.ms_id_register* %id_reg, i32 0, i32 2
  %10 = load i8, i8* %category, align 1, !tbaa !86
  %id10 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %category11 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id10, i32 0, i32 2
  store i8 %10, i8* %category11, align 2, !tbaa !79
  %class = getelementptr inbounds %struct.ms_id_register, %struct.ms_id_register* %id_reg, i32 0, i32 3
  %11 = load i8, i8* %class, align 1, !tbaa !87
  %id12 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 0
  %class13 = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id12, i32 0, i32 3
  store i8 %11, i8* %class13, align 1, !tbaa !81
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.else
  %mrq_complete = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %card, i32 0, i32 3
  call void @complete(%struct.completion* %mrq_complete)
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.then
  %retval.0 = phi i32 [ -11, %if.end14 ], [ 0, %if.then ]
  %12 = bitcast %struct.ms_id_register* %id_reg to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #5
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name(%struct.kobject* %kobj) #1 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !88
  ret i8* %0
}

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #3

declare i8* @__memcpy(i8*, i8*, i64) #3

; Function Attrs: nounwind uwtable
define internal void @memstick_free(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -72
  %1 = bitcast i8* %add.ptr to %struct.memstick_host*
  %2 = bitcast %struct.memstick_host* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

declare void @_raw_spin_lock(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @__raw_spin_unlock(%struct.raw_spinlock* %lock) #1 {
entry:
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %lock)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !89
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @do_raw_spin_unlock(%struct.raw_spinlock* %lock) #1 {
entry:
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %lock, i32 0, i32 0
  call void @queued_spin_unlock(%struct.qspinlock* %raw_lock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queued_spin_unlock(%struct.qspinlock* %lock) #1 {
entry:
  call void @native_queued_spin_unlock(%struct.qspinlock* %lock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @native_queued_spin_unlock(%struct.qspinlock* %lock) #1 {
entry:
  %__u = alloca %union.anon.50, align 1
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then, label %do.body2

if.then:                                          ; preds = %entry
  call void @__compiletime_assert_17()
  br label %do.body2

do.body2:                                         ; preds = %entry, %if.then
  %tobool3 = trunc i8 0 to i1
  %conv = zext i1 %tobool3 to i32
  %mul = mul nsw i32 2, %conv
  %sub = sub nsw i32 1, %mul
  %0 = zext i32 %sub to i64
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !90
  %1 = bitcast %union.anon.50* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %1) #5
  %2 = bitcast %union.anon.50* %__u to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 1, i32 1, i1 false)
  %3 = bitcast %struct.qspinlock* %lock to i8*
  %__c = bitcast %union.anon.50* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %3, i8* %arraydecay, i32 1)
  %__val = bitcast %union.anon.50* %__u to i8*
  %4 = load i8, i8* %__val, align 1, !tbaa !46
  %5 = bitcast %union.anon.50* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %5) #5
  ret void
}

declare void @__compiletime_assert_17() #3

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

declare i8* @radix_tree_delete_item(%struct.radix_tree_root*, i64, i8*) #3

; Function Attrs: nounwind uwtable
define internal i32 @memstick_bus_match(%struct.device* %dev, %struct.device_driver* %drv) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %2 = bitcast %struct.device_driver* %drv to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 -40
  %3 = bitcast i8* %add.ptr3 to %struct.memstick_driver*
  %id_table = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %3, i32 0, i32 0
  %4 = load %struct.memstick_device_id*, %struct.memstick_device_id** %id_table, align 8, !tbaa !91
  %tobool = icmp ne %struct.memstick_device_id* %4, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then
  %ids.0 = phi %struct.memstick_device_id* [ %4, %if.then ], [ %incdec.ptr, %if.end ]
  %match_flags = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %ids.0, i32 0, i32 0
  %5 = load i8, i8* %match_flags, align 1, !tbaa !75
  %tobool4 = icmp ne i8 %5, 0
  br i1 %tobool4, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %call = call i32 @memstick_dev_match(%struct.memstick_dev* %1, %struct.memstick_device_id* %ids.0)
  %tobool5 = icmp ne i32 %call, 0
  br i1 %tobool5, label %cleanup, label %if.end

if.end:                                           ; preds = %while.body
  %incdec.ptr = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %ids.0, i32 1
  br label %while.cond

cleanup:                                          ; preds = %entry, %while.cond, %while.body
  %retval.0 = phi i32 [ 1, %while.body ], [ 0, %while.cond ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %type = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 1
  %2 = load i8, i8* %type, align 1, !tbaa !77
  %conv = zext i8 %2 to i32
  %call = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.10, i32 0, i32 0), i32 %conv)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %id1 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %category = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id1, i32 0, i32 2
  %3 = load i8, i8* %category, align 2, !tbaa !79
  %conv2 = zext i8 %3 to i32
  %call3 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11, i32 0, i32 0), i32 %conv2)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %id7 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %class = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id7, i32 0, i32 3
  %4 = load i8, i8* %class, align 1, !tbaa !81
  %conv8 = zext i8 %4 to i32
  %call9 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.12, i32 0, i32 0), i32 %conv8)
  %tobool10 = icmp ne i32 %call9, 0
  %. = select i1 %tobool10, i32 -12, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end, %entry
  %retval.0 = phi i32 [ -12, %entry ], [ -12, %if.end ], [ %., %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_device_probe(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !92
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.memstick_driver*
  %driver4 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver4, align 8, !tbaa !92
  %tobool = icmp ne %struct.device_driver* %5, null
  br i1 %tobool, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %entry
  %probe = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 1
  %6 = load i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*)** %probe, align 8, !tbaa !93
  %tobool5 = icmp ne i32 (%struct.memstick_dev*)* %6, null
  br i1 %tobool5, label %if.then, label %if.end10

if.then:                                          ; preds = %land.lhs.true
  %probe6 = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 1
  %7 = load i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*)** %probe6, align 8, !tbaa !93
  %call = call i32 %7(%struct.memstick_dev* %1)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.then
  %call9 = call %struct.device* @get_device(%struct.device* %dev)
  br label %if.end10

if.end10:                                         ; preds = %if.then, %if.then8, %land.lhs.true, %entry
  %rc.0 = phi i32 [ -19, %land.lhs.true ], [ -19, %entry ], [ %call, %if.then8 ], [ %call, %if.then ]
  ret i32 %rc.0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_device_remove(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !92
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.memstick_driver*
  %driver4 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver4, align 8, !tbaa !92
  %tobool = icmp ne %struct.device_driver* %5, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %remove = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 2
  %6 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %remove, align 8, !tbaa !94
  %tobool5 = icmp ne void (%struct.memstick_dev*)* %6, null
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %remove6 = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 2
  %7 = load void (%struct.memstick_dev*)*, void (%struct.memstick_dev*)** %remove6, align 8, !tbaa !94
  call void %7(%struct.memstick_dev* %1)
  %dev7 = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 9
  %driver8 = getelementptr inbounds %struct.device, %struct.device* %dev7, i32 0, i32 7
  store %struct.device_driver* null, %struct.device_driver** %driver8, align 8, !tbaa !95
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  call void @put_device(%struct.device* %dev)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_device_suspend(%struct.device* %dev, i32 %state.coerce) #0 {
entry:
  %state = alloca %struct.pm_message, align 4
  %coerce.dive = getelementptr inbounds %struct.pm_message, %struct.pm_message* %state, i32 0, i32 0
  store i32 %state.coerce, i32* %coerce.dive, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !92
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.memstick_driver*
  %driver4 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver4, align 8, !tbaa !92
  %tobool = icmp ne %struct.device_driver* %5, null
  br i1 %tobool, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %entry
  %suspend = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 3
  %6 = load i32 (%struct.memstick_dev*, i32)*, i32 (%struct.memstick_dev*, i32)** %suspend, align 8, !tbaa !96
  %tobool5 = icmp ne i32 (%struct.memstick_dev*, i32)* %6, null
  br i1 %tobool5, label %if.then, label %cleanup

if.then:                                          ; preds = %land.lhs.true
  %suspend6 = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 3
  %7 = load i32 (%struct.memstick_dev*, i32)*, i32 (%struct.memstick_dev*, i32)** %suspend6, align 8, !tbaa !96
  %coerce.dive7 = getelementptr inbounds %struct.pm_message, %struct.pm_message* %state, i32 0, i32 0
  %8 = load i32, i32* %coerce.dive7, align 4
  %call = call i32 %7(%struct.memstick_dev* %1, i32 %8)
  br label %cleanup

cleanup:                                          ; preds = %entry, %land.lhs.true, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @memstick_device_resume(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %2 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !92
  %3 = bitcast %struct.device_driver* %2 to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.memstick_driver*
  %driver4 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver4, align 8, !tbaa !92
  %tobool = icmp ne %struct.device_driver* %5, null
  br i1 %tobool, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %entry
  %resume = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 4
  %6 = load i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*)** %resume, align 8, !tbaa !97
  %tobool5 = icmp ne i32 (%struct.memstick_dev*)* %6, null
  br i1 %tobool5, label %if.then, label %cleanup

if.then:                                          ; preds = %land.lhs.true
  %resume6 = getelementptr inbounds %struct.memstick_driver, %struct.memstick_driver* %4, i32 0, i32 4
  %7 = load i32 (%struct.memstick_dev*)*, i32 (%struct.memstick_dev*)** %resume6, align 8, !tbaa !97
  %call = call i32 %7(%struct.memstick_dev* %1)
  br label %cleanup

cleanup:                                          ; preds = %entry, %land.lhs.true, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @type_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %type = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 1
  %2 = load i8, i8* %type, align 1, !tbaa !77
  %conv = zext i8 %2 to i32
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  ret i64 %conv1
}

declare i32 @sprintf(i8*, i8*, ...) #3

; Function Attrs: nounwind uwtable
define internal i64 @category_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %category = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 2
  %2 = load i8, i8* %category, align 2, !tbaa !79
  %conv = zext i8 %2 to i32
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @class_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.memstick_dev*
  %id = getelementptr inbounds %struct.memstick_dev, %struct.memstick_dev* %1, i32 0, i32 0
  %class = getelementptr inbounds %struct.memstick_device_id, %struct.memstick_device_id* %id, i32 0, i32 3
  %2 = load i8, i8* %class, align 1, !tbaa !81
  %conv = zext i8 %2 to i32
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  ret i64 %conv1
}

declare i32 @add_uevent_var(%struct.kobj_uevent_env*, i8*, ...) #3

declare %struct.device* @get_device(%struct.device*) #3

declare %struct.workqueue_struct* @__alloc_workqueue_key(i8*, i32, i32, %struct.lock_class_key*, i8*, ...) #3

declare i32 @bus_register(%struct.bus_type*) #3

declare i32 @__class_register(%struct.class*, %struct.lock_class_key*) #3

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"any pointer", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !8, i64 4}
!7 = !{!"memstick_request", !4, i64 0, !4, i64 1, !4, i64 1, !4, i64 1, !4, i64 2, !8, i64 4, !4, i64 8}
!8 = !{!"int", !4, i64 0}
!9 = !{!10, !8, i64 808}
!10 = !{!"memstick_host", !11, i64 0, !8, i64 32, !8, i64 36, !18, i64 40, !19, i64 72, !3, i64 800, !8, i64 808, !3, i64 816, !3, i64 824, !4, i64 832}
!11 = !{!"mutex", !12, i64 0, !14, i64 8, !15, i64 12, !17, i64 16}
!12 = !{!"", !13, i64 0}
!13 = !{!"long", !4, i64 0}
!14 = !{!"spinlock", !4, i64 0}
!15 = !{!"optimistic_spin_queue", !16, i64 0}
!16 = !{!"", !8, i64 0}
!17 = !{!"list_head", !3, i64 0, !3, i64 8}
!18 = !{!"work_struct", !12, i64 0, !17, i64 8, !3, i64 24}
!19 = !{!"device", !3, i64 0, !3, i64 8, !20, i64 16, !3, i64 80, !3, i64 88, !11, i64 96, !3, i64 128, !3, i64 136, !3, i64 144, !3, i64 152, !23, i64 160, !24, i64 200, !3, i64 488, !3, i64 496, !17, i64 504, !8, i64 520, !3, i64 528, !3, i64 536, !31, i64 544, !13, i64 552, !3, i64 560, !17, i64 568, !3, i64 584, !32, i64 592, !3, i64 600, !3, i64 608, !8, i64 616, !8, i64 620, !14, i64 624, !17, i64 632, !33, i64 648, !3, i64 680, !3, i64 688, !3, i64 696, !3, i64 704, !3, i64 712, !26, i64 720, !26, i64 720}
!20 = !{!"kobject", !3, i64 0, !17, i64 8, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !21, i64 56, !8, i64 60, !8, i64 60, !8, i64 60, !8, i64 60, !8, i64 60}
!21 = !{!"kref", !22, i64 0}
!22 = !{!"refcount_struct", !16, i64 0}
!23 = !{!"dev_links_info", !17, i64 0, !17, i64 16, !4, i64 32}
!24 = !{!"dev_pm_info", !25, i64 0, !8, i64 4, !8, i64 4, !26, i64 4, !26, i64 4, !26, i64 4, !26, i64 4, !26, i64 4, !26, i64 4, !26, i64 5, !14, i64 8, !17, i64 16, !27, i64 32, !3, i64 64, !26, i64 72, !26, i64 72, !26, i64 72, !29, i64 80, !13, i64 128, !18, i64 136, !28, i64 168, !3, i64 192, !16, i64 200, !16, i64 204, !8, i64 208, !8, i64 208, !8, i64 208, !8, i64 208, !8, i64 208, !8, i64 208, !26, i64 209, !8, i64 209, !8, i64 209, !8, i64 209, !8, i64 209, !8, i64 209, !8, i64 212, !4, i64 216, !4, i64 220, !8, i64 224, !8, i64 228, !13, i64 232, !13, i64 240, !13, i64 248, !13, i64 256, !3, i64 264, !3, i64 272, !3, i64 280}
!25 = !{!"pm_message", !8, i64 0}
!26 = !{!"_Bool", !4, i64 0}
!27 = !{!"completion", !8, i64 0, !28, i64 8}
!28 = !{!"__wait_queue_head", !14, i64 0, !17, i64 8}
!29 = !{!"timer_list", !30, i64 0, !13, i64 16, !3, i64 24, !13, i64 32, !8, i64 40}
!30 = !{!"hlist_node", !3, i64 0, !3, i64 8}
!31 = !{!"long long", !4, i64 0}
!32 = !{!"dev_archdata", !3, i64 0}
!33 = !{!"klist_node", !3, i64 0, !17, i64 8, !21, i64 24}
!34 = !{!10, !3, i64 800}
!35 = !{!36, !3, i64 104}
!36 = !{!"memstick_dev", !37, i64 0, !3, i64 8, !38, i64 16, !27, i64 24, !7, i64 56, !3, i64 96, !3, i64 104, !3, i64 112, !3, i64 120, !19, i64 128}
!37 = !{!"memstick_device_id", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3}
!38 = !{!"ms_register_addr", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3}
!39 = !{!8, !8, i64 0}
!40 = !{!10, !3, i64 816}
!41 = !{!27, !8, i64 0}
!42 = !{!7, !4, i64 0}
!43 = !{i64 0, i64 8, !44, i64 8, i64 4, !39, i64 12, i64 4, !39, i64 16, i64 8, !45, i64 24, i64 4, !39}
!44 = !{!13, !13, i64 0}
!45 = !{!31, !31, i64 0}
!46 = !{!4, !4, i64 0}
!47 = !{!36, !3, i64 8}
!48 = !{!36, !8, i64 60}
!49 = !{!12, !13, i64 0}
!50 = !{i64 0, i64 8, !44}
!51 = !{!18, !3, i64 24}
!52 = !{!10, !3, i64 752}
!53 = !{!10, !3, i64 72}
!54 = !{!17, !3, i64 8}
!55 = !{!36, !3, i64 112}
!56 = !{!36, !3, i64 96}
!57 = !{!36, !3, i64 120}
!58 = !{!10, !3, i64 824}
!59 = !{!10, !8, i64 32}
!60 = !{i32 -2145018224}
!61 = !{!62, !3, i64 48}
!62 = !{!"memstick_driver", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !63, i64 40}
!63 = !{!"device_driver", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !26, i64 32, !4, i64 36, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !3, i64 112}
!64 = !{!65, !65, i64 0}
!65 = !{!"short", !4, i64 0}
!66 = !{i32 -2147304335}
!67 = !{i32 -2147304297}
!68 = !{!36, !3, i64 128}
!69 = !{!36, !3, i64 256}
!70 = !{!36, !3, i64 824}
!71 = !{!36, !4, i64 16}
!72 = !{!36, !4, i64 17}
!73 = !{!36, !4, i64 18}
!74 = !{!36, !4, i64 19}
!75 = !{!37, !4, i64 0}
!76 = !{!37, !4, i64 1}
!77 = !{!36, !4, i64 1}
!78 = !{!37, !4, i64 2}
!79 = !{!36, !4, i64 2}
!80 = !{!37, !4, i64 3}
!81 = !{!36, !4, i64 3}
!82 = !{!19, !3, i64 80}
!83 = !{!36, !4, i64 0}
!84 = !{!85, !4, i64 0}
!85 = !{!"ms_id_register", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3}
!86 = !{!85, !4, i64 2}
!87 = !{!85, !4, i64 3}
!88 = !{!20, !3, i64 0}
!89 = !{i32 -2146397976}
!90 = !{i32 -2146425951}
!91 = !{!62, !3, i64 0}
!92 = !{!19, !3, i64 136}
!93 = !{!62, !3, i64 8}
!94 = !{!62, !3, i64 16}
!95 = !{!36, !3, i64 264}
!96 = !{!62, !3, i64 24}
!97 = !{!62, !3, i64 32}
