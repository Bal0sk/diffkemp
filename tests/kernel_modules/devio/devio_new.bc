; ModuleID = 'drivers/usb/core/devio.bc'
source_filename = "drivers/usb/core/devio.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.atomic64_t = type { i64 }
%struct.spinlock = type { %union.anon }
%union.anon = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, [12 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon.0, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon.0 = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.49, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, [56 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.4, i32 }
%union.anon.4 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.5, %union.anon.33, %union.anon.34, %union.anon.38, %union.anon.41, [8 x i8] }
%union.anon.5 = type { %struct.address_space* }
%union.anon.33 = type { i64 }
%union.anon.34 = type { i64 }
%union.anon.38 = type { %struct.list_head }
%union.anon.41 = type { i64 }
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.mem_cgroup = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct* }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, i32, %struct.task_struct*, %struct.vm_struct*, %struct.atomic_t, [28 x i8], %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.6, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon.6 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type {}
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type {}
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.7 }
%union.anon.7 = type { %struct.anon.8 }
%struct.anon.8 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.cgroup_namespace* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.cgroup_namespace = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, %struct.pid*, i32, %struct.tty_struct*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, %struct.tty_audit_buf*, i8, i16, i16, %struct.mm_struct*, %struct.mutex }
%struct.cpu_itimer = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic, i8, i8 }
%struct.task_cputime_atomic = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.tty_struct = type opaque
%struct.seqlock_t = type { %struct.seqcount, %struct.spinlock }
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.13 }
%union.anon.13 = type { %struct.anon.17, [80 x i8] }
%struct.anon.17 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.compat_robust_list, i32, i32 }
%struct.compat_robust_list = type { i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.vm_struct = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.23 }
%union.anon.23 = type { %struct.anon.24 }
%struct.anon.24 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.26, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.29 }
%union.anon.26 = type { %struct.anon.27 }
%struct.anon.27 = type { i64, i64 }
%union.anon.29 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, %struct.kuid_t, %struct.kgid_t, %struct.ns_common, i64, %struct.work_struct, %struct.ctl_table_set, %struct.ctl_table_header*, %struct.ucounts*, [9 x i32] }
%struct.uid_gid_map = type { i32, [5 x %struct.uid_gid_extent] }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.kgid_t = type { i32 }
%struct.ns_common = type { %struct.atomic64_t, %struct.proc_ns_operations*, i32 }
%struct.proc_ns_operations = type opaque
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.11, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node*, %struct.list_head }
%union.anon.11 = type { %struct.anon.12 }
%struct.anon.12 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.__wait_queue_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*)*, void (%struct.ctl_table_header*, %struct.ctl_table*, %struct.kuid_t*, %struct.kgid_t*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.ucounts = type { %struct.hlist_node, %struct.user_namespace*, %struct.kuid_t, i32, [9 x %struct.atomic_t] }
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, [32 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%union.anon.49 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.42, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.43, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.42 = type { i32 }
%struct.timespec = type { i64, i64 }
%union.anon.43 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.1, [64 x i8*], [3 x [1 x i64]] }
%union.anon.1 = type { %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type { i32, i64, i64, %union.anon.30, %union.anon.31 }
%union.anon.30 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%union.anon.31 = type { i64 }
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.53, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.53 = type { i64 }
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, i64, %struct.atomic64_t, %struct.key*, %struct.key*, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %struct.pmd_t*, %struct.pud_t*, %struct.pte_t, %struct.page*, %struct.mem_cgroup*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%struct.pte_t = type { i64 }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%union.anon.51 = type { i8* }
%struct.usb_driver = type { i8*, i32 (%struct.usb_interface*, %struct.usb_device_id*)*, void (%struct.usb_interface*)*, i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, %struct.usb_device_id*, %struct.usb_dynids, %struct.usbdrv_wrap, i8 }
%struct.usb_interface = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device, %struct.device*, %struct.atomic_t, %struct.work_struct }
%struct.usb_host_interface = type { %struct.usb_interface_descriptor, i32, i8*, %struct.usb_host_endpoint*, i8* }
%struct.usb_interface_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.usb_host_endpoint = type <{ %struct.usb_endpoint_descriptor, %struct.usb_ss_ep_comp_descriptor, %struct.usb_ssp_isoc_ep_comp_descriptor, i8, %struct.list_head, i8*, %struct.ep_device*, i8*, i32, i32, i32, [4 x i8] }>
%struct.usb_endpoint_descriptor = type <{ i8, i8, i8, i8, i16, i8, i8, i8 }>
%struct.usb_ss_ep_comp_descriptor = type { i8, i8, i8, i8, i16 }
%struct.usb_ssp_isoc_ep_comp_descriptor = type { i8, i8, i16, i32 }
%struct.ep_device = type opaque
%struct.usb_interface_assoc_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type opaque
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.usb_device_id = type { i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8, i64 }
%struct.usb_dynids = type { %struct.spinlock, %struct.list_head }
%struct.usbdrv_wrap = type { %struct.device_driver, i32 }
%struct.cdev = type { %struct.kobject, %struct.module*, %struct.file_operations*, %struct.list_head, i32, i32 }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.usb_dev_state = type { %struct.list_head, %struct.usb_device*, %struct.file*, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head, %struct.__wait_queue_head, i32, %struct.pid*, %struct.cred*, i8*, i64, i32, i32, i8, i64 }
%struct.usb_device = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt*, i32, [2 x i32], %struct.usb_device*, %struct.usb_bus*, %struct.usb_host_endpoint, %struct.device, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config*, %struct.usb_host_config*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %struct.atomic_t, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.usb2_lpm_parameters, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_tt = type { %struct.usb_device*, i32, i32, i8*, %struct.spinlock, %struct.list_head, %struct.work_struct }
%struct.usb_bus = type { %struct.device*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.mutex, %struct.usb_devmap, %struct.usb_device*, %struct.usb_bus*, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_devmap = type { [2 x i64] }
%struct.mon_bus = type opaque
%struct.usb_device_descriptor = type { i8, i8, i16, i8, i8, i8, i8, i16, i16, i16, i8, i8, i8, i8 }
%struct.usb_host_bos = type { %struct.usb_bos_descriptor*, %struct.usb_ext_cap_descriptor*, %struct.usb_ss_cap_descriptor*, %struct.usb_ssp_cap_descriptor*, %struct.usb_ss_container_id_descriptor*, %struct.usb_ptm_cap_descriptor* }
%struct.usb_bos_descriptor = type <{ i8, i8, i16, i8 }>
%struct.usb_ext_cap_descriptor = type <{ i8, i8, i8, i32 }>
%struct.usb_ss_cap_descriptor = type { i8, i8, i8, i8, i16, i8, i8, i16 }
%struct.usb_ssp_cap_descriptor = type { i8, i8, i8, i8, i32, i16, i16, [1 x i32] }
%struct.usb_ss_container_id_descriptor = type { i8, i8, i8, i8, [16 x i8] }
%struct.usb_ptm_cap_descriptor = type { i8, i8, i8 }
%struct.usb_host_config = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_config_descriptor = type <{ i8, i8, i16, i8, i8, i8, i8, i8 }>
%struct.usb_interface_cache = type { i32, %struct.kref, [0 x %struct.usb_host_interface] }
%struct.wusb_dev = type opaque
%struct.usb2_lpm_parameters = type { i32, i32 }
%struct.usb3_lpm_parameters = type { i32, i32, i32, i32 }
%struct.usb_memory = type { %struct.list_head, i32, i32, i32, i8*, i64, i64, %struct.usb_dev_state* }
%struct.async = type { %struct.list_head, %struct.usb_dev_state*, %struct.pid*, %struct.cred*, i32, i32, i8*, i8*, %struct.urb*, %struct.usb_memory*, i32, i32, i32, i8, i8 }
%struct.urb = type { %struct.kref, i8*, %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, void (%struct.urb*)*, [0 x %struct.usb_iso_packet_descriptor] }
%struct.usb_anchor = type { %struct.list_head, %struct.__wait_queue_head, %struct.spinlock, %struct.atomic_t, i8 }
%struct.usb_iso_packet_descriptor = type { i32, i32, i32, i32 }
%union.anon.58 = type { %struct.list_head* }
%union.anon.59 = type { %struct.list_head* }
%union.anon.60 = type { %struct.list_head* }
%union.anon.61 = type { %struct.list_head* }
%struct.usbdevfs_ctrltransfer32 = type { i8, i8, i16, i16, i16, i32, i32 }
%struct.usbdevfs_bulktransfer32 = type { i32, i32, i32, i32 }
%struct.usbdevfs_ctrltransfer = type { i8, i8, i16, i16, i16, i32, i8* }
%struct.usbdevfs_bulktransfer = type { i32, i32, i32, i8* }
%struct.usbdevfs_getdriver = type { i32, [256 x i8] }
%struct.usbdevfs_connectinfo = type { i32, i8 }
%struct.usbdevfs_setinterface = type { i32, i32 }
%struct.usbdevfs_urb = type { i8, i8, i32, i32, i8*, i32, i32, i32, %union.anon.62, i32, i32, i8*, [0 x %struct.usbdevfs_iso_packet_desc] }
%union.anon.62 = type { i32 }
%struct.usbdevfs_iso_packet_desc = type { i32, i32, i32 }
%struct.usbdevfs_disconnectsignal32 = type { i32, i32 }
%struct.usbdevfs_urb32 = type { i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [0 x %struct.usbdevfs_iso_packet_desc] }
%struct.usbdevfs_ioctl = type { i32, i32, i8* }
%struct.usbdevfs_ioctl32 = type { i32, i32, i32 }
%struct.__large_struct = type { [100 x i64] }
%struct.usbdevfs_disconnectsignal = type { i32, i8* }
%struct.usbdevfs_disconnect_claim = type { i32, i32, [256 x i8] }
%struct.usbdevfs_streams = type { i32, i32, [0 x i8] }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%union.anon.63 = type { i64 }
%struct.usb_ctrlrequest = type { i8, i8, i16, i16, i16 }
%struct.anon.18 = type { i8*, i16, %union.anon.19 }
%union.anon.19 = type { %struct.anon.20 }
%struct.anon.20 = type { i8*, i8* }
%union.anon.64 = type { i8 }

@usbfs_mutex = global %struct.mutex { %struct.atomic64_t zeroinitializer, %struct.spinlock zeroinitializer, %struct.optimistic_spin_queue zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 16) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 16) to %struct.list_head*) } }, align 8
@__param_str_usbfs_snoop = internal constant [20 x i8] c"usbcore.usbfs_snoop\00", align 16
@param_ops_bool = external constant %struct.kernel_param_ops, align 8
@usbfs_snoop = internal global i8 0, align 1
@__param_usbfs_snoop = internal constant %struct.kernel_param { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__param_str_usbfs_snoop, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_bool, i16 420, i8 -1, i8 0, %union.anon.51 { i8* @usbfs_snoop } }, section "__param", align 8
@__param_str_usbfs_snoop_max = internal constant [24 x i8] c"usbcore.usbfs_snoop_max\00", align 16
@param_ops_uint = external constant %struct.kernel_param_ops, align 8
@usbfs_snoop_max = internal global i32 65536, align 4
@__param_usbfs_snoop_max = internal constant %struct.kernel_param { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__param_str_usbfs_snoop_max, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @usbfs_snoop_max to i8*) } }, section "__param", align 8
@__param_str_usbfs_memory_mb = internal constant [24 x i8] c"usbcore.usbfs_memory_mb\00", align 16
@usbfs_memory_mb = internal global i32 16, align 4
@__param_usbfs_memory_mb = internal constant %struct.kernel_param { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__param_str_usbfs_memory_mb, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @usbfs_memory_mb to i8*) } }, section "__param", align 8
@.str = private unnamed_addr constant [6 x i8] c"usbfs\00", align 1
@usbfs_driver = global %struct.usb_driver { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0), i32 (%struct.usb_interface*, %struct.usb_device_id*)* @driver_probe, void (%struct.usb_interface*)* @driver_disconnect, i32 (%struct.usb_interface*, i32, i8*)* null, i32 (%struct.usb_interface*, i32)* @driver_suspend, i32 (%struct.usb_interface*)* @driver_resume, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, %struct.usb_device_id* null, %struct.usb_dynids zeroinitializer, %struct.usbdrv_wrap zeroinitializer, i8 0 }, align 8
@usbdev_file_operations = constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @no_seek_end_llseek, i64 (%struct.file*, i8*, i64, i64*)* @usbdev_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @usbdev_poll, i64 (%struct.file*, i32, i64)* @usbdev_ioctl, i64 (%struct.file*, i32, i64)* @usbdev_compat_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* @usbdev_mmap, i32 (%struct.inode*, %struct.file*)* @usbdev_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.1 = private unnamed_addr constant [11 x i8] c"usb_device\00", align 1
@.str.2 = private unnamed_addr constant [44 x i8] c"\013Unable to register minors for usb_device\0A\00", align 1
@usb_device_cdev = internal global %struct.cdev zeroinitializer, align 8
@.str.3 = private unnamed_addr constant [37 x i8] c"\013Unable to get usb_device major %d\0A\00", align 1
@usbdev_nb = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @usbdev_notify, %struct.notifier_block* null, i32 0 }, align 8
@.str.4 = private unnamed_addr constant [34 x i8] c"interface number %u out of range\0A\00", align 1
@.str.5 = private unnamed_addr constant [33 x i8] c"./arch/x86/include/asm/uaccess.h\00", align 1
@.str.6 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@.str.7 = private unnamed_addr constant [13 x i8] c"%s: REAPURB\0A\00", align 1
@__func__.usbdev_do_ioctl = private unnamed_addr constant [16 x i8] c"usbdev_do_ioctl\00", align 1
@.str.8 = private unnamed_addr constant [19 x i8] c"%s: REAPURBNDELAY\0A\00", align 1
@.str.9 = private unnamed_addr constant [15 x i8] c"%s: REAPURB32\0A\00", align 1
@.str.10 = private unnamed_addr constant [21 x i8] c"%s: REAPURBNDELAY32\0A\00", align 1
@.str.11 = private unnamed_addr constant [13 x i8] c"%s: CONTROL\0A\00", align 1
@.str.12 = private unnamed_addr constant [10 x i8] c"%s: BULK\0A\00", align 1
@.str.13 = private unnamed_addr constant [13 x i8] c"%s: RESETEP\0A\00", align 1
@.str.14 = private unnamed_addr constant [11 x i8] c"%s: RESET\0A\00", align 1
@.str.15 = private unnamed_addr constant [16 x i8] c"%s: CLEAR_HALT\0A\00", align 1
@.str.16 = private unnamed_addr constant [15 x i8] c"%s: GETDRIVER\0A\00", align 1
@.str.17 = private unnamed_addr constant [17 x i8] c"%s: CONNECTINFO\0A\00", align 1
@.str.18 = private unnamed_addr constant [18 x i8] c"%s: SETINTERFACE\0A\00", align 1
@.str.19 = private unnamed_addr constant [22 x i8] c"%s: SETCONFIGURATION\0A\00", align 1
@.str.20 = private unnamed_addr constant [15 x i8] c"%s: SUBMITURB\0A\00", align 1
@.str.21 = private unnamed_addr constant [15 x i8] c"%s: CONTROL32\0A\00", align 1
@.str.22 = private unnamed_addr constant [12 x i8] c"%s: BULK32\0A\00", align 1
@.str.23 = private unnamed_addr constant [18 x i8] c"%s: DISCSIGNAL32\0A\00", align 1
@.str.24 = private unnamed_addr constant [17 x i8] c"%s: SUBMITURB32\0A\00", align 1
@.str.25 = private unnamed_addr constant [13 x i8] c"%s: IOCTL32\0A\00", align 1
@.str.26 = private unnamed_addr constant [19 x i8] c"%s: DISCARDURB %p\0A\00", align 1
@.str.27 = private unnamed_addr constant [16 x i8] c"%s: DISCSIGNAL\0A\00", align 1
@.str.28 = private unnamed_addr constant [20 x i8] c"%s: CLAIMINTERFACE\0A\00", align 1
@.str.29 = private unnamed_addr constant [22 x i8] c"%s: RELEASEINTERFACE\0A\00", align 1
@.str.30 = private unnamed_addr constant [11 x i8] c"%s: IOCTL\0A\00", align 1
@.str.31 = private unnamed_addr constant [16 x i8] c"%s: CLAIM_PORT\0A\00", align 1
@.str.32 = private unnamed_addr constant [18 x i8] c"%s: RELEASE_PORT\0A\00", align 1
@.str.33 = private unnamed_addr constant [9 x i8] c"reap %p\0A\00", align 1
@usbfs_memory_usage = internal global %struct.atomic64_t zeroinitializer, align 8
@current_task = external global %struct.task_struct*, align 8
@.str.34 = private unnamed_addr constant [83 x i8] c"control urb: bRequestType=%02x bRequest=%02x wValue=%04x wIndex=%04x wLength=%04x\0A\00", align 1
@.str.35 = private unnamed_addr constant [3 x i8] c"\017\00", align 1
@.str.36 = private unnamed_addr constant [66 x i8] c"usbfs: USBDEVFS_CONTROL failed cmd %s rqt %u rq %u len %u ret %d\0A\00", align 1
@.str.37 = private unnamed_addr constant [55 x i8] c"%s: process %i (%s) requesting ep %02x but needs %02x\0A\00", align 1
@__func__.check_ctrlrecip = private unnamed_addr constant [16 x i8] c"check_ctrlrecip\00", align 1
@.str.38 = private unnamed_addr constant [62 x i8] c"usbfs: process %d (%s) did not claim interface %u before use\0A\00", align 1
@snoop_urb.types = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.39, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.40, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.41, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i32 0, i32 0)], align 16
@.str.39 = private unnamed_addr constant [5 x i8] c"isoc\00", align 1
@.str.40 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str.41 = private unnamed_addr constant [5 x i8] c"ctrl\00", align 1
@.str.42 = private unnamed_addr constant [5 x i8] c"bulk\00", align 1
@snoop_urb.dirs = internal global [2 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.43, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.44, i32 0, i32 0)], align 16
@.str.43 = private unnamed_addr constant [4 x i8] c"out\00", align 1
@.str.44 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.45 = private unnamed_addr constant [35 x i8] c"userurb %p, ep%d %s-%s, length %u\0A\00", align 1
@.str.46 = private unnamed_addr constant [52 x i8] c"userurb %p, ep%d %s-%s, actual_length %u status %d\0A\00", align 1
@.str.47 = private unnamed_addr constant [35 x i8] c"ep%d %s-%s, length %u, timeout %d\0A\00", align 1
@.str.48 = private unnamed_addr constant [41 x i8] c"ep%d %s-%s, actual_length %u, status %d\0A\00", align 1
@.str.49 = private unnamed_addr constant [7 x i8] c"data: \00", align 1
@.str.50 = private unnamed_addr constant [22 x i8] c"./include/linux/usb.h\00", align 1
@.str.51 = private unnamed_addr constant [8 x i8] c"RESETEP\00", align 1
@.str.52 = private unnamed_addr constant [63 x i8] c"Process %d (%s) called USBDEVFS_%s for active endpoint 0x%02x\0A\00", align 1
@.str.53 = private unnamed_addr constant [60 x i8] c"usbfs: interface %d claimed by %s while '%s' resets device\0A\00", align 1
@.str.54 = private unnamed_addr constant [11 x i8] c"CLEAR_HALT\00", align 1
@.str.55 = private unnamed_addr constant [62 x i8] c"usbfs: interface %d claimed by %s while '%s' sets config #%d\0A\00", align 1
@.str.56 = private unnamed_addr constant [35 x i8] c"usbfs: usb_submit_urb returned %d\0A\00", align 1
@.str.57 = private unnamed_addr constant [30 x i8] c"./include/linux/scatterlist.h\00", align 1
@phys_base = external global i64, align 8
@.str.58 = private unnamed_addr constant [14 x i8] c"urb complete\0A\00", align 1
@.str.59 = private unnamed_addr constant [35 x i8] c"port %d claimed by process %d: %s\0A\00", align 1
@usbdev_vm_ops = internal global %struct.vm_operations_struct { void (%struct.vm_area_struct*)* @usbdev_vm_open, void (%struct.vm_area_struct*)* @usbdev_vm_close, i32 (%struct.vm_area_struct*)* null, i32 (%struct.vm_fault*)* null, i32 (%struct.vm_fault*, i32)* null, void (%struct.vm_fault*, i64, i64)* null, i32 (%struct.vm_fault*)* null, i32 (%struct.vm_fault*)* null, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)* null, i8* (%struct.vm_area_struct*)* null, i32 (%struct.vm_area_struct*, %struct.mempolicy*)* null, %struct.mempolicy* (%struct.vm_area_struct*, i64)* null, %struct.page* (%struct.vm_area_struct*, i64)* null }, align 8
@usbdev_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.60 = private unnamed_addr constant [10 x i8] c"&ps->wait\00", align 1
@.str.61 = private unnamed_addr constant [26 x i8] c"opened by process %d: %s\0A\00", align 1
@usb_bus_type = external global %struct.bus_type, align 8
@llvm.used = appending global [3 x i8*] [i8* bitcast (%struct.kernel_param* @__param_usbfs_snoop to i8*), i8* bitcast (%struct.kernel_param* @__param_usbfs_snoop_max to i8*), i8* bitcast (%struct.kernel_param* @__param_usbfs_memory_mb to i8*)], section "llvm.metadata"

; Function Attrs: nounwind uwtable
define internal i32 @driver_probe(%struct.usb_interface* %intf, %struct.usb_device_id* %id) #0 {
entry:
  ret i32 -19
}

; Function Attrs: nounwind uwtable
define internal void @driver_disconnect(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.usb_dev_state*
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %1 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !2
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %2 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !31
  %conv = zext i8 %2 to i32
  %tobool = icmp ne %struct.usb_dev_state* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %conv1 = zext i32 %conv to i64
  %cmp = icmp ult i64 %conv1, 64
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 1)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %conv7 = zext i32 %conv to i64
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 12
  call void @clear_bit(i64 %conv7, i64* %ifclaimed)
  br label %if.end8

if.else:                                          ; preds = %if.end
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.4, i32 0, i32 0), i32 %conv)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then6
  call void @usb_set_intfdata(%struct.usb_interface* %intf, i8* null)
  call void @destroy_async_on_interface(%struct.usb_dev_state* %0, i32 %conv)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end8, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @driver_suspend(%struct.usb_interface* %intf, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.pm_message, align 4
  %coerce.dive = getelementptr inbounds %struct.pm_message, %struct.pm_message* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @driver_resume(%struct.usb_interface* %intf) #0 {
entry:
  ret i32 0
}

declare i64 @no_seek_end_llseek(%struct.file*, i64, i32) #1

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_read(%struct.file* %file, i8* %buf, i64 %nbytes, i64* %ppos) #0 {
entry:
  %temp_desc = alloca %struct.usb_device_descriptor, align 1
  %__UNIQUE_ID_min1_24 = alloca i32, align 4
  %__UNIQUE_ID_min2_25 = alloca i32, align 4
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !34
  %1 = bitcast i8* %0 to %struct.usb_dev_state*
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !42
  %3 = load i64, i64* %ppos, align 8, !tbaa !44
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  %call = call i32 @connected(%struct.usb_dev_state* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %err

if.else:                                          ; preds = %entry
  %cmp = icmp slt i64 %3, 0
  br i1 %cmp, label %err, label %if.end4

if.end4:                                          ; preds = %if.else
  %cmp5 = icmp ult i64 %3, 18
  br i1 %cmp5, label %if.then6, label %if.end39

if.then6:                                         ; preds = %if.end4
  %4 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  call void @llvm.lifetime.start.p0i8(i64 18, i8* %4) #7
  %cmp7 = icmp uge i64 18, 64
  %5 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 12
  %6 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  br i1 %cmp7, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.then6
  %call9 = call i8* @__memcpy(i8* %5, i8* %6, i64 18)
  br label %do.body

if.else10:                                        ; preds = %if.then6
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 18, i32 1, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.then8, %if.else10
  %__ret.0 = phi i8* [ %call9, %if.then8 ], [ %5, %if.else10 ]
  %bcdUSB = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 2
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 7
  %idProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 8
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 9
  %sub = sub i64 18, %3
  %conv = trunc i64 %sub to i32
  %conv22 = zext i32 %conv to i64
  %cmp23 = icmp ugt i64 %conv22, %nbytes
  %conv26 = trunc i64 %nbytes to i32
  %len.0 = select i1 %cmp23, i32 %conv26, i32 %conv
  %7 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %3
  %conv28 = zext i32 %len.0 to i64
  %call29 = call i64 @copy_to_user(i8* %buf, i8* %add.ptr, i64 %conv28)
  %tobool30 = icmp ne i64 %call29, 0
  br i1 %tobool30, label %cleanup, label %if.end32

if.end32:                                         ; preds = %do.body
  %conv33 = zext i32 %len.0 to i64
  %8 = load i64, i64* %ppos, align 8, !tbaa !44
  %add = add nsw i64 %8, %conv33
  store i64 %add, i64* %ppos, align 8, !tbaa !44
  %idx.ext = zext i32 %len.0 to i64
  %add.ptr34 = getelementptr inbounds i8, i8* %buf, i64 %idx.ext
  %conv35 = zext i32 %len.0 to i64
  %sub36 = sub i64 %nbytes, %conv35
  %conv37 = zext i32 %len.0 to i64
  %add38 = add nsw i64 0, %conv37
  br label %cleanup

cleanup:                                          ; preds = %do.body, %if.end32
  %ret.0 = phi i64 [ %add38, %if.end32 ], [ -14, %do.body ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end32 ], [ 2, %do.body ]
  %nbytes.addr.0 = phi i64 [ %sub36, %if.end32 ], [ %nbytes, %do.body ]
  %buf.addr.0 = phi i8* [ %add.ptr34, %if.end32 ], [ %buf, %do.body ]
  %9 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  call void @llvm.lifetime.end.p0i8(i64 18, i8* %9) #7
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %if.end39, label %err

if.end39:                                         ; preds = %cleanup, %if.end4
  %ret.1 = phi i64 [ 0, %if.end4 ], [ %ret.0, %cleanup ]
  %nbytes.addr.1 = phi i64 [ %nbytes, %if.end4 ], [ %nbytes.addr.0, %cleanup ]
  %buf.addr.1 = phi i8* [ %buf, %if.end4 ], [ %buf.addr.0, %cleanup ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end39
  %pos.0 = phi i64 [ 18, %if.end39 ], [ %pos.1, %for.inc ]
  %ret.2 = phi i64 [ %ret.1, %if.end39 ], [ %ret.5, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end39 ], [ %inc, %for.inc ]
  %nbytes.addr.2 = phi i64 [ %nbytes.addr.1, %if.end39 ], [ %nbytes.addr.5, %for.inc ]
  %buf.addr.2 = phi i8* [ %buf.addr.1, %if.end39 ], [ %buf.addr.5, %for.inc ]
  %tobool40 = icmp ne i64 %nbytes.addr.2, 0
  br i1 %tobool40, label %land.rhs, label %err

land.rhs:                                         ; preds = %for.cond
  %descriptor41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor41, i32 0, i32 13
  %10 = load i8, i8* %bNumConfigurations, align 1, !tbaa !45
  %conv42 = zext i8 %10 to i32
  %cmp43 = icmp slt i32 %i.0, %conv42
  br i1 %cmp43, label %for.body, label %err

for.body:                                         ; preds = %land.rhs
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 18
  %11 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !55
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %11, i64 %idxprom
  %12 = load i8*, i8** %arrayidx, align 8, !tbaa !56
  %13 = bitcast i8* %12 to %struct.usb_config_descriptor*
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %13, i32 0, i32 2
  %14 = load i16, i16* %wTotalLength, align 1, !tbaa !57
  %conv45 = zext i16 %14 to i32
  %15 = load i64, i64* %ppos, align 8, !tbaa !44
  %conv46 = zext i32 %conv45 to i64
  %add47 = add nsw i64 %pos.0, %conv46
  %cmp48 = icmp slt i64 %15, %add47
  br i1 %cmp48, label %if.then50, label %if.end102

if.then50:                                        ; preds = %for.body
  %config51 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 14
  %16 = load %struct.usb_host_config*, %struct.usb_host_config** %config51, align 8, !tbaa !59
  %idxprom52 = sext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %16, i64 %idxprom52
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx53, i32 0, i32 0
  %wTotalLength54 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 2
  %17 = load i16, i16* %wTotalLength54, align 2, !tbaa !60
  %conv55 = zext i16 %17 to i32
  %conv56 = zext i32 %conv45 to i64
  %18 = load i64, i64* %ppos, align 8, !tbaa !44
  %sub57 = sub nsw i64 %18, %pos.0
  %sub58 = sub nsw i64 %conv56, %sub57
  %conv59 = trunc i64 %sub58 to i32
  %conv60 = zext i32 %conv59 to i64
  %cmp61 = icmp ugt i64 %conv60, %nbytes.addr.2
  %conv64 = trunc i64 %nbytes.addr.2 to i32
  %conv64.conv59 = select i1 %cmp61, i32 %conv64, i32 %conv59
  %conv66 = zext i32 %conv55 to i64
  %19 = load i64, i64* %ppos, align 8, !tbaa !44
  %sub67 = sub nsw i64 %19, %pos.0
  %cmp68 = icmp sgt i64 %conv66, %sub67
  br i1 %cmp68, label %if.then70, label %if.end90

if.then70:                                        ; preds = %if.then50
  %20 = load i64, i64* %ppos, align 8, !tbaa !44
  %sub71 = sub nsw i64 %20, %pos.0
  %conv72 = zext i32 %conv55 to i64
  %sub73 = sub nsw i64 %conv72, %sub71
  %conv74 = trunc i64 %sub73 to i32
  %rawdescriptors75 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 18
  %21 = load i8**, i8*** %rawdescriptors75, align 8, !tbaa !55
  %idxprom76 = sext i32 %i.0 to i64
  %arrayidx77 = getelementptr inbounds i8*, i8** %21, i64 %idxprom76
  %22 = load i8*, i8** %arrayidx77, align 8, !tbaa !56
  %23 = load i64, i64* %ppos, align 8, !tbaa !44
  %sub78 = sub nsw i64 %23, %pos.0
  %add.ptr79 = getelementptr inbounds i8, i8* %22, i64 %sub78
  %24 = bitcast i32* %__UNIQUE_ID_min1_24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %24) #7
  store i32 %conv64.conv59, i32* %__UNIQUE_ID_min1_24, align 4, !tbaa !62
  %25 = bitcast i32* %__UNIQUE_ID_min2_25 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %25) #7
  store i32 %conv74, i32* %__UNIQUE_ID_min2_25, align 4, !tbaa !62
  %cmp80 = icmp eq i32* %__UNIQUE_ID_min1_24, %__UNIQUE_ID_min2_25
  %conv81 = zext i1 %cmp80 to i32
  %26 = load i32, i32* %__UNIQUE_ID_min1_24, align 4, !tbaa !62
  %27 = load i32, i32* %__UNIQUE_ID_min2_25, align 4, !tbaa !62
  %cmp83 = icmp ult i32 %26, %27
  %28 = load i32, i32* %__UNIQUE_ID_min1_24, align 4
  %29 = load i32, i32* %__UNIQUE_ID_min2_25, align 4
  %cond = select i1 %cmp83, i32 %28, i32 %29
  %30 = bitcast i32* %__UNIQUE_ID_min2_25 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %30) #7
  %31 = bitcast i32* %__UNIQUE_ID_min1_24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %31) #7
  %conv85 = zext i32 %cond to i64
  %call86 = call i64 @copy_to_user(i8* %buf.addr.2, i8* %add.ptr79, i64 %conv85)
  %tobool87 = icmp ne i64 %call86, 0
  br i1 %tobool87, label %cleanup99, label %if.end90

if.end90:                                         ; preds = %if.then70, %if.then50
  %conv91 = zext i32 %conv64.conv59 to i64
  %32 = load i64, i64* %ppos, align 8, !tbaa !44
  %add92 = add nsw i64 %32, %conv91
  store i64 %add92, i64* %ppos, align 8, !tbaa !44
  %idx.ext93 = zext i32 %conv64.conv59 to i64
  %add.ptr94 = getelementptr inbounds i8, i8* %buf.addr.2, i64 %idx.ext93
  %conv95 = zext i32 %conv64.conv59 to i64
  %sub96 = sub i64 %nbytes.addr.2, %conv95
  %conv97 = zext i32 %conv64.conv59 to i64
  %add98 = add nsw i64 %ret.2, %conv97
  br label %cleanup99

cleanup99:                                        ; preds = %if.then70, %if.end90
  %ret.3 = phi i64 [ %add98, %if.end90 ], [ -14, %if.then70 ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end90 ], [ 2, %if.then70 ]
  %nbytes.addr.3 = phi i64 [ %sub96, %if.end90 ], [ %nbytes.addr.2, %if.then70 ]
  %buf.addr.3 = phi i8* [ %add.ptr94, %if.end90 ], [ %buf.addr.2, %if.then70 ]
  %cond1 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %cond1, label %if.end102, label %cleanup105

if.end102:                                        ; preds = %cleanup99, %for.body
  %ret.4 = phi i64 [ %ret.2, %for.body ], [ %ret.3, %cleanup99 ]
  %nbytes.addr.4 = phi i64 [ %nbytes.addr.2, %for.body ], [ %nbytes.addr.3, %cleanup99 ]
  %buf.addr.4 = phi i8* [ %buf.addr.2, %for.body ], [ %buf.addr.3, %cleanup99 ]
  %conv103 = zext i32 %conv45 to i64
  %add104 = add nsw i64 %pos.0, %conv103
  br label %cleanup105

cleanup105:                                       ; preds = %cleanup99, %if.end102
  %pos.1 = phi i64 [ %pos.0, %cleanup99 ], [ %add104, %if.end102 ]
  %ret.5 = phi i64 [ %ret.3, %cleanup99 ], [ %ret.4, %if.end102 ]
  %cleanup.dest.slot.2 = phi i32 [ %cleanup.dest.slot.1, %cleanup99 ], [ 0, %if.end102 ]
  %nbytes.addr.5 = phi i64 [ %nbytes.addr.3, %cleanup99 ], [ %nbytes.addr.4, %if.end102 ]
  %buf.addr.5 = phi i8* [ %buf.addr.3, %cleanup99 ], [ %buf.addr.4, %if.end102 ]
  br label %NodeBlock

NodeBlock:                                        ; preds = %cleanup105
  %Pivot = icmp slt i32 %cleanup.dest.slot.2, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %cleanup.dest.slot.2, 2
  br i1 %SwitchLeaf4, label %err, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.2, 0
  br i1 %SwitchLeaf, label %for.inc, label %NewDefault

for.inc:                                          ; preds = %LeafBlock
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

err:                                              ; preds = %LeafBlock3, %land.rhs, %for.cond, %cleanup, %if.else, %entry
  %ret.6 = phi i64 [ %ret.0, %cleanup ], [ -19, %entry ], [ -22, %if.else ], [ %ret.2, %for.cond ], [ %ret.2, %land.rhs ], [ %ret.5, %LeafBlock3 ]
  %dev109 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev109)
  br label %cleanup110

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock
  br label %cleanup110

cleanup110:                                       ; preds = %NewDefault, %err
  %retval.0 = phi i64 [ %ret.6, %err ], [ undef, %NewDefault ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !34
  %1 = bitcast i8* %0 to %struct.usb_dev_state*
  %wait1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 7
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* %wait1, %struct.poll_table_struct* %wait)
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %2 = load i32, i32* %f_mode, align 4, !tbaa !63
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %async_completed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 5
  %call = call i32 @list_empty(%struct.list_head* %async_completed)
  %tobool2 = icmp ne i32 %call, 0
  %or = or i32 0, 260
  %.or = select i1 %tobool2, i32 0, i32 %or
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %mask.0 = phi i32 [ 0, %entry ], [ %.or, %land.lhs.true ]
  %call3 = call i32 @connected(%struct.usb_dev_state* %1)
  %tobool4 = icmp ne i32 %call3, 0
  %or6 = or i32 %mask.0, 16
  %mask.0.or6 = select i1 %tobool4, i32 %mask.0, i32 %or6
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 0
  %call8 = call i32 @list_empty(%struct.list_head* %list)
  %tobool9 = icmp ne i32 %call8, 0
  %or11 = or i32 %mask.0.or6, 8
  %mask.2 = select i1 %tobool9, i32 %or11, i32 %mask.0.or6
  ret i32 %mask.2
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %0 = inttoptr i64 %arg to i8*
  %call = call i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %0)
  %conv = trunc i64 %call to i32
  %conv1 = sext i32 %conv to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_compat_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %conv = trunc i64 %arg to i32
  %call = call i8* @compat_ptr(i32 %conv)
  %call1 = call i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %call)
  %conv2 = trunc i64 %call1 to i32
  %conv3 = sext i32 %conv2 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_mmap(%struct.file* %file, %struct.vm_area_struct* %vma) #0 {
entry:
  %dma_handle = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !34
  %1 = bitcast i8* %0 to %struct.usb_dev_state*
  %vm_end = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 1
  %2 = load i64, i64* %vm_end, align 8, !tbaa !64
  %vm_start = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 0
  %3 = load i64, i64* %vm_start, align 8, !tbaa !70
  %sub = sub i64 %2, %3
  %4 = bitcast i64* %dma_handle to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %add = add i64 %sub, 64
  %call = call i32 @usbfs_increase_memory_usage(i64 %add)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i8* @kzalloc(i64 64, i32 20971712)
  %5 = bitcast i8* %call1 to %struct.usb_memory*
  %tobool2 = icmp ne %struct.usb_memory* %5, null
  br i1 %tobool2, label %if.end4, label %error_decrease_mem

if.end4:                                          ; preds = %if.end
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %call5 = call i8* @usb_alloc_coherent(%struct.usb_device* %6, i64 %sub, i32 21103296, i64* %dma_handle)
  %tobool6 = icmp ne i8* %call5, null
  br i1 %tobool6, label %if.end8, label %error_free_usbm

if.end8:                                          ; preds = %if.end4
  call void @llvm.memset.p0i8.i64(i8* %call5, i8 0, i64 %sub, i32 1, i1 false)
  %mem9 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 4
  store i8* %call5, i8** %mem9, align 8, !tbaa !71
  %7 = load i64, i64* %dma_handle, align 8, !tbaa !44
  %dma_handle10 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 5
  store i64 %7, i64* %dma_handle10, align 8, !tbaa !73
  %conv = trunc i64 %sub to i32
  %size11 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 3
  store i32 %conv, i32* %size11, align 8, !tbaa !74
  %ps12 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 7
  store %struct.usb_dev_state* %1, %struct.usb_dev_state** %ps12, align 8, !tbaa !75
  %vm_start13 = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 0
  %8 = load i64, i64* %vm_start13, align 8, !tbaa !70
  %vm_start14 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 6
  store i64 %8, i64* %vm_start14, align 8, !tbaa !76
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 1
  store i32 1, i32* %vma_use_count, align 8, !tbaa !77
  %memlist = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 0
  call void @INIT_LIST_HEAD(%struct.list_head* %memlist)
  %vm_start15 = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 0
  %9 = load i64, i64* %vm_start15, align 8, !tbaa !70
  %mem16 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 4
  %10 = load i8*, i8** %mem16, align 8, !tbaa !71
  %call17 = call i64 @virt_to_phys(i8* %10)
  %shr = lshr i64 %call17, 12
  %vm_page_prot = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 7
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %vm_page_prot, i32 0, i32 0
  %11 = load i64, i64* %coerce.dive, align 8
  %call18 = call i32 @remap_pfn_range(%struct.vm_area_struct* %vma, i64 %9, i64 %shr, i64 %sub, i64 %11)
  %cmp = icmp slt i32 %call18, 0
  br i1 %cmp, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end8
  %vma_use_count21 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 1
  call void @dec_usb_memory_use_count(%struct.usb_memory* %5, i32* %vma_use_count21)
  br label %cleanup

if.end22:                                         ; preds = %if.end8
  %vm_flags = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 8
  %12 = load i64, i64* %vm_flags, align 8, !tbaa !78
  %or = or i64 %12, 16384
  store i64 %or, i64* %vm_flags, align 8, !tbaa !78
  %vm_flags23 = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 8
  %13 = load i64, i64* %vm_flags23, align 8, !tbaa !78
  %or24 = or i64 %13, 67371008
  store i64 %or24, i64* %vm_flags23, align 8, !tbaa !78
  %vm_ops = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 12
  store %struct.vm_operations_struct* @usbdev_vm_ops, %struct.vm_operations_struct** %vm_ops, align 8, !tbaa !79
  %14 = bitcast %struct.usb_memory* %5 to i8*
  %vm_private_data = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 15
  store i8* %14, i8** %vm_private_data, align 8, !tbaa !80
  %15 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %15) #7
  %16 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #7
  %cmp26 = icmp eq i64* %__dummy, %__dummy2
  %conv27 = zext i1 %cmp26 to i32
  %17 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #7
  %18 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #7
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 3
  %call28 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call29 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call28)
  %memlist32 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %5, i32 0, i32 0
  %memory_list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 6
  call void @list_add_tail(%struct.list_head* %memlist32, %struct.list_head* %memory_list)
  %lock33 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock33, i64 %call29)
  br label %cleanup

error_free_usbm:                                  ; preds = %if.end4
  %19 = bitcast %struct.usb_memory* %5 to i8*
  call void @kfree(i8* %19)
  br label %error_decrease_mem

error_decrease_mem:                               ; preds = %if.end, %error_free_usbm
  %add34 = add i64 %sub, 64
  call void @usbfs_decrease_memory_usage(i64 %add34)
  br label %cleanup

cleanup:                                          ; preds = %error_decrease_mem, %entry, %if.end22, %if.then20
  %retval.0 = phi i32 [ -11, %if.then20 ], [ 0, %if.end22 ], [ -12, %error_decrease_mem ], [ %call, %entry ]
  %20 = bitcast i64* %dma_handle to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %.compoundliteral = alloca %struct.raw_spinlock, align 4
  %call = call i8* @kzalloc(i64 176, i32 20971712)
  %0 = bitcast i8* %call to %struct.usb_dev_state*
  %tobool = icmp ne %struct.usb_dev_state* %0, null
  br i1 %tobool, label %if.end, label %out_free_ps

if.end:                                           ; preds = %entry
  call void @mutex_lock(%struct.mutex* @usbfs_mutex)
  %call1 = call i32 @imajor(%struct.inode* %inode)
  %cmp = icmp eq i32 %call1, 189
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %1 = load i32, i32* %i_rdev, align 4, !tbaa !81
  %call3 = call %struct.usb_device* @usbdev_lookup_by_devt(i32 %1)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %dev.0 = phi %struct.usb_device* [ %call3, %if.then2 ], [ null, %if.end ]
  call void @mutex_unlock(%struct.mutex* @usbfs_mutex)
  %tobool5 = icmp ne %struct.usb_device* %dev.0, null
  br i1 %tobool5, label %if.end7, label %out_free_ps

if.end7:                                          ; preds = %if.end4
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev8)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !90
  %cmp9 = icmp eq i32 %2, 0
  br i1 %cmp9, label %out_unlock_device, label %if.end11

if.end11:                                         ; preds = %if.end7
  %call12 = call i32 @usb_autoresume_device(%struct.usb_device* %dev.0)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %out_unlock_device, label %if.end15

if.end15:                                         ; preds = %if.end11
  %dev16 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 1
  store %struct.usb_device* %dev.0, %struct.usb_device** %dev16, align 8, !tbaa !42
  %file17 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 2
  store %struct.file* %file, %struct.file** %file17, align 8, !tbaa !91
  %interface_allowed_mask = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 16
  store i64 4294967295, i64* %interface_allowed_mask, align 8, !tbaa !92
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %call18 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %lock20 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock20, i32 0, i32 0
  %rlock = bitcast %union.anon* %3 to %struct.raw_spinlock*
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %.compoundliteral, i32 0, i32 0
  %val = getelementptr inbounds %struct.qspinlock, %struct.qspinlock* %raw_lock, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %val, i32 0, i32 0
  store i32 0, i32* %counter, align 4, !tbaa !93
  %4 = bitcast %struct.raw_spinlock* %rlock to i8*
  %5 = bitcast %struct.raw_spinlock* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 4, i32 4, i1 false), !tbaa.struct !94
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 0
  call void @INIT_LIST_HEAD(%struct.list_head* %list)
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 4
  call void @INIT_LIST_HEAD(%struct.list_head* %async_pending)
  %async_completed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 5
  call void @INIT_LIST_HEAD(%struct.list_head* %async_completed)
  %memory_list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 6
  call void @INIT_LIST_HEAD(%struct.list_head* %memory_list)
  %wait = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 7
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.60, i32 0, i32 0), %struct.lock_class_key* @usbdev_open.__key)
  %call26 = call %struct.task_struct* @get_current()
  %call27 = call %struct.pid* @task_pid(%struct.task_struct* %call26)
  %call28 = call %struct.pid* @get_pid(%struct.pid* %call27)
  %disc_pid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 9
  store %struct.pid* %call28, %struct.pid** %disc_pid, align 8, !tbaa !95
  %call32 = call %struct.task_struct* @get_current()
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call32, i32 0, i32 76
  %6 = load %struct.cred*, %struct.cred** %cred, align 32, !tbaa !96
  %call33 = call %struct.cred* @get_cred(%struct.cred* %6)
  %cred34 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 10
  store %struct.cred* %call33, %struct.cred** %cred34, align 8, !tbaa !129
  %call35 = call %struct.task_struct* @get_current()
  %secid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 13
  call void @security_task_getsecid(%struct.task_struct* %call35, i32* %secid)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !130
  %list36 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 0
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 27
  call void @list_add_tail(%struct.list_head* %list36, %struct.list_head* %filelist)
  %7 = bitcast %struct.usb_dev_state* %0 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %7, i8** %private_data, align 8, !tbaa !34
  %dev37 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev37)
  %8 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool39 = trunc i8 %8 to i1
  br i1 %tobool39, label %if.then40, label %cleanup

if.then40:                                        ; preds = %if.end15
  %dev41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  %call42 = call %struct.task_struct* @get_current()
  %call43 = call i32 @task_pid_nr(%struct.task_struct* %call42)
  %call44 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call44, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev41, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.61, i32 0, i32 0), i32 %call43, i8* %arraydecay)
  br label %cleanup

out_unlock_device:                                ; preds = %if.end11, %if.end7
  %ret.0 = phi i32 [ -19, %if.end7 ], [ %call12, %if.end11 ]
  %dev48 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev48)
  call void @usb_put_dev(%struct.usb_device* %dev.0)
  br label %out_free_ps

out_free_ps:                                      ; preds = %if.end4, %entry, %out_unlock_device
  %ret.1 = phi i32 [ %ret.0, %out_unlock_device ], [ -12, %entry ], [ -19, %if.end4 ]
  %9 = bitcast %struct.usb_dev_state* %0 to i8*
  call void @kfree(i8* %9)
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then40, %out_free_ps
  %retval.0 = phi i32 [ %ret.1, %out_free_ps ], [ %call12, %if.then40 ], [ %call12, %if.end15 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !34
  %1 = bitcast i8* %0 to %struct.usb_dev_state*
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !42
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  call void @usb_hub_release_all_ports(%struct.usb_device* %2, %struct.usb_dev_state* %1)
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %list)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %ifnum.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 12
  %3 = load i64, i64* %ifclaimed, align 8, !tbaa !133
  %tobool = icmp ne i64 %3, 0
  %conv = zext i32 %ifnum.0 to i64
  %cmp = icmp ult i64 %conv, 64
  %4 = select i1 %tobool, i1 %cmp, i1 false
  br i1 %4, label %cond.false, label %for.end

cond.false:                                       ; preds = %for.cond
  %conv7 = zext i32 %ifnum.0 to i64
  %ifclaimed8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 12
  %call9 = call zeroext i1 @variable_test_bit(i64 %conv7, i64* %ifclaimed8)
  br i1 %call9, label %if.then, label %for.inc

if.then:                                          ; preds = %cond.false
  %call11 = call i32 @releaseintf(%struct.usb_dev_state* %1, i32 %ifnum.0)
  br label %for.inc

for.inc:                                          ; preds = %cond.false, %if.then
  %inc = add i32 %ifnum.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @destroy_all_async(%struct.usb_dev_state* %1)
  call void @usb_autosuspend_device(%struct.usb_device* %2)
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev12)
  call void @usb_put_dev(%struct.usb_device* %2)
  %disc_pid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 9
  %5 = load %struct.pid*, %struct.pid** %disc_pid, align 8, !tbaa !95
  call void @put_pid(%struct.pid* %5)
  %cred = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 10
  %6 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !129
  call void @put_cred(%struct.cred* %6)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %call15 = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %1)
  %tobool14 = icmp ne %struct.async* %call15, null
  br i1 %tobool14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @free_async(%struct.async* %call15)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %7 = bitcast %struct.usb_dev_state* %1 to i8*
  call void @kfree(i8* %7)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @usb_devio_init() #0 section ".init.text" {
entry:
  %call = call i32 @register_chrdev_region(i32 198180864, i32 8192, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i32 0, i32 0))
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.2, i32 0, i32 0))
  br label %out

if.end:                                           ; preds = %entry
  call void @cdev_init(%struct.cdev* @usb_device_cdev, %struct.file_operations* @usbdev_file_operations)
  %call3 = call i32 @cdev_add(%struct.cdev* @usb_device_cdev, i32 198180864, i32 8192)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.3, i32 0, i32 0), i32 189)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  br label %out

if.end7:                                          ; preds = %if.end
  call void @usb_register_notify(%struct.notifier_block* @usbdev_nb)
  br label %out

out:                                              ; preds = %if.then5, %if.end7, %if.then
  %retval1.0 = phi i32 [ %call, %if.then ], [ %call3, %if.then5 ], [ %call3, %if.end7 ]
  ret i32 %retval1.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

declare i32 @register_chrdev_region(i32, i32, i8*) #1

declare i32 @printk(i8*, ...) #1

declare void @cdev_init(%struct.cdev*, %struct.file_operations*) #1

declare i32 @cdev_add(%struct.cdev*, i32, i32) #1

declare void @usb_register_notify(%struct.notifier_block*) #1

declare void @unregister_chrdev_region(i32, i32) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

; Function Attrs: nounwind uwtable
define void @usb_devio_cleanup() #0 {
entry:
  call void @usb_unregister_notify(%struct.notifier_block* @usbdev_nb)
  call void @cdev_del(%struct.cdev* @usb_device_cdev)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  ret void
}

declare void @usb_unregister_notify(%struct.notifier_block*) #1

declare void @cdev_del(%struct.cdev*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @usb_get_intfdata(%struct.usb_interface* %intf) #3 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #4

; Function Attrs: alwaysinline nounwind uwtable
define internal void @clear_bit(i64 %nr, i64* %addr) #5 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i64 %nr, i64* %addr) #7, !srcloc !134
  ret void
}

declare void @dev_warn(%struct.device*, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_set_intfdata(%struct.usb_interface* %intf, i8* %data) #3 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %hitlist = alloca %struct.list_head, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast %struct.list_head* %hitlist to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  call void @INIT_LIST_HEAD(%struct.list_head* %hitlist)
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !135
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.list_head* [ %6, %for.inc ], [ %5, %entry ]
  %p.0 = phi %struct.list_head* [ %5, %entry ], [ %6, %for.inc ]
  %next13 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next13, align 8, !tbaa !135
  %async_pending6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  %cmp7 = icmp ne %struct.list_head* %p.0, %async_pending6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = bitcast %struct.list_head* %p.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr to %struct.async*
  %ifnum10 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 5
  %9 = load i32, i32* %ifnum10, align 4, !tbaa !136
  %cmp11 = icmp eq i32 %ifnum, %9
  br i1 %cmp11, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_move_tail(%struct.list_head* %p.0, %struct.list_head* %hitlist)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %lock14 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock14, i64 %call2)
  call void @destroy_async(%struct.usb_dev_state* %ps, %struct.list_head* %hitlist)
  %10 = bitcast %struct.list_head* %hitlist to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %10) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !138
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !138
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #3 {
entry:
  %__u = alloca %union.anon.58, align 8
  %0 = bitcast %union.anon.58* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %__val = bitcast %union.anon.58* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !139
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.58* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.58* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !139
  %3 = bitcast %union.anon.58* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !140
  ret void
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_move_tail(%struct.list_head* %list, %struct.list_head* %head) #3 {
entry:
  call void @__list_del_entry(%struct.list_head* %list)
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %head)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #5 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @destroy_async(%struct.usb_dev_state* %ps, %struct.list_head* %list) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy12 = alloca i64, align 8
  %__dummy213 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %lock17 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %call18 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock17)
  %call19 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call18)
  %call5 = call i32 @list_empty(%struct.list_head* %list)
  %tobool = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !135
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  %urb7 = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 8
  %7 = load %struct.urb*, %struct.urb** %urb7, align 8, !tbaa !141
  %call8 = call %struct.urb* @usb_get_urb(%struct.urb* %7)
  %lock9 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock9, i64 %call19)
  call void @usb_kill_urb(%struct.urb* %7)
  call void @usb_free_urb(%struct.urb* %7)
  %8 = bitcast i64* %__dummy12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #7
  %9 = bitcast i64* %__dummy213 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #7
  %cmp14 = icmp eq i64* %__dummy12, %__dummy213
  %conv15 = zext i1 %cmp14 to i32
  %10 = bitcast i64* %__dummy213 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #7
  %11 = bitcast i64* %__dummy12 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #7
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %lock24 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock24, i64 %call19)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size(i8* %p, i8* %res, i32 %size) #5 {
entry:
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !139
  store volatile i8 %0, i8* %p, align 1, !tbaa !139
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !142
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !142
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !62
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !62
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !44
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !44
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !143
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !144
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #3 {
entry:
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !140
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !135
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !140
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1) #3 {
entry:
  ret i1 true
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  %__u = alloca %union.anon.59, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !140
  %0 = bitcast %union.anon.59* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  store %struct.list_head* %next, %struct.list_head** %__val, align 8, !tbaa !139
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val3 = bitcast %union.anon.59* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val3, align 8, !tbaa !139
  %3 = bitcast %union.anon.59* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  %__u = alloca %union.anon.60, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !140
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !135
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !140
  %0 = bitcast %union.anon.60* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %__val = bitcast %union.anon.60* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !139
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.60* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val5 = bitcast %union.anon.60* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val5, align 8, !tbaa !139
  %3 = bitcast %union.anon.60* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #3 {
entry:
  ret i1 true
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #3 {
entry:
  %__u = alloca %union.anon.61, align 8
  %0 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val, align 8, !tbaa !139
  %3 = bitcast %union.anon.61* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %cmp = icmp eq %struct.list_head* %2, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #3 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD(%struct.list_head* %entry1)
  ret void
}

declare %struct.urb* @usb_get_urb(%struct.urb*) #1

declare void @usb_kill_urb(%struct.urb*) #1

declare void @usb_free_urb(%struct.urb*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__read_once_size(i8* %p, i8* %res, i32 %size) #5 {
entry:
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %0 = load volatile i8, i8* %p, align 1, !tbaa !139
  store i8 %0, i8* %res, align 1, !tbaa !139
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %p to i16*
  %2 = load volatile i16, i16* %1, align 2, !tbaa !142
  %3 = bitcast i8* %res to i16*
  store i16 %2, i16* %3, align 2, !tbaa !142
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %p to i32*
  %5 = load volatile i32, i32* %4, align 4, !tbaa !62
  %6 = bitcast i8* %res to i32*
  store i32 %5, i32* %6, align 4, !tbaa !62
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %p to i64*
  %8 = load volatile i64, i64* %7, align 8, !tbaa !44
  %9 = bitcast i8* %res to i64*
  store i64 %8, i64* %9, align 8, !tbaa !44
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !145
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %res, i8* %p, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !146
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock(%struct.device* %dev) #3 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @connected(%struct.usb_dev_state* %ps) #0 {
entry:
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 0
  %call = call i32 @list_empty(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !90
  %cmp = icmp ne i32 %1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

declare i8* @__memcpy(i8*, i8*, i64) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @copy_to_user(i8* %to, i8* %from, i64 %n) #5 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %from, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  %conv1 = trunc i64 %n to i32
  call void @kasan_check_read(i8* %from, i32 %conv1)
  call void @might_fault()
  %cmp = icmp slt i32 %conv, 0
  %conv3 = sext i32 %conv to i64
  %cmp4 = icmp uge i64 %conv3, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp4
  %lnot = xor i1 %1, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @check_object_size(i8* %from, i64 %n, i1 zeroext true)
  %conv8 = trunc i64 %n to i32
  %call = call i64 @_copy_to_user(i8* %to, i8* %from, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @copy_user_overflow(i32 %conv, i64 %n)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.else ]
  ret i64 %n.addr.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock(%struct.device* %dev) #3 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

declare void @mutex_lock(%struct.mutex*) #1

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #6

; Function Attrs: inlinehint nounwind uwtable
define internal void @kasan_check_read(i8* %p, i32 %size) #3 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @might_fault() #3 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @check_object_size(i8* %ptr, i64 %n, i1 zeroext %to_user) #3 {
entry:
  %frombool = zext i1 %to_user to i8
  ret void
}

declare i64 @_copy_to_user(i8*, i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @copy_user_overflow(i32 %size, i64 %count) #3 {
entry:
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.5, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.6, i32 0, i32 0), i32 %size, i64 %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool3 = icmp ne i32 1, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %expval9 = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  ret void
}

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #1

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #3 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !147
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !147
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %p) #0 {
entry:
  %coerce = alloca %struct.timespec, align 8
  %coerce65 = alloca %struct.timespec, align 8
  %coerce80 = alloca %struct.timespec, align 8
  %coerce104 = alloca %struct.timespec, align 8
  %coerce155 = alloca %struct.timespec, align 8
  %coerce170 = alloca %struct.timespec, align 8
  %coerce185 = alloca %struct.timespec, align 8
  %coerce209 = alloca %struct.timespec, align 8
  %coerce299 = alloca %struct.timespec, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !34
  %1 = bitcast i8* %0 to %struct.usb_dev_state*
  %call = call %struct.inode* @file_inode(%struct.file* %file)
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !42
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %3 = load i32, i32* %f_mode, align 4, !tbaa !63
  %and = and i32 %3, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  br label %NodeBlock7

NodeBlock7:                                       ; preds = %if.end
  %Pivot8 = icmp slt i32 %cmd, 1074287884
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %cmd, 1074287885
  br i1 %Pivot6, label %do.body, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %cmd, 1074287885
  br i1 %SwitchLeaf4, label %do.body9, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock7
  %Pivot = icmp slt i32 %cmd, 1074025741
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, 1074025741
  br i1 %SwitchLeaf2, label %do.body27, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, 1074025740
  br i1 %SwitchLeaf, label %do.body18, label %NewDefault

do.body:                                          ; preds = %NodeBlock5
  %4 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool3 = trunc i8 %4 to i1
  br i1 %tobool3, label %if.then4, label %do.end

if.then4:                                         ; preds = %do.body
  %dev5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev5, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then4, %do.body
  %call7 = call i32 @proc_reapurb(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body9:                                         ; preds = %LeafBlock3
  %5 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool10 = trunc i8 %5 to i1
  br i1 %tobool10, label %if.then11, label %do.end15

if.then11:                                        ; preds = %do.body9
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev12, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end15

do.end15:                                         ; preds = %if.then11, %do.body9
  %call16 = call i32 @proc_reapurbnonblock(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body18:                                        ; preds = %LeafBlock
  %6 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool19 = trunc i8 %6 to i1
  br i1 %tobool19, label %if.then20, label %do.end24

if.then20:                                        ; preds = %do.body18
  %dev21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev21, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end24

do.end24:                                         ; preds = %if.then20, %do.body18
  %call25 = call i32 @proc_reapurb_compat(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body27:                                        ; preds = %LeafBlock1
  %7 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool28 = trunc i8 %7 to i1
  br i1 %tobool28, label %if.then29, label %do.end33

if.then29:                                        ; preds = %do.body27
  %dev30 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev30, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end33

do.end33:                                         ; preds = %if.then29, %do.body27
  %call34 = call i32 @proc_reapurbnonblock_compat(%struct.usb_dev_state* %1, i8* %p)
  br label %done

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault
  %call35 = call i32 @connected(%struct.usb_dev_state* %1)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.end39, label %if.then37

if.then37:                                        ; preds = %sw.epilog
  %dev38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev38)
  br label %cleanup

if.end39:                                         ; preds = %sw.epilog
  br label %NodeBlock106

NodeBlock106:                                     ; preds = %if.end39
  %Pivot107 = icmp slt i32 %cmd, -2144578294
  br i1 %Pivot107, label %NodeBlock50, label %NodeBlock104

NodeBlock104:                                     ; preds = %NodeBlock106
  %Pivot105 = icmp slt i32 %cmd, -1072147200
  br i1 %Pivot105, label %NodeBlock76, label %NodeBlock102

NodeBlock102:                                     ; preds = %NodeBlock104
  %Pivot103 = icmp slt i32 %cmd, 21780
  br i1 %Pivot103, label %NodeBlock86, label %NodeBlock100

NodeBlock100:                                     ; preds = %NodeBlock102
  %Pivot101 = icmp slt i32 %cmd, 1074287889
  br i1 %Pivot101, label %NodeBlock92, label %NodeBlock98

NodeBlock98:                                      ; preds = %NodeBlock100
  %Pivot99 = icmp slt i32 %cmd, 1090802952
  br i1 %Pivot99, label %LeafBlock94, label %LeafBlock96

LeafBlock96:                                      ; preds = %NodeBlock98
  %SwitchLeaf97 = icmp eq i32 %cmd, 1090802952
  br i1 %SwitchLeaf97, label %do.body107, label %NewDefault9

LeafBlock94:                                      ; preds = %NodeBlock98
  %SwitchLeaf95 = icmp eq i32 %cmd, 1074287889
  br i1 %SwitchLeaf95, label %do.body116, label %NewDefault9

NodeBlock92:                                      ; preds = %NodeBlock100
  %Pivot93 = icmp slt i32 %cmd, 1074025758
  br i1 %Pivot93, label %LeafBlock88, label %LeafBlock90

LeafBlock90:                                      ; preds = %NodeBlock92
  %SwitchLeaf91 = icmp eq i32 %cmd, 1074025758
  br i1 %SwitchLeaf91, label %sw.bb292, label %NewDefault9

LeafBlock88:                                      ; preds = %NodeBlock92
  %SwitchLeaf89 = icmp eq i32 %cmd, 21780
  br i1 %SwitchLeaf89, label %do.body83, label %NewDefault9

NodeBlock86:                                      ; preds = %NodeBlock102
  %Pivot87 = icmp slt i32 %cmd, -1072147198
  br i1 %Pivot87, label %LeafBlock78, label %NodeBlock84

NodeBlock84:                                      ; preds = %NodeBlock86
  %Pivot85 = icmp slt i32 %cmd, 21771
  br i1 %Pivot85, label %LeafBlock80, label %LeafBlock82

LeafBlock82:                                      ; preds = %NodeBlock84
  %SwitchLeaf83 = icmp eq i32 %cmd, 21771
  br i1 %SwitchLeaf83, label %do.body222, label %NewDefault9

LeafBlock80:                                      ; preds = %NodeBlock84
  %SwitchLeaf81 = icmp eq i32 %cmd, -1072147198
  br i1 %SwitchLeaf81, label %do.body53, label %NewDefault9

LeafBlock78:                                      ; preds = %NodeBlock86
  %SwitchLeaf79 = icmp eq i32 %cmd, -1072147200
  br i1 %SwitchLeaf79, label %do.body41, label %NewDefault9

NodeBlock76:                                      ; preds = %NodeBlock104
  %Pivot77 = icmp slt i32 %cmd, -1072933614
  br i1 %Pivot77, label %NodeBlock60, label %NodeBlock74

NodeBlock74:                                      ; preds = %NodeBlock76
  %Pivot75 = icmp slt i32 %cmd, -1072671486
  br i1 %Pivot75, label %NodeBlock66, label %NodeBlock72

NodeBlock72:                                      ; preds = %NodeBlock74
  %Pivot73 = icmp slt i32 %cmd, -1072671470
  br i1 %Pivot73, label %LeafBlock68, label %LeafBlock70

LeafBlock70:                                      ; preds = %NodeBlock72
  %SwitchLeaf71 = icmp eq i32 %cmd, -1072671470
  br i1 %SwitchLeaf71, label %do.body258, label %NewDefault9

LeafBlock68:                                      ; preds = %NodeBlock72
  %SwitchLeaf69 = icmp eq i32 %cmd, -1072671486
  br i1 %SwitchLeaf69, label %do.body173, label %NewDefault9

NodeBlock66:                                      ; preds = %NodeBlock74
  %Pivot67 = icmp slt i32 %cmd, -1072671488
  br i1 %Pivot67, label %LeafBlock62, label %LeafBlock64

LeafBlock64:                                      ; preds = %NodeBlock66
  %SwitchLeaf65 = icmp eq i32 %cmd, -1072671488
  br i1 %SwitchLeaf65, label %do.body158, label %NewDefault9

LeafBlock62:                                      ; preds = %NodeBlock66
  %SwitchLeaf63 = icmp eq i32 %cmd, -1072933614
  br i1 %SwitchLeaf63, label %do.body212, label %NewDefault9

NodeBlock60:                                      ; preds = %NodeBlock76
  %Pivot61 = icmp slt i32 %cmd, -2143791862
  br i1 %Pivot61, label %LeafBlock52, label %NodeBlock58

NodeBlock58:                                      ; preds = %NodeBlock60
  %Pivot59 = icmp slt i32 %cmd, -2130160357
  br i1 %Pivot59, label %LeafBlock54, label %LeafBlock56

LeafBlock56:                                      ; preds = %NodeBlock58
  %SwitchLeaf57 = icmp eq i32 %cmd, -2130160357
  br i1 %SwitchLeaf57, label %sw.bb286, label %NewDefault9

LeafBlock54:                                      ; preds = %NodeBlock58
  %SwitchLeaf55 = icmp eq i32 %cmd, -2143791862
  br i1 %SwitchLeaf55, label %do.body143, label %NewDefault9

LeafBlock52:                                      ; preds = %NodeBlock60
  %SwitchLeaf53 = icmp eq i32 %cmd, -2144578294
  br i1 %SwitchLeaf53, label %do.body197, label %NewDefault9

NodeBlock50:                                      ; preds = %NodeBlock106
  %Pivot51 = icmp slt i32 %cmd, -2147199719
  br i1 %Pivot51, label %NodeBlock26, label %NodeBlock48

NodeBlock48:                                      ; preds = %NodeBlock50
  %Pivot49 = icmp slt i32 %cmd, -2146937586
  br i1 %Pivot49, label %NodeBlock34, label %NodeBlock46

NodeBlock46:                                      ; preds = %NodeBlock48
  %Pivot47 = icmp slt i32 %cmd, -2146937571
  br i1 %Pivot47, label %NodeBlock38, label %NodeBlock44

NodeBlock44:                                      ; preds = %NodeBlock46
  %Pivot45 = icmp slt i32 %cmd, -2146413298
  br i1 %Pivot45, label %LeafBlock40, label %LeafBlock42

LeafBlock42:                                      ; preds = %NodeBlock44
  %SwitchLeaf43 = icmp eq i32 %cmd, -2146413298
  br i1 %SwitchLeaf43, label %do.body231, label %NewDefault9

LeafBlock40:                                      ; preds = %NodeBlock44
  %SwitchLeaf41 = icmp eq i32 %cmd, -2146937571
  br i1 %SwitchLeaf41, label %sw.bb290, label %NewDefault9

NodeBlock38:                                      ; preds = %NodeBlock46
  %Pivot39 = icmp slt i32 %cmd, -2146937572
  br i1 %Pivot39, label %LeafBlock36, label %sw.bb288

LeafBlock36:                                      ; preds = %NodeBlock38
  %SwitchLeaf37 = icmp eq i32 %cmd, -2146937586
  br i1 %SwitchLeaf37, label %do.body188, label %NewDefault9

NodeBlock34:                                      ; preds = %NodeBlock48
  %Pivot35 = icmp slt i32 %cmd, -2147199718
  br i1 %Pivot35, label %do.body276, label %NodeBlock32

NodeBlock32:                                      ; preds = %NodeBlock34
  %Pivot33 = icmp slt i32 %cmd, -2146937596
  br i1 %Pivot33, label %LeafBlock28, label %LeafBlock30

LeafBlock30:                                      ; preds = %NodeBlock32
  %SwitchLeaf31 = icmp eq i32 %cmd, -2146937596
  br i1 %SwitchLeaf31, label %do.body125, label %NewDefault9

LeafBlock28:                                      ; preds = %NodeBlock32
  %SwitchLeaf29 = icmp eq i32 %cmd, -2147199718
  br i1 %SwitchLeaf29, label %sw.bb284, label %NewDefault9

NodeBlock26:                                      ; preds = %NodeBlock50
  %Pivot27 = icmp slt i32 %cmd, -2147199728
  br i1 %Pivot27, label %NodeBlock16, label %NodeBlock24

NodeBlock24:                                      ; preds = %NodeBlock26
  %Pivot25 = icmp slt i32 %cmd, -2147199723
  br i1 %Pivot25, label %LeafBlock18, label %NodeBlock22

NodeBlock22:                                      ; preds = %NodeBlock24
  %Pivot23 = icmp slt i32 %cmd, -2147199720
  br i1 %Pivot23, label %LeafBlock20, label %do.body267

LeafBlock20:                                      ; preds = %NodeBlock22
  %SwitchLeaf21 = icmp eq i32 %cmd, -2147199723
  br i1 %SwitchLeaf21, label %do.body92, label %NewDefault9

LeafBlock18:                                      ; preds = %NodeBlock24
  %SwitchLeaf19 = icmp eq i32 %cmd, -2147199728
  br i1 %SwitchLeaf19, label %do.body249, label %NewDefault9

NodeBlock16:                                      ; preds = %NodeBlock26
  %Pivot17 = icmp slt i32 %cmd, -2147199739
  br i1 %Pivot17, label %LeafBlock10, label %NodeBlock14

NodeBlock14:                                      ; preds = %NodeBlock16
  %Pivot15 = icmp slt i32 %cmd, -2147199729
  br i1 %Pivot15, label %LeafBlock12, label %do.body240

LeafBlock12:                                      ; preds = %NodeBlock14
  %SwitchLeaf13 = icmp eq i32 %cmd, -2147199739
  br i1 %SwitchLeaf13, label %do.body134, label %NewDefault9

LeafBlock10:                                      ; preds = %NodeBlock16
  %SwitchLeaf11 = icmp eq i32 %cmd, -2147199741
  br i1 %SwitchLeaf11, label %do.body68, label %NewDefault9

do.body41:                                        ; preds = %LeafBlock78
  %8 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool42 = trunc i8 %8 to i1
  br i1 %tobool42, label %if.then43, label %do.end47

if.then43:                                        ; preds = %do.body41
  %dev44 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev44, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end47

do.end47:                                         ; preds = %if.then43, %do.body41
  %call48 = call i32 @proc_control(%struct.usb_dev_state* %1, i8* %p)
  %cmp = icmp sge i32 %call48, 0
  br i1 %cmp, label %if.then49, label %done

if.then49:                                        ; preds = %do.end47
  %i_mtime = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call50 = call { i64, i64 } @current_time(%struct.inode* %call)
  %9 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %9, i32 0, i32 0
  %11 = extractvalue { i64, i64 } %call50, 0
  store i64 %11, i64* %10, align 8
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %9, i32 0, i32 1
  %13 = extractvalue { i64, i64 } %call50, 1
  store i64 %13, i64* %12, align 8
  %14 = bitcast %struct.timespec* %i_mtime to i8*
  %15 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 16, i32 8, i1 false), !tbaa.struct !149
  br label %done

do.body53:                                        ; preds = %LeafBlock80
  %16 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool54 = trunc i8 %16 to i1
  br i1 %tobool54, label %if.then55, label %do.end59

if.then55:                                        ; preds = %do.body53
  %dev56 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev56, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end59

do.end59:                                         ; preds = %if.then55, %do.body53
  %call60 = call i32 @proc_bulk(%struct.usb_dev_state* %1, i8* %p)
  %cmp61 = icmp sge i32 %call60, 0
  br i1 %cmp61, label %if.then62, label %done

if.then62:                                        ; preds = %do.end59
  %i_mtime63 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call64 = call { i64, i64 } @current_time(%struct.inode* %call)
  %17 = bitcast %struct.timespec* %coerce65 to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call64, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call64, 1
  store i64 %21, i64* %20, align 8
  %22 = bitcast %struct.timespec* %i_mtime63 to i8*
  %23 = bitcast %struct.timespec* %coerce65 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %22, i8* %23, i64 16, i32 8, i1 false), !tbaa.struct !149
  br label %done

do.body68:                                        ; preds = %LeafBlock10
  %24 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool69 = trunc i8 %24 to i1
  br i1 %tobool69, label %if.then70, label %do.end74

if.then70:                                        ; preds = %do.body68
  %dev71 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev71, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end74

do.end74:                                         ; preds = %if.then70, %do.body68
  %call75 = call i32 @proc_resetep(%struct.usb_dev_state* %1, i8* %p)
  %cmp76 = icmp sge i32 %call75, 0
  br i1 %cmp76, label %if.then77, label %done

if.then77:                                        ; preds = %do.end74
  %i_mtime78 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call79 = call { i64, i64 } @current_time(%struct.inode* %call)
  %25 = bitcast %struct.timespec* %coerce80 to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call79, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call79, 1
  store i64 %29, i64* %28, align 8
  %30 = bitcast %struct.timespec* %i_mtime78 to i8*
  %31 = bitcast %struct.timespec* %coerce80 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 16, i32 8, i1 false), !tbaa.struct !149
  br label %done

do.body83:                                        ; preds = %LeafBlock88
  %32 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool84 = trunc i8 %32 to i1
  br i1 %tobool84, label %if.then85, label %do.end89

if.then85:                                        ; preds = %do.body83
  %dev86 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev86, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end89

do.end89:                                         ; preds = %if.then85, %do.body83
  %call90 = call i32 @proc_resetdevice(%struct.usb_dev_state* %1)
  br label %done

do.body92:                                        ; preds = %LeafBlock20
  %33 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool93 = trunc i8 %33 to i1
  br i1 %tobool93, label %if.then94, label %do.end98

if.then94:                                        ; preds = %do.body92
  %dev95 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev95, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end98

do.end98:                                         ; preds = %if.then94, %do.body92
  %call99 = call i32 @proc_clearhalt(%struct.usb_dev_state* %1, i8* %p)
  %cmp100 = icmp sge i32 %call99, 0
  br i1 %cmp100, label %if.then101, label %done

if.then101:                                       ; preds = %do.end98
  %i_mtime102 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call103 = call { i64, i64 } @current_time(%struct.inode* %call)
  %34 = bitcast %struct.timespec* %coerce104 to { i64, i64 }*
  %35 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %34, i32 0, i32 0
  %36 = extractvalue { i64, i64 } %call103, 0
  store i64 %36, i64* %35, align 8
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %34, i32 0, i32 1
  %38 = extractvalue { i64, i64 } %call103, 1
  store i64 %38, i64* %37, align 8
  %39 = bitcast %struct.timespec* %i_mtime102 to i8*
  %40 = bitcast %struct.timespec* %coerce104 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %39, i8* %40, i64 16, i32 8, i1 false), !tbaa.struct !149
  br label %done

do.body107:                                       ; preds = %LeafBlock96
  %41 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool108 = trunc i8 %41 to i1
  br i1 %tobool108, label %if.then109, label %do.end113

if.then109:                                       ; preds = %do.body107
  %dev110 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev110, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end113

do.end113:                                        ; preds = %if.then109, %do.body107
  %call114 = call i32 @proc_getdriver(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body116:                                       ; preds = %LeafBlock94
  %42 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool117 = trunc i8 %42 to i1
  br i1 %tobool117, label %if.then118, label %do.end122

if.then118:                                       ; preds = %do.body116
  %dev119 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev119, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end122

do.end122:                                        ; preds = %if.then118, %do.body116
  %call123 = call i32 @proc_connectinfo(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body125:                                       ; preds = %LeafBlock30
  %43 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool126 = trunc i8 %43 to i1
  br i1 %tobool126, label %if.then127, label %do.end131

if.then127:                                       ; preds = %do.body125
  %dev128 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev128, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end131

do.end131:                                        ; preds = %if.then127, %do.body125
  %call132 = call i32 @proc_setintf(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body134:                                       ; preds = %LeafBlock12
  %44 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool135 = trunc i8 %44 to i1
  br i1 %tobool135, label %if.then136, label %do.end140

if.then136:                                       ; preds = %do.body134
  %dev137 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev137, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end140

do.end140:                                        ; preds = %if.then136, %do.body134
  %call141 = call i32 @proc_setconfig(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body143:                                       ; preds = %LeafBlock54
  %45 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool144 = trunc i8 %45 to i1
  br i1 %tobool144, label %if.then145, label %do.end149

if.then145:                                       ; preds = %do.body143
  %dev146 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev146, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end149

do.end149:                                        ; preds = %if.then145, %do.body143
  %call150 = call i32 @proc_submiturb(%struct.usb_dev_state* %1, i8* %p)
  %cmp151 = icmp sge i32 %call150, 0
  br i1 %cmp151, label %if.then152, label %done

if.then152:                                       ; preds = %do.end149
  %i_mtime153 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call154 = call { i64, i64 } @current_time(%struct.inode* %call)
  %46 = bitcast %struct.timespec* %coerce155 to { i64, i64 }*
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 0
  %48 = extractvalue { i64, i64 } %call154, 0
  store i64 %48, i64* %47, align 8
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 1
  %50 = extractvalue { i64, i64 } %call154, 1
  store i64 %50, i64* %49, align 8
  %51 = bitcast %struct.timespec* %i_mtime153 to i8*
  %52 = bitcast %struct.timespec* %coerce155 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %51, i8* %52, i64 16, i32 8, i1 false), !tbaa.struct !149
  br label %done

do.body158:                                       ; preds = %LeafBlock64
  %53 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool159 = trunc i8 %53 to i1
  br i1 %tobool159, label %if.then160, label %do.end164

if.then160:                                       ; preds = %do.body158
  %dev161 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev161, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.21, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end164

do.end164:                                        ; preds = %if.then160, %do.body158
  %54 = bitcast i8* %p to %struct.usbdevfs_ctrltransfer32*
  %call165 = call i32 @proc_control_compat(%struct.usb_dev_state* %1, %struct.usbdevfs_ctrltransfer32* %54)
  %cmp166 = icmp sge i32 %call165, 0
  br i1 %cmp166, label %if.then167, label %done

if.then167:                                       ; preds = %do.end164
  %i_mtime168 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call169 = call { i64, i64 } @current_time(%struct.inode* %call)
  %55 = bitcast %struct.timespec* %coerce170 to { i64, i64 }*
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 0
  %57 = extractvalue { i64, i64 } %call169, 0
  store i64 %57, i64* %56, align 8
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 1
  %59 = extractvalue { i64, i64 } %call169, 1
  store i64 %59, i64* %58, align 8
  %60 = bitcast %struct.timespec* %i_mtime168 to i8*
  %61 = bitcast %struct.timespec* %coerce170 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %60, i8* %61, i64 16, i32 8, i1 false), !tbaa.struct !149
  br label %done

do.body173:                                       ; preds = %LeafBlock68
  %62 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool174 = trunc i8 %62 to i1
  br i1 %tobool174, label %if.then175, label %do.end179

if.then175:                                       ; preds = %do.body173
  %dev176 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev176, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end179

do.end179:                                        ; preds = %if.then175, %do.body173
  %63 = bitcast i8* %p to %struct.usbdevfs_bulktransfer32*
  %call180 = call i32 @proc_bulk_compat(%struct.usb_dev_state* %1, %struct.usbdevfs_bulktransfer32* %63)
  %cmp181 = icmp sge i32 %call180, 0
  br i1 %cmp181, label %if.then182, label %done

if.then182:                                       ; preds = %do.end179
  %i_mtime183 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call184 = call { i64, i64 } @current_time(%struct.inode* %call)
  %64 = bitcast %struct.timespec* %coerce185 to { i64, i64 }*
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %64, i32 0, i32 0
  %66 = extractvalue { i64, i64 } %call184, 0
  store i64 %66, i64* %65, align 8
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %64, i32 0, i32 1
  %68 = extractvalue { i64, i64 } %call184, 1
  store i64 %68, i64* %67, align 8
  %69 = bitcast %struct.timespec* %i_mtime183 to i8*
  %70 = bitcast %struct.timespec* %coerce185 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %70, i64 16, i32 8, i1 false), !tbaa.struct !149
  br label %done

do.body188:                                       ; preds = %LeafBlock36
  %71 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool189 = trunc i8 %71 to i1
  br i1 %tobool189, label %if.then190, label %do.end194

if.then190:                                       ; preds = %do.body188
  %dev191 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev191, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end194

do.end194:                                        ; preds = %if.then190, %do.body188
  %call195 = call i32 @proc_disconnectsignal_compat(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body197:                                       ; preds = %LeafBlock52
  %72 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool198 = trunc i8 %72 to i1
  br i1 %tobool198, label %if.then199, label %do.end203

if.then199:                                       ; preds = %do.body197
  %dev200 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev200, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end203

do.end203:                                        ; preds = %if.then199, %do.body197
  %call204 = call i32 @proc_submiturb_compat(%struct.usb_dev_state* %1, i8* %p)
  %cmp205 = icmp sge i32 %call204, 0
  br i1 %cmp205, label %if.then206, label %done

if.then206:                                       ; preds = %do.end203
  %i_mtime207 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call208 = call { i64, i64 } @current_time(%struct.inode* %call)
  %73 = bitcast %struct.timespec* %coerce209 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = extractvalue { i64, i64 } %call208, 0
  store i64 %75, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = extractvalue { i64, i64 } %call208, 1
  store i64 %77, i64* %76, align 8
  %78 = bitcast %struct.timespec* %i_mtime207 to i8*
  %79 = bitcast %struct.timespec* %coerce209 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %78, i8* %79, i64 16, i32 8, i1 false), !tbaa.struct !149
  br label %done

do.body212:                                       ; preds = %LeafBlock62
  %80 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool213 = trunc i8 %80 to i1
  br i1 %tobool213, label %if.then214, label %do.end218

if.then214:                                       ; preds = %do.body212
  %dev215 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev215, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end218

do.end218:                                        ; preds = %if.then214, %do.body212
  %call219 = call i32 @ptr_to_compat(i8* %p)
  %call220 = call i32 @proc_ioctl_compat(%struct.usb_dev_state* %1, i32 %call219)
  br label %done

do.body222:                                       ; preds = %LeafBlock82
  %81 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool223 = trunc i8 %81 to i1
  br i1 %tobool223, label %if.then224, label %do.end228

if.then224:                                       ; preds = %do.body222
  %dev225 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev225, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0), i8* %p)
  br label %do.end228

do.end228:                                        ; preds = %if.then224, %do.body222
  %call229 = call i32 @proc_unlinkurb(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body231:                                       ; preds = %LeafBlock42
  %82 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool232 = trunc i8 %82 to i1
  br i1 %tobool232, label %if.then233, label %do.end237

if.then233:                                       ; preds = %do.body231
  %dev234 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev234, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end237

do.end237:                                        ; preds = %if.then233, %do.body231
  %call238 = call i32 @proc_disconnectsignal(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body240:                                       ; preds = %NodeBlock14
  %83 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool241 = trunc i8 %83 to i1
  br i1 %tobool241, label %if.then242, label %do.end246

if.then242:                                       ; preds = %do.body240
  %dev243 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev243, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.28, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end246

do.end246:                                        ; preds = %if.then242, %do.body240
  %call247 = call i32 @proc_claiminterface(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body249:                                       ; preds = %LeafBlock18
  %84 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool250 = trunc i8 %84 to i1
  br i1 %tobool250, label %if.then251, label %do.end255

if.then251:                                       ; preds = %do.body249
  %dev252 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev252, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.29, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end255

do.end255:                                        ; preds = %if.then251, %do.body249
  %call256 = call i32 @proc_releaseinterface(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body258:                                       ; preds = %LeafBlock70
  %85 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool259 = trunc i8 %85 to i1
  br i1 %tobool259, label %if.then260, label %do.end264

if.then260:                                       ; preds = %do.body258
  %dev261 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev261, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.30, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end264

do.end264:                                        ; preds = %if.then260, %do.body258
  %call265 = call i32 @proc_ioctl_default(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body267:                                       ; preds = %NodeBlock22
  %86 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool268 = trunc i8 %86 to i1
  br i1 %tobool268, label %if.then269, label %do.end273

if.then269:                                       ; preds = %do.body267
  %dev270 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev270, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.31, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end273

do.end273:                                        ; preds = %if.then269, %do.body267
  %call274 = call i32 @proc_claim_port(%struct.usb_dev_state* %1, i8* %p)
  br label %done

do.body276:                                       ; preds = %NodeBlock34
  %87 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool277 = trunc i8 %87 to i1
  br i1 %tobool277, label %if.then278, label %do.end282

if.then278:                                       ; preds = %do.body276
  %dev279 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev279, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end282

do.end282:                                        ; preds = %if.then278, %do.body276
  %call283 = call i32 @proc_release_port(%struct.usb_dev_state* %1, i8* %p)
  br label %done

sw.bb284:                                         ; preds = %LeafBlock28
  %call285 = call i32 @proc_get_capabilities(%struct.usb_dev_state* %1, i8* %p)
  br label %done

sw.bb286:                                         ; preds = %LeafBlock56
  %call287 = call i32 @proc_disconnect_claim(%struct.usb_dev_state* %1, i8* %p)
  br label %done

sw.bb288:                                         ; preds = %NodeBlock38
  %call289 = call i32 @proc_alloc_streams(%struct.usb_dev_state* %1, i8* %p)
  br label %done

sw.bb290:                                         ; preds = %LeafBlock40
  %call291 = call i32 @proc_free_streams(%struct.usb_dev_state* %1, i8* %p)
  br label %done

sw.bb292:                                         ; preds = %LeafBlock90
  %call293 = call i32 @proc_drop_privileges(%struct.usb_dev_state* %1, i8* %p)
  br label %done

NewDefault9:                                      ; preds = %LeafBlock96, %LeafBlock94, %LeafBlock90, %LeafBlock88, %LeafBlock82, %LeafBlock80, %LeafBlock78, %LeafBlock70, %LeafBlock68, %LeafBlock64, %LeafBlock62, %LeafBlock56, %LeafBlock54, %LeafBlock52, %LeafBlock42, %LeafBlock40, %LeafBlock36, %LeafBlock30, %LeafBlock28, %LeafBlock20, %LeafBlock18, %LeafBlock12, %LeafBlock10
  br label %done

done:                                             ; preds = %NewDefault9, %do.end89, %do.end113, %do.end122, %do.end131, %do.end140, %do.end194, %do.end218, %do.end228, %do.end237, %do.end246, %do.end255, %do.end264, %do.end273, %do.end282, %sw.bb284, %sw.bb286, %sw.bb288, %sw.bb290, %sw.bb292, %if.then49, %do.end47, %if.then62, %do.end59, %if.then77, %do.end74, %if.then101, %do.end98, %if.then152, %do.end149, %if.then167, %do.end164, %if.then182, %do.end179, %if.then206, %do.end203, %do.end33, %do.end24, %do.end15, %do.end
  %ret.1 = phi i32 [ %call34, %do.end33 ], [ %call25, %do.end24 ], [ %call16, %do.end15 ], [ %call7, %do.end ], [ -25, %NewDefault9 ], [ %call293, %sw.bb292 ], [ %call291, %sw.bb290 ], [ %call289, %sw.bb288 ], [ %call287, %sw.bb286 ], [ %call285, %sw.bb284 ], [ %call283, %do.end282 ], [ %call274, %do.end273 ], [ %call265, %do.end264 ], [ %call256, %do.end255 ], [ %call247, %do.end246 ], [ %call238, %do.end237 ], [ %call229, %do.end228 ], [ %call220, %do.end218 ], [ %call195, %do.end194 ], [ %call141, %do.end140 ], [ %call132, %do.end131 ], [ %call123, %do.end122 ], [ %call114, %do.end113 ], [ %call90, %do.end89 ], [ %call48, %if.then49 ], [ %call48, %do.end47 ], [ %call60, %if.then62 ], [ %call60, %do.end59 ], [ %call75, %if.then77 ], [ %call75, %do.end74 ], [ %call99, %if.then101 ], [ %call99, %do.end98 ], [ %call150, %if.then152 ], [ %call150, %do.end149 ], [ %call165, %if.then167 ], [ %call165, %do.end164 ], [ %call180, %if.then182 ], [ %call180, %do.end179 ], [ %call204, %if.then206 ], [ %call204, %do.end203 ]
  %dev295 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev295)
  %cmp296 = icmp sge i32 %ret.1, 0
  br i1 %cmp296, label %if.then297, label %if.end300

if.then297:                                       ; preds = %done
  %i_atime = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 15
  %call298 = call { i64, i64 } @current_time(%struct.inode* %call)
  %88 = bitcast %struct.timespec* %coerce299 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = extractvalue { i64, i64 } %call298, 0
  store i64 %90, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = extractvalue { i64, i64 } %call298, 1
  store i64 %92, i64* %91, align 8
  %93 = bitcast %struct.timespec* %i_atime to i8*
  %94 = bitcast %struct.timespec* %coerce299 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %93, i8* %94, i64 16, i32 8, i1 false), !tbaa.struct !149
  br label %if.end300

if.end300:                                        ; preds = %if.then297, %done
  %conv = sext i32 %ret.1 to i64
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end300, %if.then37
  %retval.0 = phi i64 [ %conv, %if.end300 ], [ -19, %if.then37 ], [ -1, %entry ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #3 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !151
  ret %struct.inode* %0
}

declare void @_dev_info(%struct.device*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurb(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @reap_as(%struct.usb_dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %do.body, label %if.end6

do.body:                                          ; preds = %entry
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool2 = trunc i8 %0 to i1
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %userurb = getelementptr inbounds %struct.async, %struct.async* %call, i32 0, i32 7
  %2 = load i8*, i8** %userurb, align 8, !tbaa !152
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev4, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i8* %2)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %3 = bitcast i8* %arg to i8**
  %call5 = call i32 @processcompl(%struct.async* %call, i8** %3)
  call void @free_async(%struct.async* %call)
  br label %cleanup

if.end6:                                          ; preds = %entry
  %call7 = call %struct.task_struct* @get_current()
  %call8 = call i32 @signal_pending(%struct.task_struct* %call7)
  %tobool9 = icmp ne i32 %call8, 0
  %. = select i1 %tobool9, i32 -4, i32 -19
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %do.end
  %retval.0 = phi i32 [ %call5, %do.end ], [ %., %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurbnonblock(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %do.body, label %if.else

do.body:                                          ; preds = %entry
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool2 = trunc i8 %0 to i1
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %userurb = getelementptr inbounds %struct.async, %struct.async* %call, i32 0, i32 7
  %2 = load i8*, i8** %userurb, align 8, !tbaa !152
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev4, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i8* %2)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %3 = bitcast i8* %arg to i8**
  %call5 = call i32 @processcompl(%struct.async* %call, i8** %3)
  call void @free_async(%struct.async* %call)
  br label %if.end8

if.else:                                          ; preds = %entry
  %call6 = call i32 @connected(%struct.usb_dev_state* %ps)
  %tobool7 = icmp ne i32 %call6, 0
  %4 = zext i1 %tobool7 to i64
  %cond = select i1 %tobool7, i32 -11, i32 -19
  br label %if.end8

if.end8:                                          ; preds = %if.else, %do.end
  %retval1.0 = phi i32 [ %call5, %do.end ], [ %cond, %if.else ]
  ret i32 %retval1.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurb_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @reap_as(%struct.usb_dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %do.body, label %if.end6

do.body:                                          ; preds = %entry
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool2 = trunc i8 %0 to i1
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %userurb = getelementptr inbounds %struct.async, %struct.async* %call, i32 0, i32 7
  %2 = load i8*, i8** %userurb, align 8, !tbaa !152
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev4, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i8* %2)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %3 = bitcast i8* %arg to i8**
  %call5 = call i32 @processcompl_compat(%struct.async* %call, i8** %3)
  call void @free_async(%struct.async* %call)
  br label %cleanup

if.end6:                                          ; preds = %entry
  %call7 = call %struct.task_struct* @get_current()
  %call8 = call i32 @signal_pending(%struct.task_struct* %call7)
  %tobool9 = icmp ne i32 %call8, 0
  %. = select i1 %tobool9, i32 -4, i32 -19
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %do.end
  %retval.0 = phi i32 [ %call5, %do.end ], [ %., %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurbnonblock_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %call = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %do.body, label %if.else

do.body:                                          ; preds = %entry
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool2 = trunc i8 %0 to i1
  br i1 %tobool2, label %if.then3, label %do.end

if.then3:                                         ; preds = %do.body
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 11
  %userurb = getelementptr inbounds %struct.async, %struct.async* %call, i32 0, i32 7
  %2 = load i8*, i8** %userurb, align 8, !tbaa !152
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev4, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i8* %2)
  br label %do.end

do.end:                                           ; preds = %if.then3, %do.body
  %3 = bitcast i8* %arg to i8**
  %call5 = call i32 @processcompl_compat(%struct.async* %call, i8** %3)
  call void @free_async(%struct.async* %call)
  br label %if.end8

if.else:                                          ; preds = %entry
  %call6 = call i32 @connected(%struct.usb_dev_state* %ps)
  %tobool7 = icmp ne i32 %call6, 0
  %4 = zext i1 %tobool7 to i64
  %cond = select i1 %tobool7, i32 -11, i32 -19
  br label %if.end8

if.end8:                                          ; preds = %if.else, %do.end
  %retval1.0 = phi i32 [ %call5, %do.end ], [ %cond, %if.else ]
  ret i32 %retval1.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_control(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ctrl = alloca %struct.usbdevfs_ctrltransfer, align 8
  %__UNIQUE_ID_max1_30 = alloca i32, align 4
  %__UNIQUE_ID_max2_31 = alloca i32, align 4
  %__UNIQUE_ID_min1_32 = alloca i32, align 4
  %__UNIQUE_ID_min2_33 = alloca i32, align 4
  %__UNIQUE_ID_max1_34 = alloca i32, align 4
  %__UNIQUE_ID_max2_35 = alloca i32, align 4
  %__UNIQUE_ID_max1_36 = alloca i32, align 4
  %__UNIQUE_ID_max2_37 = alloca i32, align 4
  %__UNIQUE_ID_min1_38 = alloca i32, align 4
  %__UNIQUE_ID_min2_39 = alloca i32, align 4
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !42
  %1 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %1) #7
  %2 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  %call = call i64 @copy_from_user(i8* %2, i8* %arg, i64 24)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %bRequestType = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %3 = load i8, i8* %bRequestType, align 8, !tbaa !153
  %conv = zext i8 %3 to i32
  %bRequest = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %4 = load i8, i8* %bRequest, align 1, !tbaa !155
  %conv2 = zext i8 %4 to i32
  %wIndex = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %5 = load i16, i16* %wIndex, align 4, !tbaa !156
  %conv3 = zext i16 %5 to i32
  %call4 = call i32 @check_ctrlrecip(%struct.usb_dev_state* %ps, i32 %conv, i32 %conv2, i32 %conv3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end
  %wLength8 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %6 = load i16, i16* %wLength8, align 2, !tbaa !157
  %conv9 = zext i16 %6 to i32
  %conv10 = zext i32 %conv9 to i64
  %cmp = icmp ugt i64 %conv10, 4096
  br i1 %cmp, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.end7
  %call14 = call i32 @usbfs_increase_memory_usage(i64 4296)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end13
  %call18 = call i64 @__get_free_pages(i32 20971712, i32 0)
  %7 = inttoptr i64 %call18 to i8*
  %tobool19 = icmp ne i8* %7, null
  br i1 %tobool19, label %if.end21, label %done

if.end21:                                         ; preds = %if.end17
  %timeout = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 5
  %8 = load i32, i32* %timeout, align 8, !tbaa !158
  %9 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool22 = trunc i8 %9 to i1
  br i1 %tobool22, label %if.then23, label %do.end

if.then23:                                        ; preds = %if.end21
  %dev24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %bRequestType25 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %10 = load i8, i8* %bRequestType25, align 8, !tbaa !153
  %conv26 = zext i8 %10 to i32
  %bRequest27 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %11 = load i8, i8* %bRequest27, align 1, !tbaa !155
  %conv28 = zext i8 %11 to i32
  %wValue = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %12 = load i16, i16* %wValue, align 2, !tbaa !159
  %conv29 = zext i16 %12 to i32
  %wIndex30 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %13 = load i16, i16* %wIndex30, align 4, !tbaa !156
  %conv31 = zext i16 %13 to i32
  %wLength32 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %14 = load i16, i16* %wLength32, align 2, !tbaa !157
  %conv33 = zext i16 %14 to i32
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev24, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @.str.34, i32 0, i32 0), i32 %conv26, i32 %conv28, i32 %conv29, i32 %conv31, i32 %conv33)
  br label %do.end

do.end:                                           ; preds = %if.then23, %if.end21
  %bRequestType35 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %15 = load i8, i8* %bRequestType35, align 8, !tbaa !153
  %conv36 = zext i8 %15 to i32
  %and = and i32 %conv36, 128
  %tobool37 = icmp ne i32 %and, 0
  %wLength39 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %16 = load i16, i16* %wLength39, align 2, !tbaa !157
  br i1 %tobool37, label %if.then38, label %if.else

if.then38:                                        ; preds = %do.end
  %conv40 = zext i16 %16 to i32
  %tobool41 = icmp ne i32 %conv40, 0
  br i1 %tobool41, label %land.lhs.true, label %if.end53

land.lhs.true:                                    ; preds = %if.then38
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %17 = load i8*, i8** %data, align 8, !tbaa !160
  %18 = ptrtoint i8* %17 to i64
  %wLength43 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %19 = load i16, i16* %wLength43, align 2, !tbaa !157
  %conv44 = zext i16 %19 to i64
  %call45 = call %struct.task_struct* @get_current()
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call45, i32 0, i32 151
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %20 = load i64, i64* %seg, align 8, !tbaa !161
  %call46 = call zeroext i1 @__chk_range_not_ok(i64 %18, i64 %conv44, i64 %20)
  %frombool = zext i1 %call46 to i8
  %tobool47 = trunc i8 %frombool to i1
  %lnot = xor i1 %tobool47, true
  %lnot48 = xor i1 %lnot, true
  %lnot49 = xor i1 %lnot48, true
  %lnot.ext = zext i1 %lnot49 to i32
  %conv50 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv50, i64 1)
  %tobool51 = icmp ne i64 %expval, 0
  br i1 %tobool51, label %if.end53, label %done

if.end53:                                         ; preds = %land.lhs.true, %if.then38
  %call54 = call i32 @__create_pipe(%struct.usb_device* %0, i32 0)
  %or = or i32 -2147483648, %call54
  %or55 = or i32 %or, 128
  %wLength56 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %21 = load i16, i16* %wLength56, align 2, !tbaa !157
  %conv57 = zext i16 %21 to i32
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %or55, i32 %conv57, i32 %8, i32 0, i8* null, i32 0)
  %dev58 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev58)
  %bRequest59 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %22 = load i8, i8* %bRequest59, align 1, !tbaa !155
  %bRequestType60 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %23 = load i8, i8* %bRequestType60, align 8, !tbaa !153
  %wValue61 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %24 = load i16, i16* %wValue61, align 2, !tbaa !159
  %wIndex62 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %25 = load i16, i16* %wIndex62, align 4, !tbaa !156
  %wLength63 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %26 = load i16, i16* %wLength63, align 2, !tbaa !157
  %call64 = call i32 @usb_control_msg(%struct.usb_device* %0, i32 %or55, i8 zeroext %22, i8 zeroext %23, i16 zeroext %24, i16 zeroext %25, i8* %7, i16 zeroext %26, i32 %8)
  %dev65 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev65)
  %27 = bitcast i32* %__UNIQUE_ID_max1_30 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %27) #7
  store i32 %call64, i32* %__UNIQUE_ID_max1_30, align 4, !tbaa !62
  %28 = bitcast i32* %__UNIQUE_ID_max2_31 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %28) #7
  store i32 0, i32* %__UNIQUE_ID_max2_31, align 4, !tbaa !62
  %cmp66 = icmp eq i32* %__UNIQUE_ID_max1_30, %__UNIQUE_ID_max2_31
  %conv67 = zext i1 %cmp66 to i32
  %29 = load i32, i32* %__UNIQUE_ID_max1_30, align 4, !tbaa !62
  %30 = load i32, i32* %__UNIQUE_ID_max2_31, align 4, !tbaa !62
  %cmp69 = icmp sgt i32 %29, %30
  %31 = load i32, i32* %__UNIQUE_ID_max1_30, align 4
  %32 = load i32, i32* %__UNIQUE_ID_max2_31, align 4
  %cond = select i1 %cmp69, i32 %31, i32 %32
  %33 = bitcast i32* %__UNIQUE_ID_max2_31 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %33) #7
  %34 = bitcast i32* %__UNIQUE_ID_max1_30 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %34) #7
  %35 = bitcast i32* %__UNIQUE_ID_min1_32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %35) #7
  store i32 %call64, i32* %__UNIQUE_ID_min1_32, align 4, !tbaa !62
  %36 = bitcast i32* %__UNIQUE_ID_min2_33 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %36) #7
  store i32 0, i32* %__UNIQUE_ID_min2_33, align 4, !tbaa !62
  %cmp71 = icmp eq i32* %__UNIQUE_ID_min1_32, %__UNIQUE_ID_min2_33
  %conv72 = zext i1 %cmp71 to i32
  %37 = load i32, i32* %__UNIQUE_ID_min1_32, align 4, !tbaa !62
  %38 = load i32, i32* %__UNIQUE_ID_min2_33, align 4, !tbaa !62
  %cmp74 = icmp slt i32 %37, %38
  %39 = load i32, i32* %__UNIQUE_ID_min1_32, align 4
  %40 = load i32, i32* %__UNIQUE_ID_min2_33, align 4
  %cond79 = select i1 %cmp74, i32 %39, i32 %40
  %41 = bitcast i32* %__UNIQUE_ID_min2_33 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %41) #7
  %42 = bitcast i32* %__UNIQUE_ID_min1_32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %42) #7
  %43 = bitcast i32* %__UNIQUE_ID_max1_34 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %43) #7
  store i32 %call64, i32* %__UNIQUE_ID_max1_34, align 4, !tbaa !62
  %44 = bitcast i32* %__UNIQUE_ID_max2_35 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %44) #7
  store i32 0, i32* %__UNIQUE_ID_max2_35, align 4, !tbaa !62
  %cmp80 = icmp eq i32* %__UNIQUE_ID_max1_34, %__UNIQUE_ID_max2_35
  %conv81 = zext i1 %cmp80 to i32
  %45 = load i32, i32* %__UNIQUE_ID_max1_34, align 4, !tbaa !62
  %46 = load i32, i32* %__UNIQUE_ID_max2_35, align 4, !tbaa !62
  %cmp83 = icmp sgt i32 %45, %46
  %47 = load i32, i32* %__UNIQUE_ID_max1_34, align 4
  %48 = load i32, i32* %__UNIQUE_ID_max2_35, align 4
  %cond88 = select i1 %cmp83, i32 %47, i32 %48
  %49 = bitcast i32* %__UNIQUE_ID_max2_35 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %49) #7
  %50 = bitcast i32* %__UNIQUE_ID_max1_34 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %50) #7
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %or55, i32 %cond, i32 %cond79, i32 1, i8* %7, i32 %cond88)
  %cmp89 = icmp sgt i32 %call64, 0
  br i1 %cmp89, label %land.lhs.true91, label %if.end148

land.lhs.true91:                                  ; preds = %if.end53
  %wLength92 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %51 = load i16, i16* %wLength92, align 2, !tbaa !157
  %conv93 = zext i16 %51 to i32
  %tobool94 = icmp ne i32 %conv93, 0
  br i1 %tobool94, label %if.then95, label %if.end148

if.then95:                                        ; preds = %land.lhs.true91
  %data96 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %52 = load i8*, i8** %data96, align 8, !tbaa !160
  %conv97 = sext i32 %call64 to i64
  %call98 = call i64 @copy_to_user(i8* %52, i8* %7, i64 %conv97)
  %tobool99 = icmp ne i64 %call98, 0
  br i1 %tobool99, label %done, label %if.end148

if.else:                                          ; preds = %do.end
  %tobool104 = icmp ne i16 %16, 0
  br i1 %tobool104, label %if.then105, label %if.end113

if.then105:                                       ; preds = %if.else
  %data106 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %53 = load i8*, i8** %data106, align 8, !tbaa !160
  %wLength107 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %54 = load i16, i16* %wLength107, align 2, !tbaa !157
  %conv108 = zext i16 %54 to i64
  %call109 = call i64 @copy_from_user(i8* %7, i8* %53, i64 %conv108)
  %tobool110 = icmp ne i64 %call109, 0
  br i1 %tobool110, label %done, label %if.end113

if.end113:                                        ; preds = %if.then105, %if.else
  %call114 = call i32 @__create_pipe(%struct.usb_device* %0, i32 0)
  %or115 = or i32 -2147483648, %call114
  %wLength116 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %55 = load i16, i16* %wLength116, align 2, !tbaa !157
  %conv117 = zext i16 %55 to i32
  %wLength118 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %56 = load i16, i16* %wLength118, align 2, !tbaa !157
  %conv119 = zext i16 %56 to i32
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %or115, i32 %conv117, i32 %8, i32 0, i8* %7, i32 %conv119)
  %dev120 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev120)
  %call121 = call i32 @__create_pipe(%struct.usb_device* %0, i32 0)
  %or122 = or i32 -2147483648, %call121
  %bRequest123 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %57 = load i8, i8* %bRequest123, align 1, !tbaa !155
  %bRequestType124 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %58 = load i8, i8* %bRequestType124, align 8, !tbaa !153
  %wValue125 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %59 = load i16, i16* %wValue125, align 2, !tbaa !159
  %wIndex126 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %60 = load i16, i16* %wIndex126, align 4, !tbaa !156
  %wLength127 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %61 = load i16, i16* %wLength127, align 2, !tbaa !157
  %call128 = call i32 @usb_control_msg(%struct.usb_device* %0, i32 %or122, i8 zeroext %57, i8 zeroext %58, i16 zeroext %59, i16 zeroext %60, i8* %7, i16 zeroext %61, i32 %8)
  %dev129 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev129)
  %62 = bitcast i32* %__UNIQUE_ID_max1_36 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %62) #7
  store i32 %call128, i32* %__UNIQUE_ID_max1_36, align 4, !tbaa !62
  %63 = bitcast i32* %__UNIQUE_ID_max2_37 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %63) #7
  store i32 0, i32* %__UNIQUE_ID_max2_37, align 4, !tbaa !62
  %cmp130 = icmp eq i32* %__UNIQUE_ID_max1_36, %__UNIQUE_ID_max2_37
  %conv131 = zext i1 %cmp130 to i32
  %64 = load i32, i32* %__UNIQUE_ID_max1_36, align 4, !tbaa !62
  %65 = load i32, i32* %__UNIQUE_ID_max2_37, align 4, !tbaa !62
  %cmp133 = icmp sgt i32 %64, %65
  %66 = load i32, i32* %__UNIQUE_ID_max1_36, align 4
  %67 = load i32, i32* %__UNIQUE_ID_max2_37, align 4
  %cond138 = select i1 %cmp133, i32 %66, i32 %67
  %68 = bitcast i32* %__UNIQUE_ID_max2_37 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %68) #7
  %69 = bitcast i32* %__UNIQUE_ID_max1_36 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %69) #7
  %70 = bitcast i32* %__UNIQUE_ID_min1_38 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %70) #7
  store i32 %call128, i32* %__UNIQUE_ID_min1_38, align 4, !tbaa !62
  %71 = bitcast i32* %__UNIQUE_ID_min2_39 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %71) #7
  store i32 0, i32* %__UNIQUE_ID_min2_39, align 4, !tbaa !62
  %cmp139 = icmp eq i32* %__UNIQUE_ID_min1_38, %__UNIQUE_ID_min2_39
  %conv140 = zext i1 %cmp139 to i32
  %72 = load i32, i32* %__UNIQUE_ID_min1_38, align 4, !tbaa !62
  %73 = load i32, i32* %__UNIQUE_ID_min2_39, align 4, !tbaa !62
  %cmp142 = icmp slt i32 %72, %73
  %74 = load i32, i32* %__UNIQUE_ID_min1_38, align 4
  %75 = load i32, i32* %__UNIQUE_ID_min2_39, align 4
  %cond147 = select i1 %cmp142, i32 %74, i32 %75
  %76 = bitcast i32* %__UNIQUE_ID_min2_39 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %76) #7
  %77 = bitcast i32* %__UNIQUE_ID_min1_38 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %77) #7
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %or115, i32 %cond138, i32 %cond147, i32 1, i8* null, i32 0)
  br label %if.end148

if.end148:                                        ; preds = %if.end53, %land.lhs.true91, %if.then95, %if.end113
  %i.0 = phi i32 [ %call128, %if.end113 ], [ %call64, %if.then95 ], [ %call64, %land.lhs.true91 ], [ %call64, %if.end53 ]
  %cmp149 = icmp slt i32 %i.0, 0
  %cmp152 = icmp ne i32 %i.0, -32
  %or.cond = and i1 %cmp149, %cmp152
  br i1 %or.cond, label %if.then154, label %done

if.then154:                                       ; preds = %if.end148
  %dev155 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %call156 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call156, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %bRequestType157 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %78 = load i8, i8* %bRequestType157, align 8, !tbaa !153
  %conv158 = zext i8 %78 to i32
  %bRequest159 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %79 = load i8, i8* %bRequest159, align 1, !tbaa !155
  %conv160 = zext i8 %79 to i32
  %wLength161 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %80 = load i16, i16* %wLength161, align 2, !tbaa !157
  %conv162 = zext i16 %80 to i32
  call void (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), %struct.device* %dev155, i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.36, i32 0, i32 0), i8* %arraydecay, i32 %conv158, i32 %conv160, i32 %conv162, i32 %i.0)
  br label %done

done:                                             ; preds = %if.end148, %if.then154, %if.then105, %if.then95, %land.lhs.true, %if.end17
  %ret.0 = phi i32 [ -12, %if.end17 ], [ -22, %land.lhs.true ], [ -14, %if.then95 ], [ -14, %if.then105 ], [ %i.0, %if.then154 ], [ %i.0, %if.end148 ]
  %81 = ptrtoint i8* %7 to i64
  call void @free_pages(i64 %81, i32 0)
  call void @usbfs_decrease_memory_usage(i64 4296)
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %if.end7, %if.end, %entry, %done
  %retval.0 = phi i32 [ %ret.0, %done ], [ -14, %entry ], [ %call4, %if.end ], [ -22, %if.end7 ], [ %call14, %if.end13 ]
  %82 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %82) #7
  ret i32 %retval.0
}

declare { i64, i64 } @current_time(%struct.inode*) #1

; Function Attrs: nounwind uwtable
define internal i32 @proc_bulk(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %bulk = alloca %struct.usbdevfs_bulktransfer, align 8
  %len2 = alloca i32, align 4
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !42
  %1 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %1) #7
  %2 = bitcast i32* %len2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #7
  %3 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  %call = call i64 @copy_from_user(i8* %3, i8* %arg, i64 24)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !42
  %ep = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %5 = load i32, i32* %ep, align 8, !tbaa !162
  %call3 = call i32 @findintfep(%struct.usb_device* %4, i32 %5)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %call3)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end5
  %ep10 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %6 = load i32, i32* %ep10, align 8, !tbaa !162
  %and = and i32 %6, 128
  %tobool11 = icmp ne i32 %and, 0
  %ep13 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %7 = load i32, i32* %ep13, align 8, !tbaa !162
  %and14 = and i32 %7, 127
  %call15 = call i32 @__create_pipe(%struct.usb_device* %0, i32 %and14)
  %or = or i32 -1073741824, %call15
  %or16 = or i32 %or, 128
  %pipe.0 = select i1 %tobool11, i32 %or16, i32 %or
  %ep22 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %8 = load i32, i32* %ep22, align 8, !tbaa !162
  %and23 = and i32 %8, 128
  %tobool24 = icmp ne i32 %and23, 0
  %lnot = xor i1 %tobool24, true
  %lnot.ext = zext i1 %lnot to i32
  %call25 = call zeroext i16 @usb_maxpacket(%struct.usb_device* %0, i32 %pipe.0, i32 %lnot.ext)
  %tobool26 = icmp ne i16 %call25, 0
  br i1 %tobool26, label %if.end28, label %cleanup

if.end28:                                         ; preds = %if.end9
  %len = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 1
  %9 = load i32, i32* %len, align 4, !tbaa !164
  %conv = zext i32 %9 to i64
  %cmp29 = icmp uge i64 %conv, 2147483455
  br i1 %cmp29, label %cleanup, label %if.end32

if.end32:                                         ; preds = %if.end28
  %conv33 = zext i32 %9 to i64
  %add = add i64 %conv33, 192
  %call34 = call i32 @usbfs_increase_memory_usage(i64 %add)
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %cleanup, label %if.end37

if.end37:                                         ; preds = %if.end32
  %conv38 = zext i32 %9 to i64
  %call39 = call i8* @kmalloc(i64 %conv38, i32 20971712)
  %tobool40 = icmp ne i8* %call39, null
  br i1 %tobool40, label %if.end42, label %done

if.end42:                                         ; preds = %if.end37
  %timeout = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 2
  %10 = load i32, i32* %timeout, align 8, !tbaa !165
  %ep43 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %11 = load i32, i32* %ep43, align 8, !tbaa !162
  %and44 = and i32 %11, 128
  %tobool45 = icmp ne i32 %and44, 0
  %tobool47 = icmp ne i32 %9, 0
  br i1 %tobool45, label %if.then46, label %if.else77

if.then46:                                        ; preds = %if.end42
  br i1 %tobool47, label %land.lhs.true, label %if.end62

land.lhs.true:                                    ; preds = %if.then46
  %data = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %12 = load i8*, i8** %data, align 8, !tbaa !166
  %13 = ptrtoint i8* %12 to i64
  %conv49 = zext i32 %9 to i64
  %call50 = call %struct.task_struct* @get_current()
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call50, i32 0, i32 151
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %14 = load i64, i64* %seg, align 8, !tbaa !161
  %call51 = call zeroext i1 @__chk_range_not_ok(i64 %13, i64 %conv49, i64 %14)
  %frombool = zext i1 %call51 to i8
  %tobool52 = trunc i8 %frombool to i1
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv59, i64 1)
  %tobool60 = icmp ne i64 %expval, 0
  br i1 %tobool60, label %if.end62, label %done

if.end62:                                         ; preds = %land.lhs.true, %if.then46
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %pipe.0, i32 %9, i32 %10, i32 0, i8* null, i32 0)
  %dev63 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev63)
  %call64 = call i32 @usb_bulk_msg(%struct.usb_device* %0, i32 %pipe.0, i8* %call39, i32 %9, i32* %len2, i32 %10)
  %dev65 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev65)
  %15 = load i32, i32* %len2, align 4, !tbaa !62
  %16 = load i32, i32* %len2, align 4, !tbaa !62
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %pipe.0, i32 %15, i32 %call64, i32 1, i8* %call39, i32 %16)
  %tobool66 = icmp eq i32 %call64, 0
  %17 = load i32, i32* %len2, align 4
  %tobool68 = icmp ne i32 %17, 0
  %or.cond = and i1 %tobool66, %tobool68
  br i1 %or.cond, label %if.then69, label %if.end90

if.then69:                                        ; preds = %if.end62
  %data70 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %18 = load i8*, i8** %data70, align 8, !tbaa !166
  %19 = load i32, i32* %len2, align 4, !tbaa !62
  %conv71 = sext i32 %19 to i64
  %call72 = call i64 @copy_to_user(i8* %18, i8* %call39, i64 %conv71)
  %tobool73 = icmp ne i64 %call72, 0
  br i1 %tobool73, label %done, label %if.end90

if.else77:                                        ; preds = %if.end42
  br i1 %tobool47, label %if.then79, label %if.end86

if.then79:                                        ; preds = %if.else77
  %data80 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %20 = load i8*, i8** %data80, align 8, !tbaa !166
  %conv81 = zext i32 %9 to i64
  %call82 = call i64 @copy_from_user(i8* %call39, i8* %20, i64 %conv81)
  %tobool83 = icmp ne i64 %call82, 0
  br i1 %tobool83, label %done, label %if.end86

if.end86:                                         ; preds = %if.then79, %if.else77
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %pipe.0, i32 %9, i32 %10, i32 0, i8* %call39, i32 %9)
  %dev87 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev87)
  %call88 = call i32 @usb_bulk_msg(%struct.usb_device* %0, i32 %pipe.0, i8* %call39, i32 %9, i32* %len2, i32 %10)
  %dev89 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev89)
  %21 = load i32, i32* %len2, align 4, !tbaa !62
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %pipe.0, i32 %21, i32 %call88, i32 1, i8* null, i32 0)
  br label %if.end90

if.end90:                                         ; preds = %if.end62, %if.then69, %if.end86
  %i.0 = phi i32 [ %call88, %if.end86 ], [ %call64, %if.then69 ], [ %call64, %if.end62 ]
  %cmp91 = icmp slt i32 %i.0, 0
  %22 = load i32, i32* %len2, align 4
  %cond = select i1 %cmp91, i32 %i.0, i32 %22
  br label %done

done:                                             ; preds = %if.end90, %if.then79, %if.then69, %land.lhs.true, %if.end37
  %ret.0 = phi i32 [ -12, %if.end37 ], [ -22, %land.lhs.true ], [ -14, %if.then69 ], [ -14, %if.then79 ], [ %cond, %if.end90 ]
  call void @kfree(i8* %call39)
  %conv93 = zext i32 %9 to i64
  %add94 = add i64 %conv93, 192
  call void @usbfs_decrease_memory_usage(i64 %add94)
  br label %cleanup

cleanup:                                          ; preds = %if.end32, %if.end28, %if.end9, %if.end5, %if.end, %entry, %done
  %retval.0 = phi i32 [ %ret.0, %done ], [ -14, %entry ], [ %call3, %if.end ], [ %call6, %if.end5 ], [ -22, %if.end9 ], [ -22, %if.end28 ], [ %call34, %if.end32 ]
  %23 = bitcast i32* %len2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %23) #7
  %24 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %24) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_resetep(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #7, !srcloc !167
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %1, 2
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %call = call i32 @findintfep(%struct.usb_device* %4, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %call)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end6
  %dev11 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8, !tbaa !42
  call void @check_reset_of_active_ep(%struct.usb_device* %5, i32 %conv, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.51, i32 0, i32 0))
  %dev12 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev12, align 8, !tbaa !42
  call void @usb_reset_endpoint(%struct.usb_device* %6, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end, %entry, %if.end10
  %retval.0 = phi i32 [ 0, %if.end10 ], [ -14, %entry ], [ %call, %if.end ], [ %call7, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_resetdevice(%struct.usb_dev_state* %ps) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8, !tbaa !168
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 15
  %2 = load i8, i8* %privileges_dropped, align 8, !tbaa !169, !range !132
  %tobool = trunc i8 %2 to i1
  %tobool2 = icmp ne %struct.usb_host_config* %1, null
  %or.cond = and i1 %tobool, %tobool2
  br i1 %or.cond, label %if.then, label %if.end21

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %3 = load i8, i8* %bNumInterfaces, align 4, !tbaa !170
  %conv = zext i8 %3 to i32
  %cmp = icmp slt i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %if.end21

for.body:                                         ; preds = %for.cond
  %interface4 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface4, i64 0, i64 %idxprom
  %4 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !56
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 1
  %5 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !171
  %desc5 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %5, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc5, i32 0, i32 2
  %6 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !31
  %conv6 = zext i8 %6 to i32
  %call = call i32 @usb_interface_claimed(%struct.usb_interface* %4)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %cond.false, label %for.inc

cond.false:                                       ; preds = %for.body
  %conv12 = sext i32 %conv6 to i64
  %ifclaimed13 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 12
  %call14 = call zeroext i1 @variable_test_bit(i64 %conv12, i64* %ifclaimed13)
  br i1 %call14, label %for.inc, label %if.then16

if.then16:                                        ; preds = %cond.false
  %dev17 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %dev17, align 8, !tbaa !42
  %dev18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 11
  %dev19 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev19, i32 0, i32 7
  %8 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !172
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %8, i32 0, i32 0
  %9 = load i8*, i8** %name, align 8, !tbaa !173
  %call20 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call20, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev18, i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.53, i32 0, i32 0), i32 %conv6, i8* %9, i8* %arraydecay)
  br label %cleanup

for.inc:                                          ; preds = %for.body, %cond.false
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end21:                                         ; preds = %for.cond, %entry
  %dev22 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev22, align 8, !tbaa !42
  %call23 = call i32 @usb_reset_device(%struct.usb_device* %10)
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %if.then16
  %retval.0 = phi i32 [ -13, %if.then16 ], [ %call23, %if.end21 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_clearhalt(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #7, !srcloc !175
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %1, 2
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %call = call i32 @findintfep(%struct.usb_device* %4, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %call)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end6
  %dev11 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8, !tbaa !42
  call void @check_reset_of_active_ep(%struct.usb_device* %5, i32 %conv, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.54, i32 0, i32 0))
  %and = and i32 %conv, 128
  %tobool12 = icmp ne i32 %and, 0
  %dev14 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev14, align 8, !tbaa !42
  %and15 = and i32 %conv, 127
  %call16 = call i32 @__create_pipe(%struct.usb_device* %6, i32 %and15)
  %or = or i32 -1073741824, %call16
  %or17 = or i32 %or, 128
  %pipe.0 = select i1 %tobool12, i32 %or17, i32 %or
  %dev23 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %dev23, align 8, !tbaa !42
  %call24 = call i32 @usb_clear_halt(%struct.usb_device* %7, i32 %pipe.0)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end, %entry, %if.end10
  %retval.0 = phi i32 [ %call24, %if.end10 ], [ -14, %entry ], [ %call, %if.end ], [ %call7, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_getdriver(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %gd = alloca %struct.usbdevfs_getdriver, align 4
  %0 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  call void @llvm.lifetime.start.p0i8(i64 260, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 260)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %interface = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 0
  %3 = load i32, i32* %interface, align 4, !tbaa !176
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %2, i32 %3)
  %tobool2 = icmp ne %struct.usb_interface* %call1, null
  br i1 %tobool2, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %dev3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev3, i32 0, i32 7
  %4 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !172
  %tobool4 = icmp ne %struct.device_driver* %4, null
  br i1 %tobool4, label %if.else, label %cleanup

if.else:                                          ; preds = %lor.lhs.false
  %driver6 = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 1
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver6, i32 0, i32 0
  %dev7 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver8 = getelementptr inbounds %struct.device, %struct.device* %dev7, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver8, align 8, !tbaa !172
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %5, i32 0, i32 0
  %6 = load i8*, i8** %name, align 8, !tbaa !173
  %call9 = call i64 @strlcpy(i8* %arraydecay, i8* %6, i64 256)
  %7 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  %call10 = call i64 @copy_to_user(i8* %arg, i8* %7, i64 260)
  %tobool11 = icmp ne i64 %call10, 0
  %8 = zext i1 %tobool11 to i64
  %cond = select i1 %tobool11, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.else, %lor.lhs.false, %if.end, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ %cond, %if.else ], [ -61, %lor.lhs.false ], [ -61, %if.end ]
  %9 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  call void @llvm.lifetime.end.p0i8(i64 260, i8* %9) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_connectinfo(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ci = alloca %struct.usbdevfs_connectinfo, align 4
  %0 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 8, i32 4, i1 false)
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 0
  %3 = load i32, i32* %devnum, align 8, !tbaa !178
  %devnum1 = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 0
  store i32 %3, i32* %devnum1, align 4, !tbaa !179
  %dev2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !42
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 4
  %5 = load i32, i32* %speed, align 4, !tbaa !181
  %cmp = icmp eq i32 %5, 1
  %conv = zext i1 %cmp to i32
  %conv3 = trunc i32 %conv to i8
  %slow = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 1
  store i8 %conv3, i8* %slow, align 4, !tbaa !182
  %6 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  %call = call i64 @copy_to_user(i8* %arg, i8* %6, i64 8)
  %tobool = icmp ne i64 %call, 0
  %. = select i1 %tobool, i32 -14, i32 0
  %7 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_setintf(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %setintf = alloca %struct.usbdevfs_setinterface, align 4
  %0 = bitcast %struct.usbdevfs_setinterface* %setintf to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_setinterface* %setintf to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 8)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %interface = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 0
  %2 = load i32, i32* %interface, align 4, !tbaa !183
  %call1 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %2)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %interface5 = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 0
  %3 = load i32, i32* %interface5, align 4, !tbaa !183
  call void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %3)
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %interface6 = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 0
  %5 = load i32, i32* %interface6, align 4, !tbaa !183
  %altsetting = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 1
  %6 = load i32, i32* %altsetting, align 4, !tbaa !185
  %call7 = call i32 @usb_set_interface(%struct.usb_device* %4, i32 %5, i32 %6)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end4
  %retval.0 = phi i32 [ %call7, %if.end4 ], [ -14, %entry ], [ %call1, %if.end ]
  %7 = bitcast %struct.usbdevfs_setinterface* %setintf to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_setconfig(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #7, !srcloc !186
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %1, 2
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 15
  %5 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8, !tbaa !168
  %tobool5 = icmp ne %struct.usb_host_config* %5, null
  br i1 %tobool5, label %if.then6, label %if.end24

if.then6:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then6
  %i.0 = phi i32 [ 0, %if.then6 ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %6 = load i8, i8* %bNumInterfaces, align 4, !tbaa !170
  %conv7 = zext i8 %6 to i32
  %cmp = icmp slt i32 %i.0, %conv7
  br i1 %cmp, label %for.body, label %if.end24

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %7 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !56
  %call = call i32 @usb_interface_claimed(%struct.usb_interface* %7)
  %tobool9 = icmp ne i32 %call, 0
  br i1 %tobool9, label %if.then10, label %for.inc

if.then10:                                        ; preds = %for.body
  %dev11 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8, !tbaa !42
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  %interface13 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 3
  %idxprom14 = sext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface13, i64 0, i64 %idxprom14
  %9 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx15, align 8, !tbaa !56
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %9, i32 0, i32 1
  %10 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !171
  %desc16 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %10, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc16, i32 0, i32 2
  %11 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !31
  %conv17 = zext i8 %11 to i32
  %interface18 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 3
  %idxprom19 = sext i32 %i.0 to i64
  %arrayidx20 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface18, i64 0, i64 %idxprom19
  %12 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx20, align 8, !tbaa !56
  %dev21 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev21, i32 0, i32 7
  %13 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !172
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %13, i32 0, i32 0
  %14 = load i8*, i8** %name, align 8, !tbaa !173
  %call22 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call22, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev12, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.55, i32 0, i32 0), i32 %conv17, i8* %14, i8* %arraydecay, i32 %conv)
  br label %if.end24

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end24:                                         ; preds = %if.then10, %for.cond, %if.end
  %status.1 = phi i32 [ 0, %if.end ], [ -16, %if.then10 ], [ 0, %for.cond ]
  %cmp25 = icmp eq i32 %status.1, 0
  br i1 %cmp25, label %if.then27, label %cleanup

if.then27:                                        ; preds = %if.end24
  %tobool28 = icmp ne %struct.usb_host_config* %5, null
  br i1 %tobool28, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then27
  %desc29 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc29, i32 0, i32 4
  %15 = load i8, i8* %bConfigurationValue, align 1, !tbaa !187
  %conv30 = zext i8 %15 to i32
  %cmp31 = icmp eq i32 %conv30, %conv
  br i1 %cmp31, label %if.then33, label %if.else

if.then33:                                        ; preds = %land.lhs.true
  %dev34 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %16 = load %struct.usb_device*, %struct.usb_device** %dev34, align 8, !tbaa !42
  %call35 = call i32 @usb_reset_configuration(%struct.usb_device* %16)
  br label %cleanup

if.else:                                          ; preds = %land.lhs.true, %if.then27
  %dev36 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %17 = load %struct.usb_device*, %struct.usb_device** %dev36, align 8, !tbaa !42
  %call37 = call i32 @usb_set_configuration(%struct.usb_device* %17, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end24, %if.else, %if.then33, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ %status.1, %if.end24 ], [ %call35, %if.then33 ], [ %call37, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_submiturb(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %uurb = alloca %struct.usbdevfs_urb, align 8
  %0 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 56)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast i8* %arg to %struct.usbdevfs_urb*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc, i32 0, i32 0
  %call1 = call i32 @proc_do_submiturb(%struct.usb_dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %arraydecay, i8* %arg)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  %3 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  call void @llvm.lifetime.end.p0i8(i64 56, i8* %3) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_control_compat(%struct.usb_dev_state* %ps, %struct.usbdevfs_ctrltransfer32* %p32) #0 {
entry:
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_ctrltransfer*
  %1 = bitcast %struct.usbdevfs_ctrltransfer* %0 to i8*
  %2 = bitcast %struct.usbdevfs_ctrltransfer32* %p32 to i8*
  %call1 = call i64 @copy_in_user(i8* %1, i8* %2, i32 12)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer32, %struct.usbdevfs_ctrltransfer32* %p32, i32 0, i32 6
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4, i8* undef) #7, !srcloc !188
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult3 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  %conv = trunc i64 %asmresult2 to i32
  %conv4 = sext i32 %5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %cleanup, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  call void @might_fault()
  %call7 = call i8* @compat_ptr(i32 %conv)
  %data8 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %0, i32 0, i32 6
  %6 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %call7, i8** %data8) #7, !srcloc !189
  %7 = ptrtoint i8* %6 to i64
  %8 = trunc i64 %7 to i32
  %conv10 = sext i32 %8 to i64
  %expval11 = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool12 = icmp ne i64 %expval11, 0
  br i1 %tobool12, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false6
  %9 = bitcast %struct.usbdevfs_ctrltransfer* %0 to i8*
  %call13 = call i32 @proc_control(%struct.usb_dev_state* %ps, i8* %9)
  br label %cleanup

cleanup:                                          ; preds = %entry, %lor.lhs.false, %lor.lhs.false6, %if.end
  %retval.0 = phi i32 [ %call13, %if.end ], [ -14, %lor.lhs.false6 ], [ -14, %lor.lhs.false ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_bulk_compat(%struct.usb_dev_state* %ps, %struct.usbdevfs_bulktransfer32* %p32) #0 {
entry:
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_bulktransfer*
  call void @might_fault()
  %ep = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %p32, i32 0, i32 0
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %ep, i64 4, i8* undef) #7, !srcloc !190
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %1, 2
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %ep4 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 0
  %4 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv, i32* %ep4) #7, !srcloc !191
  %conv6 = sext i32 %4 to i64
  %expval7 = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool8 = icmp ne i64 %expval7, 0
  br i1 %tobool8, label %cleanup, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  call void @might_fault()
  %len = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %p32, i32 0, i32 1
  %5 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %len, i64 4, i8* undef) #7, !srcloc !192
  %asmresult13 = extractvalue { i32*, i64, i8* } %5, 0
  %asmresult14 = extractvalue { i32*, i64, i8* } %5, 1
  %asmresult15 = extractvalue { i32*, i64, i8* } %5, 2
  %6 = ptrtoint i32* %asmresult13 to i64
  %7 = trunc i64 %6 to i32
  %conv16 = trunc i64 %asmresult14 to i32
  %conv18 = sext i32 %7 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %cleanup, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %lor.lhs.false9
  call void @might_fault()
  %len24 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 1
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv16, i32* %len24) #7, !srcloc !193
  %conv26 = sext i32 %8 to i64
  %expval27 = call i64 @llvm.expect.i64(i64 %conv26, i64 0)
  %tobool28 = icmp ne i64 %expval27, 0
  br i1 %tobool28, label %cleanup, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %lor.lhs.false21
  call void @might_fault()
  %timeout = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %p32, i32 0, i32 2
  %9 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %timeout, i64 4, i8* undef) #7, !srcloc !194
  %asmresult33 = extractvalue { i32*, i64, i8* } %9, 0
  %asmresult34 = extractvalue { i32*, i64, i8* } %9, 1
  %asmresult35 = extractvalue { i32*, i64, i8* } %9, 2
  %10 = ptrtoint i32* %asmresult33 to i64
  %11 = trunc i64 %10 to i32
  %conv36 = trunc i64 %asmresult34 to i32
  %conv38 = sext i32 %11 to i64
  %expval39 = call i64 @llvm.expect.i64(i64 %conv38, i64 0)
  %tobool40 = icmp ne i64 %expval39, 0
  br i1 %tobool40, label %cleanup, label %lor.lhs.false41

lor.lhs.false41:                                  ; preds = %lor.lhs.false29
  call void @might_fault()
  %timeout44 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 2
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv36, i32* %timeout44) #7, !srcloc !195
  %conv46 = sext i32 %12 to i64
  %expval47 = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool48 = icmp ne i64 %expval47, 0
  br i1 %tobool48, label %cleanup, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %lor.lhs.false41
  call void @might_fault()
  %data = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %p32, i32 0, i32 3
  %13 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4, i8* undef) #7, !srcloc !196
  %asmresult53 = extractvalue { i32*, i64, i8* } %13, 0
  %asmresult54 = extractvalue { i32*, i64, i8* } %13, 1
  %asmresult55 = extractvalue { i32*, i64, i8* } %13, 2
  %14 = ptrtoint i32* %asmresult53 to i64
  %15 = trunc i64 %14 to i32
  %conv56 = trunc i64 %asmresult54 to i32
  %conv58 = sext i32 %15 to i64
  %expval59 = call i64 @llvm.expect.i64(i64 %conv58, i64 0)
  %tobool60 = icmp ne i64 %expval59, 0
  br i1 %tobool60, label %cleanup, label %lor.lhs.false61

lor.lhs.false61:                                  ; preds = %lor.lhs.false49
  call void @might_fault()
  %call64 = call i8* @compat_ptr(i32 %conv56)
  %data65 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 3
  %16 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %call64, i8** %data65) #7, !srcloc !197
  %17 = ptrtoint i8* %16 to i64
  %18 = trunc i64 %17 to i32
  %conv67 = sext i32 %18 to i64
  %expval68 = call i64 @llvm.expect.i64(i64 %conv67, i64 0)
  %tobool69 = icmp ne i64 %expval68, 0
  br i1 %tobool69, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false61
  %19 = bitcast %struct.usbdevfs_bulktransfer* %0 to i8*
  %call70 = call i32 @proc_bulk(%struct.usb_dev_state* %ps, i8* %19)
  br label %cleanup

cleanup:                                          ; preds = %entry, %lor.lhs.false, %lor.lhs.false9, %lor.lhs.false21, %lor.lhs.false29, %lor.lhs.false41, %lor.lhs.false49, %lor.lhs.false61, %if.end
  %retval.0 = phi i32 [ %call70, %if.end ], [ -14, %lor.lhs.false61 ], [ -14, %lor.lhs.false49 ], [ -14, %lor.lhs.false41 ], [ -14, %lor.lhs.false29 ], [ -14, %lor.lhs.false21 ], [ -14, %lor.lhs.false9 ], [ -14, %lor.lhs.false ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_disconnectsignal_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ds = alloca %struct.usbdevfs_disconnectsignal32, align 4
  %0 = bitcast %struct.usbdevfs_disconnectsignal32* %ds to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_disconnectsignal32* %ds to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 8)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %signr = getelementptr inbounds %struct.usbdevfs_disconnectsignal32, %struct.usbdevfs_disconnectsignal32* %ds, i32 0, i32 0
  %2 = load i32, i32* %signr, align 4, !tbaa !198
  %discsignr = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 8
  store i32 %2, i32* %discsignr, align 8, !tbaa !200
  %context = getelementptr inbounds %struct.usbdevfs_disconnectsignal32, %struct.usbdevfs_disconnectsignal32* %ds, i32 0, i32 1
  %3 = load i32, i32* %context, align 4, !tbaa !201
  %call1 = call i8* @compat_ptr(i32 %3)
  %disccontext = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 11
  store i8* %call1, i8** %disccontext, align 8, !tbaa !202
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ -14, %entry ]
  %4 = bitcast %struct.usbdevfs_disconnectsignal32* %ds to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_submiturb_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %uurb = alloca %struct.usbdevfs_urb, align 8
  %0 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* %0) #7
  %1 = bitcast i8* %arg to %struct.usbdevfs_urb32*
  %call = call i32 @get_urb32(%struct.usbdevfs_urb* %uurb, %struct.usbdevfs_urb32* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast i8* %arg to %struct.usbdevfs_urb32*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc, i32 0, i32 0
  %call1 = call i32 @proc_do_submiturb(%struct.usb_dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %arraydecay, i8* %arg)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  %3 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  call void @llvm.lifetime.end.p0i8(i64 56, i8* %3) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_ioctl_compat(%struct.usb_dev_state* %ps, i32 %arg) #0 {
entry:
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  %0 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  %conv = zext i32 %arg to i64
  %conv1 = trunc i64 %conv to i32
  %call = call i8* @compat_ptr(i32 %conv1)
  %1 = bitcast i8* %call to %struct.usbdevfs_ioctl32*
  %2 = ptrtoint %struct.usbdevfs_ioctl32* %1 to i64
  %call3 = call %struct.task_struct* @get_current()
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call3, i32 0, i32 151
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %3 = load i64, i64* %seg, align 8, !tbaa !161
  %call4 = call zeroext i1 @__chk_range_not_ok(i64 %2, i64 12, i64 %3)
  %frombool = zext i1 %call4 to i8
  %tobool = trunc i8 %frombool to i1
  %lnot = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  call void @stac()
  %ifno = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %1, i32 0, i32 0
  %4 = bitcast i32* %ifno to %struct.__large_struct*
  %5 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %4, i32 -14, i32 0) #7, !srcloc !203
  %asmresult = extractvalue { i32, i64 } %5, 0
  %asmresult9 = extractvalue { i32, i64 } %5, 1
  call void @clac()
  %conv10 = trunc i64 %asmresult9 to i32
  %ifno11 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 0
  store i32 %conv10, i32* %ifno11, align 8, !tbaa !204
  %conv13 = sext i32 %asmresult to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %cleanup, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %lor.lhs.false
  call void @stac()
  %ioctl_code = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %1, i32 0, i32 1
  %6 = bitcast i32* %ioctl_code to %struct.__large_struct*
  %7 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %6, i32 -14, i32 0) #7, !srcloc !206
  %asmresult20 = extractvalue { i32, i64 } %7, 0
  %asmresult21 = extractvalue { i32, i64 } %7, 1
  call void @clac()
  %conv24 = trunc i64 %asmresult21 to i32
  %ioctl_code25 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 1
  store i32 %conv24, i32* %ioctl_code25, align 4, !tbaa !207
  %conv27 = sext i32 %asmresult20 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %cleanup, label %lor.lhs.false30

lor.lhs.false30:                                  ; preds = %lor.lhs.false16
  call void @stac()
  %data = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %1, i32 0, i32 2
  %8 = bitcast i32* %data to %struct.__large_struct*
  %9 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %8, i32 -14, i32 0) #7, !srcloc !208
  %asmresult34 = extractvalue { i32, i64 } %9, 0
  %asmresult35 = extractvalue { i32, i64 } %9, 1
  call void @clac()
  %conv38 = trunc i64 %asmresult35 to i32
  %conv40 = sext i32 %asmresult34 to i64
  %expval41 = call i64 @llvm.expect.i64(i64 %conv40, i64 0)
  %tobool42 = icmp ne i64 %expval41, 0
  br i1 %tobool42, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false30
  %call43 = call i8* @compat_ptr(i32 %conv38)
  %data44 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 2
  store i8* %call43, i8** %data44, align 8, !tbaa !209
  %call45 = call i32 @proc_ioctl(%struct.usb_dev_state* %ps, %struct.usbdevfs_ioctl* %ctrl)
  br label %cleanup

cleanup:                                          ; preds = %entry, %lor.lhs.false, %lor.lhs.false16, %lor.lhs.false30, %if.end
  %retval.0 = phi i32 [ %call45, %if.end ], [ -14, %lor.lhs.false30 ], [ -14, %lor.lhs.false16 ], [ -14, %lor.lhs.false ], [ -14, %entry ]
  %10 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %10) #7
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ptr_to_compat(i8* %uptr) #3 {
entry:
  %0 = ptrtoint i8* %uptr to i64
  %conv = trunc i64 %0 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_unlinkurb(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %call5 = call %struct.async* @async_getpending(%struct.usb_dev_state* %ps, i8* %arg)
  %tobool = icmp ne %struct.async* %call5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %lock6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock6, i64 %call2)
  br label %cleanup

if.end:                                           ; preds = %entry
  %urb7 = getelementptr inbounds %struct.async, %struct.async* %call5, i32 0, i32 8
  %4 = load %struct.urb*, %struct.urb** %urb7, align 8, !tbaa !141
  %call8 = call %struct.urb* @usb_get_urb(%struct.urb* %4)
  %lock9 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock9, i64 %call2)
  call void @usb_kill_urb(%struct.urb* %4)
  call void @usb_free_urb(%struct.urb* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.end ], [ -22, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_disconnectsignal(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ds = alloca %struct.usbdevfs_disconnectsignal, align 8
  %0 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 16)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %signr = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 0
  %2 = load i32, i32* %signr, align 8, !tbaa !210
  %discsignr = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 8
  store i32 %2, i32* %discsignr, align 8, !tbaa !200
  %context = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 1
  %3 = load i8*, i8** %context, align 8, !tbaa !212
  %disccontext = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 11
  store i8* %3, i8** %disccontext, align 8, !tbaa !202
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ -14, %entry ]
  %4 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %4) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_claiminterface(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #7, !srcloc !213
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %1, 2
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @claimintf(%struct.usb_dev_state* %ps, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call, %if.end ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_releaseinterface(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #7, !srcloc !214
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %1, 2
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @releaseintf(%struct.usb_dev_state* %ps, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  call void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end6
  %retval.0 = phi i32 [ 0, %if.end6 ], [ -14, %entry ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_ioctl_default(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  %0 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 16)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @proc_ioctl(%struct.usb_dev_state* %ps, %struct.usbdevfs_ioctl* %ctrl)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  %2 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %2) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_claim_port(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #7, !srcloc !215
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %1, 2
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %call = call i32 @usb_hub_claim_port(%struct.usb_device* %4, i32 %conv, %struct.usb_dev_state* %ps)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %5 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool6 = trunc i8 %5 to i1
  br i1 %tobool6, label %if.then7, label %cleanup

if.then7:                                         ; preds = %do.body
  %dev8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev8, align 8, !tbaa !42
  %dev9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 11
  %call10 = call %struct.task_struct* @get_current()
  %call11 = call i32 @task_pid_nr(%struct.task_struct* %call10)
  %call12 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call12, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev9, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.59, i32 0, i32 0), i32 %conv, i32 %call11, i8* %arraydecay)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then7, %do.body, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ %call, %do.body ], [ %call, %if.then7 ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_release_port(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4, i8* undef) #7, !srcloc !216
  %asmresult = extractvalue { i32*, i64, i8* } %1, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %1, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %1, 2
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %conv3 = sext i32 %3 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv3, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %call = call i32 @usb_hub_release_port(%struct.usb_device* %4, i32 %conv, %struct.usb_dev_state* %ps)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call, %if.end ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_get_capabilities(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !217
  %no_stop_on_short = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %1, i32 0, i32 6
  %bf.load = load i8, i8* %no_stop_on_short, align 1
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  %or = or i32 117, 2
  %.or = select i1 %tobool, i32 117, i32 %or
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !42
  %bus2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus2, align 8, !tbaa !217
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %3, i32 0, i32 7
  %4 = load i32, i32* %sg_tablesize, align 4, !tbaa !218
  %tobool3 = icmp ne i32 %4, 0
  %or5 = or i32 %.or, 8
  %caps.1 = select i1 %tobool3, i32 %or5, i32 %.or
  call void @might_fault()
  %5 = bitcast i8* %arg to i32*
  %6 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %caps.1, i32* %5) #7, !srcloc !221
  %conv = sext i32 %6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  %. = select i1 %tobool7, i32 -14, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_disconnect_claim(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %dc = alloca %struct.usbdevfs_disconnect_claim, align 4
  %0 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  call void @llvm.lifetime.start.p0i8(i64 264, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 264)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup37, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %interface = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %3 = load i32, i32* %interface, align 4, !tbaa !222
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %2, i32 %3)
  %tobool2 = icmp ne %struct.usb_interface* %call1, null
  br i1 %tobool2, label %if.end4, label %cleanup37

if.end4:                                          ; preds = %if.end
  %dev5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev5, i32 0, i32 7
  %4 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !172
  %tobool6 = icmp ne %struct.device_driver* %4, null
  br i1 %tobool6, label %if.then7, label %if.end34

if.then7:                                         ; preds = %if.end4
  %dev9 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver10 = getelementptr inbounds %struct.device, %struct.device* %dev9, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver10, align 8, !tbaa !172
  %6 = bitcast %struct.device_driver* %5 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 -104
  %7 = bitcast i8* %add.ptr to %struct.usb_driver*
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 15
  %8 = load i8, i8* %privileges_dropped, align 8, !tbaa !169, !range !132
  %tobool11 = trunc i8 %8 to i1
  br i1 %tobool11, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.then7
  %flags = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %9 = load i32, i32* %flags, align 4, !tbaa !224
  %and = and i32 %9, 1
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end13
  %driver15 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver15, i32 0, i32 0
  %dev16 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver17 = getelementptr inbounds %struct.device, %struct.device* %dev16, i32 0, i32 7
  %10 = load %struct.device_driver*, %struct.device_driver** %driver17, align 8, !tbaa !172
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %10, i32 0, i32 0
  %11 = load i8*, i8** %name, align 8, !tbaa !173
  %call18 = call i32 @strncmp(i8* %arraydecay, i8* %11, i64 256)
  %cmp = icmp ne i32 %call18, 0
  br i1 %cmp, label %cleanup, label %if.end20

if.end20:                                         ; preds = %land.lhs.true, %if.end13
  %flags21 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %12 = load i32, i32* %flags21, align 4, !tbaa !224
  %and22 = and i32 %12, 2
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %land.lhs.true24, label %if.end33

land.lhs.true24:                                  ; preds = %if.end20
  %driver25 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay26 = getelementptr inbounds [256 x i8], [256 x i8]* %driver25, i32 0, i32 0
  %dev27 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver28 = getelementptr inbounds %struct.device, %struct.device* %dev27, i32 0, i32 7
  %13 = load %struct.device_driver*, %struct.device_driver** %driver28, align 8, !tbaa !172
  %name29 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %13, i32 0, i32 0
  %14 = load i8*, i8** %name29, align 8, !tbaa !173
  %call30 = call i32 @strncmp(i8* %arraydecay26, i8* %14, i64 256)
  %cmp31 = icmp eq i32 %call30, 0
  br i1 %cmp31, label %cleanup, label %if.end33

if.end33:                                         ; preds = %land.lhs.true24, %if.end20
  call void @usb_driver_release_interface(%struct.usb_driver* %7, %struct.usb_interface* %call1)
  br label %cleanup

cleanup:                                          ; preds = %land.lhs.true24, %land.lhs.true, %if.then7, %if.end33
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end33 ], [ 1, %if.then7 ], [ 1, %land.lhs.true ], [ 1, %land.lhs.true24 ]
  %retval.0 = phi i32 [ undef, %if.end33 ], [ -13, %if.then7 ], [ -16, %land.lhs.true ], [ -16, %land.lhs.true24 ]
  %cond = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %cond, label %if.end34, label %cleanup37

if.end34:                                         ; preds = %cleanup, %if.end4
  %interface35 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %15 = load i32, i32* %interface35, align 4, !tbaa !222
  %call36 = call i32 @claimintf(%struct.usb_dev_state* %ps, i32 %15)
  br label %cleanup37

cleanup37:                                        ; preds = %if.end, %entry, %cleanup, %if.end34
  %retval.1 = phi i32 [ %retval.0, %cleanup ], [ %call36, %if.end34 ], [ -14, %entry ], [ -22, %if.end ]
  %16 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  call void @llvm.lifetime.end.p0i8(i64 264, i8* %16) #7
  ret i32 %retval.1
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_alloc_streams(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %num_streams = alloca i32, align 4
  %num_eps = alloca i32, align 4
  %eps = alloca %struct.usb_host_endpoint**, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %0 = bitcast i32* %num_streams to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = bitcast i32* %num_eps to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  %2 = bitcast %struct.usb_host_endpoint*** %eps to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = bitcast %struct.usb_interface** %intf to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i8* %arg to %struct.usbdevfs_streams*
  %call = call i32 @parse_usbdevfs_streams(%struct.usb_dev_state* %ps, %struct.usbdevfs_streams* %4, i32* %num_streams, i32* %num_eps, %struct.usb_host_endpoint*** %eps, %struct.usb_interface** %intf)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %5 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !56
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %5, i32 0, i32 0
  %6 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !2
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %6, i64 0
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %7 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !31
  %conv = zext i8 %7 to i32
  call void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %conv)
  %8 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !56
  %9 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8, !tbaa !56
  %10 = load i32, i32* %num_eps, align 4, !tbaa !62
  %11 = load i32, i32* %num_streams, align 4, !tbaa !62
  %call1 = call i32 @usb_alloc_streams(%struct.usb_interface* %8, %struct.usb_host_endpoint** %9, i32 %10, i32 %11, i32 20971712)
  %12 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8, !tbaa !56
  %13 = bitcast %struct.usb_host_endpoint** %12 to i8*
  call void @kfree(i8* %13)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call1, %if.end ], [ %call, %entry ]
  %14 = bitcast %struct.usb_interface** %intf to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #7
  %15 = bitcast %struct.usb_host_endpoint*** %eps to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #7
  %16 = bitcast i32* %num_eps to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %16) #7
  %17 = bitcast i32* %num_streams to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %17) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_free_streams(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %num_eps = alloca i32, align 4
  %eps = alloca %struct.usb_host_endpoint**, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %0 = bitcast i32* %num_eps to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = bitcast %struct.usb_host_endpoint*** %eps to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast %struct.usb_interface** %intf to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i8* %arg to %struct.usbdevfs_streams*
  %call = call i32 @parse_usbdevfs_streams(%struct.usb_dev_state* %ps, %struct.usbdevfs_streams* %3, i32* null, i32* %num_eps, %struct.usb_host_endpoint*** %eps, %struct.usb_interface** %intf)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %4 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !56
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 0
  %5 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !2
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %5, i64 0
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %6 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !31
  %conv = zext i8 %6 to i32
  call void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %conv)
  %7 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !56
  %8 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8, !tbaa !56
  %9 = load i32, i32* %num_eps, align 4, !tbaa !62
  %call1 = call i32 @usb_free_streams(%struct.usb_interface* %7, %struct.usb_host_endpoint** %8, i32 %9, i32 20971712)
  %10 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8, !tbaa !56
  %11 = bitcast %struct.usb_host_endpoint** %10 to i8*
  call void @kfree(i8* %11)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call1, %if.end ], [ %call, %entry ]
  %12 = bitcast %struct.usb_interface** %intf to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #7
  %13 = bitcast %struct.usb_host_endpoint*** %eps to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #7
  %14 = bitcast i32* %num_eps to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_drop_privileges(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %data = alloca i32, align 4
  %0 = bitcast i32* %data to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = bitcast i32* %data to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 4)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %data, align 4, !tbaa !62
  %conv = zext i32 %2 to i64
  %interface_allowed_mask = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 16
  %3 = load i64, i64* %interface_allowed_mask, align 8, !tbaa !92
  %and = and i64 %3, %conv
  store i64 %and, i64* %interface_allowed_mask, align 8, !tbaa !92
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 15
  store i8 1, i8* %privileges_dropped, align 8, !tbaa !169
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ -14, %entry ]
  %4 = bitcast i32* %data to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.async* @reap_as(%struct.usb_dev_state* %ps) #0 {
entry:
  %wait = alloca %struct.__wait_queue, align 8
  %__ret = alloca i64, align 8
  %0 = bitcast %struct.__wait_queue* %wait to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %0) #7
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !225
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 1
  %call = call %struct.task_struct* @get_current()
  %1 = bitcast %struct.task_struct* %call to i8*
  store i8* %1, i8** %private, align 8, !tbaa !227
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !228
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  store %struct.list_head* null, %struct.list_head** %next, align 8, !tbaa !135
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  store %struct.list_head* null, %struct.list_head** %prev, align 8, !tbaa !140
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !42
  %wait2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 7
  call void @add_wait_queue(%struct.__wait_queue_head* %wait2, %struct.__wait_queue* %wait)
  br label %for.cond

for.cond:                                         ; preds = %if.end11, %entry
  %call3 = call %struct.task_struct* @get_current()
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call3, i32 0, i32 1
  store volatile i64 1, i64* %state, align 8, !tbaa !229
  %call4 = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %ps)
  %tobool = icmp ne %struct.async* %call4, null
  br i1 %tobool, label %for.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %call5 = call i32 @connected(%struct.usb_dev_state* %ps)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end, label %for.end

if.end:                                           ; preds = %lor.lhs.false
  %call7 = call %struct.task_struct* @get_current()
  %call8 = call i32 @signal_pending(%struct.task_struct* %call7)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %for.end, label %if.end11

if.end11:                                         ; preds = %if.end
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev12)
  call void @schedule()
  %dev13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock(%struct.device* %dev13)
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond, %lor.lhs.false
  %wait14 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 7
  call void @remove_wait_queue(%struct.__wait_queue_head* %wait14, %struct.__wait_queue* %wait)
  %3 = bitcast i64* %__ret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  store volatile i64 0, i64* %__ret, align 8, !tbaa !150
  %4 = load volatile i64, i64* %__ret, align 8, !tbaa !150
  %call16 = call %struct.task_struct* @get_current()
  %state17 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call16, i32 0, i32 1
  %5 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state17, i64 %4, i64* %state17) #7, !srcloc !230
  store volatile i64 %5, i64* %__ret, align 8, !tbaa !150
  %6 = load volatile i64, i64* %__ret, align 8, !tbaa !150
  %7 = bitcast i64* %__ret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %8 = bitcast %struct.__wait_queue* %wait to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %8) #7
  ret %struct.async* %call4
}

; Function Attrs: nounwind uwtable
define internal i32 @processcompl(%struct.async* %as, i8** %arg) #0 {
entry:
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %0 = load %struct.urb*, %struct.urb** %urb1, align 8, !tbaa !141
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %1 = load i8*, i8** %userurb2, align 8, !tbaa !152
  %2 = bitcast i8* %1 to %struct.usbdevfs_urb*
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %3 = load i8*, i8** %userurb3, align 8, !tbaa !152
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %4 = load i8*, i8** %userbuffer, align 8, !tbaa !231
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4, !tbaa !232
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %6 = load i8*, i8** %userbuffer5, align 8, !tbaa !231
  %call = call i32 @copy_urb_data_to_user(i8* %6, %struct.urb* %0)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.then, %land.lhs.true, %entry
  call void @might_fault()
  %status = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 11
  %7 = load i32, i32* %status, align 4, !tbaa !234
  %status9 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 2
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %7, i32* %status9) #7, !srcloc !235
  %conv = sext i32 %8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  call void @might_fault()
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %9 = load i32, i32* %actual_length15, align 4, !tbaa !232
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 6
  %10 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %9, i32* %actual_length16) #7, !srcloc !236
  %conv18 = sext i32 %10 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.end12
  call void @might_fault()
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 26
  %11 = load i32, i32* %error_count, align 4, !tbaa !237
  %error_count25 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 9
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %11, i32* %error_count25) #7, !srcloc !238
  %conv27 = sext i32 %12 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.end22
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 9
  %13 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !239
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %13, i32 0, i32 0
  %call32 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.end65

if.then34:                                        ; preds = %if.end31
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then34
  %i.0 = phi i32 [ 0, %if.then34 ], [ %inc, %for.inc ]
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 24
  %14 = load i32, i32* %number_of_packets, align 4, !tbaa !240
  %cmp = icmp ult i32 %i.0, %14
  br i1 %cmp, label %for.body, label %if.end65

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length38 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx, i32 0, i32 2
  %15 = load i32, i32* %actual_length38, align 8, !tbaa !241
  %iso_frame_desc39 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %idxprom40 = zext i32 %i.0 to i64
  %arrayidx41 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc39, i64 0, i64 %idxprom40
  %actual_length42 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx41, i32 0, i32 1
  %16 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %15, i32* %actual_length42) #7, !srcloc !243
  %conv44 = sext i32 %16 to i64
  %expval45 = call i64 @llvm.expect.i64(i64 %conv44, i64 0)
  %tobool46 = icmp ne i64 %expval45, 0
  br i1 %tobool46, label %cleanup, label %if.end48

if.end48:                                         ; preds = %for.body
  call void @might_fault()
  %iso_frame_desc51 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom52 = zext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc51, i64 0, i64 %idxprom52
  %status54 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx53, i32 0, i32 3
  %17 = load i32, i32* %status54, align 4, !tbaa !244
  %iso_frame_desc55 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %idxprom56 = zext i32 %i.0 to i64
  %arrayidx57 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc55, i64 0, i64 %idxprom56
  %status58 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx57, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %17, i32* %status58) #7, !srcloc !245
  %conv60 = sext i32 %18 to i64
  %expval61 = call i64 @llvm.expect.i64(i64 %conv60, i64 0)
  %tobool62 = icmp ne i64 %expval61, 0
  br i1 %tobool62, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end48
  %inc = add i32 %i.0, 1
  br label %for.cond

if.end65:                                         ; preds = %for.cond, %if.end31
  call void @might_fault()
  %19 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %3, i8** %arg) #7, !srcloc !246
  %20 = ptrtoint i8* %19 to i64
  %21 = trunc i64 %20 to i32
  %conv69 = sext i32 %21 to i64
  %expval70 = call i64 @llvm.expect.i64(i64 %conv69, i64 0)
  %tobool71 = icmp ne i64 %expval70, 0
  %. = select i1 %tobool71, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.then, %if.end8, %if.end12, %if.end22, %for.body, %if.end48, %if.end65
  %retval.0 = phi i32 [ %., %if.end65 ], [ -14, %if.end48 ], [ -14, %for.body ], [ -14, %if.end22 ], [ -14, %if.end12 ], [ -14, %if.end8 ], [ -14, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @free_async(%struct.async* %as) #0 {
entry:
  %pid = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 2
  %0 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !247
  call void @put_pid(%struct.pid* %0)
  %cred = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 3
  %1 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !248
  %tobool = icmp ne %struct.cred* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %cred1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 3
  %2 = load %struct.cred*, %struct.cred** %cred1, align 8, !tbaa !248
  call void @put_cred(%struct.cred* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %urb = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %3 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !141
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 18
  %4 = load i32, i32* %num_sgs, align 4, !tbaa !249
  %cmp = icmp slt i32 %i.0, %4
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %5 = load %struct.urb*, %struct.urb** %urb2, align 8, !tbaa !141
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %5, i32 0, i32 16
  %6 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !250
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %6, i64 %idxprom
  %call = call %struct.page* @sg_page(%struct.scatterlist* %arrayidx)
  %tobool3 = icmp ne %struct.page* %call, null
  br i1 %tobool3, label %if.then4, label %for.inc

if.then4:                                         ; preds = %for.body
  %urb5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %7 = load %struct.urb*, %struct.urb** %urb5, align 8, !tbaa !141
  %sg6 = getelementptr inbounds %struct.urb, %struct.urb* %7, i32 0, i32 16
  %8 = load %struct.scatterlist*, %struct.scatterlist** %sg6, align 8, !tbaa !250
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %8, i64 %idxprom7
  %call9 = call i8* @sg_virt(%struct.scatterlist* %arrayidx8)
  call void @kfree(i8* %call9)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then4
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = bitcast %struct.scatterlist* %6 to i8*
  call void @kfree(i8* %9)
  %usbm = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 9
  %10 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8, !tbaa !251
  %cmp13 = icmp eq %struct.usb_memory* %10, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %for.end
  %urb15 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %11 = load %struct.urb*, %struct.urb** %urb15, align 8, !tbaa !141
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %11, i32 0, i32 14
  %12 = load i8*, i8** %transfer_buffer, align 8, !tbaa !252
  call void @kfree(i8* %12)
  br label %if.end18

if.else:                                          ; preds = %for.end
  %usbm16 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 9
  %13 = load %struct.usb_memory*, %struct.usb_memory** %usbm16, align 8, !tbaa !251
  %usbm17 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 9
  %14 = load %struct.usb_memory*, %struct.usb_memory** %usbm17, align 8, !tbaa !251
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %14, i32 0, i32 2
  call void @dec_usb_memory_use_count(%struct.usb_memory* %13, i32* %urb_use_count)
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then14
  %urb19 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %15 = load %struct.urb*, %struct.urb** %urb19, align 8, !tbaa !141
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %15, i32 0, i32 21
  %16 = load i8*, i8** %setup_packet, align 8, !tbaa !253
  call void @kfree(i8* %16)
  %urb20 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %17 = load %struct.urb*, %struct.urb** %urb20, align 8, !tbaa !141
  call void @usb_free_urb(%struct.urb* %17)
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 10
  %18 = load i32, i32* %mem_usage, align 8, !tbaa !254
  %conv = zext i32 %18 to i64
  call void @usbfs_decrease_memory_usage(i64 %conv)
  %19 = bitcast %struct.async* %as to i8*
  call void @kfree(i8* %19)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #3 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #5 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !255
  ret %struct.task_struct* %0
}

declare i32 @default_wake_function(%struct.__wait_queue*, i32, i32, i8*) #1

declare void @add_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: nounwind uwtable
define internal %struct.async* @async_getcompleted(%struct.usb_dev_state* %ps) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %async_completed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 5
  %call5 = call i32 @list_empty(%struct.list_head* %async_completed)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %async_completed6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 5
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_completed6, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !256
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %as.0 = phi %struct.async* [ null, %entry ], [ %6, %if.then ]
  %lock8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock8, i64 %call2)
  ret %struct.async* %as.0
}

declare void @schedule() #1

declare void @remove_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: nounwind uwtable
define internal i32 @copy_urb_data_to_user(i8* %userbuffer, %struct.urb* %urb) #0 {
entry:
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 24
  %0 = load i32, i32* %number_of_packets, align 4, !tbaa !240
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %1 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !257
  br label %if.end

if.else:                                          ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %2 = load i32, i32* %actual_length, align 4, !tbaa !232
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %len.0 = phi i32 [ %1, %if.then ], [ %2, %if.else ]
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %3 = load i32, i32* %num_sgs, align 4, !tbaa !249
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %4 = load i8*, i8** %transfer_buffer, align 8, !tbaa !252
  %conv = zext i32 %len.0 to i64
  %call = call i64 @copy_to_user(i8* %userbuffer, i8* %4, i64 %conv)
  %tobool = icmp ne i64 %call, 0
  %. = select i1 %tobool, i32 -14, i32 0
  br label %cleanup

if.end5:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %if.end17, %if.end5
  %len.1 = phi i32 [ %len.0, %if.end5 ], [ %sub, %if.end17 ]
  %i.0 = phi i32 [ 0, %if.end5 ], [ %inc, %if.end17 ]
  %userbuffer.addr.0 = phi i8* [ %userbuffer, %if.end5 ], [ %add.ptr, %if.end17 ]
  %num_sgs6 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %5 = load i32, i32* %num_sgs6, align 4, !tbaa !249
  %cmp7 = icmp ult i32 %i.0, %5
  %tobool9 = icmp ne i32 %len.1, 0
  %tobool9. = select i1 %cmp7, i1 %tobool9, i1 false
  br i1 %tobool9., label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %cmp10 = icmp ugt i32 %len.1, 16384
  %.len.1 = select i1 %cmp10, i32 16384, i32 %len.1
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %6 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !250
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %6, i64 %idxprom
  %call12 = call i8* @sg_virt(%struct.scatterlist* %arrayidx)
  %conv13 = zext i32 %.len.1 to i64
  %call14 = call i64 @copy_to_user(i8* %userbuffer.addr.0, i8* %call12, i64 %conv13)
  %tobool15 = icmp ne i64 %call14, 0
  br i1 %tobool15, label %cleanup, label %if.end17

if.end17:                                         ; preds = %for.body
  %idx.ext = zext i32 %.len.1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %userbuffer.addr.0, i64 %idx.ext
  %sub = sub i32 %len.1, %.len.1
  %inc = add i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %for.body, %if.then2
  %retval.0 = phi i32 [ %., %if.then2 ], [ -14, %for.body ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %epd) #3 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !258
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @sg_virt(%struct.scatterlist* %sg) #3 {
entry:
  %call = call %struct.page* @sg_page(%struct.scatterlist* %sg)
  %call1 = call i8* @lowmem_page_address(%struct.page* %call)
  %offset = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %0 = load i32, i32* %offset, align 8, !tbaa !259
  %idx.ext = zext i32 %0 to i64
  %add.ptr = getelementptr i8, i8* %call1, i64 %idx.ext
  ret i8* %add.ptr
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @lowmem_page_address(%struct.page* %page) #5 {
entry:
  %sub.ptr.lhs.cast = ptrtoint %struct.page* %page to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, -24189255811072
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 64
  %shl = shl i64 %sub.ptr.div, 12
  %add = add i64 %shl, -131941395333120
  %0 = inttoptr i64 %add to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @sg_page(%struct.scatterlist* %sg) #3 {
entry:
  %page_link = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %0 = load i64, i64* %page_link, align 8, !tbaa !261
  %and = and i64 %0, -4
  %1 = inttoptr i64 %and to %struct.page*
  ret %struct.page* %1
}

declare void @put_pid(%struct.pid*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @put_cred(%struct.cred* %_cred) #3 {
entry:
  call void @validate_creds(%struct.cred* %_cred)
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %_cred, i32 0, i32 0
  %call = call zeroext i1 @atomic_dec_and_test(%struct.atomic_t* %usage)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__put_cred(%struct.cred* %_cred)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @kfree(i8*) #1

; Function Attrs: nounwind uwtable
define internal void @dec_usb_memory_use_count(%struct.usb_memory* %usbm, i32* %count) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %ps1 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 7
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8, !tbaa !75
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %5 = load i32, i32* %count, align 4, !tbaa !62
  %dec = add nsw i32 %5, -1
  store i32 %dec, i32* %count, align 4, !tbaa !62
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 2
  %6 = load i32, i32* %urb_use_count, align 4, !tbaa !262
  %cmp6 = icmp eq i32 %6, 0
  br i1 %cmp6, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 1
  %7 = load i32, i32* %vma_use_count, align 8, !tbaa !77
  %cmp8 = icmp eq i32 %7, 0
  br i1 %cmp8, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %memlist = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 0
  call void @list_del(%struct.list_head* %memlist)
  %lock10 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock10, i64 %call3)
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %size = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 3
  %9 = load i32, i32* %size, align 8, !tbaa !74
  %conv11 = zext i32 %9 to i64
  %mem = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 4
  %10 = load i8*, i8** %mem, align 8, !tbaa !71
  %dma_handle = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 5
  %11 = load i64, i64* %dma_handle, align 8, !tbaa !73
  call void @usb_free_coherent(%struct.usb_device* %8, i64 %conv11, i8* %10, i64 %11)
  %size12 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %usbm, i32 0, i32 3
  %12 = load i32, i32* %size12, align 8, !tbaa !74
  %conv13 = zext i32 %12 to i64
  %add = add i64 %conv13, 64
  call void @usbfs_decrease_memory_usage(i64 %add)
  %13 = bitcast %struct.usb_memory* %usbm to i8*
  call void @kfree(i8* %13)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %lock14 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock14, i64 %call3)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usbfs_decrease_memory_usage(i64 %amount) #0 {
entry:
  call void @atomic64_sub(i64 %amount, %struct.atomic64_t* @usbfs_memory_usage)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @validate_creds(%struct.cred* %cred) #3 {
entry:
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @atomic_dec_and_test(%struct.atomic_t* %v) #5 {
entry:
  %c = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #7
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0;\0A\09sete $1\0A", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !263
  %0 = load i8, i8* %c, align 1, !tbaa !131, !range !132
  %tobool = trunc i8 %0 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #7
  ret i1 %tobool
}

declare void @__put_cred(%struct.cred*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del(%struct.list_head* %entry1) #3 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8, !tbaa !135
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8, !tbaa !140
  ret void
}

declare void @usb_free_coherent(%struct.usb_device*, i64, i8*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic64_sub(i64 %i, %struct.atomic64_t* %v) #3 {
entry:
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i32 0, i32 0
  %counter1 = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subq $1,$0", "=*m,er,*m,~{dirflag},~{fpsr},~{flags}"(i64* %counter, i64 %i, i64* %counter1) #7, !srcloc !264
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #3 {
entry:
  %call = call %struct.thread_info* @task_thread_info(%struct.task_struct* %tsk)
  %call1 = call i32 @test_ti_thread_flag(%struct.thread_info* %call, i32 %flag)
  ret i32 %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #3 {
entry:
  %conv = sext i32 %flag to i64
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 0
  %call = call zeroext i1 @variable_test_bit(i64 %conv, i64* %flags)
  %conv1 = zext i1 %call to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @task_thread_info(%struct.task_struct* %task) #3 {
entry:
  %thread_info = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i32 0, i32 0
  ret %struct.thread_info* %thread_info
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @variable_test_bit(i64 %nr, i64* %addr) #5 {
entry:
  %oldbit = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %oldbit) #7
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit, i64* %addr, i64 %nr) #7, !srcloc !265
  %0 = load i8, i8* %oldbit, align 1, !tbaa !131, !range !132
  %tobool = trunc i8 %0 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %oldbit) #7
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal i32 @processcompl_compat(%struct.async* %as, i8** %arg) #0 {
entry:
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %0 = load %struct.urb*, %struct.urb** %urb1, align 8, !tbaa !141
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %1 = load i8*, i8** %userurb2, align 8, !tbaa !152
  %2 = bitcast i8* %1 to %struct.usbdevfs_urb32*
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %3 = load i8*, i8** %userurb3, align 8, !tbaa !152
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %4 = load i8*, i8** %userbuffer, align 8, !tbaa !231
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4, !tbaa !232
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %6 = load i8*, i8** %userbuffer5, align 8, !tbaa !231
  %call = call i32 @copy_urb_data_to_user(i8* %6, %struct.urb* %0)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.then, %land.lhs.true, %entry
  call void @might_fault()
  %status = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 11
  %7 = load i32, i32* %status, align 4, !tbaa !234
  %status9 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 2
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %7, i32* %status9) #7, !srcloc !266
  %conv = sext i32 %8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  call void @might_fault()
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %9 = load i32, i32* %actual_length15, align 4, !tbaa !232
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 6
  %10 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %9, i32* %actual_length16) #7, !srcloc !267
  %conv18 = sext i32 %10 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.end12
  call void @might_fault()
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 26
  %11 = load i32, i32* %error_count, align 4, !tbaa !237
  %error_count25 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 9
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %11, i32* %error_count25) #7, !srcloc !268
  %conv27 = sext i32 %12 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 0)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.end22
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 9
  %13 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !239
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %13, i32 0, i32 0
  %call32 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.end65

if.then34:                                        ; preds = %if.end31
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then34
  %i.0 = phi i32 [ 0, %if.then34 ], [ %inc, %for.inc ]
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 24
  %14 = load i32, i32* %number_of_packets, align 4, !tbaa !240
  %cmp = icmp ult i32 %i.0, %14
  br i1 %cmp, label %for.body, label %if.end65

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length38 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx, i32 0, i32 2
  %15 = load i32, i32* %actual_length38, align 8, !tbaa !241
  %iso_frame_desc39 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %idxprom40 = zext i32 %i.0 to i64
  %arrayidx41 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc39, i64 0, i64 %idxprom40
  %actual_length42 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx41, i32 0, i32 1
  %16 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %15, i32* %actual_length42) #7, !srcloc !269
  %conv44 = sext i32 %16 to i64
  %expval45 = call i64 @llvm.expect.i64(i64 %conv44, i64 0)
  %tobool46 = icmp ne i64 %expval45, 0
  br i1 %tobool46, label %cleanup, label %if.end48

if.end48:                                         ; preds = %for.body
  call void @might_fault()
  %iso_frame_desc51 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom52 = zext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc51, i64 0, i64 %idxprom52
  %status54 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx53, i32 0, i32 3
  %17 = load i32, i32* %status54, align 4, !tbaa !244
  %iso_frame_desc55 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %idxprom56 = zext i32 %i.0 to i64
  %arrayidx57 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc55, i64 0, i64 %idxprom56
  %status58 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx57, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %17, i32* %status58) #7, !srcloc !270
  %conv60 = sext i32 %18 to i64
  %expval61 = call i64 @llvm.expect.i64(i64 %conv60, i64 0)
  %tobool62 = icmp ne i64 %expval61, 0
  br i1 %tobool62, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end48
  %inc = add i32 %i.0, 1
  br label %for.cond

if.end65:                                         ; preds = %for.cond, %if.end31
  call void @might_fault()
  %call68 = call i32 @ptr_to_compat(i8* %3)
  %19 = bitcast i8** %arg to i32*
  %20 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %call68, i32* %19) #7, !srcloc !271
  %conv70 = sext i32 %20 to i64
  %expval71 = call i64 @llvm.expect.i64(i64 %conv70, i64 0)
  %tobool72 = icmp ne i64 %expval71, 0
  %. = select i1 %tobool72, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end65, %if.end48, %for.body, %if.end22, %if.end12, %if.end8, %if.then
  %retval.0 = phi i32 [ -14, %if.then ], [ -14, %if.end8 ], [ -14, %if.end12 ], [ -14, %if.end22 ], [ -14, %for.body ], [ -14, %if.end48 ], [ %., %if.end65 ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #5 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %conv1 = trunc i64 %n to i32
  call void @kasan_check_write(i8* %to, i32 %conv1)
  %cmp = icmp slt i32 %conv, 0
  %conv3 = sext i32 %conv to i64
  %cmp4 = icmp uge i64 %conv3, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp4
  %lnot = xor i1 %1, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @check_object_size(i8* %to, i64 %n, i1 zeroext false)
  %conv8 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @copy_user_overflow(i32 %conv, i64 %n)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.else ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind uwtable
define internal i32 @check_ctrlrecip(%struct.usb_dev_state* %ps, i32 %requesttype, i32 %request, i32 %index) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !90
  %cmp = icmp ne i32 %1, 4
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !42
  %state2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %3 = load i32, i32* %state2, align 8, !tbaa !90
  %cmp3 = icmp ne i32 %3, 6
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %dev5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev5, align 8, !tbaa !42
  %state6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 3
  %5 = load i32, i32* %state6, align 8, !tbaa !90
  %cmp7 = icmp ne i32 %5, 7
  br i1 %cmp7, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %entry
  %and = and i32 96, %requesttype
  %cmp8 = icmp eq i32 64, %and
  br i1 %cmp8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end
  %cmp11 = icmp eq i32 %requesttype, 161
  %cmp13 = icmp eq i32 %request, 0
  %or.cond = and i1 %cmp11, %cmp13
  br i1 %or.cond, label %if.then14, label %if.end22

if.then14:                                        ; preds = %if.end10
  %dev15 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev15, align 8, !tbaa !42
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 15
  %7 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !168
  %shr = lshr i32 %index, 8
  %and16 = and i32 %index, 255
  %call = call %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %7, i32 %shr, i32 %and16)
  %tobool = icmp ne %struct.usb_host_interface* %call, null
  br i1 %tobool, label %land.lhs.true17, label %if.end22

land.lhs.true17:                                  ; preds = %if.then14
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call, i32 0, i32 0
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %8 = load i8, i8* %bInterfaceClass, align 1, !tbaa !272
  %conv = zext i8 %8 to i32
  %cmp18 = icmp eq i32 %conv, 7
  br i1 %cmp18, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.then14, %land.lhs.true17, %if.end10
  %and23 = and i32 %index, 255
  %and24 = and i32 %requesttype, 31
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end22
  %Pivot = icmp slt i32 %and24, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and24, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %and24, 1
  br i1 %SwitchLeaf, label %sw.bb53, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %and25 = and i32 %and23, -129
  %cmp26 = icmp eq i32 %and25, 0
  br i1 %cmp26, label %cleanup, label %if.end29

if.end29:                                         ; preds = %sw.bb
  %dev30 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %dev30, align 8, !tbaa !42
  %call31 = call i32 @findintfep(%struct.usb_device* %9, i32 %and23)
  %cmp32 = icmp slt i32 %call31, 0
  br i1 %cmp32, label %if.then34, label %if.end47

if.then34:                                        ; preds = %if.end29
  %dev35 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev35, align 8, !tbaa !42
  %xor = xor i32 %and23, 128
  %call36 = call i32 @findintfep(%struct.usb_device* %10, i32 %xor)
  %cmp37 = icmp sge i32 %call36, 0
  br i1 %cmp37, label %if.then39, label %if.end47

if.then39:                                        ; preds = %if.then34
  %dev40 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %11 = load %struct.usb_device*, %struct.usb_device** %dev40, align 8, !tbaa !42
  %dev41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %11, i32 0, i32 11
  %call42 = call %struct.task_struct* @get_current()
  %call43 = call i32 @task_pid_nr(%struct.task_struct* %call42)
  %call44 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call44, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %xor45 = xor i32 %and23, 128
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev41, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.37, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.check_ctrlrecip, i32 0, i32 0), i32 %call43, i8* %arraydecay, i32 %and23, i32 %xor45)
  br label %if.end47

if.end47:                                         ; preds = %if.then34, %if.then39, %if.end29
  %ret.0 = phi i32 [ %call31, %if.end29 ], [ %call36, %if.then39 ], [ %call36, %if.then34 ]
  %cmp48 = icmp sge i32 %ret.0, 0
  br i1 %cmp48, label %if.then50, label %cleanup

if.then50:                                        ; preds = %if.end47
  %call51 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %ret.0)
  br label %cleanup

sw.bb53:                                          ; preds = %LeafBlock
  %call54 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %and23)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %cleanup

cleanup:                                          ; preds = %NewDefault, %sw.bb53, %if.then50, %if.end47, %sw.bb, %land.lhs.true17, %if.end, %land.lhs.true4
  %retval.0 = phi i32 [ -113, %land.lhs.true4 ], [ 0, %if.end ], [ 0, %land.lhs.true17 ], [ 0, %sw.bb ], [ 0, %NewDefault ], [ %call54, %sw.bb53 ], [ %call51, %if.then50 ], [ %ret.0, %if.end47 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbfs_increase_memory_usage(i64 %amount) #0 {
entry:
  %0 = load volatile i32, i32* @usbfs_memory_mb, align 4, !tbaa !62
  %conv = zext i32 %0 to i64
  %shl = shl i64 %conv, 20
  call void @atomic64_add(i64 %amount, %struct.atomic64_t* @usbfs_memory_usage)
  %cmp = icmp ugt i64 %shl, 0
  br i1 %cmp, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %entry
  %call = call i64 @atomic64_read(%struct.atomic64_t* @usbfs_memory_usage)
  %cmp2 = icmp ugt i64 %call, %shl
  br i1 %cmp2, label %if.then, label %cleanup

if.then:                                          ; preds = %land.lhs.true
  call void @atomic64_sub(i64 %amount, %struct.atomic64_t* @usbfs_memory_usage)
  br label %cleanup

cleanup:                                          ; preds = %entry, %land.lhs.true, %if.then
  %retval.0 = phi i32 [ -12, %if.then ], [ 0, %land.lhs.true ], [ 0, %entry ]
  ret i32 %retval.0
}

declare i64 @__get_free_pages(i32, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @__chk_range_not_ok(i64 %addr, i64 %size, i64 %limit) #3 {
entry:
  %add = add i64 %addr, %size
  %cmp = icmp ult i64 %add, %size
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp2 = icmp ugt i64 %add, %limit
  %lnot4 = xor i1 %cmp2, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %expval9 = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool10 = icmp ne i64 %expval9, 0
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i1 [ %tobool10, %if.end ], [ true, %entry ]
  ret i1 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__create_pipe(%struct.usb_device* %dev, i32 %endpoint) #3 {
entry:
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 0
  %0 = load i32, i32* %devnum, align 8, !tbaa !178
  %shl = shl i32 %0, 8
  %shl1 = shl i32 %endpoint, 15
  %or = or i32 %shl, %shl1
  ret i32 %or
}

; Function Attrs: nounwind uwtable
define internal void @snoop_urb(%struct.usb_device* %udev, i8* %userurb, i32 %pipe, i32 %length, i32 %timeout_or_status, i32 %when, i8* %data, i32 %data_len) #0 {
entry:
  %__UNIQUE_ID_min1_26 = alloca i32, align 4
  %__UNIQUE_ID_min2_27 = alloca i32, align 4
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %shr = ashr i32 %pipe, 15
  %and = and i32 %shr, 15
  %shr1 = ashr i32 %pipe, 30
  %and2 = and i32 %shr1, 3
  %idxprom = sext i32 %and2 to i64
  %arrayidx = getelementptr inbounds [4 x i8*], [4 x i8*]* @snoop_urb.types, i64 0, i64 %idxprom
  %1 = load i8*, i8** %arrayidx, align 8, !tbaa !56
  %and3 = and i32 %pipe, 128
  %tobool4 = icmp ne i32 %and3, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %idxprom6 = sext i32 %lnot.ext to i64
  %arrayidx7 = getelementptr inbounds [2 x i8*], [2 x i8*]* @snoop_urb.dirs, i64 0, i64 %idxprom6
  %2 = load i8*, i8** %arrayidx7, align 8, !tbaa !56
  %tobool8 = icmp ne i8* %userurb, null
  %cmp = icmp eq i32 %when, 0
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  br i1 %tobool8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.end
  br i1 %cmp, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then9
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.45, i32 0, i32 0), i8* %userurb, i32 %and, i8* %1, i8* %2, i32 %length)
  br label %if.end20

if.else:                                          ; preds = %if.then9
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.46, i32 0, i32 0), i8* %userurb, i32 %and, i8* %1, i8* %2, i32 %length, i32 %timeout_or_status)
  br label %if.end20

if.else13:                                        ; preds = %if.end
  br i1 %cmp, label %if.then15, label %if.else17

if.then15:                                        ; preds = %if.else13
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.47, i32 0, i32 0), i32 %and, i8* %1, i8* %2, i32 %length, i32 %timeout_or_status)
  br label %if.end20

if.else17:                                        ; preds = %if.else13
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.48, i32 0, i32 0), i32 %and, i8* %1, i8* %2, i32 %length, i32 %timeout_or_status)
  br label %if.end20

if.end20:                                         ; preds = %if.then15, %if.else17, %if.then10, %if.else
  %3 = bitcast i32* %__UNIQUE_ID_min1_26 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #7
  store i32 %data_len, i32* %__UNIQUE_ID_min1_26, align 4, !tbaa !62
  %4 = bitcast i32* %__UNIQUE_ID_min2_27 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #7
  %5 = load i32, i32* @usbfs_snoop_max, align 4, !tbaa !62
  store i32 %5, i32* %__UNIQUE_ID_min2_27, align 4, !tbaa !62
  %cmp21 = icmp eq i32* %__UNIQUE_ID_min1_26, %__UNIQUE_ID_min2_27
  %conv = zext i1 %cmp21 to i32
  %6 = load i32, i32* %__UNIQUE_ID_min1_26, align 4, !tbaa !62
  %7 = load i32, i32* %__UNIQUE_ID_min2_27, align 4, !tbaa !62
  %cmp22 = icmp ult i32 %6, %7
  %8 = load i32, i32* %__UNIQUE_ID_min1_26, align 4
  %9 = load i32, i32* %__UNIQUE_ID_min2_27, align 4
  %cond = select i1 %cmp22, i32 %8, i32 %9
  %10 = bitcast i32* %__UNIQUE_ID_min2_27 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %10) #7
  %11 = bitcast i32* %__UNIQUE_ID_min1_26 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %11) #7
  %tobool24 = icmp ne i8* %data, null
  %cmp25 = icmp ugt i32 %cond, 0
  %or.cond = and i1 %tobool24, %cmp25
  br i1 %or.cond, label %if.then27, label %cleanup.cont

if.then27:                                        ; preds = %if.end20
  %conv28 = zext i32 %cond to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.49, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %data, i64 %conv28, i1 zeroext true)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %entry, %if.then27, %if.end20
  ret void
}

declare i32 @usb_control_msg(%struct.usb_device*, i32, i8 zeroext, i8 zeroext, i16 zeroext, i16 zeroext, i8*, i16 zeroext, i32) #1

declare void @dev_printk(i8*, %struct.device*, i8*, ...) #1

declare void @free_pages(i64, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @kasan_check_write(i8* %p, i32 %size) #3 {
entry:
  ret void
}

declare i64 @_copy_from_user(i8*, i8*, i32) #1

declare %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config*, i32, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @findintfep(%struct.usb_device* %dev, i32 %ep) #0 {
entry:
  %and = and i32 %ep, -144
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !168
  %tobool1 = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool1, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc32, %if.end3
  %i.0 = phi i32 [ 0, %if.end3 ], [ %inc33, %for.inc32 ]
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8, !tbaa !168
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %2 = load i8, i8* %bNumInterfaces, align 4, !tbaa !170
  %conv = zext i8 %2 to i32
  %cmp = icmp ult i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %actconfig6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig6, align 8, !tbaa !168
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %3, i32 0, i32 3
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %4 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !56
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc29, %for.body
  %j.0 = phi i32 [ 0, %for.body ], [ %inc30, %for.inc29 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 2
  %5 = load i32, i32* %num_altsetting, align 8, !tbaa !273
  %cmp8 = icmp ult i32 %j.0, %5
  br i1 %cmp8, label %for.body10, label %for.inc32

for.body10:                                       ; preds = %for.cond7
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 0
  %6 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !2
  %idxprom11 = zext i32 %j.0 to i64
  %arrayidx12 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %6, i64 %idxprom11
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc, %for.body10
  %e.0 = phi i32 [ 0, %for.body10 ], [ %inc, %for.inc ]
  %desc14 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc14, i32 0, i32 4
  %7 = load i8, i8* %bNumEndpoints, align 4, !tbaa !274
  %conv15 = zext i8 %7 to i32
  %cmp16 = icmp ult i32 %e.0, %conv15
  br i1 %cmp16, label %for.body18, label %for.inc29

for.body18:                                       ; preds = %for.cond13
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 3
  %8 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !275
  %idxprom19 = zext i32 %e.0 to i64
  %arrayidx20 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %8, i64 %idxprom19
  %desc21 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx20, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc21, i32 0, i32 2
  %9 = load i8, i8* %bEndpointAddress, align 1, !tbaa !276
  %conv22 = zext i8 %9 to i32
  %cmp23 = icmp eq i32 %conv22, %ep
  br i1 %cmp23, label %if.then25, label %for.inc

if.then25:                                        ; preds = %for.body18
  %desc26 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc26, i32 0, i32 2
  %10 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !31
  %conv27 = zext i8 %10 to i32
  br label %cleanup

for.inc:                                          ; preds = %for.body18
  %inc = add i32 %e.0, 1
  br label %for.cond13

for.inc29:                                        ; preds = %for.cond13
  %inc30 = add i32 %j.0, 1
  br label %for.cond7

for.inc32:                                        ; preds = %for.cond7
  %inc33 = add i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.end, %entry, %if.then25
  %retval.0 = phi i32 [ %conv27, %if.then25 ], [ -22, %entry ], [ -3, %if.end ], [ -2, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @task_pid_nr(%struct.task_struct* %tsk) #3 {
entry:
  %pid = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 47
  %0 = load i32, i32* %pid, align 8, !tbaa !277
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @checkintf(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !90
  %cmp = icmp ne i32 %1, 7
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i32 %ifnum to i64
  %cmp1 = icmp uge i64 %conv, 64
  br i1 %cmp1, label %return, label %cond.false

cond.false:                                       ; preds = %if.end
  %conv7 = zext i32 %ifnum to i64
  %ifclaimed8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 12
  %call9 = call zeroext i1 @variable_test_bit(i64 %conv7, i64* %ifclaimed8)
  br i1 %call9, label %return, label %if.end12

if.end12:                                         ; preds = %cond.false
  %dev13 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev13, align 8, !tbaa !42
  %dev14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call15 = call %struct.task_struct* @get_current()
  %call16 = call i32 @task_pid_nr(%struct.task_struct* %call15)
  %call17 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call17, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev14, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.38, i32 0, i32 0), i32 %call16, i8* %arraydecay, i32 %ifnum)
  %call18 = call i32 @claimintf(%struct.usb_dev_state* %ps, i32 %ifnum)
  br label %return

return:                                           ; preds = %cond.false, %if.end, %entry, %if.end12
  %retval.0 = phi i32 [ %call18, %if.end12 ], [ -113, %entry ], [ -22, %if.end ], [ 0, %cond.false ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @constant_test_bit(i64 %nr, i64* %addr) #5 {
entry:
  %and = and i64 %nr, 63
  %shl = shl i64 1, %and
  %shr = ashr i64 %nr, 6
  %arrayidx = getelementptr inbounds i64, i64* %addr, i64 %shr
  %0 = load volatile i64, i64* %arrayidx, align 8, !tbaa !150
  %and1 = and i64 %shl, %0
  %cmp = icmp ne i64 %and1, 0
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal i32 @claimintf(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !42
  %conv = zext i32 %ifnum to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %cleanup, label %cond.false

cond.false:                                       ; preds = %entry
  %conv5 = zext i32 %ifnum to i64
  %ifclaimed6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 12
  %call7 = call zeroext i1 @variable_test_bit(i64 %conv5, i64* %ifclaimed6)
  br i1 %call7, label %cleanup, label %if.end10

if.end10:                                         ; preds = %cond.false
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 15
  %1 = load i8, i8* %privileges_dropped, align 8, !tbaa !169, !range !132
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %cond.false16, label %if.end22

cond.false16:                                     ; preds = %if.end10
  %conv17 = zext i32 %ifnum to i64
  %interface_allowed_mask18 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 16
  %call19 = call zeroext i1 @variable_test_bit(i64 %conv17, i64* %interface_allowed_mask18)
  br i1 %call19, label %if.end22, label %cleanup

if.end22:                                         ; preds = %cond.false16, %if.end10
  %call23 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %0, i32 %ifnum)
  %tobool24 = icmp ne %struct.usb_interface* %call23, null
  br i1 %tobool24, label %if.else, label %if.end27

if.else:                                          ; preds = %if.end22
  %2 = bitcast %struct.usb_dev_state* %ps to i8*
  %call26 = call i32 @usb_driver_claim_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %call23, i8* %2)
  br label %if.end27

if.end27:                                         ; preds = %if.end22, %if.else
  %err.0 = phi i32 [ %call26, %if.else ], [ -2, %if.end22 ]
  %cmp28 = icmp eq i32 %err.0, 0
  br i1 %cmp28, label %if.then30, label %cleanup

if.then30:                                        ; preds = %if.end27
  %conv31 = zext i32 %ifnum to i64
  %ifclaimed32 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 12
  call void @set_bit(i64 %conv31, i64* %ifclaimed32)
  br label %cleanup

cleanup:                                          ; preds = %if.end27, %if.then30, %cond.false16, %cond.false, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ 0, %cond.false ], [ -13, %cond.false16 ], [ %err.0, %if.then30 ], [ %err.0, %if.end27 ]
  ret i32 %retval.0
}

declare %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device*, i32) #1

declare i32 @usb_driver_claim_interface(%struct.usb_driver*, %struct.usb_interface*, i8*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @set_bit(i64 %nr, i64* %addr) #5 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i64 %nr, i64* %addr) #7, !srcloc !278
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @atomic64_add(i64 %i, %struct.atomic64_t* %v) #5 {
entry:
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i32 0, i32 0
  %counter1 = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; addq $1,$0", "=*m,er,*m,~{dirflag},~{fpsr},~{flags}"(i64* %counter, i64 %i, i64* %counter1) #7, !srcloc !279
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @atomic64_read(%struct.atomic64_t* %v) #3 {
entry:
  %__u = alloca %union.anon.63, align 8
  %0 = bitcast %union.anon.63* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %v, i32 0, i32 0
  %1 = bitcast i64* %counter to i8*
  %__c = bitcast %union.anon.63* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.63* %__u to i64*
  %2 = load i64, i64* %__val, align 8, !tbaa !139
  %3 = bitcast %union.anon.63* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  ret i64 %2
}

declare void @print_hex_dump(i8*, i8*, i32, i32, i32, i8*, i64, i1 zeroext) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @usb_maxpacket(%struct.usb_device* %udev, i32 %pipe, i32 %is_out) #3 {
entry:
  %shr = ashr i32 %pipe, 15
  %and = and i32 %shr, 15
  %tobool = icmp ne i32 %is_out, 0
  %and1 = and i32 %pipe, 128
  %tobool2 = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.50, i32 0, i32 0), i32 1854)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %tobool11 = icmp ne i32 %lnot.ext, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  br label %if.end47

if.else:                                          ; preds = %entry
  %lnot25 = xor i1 %lnot3, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.else
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.50, i32 0, i32 0), i32 1857)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.else
  %tobool38 = icmp ne i32 %lnot.ext26, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  br label %if.end47

if.end47:                                         ; preds = %if.end36, %if.end
  %ep_in.sink = phi [16 x %struct.usb_host_endpoint*]* [ %ep_in, %if.end36 ], [ %ep_out, %if.end ]
  %idxprom45 = zext i32 %and to i64
  %arrayidx46 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in.sink, i64 0, i64 %idxprom45
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx46, align 8, !tbaa !56
  %tobool48 = icmp ne %struct.usb_host_endpoint* %0, null
  br i1 %tobool48, label %if.end50, label %cleanup

if.end50:                                         ; preds = %if.end47
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call = call i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %desc)
  %conv51 = trunc i32 %call to i16
  br label %cleanup

cleanup:                                          ; preds = %if.end47, %if.end50
  %retval.0 = phi i16 [ %conv51, %if.end50 ], [ 0, %if.end47 ]
  ret i16 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #5 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare i32 @usb_bulk_msg(%struct.usb_device*, i32, i8*, i32, i32*, i32) #1

declare void @warn_slowpath_null(i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %epd) #3 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !280
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 2047
  ret i32 %and
}

declare noalias i8* @__kmalloc(i64, i32) #1

; Function Attrs: nounwind uwtable
define internal void @check_reset_of_active_ep(%struct.usb_device* %udev, i32 %epnum, i8* %ioctl_name) #0 {
entry:
  %and = and i32 %epnum, 128
  %tobool = icmp ne i32 %and, 0
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  %ep_out.sink = select i1 %tobool, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %arraydecay1 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out.sink, i32 0, i32 0
  %and2 = and i32 %epnum, 15
  %idxprom = zext i32 %and2 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arraydecay1, i64 %idxprom
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8, !tbaa !56
  %tobool3 = icmp ne %struct.usb_host_endpoint* %0, null
  br i1 %tobool3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 4
  %call = call i32 @list_empty(%struct.list_head* %urb_list)
  %tobool4 = icmp ne i32 %call, 0
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  %call5 = call %struct.task_struct* @get_current()
  %call6 = call i32 @task_pid_nr(%struct.task_struct* %call5)
  %call7 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call7, i32 0, i32 77
  %arraydecay8 = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.52, i32 0, i32 0), i32 %call6, i8* %arraydecay8, i8* %ioctl_name, i32 %epnum)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

declare void @usb_reset_endpoint(%struct.usb_device*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_interface_claimed(%struct.usb_interface* %iface) #3 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !172
  %cmp = icmp ne %struct.device_driver* %0, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i32 @usb_reset_device(%struct.usb_device*) #1

declare i32 @usb_clear_halt(%struct.usb_device*, i32) #1

declare i64 @strlcpy(i8*, i8*, i64) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

declare i32 @usb_set_interface(%struct.usb_device*, i32, i32) #1

declare i32 @usb_reset_configuration(%struct.usb_device*) #1

declare i32 @usb_set_configuration(%struct.usb_device*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @proc_do_submiturb(%struct.usb_dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %iso_frame_desc, i8* %arg) #0 {
entry:
  %__UNIQUE_ID_min1_40 = alloca i32, align 4
  %__UNIQUE_ID_min2_41 = alloca i32, align 4
  %flags = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %0 = load i32, i32* %flags, align 8, !tbaa !281
  %and = and i32 %0, -232
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %1 = load i32, i32* %buffer_length, align 8, !tbaa !283
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end3

land.lhs.true:                                    ; preds = %if.end
  %buffer = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %2 = load i8*, i8** %buffer, align 8, !tbaa !284
  %tobool1 = icmp ne i8* %2, null
  br i1 %tobool1, label %if.end3, label %cleanup

if.end3:                                          ; preds = %land.lhs.true, %if.end
  %type = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %3 = load i8, i8* %type, align 8, !tbaa !285
  %conv = zext i8 %3 to i32
  %cmp4 = icmp eq i32 %conv, 2
  br i1 %cmp4, label %land.lhs.true6, label %if.then11

land.lhs.true6:                                   ; preds = %if.end3
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %4 = load i8, i8* %endpoint, align 1, !tbaa !286
  %conv7 = zext i8 %4 to i32
  %and8 = and i32 %conv7, -129
  %cmp9 = icmp eq i32 %and8, 0
  br i1 %cmp9, label %if.end22, label %if.then11

if.then11:                                        ; preds = %land.lhs.true6, %if.end3
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %endpoint12 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %6 = load i8, i8* %endpoint12, align 1, !tbaa !286
  %conv13 = zext i8 %6 to i32
  %call = call i32 @findintfep(%struct.usb_device* %5, i32 %conv13)
  %cmp14 = icmp slt i32 %call, 0
  br i1 %cmp14, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.then11
  %call18 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %call)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.end17, %land.lhs.true6
  %ifnum.0 = phi i32 [ -1, %land.lhs.true6 ], [ %call, %if.end17 ]
  %dev23 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %dev23, align 8, !tbaa !42
  %endpoint24 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %8 = load i8, i8* %endpoint24, align 1, !tbaa !286
  %call25 = call %struct.usb_host_endpoint* @ep_to_host_endpoint(%struct.usb_device* %7, i8 zeroext %8)
  %tobool26 = icmp ne %struct.usb_host_endpoint* %call25, null
  br i1 %tobool26, label %if.end28, label %cleanup

if.end28:                                         ; preds = %if.end22
  %endpoint29 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %9 = load i8, i8* %endpoint29, align 1, !tbaa !286
  %conv30 = zext i8 %9 to i32
  %and31 = and i32 %conv30, 128
  %cmp32 = icmp ne i32 %and31, 0
  %conv33 = zext i1 %cmp32 to i32
  %type34 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %10 = load i8, i8* %type34, align 8, !tbaa !285
  %conv35 = zext i8 %10 to i32
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end28
  %Pivot6 = icmp slt i32 %conv35, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %conv35, 3
  br i1 %Pivot4, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %conv35, 3
  br i1 %SwitchLeaf2, label %sw.bb107, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv35, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb126

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv35, 0
  br i1 %SwitchLeaf, label %sw.bb132, label %NewDefault

sw.bb:                                            ; preds = %NodeBlock3
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 0
  %call36 = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %desc)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.end39, label %cleanup

if.end39:                                         ; preds = %sw.bb
  %buffer_length40 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %11 = load i32, i32* %buffer_length40, align 8, !tbaa !283
  %cmp41 = icmp slt i32 %11, 8
  br i1 %cmp41, label %cleanup, label %if.end44

if.end44:                                         ; preds = %if.end39
  %call45 = call i8* @kmalloc(i64 8, i32 20971712)
  %12 = bitcast i8* %call45 to %struct.usb_ctrlrequest*
  %tobool46 = icmp ne %struct.usb_ctrlrequest* %12, null
  br i1 %tobool46, label %if.end48, label %cleanup

if.end48:                                         ; preds = %if.end44
  %13 = bitcast %struct.usb_ctrlrequest* %12 to i8*
  %buffer49 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %14 = load i8*, i8** %buffer49, align 8, !tbaa !284
  %call50 = call i64 @copy_from_user(i8* %13, i8* %14, i64 8)
  %tobool51 = icmp ne i64 %call50, 0
  br i1 %tobool51, label %error, label %if.end53

if.end53:                                         ; preds = %if.end48
  %buffer_length54 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %15 = load i32, i32* %buffer_length54, align 8, !tbaa !283
  %wLength = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 4
  %call55 = call zeroext i16 @__le16_to_cpup(i16* %wLength)
  %conv56 = zext i16 %call55 to i32
  %add = add nsw i32 %conv56, 8
  %cmp57 = icmp slt i32 %15, %add
  br i1 %cmp57, label %error, label %if.end60

if.end60:                                         ; preds = %if.end53
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 0
  %16 = load i8, i8* %bRequestType, align 1, !tbaa !287
  %conv61 = zext i8 %16 to i32
  %bRequest = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 1
  %17 = load i8, i8* %bRequest, align 1, !tbaa !289
  %conv62 = zext i8 %17 to i32
  %wIndex = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 3
  %call63 = call zeroext i16 @__le16_to_cpup(i16* %wIndex)
  %conv64 = zext i16 %call63 to i32
  %call65 = call i32 @check_ctrlrecip(%struct.usb_dev_state* %ps, i32 %conv61, i32 %conv62, i32 %conv64)
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %error, label %if.end68

if.end68:                                         ; preds = %if.end60
  %wLength69 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 4
  %call70 = call zeroext i16 @__le16_to_cpup(i16* %wLength69)
  %conv71 = zext i16 %call70 to i32
  %buffer_length72 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  store i32 %conv71, i32* %buffer_length72, align 8, !tbaa !283
  %buffer73 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %18 = load i8*, i8** %buffer73, align 8, !tbaa !284
  %add.ptr = getelementptr i8, i8* %18, i64 8
  store i8* %add.ptr, i8** %buffer73, align 8, !tbaa !284
  %bRequestType74 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 0
  %19 = load i8, i8* %bRequestType74, align 1, !tbaa !287
  %conv75 = zext i8 %19 to i32
  %and76 = and i32 %conv75, 128
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %land.lhs.true78, label %if.else

land.lhs.true78:                                  ; preds = %if.end68
  %buffer_length79 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %20 = load i32, i32* %buffer_length79, align 8, !tbaa !283
  %tobool80 = icmp ne i32 %20, 0
  br i1 %tobool80, label %if.then81, label %if.else

if.then81:                                        ; preds = %land.lhs.true78
  %endpoint82 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %21 = load i8, i8* %endpoint82, align 1, !tbaa !286
  %conv83 = zext i8 %21 to i32
  %or = or i32 %conv83, 128
  br label %if.end89

if.else:                                          ; preds = %land.lhs.true78, %if.end68
  %endpoint85 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %22 = load i8, i8* %endpoint85, align 1, !tbaa !286
  %conv86 = zext i8 %22 to i32
  %and87 = and i32 %conv86, -129
  br label %if.end89

if.end89:                                         ; preds = %if.else, %if.then81
  %and87.sink = phi i32 [ %and87, %if.else ], [ %or, %if.then81 ]
  %endpoint85.sink = phi i8* [ %endpoint85, %if.else ], [ %endpoint82, %if.then81 ]
  %is_in.0 = phi i32 [ 1, %if.then81 ], [ 0, %if.else ]
  %conv88 = trunc i32 %and87.sink to i8
  store i8 %conv88, i8* %endpoint85.sink, align 1, !tbaa !286
  %23 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool90 = trunc i8 %23 to i1
  br i1 %tobool90, label %if.then91, label %sw.epilog171

if.then91:                                        ; preds = %if.end89
  %dev92 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %24 = load %struct.usb_device*, %struct.usb_device** %dev92, align 8, !tbaa !42
  %dev93 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %24, i32 0, i32 11
  %bRequestType94 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 0
  %25 = load i8, i8* %bRequestType94, align 1, !tbaa !287
  %conv95 = zext i8 %25 to i32
  %bRequest96 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 1
  %26 = load i8, i8* %bRequest96, align 1, !tbaa !289
  %conv97 = zext i8 %26 to i32
  %wValue = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 2
  %call98 = call zeroext i16 @__le16_to_cpup(i16* %wValue)
  %conv99 = zext i16 %call98 to i32
  %wIndex100 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 3
  %call101 = call zeroext i16 @__le16_to_cpup(i16* %wIndex100)
  %conv102 = zext i16 %call101 to i32
  %wLength103 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %12, i32 0, i32 4
  %call104 = call zeroext i16 @__le16_to_cpup(i16* %wLength103)
  %conv105 = zext i16 %call104 to i32
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev93, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @.str.34, i32 0, i32 0), i32 %conv95, i32 %conv97, i32 %conv99, i32 %conv102, i32 %conv105)
  br label %sw.epilog171

sw.bb107:                                         ; preds = %LeafBlock1
  %desc108 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 0
  %call109 = call i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %desc108)
  br label %NodeBlock12

NodeBlock12:                                      ; preds = %sw.bb107
  %Pivot13 = icmp slt i32 %call109, 3
  br i1 %Pivot13, label %LeafBlock8, label %LeafBlock10

LeafBlock10:                                      ; preds = %NodeBlock12
  %SwitchLeaf11 = icmp eq i32 %call109, 3
  br i1 %SwitchLeaf11, label %sw.bb111, label %NewDefault7

LeafBlock8:                                       ; preds = %NodeBlock12
  %SwitchLeaf9 = icmp ule i32 %call109, 1
  br i1 %SwitchLeaf9, label %cleanup, label %NewDefault7

sw.bb111:                                         ; preds = %LeafBlock10
  %type112 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  store i8 1, i8* %type112, align 8, !tbaa !285
  br label %sw.epilog171

NewDefault7:                                      ; preds = %LeafBlock10, %LeafBlock8
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault7
  %buffer_length113 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %27 = load i32, i32* %buffer_length113, align 8, !tbaa !283
  %add114 = add nsw i32 %27, 16384
  %sub = sub nsw i32 %add114, 1
  %div = sdiv i32 %sub, 16384
  %cmp115 = icmp eq i32 %div, 1
  br i1 %cmp115, label %if.then120, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %dev117 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %28 = load %struct.usb_device*, %struct.usb_device** %dev117, align 8, !tbaa !42
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %28, i32 0, i32 9
  %29 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !217
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %29, i32 0, i32 7
  %30 = load i32, i32* %sg_tablesize, align 4, !tbaa !218
  %cmp118 = icmp ugt i32 %div, %30
  br i1 %cmp118, label %if.then120, label %if.end121

if.then120:                                       ; preds = %lor.lhs.false, %sw.epilog
  br label %if.end121

if.end121:                                        ; preds = %if.then120, %lor.lhs.false
  %num_sgs.0 = phi i32 [ 0, %if.then120 ], [ %div, %lor.lhs.false ]
  %streams = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 10
  %31 = load i32, i32* %streams, align 8, !tbaa !290
  %tobool122 = icmp ne i32 %31, 0
  br i1 %tobool122, label %if.then123, label %sw.epilog171

if.then123:                                       ; preds = %if.end121
  %32 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %stream_id124 = bitcast %union.anon.62* %32 to i32*
  %33 = load i32, i32* %stream_id124, align 4, !tbaa !139
  br label %sw.epilog171

sw.bb126:                                         ; preds = %NodeBlock
  %desc127 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 0
  %call128 = call i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %desc127)
  %tobool129 = icmp ne i32 %call128, 0
  br i1 %tobool129, label %sw.epilog171, label %cleanup

sw.bb132:                                         ; preds = %LeafBlock
  %34 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %number_of_packets133 = bitcast %union.anon.62* %34 to i32*
  %35 = load i32, i32* %number_of_packets133, align 4, !tbaa !139
  %cmp134 = icmp slt i32 %35, 1
  br i1 %cmp134, label %cleanup, label %lor.lhs.false136

lor.lhs.false136:                                 ; preds = %sw.bb132
  %36 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %number_of_packets137 = bitcast %union.anon.62* %36 to i32*
  %37 = load i32, i32* %number_of_packets137, align 4, !tbaa !139
  %cmp138 = icmp sgt i32 %37, 128
  br i1 %cmp138, label %cleanup, label %if.end141

if.end141:                                        ; preds = %lor.lhs.false136
  %desc142 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 0
  %call143 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc142)
  %tobool144 = icmp ne i32 %call143, 0
  br i1 %tobool144, label %if.end146, label %cleanup

if.end146:                                        ; preds = %if.end141
  %38 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %number_of_packets147 = bitcast %union.anon.62* %38 to i32*
  %39 = load i32, i32* %number_of_packets147, align 4, !tbaa !139
  %conv148 = sext i32 %39 to i64
  %mul = mul i64 12, %conv148
  %conv149 = trunc i64 %mul to i32
  %40 = bitcast %struct.usbdevfs_iso_packet_desc* %iso_frame_desc to i8*
  %conv150 = zext i32 %conv149 to i64
  %call151 = call i8* @memdup_user(i8* %40, i64 %conv150)
  %41 = bitcast i8* %call151 to %struct.usbdevfs_iso_packet_desc*
  %42 = bitcast %struct.usbdevfs_iso_packet_desc* %41 to i8*
  %call152 = call zeroext i1 @IS_ERR(i8* %42)
  br i1 %call152, label %if.then153, label %if.end156

if.then153:                                       ; preds = %if.end146
  %43 = bitcast %struct.usbdevfs_iso_packet_desc* %41 to i8*
  %call154 = call i64 @PTR_ERR(i8* %43)
  %conv155 = trunc i64 %call154 to i32
  br label %error

if.end156:                                        ; preds = %if.end146
  br label %for.cond

for.cond:                                         ; preds = %if.end162, %if.end156
  %totlen.0 = phi i32 [ 0, %if.end156 ], [ %add166, %if.end162 ]
  %u.0 = phi i32 [ 0, %if.end156 ], [ %inc, %if.end162 ]
  %cmp157 = icmp ult i32 %u.0, %39
  %idxprom = zext i32 %u.0 to i64
  br i1 %cmp157, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %41, i64 %idxprom
  %length = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx, i32 0, i32 0
  %44 = load i32, i32* %length, align 4, !tbaa !291
  %cmp159 = icmp ugt i32 %44, 49152
  br i1 %cmp159, label %error, label %if.end162

if.end162:                                        ; preds = %for.body
  %idxprom163 = zext i32 %u.0 to i64
  %arrayidx164 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %41, i64 %idxprom163
  %length165 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx164, i32 0, i32 0
  %45 = load i32, i32* %length165, align 4, !tbaa !291
  %add166 = add i32 %totlen.0, %45
  %inc = add i32 %u.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %mul168 = mul i64 %idxprom, 16
  %conv169 = trunc i64 %mul168 to i32
  %buffer_length170 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  store i32 %totlen.0, i32* %buffer_length170, align 8, !tbaa !283
  br label %sw.epilog171

sw.epilog171:                                     ; preds = %sw.bb111, %sw.bb126, %if.end121, %if.then123, %if.end89, %if.then91, %for.end
  %is_in.1 = phi i32 [ %conv33, %for.end ], [ %is_in.0, %if.then91 ], [ %is_in.0, %if.end89 ], [ %conv33, %if.then123 ], [ %conv33, %if.end121 ], [ %conv33, %sw.bb126 ], [ %conv33, %sw.bb111 ]
  %u.1 = phi i32 [ %conv169, %for.end ], [ 8, %if.then91 ], [ 8, %if.end89 ], [ 0, %if.then123 ], [ 0, %if.end121 ], [ 0, %sw.bb126 ], [ 0, %sw.bb111 ]
  %dr.0 = phi %struct.usb_ctrlrequest* [ null, %for.end ], [ %12, %if.then91 ], [ %12, %if.end89 ], [ null, %if.then123 ], [ null, %if.end121 ], [ null, %sw.bb126 ], [ null, %sw.bb111 ]
  %num_sgs.1 = phi i32 [ 0, %for.end ], [ 0, %if.then91 ], [ 0, %if.end89 ], [ %num_sgs.0, %if.then123 ], [ %num_sgs.0, %if.end121 ], [ 0, %sw.bb126 ], [ 0, %sw.bb111 ]
  %isopkt.0 = phi %struct.usbdevfs_iso_packet_desc* [ %41, %for.end ], [ null, %if.then91 ], [ null, %if.end89 ], [ null, %if.then123 ], [ null, %if.end121 ], [ null, %sw.bb126 ], [ null, %sw.bb111 ]
  %number_of_packets.0 = phi i32 [ %39, %for.end ], [ 0, %if.then91 ], [ 0, %if.end89 ], [ 0, %if.then123 ], [ 0, %if.end121 ], [ 0, %sw.bb126 ], [ 0, %sw.bb111 ]
  %stream_id.1 = phi i32 [ 0, %for.end ], [ 0, %if.then91 ], [ 0, %if.end89 ], [ %33, %if.then123 ], [ 0, %if.end121 ], [ 0, %sw.bb126 ], [ 0, %sw.bb111 ]
  %buffer_length172 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %46 = load i32, i32* %buffer_length172, align 8, !tbaa !283
  %cmp173 = icmp sgt i32 %46, 0
  br i1 %cmp173, label %land.lhs.true175, label %if.end188

land.lhs.true175:                                 ; preds = %sw.epilog171
  %buffer177 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %47 = load i8*, i8** %buffer177, align 8, !tbaa !284
  %48 = ptrtoint i8* %47 to i64
  %buffer_length178 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %49 = load i32, i32* %buffer_length178, align 8, !tbaa !283
  %conv179 = sext i32 %49 to i64
  %call180 = call %struct.task_struct* @get_current()
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call180, i32 0, i32 151
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %50 = load i64, i64* %seg, align 8, !tbaa !161
  %call181 = call zeroext i1 @__chk_range_not_ok(i64 %48, i64 %conv179, i64 %50)
  %frombool = zext i1 %call181 to i8
  %tobool182 = trunc i8 %frombool to i1
  %lnot = xor i1 %tobool182, true
  %lnot183 = xor i1 %lnot, true
  %lnot184 = xor i1 %lnot183, true
  %lnot.ext = zext i1 %lnot184 to i32
  %conv185 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv185, i64 1)
  %tobool186 = icmp ne i64 %expval, 0
  br i1 %tobool186, label %if.end188, label %error

if.end188:                                        ; preds = %land.lhs.true175, %sw.epilog171
  %call189 = call %struct.async* @alloc_async(i32 %number_of_packets.0)
  %tobool190 = icmp ne %struct.async* %call189, null
  br i1 %tobool190, label %if.end192, label %error

if.end192:                                        ; preds = %if.end188
  %call193 = call %struct.usb_memory* @find_memory_area(%struct.usb_dev_state* %ps, %struct.usbdevfs_urb* %uurb)
  %usbm = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 9
  store %struct.usb_memory* %call193, %struct.usb_memory** %usbm, align 8, !tbaa !251
  %usbm194 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 9
  %51 = load %struct.usb_memory*, %struct.usb_memory** %usbm194, align 8, !tbaa !251
  %52 = bitcast %struct.usb_memory* %51 to i8*
  %call195 = call zeroext i1 @IS_ERR(i8* %52)
  %usbm197 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 9
  %53 = load %struct.usb_memory*, %struct.usb_memory** %usbm197, align 8, !tbaa !251
  br i1 %call195, label %if.then196, label %if.end201

if.then196:                                       ; preds = %if.end192
  %54 = bitcast %struct.usb_memory* %53 to i8*
  %call198 = call i64 @PTR_ERR(i8* %54)
  %conv199 = trunc i64 %call198 to i32
  %usbm200 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 9
  store %struct.usb_memory* null, %struct.usb_memory** %usbm200, align 8, !tbaa !251
  br label %error

if.end201:                                        ; preds = %if.end192
  %tobool203 = icmp ne %struct.usb_memory* %53, null
  %.num_sgs.1 = select i1 %tobool203, i32 0, i32 %num_sgs.1
  %buffer_length206 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %55 = load i32, i32* %buffer_length206, align 8, !tbaa !283
  %conv207 = sext i32 %55 to i64
  %add208 = add i64 288, %conv207
  %conv209 = sext i32 %.num_sgs.1 to i64
  %mul210 = mul i64 %conv209, 32
  %add211 = add i64 %add208, %mul210
  %conv212 = zext i32 %u.1 to i64
  %add213 = add i64 %conv212, %add211
  %conv214 = trunc i64 %add213 to i32
  %conv215 = zext i32 %conv214 to i64
  %call216 = call i32 @usbfs_increase_memory_usage(i64 %conv215)
  %tobool217 = icmp ne i32 %call216, 0
  br i1 %tobool217, label %error, label %if.end219

if.end219:                                        ; preds = %if.end201
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 10
  store i32 %conv214, i32* %mem_usage, align 8, !tbaa !254
  %tobool220 = icmp ne i32 %.num_sgs.1, 0
  br i1 %tobool220, label %if.then221, label %if.else269

if.then221:                                       ; preds = %if.end219
  %conv222 = sext i32 %.num_sgs.1 to i64
  %mul223 = mul i64 %conv222, 32
  %call224 = call i8* @kmalloc(i64 %mul223, i32 20971712)
  %56 = bitcast i8* %call224 to %struct.scatterlist*
  %urb = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %57 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !141
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %57, i32 0, i32 16
  store %struct.scatterlist* %56, %struct.scatterlist** %sg, align 8, !tbaa !250
  %urb225 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %58 = load %struct.urb*, %struct.urb** %urb225, align 8, !tbaa !141
  %sg226 = getelementptr inbounds %struct.urb, %struct.urb* %58, i32 0, i32 16
  %59 = load %struct.scatterlist*, %struct.scatterlist** %sg226, align 8, !tbaa !250
  %tobool227 = icmp ne %struct.scatterlist* %59, null
  br i1 %tobool227, label %if.end229, label %error

if.end229:                                        ; preds = %if.then221
  %urb230 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %60 = load %struct.urb*, %struct.urb** %urb230, align 8, !tbaa !141
  %num_sgs231 = getelementptr inbounds %struct.urb, %struct.urb* %60, i32 0, i32 18
  store i32 %.num_sgs.1, i32* %num_sgs231, align 4, !tbaa !249
  %urb232 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %61 = load %struct.urb*, %struct.urb** %urb232, align 8, !tbaa !141
  %sg233 = getelementptr inbounds %struct.urb, %struct.urb* %61, i32 0, i32 16
  %62 = load %struct.scatterlist*, %struct.scatterlist** %sg233, align 8, !tbaa !250
  %urb234 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %63 = load %struct.urb*, %struct.urb** %urb234, align 8, !tbaa !141
  %num_sgs235 = getelementptr inbounds %struct.urb, %struct.urb* %63, i32 0, i32 18
  %64 = load i32, i32* %num_sgs235, align 4, !tbaa !249
  call void @sg_init_table(%struct.scatterlist* %62, i32 %64)
  %buffer_length236 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %65 = load i32, i32* %buffer_length236, align 8, !tbaa !283
  br label %for.cond237

for.cond237:                                      ; preds = %if.end264, %if.end229
  %i.0 = phi i32 [ 0, %if.end229 ], [ %inc267, %if.end264 ]
  %totlen.1 = phi i32 [ %65, %if.end229 ], [ %sub265, %if.end264 ]
  %urb238 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %66 = load %struct.urb*, %struct.urb** %urb238, align 8, !tbaa !141
  %num_sgs239 = getelementptr inbounds %struct.urb, %struct.urb* %66, i32 0, i32 18
  %67 = load i32, i32* %num_sgs239, align 4, !tbaa !249
  %cmp240 = icmp slt i32 %i.0, %67
  br i1 %cmp240, label %for.body242, label %if.end319

for.body242:                                      ; preds = %for.cond237
  %cmp243 = icmp ugt i32 %totlen.1, 16384
  %.totlen.1 = select i1 %cmp243, i32 16384, i32 %totlen.1
  %conv245 = zext i32 %.totlen.1 to i64
  %call246 = call i8* @kmalloc(i64 %conv245, i32 20971712)
  %tobool247 = icmp ne i8* %call246, null
  br i1 %tobool247, label %if.end249, label %error

if.end249:                                        ; preds = %for.body242
  %urb250 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %68 = load %struct.urb*, %struct.urb** %urb250, align 8, !tbaa !141
  %sg251 = getelementptr inbounds %struct.urb, %struct.urb* %68, i32 0, i32 16
  %69 = load %struct.scatterlist*, %struct.scatterlist** %sg251, align 8, !tbaa !250
  %idxprom252 = sext i32 %i.0 to i64
  %arrayidx253 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %69, i64 %idxprom252
  call void @sg_set_buf(%struct.scatterlist* %arrayidx253, i8* %call246, i32 %.totlen.1)
  %tobool254 = icmp ne i32 %is_in.1, 0
  br i1 %tobool254, label %if.end264, label %if.then255

if.then255:                                       ; preds = %if.end249
  %buffer256 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %70 = load i8*, i8** %buffer256, align 8, !tbaa !284
  %conv257 = zext i32 %.totlen.1 to i64
  %call258 = call i64 @copy_from_user(i8* %call246, i8* %70, i64 %conv257)
  %tobool259 = icmp ne i64 %call258, 0
  br i1 %tobool259, label %error, label %if.end261

if.end261:                                        ; preds = %if.then255
  %buffer262 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %71 = load i8*, i8** %buffer262, align 8, !tbaa !284
  %idx.ext = zext i32 %.totlen.1 to i64
  %add.ptr263 = getelementptr i8, i8* %71, i64 %idx.ext
  store i8* %add.ptr263, i8** %buffer262, align 8, !tbaa !284
  br label %if.end264

if.end264:                                        ; preds = %if.end261, %if.end249
  %sub265 = sub i32 %totlen.1, %.totlen.1
  %inc267 = add nsw i32 %i.0, 1
  br label %for.cond237

if.else269:                                       ; preds = %if.end219
  %buffer_length270 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %72 = load i32, i32* %buffer_length270, align 8, !tbaa !283
  %cmp271 = icmp sgt i32 %72, 0
  br i1 %cmp271, label %if.then273, label %if.end319

if.then273:                                       ; preds = %if.else269
  %usbm274 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 9
  %73 = load %struct.usb_memory*, %struct.usb_memory** %usbm274, align 8, !tbaa !251
  %tobool275 = icmp ne %struct.usb_memory* %73, null
  br i1 %tobool275, label %if.then276, label %if.else283

if.then276:                                       ; preds = %if.then273
  %buffer277 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %74 = load i8*, i8** %buffer277, align 8, !tbaa !284
  %75 = ptrtoint i8* %74 to i64
  %usbm278 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 9
  %76 = load %struct.usb_memory*, %struct.usb_memory** %usbm278, align 8, !tbaa !251
  %mem = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %76, i32 0, i32 4
  %77 = load i8*, i8** %mem, align 8, !tbaa !71
  %usbm279 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 9
  %78 = load %struct.usb_memory*, %struct.usb_memory** %usbm279, align 8, !tbaa !251
  %vm_start = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %78, i32 0, i32 6
  %79 = load i64, i64* %vm_start, align 8, !tbaa !76
  %sub280 = sub i64 %75, %79
  %add.ptr281 = getelementptr i8, i8* %77, i64 %sub280
  %urb282 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %80 = load %struct.urb*, %struct.urb** %urb282, align 8, !tbaa !141
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %80, i32 0, i32 14
  store i8* %add.ptr281, i8** %transfer_buffer, align 8, !tbaa !252
  br label %if.end319

if.else283:                                       ; preds = %if.then273
  %buffer_length284 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %81 = load i32, i32* %buffer_length284, align 8, !tbaa !283
  %conv285 = sext i32 %81 to i64
  %call286 = call i8* @kmalloc(i64 %conv285, i32 20971712)
  %urb287 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %82 = load %struct.urb*, %struct.urb** %urb287, align 8, !tbaa !141
  %transfer_buffer288 = getelementptr inbounds %struct.urb, %struct.urb* %82, i32 0, i32 14
  store i8* %call286, i8** %transfer_buffer288, align 8, !tbaa !252
  %urb289 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %83 = load %struct.urb*, %struct.urb** %urb289, align 8, !tbaa !141
  %transfer_buffer290 = getelementptr inbounds %struct.urb, %struct.urb* %83, i32 0, i32 14
  %84 = load i8*, i8** %transfer_buffer290, align 8, !tbaa !252
  %tobool291 = icmp ne i8* %84, null
  br i1 %tobool291, label %if.end293, label %error

if.end293:                                        ; preds = %if.else283
  %tobool294 = icmp ne i32 %is_in.1, 0
  br i1 %tobool294, label %if.else305, label %if.then295

if.then295:                                       ; preds = %if.end293
  %urb296 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %85 = load %struct.urb*, %struct.urb** %urb296, align 8, !tbaa !141
  %transfer_buffer297 = getelementptr inbounds %struct.urb, %struct.urb* %85, i32 0, i32 14
  %86 = load i8*, i8** %transfer_buffer297, align 8, !tbaa !252
  %buffer298 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %87 = load i8*, i8** %buffer298, align 8, !tbaa !284
  %buffer_length299 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %88 = load i32, i32* %buffer_length299, align 8, !tbaa !283
  %conv300 = sext i32 %88 to i64
  %call301 = call i64 @copy_from_user(i8* %86, i8* %87, i64 %conv300)
  %tobool302 = icmp ne i64 %call301, 0
  br i1 %tobool302, label %error, label %if.end319

if.else305:                                       ; preds = %if.end293
  %type306 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %89 = load i8, i8* %type306, align 8, !tbaa !285
  %conv307 = zext i8 %89 to i32
  %cmp308 = icmp eq i32 %conv307, 0
  br i1 %cmp308, label %if.then310, label %if.end319

if.then310:                                       ; preds = %if.else305
  %urb311 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %90 = load %struct.urb*, %struct.urb** %urb311, align 8, !tbaa !141
  %transfer_buffer312 = getelementptr inbounds %struct.urb, %struct.urb* %90, i32 0, i32 14
  %91 = load i8*, i8** %transfer_buffer312, align 8, !tbaa !252
  %buffer_length313 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %92 = load i32, i32* %buffer_length313, align 8, !tbaa !283
  %conv314 = sext i32 %92 to i64
  call void @llvm.memset.p0i8.i64(i8* %91, i8 0, i64 %conv314, i32 1, i1 false)
  br label %if.end319

if.end319:                                        ; preds = %if.else269, %if.then295, %if.then310, %if.else305, %if.then276, %for.cond237
  %dev320 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %93 = load %struct.usb_device*, %struct.usb_device** %dev320, align 8, !tbaa !42
  %urb321 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %94 = load %struct.urb*, %struct.urb** %urb321, align 8, !tbaa !141
  %dev322 = getelementptr inbounds %struct.urb, %struct.urb* %94, i32 0, i32 8
  store %struct.usb_device* %93, %struct.usb_device** %dev322, align 8, !tbaa !293
  %type323 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %95 = load i8, i8* %type323, align 8, !tbaa !285
  %conv324 = zext i8 %95 to i32
  %shl = shl i32 %conv324, 30
  %dev325 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %96 = load %struct.usb_device*, %struct.usb_device** %dev325, align 8, !tbaa !42
  %endpoint326 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %97 = load i8, i8* %endpoint326, align 1, !tbaa !286
  %conv327 = zext i8 %97 to i32
  %and328 = and i32 %conv327, 15
  %call329 = call i32 @__create_pipe(%struct.usb_device* %96, i32 %and328)
  %or330 = or i32 %shl, %call329
  %endpoint331 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %98 = load i8, i8* %endpoint331, align 1, !tbaa !286
  %conv332 = zext i8 %98 to i32
  %and333 = and i32 %conv332, 128
  %or334 = or i32 %or330, %and333
  %urb335 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %99 = load %struct.urb*, %struct.urb** %urb335, align 8, !tbaa !141
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %99, i32 0, i32 10
  store i32 %or334, i32* %pipe, align 8, !tbaa !294
  %tobool336 = icmp ne i32 %is_in.1, 0
  %100 = zext i1 %tobool336 to i64
  %cond337 = select i1 %tobool336, i32 512, i32 0
  %flags338 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %101 = load i32, i32* %flags338, align 8, !tbaa !281
  %and339 = and i32 %101, 2
  %tobool340 = icmp ne i32 %and339, 0
  %or342 = or i32 %cond337, 2
  %or342.cond337 = select i1 %tobool340, i32 %or342, i32 %cond337
  %flags344 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %102 = load i32, i32* %flags344, align 8, !tbaa !281
  %and345 = and i32 %102, 1
  %tobool346 = icmp ne i32 %and345, 0
  %tobool348 = icmp ne i32 %is_in.1, 0
  %or.cond = and i1 %tobool346, %tobool348
  %or350 = or i32 %or342.cond337, 1
  %u.3 = select i1 %or.cond, i32 %or350, i32 %or342.cond337
  %flags352 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %103 = load i32, i32* %flags352, align 8, !tbaa !281
  %and353 = and i32 %103, 32
  %tobool354 = icmp ne i32 %and353, 0
  %or356 = or i32 %u.3, 32
  %or356.u.3 = select i1 %tobool354, i32 %or356, i32 %u.3
  %flags358 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %104 = load i32, i32* %flags358, align 8, !tbaa !281
  %and359 = and i32 %104, 64
  %tobool360 = icmp ne i32 %and359, 0
  %or362 = or i32 %or356.u.3, 64
  %u.5 = select i1 %tobool360, i32 %or362, i32 %or356.u.3
  %flags364 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %105 = load i32, i32* %flags364, align 8, !tbaa !281
  %and365 = and i32 %105, 128
  %tobool366 = icmp ne i32 %and365, 0
  %or368 = or i32 %u.5, 128
  %or368.u.5 = select i1 %tobool366, i32 %or368, i32 %u.5
  %urb370 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %106 = load %struct.urb*, %struct.urb** %urb370, align 8, !tbaa !141
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %106, i32 0, i32 13
  store i32 %or368.u.5, i32* %transfer_flags, align 4, !tbaa !295
  %buffer_length371 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %107 = load i32, i32* %buffer_length371, align 8, !tbaa !283
  %urb372 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %108 = load %struct.urb*, %struct.urb** %urb372, align 8, !tbaa !141
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %108, i32 0, i32 19
  store i32 %107, i32* %transfer_buffer_length, align 8, !tbaa !257
  %109 = bitcast %struct.usb_ctrlrequest* %dr.0 to i8*
  %urb373 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %110 = load %struct.urb*, %struct.urb** %urb373, align 8, !tbaa !141
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %110, i32 0, i32 21
  store i8* %109, i8** %setup_packet, align 8, !tbaa !253
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 7
  %111 = load i32, i32* %start_frame, align 8, !tbaa !296
  %urb374 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %112 = load %struct.urb*, %struct.urb** %urb374, align 8, !tbaa !141
  %start_frame375 = getelementptr inbounds %struct.urb, %struct.urb* %112, i32 0, i32 23
  store i32 %111, i32* %start_frame375, align 8, !tbaa !297
  %urb376 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %113 = load %struct.urb*, %struct.urb** %urb376, align 8, !tbaa !141
  %number_of_packets377 = getelementptr inbounds %struct.urb, %struct.urb* %113, i32 0, i32 24
  store i32 %number_of_packets.0, i32* %number_of_packets377, align 4, !tbaa !240
  %urb378 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %114 = load %struct.urb*, %struct.urb** %urb378, align 8, !tbaa !141
  %stream_id379 = getelementptr inbounds %struct.urb, %struct.urb* %114, i32 0, i32 11
  store i32 %stream_id.1, i32* %stream_id379, align 4, !tbaa !298
  %desc380 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 0
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc380, i32 0, i32 5
  %115 = load i8, i8* %bInterval, align 2, !tbaa !299
  %tobool381 = icmp ne i8 %115, 0
  br i1 %tobool381, label %if.then382, label %if.end419

if.then382:                                       ; preds = %if.end319
  %type383 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %116 = load i8, i8* %type383, align 8, !tbaa !285
  %conv384 = zext i8 %116 to i32
  %cmp385 = icmp eq i32 %conv384, 0
  br i1 %cmp385, label %if.then396, label %lor.lhs.false387

lor.lhs.false387:                                 ; preds = %if.then382
  %dev388 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %117 = load %struct.usb_device*, %struct.usb_device** %dev388, align 8, !tbaa !42
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %117, i32 0, i32 4
  %118 = load i32, i32* %speed, align 4, !tbaa !181
  %cmp389 = icmp eq i32 %118, 3
  br i1 %cmp389, label %if.then396, label %lor.lhs.false391

lor.lhs.false391:                                 ; preds = %lor.lhs.false387
  %dev392 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %119 = load %struct.usb_device*, %struct.usb_device** %dev392, align 8, !tbaa !42
  %speed393 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %119, i32 0, i32 4
  %120 = load i32, i32* %speed393, align 4, !tbaa !181
  %cmp394 = icmp uge i32 %120, 5
  br i1 %cmp394, label %if.then396, label %if.else412

if.then396:                                       ; preds = %lor.lhs.false391, %lor.lhs.false387, %if.then382
  %121 = bitcast i32* %__UNIQUE_ID_min1_40 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %121) #7
  store i32 15, i32* %__UNIQUE_ID_min1_40, align 4, !tbaa !62
  %122 = bitcast i32* %__UNIQUE_ID_min2_41 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %122) #7
  %desc397 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 0
  %bInterval398 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc397, i32 0, i32 5
  %123 = load i8, i8* %bInterval398, align 2, !tbaa !299
  %conv399 = zext i8 %123 to i32
  %sub400 = sub nsw i32 %conv399, 1
  store i32 %sub400, i32* %__UNIQUE_ID_min2_41, align 4, !tbaa !62
  %cmp401 = icmp eq i32* %__UNIQUE_ID_min1_40, %__UNIQUE_ID_min2_41
  %conv402 = zext i1 %cmp401 to i32
  %124 = load i32, i32* %__UNIQUE_ID_min1_40, align 4, !tbaa !62
  %125 = load i32, i32* %__UNIQUE_ID_min2_41, align 4, !tbaa !62
  %cmp404 = icmp slt i32 %124, %125
  %126 = load i32, i32* %__UNIQUE_ID_min1_40, align 4
  %127 = load i32, i32* %__UNIQUE_ID_min2_41, align 4
  %cond409 = select i1 %cmp404, i32 %126, i32 %127
  %128 = bitcast i32* %__UNIQUE_ID_min2_41 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %128) #7
  %129 = bitcast i32* %__UNIQUE_ID_min1_40 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %129) #7
  %shl410 = shl i32 1, %cond409
  br label %if.end418

if.else412:                                       ; preds = %lor.lhs.false391
  %desc413 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 0
  %bInterval414 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc413, i32 0, i32 5
  %130 = load i8, i8* %bInterval414, align 2, !tbaa !299
  %conv415 = zext i8 %130 to i32
  br label %if.end418

if.end418:                                        ; preds = %if.else412, %if.then396
  %conv415.sink = phi i32 [ %conv415, %if.else412 ], [ %shl410, %if.then396 ]
  %urb416 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %131 = load %struct.urb*, %struct.urb** %urb416, align 8, !tbaa !141
  %interval417 = getelementptr inbounds %struct.urb, %struct.urb* %131, i32 0, i32 25
  store i32 %conv415.sink, i32* %interval417, align 8, !tbaa !300
  br label %if.end419

if.end419:                                        ; preds = %if.end418, %if.end319
  %132 = bitcast %struct.async* %call189 to i8*
  %urb420 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %133 = load %struct.urb*, %struct.urb** %urb420, align 8, !tbaa !141
  %context = getelementptr inbounds %struct.urb, %struct.urb* %133, i32 0, i32 27
  store i8* %132, i8** %context, align 8, !tbaa !301
  %urb421 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %134 = load %struct.urb*, %struct.urb** %urb421, align 8, !tbaa !141
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %134, i32 0, i32 28
  store void (%struct.urb*)* @async_completed, void (%struct.urb*)** %complete, align 8, !tbaa !302
  br label %for.cond422

for.cond422:                                      ; preds = %for.body425, %if.end419
  %totlen.2 = phi i32 [ 0, %if.end419 ], [ %add441, %for.body425 ]
  %u.7 = phi i32 [ 0, %if.end419 ], [ %inc443, %for.body425 ]
  %cmp423 = icmp ult i32 %u.7, %number_of_packets.0
  br i1 %cmp423, label %for.body425, label %for.end444

for.body425:                                      ; preds = %for.cond422
  %urb426 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %135 = load %struct.urb*, %struct.urb** %urb426, align 8, !tbaa !141
  %iso_frame_desc427 = getelementptr inbounds %struct.urb, %struct.urb* %135, i32 0, i32 29
  %idxprom428 = zext i32 %u.7 to i64
  %arrayidx429 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc427, i64 0, i64 %idxprom428
  %offset = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx429, i32 0, i32 0
  store i32 %totlen.2, i32* %offset, align 8, !tbaa !303
  %idxprom430 = zext i32 %u.7 to i64
  %arrayidx431 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %isopkt.0, i64 %idxprom430
  %length432 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx431, i32 0, i32 0
  %136 = load i32, i32* %length432, align 4, !tbaa !291
  %urb433 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %137 = load %struct.urb*, %struct.urb** %urb433, align 8, !tbaa !141
  %iso_frame_desc434 = getelementptr inbounds %struct.urb, %struct.urb* %137, i32 0, i32 29
  %idxprom435 = zext i32 %u.7 to i64
  %arrayidx436 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc434, i64 0, i64 %idxprom435
  %length437 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx436, i32 0, i32 1
  store i32 %136, i32* %length437, align 4, !tbaa !304
  %idxprom438 = zext i32 %u.7 to i64
  %arrayidx439 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %isopkt.0, i64 %idxprom438
  %length440 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx439, i32 0, i32 0
  %138 = load i32, i32* %length440, align 4, !tbaa !291
  %add441 = add i32 %totlen.2, %138
  %inc443 = add i32 %u.7, 1
  br label %for.cond422

for.end444:                                       ; preds = %for.cond422
  %139 = bitcast %struct.usbdevfs_iso_packet_desc* %isopkt.0 to i8*
  call void @kfree(i8* %139)
  %ps445 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 1
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps445, align 8, !tbaa !305
  %userurb = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 7
  store i8* %arg, i8** %userurb, align 8, !tbaa !152
  %usbm446 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 9
  %140 = load %struct.usb_memory*, %struct.usb_memory** %usbm446, align 8, !tbaa !251
  %tobool447 = icmp ne %struct.usb_memory* %140, null
  br i1 %tobool447, label %if.then448, label %if.else460

if.then448:                                       ; preds = %for.end444
  %buffer450 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %141 = load i8*, i8** %buffer450, align 8, !tbaa !284
  %142 = ptrtoint i8* %141 to i64
  %urb451 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %143 = load %struct.urb*, %struct.urb** %urb451, align 8, !tbaa !141
  %transfer_flags452 = getelementptr inbounds %struct.urb, %struct.urb* %143, i32 0, i32 13
  %144 = load i32, i32* %transfer_flags452, align 4, !tbaa !295
  %or453 = or i32 %144, 4
  store i32 %or453, i32* %transfer_flags452, align 4, !tbaa !295
  %usbm454 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 9
  %145 = load %struct.usb_memory*, %struct.usb_memory** %usbm454, align 8, !tbaa !251
  %dma_handle = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %145, i32 0, i32 5
  %146 = load i64, i64* %dma_handle, align 8, !tbaa !73
  %usbm455 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 9
  %147 = load %struct.usb_memory*, %struct.usb_memory** %usbm455, align 8, !tbaa !251
  %vm_start456 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %147, i32 0, i32 6
  %148 = load i64, i64* %vm_start456, align 8, !tbaa !76
  %sub457 = sub i64 %142, %148
  %add458 = add i64 %146, %sub457
  %urb459 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %149 = load %struct.urb*, %struct.urb** %urb459, align 8, !tbaa !141
  %transfer_dma = getelementptr inbounds %struct.urb, %struct.urb* %149, i32 0, i32 15
  store i64 %add458, i64* %transfer_dma, align 8, !tbaa !306
  br label %if.end469

if.else460:                                       ; preds = %for.end444
  %tobool461 = icmp ne i32 %is_in.1, 0
  br i1 %tobool461, label %land.lhs.true462, label %if.end469

land.lhs.true462:                                 ; preds = %if.else460
  %buffer_length463 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %150 = load i32, i32* %buffer_length463, align 8, !tbaa !283
  %cmp464 = icmp sgt i32 %150, 0
  br i1 %cmp464, label %if.then466, label %if.end469

if.then466:                                       ; preds = %land.lhs.true462
  %buffer467 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %151 = load i8*, i8** %buffer467, align 8, !tbaa !284
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 6
  store i8* %151, i8** %userbuffer, align 8, !tbaa !231
  br label %if.end469

if.end469:                                        ; preds = %if.else460, %land.lhs.true462, %if.then466, %if.then448
  %signr = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 10
  %152 = load i32, i32* %signr, align 4, !tbaa !307
  %signr470 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 4
  store i32 %152, i32* %signr470, align 8, !tbaa !308
  %ifnum471 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 5
  store i32 %ifnum.0, i32* %ifnum471, align 4, !tbaa !136
  %call472 = call %struct.task_struct* @get_current()
  %call473 = call %struct.pid* @task_pid(%struct.task_struct* %call472)
  %call474 = call %struct.pid* @get_pid(%struct.pid* %call473)
  %pid = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 2
  store %struct.pid* %call474, %struct.pid** %pid, align 8, !tbaa !247
  %call479 = call %struct.task_struct* @get_current()
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call479, i32 0, i32 76
  %153 = load %struct.cred*, %struct.cred** %cred, align 32, !tbaa !96
  %call480 = call %struct.cred* @get_cred(%struct.cred* %153)
  %cred481 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 3
  store %struct.cred* %call480, %struct.cred** %cred481, align 8, !tbaa !248
  %call482 = call %struct.task_struct* @get_current()
  %secid = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 12
  call void @security_task_getsecid(%struct.task_struct* %call482, i32* %secid)
  %dev483 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %154 = load %struct.usb_device*, %struct.usb_device** %dev483, align 8, !tbaa !42
  %userurb484 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 7
  %155 = load i8*, i8** %userurb484, align 8, !tbaa !152
  %urb485 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %156 = load %struct.urb*, %struct.urb** %urb485, align 8, !tbaa !141
  %pipe486 = getelementptr inbounds %struct.urb, %struct.urb* %156, i32 0, i32 10
  %157 = load i32, i32* %pipe486, align 8, !tbaa !294
  %urb487 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %158 = load %struct.urb*, %struct.urb** %urb487, align 8, !tbaa !141
  %transfer_buffer_length488 = getelementptr inbounds %struct.urb, %struct.urb* %158, i32 0, i32 19
  %159 = load i32, i32* %transfer_buffer_length488, align 8, !tbaa !257
  call void @snoop_urb(%struct.usb_device* %154, i8* %155, i32 %157, i32 %159, i32 0, i32 0, i8* null, i32 0)
  %tobool489 = icmp ne i32 %is_in.1, 0
  br i1 %tobool489, label %if.end494, label %if.then490

if.then490:                                       ; preds = %if.end469
  %urb491 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %160 = load %struct.urb*, %struct.urb** %urb491, align 8, !tbaa !141
  %urb492 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %161 = load %struct.urb*, %struct.urb** %urb492, align 8, !tbaa !141
  %transfer_buffer_length493 = getelementptr inbounds %struct.urb, %struct.urb* %161, i32 0, i32 19
  %162 = load i32, i32* %transfer_buffer_length493, align 8, !tbaa !257
  call void @snoop_urb_data(%struct.urb* %160, i32 %162)
  br label %if.end494

if.end494:                                        ; preds = %if.then490, %if.end469
  call void @async_newpending(%struct.async* %call189)
  %desc495 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 0
  %call496 = call i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %desc495)
  %tobool497 = icmp ne i32 %call496, 0
  br i1 %tobool497, label %if.then498, label %if.else528

if.then498:                                       ; preds = %if.end494
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_lock_irq(%struct.spinlock* %lock)
  %desc499 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 0
  %call500 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %desc499)
  %desc501 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call25, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc501, i32 0, i32 2
  %163 = load i8, i8* %bEndpointAddress, align 2, !tbaa !309
  %conv502 = zext i8 %163 to i32
  %and503 = and i32 %conv502, 128
  %shr = ashr i32 %and503, 3
  %or504 = or i32 %call500, %shr
  %conv505 = trunc i32 %or504 to i8
  %bulk_addr = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 13
  store i8 %conv505, i8* %bulk_addr, align 4, !tbaa !310
  %flags506 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %164 = load i32, i32* %flags506, align 8, !tbaa !281
  %and507 = and i32 %164, 4
  %tobool508 = icmp ne i32 %and507, 0
  br i1 %tobool508, label %if.then509, label %if.else510

if.then509:                                       ; preds = %if.then498
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 14
  store i8 1, i8* %bulk_status, align 1, !tbaa !311
  br label %if.end515

if.else510:                                       ; preds = %if.then498
  %bulk_addr511 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 13
  %165 = load i8, i8* %bulk_addr511, align 4, !tbaa !310
  %conv512 = zext i8 %165 to i32
  %shl513 = shl i32 1, %conv512
  %neg = xor i32 %shl513, -1
  %disabled_bulk_eps = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 14
  %166 = load i32, i32* %disabled_bulk_eps, align 4, !tbaa !312
  %and514 = and i32 %166, %neg
  store i32 %and514, i32* %disabled_bulk_eps, align 4, !tbaa !312
  br label %if.end515

if.end515:                                        ; preds = %if.else510, %if.then509
  %disabled_bulk_eps516 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 14
  %167 = load i32, i32* %disabled_bulk_eps516, align 4, !tbaa !312
  %bulk_addr517 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 13
  %168 = load i8, i8* %bulk_addr517, align 4, !tbaa !310
  %conv518 = zext i8 %168 to i32
  %shl519 = shl i32 1, %conv518
  %and520 = and i32 %167, %shl519
  %tobool521 = icmp ne i32 %and520, 0
  br i1 %tobool521, label %if.end526, label %if.else523

if.else523:                                       ; preds = %if.end515
  %urb524 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %169 = load %struct.urb*, %struct.urb** %urb524, align 8, !tbaa !141
  %call525 = call i32 @usb_submit_urb(%struct.urb* %169, i32 17301536)
  br label %if.end526

if.end526:                                        ; preds = %if.end515, %if.else523
  %ret.0 = phi i32 [ %call525, %if.else523 ], [ -121, %if.end515 ]
  %lock527 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irq(%struct.spinlock* %lock527)
  br label %if.end531

if.else528:                                       ; preds = %if.end494
  %urb529 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %170 = load %struct.urb*, %struct.urb** %urb529, align 8, !tbaa !141
  %call530 = call i32 @usb_submit_urb(%struct.urb* %170, i32 20971712)
  br label %if.end531

if.end531:                                        ; preds = %if.else528, %if.end526
  %ret.1 = phi i32 [ %ret.0, %if.end526 ], [ %call530, %if.else528 ]
  %tobool532 = icmp ne i32 %ret.1, 0
  br i1 %tobool532, label %if.then533, label %cleanup

if.then533:                                       ; preds = %if.end531
  %dev534 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %171 = load %struct.usb_device*, %struct.usb_device** %dev534, align 8, !tbaa !42
  %dev535 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %171, i32 0, i32 11
  call void (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), %struct.device* %dev535, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.56, i32 0, i32 0), i32 %ret.1)
  %dev536 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %172 = load %struct.usb_device*, %struct.usb_device** %dev536, align 8, !tbaa !42
  %userurb537 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 7
  %173 = load i8*, i8** %userurb537, align 8, !tbaa !152
  %urb538 = getelementptr inbounds %struct.async, %struct.async* %call189, i32 0, i32 8
  %174 = load %struct.urb*, %struct.urb** %urb538, align 8, !tbaa !141
  %pipe539 = getelementptr inbounds %struct.urb, %struct.urb* %174, i32 0, i32 10
  %175 = load i32, i32* %pipe539, align 8, !tbaa !294
  call void @snoop_urb(%struct.usb_device* %172, i8* %173, i32 %175, i32 0, i32 %ret.1, i32 1, i8* null, i32 0)
  call void @async_removepending(%struct.async* %call189)
  br label %error

error:                                            ; preds = %if.then295, %if.else283, %if.then255, %for.body242, %if.then221, %if.end201, %if.end188, %land.lhs.true175, %for.body, %if.end60, %if.end53, %if.end48, %if.then533, %if.then196, %if.then153
  %ret.2 = phi i32 [ %conv155, %if.then153 ], [ %conv199, %if.then196 ], [ %ret.1, %if.then533 ], [ -14, %if.end48 ], [ -22, %if.end53 ], [ %call65, %if.end60 ], [ -22, %for.body ], [ -14, %land.lhs.true175 ], [ -12, %if.end188 ], [ %call216, %if.end201 ], [ -12, %if.then221 ], [ -12, %for.body242 ], [ -14, %if.then255 ], [ -12, %if.else283 ], [ -14, %if.then295 ]
  %dr.1 = phi %struct.usb_ctrlrequest* [ null, %if.then153 ], [ %dr.0, %if.then196 ], [ null, %if.then533 ], [ %12, %if.end48 ], [ %12, %if.end53 ], [ %12, %if.end60 ], [ null, %for.body ], [ %dr.0, %land.lhs.true175 ], [ %dr.0, %if.end188 ], [ %dr.0, %if.end201 ], [ %dr.0, %if.then221 ], [ %dr.0, %for.body242 ], [ %dr.0, %if.then255 ], [ %dr.0, %if.else283 ], [ %dr.0, %if.then295 ]
  %as.0 = phi %struct.async* [ null, %if.then153 ], [ %call189, %if.then196 ], [ %call189, %if.then533 ], [ null, %if.end48 ], [ null, %if.end53 ], [ null, %if.end60 ], [ null, %for.body ], [ null, %land.lhs.true175 ], [ %call189, %if.end188 ], [ %call189, %if.end201 ], [ %call189, %if.then221 ], [ %call189, %for.body242 ], [ %call189, %if.then255 ], [ %call189, %if.else283 ], [ %call189, %if.then295 ]
  %isopkt.1 = phi %struct.usbdevfs_iso_packet_desc* [ null, %if.then153 ], [ %isopkt.0, %if.then196 ], [ null, %if.then533 ], [ null, %if.end48 ], [ null, %if.end53 ], [ null, %if.end60 ], [ %41, %for.body ], [ %isopkt.0, %land.lhs.true175 ], [ %isopkt.0, %if.end188 ], [ %isopkt.0, %if.end201 ], [ %isopkt.0, %if.then221 ], [ %isopkt.0, %for.body242 ], [ %isopkt.0, %if.then255 ], [ %isopkt.0, %if.else283 ], [ %isopkt.0, %if.then295 ]
  %tobool541 = icmp ne %struct.async* %as.0, null
  br i1 %tobool541, label %land.lhs.true542, label %if.end548

land.lhs.true542:                                 ; preds = %error
  %usbm543 = getelementptr inbounds %struct.async, %struct.async* %as.0, i32 0, i32 9
  %176 = load %struct.usb_memory*, %struct.usb_memory** %usbm543, align 8, !tbaa !251
  %tobool544 = icmp ne %struct.usb_memory* %176, null
  br i1 %tobool544, label %if.then545, label %if.end548

if.then545:                                       ; preds = %land.lhs.true542
  %usbm546 = getelementptr inbounds %struct.async, %struct.async* %as.0, i32 0, i32 9
  %177 = load %struct.usb_memory*, %struct.usb_memory** %usbm546, align 8, !tbaa !251
  %usbm547 = getelementptr inbounds %struct.async, %struct.async* %as.0, i32 0, i32 9
  %178 = load %struct.usb_memory*, %struct.usb_memory** %usbm547, align 8, !tbaa !251
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %178, i32 0, i32 2
  call void @dec_usb_memory_use_count(%struct.usb_memory* %177, i32* %urb_use_count)
  br label %if.end548

if.end548:                                        ; preds = %if.then545, %land.lhs.true542, %error
  %179 = bitcast %struct.usbdevfs_iso_packet_desc* %isopkt.1 to i8*
  call void @kfree(i8* %179)
  %180 = bitcast %struct.usb_ctrlrequest* %dr.1 to i8*
  call void @kfree(i8* %180)
  %tobool549 = icmp ne %struct.async* %as.0, null
  br i1 %tobool549, label %if.then550, label %cleanup

if.then550:                                       ; preds = %if.end548
  call void @free_async(%struct.async* %as.0)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %cleanup

cleanup:                                          ; preds = %LeafBlock8, %NewDefault, %if.end548, %if.then550, %if.end531, %if.end141, %sw.bb132, %lor.lhs.false136, %sw.bb126, %if.end44, %if.end39, %sw.bb, %if.end22, %if.end17, %if.then11, %land.lhs.true, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -22, %land.lhs.true ], [ %call, %if.then11 ], [ %call18, %if.end17 ], [ -2, %if.end22 ], [ -22, %sw.bb ], [ -22, %if.end39 ], [ -12, %if.end44 ], [ -22, %LeafBlock8 ], [ -22, %sw.bb126 ], [ -22, %lor.lhs.false136 ], [ -22, %sw.bb132 ], [ -22, %if.end141 ], [ -22, %NewDefault ], [ 0, %if.end531 ], [ %ret.2, %if.then550 ], [ %ret.2, %if.end548 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.usb_host_endpoint* @ep_to_host_endpoint(%struct.usb_device* %dev, i8 zeroext %ep) #0 {
entry:
  %conv = zext i8 %ep to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 17
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 16
  %ep_out.sink = select i1 %tobool, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %conv3 = zext i8 %ep to i32
  %and4 = and i32 %conv3, 15
  %idxprom5 = sext i32 %and4 to i64
  %arrayidx6 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out.sink, i64 0, i64 %idxprom5
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx6, align 8, !tbaa !56
  ret %struct.usb_host_endpoint* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %epd) #3 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !258
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i16 @__le16_to_cpup(i16* %p) #5 {
entry:
  %0 = load i16, i16* %p, align 2, !tbaa !142
  ret i16 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %epd) #3 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !258
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %epd) #3 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !258
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare i8* @memdup_user(i8*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal %struct.async* @alloc_async(i32 %numisoframes) #0 {
entry:
  %call = call i8* @kzalloc(i64 96, i32 20971712)
  %0 = bitcast i8* %call to %struct.async*
  %tobool = icmp ne %struct.async* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call %struct.urb* @usb_alloc_urb(i32 %numisoframes, i32 20971712)
  %urb = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  store %struct.urb* %call1, %struct.urb** %urb, align 8, !tbaa !141
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %1 = load %struct.urb*, %struct.urb** %urb2, align 8, !tbaa !141
  %tobool3 = icmp ne %struct.urb* %1, null
  br i1 %tobool3, label %cleanup, label %if.then4

if.then4:                                         ; preds = %if.end
  %2 = bitcast %struct.async* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.then4
  %retval.0 = phi %struct.async* [ null, %if.then4 ], [ null, %entry ], [ %0, %if.end ]
  ret %struct.async* %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.usb_memory* @find_memory_area(%struct.usb_dev_state* %ps, %struct.usbdevfs_urb* %uurb) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %buffer = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %0 = load i8*, i8** %buffer, align 8, !tbaa !284
  %1 = ptrtoint i8* %0 to i64
  %2 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #7
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %memory_list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 6
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %memlist26.sink = phi %struct.list_head* [ %memlist26, %for.inc ], [ %memory_list, %entry ]
  %next27 = getelementptr inbounds %struct.list_head, %struct.list_head* %memlist26.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next27, align 8, !tbaa !56
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr29 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr29 to %struct.usb_memory*
  %memlist = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %8, i32 0, i32 0
  %memory_list6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 6
  %cmp7 = icmp ne %struct.list_head* %memlist, %memory_list6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %vm_start = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %8, i32 0, i32 6
  %9 = load i64, i64* %vm_start, align 8, !tbaa !76
  %cmp9 = icmp uge i64 %1, %9
  br i1 %cmp9, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %vm_start11 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %8, i32 0, i32 6
  %10 = load i64, i64* %vm_start11, align 8, !tbaa !76
  %size = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %8, i32 0, i32 3
  %11 = load i32, i32* %size, align 8, !tbaa !74
  %conv12 = zext i32 %11 to i64
  %add = add i64 %10, %conv12
  %cmp13 = icmp ult i64 %1, %add
  br i1 %cmp13, label %if.then, label %for.inc

if.then:                                          ; preds = %land.lhs.true
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %12 = load i32, i32* %buffer_length, align 8, !tbaa !283
  %conv15 = sext i32 %12 to i64
  %vm_start16 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %8, i32 0, i32 6
  %13 = load i64, i64* %vm_start16, align 8, !tbaa !76
  %size17 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %8, i32 0, i32 3
  %14 = load i32, i32* %size17, align 8, !tbaa !74
  %conv18 = zext i32 %14 to i64
  %add19 = add i64 %13, %conv18
  %sub = sub i64 %add19, %1
  %cmp20 = icmp ugt i64 %conv15, %sub
  br i1 %cmp20, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.then
  %call23 = call i8* @ERR_PTR(i64 -22)
  %15 = bitcast i8* %call23 to %struct.usb_memory*
  br label %for.end

if.else:                                          ; preds = %if.then
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %8, i32 0, i32 2
  %16 = load i32, i32* %urb_use_count, align 4, !tbaa !262
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %urb_use_count, align 4, !tbaa !262
  br label %for.end

for.inc:                                          ; preds = %for.body, %land.lhs.true
  %memlist26 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %8, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then22, %if.else
  %usbm.1 = phi %struct.usb_memory* [ %15, %if.then22 ], [ %8, %if.else ], [ null, %for.cond ]
  %lock30 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock30, i64 %call2)
  ret %struct.usb_memory* %usbm.1
}

declare void @sg_init_table(%struct.scatterlist*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_set_buf(%struct.scatterlist* %sg, i8* %buf, i32 %buflen) #3 {
entry:
  %0 = ptrtoint i8* %buf to i64
  %call = call i64 @__phys_addr_nodebug(i64 %0)
  %shr = lshr i64 %call, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %1 = ptrtoint i8* %buf to i64
  %and = and i64 %1, 4095
  %conv = trunc i64 %and to i32
  call void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %add.ptr, i32 %buflen, i32 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @async_completed(%struct.urb* %urb) #0 {
entry:
  %sinfo = alloca %struct.siginfo, align 8
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  %0 = load i8*, i8** %context, align 8, !tbaa !301
  %1 = bitcast i8* %0 to %struct.async*
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 1
  %2 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8, !tbaa !305
  %3 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %3) #7
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %lock)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 0
  %async_completed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 5
  call void @list_move_tail(%struct.list_head* %asynclist, %struct.list_head* %async_completed)
  %status = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  %4 = load i32, i32* %status, align 8, !tbaa !313
  %status2 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 11
  store i32 %4, i32* %status2, align 4, !tbaa !234
  %signr3 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 4
  %5 = load i32, i32* %signr3, align 8, !tbaa !308
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %do.body

if.then:                                          ; preds = %entry
  %6 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.memset.p0i8.i64(i8* %6, i8 0, i64 128, i32 8, i1 false)
  %signr4 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 4
  %7 = load i32, i32* %signr4, align 8, !tbaa !308
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %7, i32* %si_signo, align 8, !tbaa !314
  %status5 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 11
  %8 = load i32, i32* %status5, align 4, !tbaa !234
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 %8, i32* %si_errno, align 4, !tbaa !316
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8, !tbaa !317
  %userurb = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 7
  %9 = load i8*, i8** %userurb, align 8, !tbaa !152
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.13* %_sifields to %struct.anon.18*
  %_addr = getelementptr inbounds %struct.anon.18, %struct.anon.18* %_sigfault, i32 0, i32 0
  store i8* %9, i8** %_addr, align 8, !tbaa !139
  %pid6 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 2
  %10 = load %struct.pid*, %struct.pid** %pid6, align 8, !tbaa !247
  %call = call %struct.pid* @get_pid(%struct.pid* %10)
  %cred7 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 3
  %11 = load %struct.cred*, %struct.cred** %cred7, align 8, !tbaa !248
  %call8 = call %struct.cred* @get_cred(%struct.cred* %11)
  %secid9 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 12
  %12 = load i32, i32* %secid9, align 8, !tbaa !318
  br label %do.body

do.body:                                          ; preds = %entry, %if.then
  %pid.0 = phi %struct.pid* [ %call, %if.then ], [ null, %entry ]
  %secid.0 = phi i32 [ %12, %if.then ], [ 0, %entry ]
  %cred.0 = phi %struct.cred* [ %call8, %if.then ], [ null, %entry ]
  %13 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool10 = trunc i8 %13 to i1
  br i1 %tobool10, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %14 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !293
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %14, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev12, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.58, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %dev14 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %15 = load %struct.usb_device*, %struct.usb_device** %dev14, align 8, !tbaa !293
  %userurb15 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 7
  %16 = load i8*, i8** %userurb15, align 8, !tbaa !152
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  %17 = load i32, i32* %pipe, align 8, !tbaa !294
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %18 = load i32, i32* %actual_length, align 4, !tbaa !232
  %status16 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 11
  %19 = load i32, i32* %status16, align 4, !tbaa !234
  call void @snoop_urb(%struct.usb_device* %15, i8* %16, i32 %17, i32 %18, i32 %19, i32 1, i8* null, i32 0)
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %20 = load i32, i32* %transfer_flags, align 4, !tbaa !295
  %and = and i32 %20, 512
  %cmp = icmp eq i32 %and, 512
  br i1 %cmp, label %if.then17, label %if.end19

if.then17:                                        ; preds = %do.end
  %actual_length18 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %21 = load i32, i32* %actual_length18, align 4, !tbaa !232
  call void @snoop_urb_data(%struct.urb* %urb, i32 %21)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %do.end
  %status20 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 11
  %22 = load i32, i32* %status20, align 4, !tbaa !234
  %cmp21 = icmp slt i32 %22, 0
  br i1 %cmp21, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %if.end19
  %bulk_addr = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 13
  %23 = load i8, i8* %bulk_addr, align 4, !tbaa !310
  %conv = zext i8 %23 to i32
  %tobool22 = icmp ne i32 %conv, 0
  br i1 %tobool22, label %land.lhs.true23, label %if.end34

land.lhs.true23:                                  ; preds = %land.lhs.true
  %status24 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 11
  %24 = load i32, i32* %status24, align 4, !tbaa !234
  %cmp25 = icmp ne i32 %24, -104
  br i1 %cmp25, label %land.lhs.true27, label %if.end34

land.lhs.true27:                                  ; preds = %land.lhs.true23
  %status28 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 11
  %25 = load i32, i32* %status28, align 4, !tbaa !234
  %cmp29 = icmp ne i32 %25, -2
  br i1 %cmp29, label %if.then31, label %if.end34

if.then31:                                        ; preds = %land.lhs.true27
  %bulk_addr32 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 13
  %26 = load i8, i8* %bulk_addr32, align 4, !tbaa !310
  %conv33 = zext i8 %26 to i32
  call void @cancel_bulk_urbs(%struct.usb_dev_state* %2, i32 %conv33)
  br label %if.end34

if.end34:                                         ; preds = %if.then31, %land.lhs.true27, %land.lhs.true23, %land.lhs.true, %if.end19
  %lock35 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %lock35)
  %tobool36 = icmp ne i32 %5, 0
  br i1 %tobool36, label %if.then37, label %if.end40

if.then37:                                        ; preds = %if.end34
  %si_signo38 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  %27 = load i32, i32* %si_signo38, align 8, !tbaa !314
  %call39 = call i32 @kill_pid_info_as_cred(i32 %27, %struct.siginfo* %sinfo, %struct.pid* %pid.0, %struct.cred* %cred.0, i32 %secid.0)
  call void @put_pid(%struct.pid* %pid.0)
  call void @put_cred(%struct.cred* %cred.0)
  br label %if.end40

if.end40:                                         ; preds = %if.then37, %if.end34
  %wait = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 7
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 1, i8* null)
  %28 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %28) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.pid* @get_pid(%struct.pid* %pid) #3 {
entry:
  %tobool = icmp ne %struct.pid* %pid, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count = getelementptr inbounds %struct.pid, %struct.pid* %pid, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.pid* %pid
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.pid* @task_pid(%struct.task_struct* %task) #3 {
entry:
  %pids = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i32 0, i32 56
  %arrayidx = getelementptr inbounds [3 x %struct.pid_link], [3 x %struct.pid_link]* %pids, i64 0, i64 0
  %pid = getelementptr inbounds %struct.pid_link, %struct.pid_link* %arrayidx, i32 0, i32 1
  %0 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !319
  ret %struct.pid* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.cred* @get_cred(%struct.cred* %cred) #3 {
entry:
  call void @validate_creds(%struct.cred* %cred)
  %call = call %struct.cred* @get_new_cred(%struct.cred* %cred)
  ret %struct.cred* %call
}

declare void @security_task_getsecid(%struct.task_struct*, i32*) #1

; Function Attrs: nounwind uwtable
define internal void @snoop_urb_data(%struct.urb* %urb, i32 %len) #0 {
entry:
  %__UNIQUE_ID_min1_28 = alloca i32, align 4
  %__UNIQUE_ID_min2_29 = alloca i32, align 4
  %0 = bitcast i32* %__UNIQUE_ID_min1_28 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  store i32 %len, i32* %__UNIQUE_ID_min1_28, align 4, !tbaa !62
  %1 = bitcast i32* %__UNIQUE_ID_min2_29 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  %2 = load i32, i32* @usbfs_snoop_max, align 4, !tbaa !62
  store i32 %2, i32* %__UNIQUE_ID_min2_29, align 4, !tbaa !62
  %cmp = icmp eq i32* %__UNIQUE_ID_min1_28, %__UNIQUE_ID_min2_29
  %conv = zext i1 %cmp to i32
  %3 = load i32, i32* %__UNIQUE_ID_min1_28, align 4, !tbaa !62
  %4 = load i32, i32* %__UNIQUE_ID_min2_29, align 4, !tbaa !62
  %cmp1 = icmp ult i32 %3, %4
  %5 = load i32, i32* %__UNIQUE_ID_min1_28, align 4
  %6 = load i32, i32* %__UNIQUE_ID_min2_29, align 4
  %cond = select i1 %cmp1, i32 %5, i32 %6
  %7 = bitcast i32* %__UNIQUE_ID_min2_29 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #7
  %8 = bitcast i32* %__UNIQUE_ID_min1_28 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #7
  %9 = load i8, i8* @usbfs_snoop, align 1, !tbaa !131, !range !132
  %tobool = trunc i8 %9 to i1
  %tobool.not = xor i1 %tobool, true
  %cmp3 = icmp eq i32 %cond, 0
  %or.cond = or i1 %tobool.not, %cmp3
  br i1 %or.cond, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %10 = load i32, i32* %num_sgs, align 4, !tbaa !249
  %cmp5 = icmp eq i32 %10, 0
  br i1 %cmp5, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %11 = load i8*, i8** %transfer_buffer, align 8, !tbaa !252
  %conv8 = zext i32 %cond to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.49, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %11, i64 %conv8, i1 zeroext true)
  br label %cleanup.cont

if.end9:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end9
  %i.0 = phi i32 [ 0, %if.end9 ], [ %inc, %for.body ]
  %len.addr.0 = phi i32 [ %cond, %if.end9 ], [ %sub, %for.body ]
  %num_sgs10 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %12 = load i32, i32* %num_sgs10, align 4, !tbaa !249
  %cmp11 = icmp slt i32 %i.0, %12
  %tobool13 = icmp ne i32 %len.addr.0, 0
  %tobool13. = select i1 %cmp11, i1 %tobool13, i1 false
  br i1 %tobool13., label %for.body, label %cleanup.cont

for.body:                                         ; preds = %for.cond
  %cmp14 = icmp ugt i32 %len.addr.0, 16384
  %.len.addr.0 = select i1 %cmp14, i32 16384, i32 %len.addr.0
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %13 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !250
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %13, i64 %idxprom
  %call = call i8* @sg_virt(%struct.scatterlist* %arrayidx)
  %conv20 = sext i32 %.len.addr.0 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.49, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %call, i64 %conv20, i1 zeroext true)
  %sub = sub i32 %len.addr.0, %.len.addr.0
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup.cont:                                     ; preds = %if.then7, %entry, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @async_newpending(%struct.async* %as) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 1
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8, !tbaa !305
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 0
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 4
  call void @list_add_tail(%struct.list_head* %asynclist, %struct.list_head* %async_pending)
  %lock6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock6, i64 %call3)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %epd) #3 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !258
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 2
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_lock_irq(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %epd) #3 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !276
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

declare i32 @usb_submit_urb(%struct.urb*, i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock_irq(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon* %0 to %struct.raw_spinlock*
  call void @__raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @async_removepending(%struct.async* %as) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 1
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8, !tbaa !305
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  %lock6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock6, i64 %call3)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

declare %struct.urb* @usb_alloc_urb(i32, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR(i64 %error) #3 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %page, i32 %len, i32 %offset) #3 {
entry:
  call void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page)
  %offset1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  store i32 %offset, i32* %offset1, align 8, !tbaa !259
  %length = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 2
  store i32 %len, i32* %length, align 4, !tbaa !321
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @__phys_addr_nodebug(i64 %x) #3 {
entry:
  %sub = sub i64 %x, -2147483648
  %cmp = icmp ugt i64 %x, %sub
  %0 = load i64, i64* @phys_base, align 8
  %cond = select i1 %cmp, i64 %0, i64 131939247849472
  %add = add i64 %sub, %cond
  ret i64 %add
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page) #3 {
entry:
  %page_link1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %0 = load i64, i64* %page_link1, align 8, !tbaa !261
  %and = and i64 %0, 3
  %1 = ptrtoint %struct.page* %page to i64
  %and2 = and i64 %1, 3
  %tobool = icmp ne i64 %and2, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.57, i32 0, i32 0), i32 90, i64 12) #7, !srcloc !322
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  %2 = ptrtoint %struct.page* %page to i64
  %or = or i64 %and, %2
  %page_link11 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  store i64 %or, i64* %page_link11, align 8, !tbaa !261
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cancel_bulk_urbs(%struct.usb_dev_state* %ps, i32 %bulk_addr) #0 {
entry:
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %asynclist13.sink = phi %struct.list_head* [ %asynclist13, %for.inc ], [ %async_pending, %entry ]
  %next14 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist13.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next14, align 8, !tbaa !56
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr16 to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  %async_pending1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %bulk_addr2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 13
  %3 = load i8, i8* %bulk_addr2, align 4, !tbaa !310
  %conv = zext i8 %3 to i32
  %cmp3 = icmp eq i32 %conv, %bulk_addr
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 14
  %4 = load i8, i8* %bulk_status, align 1, !tbaa !311
  %conv5 = zext i8 %4 to i32
  %cmp6 = icmp ne i32 %conv5, 1
  br i1 %cmp6, label %rescan.preheader, label %if.end

if.end:                                           ; preds = %if.then
  %bulk_status9 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 14
  store i8 2, i8* %bulk_status9, align 1, !tbaa !311
  %bulk_addr10 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 13
  store i8 0, i8* %bulk_addr10, align 4, !tbaa !310
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end
  %asynclist13 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %shl = shl i32 1, %bulk_addr
  %disabled_bulk_eps = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 14
  %5 = load i32, i32* %disabled_bulk_eps, align 4, !tbaa !312
  %or = or i32 %5, %shl
  store i32 %or, i32* %disabled_bulk_eps, align 4, !tbaa !312
  br label %rescan.preheader

rescan.preheader:                                 ; preds = %if.then, %for.end
  br label %rescan

rescan:                                           ; preds = %rescan.preheader, %if.then32
  %async_pending18 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc38, %rescan
  %asynclist40.sink = phi %struct.list_head* [ %asynclist40, %for.inc38 ], [ %async_pending18, %rescan ]
  %next41 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist40.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next41, align 8, !tbaa !56
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr43 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr43 to %struct.async*
  %asynclist23 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 0
  %async_pending24 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  %cmp25 = icmp ne %struct.list_head* %asynclist23, %async_pending24
  br i1 %cmp25, label %for.body27, label %for.end44

for.body27:                                       ; preds = %for.cond22
  %bulk_status28 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 14
  %9 = load i8, i8* %bulk_status28, align 1, !tbaa !311
  %conv29 = zext i8 %9 to i32
  %cmp30 = icmp eq i32 %conv29, 2
  br i1 %cmp30, label %if.then32, label %for.inc38

if.then32:                                        ; preds = %for.body27
  %bulk_status33 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 14
  store i8 0, i8* %bulk_status33, align 1, !tbaa !311
  %urb34 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 8
  %10 = load %struct.urb*, %struct.urb** %urb34, align 8, !tbaa !141
  %call = call %struct.urb* @usb_get_urb(%struct.urb* %10)
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %lock)
  %call35 = call i32 @usb_unlink_urb(%struct.urb* %10)
  call void @usb_free_urb(%struct.urb* %10)
  %lock36 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %lock36)
  br label %rescan

for.inc38:                                        ; preds = %for.body27
  %asynclist40 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 0
  br label %for.cond22

for.end44:                                        ; preds = %for.cond22
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon* %0 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

declare i32 @kill_pid_info_as_cred(i32, %struct.siginfo*, %struct.pid*, %struct.cred*, i32) #1

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

declare void @_raw_spin_lock(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare i32 @usb_unlink_urb(%struct.urb*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__raw_spin_unlock(%struct.raw_spinlock* %lock) #3 {
entry:
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %lock)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !323
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @do_raw_spin_unlock(%struct.raw_spinlock* %lock) #3 {
entry:
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %lock, i32 0, i32 0
  call void @queued_spin_unlock(%struct.qspinlock* %raw_lock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queued_spin_unlock(%struct.qspinlock* %lock) #3 {
entry:
  call void @native_queued_spin_unlock(%struct.qspinlock* %lock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @native_queued_spin_unlock(%struct.qspinlock* %lock) #3 {
entry:
  %__u = alloca %union.anon.64, align 1
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then, label %do.body2

if.then:                                          ; preds = %entry
  call void @__compiletime_assert_17()
  br label %do.body2

do.body2:                                         ; preds = %entry, %if.then
  %tobool3 = trunc i8 0 to i1
  %conv = zext i1 %tobool3 to i32
  %mul = mul nsw i32 2, %conv
  %sub = sub nsw i32 1, %mul
  %0 = zext i32 %sub to i64
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !324
  %1 = bitcast %union.anon.64* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %1) #7
  %2 = bitcast %union.anon.64* %__u to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 1, i32 1, i1 false)
  %3 = bitcast %struct.qspinlock* %lock to i8*
  %__c = bitcast %union.anon.64* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %3, i8* %arraydecay, i32 1)
  %__val = bitcast %union.anon.64* %__u to i8*
  %4 = load i8, i8* %__val, align 1, !tbaa !139
  %5 = bitcast %union.anon.64* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %5) #7
  ret void
}

declare void @__compiletime_assert_17() #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @atomic_inc(%struct.atomic_t* %v) #5 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !325
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.cred* @get_new_cred(%struct.cred* %cred) #3 {
entry:
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %cred, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %usage)
  ret %struct.cred* %cred
}

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @__raw_spin_unlock_irq(%struct.raw_spinlock* %lock) #3 {
entry:
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %lock)
  call void @arch_local_irq_enable()
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !326
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_enable() #3 {
entry:
  call void @native_irq_enable()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @native_irq_enable() #3 {
entry:
  call void asm sideeffect "sti", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !327
  ret void
}

declare i8* @compat_alloc_user_space(i64) #1

declare i64 @copy_in_user(i8*, i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @compat_ptr(i32 %uptr) #3 {
entry:
  %conv = zext i32 %uptr to i64
  %0 = inttoptr i64 %conv to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_urb32(%struct.usbdevfs_urb* %kurb, %struct.usbdevfs_urb32* %uurb) #0 {
entry:
  %0 = ptrtoint %struct.usbdevfs_urb32* %uurb to i64
  %call = call %struct.task_struct* @get_current()
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call, i32 0, i32 151
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %1 = load i64, i64* %seg, align 8, !tbaa !161
  %call2 = call zeroext i1 @__chk_range_not_ok(i64 %0, i64 44, i64 %1)
  %frombool = zext i1 %call2 to i8
  %tobool = trunc i8 %frombool to i1
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %entry
  call void @stac()
  %type = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 0
  %2 = bitcast i8* %type to %struct.__large_struct*
  %3 = call { i32, i64 } asm sideeffect "\0A1:\09movb $2,${1:b}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %2, i32 -14, i32 0) #7, !srcloc !328
  %asmresult = extractvalue { i32, i64 } %3, 0
  %asmresult6 = extractvalue { i32, i64 } %3, 1
  call void @clac()
  %conv7 = trunc i64 %asmresult6 to i8
  %type8 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 0
  store i8 %conv7, i8* %type8, align 8, !tbaa !285
  %conv10 = sext i32 %asmresult to i64
  %expval11 = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool12 = icmp ne i64 %expval11, 0
  br i1 %tobool12, label %cleanup, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false
  call void @stac()
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 1
  %4 = bitcast i8* %endpoint to %struct.__large_struct*
  %5 = call { i32, i64 } asm sideeffect "\0A1:\09movb $2,${1:b}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %4, i32 -14, i32 0) #7, !srcloc !329
  %asmresult17 = extractvalue { i32, i64 } %5, 0
  %asmresult18 = extractvalue { i32, i64 } %5, 1
  call void @clac()
  %conv21 = trunc i64 %asmresult18 to i8
  %endpoint22 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 1
  store i8 %conv21, i8* %endpoint22, align 1, !tbaa !286
  %conv24 = sext i32 %asmresult17 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %cleanup, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %lor.lhs.false13
  call void @stac()
  %status = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 2
  %6 = bitcast i32* %status to %struct.__large_struct*
  %7 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %6, i32 -14, i32 0) #7, !srcloc !330
  %asmresult31 = extractvalue { i32, i64 } %7, 0
  %asmresult32 = extractvalue { i32, i64 } %7, 1
  call void @clac()
  %conv35 = trunc i64 %asmresult32 to i32
  %status36 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 2
  store i32 %conv35, i32* %status36, align 4, !tbaa !331
  %conv38 = sext i32 %asmresult31 to i64
  %expval39 = call i64 @llvm.expect.i64(i64 %conv38, i64 0)
  %tobool40 = icmp ne i64 %expval39, 0
  br i1 %tobool40, label %cleanup, label %lor.lhs.false41

lor.lhs.false41:                                  ; preds = %lor.lhs.false27
  call void @stac()
  %flags = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 3
  %8 = bitcast i32* %flags to %struct.__large_struct*
  %9 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %8, i32 -14, i32 0) #7, !srcloc !332
  %asmresult45 = extractvalue { i32, i64 } %9, 0
  %asmresult46 = extractvalue { i32, i64 } %9, 1
  call void @clac()
  %conv49 = trunc i64 %asmresult46 to i32
  %flags50 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 3
  store i32 %conv49, i32* %flags50, align 8, !tbaa !281
  %conv52 = sext i32 %asmresult45 to i64
  %expval53 = call i64 @llvm.expect.i64(i64 %conv52, i64 0)
  %tobool54 = icmp ne i64 %expval53, 0
  br i1 %tobool54, label %cleanup, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %lor.lhs.false41
  call void @stac()
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 5
  %10 = bitcast i32* %buffer_length to %struct.__large_struct*
  %11 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %10, i32 -14, i32 0) #7, !srcloc !333
  %asmresult59 = extractvalue { i32, i64 } %11, 0
  %asmresult60 = extractvalue { i32, i64 } %11, 1
  call void @clac()
  %conv63 = trunc i64 %asmresult60 to i32
  %buffer_length64 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 5
  store i32 %conv63, i32* %buffer_length64, align 8, !tbaa !283
  %conv66 = sext i32 %asmresult59 to i64
  %expval67 = call i64 @llvm.expect.i64(i64 %conv66, i64 0)
  %tobool68 = icmp ne i64 %expval67, 0
  br i1 %tobool68, label %cleanup, label %lor.lhs.false69

lor.lhs.false69:                                  ; preds = %lor.lhs.false55
  call void @stac()
  %actual_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 6
  %12 = bitcast i32* %actual_length to %struct.__large_struct*
  %13 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %12, i32 -14, i32 0) #7, !srcloc !334
  %asmresult73 = extractvalue { i32, i64 } %13, 0
  %asmresult74 = extractvalue { i32, i64 } %13, 1
  call void @clac()
  %conv77 = trunc i64 %asmresult74 to i32
  %actual_length78 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 6
  store i32 %conv77, i32* %actual_length78, align 4, !tbaa !335
  %conv80 = sext i32 %asmresult73 to i64
  %expval81 = call i64 @llvm.expect.i64(i64 %conv80, i64 0)
  %tobool82 = icmp ne i64 %expval81, 0
  br i1 %tobool82, label %cleanup, label %lor.lhs.false83

lor.lhs.false83:                                  ; preds = %lor.lhs.false69
  call void @stac()
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 7
  %14 = bitcast i32* %start_frame to %struct.__large_struct*
  %15 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %14, i32 -14, i32 0) #7, !srcloc !336
  %asmresult87 = extractvalue { i32, i64 } %15, 0
  %asmresult88 = extractvalue { i32, i64 } %15, 1
  call void @clac()
  %conv91 = trunc i64 %asmresult88 to i32
  %start_frame92 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 7
  store i32 %conv91, i32* %start_frame92, align 8, !tbaa !296
  %conv94 = sext i32 %asmresult87 to i64
  %expval95 = call i64 @llvm.expect.i64(i64 %conv94, i64 0)
  %tobool96 = icmp ne i64 %expval95, 0
  br i1 %tobool96, label %cleanup, label %lor.lhs.false97

lor.lhs.false97:                                  ; preds = %lor.lhs.false83
  call void @stac()
  %number_of_packets = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 8
  %16 = bitcast i32* %number_of_packets to %struct.__large_struct*
  %17 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %16, i32 -14, i32 0) #7, !srcloc !337
  %asmresult101 = extractvalue { i32, i64 } %17, 0
  %asmresult102 = extractvalue { i32, i64 } %17, 1
  call void @clac()
  %conv105 = trunc i64 %asmresult102 to i32
  %18 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 8
  %number_of_packets106 = bitcast %union.anon.62* %18 to i32*
  store i32 %conv105, i32* %number_of_packets106, align 4, !tbaa !139
  %conv108 = sext i32 %asmresult101 to i64
  %expval109 = call i64 @llvm.expect.i64(i64 %conv108, i64 0)
  %tobool110 = icmp ne i64 %expval109, 0
  br i1 %tobool110, label %cleanup, label %lor.lhs.false111

lor.lhs.false111:                                 ; preds = %lor.lhs.false97
  call void @stac()
  %error_count = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 9
  %19 = bitcast i32* %error_count to %struct.__large_struct*
  %20 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %19, i32 -14, i32 0) #7, !srcloc !338
  %asmresult115 = extractvalue { i32, i64 } %20, 0
  %asmresult116 = extractvalue { i32, i64 } %20, 1
  call void @clac()
  %conv119 = trunc i64 %asmresult116 to i32
  %error_count120 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 9
  store i32 %conv119, i32* %error_count120, align 8, !tbaa !339
  %conv122 = sext i32 %asmresult115 to i64
  %expval123 = call i64 @llvm.expect.i64(i64 %conv122, i64 0)
  %tobool124 = icmp ne i64 %expval123, 0
  br i1 %tobool124, label %cleanup, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %lor.lhs.false111
  call void @stac()
  %signr = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 10
  %21 = bitcast i32* %signr to %struct.__large_struct*
  %22 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %21, i32 -14, i32 0) #7, !srcloc !340
  %asmresult129 = extractvalue { i32, i64 } %22, 0
  %asmresult130 = extractvalue { i32, i64 } %22, 1
  call void @clac()
  %conv133 = trunc i64 %asmresult130 to i32
  %signr134 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 10
  store i32 %conv133, i32* %signr134, align 4, !tbaa !307
  %conv136 = sext i32 %asmresult129 to i64
  %expval137 = call i64 @llvm.expect.i64(i64 %conv136, i64 0)
  %tobool138 = icmp ne i64 %expval137, 0
  br i1 %tobool138, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false125
  call void @stac()
  %buffer = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 4
  %23 = bitcast i32* %buffer to %struct.__large_struct*
  %24 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %23, i32 -14, i32 0) #7, !srcloc !341
  %asmresult142 = extractvalue { i32, i64 } %24, 0
  %asmresult143 = extractvalue { i32, i64 } %24, 1
  call void @clac()
  %conv146 = trunc i64 %asmresult143 to i32
  %conv148 = sext i32 %asmresult142 to i64
  %expval149 = call i64 @llvm.expect.i64(i64 %conv148, i64 0)
  %tobool150 = icmp ne i64 %expval149, 0
  br i1 %tobool150, label %cleanup, label %if.end152

if.end152:                                        ; preds = %if.end
  %call153 = call i8* @compat_ptr(i32 %conv146)
  %buffer154 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 4
  store i8* %call153, i8** %buffer154, align 8, !tbaa !284
  call void @stac()
  %usercontext = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 11
  %25 = bitcast i32* %usercontext to %struct.__large_struct*
  %26 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %25, i32 -14, i32 0) #7, !srcloc !342
  %asmresult158 = extractvalue { i32, i64 } %26, 0
  %asmresult159 = extractvalue { i32, i64 } %26, 1
  call void @clac()
  %conv162 = trunc i64 %asmresult159 to i32
  %conv164 = sext i32 %asmresult158 to i64
  %expval165 = call i64 @llvm.expect.i64(i64 %conv164, i64 0)
  %tobool166 = icmp ne i64 %expval165, 0
  br i1 %tobool166, label %cleanup, label %if.end168

if.end168:                                        ; preds = %if.end152
  %call169 = call i8* @compat_ptr(i32 %conv162)
  %usercontext170 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 11
  store i8* %call169, i8** %usercontext170, align 8, !tbaa !343
  br label %cleanup

cleanup:                                          ; preds = %if.end152, %if.end, %entry, %lor.lhs.false, %lor.lhs.false13, %lor.lhs.false27, %lor.lhs.false41, %lor.lhs.false55, %lor.lhs.false69, %lor.lhs.false83, %lor.lhs.false97, %lor.lhs.false111, %lor.lhs.false125, %if.end168
  %retval.0 = phi i32 [ 0, %if.end168 ], [ -14, %lor.lhs.false125 ], [ -14, %lor.lhs.false111 ], [ -14, %lor.lhs.false97 ], [ -14, %lor.lhs.false83 ], [ -14, %lor.lhs.false69 ], [ -14, %lor.lhs.false55 ], [ -14, %lor.lhs.false41 ], [ -14, %lor.lhs.false27 ], [ -14, %lor.lhs.false13 ], [ -14, %lor.lhs.false ], [ -14, %entry ], [ -14, %if.end ], [ -14, %if.end152 ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @stac() #5 {
entry:
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !344
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @clac() #5 {
entry:
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !345
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_ioctl(%struct.usb_dev_state* %ps, %struct.usbdevfs_ioctl* %ctl) #0 {
entry:
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 15
  %0 = load i8, i8* %privileges_dropped, align 8, !tbaa !169, !range !132
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %ioctl_code = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %1 = load i32, i32* %ioctl_code, align 4, !tbaa !207
  %shr = ashr i32 %1, 16
  %and = and i32 %shr, 16383
  %cmp = icmp sgt i32 %and, 0
  br i1 %cmp, label %if.then2, label %if.end20

if.then2:                                         ; preds = %if.end
  %conv = sext i32 %and to i64
  %call = call i8* @kmalloc(i64 %conv, i32 20971712)
  %cmp3 = icmp eq i8* %call, null
  br i1 %cmp3, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.then2
  %ioctl_code7 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %2 = load i32, i32* %ioctl_code7, align 4, !tbaa !207
  %shr8 = ashr i32 %2, 30
  %and9 = and i32 %shr8, 3
  %and10 = and i32 %and9, 1
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end6
  %data = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 2
  %3 = load i8*, i8** %data, align 8, !tbaa !209
  %conv13 = sext i32 %and to i64
  %call14 = call i64 @copy_from_user(i8* %call, i8* %3, i64 %conv13)
  %tobool15 = icmp ne i64 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end20

if.then16:                                        ; preds = %if.then12
  call void @kfree(i8* %call)
  br label %cleanup

if.else:                                          ; preds = %if.end6
  %conv18 = sext i32 %and to i64
  call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 %conv18, i32 1, i1 false)
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then12, %if.end
  %buf.0 = phi i8* [ null, %if.end ], [ %call, %if.then12 ], [ %call, %if.else ]
  %call21 = call i32 @connected(%struct.usb_dev_state* %ps)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end20
  call void @kfree(i8* %buf.0)
  br label %cleanup

if.end24:                                         ; preds = %if.end20
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 3
  %5 = load i32, i32* %state, align 8, !tbaa !90
  %cmp25 = icmp ne i32 %5, 7
  br i1 %cmp25, label %if.end77, label %if.else28

if.else28:                                        ; preds = %if.end24
  %dev29 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev29, align 8, !tbaa !42
  %ifno = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 0
  %7 = load i32, i32* %ifno, align 8, !tbaa !204
  %call30 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %6, i32 %7)
  %tobool31 = icmp ne %struct.usb_interface* %call30, null
  br i1 %tobool31, label %if.else33, label %if.end77

if.else33:                                        ; preds = %if.else28
  %ioctl_code34 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %8 = load i32, i32* %ioctl_code34, align 4, !tbaa !207
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.else33
  %Pivot = icmp slt i32 %8, 21783
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %8, 21783
  br i1 %SwitchLeaf2, label %sw.bb43, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %8, 21782
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %dev35 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call30, i32 0, i32 7
  %driver36 = getelementptr inbounds %struct.device, %struct.device* %dev35, i32 0, i32 7
  %9 = load %struct.device_driver*, %struct.device_driver** %driver36, align 8, !tbaa !172
  %tobool37 = icmp ne %struct.device_driver* %9, null
  br i1 %tobool37, label %if.then38, label %if.end77

if.then38:                                        ; preds = %sw.bb
  %dev39 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call30, i32 0, i32 7
  %driver40 = getelementptr inbounds %struct.device, %struct.device* %dev39, i32 0, i32 7
  %10 = load %struct.device_driver*, %struct.device_driver** %driver40, align 8, !tbaa !172
  %11 = bitcast %struct.device_driver* %10 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 -104
  %12 = bitcast i8* %add.ptr to %struct.usb_driver*
  call void @usb_driver_release_interface(%struct.usb_driver* %12, %struct.usb_interface* %call30)
  br label %if.end77

sw.bb43:                                          ; preds = %LeafBlock1
  %dev44 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call30, i32 0, i32 7
  %driver45 = getelementptr inbounds %struct.device, %struct.device* %dev44, i32 0, i32 7
  %13 = load %struct.device_driver*, %struct.device_driver** %driver45, align 8, !tbaa !172
  %tobool46 = icmp ne %struct.device_driver* %13, null
  br i1 %tobool46, label %if.end77, label %if.then47

if.then47:                                        ; preds = %sw.bb43
  %dev48 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call30, i32 0, i32 7
  %call49 = call i32 @device_attach(%struct.device* %dev48)
  br label %if.end77

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %dev52 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call30, i32 0, i32 7
  %driver53 = getelementptr inbounds %struct.device, %struct.device* %dev52, i32 0, i32 7
  %14 = load %struct.device_driver*, %struct.device_driver** %driver53, align 8, !tbaa !172
  %tobool54 = icmp ne %struct.device_driver* %14, null
  br i1 %tobool54, label %if.then55, label %if.end61

if.then55:                                        ; preds = %sw.default
  %dev57 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call30, i32 0, i32 7
  %driver58 = getelementptr inbounds %struct.device, %struct.device* %dev57, i32 0, i32 7
  %15 = load %struct.device_driver*, %struct.device_driver** %driver58, align 8, !tbaa !172
  %16 = bitcast %struct.device_driver* %15 to i8*
  %add.ptr60 = getelementptr inbounds i8, i8* %16, i64 -104
  %17 = bitcast i8* %add.ptr60 to %struct.usb_driver*
  br label %if.end61

if.end61:                                         ; preds = %if.then55, %sw.default
  %driver.0 = phi %struct.usb_driver* [ %17, %if.then55 ], [ null, %sw.default ]
  %cmp62 = icmp eq %struct.usb_driver* %driver.0, null
  br i1 %cmp62, label %if.end77, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end61
  %unlocked_ioctl = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver.0, i32 0, i32 3
  %18 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl, align 8, !tbaa !346
  %cmp64 = icmp eq i32 (%struct.usb_interface*, i32, i8*)* %18, null
  br i1 %cmp64, label %if.end77, label %if.else67

if.else67:                                        ; preds = %lor.lhs.false
  %unlocked_ioctl68 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver.0, i32 0, i32 3
  %19 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl68, align 8, !tbaa !346
  %ioctl_code69 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %20 = load i32, i32* %ioctl_code69, align 4, !tbaa !207
  %call70 = call i32 %19(%struct.usb_interface* %call30, i32 %20, i8* %buf.0)
  %cmp71 = icmp eq i32 %call70, -515
  %.call70 = select i1 %cmp71, i32 -25, i32 %call70
  br label %if.end77

if.end77:                                         ; preds = %if.else28, %if.else67, %lor.lhs.false, %if.end61, %if.then47, %sw.bb43, %if.then38, %sw.bb, %if.end24
  %retval1.6 = phi i32 [ -113, %if.end24 ], [ -22, %if.else28 ], [ 0, %if.then38 ], [ -61, %sw.bb ], [ %call49, %if.then47 ], [ -16, %sw.bb43 ], [ %.call70, %if.else67 ], [ -25, %lor.lhs.false ], [ -25, %if.end61 ]
  %cmp78 = icmp sge i32 %retval1.6, 0
  br i1 %cmp78, label %land.lhs.true, label %if.end96

land.lhs.true:                                    ; preds = %if.end77
  %ioctl_code80 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %21 = load i32, i32* %ioctl_code80, align 4, !tbaa !207
  %shr81 = ashr i32 %21, 30
  %and82 = and i32 %shr81, 3
  %and83 = and i32 %and82, 2
  %cmp84 = icmp ne i32 %and83, 0
  %cmp87 = icmp sgt i32 %and, 0
  %or.cond = and i1 %cmp84, %cmp87
  br i1 %or.cond, label %land.lhs.true89, label %if.end96

land.lhs.true89:                                  ; preds = %land.lhs.true
  %data90 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 2
  %22 = load i8*, i8** %data90, align 8, !tbaa !209
  %conv91 = sext i32 %and to i64
  %call92 = call i64 @copy_to_user(i8* %22, i8* %buf.0, i64 %conv91)
  %cmp93 = icmp ne i64 %call92, 0
  %.retval1.6 = select i1 %cmp93, i32 -14, i32 %retval1.6
  br label %if.end96

if.end96:                                         ; preds = %land.lhs.true89, %land.lhs.true, %if.end77
  %retval1.7 = phi i32 [ %retval1.6, %land.lhs.true ], [ %retval1.6, %if.end77 ], [ %.retval1.6, %land.lhs.true89 ]
  call void @kfree(i8* %buf.0)
  br label %cleanup

cleanup:                                          ; preds = %if.then2, %entry, %if.end96, %if.then23, %if.then16
  %retval.0 = phi i32 [ -14, %if.then16 ], [ %retval1.7, %if.end96 ], [ -19, %if.then23 ], [ -13, %entry ], [ -12, %if.then2 ]
  ret i32 %retval.0
}

declare void @usb_driver_release_interface(%struct.usb_driver*, %struct.usb_interface*) #1

declare i32 @device_attach(%struct.device*) #1

; Function Attrs: nounwind uwtable
define internal %struct.async* @async_getpending(%struct.usb_dev_state* %ps, i8* %userurb) #0 {
entry:
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %asynclist6.sink = phi %struct.list_head* [ %asynclist4, %for.inc ], [ %async_pending, %entry ]
  %next7 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist6.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next7, align 8, !tbaa !56
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr9 to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  %async_pending1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 7
  %3 = load i8*, i8** %userurb2, align 8, !tbaa !152
  %cmp3 = icmp eq i8* %3, %userurb
  %asynclist4 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_del_init(%struct.list_head* %asynclist4)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.then
  %retval.0 = phi %struct.async* [ %2, %if.then ], [ null, %for.cond ]
  ret %struct.async* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @releaseintf(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %conv = zext i32 %ifnum to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !42
  %call = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %0, i32 %ifnum)
  %tobool = icmp ne %struct.usb_interface* %call, null
  br i1 %tobool, label %if.else, label %cleanup

if.else:                                          ; preds = %if.end
  %conv4 = zext i32 %ifnum to i64
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 12
  %call5 = call zeroext i1 @test_and_clear_bit(i64 %conv4, i64* %ifclaimed)
  br i1 %call5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %if.else
  call void @usb_driver_release_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then6, %if.else, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -2, %if.end ], [ 0, %if.then6 ], [ -22, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @test_and_clear_bit(i64 %nr, i64* %addr) #5 {
entry:
  %c = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #7
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i8* %c, i64 %nr, i64* %addr) #7, !srcloc !350
  %0 = load i8, i8* %c, align 1, !tbaa !131, !range !132
  %tobool = trunc i8 %0 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #7
  ret i1 %tobool
}

declare i32 @usb_hub_claim_port(%struct.usb_device*, i32, %struct.usb_dev_state*) #1

declare i32 @usb_hub_release_port(%struct.usb_device*, i32, %struct.usb_dev_state*) #1

declare i32 @strncmp(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @parse_usbdevfs_streams(%struct.usb_dev_state* %ps, %struct.usbdevfs_streams* %streams, i32* %num_streams_ret, i32* %num_eps_ret, %struct.usb_host_endpoint*** %eps_ret, %struct.usb_interface** %intf_ret) #0 {
entry:
  call void @might_fault()
  %num_streams1 = getelementptr inbounds %struct.usbdevfs_streams, %struct.usbdevfs_streams* %streams, i32 0, i32 0
  %0 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %num_streams1, i64 4, i8* undef) #7, !srcloc !351
  %asmresult = extractvalue { i32*, i64, i8* } %0, 0
  %asmresult2 = extractvalue { i32*, i64, i8* } %0, 1
  %asmresult3 = extractvalue { i32*, i64, i8* } %0, 2
  %1 = ptrtoint i32* %asmresult to i64
  %2 = trunc i64 %1 to i32
  %conv = trunc i64 %asmresult2 to i32
  %conv4 = sext i32 %2 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %num_eps8 = getelementptr inbounds %struct.usbdevfs_streams, %struct.usbdevfs_streams* %streams, i32 0, i32 1
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %num_eps8, i64 4, i8* undef) #7, !srcloc !352
  %asmresult9 = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult10 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult11 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult9 to i64
  %5 = trunc i64 %4 to i32
  %conv12 = trunc i64 %asmresult10 to i32
  %conv14 = sext i32 %5 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %cmp = icmp ult i32 %conv12, 1
  %cmp19 = icmp ugt i32 %conv12, 30
  %or.cond = or i1 %cmp, %cmp19
  br i1 %or.cond, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.end
  %tobool23 = icmp ne i32* %num_streams_ret, null
  br i1 %tobool23, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.end22
  %cmp24 = icmp ult i32 %conv, 2
  %cmp27 = icmp ugt i32 %conv, 65536
  %or.cond1 = or i1 %cmp24, %cmp27
  br i1 %or.cond1, label %cleanup, label %if.end30

if.end30:                                         ; preds = %land.lhs.true, %if.end22
  %conv31 = zext i32 %conv12 to i64
  %mul = mul i64 %conv31, 8
  %call = call i8* @kmalloc(i64 %mul, i32 20971712)
  %6 = bitcast i8* %call to %struct.usb_host_endpoint**
  %tobool32 = icmp ne %struct.usb_host_endpoint** %6, null
  br i1 %tobool32, label %if.end34, label %cleanup

if.end34:                                         ; preds = %if.end30
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end34
  %i.0 = phi i32 [ 0, %if.end34 ], [ %inc, %for.inc ]
  %intf.0 = phi %struct.usb_interface* [ null, %if.end34 ], [ %intf.1, %for.inc ]
  %__sp39.0 = phi i8* [ undef, %if.end34 ], [ %asmresult43, %for.inc ]
  %cmp35 = icmp ult i32 %i.0, %conv12
  br i1 %cmp35, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %eps40 = getelementptr inbounds %struct.usbdevfs_streams, %struct.usbdevfs_streams* %streams, i32 0, i32 2
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [0 x i8], [0 x i8]* %eps40, i64 0, i64 %idxprom
  %7 = call { i8*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i8* %arrayidx, i64 1, i8* %__sp39.0) #7, !srcloc !353
  %asmresult41 = extractvalue { i8*, i64, i8* } %7, 0
  %asmresult42 = extractvalue { i8*, i64, i8* } %7, 1
  %asmresult43 = extractvalue { i8*, i64, i8* } %7, 2
  %8 = ptrtoint i8* %asmresult41 to i64
  %9 = trunc i64 %8 to i32
  %conv44 = trunc i64 %asmresult42 to i8
  %conv46 = sext i32 %9 to i64
  %expval47 = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool48 = icmp ne i64 %expval47, 0
  br i1 %tobool48, label %error, label %if.end50

if.end50:                                         ; preds = %for.body
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !42
  %call51 = call %struct.usb_host_endpoint* @ep_to_host_endpoint(%struct.usb_device* %10, i8 zeroext %conv44)
  %idxprom52 = zext i32 %i.0 to i64
  %arrayidx53 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %6, i64 %idxprom52
  store %struct.usb_host_endpoint* %call51, %struct.usb_host_endpoint** %arrayidx53, align 8, !tbaa !56
  %idxprom54 = zext i32 %i.0 to i64
  %arrayidx55 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %6, i64 %idxprom54
  %11 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx55, align 8, !tbaa !56
  %tobool56 = icmp ne %struct.usb_host_endpoint* %11, null
  br i1 %tobool56, label %if.end58, label %error

if.end58:                                         ; preds = %if.end50
  %dev59 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %dev59, align 8, !tbaa !42
  %conv60 = zext i8 %conv44 to i32
  %call61 = call i32 @findintfep(%struct.usb_device* %12, i32 %conv60)
  %cmp62 = icmp slt i32 %call61, 0
  br i1 %cmp62, label %error, label %if.end65

if.end65:                                         ; preds = %if.end58
  %cmp66 = icmp eq i32 %i.0, 0
  br i1 %cmp66, label %if.then68, label %if.else

if.then68:                                        ; preds = %if.end65
  %call69 = call i32 @checkintf(%struct.usb_dev_state* %ps, i32 %call61)
  %cmp70 = icmp slt i32 %call69, 0
  br i1 %cmp70, label %error, label %if.end73

if.end73:                                         ; preds = %if.then68
  %dev74 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %dev74, align 8, !tbaa !42
  %call75 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %13, i32 %call61)
  br label %for.inc

if.else:                                          ; preds = %if.end65
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf.0, i32 0, i32 0
  %14 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !2
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %14, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %15 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !31
  %conv76 = zext i8 %15 to i32
  %cmp77 = icmp ne i32 %call61, %conv76
  br i1 %cmp77, label %error, label %for.inc

for.inc:                                          ; preds = %if.end73, %if.else
  %intf.1 = phi %struct.usb_interface* [ %call75, %if.end73 ], [ %intf.0, %if.else ]
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %tobool82 = icmp ne i32* %num_streams_ret, null
  br i1 %tobool82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %for.end
  store i32 %conv, i32* %num_streams_ret, align 4, !tbaa !62
  br label %if.end84

if.end84:                                         ; preds = %if.then83, %for.end
  store i32 %conv12, i32* %num_eps_ret, align 4, !tbaa !62
  store %struct.usb_host_endpoint** %6, %struct.usb_host_endpoint*** %eps_ret, align 8, !tbaa !56
  store %struct.usb_interface* %intf.0, %struct.usb_interface** %intf_ret, align 8, !tbaa !56
  br label %cleanup

error:                                            ; preds = %if.else, %if.then68, %if.end58, %if.end50, %for.body
  %ret.0 = phi i32 [ -14, %for.body ], [ -22, %if.end50 ], [ %call61, %if.end58 ], [ %call69, %if.then68 ], [ -22, %if.else ]
  %16 = bitcast %struct.usb_host_endpoint** %6 to i8*
  call void @kfree(i8* %16)
  br label %cleanup

cleanup:                                          ; preds = %if.end30, %land.lhs.true, %if.end, %entry, %lor.lhs.false, %error, %if.end84
  %retval.0 = phi i32 [ %ret.0, %error ], [ 0, %if.end84 ], [ -14, %lor.lhs.false ], [ -14, %entry ], [ -22, %if.end ], [ -22, %land.lhs.true ], [ -12, %if.end30 ]
  ret i32 %retval.0
}

declare i32 @usb_alloc_streams(%struct.usb_interface*, %struct.usb_host_endpoint**, i32, i32, i32) #1

declare i32 @usb_free_streams(%struct.usb_interface*, %struct.usb_host_endpoint**, i32, i32) #1

declare i8* @usb_alloc_coherent(%struct.usb_device*, i64, i32, i64*) #1

declare i32 @remap_pfn_range(%struct.vm_area_struct*, i64, i64, i64, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @virt_to_phys(i8* %address) #3 {
entry:
  %0 = ptrtoint i8* %address to i64
  %call = call i64 @__phys_addr_nodebug(i64 %0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal void @usbdev_vm_open(%struct.vm_area_struct* %vma) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %vm_private_data = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 15
  %0 = load i8*, i8** %vm_private_data, align 8, !tbaa !80
  %1 = bitcast i8* %0 to %struct.usb_memory*
  %2 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #7
  %ps = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %1, i32 0, i32 7
  %6 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8, !tbaa !75
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %6, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %1, i32 0, i32 1
  %7 = load i32, i32* %vma_use_count, align 8, !tbaa !77
  %inc = add nsw i32 %7, 1
  store i32 %inc, i32* %vma_use_count, align 8, !tbaa !77
  %ps5 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %1, i32 0, i32 7
  %8 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps5, align 8, !tbaa !75
  %lock6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %8, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock6, i64 %call2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @usbdev_vm_close(%struct.vm_area_struct* %vma) #0 {
entry:
  %vm_private_data = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %vma, i32 0, i32 15
  %0 = load i8*, i8** %vm_private_data, align 8, !tbaa !80
  %1 = bitcast i8* %0 to %struct.usb_memory*
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %1, i32 0, i32 1
  call void @dec_usb_memory_use_count(%struct.usb_memory* %1, i32* %vma_use_count)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @imajor(%struct.inode* %inode) #3 {
entry:
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %0 = load i32, i32* %i_rdev, align 4, !tbaa !81
  %shr = lshr i32 %0, 20
  ret i32 %shr
}

; Function Attrs: nounwind uwtable
define internal %struct.usb_device* @usbdev_lookup_by_devt(i32 %devt) #0 {
entry:
  %conv = zext i32 %devt to i64
  %0 = inttoptr i64 %conv to i8*
  %call = call %struct.device* @bus_find_device(%struct.bus_type* @usb_bus_type, %struct.device* null, i8* %0, i32 (%struct.device*, i8*)* @match_devt)
  %tobool = icmp ne %struct.device* %call, null
  %1 = bitcast %struct.device* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -152
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  %retval.0 = select i1 %tobool, %struct.usb_device* %2, %struct.usb_device* null
  ret %struct.usb_device* %retval.0
}

declare i32 @usb_autoresume_device(%struct.usb_device*) #1

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

declare void @usb_put_dev(%struct.usb_device*) #1

declare %struct.device* @bus_find_device(%struct.bus_type*, %struct.device*, i8*, i32 (%struct.device*, i8*)*) #1

; Function Attrs: nounwind uwtable
define internal i32 @match_devt(%struct.device* %dev, i8* %data) #0 {
entry:
  %devt = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 26
  %0 = load i32, i32* %devt, align 8, !tbaa !354
  %1 = ptrtoint i8* %data to i64
  %conv = trunc i64 %1 to i32
  %cmp = icmp eq i32 %0, %conv
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare void @usb_hub_release_all_ports(%struct.usb_device*, %struct.usb_dev_state*) #1

; Function Attrs: nounwind uwtable
define internal void @destroy_all_async(%struct.usb_dev_state* %ps) #0 {
entry:
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %ps, i32 0, i32 4
  call void @destroy_async(%struct.usb_dev_state* %ps, %struct.list_head* %async_pending)
  ret void
}

declare void @usb_autosuspend_device(%struct.usb_device*) #1

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_notify(%struct.notifier_block* %self, i64 %action, i8* %dev) #0 {
entry:
  %cond = icmp eq i64 %action, 2
  br i1 %cond, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %entry
  %0 = bitcast i8* %dev to %struct.usb_device*
  call void @usbdev_remove(%struct.usb_device* %0)
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %sw.bb
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @usbdev_remove(%struct.usb_device* %udev) #0 {
entry:
  %sinfo = alloca %struct.siginfo, align 8
  %0 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %0) #7
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 27
  %call = call i32 @list_empty(%struct.list_head* %filelist)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %filelist1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 27
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %filelist1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !355
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.usb_dev_state*
  call void @destroy_all_async(%struct.usb_dev_state* %3)
  %wait = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 7
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 0, i8* null)
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %list)
  %discsignr = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 8
  %4 = load i32, i32* %discsignr, align 8, !tbaa !200
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %5 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.memset.p0i8.i64(i8* %5, i8 0, i64 128, i32 8, i1 false)
  %discsignr3 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 8
  %6 = load i32, i32* %discsignr3, align 8, !tbaa !200
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %6, i32* %si_signo, align 8, !tbaa !314
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 32, i32* %si_errno, align 4, !tbaa !316
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8, !tbaa !317
  %disccontext = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 11
  %7 = load i8*, i8** %disccontext, align 8, !tbaa !202
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.13* %_sifields to %struct.anon.18*
  %_addr = getelementptr inbounds %struct.anon.18, %struct.anon.18* %_sigfault, i32 0, i32 0
  store i8* %7, i8** %_addr, align 8, !tbaa !139
  %discsignr4 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 8
  %8 = load i32, i32* %discsignr4, align 8, !tbaa !200
  %disc_pid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 9
  %9 = load %struct.pid*, %struct.pid** %disc_pid, align 8, !tbaa !95
  %cred = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 10
  %10 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !129
  %secid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 13
  %11 = load i32, i32* %secid, align 8, !tbaa !356
  %call5 = call i32 @kill_pid_info_as_cred(i32 %8, %struct.siginfo* %sinfo, %struct.pid* %9, %struct.cred* %10, i32 %11)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %12 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %12) #7
  ret void
}

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 0}
!3 = !{!"usb_interface", !4, i64 0, !4, i64 8, !7, i64 16, !4, i64 24, !7, i64 32, !5, i64 36, !7, i64 40, !7, i64 40, !7, i64 40, !7, i64 40, !7, i64 40, !7, i64 40, !7, i64 40, !7, i64 40, !8, i64 48, !4, i64 776, !13, i64 784, !27, i64 792}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"int", !5, i64 0}
!8 = !{!"device", !4, i64 0, !4, i64 8, !9, i64 16, !4, i64 80, !4, i64 88, !14, i64 96, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !19, i64 160, !20, i64 200, !4, i64 488, !4, i64 496, !10, i64 504, !7, i64 520, !4, i64 528, !4, i64 536, !28, i64 544, !16, i64 552, !4, i64 560, !10, i64 568, !4, i64 584, !29, i64 592, !4, i64 600, !4, i64 608, !7, i64 616, !7, i64 620, !17, i64 624, !10, i64 632, !30, i64 648, !4, i64 680, !4, i64 688, !4, i64 696, !4, i64 704, !4, i64 712, !22, i64 720, !22, i64 720}
!9 = !{!"kobject", !4, i64 0, !10, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !11, i64 56, !7, i64 60, !7, i64 60, !7, i64 60, !7, i64 60, !7, i64 60}
!10 = !{!"list_head", !4, i64 0, !4, i64 8}
!11 = !{!"kref", !12, i64 0}
!12 = !{!"refcount_struct", !13, i64 0}
!13 = !{!"", !7, i64 0}
!14 = !{!"mutex", !15, i64 0, !17, i64 8, !18, i64 12, !10, i64 16}
!15 = !{!"", !16, i64 0}
!16 = !{!"long", !5, i64 0}
!17 = !{!"spinlock", !5, i64 0}
!18 = !{!"optimistic_spin_queue", !13, i64 0}
!19 = !{!"dev_links_info", !10, i64 0, !10, i64 16, !5, i64 32}
!20 = !{!"dev_pm_info", !21, i64 0, !7, i64 4, !7, i64 4, !22, i64 4, !22, i64 4, !22, i64 4, !22, i64 4, !22, i64 4, !22, i64 4, !22, i64 5, !17, i64 8, !10, i64 16, !23, i64 32, !4, i64 64, !22, i64 72, !22, i64 72, !22, i64 72, !25, i64 80, !16, i64 128, !27, i64 136, !24, i64 168, !4, i64 192, !13, i64 200, !13, i64 204, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !22, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 212, !5, i64 216, !5, i64 220, !7, i64 224, !7, i64 228, !16, i64 232, !16, i64 240, !16, i64 248, !16, i64 256, !4, i64 264, !4, i64 272, !4, i64 280}
!21 = !{!"pm_message", !7, i64 0}
!22 = !{!"_Bool", !5, i64 0}
!23 = !{!"completion", !7, i64 0, !24, i64 8}
!24 = !{!"__wait_queue_head", !17, i64 0, !10, i64 8}
!25 = !{!"timer_list", !26, i64 0, !16, i64 16, !4, i64 24, !16, i64 32, !7, i64 40}
!26 = !{!"hlist_node", !4, i64 0, !4, i64 8}
!27 = !{!"work_struct", !15, i64 0, !10, i64 8, !4, i64 24}
!28 = !{!"long long", !5, i64 0}
!29 = !{!"dev_archdata", !4, i64 0}
!30 = !{!"klist_node", !4, i64 0, !10, i64 8, !11, i64 24}
!31 = !{!32, !5, i64 2}
!32 = !{!"usb_host_interface", !33, i64 0, !7, i64 12, !4, i64 16, !4, i64 24, !4, i64 32}
!33 = !{!"usb_interface_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !5, i64 8}
!34 = !{!35, !4, i64 200}
!35 = !{!"file", !5, i64 0, !36, i64 16, !4, i64 32, !4, i64 40, !17, i64 48, !15, i64 56, !7, i64 64, !7, i64 68, !14, i64 72, !28, i64 104, !37, i64 112, !4, i64 144, !41, i64 152, !28, i64 184, !4, i64 192, !4, i64 200, !10, i64 208, !10, i64 224, !4, i64 240}
!36 = !{!"path", !4, i64 0, !4, i64 8}
!37 = !{!"fown_struct", !38, i64 0, !4, i64 8, !5, i64 16, !13, i64 20, !13, i64 24, !7, i64 28}
!38 = !{!"", !39, i64 0}
!39 = !{!"qrwlock", !13, i64 0, !40, i64 4}
!40 = !{!"qspinlock", !13, i64 0}
!41 = !{!"file_ra_state", !16, i64 0, !7, i64 8, !7, i64 12, !7, i64 16, !7, i64 20, !28, i64 24}
!42 = !{!43, !4, i64 16}
!43 = !{!"usb_dev_state", !10, i64 0, !4, i64 16, !4, i64 24, !17, i64 32, !10, i64 40, !10, i64 56, !10, i64 72, !24, i64 88, !7, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !16, i64 144, !7, i64 152, !7, i64 156, !22, i64 160, !16, i64 168}
!44 = !{!28, !28, i64 0}
!45 = !{!46, !5, i64 897}
!46 = !{!"usb_device", !7, i64 0, !5, i64 4, !7, i64 20, !5, i64 24, !5, i64 28, !4, i64 32, !7, i64 40, !5, i64 44, !4, i64 56, !4, i64 64, !47, i64 72, !8, i64 152, !52, i64 880, !4, i64 904, !4, i64 912, !4, i64 920, !5, i64 928, !5, i64 1056, !4, i64 1184, !49, i64 1192, !5, i64 1194, !5, i64 1195, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1197, !7, i64 1197, !7, i64 1197, !7, i64 1197, !7, i64 1197, !7, i64 1200, !4, i64 1208, !4, i64 1216, !4, i64 1224, !10, i64 1232, !7, i64 1248, !7, i64 1252, !13, i64 1256, !16, i64 1264, !16, i64 1272, !7, i64 1280, !7, i64 1280, !7, i64 1280, !4, i64 1288, !7, i64 1296, !5, i64 1300, !53, i64 1304, !54, i64 1312, !54, i64 1328, !7, i64 1344}
!47 = !{!"usb_host_endpoint", !48, i64 0, !50, i64 9, !51, i64 15, !10, i64 24, !4, i64 40, !4, i64 48, !4, i64 56, !7, i64 64, !7, i64 68, !7, i64 72}
!48 = !{!"usb_endpoint_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !49, i64 4, !5, i64 6, !5, i64 7, !5, i64 8}
!49 = !{!"short", !5, i64 0}
!50 = !{!"usb_ss_ep_comp_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !49, i64 4}
!51 = !{!"usb_ssp_isoc_ep_comp_descriptor", !5, i64 0, !5, i64 1, !49, i64 2, !7, i64 4}
!52 = !{!"usb_device_descriptor", !5, i64 0, !5, i64 1, !49, i64 2, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !49, i64 8, !49, i64 10, !49, i64 12, !5, i64 14, !5, i64 15, !5, i64 16, !5, i64 17}
!53 = !{!"usb2_lpm_parameters", !7, i64 0, !7, i64 4}
!54 = !{!"usb3_lpm_parameters", !7, i64 0, !7, i64 4, !7, i64 8, !7, i64 12}
!55 = !{!46, !4, i64 1184}
!56 = !{!4, !4, i64 0}
!57 = !{!58, !49, i64 2}
!58 = !{!"usb_config_descriptor", !5, i64 0, !5, i64 1, !49, i64 2, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !5, i64 8}
!59 = !{!46, !4, i64 912}
!60 = !{!61, !49, i64 2}
!61 = !{!"usb_host_config", !58, i64 0, !4, i64 16, !5, i64 24, !5, i64 152, !5, i64 408, !4, i64 664, !7, i64 672}
!62 = !{!7, !7, i64 0}
!63 = !{!35, !7, i64 68}
!64 = !{!65, !16, i64 8}
!65 = !{!"vm_area_struct", !16, i64 0, !16, i64 8, !4, i64 16, !4, i64 24, !66, i64 32, !16, i64 56, !4, i64 64, !67, i64 72, !16, i64 80, !68, i64 88, !10, i64 120, !4, i64 136, !4, i64 144, !16, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !69, i64 184}
!66 = !{!"rb_node", !16, i64 0, !4, i64 8, !4, i64 16}
!67 = !{!"pgprot", !16, i64 0}
!68 = !{!"", !66, i64 0, !16, i64 24}
!69 = !{!"vm_userfaultfd_ctx"}
!70 = !{!65, !16, i64 0}
!71 = !{!72, !4, i64 32}
!72 = !{!"usb_memory", !10, i64 0, !7, i64 16, !7, i64 20, !7, i64 24, !4, i64 32, !28, i64 40, !16, i64 48, !4, i64 56}
!73 = !{!72, !28, i64 40}
!74 = !{!72, !7, i64 24}
!75 = !{!72, !4, i64 56}
!76 = !{!72, !16, i64 48}
!77 = !{!72, !7, i64 16}
!78 = !{!65, !16, i64 80}
!79 = !{!65, !4, i64 144}
!80 = !{!65, !4, i64 168}
!81 = !{!82, !7, i64 76}
!82 = !{!"inode", !49, i64 0, !49, i64 2, !13, i64 4, !13, i64 8, !7, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !16, i64 64, !5, i64 72, !7, i64 76, !28, i64 80, !83, i64 88, !83, i64 104, !83, i64 120, !17, i64 136, !49, i64 140, !7, i64 144, !16, i64 152, !16, i64 160, !84, i64 168, !16, i64 208, !16, i64 216, !26, i64 224, !10, i64 240, !10, i64 256, !10, i64 272, !10, i64 288, !5, i64 304, !28, i64 320, !13, i64 328, !13, i64 332, !13, i64 336, !4, i64 344, !4, i64 352, !86, i64 360, !10, i64 512, !5, i64 528, !7, i64 536, !7, i64 540, !89, i64 544, !4, i64 552}
!83 = !{!"timespec", !16, i64 0, !16, i64 8}
!84 = !{!"rw_semaphore", !15, i64 0, !10, i64 8, !85, i64 24, !18, i64 28, !4, i64 32}
!85 = !{!"raw_spinlock", !40, i64 0}
!86 = !{!"address_space", !4, i64 0, !87, i64 8, !17, i64 24, !13, i64 28, !88, i64 32, !84, i64 40, !16, i64 80, !16, i64 88, !16, i64 96, !4, i64 104, !16, i64 112, !17, i64 120, !7, i64 124, !10, i64 128, !4, i64 144}
!87 = !{!"radix_tree_root", !7, i64 0, !4, i64 8}
!88 = !{!"rb_root", !4, i64 0}
!89 = !{!"hlist_head", !4, i64 0}
!90 = !{!46, !5, i64 24}
!91 = !{!43, !4, i64 24}
!92 = !{!43, !16, i64 168}
!93 = !{!13, !7, i64 0}
!94 = !{i64 0, i64 4, !62}
!95 = !{!43, !4, i64 120}
!96 = !{!97, !4, i64 1504}
!97 = !{!"task_struct", !98, i64 0, !16, i64 8, !4, i64 16, !13, i64 24, !7, i64 28, !7, i64 32, !99, i64 40, !7, i64 48, !7, i64 52, !7, i64 56, !16, i64 64, !4, i64 72, !7, i64 80, !7, i64 84, !7, i64 88, !7, i64 92, !7, i64 96, !7, i64 100, !4, i64 104, !100, i64 128, !104, i64 576, !4, i64 624, !105, i64 632, !7, i64 784, !7, i64 788, !7, i64 792, !108, i64 800, !109, i64 808, !10, i64 840, !110, i64 856, !66, i64 896, !4, i64 920, !4, i64 928, !111, i64 936, !112, i64 976, !7, i64 996, !7, i64 1000, !7, i64 1004, !7, i64 1008, !16, i64 1016, !7, i64 1024, !7, i64 1028, !7, i64 1028, !7, i64 1028, !7, i64 1028, !7, i64 1032, !7, i64 1032, !7, i64 1032, !7, i64 1032, !7, i64 1032, !16, i64 1040, !113, i64 1048, !7, i64 1096, !7, i64 1100, !4, i64 1104, !4, i64 1112, !10, i64 1120, !10, i64 1136, !4, i64 1152, !10, i64 1160, !10, i64 1176, !5, i64 1192, !10, i64 1264, !10, i64 1280, !4, i64 1296, !4, i64 1304, !4, i64 1312, !28, i64 1320, !28, i64 1328, !28, i64 1336, !114, i64 1344, !16, i64 1368, !16, i64 1376, !28, i64 1384, !28, i64 1392, !16, i64 1400, !16, i64 1408, !115, i64 1416, !5, i64 1440, !4, i64 1488, !4, i64 1496, !4, i64 1504, !5, i64 1512, !4, i64 1528, !116, i64 1536, !117, i64 1544, !4, i64 1560, !4, i64 1568, !4, i64 1576, !4, i64 1584, !4, i64 1592, !118, i64 1600, !118, i64 1608, !118, i64 1616, !119, i64 1624, !16, i64 1648, !16, i64 1656, !7, i64 1664, !4, i64 1672, !4, i64 1680, !13, i64 1688, !7, i64 1692, !120, i64 1696, !7, i64 1712, !7, i64 1716, !17, i64 1720, !85, i64 1724, !121, i64 1728, !88, i64 1736, !4, i64 1744, !4, i64 1752, !4, i64 1760, !4, i64 1768, !4, i64 1776, !4, i64 1784, !4, i64 1792, !4, i64 1800, !16, i64 1808, !4, i64 1816, !122, i64 1824, !28, i64 1880, !28, i64 1888, !28, i64 1896, !118, i64 1904, !123, i64 1912, !7, i64 1916, !7, i64 1920, !4, i64 1928, !10, i64 1936, !4, i64 1952, !4, i64 1960, !10, i64 1968, !4, i64 1984, !5, i64 1992, !14, i64 2008, !10, i64 2040, !4, i64 2056, !49, i64 2064, !49, i64 2066, !124, i64 2072, !125, i64 2088, !4, i64 2104, !126, i64 2112, !4, i64 2128, !7, i64 2136, !7, i64 2140, !16, i64 2144, !28, i64 2152, !28, i64 2160, !16, i64 2168, !16, i64 2176, !7, i64 2184, !4, i64 2192, !4, i64 2200, !13, i64 2208, !127, i64 2240}
!98 = !{!"thread_info", !16, i64 0}
!99 = !{!"llist_node", !4, i64 0}
!100 = !{!"sched_entity", !101, i64 0, !66, i64 16, !10, i64 40, !7, i64 56, !28, i64 64, !28, i64 72, !28, i64 80, !28, i64 88, !28, i64 96, !102, i64 104, !7, i64 320, !4, i64 328, !4, i64 336, !4, i64 344, !103, i64 384}
!101 = !{!"load_weight", !16, i64 0, !7, i64 8}
!102 = !{!"sched_statistics", !28, i64 0, !28, i64 8, !28, i64 16, !28, i64 24, !28, i64 32, !28, i64 40, !28, i64 48, !28, i64 56, !28, i64 64, !28, i64 72, !28, i64 80, !28, i64 88, !28, i64 96, !28, i64 104, !28, i64 112, !28, i64 120, !28, i64 128, !28, i64 136, !28, i64 144, !28, i64 152, !28, i64 160, !28, i64 168, !28, i64 176, !28, i64 184, !28, i64 192, !28, i64 200, !28, i64 208}
!103 = !{!"sched_avg", !28, i64 0, !28, i64 8, !7, i64 16, !7, i64 20, !16, i64 24, !16, i64 32}
!104 = !{!"sched_rt_entity", !10, i64 0, !16, i64 16, !16, i64 24, !7, i64 32, !49, i64 36, !49, i64 38, !4, i64 40}
!105 = !{!"sched_dl_entity", !66, i64 0, !28, i64 24, !28, i64 32, !28, i64 40, !28, i64 48, !28, i64 56, !28, i64 64, !7, i64 72, !7, i64 76, !7, i64 80, !7, i64 84, !106, i64 88}
!106 = !{!"hrtimer", !107, i64 0, !28, i64 32, !4, i64 40, !4, i64 48, !5, i64 56, !5, i64 57}
!107 = !{!"timerqueue_node", !66, i64 0, !28, i64 24}
!108 = !{!"cpumask", !5, i64 0}
!109 = !{!"sched_info", !16, i64 0, !28, i64 8, !28, i64 16, !28, i64 24}
!110 = !{!"plist_node", !7, i64 0, !10, i64 8, !10, i64 24}
!111 = !{!"vmacache", !7, i64 0, !5, i64 8}
!112 = !{!"task_rss_stat", !7, i64 0, !5, i64 4}
!113 = !{!"restart_block", !4, i64 0, !5, i64 8}
!114 = !{!"prev_cputime", !28, i64 0, !28, i64 8, !85, i64 16}
!115 = !{!"task_cputime", !28, i64 0, !28, i64 8, !28, i64 16}
!116 = !{!"sysv_sem", !4, i64 0}
!117 = !{!"sysv_shm", !10, i64 0}
!118 = !{!"", !5, i64 0}
!119 = !{!"sigpending", !10, i64 0, !118, i64 16}
!120 = !{!"seccomp", !7, i64 0, !4, i64 8}
!121 = !{!"wake_q_node", !4, i64 0}
!122 = !{!"task_io_accounting", !28, i64 0, !28, i64 8, !28, i64 16, !28, i64 24, !28, i64 32, !28, i64 40, !28, i64 48}
!123 = !{!"seqcount", !7, i64 0}
!124 = !{!"tlbflush_unmap_batch", !108, i64 0, !22, i64 8, !22, i64 9}
!125 = !{!"callback_head", !4, i64 0, !4, i64 8}
!126 = !{!"page_frag", !4, i64 0, !7, i64 8, !7, i64 12}
!127 = !{!"thread_struct", !5, i64 0, !16, i64 24, !16, i64 32, !49, i64 40, !49, i64 42, !49, i64 44, !49, i64 46, !7, i64 48, !16, i64 56, !16, i64 64, !5, i64 72, !16, i64 104, !16, i64 112, !16, i64 120, !16, i64 128, !16, i64 136, !4, i64 144, !16, i64 152, !7, i64 160, !15, i64 168, !7, i64 176, !7, i64 176, !128, i64 192}
!128 = !{!"fpu", !7, i64 0, !5, i64 4, !5, i64 5, !5, i64 64}
!129 = !{!43, !4, i64 128}
!130 = !{i32 -2142951940}
!131 = !{!22, !22, i64 0}
!132 = !{i8 0, i8 2}
!133 = !{!43, !16, i64 144}
!134 = !{i32 -2147034058, i32 -2147034019, i32 -2147033998, i32 -2147033961, i32 -2147033938, i32 -2147034068}
!135 = !{!10, !4, i64 0}
!136 = !{!137, !7, i64 44}
!137 = !{!"async", !10, i64 0, !4, i64 16, !4, i64 24, !4, i64 32, !7, i64 40, !7, i64 44, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !7, i64 80, !7, i64 84, !7, i64 88, !5, i64 92, !5, i64 93}
!138 = !{!8, !4, i64 152}
!139 = !{!5, !5, i64 0}
!140 = !{!10, !4, i64 8}
!141 = !{!137, !4, i64 64}
!142 = !{!49, !49, i64 0}
!143 = !{i32 -2147194064}
!144 = !{i32 -2147194026}
!145 = !{i32 -2147194801}
!146 = !{i32 -2147194763}
!147 = !{!148, !4, i64 0}
!148 = !{!"poll_table_struct", !4, i64 0, !16, i64 8}
!149 = !{i64 0, i64 8, !150, i64 8, i64 8, !150}
!150 = !{!16, !16, i64 0}
!151 = !{!35, !4, i64 32}
!152 = !{!137, !4, i64 56}
!153 = !{!154, !5, i64 0}
!154 = !{!"usbdevfs_ctrltransfer", !5, i64 0, !5, i64 1, !49, i64 2, !49, i64 4, !49, i64 6, !7, i64 8, !4, i64 16}
!155 = !{!154, !5, i64 1}
!156 = !{!154, !49, i64 4}
!157 = !{!154, !49, i64 6}
!158 = !{!154, !7, i64 8}
!159 = !{!154, !49, i64 2}
!160 = !{!154, !4, i64 16}
!161 = !{!97, !16, i64 2408}
!162 = !{!163, !7, i64 0}
!163 = !{!"usbdevfs_bulktransfer", !7, i64 0, !7, i64 4, !7, i64 8, !4, i64 16}
!164 = !{!163, !7, i64 4}
!165 = !{!163, !7, i64 8}
!166 = !{!163, !4, i64 16}
!167 = !{i32 -2142939745}
!168 = !{!46, !4, i64 920}
!169 = !{!43, !22, i64 160}
!170 = !{!61, !5, i64 4}
!171 = !{!3, !4, i64 8}
!172 = !{!3, !4, i64 184}
!173 = !{!174, !4, i64 0}
!174 = !{!"device_driver", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !22, i64 32, !5, i64 36, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112}
!175 = !{i32 -2142938891}
!176 = !{!177, !7, i64 0}
!177 = !{!"usbdevfs_getdriver", !7, i64 0, !5, i64 4}
!178 = !{!46, !7, i64 0}
!179 = !{!180, !7, i64 0}
!180 = !{!"usbdevfs_connectinfo", !7, i64 0, !5, i64 4}
!181 = !{!46, !5, i64 28}
!182 = !{!180, !5, i64 4}
!183 = !{!184, !7, i64 0}
!184 = !{!"usbdevfs_setinterface", !7, i64 0, !7, i64 4}
!185 = !{!184, !7, i64 4}
!186 = !{i32 -2142937683}
!187 = !{!61, !5, i64 5}
!188 = !{i32 -2142917247}
!189 = !{i32 -2142915439}
!190 = !{i32 -2142914941}
!191 = !{i32 -2142913403}
!192 = !{i32 -2142912708}
!193 = !{i32 -2142911152}
!194 = !{i32 -2142910450}
!195 = !{i32 -2142908822}
!196 = !{i32 -2142908092}
!197 = !{i32 -2142906286}
!198 = !{!199, !7, i64 0}
!199 = !{!"usbdevfs_disconnectsignal32", !7, i64 0, !7, i64 4}
!200 = !{!43, !7, i64 112}
!201 = !{!199, !7, i64 4}
!202 = !{!43, !4, i64 136}
!203 = !{i32 -2142827883, i32 -2142827863, i32 -2142827822, i32 -2142827801, i32 -2142827762, i32 -2142827733, i32 -2142827687, i32 -2142827662, i32 -2142827390, i32 -2142827346, i32 -2142827323, i32 -2142827290, i32 -2142827259, i32 -2142827203}
!204 = !{!205, !7, i64 0}
!205 = !{!"usbdevfs_ioctl", !7, i64 0, !7, i64 4, !4, i64 8}
!206 = !{i32 -2142823052, i32 -2142823032, i32 -2142822991, i32 -2142822970, i32 -2142822931, i32 -2142822902, i32 -2142822856, i32 -2142822831, i32 -2142822553, i32 -2142822509, i32 -2142822486, i32 -2142822453, i32 -2142822422, i32 -2142822366}
!207 = !{!205, !7, i64 4}
!208 = !{i32 -2142818313, i32 -2142818293, i32 -2142818252, i32 -2142818231, i32 -2142818192, i32 -2142818163, i32 -2142818117, i32 -2142818092, i32 -2142817820, i32 -2142817776, i32 -2142817753, i32 -2142817720, i32 -2142817689, i32 -2142817633}
!209 = !{!205, !4, i64 8}
!210 = !{!211, !7, i64 0}
!211 = !{!"usbdevfs_disconnectsignal", !7, i64 0, !4, i64 8}
!212 = !{!211, !4, i64 8}
!213 = !{i32 -2142835473}
!214 = !{i32 -2142834616}
!215 = !{i32 -2142816378}
!216 = !{i32 -2142815201}
!217 = !{!46, !4, i64 64}
!218 = !{!219, !7, i64 28}
!219 = !{!"usb_bus", !4, i64 0, !7, i64 8, !4, i64 16, !5, i64 24, !5, i64 25, !5, i64 26, !7, i64 27, !7, i64 27, !7, i64 27, !7, i64 27, !7, i64 28, !7, i64 32, !14, i64 40, !220, i64 72, !4, i64 88, !4, i64 96, !7, i64 104, !7, i64 108, !7, i64 112, !7, i64 116, !4, i64 120, !7, i64 128}
!220 = !{!"usb_devmap", !5, i64 0}
!221 = !{i32 -2142813370}
!222 = !{!223, !7, i64 0}
!223 = !{!"usbdevfs_disconnect_claim", !7, i64 0, !7, i64 4, !5, i64 8}
!224 = !{!223, !7, i64 4}
!225 = !{!226, !7, i64 0}
!226 = !{!"__wait_queue", !7, i64 0, !4, i64 8, !4, i64 16, !10, i64 24}
!227 = !{!226, !4, i64 8}
!228 = !{!226, !4, i64 16}
!229 = !{!97, !16, i64 8}
!230 = !{i32 -2142917916}
!231 = !{!137, !4, i64 48}
!232 = !{!233, !7, i64 140}
!233 = !{!"urb", !11, i64 0, !4, i64 8, !13, i64 16, !13, i64 20, !7, i64 24, !10, i64 32, !10, i64 48, !4, i64 64, !4, i64 72, !4, i64 80, !7, i64 88, !7, i64 92, !7, i64 96, !7, i64 100, !4, i64 104, !28, i64 112, !4, i64 120, !7, i64 128, !7, i64 132, !7, i64 136, !7, i64 140, !4, i64 144, !28, i64 152, !7, i64 160, !7, i64 164, !7, i64 168, !7, i64 172, !4, i64 176, !4, i64 184, !5, i64 192}
!234 = !{!137, !7, i64 84}
!235 = !{i32 -2142929871}
!236 = !{i32 -2142928089}
!237 = !{!233, !7, i64 172}
!238 = !{i32 -2142926284}
!239 = !{!233, !4, i64 80}
!240 = !{!233, !7, i64 164}
!241 = !{!242, !7, i64 8}
!242 = !{!"usb_iso_packet_descriptor", !7, i64 0, !7, i64 4, !7, i64 8, !7, i64 12}
!243 = !{i32 -2142924233}
!244 = !{!242, !7, i64 12}
!245 = !{i32 -2142922133}
!246 = !{i32 -2142919920}
!247 = !{!137, !4, i64 24}
!248 = !{!137, !4, i64 32}
!249 = !{!233, !7, i64 132}
!250 = !{!233, !4, i64 120}
!251 = !{!137, !4, i64 72}
!252 = !{!233, !4, i64 104}
!253 = !{!233, !4, i64 144}
!254 = !{!137, !7, i64 80}
!255 = !{i32 -2146798038}
!256 = !{!43, !4, i64 56}
!257 = !{!233, !7, i64 136}
!258 = !{!48, !5, i64 3}
!259 = !{!260, !7, i64 8}
!260 = !{!"scatterlist", !16, i64 0, !7, i64 8, !7, i64 12, !28, i64 16, !7, i64 24}
!261 = !{!260, !16, i64 0}
!262 = !{!72, !7, i64 20}
!263 = !{i32 -2146533297, i32 -2146533258, i32 -2146533237, i32 -2146533200, i32 -2146533177, i32 -2146533168, i32 -2146533124}
!264 = !{i32 -2146511518, i32 -2146511479, i32 -2146511458, i32 -2146511421, i32 -2146511398, i32 -2146511528}
!265 = !{i32 418402, i32 418413, i32 -2147024744}
!266 = !{i32 -2142846246}
!267 = !{i32 -2142844461}
!268 = !{i32 -2142842653}
!269 = !{i32 -2142840599}
!270 = !{i32 -2142838496}
!271 = !{i32 -2142836656}
!272 = !{!32, !5, i64 5}
!273 = !{!3, !7, i64 16}
!274 = !{!32, !5, i64 4}
!275 = !{!32, !4, i64 24}
!276 = !{!48, !5, i64 2}
!277 = !{!97, !7, i64 1096}
!278 = !{i32 -2147034804, i32 -2147034765, i32 -2147034744, i32 -2147034707, i32 -2147034684, i32 -2147034814}
!279 = !{i32 -2146511730, i32 -2146511691, i32 -2146511670, i32 -2146511633, i32 -2146511610, i32 -2146511740}
!280 = !{!48, !49, i64 4}
!281 = !{!282, !7, i64 8}
!282 = !{!"usbdevfs_urb", !5, i64 0, !5, i64 1, !7, i64 4, !7, i64 8, !4, i64 16, !7, i64 24, !7, i64 28, !7, i64 32, !5, i64 36, !7, i64 40, !7, i64 44, !4, i64 48, !5, i64 56}
!283 = !{!282, !7, i64 24}
!284 = !{!282, !4, i64 16}
!285 = !{!282, !5, i64 0}
!286 = !{!282, !5, i64 1}
!287 = !{!288, !5, i64 0}
!288 = !{!"usb_ctrlrequest", !5, i64 0, !5, i64 1, !49, i64 2, !49, i64 4, !49, i64 6}
!289 = !{!288, !5, i64 1}
!290 = !{!47, !7, i64 72}
!291 = !{!292, !7, i64 0}
!292 = !{!"usbdevfs_iso_packet_desc", !7, i64 0, !7, i64 4, !7, i64 8}
!293 = !{!233, !4, i64 72}
!294 = !{!233, !7, i64 88}
!295 = !{!233, !7, i64 100}
!296 = !{!282, !7, i64 32}
!297 = !{!233, !7, i64 160}
!298 = !{!233, !7, i64 92}
!299 = !{!47, !5, i64 6}
!300 = !{!233, !7, i64 168}
!301 = !{!233, !4, i64 176}
!302 = !{!233, !4, i64 184}
!303 = !{!242, !7, i64 0}
!304 = !{!242, !7, i64 4}
!305 = !{!137, !4, i64 16}
!306 = !{!233, !28, i64 112}
!307 = !{!282, !7, i64 44}
!308 = !{!137, !7, i64 40}
!309 = !{!47, !5, i64 2}
!310 = !{!137, !5, i64 92}
!311 = !{!137, !5, i64 93}
!312 = !{!43, !7, i64 156}
!313 = !{!233, !7, i64 96}
!314 = !{!315, !7, i64 0}
!315 = !{!"siginfo", !7, i64 0, !7, i64 4, !7, i64 8, !5, i64 16}
!316 = !{!315, !7, i64 4}
!317 = !{!315, !7, i64 8}
!318 = !{!137, !7, i64 88}
!319 = !{!320, !4, i64 16}
!320 = !{!"pid_link", !26, i64 0, !4, i64 16}
!321 = !{!260, !7, i64 12}
!322 = !{i32 -2143496087, i32 -2143496062, i32 -2143495792, i32 -2143495995, i32 -2143495964, i32 -2143495934}
!323 = !{i32 -2146253831}
!324 = !{i32 -2146281806}
!325 = !{i32 -2146534299, i32 -2146534260, i32 -2146534239, i32 -2146534202, i32 -2146534179, i32 -2146534309}
!326 = !{i32 -2146253004}
!327 = !{i32 1113471}
!328 = !{i32 -2142904115, i32 -2142904095, i32 -2142904054, i32 -2142904033, i32 -2142903994, i32 -2142903965, i32 -2142903919, i32 -2142903894, i32 -2142903622, i32 -2142903578, i32 -2142903555, i32 -2142903522, i32 -2142903491, i32 -2142903435}
!329 = !{i32 -2142899336, i32 -2142899316, i32 -2142899275, i32 -2142899254, i32 -2142899215, i32 -2142899186, i32 -2142899140, i32 -2142899115, i32 -2142898839, i32 -2142898795, i32 -2142898772, i32 -2142898739, i32 -2142898708, i32 -2142898652}
!330 = !{i32 -2142892901, i32 -2142892881, i32 -2142892840, i32 -2142892819, i32 -2142892780, i32 -2142892751, i32 -2142892705, i32 -2142892680, i32 -2142892406, i32 -2142892362, i32 -2142892339, i32 -2142892306, i32 -2142892275, i32 -2142892219}
!331 = !{!282, !7, i64 4}
!332 = !{i32 -2142888153, i32 -2142888133, i32 -2142888092, i32 -2142888071, i32 -2142888032, i32 -2142888003, i32 -2142887957, i32 -2142887932, i32 -2142887659, i32 -2142887615, i32 -2142887592, i32 -2142887559, i32 -2142887528, i32 -2142887472}
!333 = !{i32 -2142883258, i32 -2142883238, i32 -2142883197, i32 -2142883176, i32 -2142883137, i32 -2142883108, i32 -2142883062, i32 -2142883037, i32 -2142882756, i32 -2142882712, i32 -2142882689, i32 -2142882656, i32 -2142882625, i32 -2142882569}
!334 = !{i32 -2142878323, i32 -2142878303, i32 -2142878262, i32 -2142878241, i32 -2142878202, i32 -2142878173, i32 -2142878127, i32 -2142878102, i32 -2142877821, i32 -2142877777, i32 -2142877754, i32 -2142877721, i32 -2142877690, i32 -2142877634}
!335 = !{!282, !7, i64 28}
!336 = !{i32 -2142873426, i32 -2142873406, i32 -2142873365, i32 -2142873344, i32 -2142873305, i32 -2142873276, i32 -2142873230, i32 -2142873205, i32 -2142872926, i32 -2142872882, i32 -2142872859, i32 -2142872826, i32 -2142872795, i32 -2142872739}
!337 = !{i32 -2142868425, i32 -2142868405, i32 -2142868364, i32 -2142868343, i32 -2142868304, i32 -2142868275, i32 -2142868229, i32 -2142868204, i32 -2142867919, i32 -2142867875, i32 -2142867852, i32 -2142867819, i32 -2142867788, i32 -2142867732}
!338 = !{i32 -2142863508, i32 -2142863488, i32 -2142863447, i32 -2142863426, i32 -2142863387, i32 -2142863358, i32 -2142863312, i32 -2142863287, i32 -2142863008, i32 -2142862964, i32 -2142862941, i32 -2142862908, i32 -2142862877, i32 -2142862821}
!339 = !{!282, !7, i64 40}
!340 = !{i32 -2142858735, i32 -2142858715, i32 -2142858674, i32 -2142858653, i32 -2142858614, i32 -2142858585, i32 -2142858539, i32 -2142858514, i32 -2142858241, i32 -2142858197, i32 -2142858174, i32 -2142858141, i32 -2142858110, i32 -2142858054}
!341 = !{i32 -2142853986, i32 -2142853966, i32 -2142853925, i32 -2142853904, i32 -2142853865, i32 -2142853836, i32 -2142853790, i32 -2142853765, i32 -2142853491, i32 -2142853447, i32 -2142853424, i32 -2142853391, i32 -2142853360, i32 -2142853304}
!342 = !{i32 -2142849147, i32 -2142849127, i32 -2142849086, i32 -2142849065, i32 -2142849026, i32 -2142848997, i32 -2142848951, i32 -2142848926, i32 -2142848647, i32 -2142848603, i32 -2142848580, i32 -2142848547, i32 -2142848516, i32 -2142848460}
!343 = !{!282, !4, i64 48}
!344 = !{i32 -2144291488, i32 -2144291481, i32 -2144291465, i32 -2144291449, i32 -2144291160, i32 -2144291813, i32 -2144291154, i32 -2144291106, i32 -2144291042, i32 -2144290980, i32 -2144290923, i32 -2144290867, i32 -2144291733, i32 -2144291708, i32 -2144290539, i32 -2144290612, i32 -2144290525, i32 -2144290571}
!345 = !{i32 -2144293118, i32 -2144293111, i32 -2144293095, i32 -2144293079, i32 -2144292790, i32 -2144293443, i32 -2144292784, i32 -2144292736, i32 -2144292672, i32 -2144292610, i32 -2144292553, i32 -2144292497, i32 -2144293363, i32 -2144293338, i32 -2144292169, i32 -2144292242, i32 -2144292155, i32 -2144292201}
!346 = !{!347, !4, i64 24}
!347 = !{!"usb_driver", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !348, i64 80, !349, i64 104, !7, i64 232, !7, i64 232, !7, i64 232, !7, i64 232}
!348 = !{!"usb_dynids", !17, i64 0, !10, i64 8}
!349 = !{!"usbdrv_wrap", !174, i64 0, !7, i64 120}
!350 = !{i32 -2147026484, i32 -2147026445, i32 -2147026424, i32 -2147026387, i32 -2147026364, i32 -2147026355, i32 -2147026301}
!351 = !{i32 -2142956074}
!352 = !{i32 -2142955244}
!353 = !{i32 -2142954239}
!354 = !{!8, !7, i64 616}
!355 = !{!46, !4, i64 1232}
!356 = !{!43, !7, i64 152}
