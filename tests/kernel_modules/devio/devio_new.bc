; ModuleID = 'drivers/usb/core/devio.bc'
source_filename = "drivers/usb/core/devio.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.atomic64_t = type { i64 }
%struct.spinlock = type { %union.anon }
%union.anon = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, [12 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon.0, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon.0 = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.49, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, [56 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.4, i32 }
%union.anon.4 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.5, %union.anon.33, %union.anon.34, %union.anon.38, %union.anon.41, [8 x i8] }
%union.anon.5 = type { %struct.address_space* }
%union.anon.33 = type { i64 }
%union.anon.34 = type { i64 }
%union.anon.38 = type { %struct.list_head }
%union.anon.41 = type { i64 }
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.mem_cgroup = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct* }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, i32, %struct.task_struct*, %struct.vm_struct*, %struct.atomic_t, [28 x i8], %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.6, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon.6 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type {}
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type {}
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.7 }
%union.anon.7 = type { %struct.anon.8 }
%struct.anon.8 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.cgroup_namespace* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.cgroup_namespace = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, %struct.pid*, i32, %struct.tty_struct*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, %struct.tty_audit_buf*, i8, i16, i16, %struct.mm_struct*, %struct.mutex }
%struct.cpu_itimer = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic, i8, i8 }
%struct.task_cputime_atomic = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.tty_struct = type opaque
%struct.seqlock_t = type { %struct.seqcount, %struct.spinlock }
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.13 }
%union.anon.13 = type { %struct.anon.17, [80 x i8] }
%struct.anon.17 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.compat_robust_list, i32, i32 }
%struct.compat_robust_list = type { i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.vm_struct = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.23 }
%union.anon.23 = type { %struct.anon.24 }
%struct.anon.24 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.26, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.29 }
%union.anon.26 = type { %struct.anon.27 }
%struct.anon.27 = type { i64, i64 }
%union.anon.29 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, %struct.kuid_t, %struct.kgid_t, %struct.ns_common, i64, %struct.work_struct, %struct.ctl_table_set, %struct.ctl_table_header*, %struct.ucounts*, [9 x i32] }
%struct.uid_gid_map = type { i32, [5 x %struct.uid_gid_extent] }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.kgid_t = type { i32 }
%struct.ns_common = type { %struct.atomic64_t, %struct.proc_ns_operations*, i32 }
%struct.proc_ns_operations = type opaque
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.11, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node*, %struct.list_head }
%union.anon.11 = type { %struct.anon.12 }
%struct.anon.12 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.__wait_queue_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*)*, void (%struct.ctl_table_header*, %struct.ctl_table*, %struct.kuid_t*, %struct.kgid_t*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.ucounts = type { %struct.hlist_node, %struct.user_namespace*, %struct.kuid_t, i32, [9 x %struct.atomic_t] }
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, [32 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%union.anon.49 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.42, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.43, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.42 = type { i32 }
%struct.timespec = type { i64, i64 }
%union.anon.43 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.1, [64 x i8*], [3 x [1 x i64]] }
%union.anon.1 = type { %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type { i32, i64, i64, %union.anon.30, %union.anon.31 }
%union.anon.30 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%union.anon.31 = type { i64 }
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.53, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.53 = type { i64 }
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, i64, %struct.atomic64_t, %struct.key*, %struct.key*, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %struct.pmd_t*, %struct.pud_t*, %struct.pte_t, %struct.page*, %struct.mem_cgroup*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%struct.pte_t = type { i64 }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%union.anon.51 = type { i8* }
%struct.usb_driver = type { i8*, i32 (%struct.usb_interface*, %struct.usb_device_id*)*, void (%struct.usb_interface*)*, i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, %struct.usb_device_id*, %struct.usb_dynids, %struct.usbdrv_wrap, i8 }
%struct.usb_interface = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device, %struct.device*, %struct.atomic_t, %struct.work_struct }
%struct.usb_host_interface = type { %struct.usb_interface_descriptor, i32, i8*, %struct.usb_host_endpoint*, i8* }
%struct.usb_interface_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.usb_host_endpoint = type <{ %struct.usb_endpoint_descriptor, %struct.usb_ss_ep_comp_descriptor, %struct.usb_ssp_isoc_ep_comp_descriptor, i8, %struct.list_head, i8*, %struct.ep_device*, i8*, i32, i32, i32, [4 x i8] }>
%struct.usb_endpoint_descriptor = type <{ i8, i8, i8, i8, i16, i8, i8, i8 }>
%struct.usb_ss_ep_comp_descriptor = type { i8, i8, i8, i8, i16 }
%struct.usb_ssp_isoc_ep_comp_descriptor = type { i8, i8, i16, i32 }
%struct.ep_device = type opaque
%struct.usb_interface_assoc_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type opaque
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.usb_device_id = type { i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8, i64 }
%struct.usb_dynids = type { %struct.spinlock, %struct.list_head }
%struct.usbdrv_wrap = type { %struct.device_driver, i32 }
%struct.cdev = type { %struct.kobject, %struct.module*, %struct.file_operations*, %struct.list_head, i32, i32 }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.usb_dev_state = type { %struct.list_head, %struct.usb_device*, %struct.file*, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head, %struct.__wait_queue_head, i32, %struct.pid*, %struct.cred*, i8*, i64, i32, i32, i8, i64 }
%struct.usb_device = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt*, i32, [2 x i32], %struct.usb_device*, %struct.usb_bus*, %struct.usb_host_endpoint, %struct.device, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config*, %struct.usb_host_config*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %struct.atomic_t, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.usb2_lpm_parameters, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_tt = type { %struct.usb_device*, i32, i32, i8*, %struct.spinlock, %struct.list_head, %struct.work_struct }
%struct.usb_bus = type { %struct.device*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.mutex, %struct.usb_devmap, %struct.usb_device*, %struct.usb_bus*, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_devmap = type { [2 x i64] }
%struct.mon_bus = type opaque
%struct.usb_device_descriptor = type { i8, i8, i16, i8, i8, i8, i8, i16, i16, i16, i8, i8, i8, i8 }
%struct.usb_host_bos = type { %struct.usb_bos_descriptor*, %struct.usb_ext_cap_descriptor*, %struct.usb_ss_cap_descriptor*, %struct.usb_ssp_cap_descriptor*, %struct.usb_ss_container_id_descriptor*, %struct.usb_ptm_cap_descriptor* }
%struct.usb_bos_descriptor = type <{ i8, i8, i16, i8 }>
%struct.usb_ext_cap_descriptor = type <{ i8, i8, i8, i32 }>
%struct.usb_ss_cap_descriptor = type { i8, i8, i8, i8, i16, i8, i8, i16 }
%struct.usb_ssp_cap_descriptor = type { i8, i8, i8, i8, i32, i16, i16, [1 x i32] }
%struct.usb_ss_container_id_descriptor = type { i8, i8, i8, i8, [16 x i8] }
%struct.usb_ptm_cap_descriptor = type { i8, i8, i8 }
%struct.usb_host_config = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_config_descriptor = type <{ i8, i8, i16, i8, i8, i8, i8, i8 }>
%struct.usb_interface_cache = type { i32, %struct.kref, [0 x %struct.usb_host_interface] }
%struct.wusb_dev = type opaque
%struct.usb2_lpm_parameters = type { i32, i32 }
%struct.usb3_lpm_parameters = type { i32, i32, i32, i32 }
%struct.usb_memory = type { %struct.list_head, i32, i32, i32, i8*, i64, i64, %struct.usb_dev_state* }
%struct.async = type { %struct.list_head, %struct.usb_dev_state*, %struct.pid*, %struct.cred*, i32, i32, i8*, i8*, %struct.urb*, %struct.usb_memory*, i32, i32, i32, i8, i8 }
%struct.urb = type { %struct.kref, i8*, %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, void (%struct.urb*)*, [0 x %struct.usb_iso_packet_descriptor] }
%struct.usb_anchor = type { %struct.list_head, %struct.__wait_queue_head, %struct.spinlock, %struct.atomic_t, i8 }
%struct.usb_iso_packet_descriptor = type { i32, i32, i32, i32 }
%union.anon.58 = type { %struct.list_head* }
%union.anon.59 = type { %struct.list_head* }
%union.anon.60 = type { %struct.list_head* }
%union.anon.61 = type { %struct.list_head* }
%struct.usbdevfs_ctrltransfer32 = type { i8, i8, i16, i16, i16, i32, i32 }
%struct.usbdevfs_bulktransfer32 = type { i32, i32, i32, i32 }
%struct.usbdevfs_ctrltransfer = type { i8, i8, i16, i16, i16, i32, i8* }
%struct.usbdevfs_bulktransfer = type { i32, i32, i32, i8* }
%struct.usbdevfs_getdriver = type { i32, [256 x i8] }
%struct.usbdevfs_connectinfo = type { i32, i8 }
%struct.usbdevfs_setinterface = type { i32, i32 }
%struct.usbdevfs_urb = type { i8, i8, i32, i32, i8*, i32, i32, i32, %union.anon.62, i32, i32, i8*, [0 x %struct.usbdevfs_iso_packet_desc] }
%union.anon.62 = type { i32 }
%struct.usbdevfs_iso_packet_desc = type { i32, i32, i32 }
%struct.usbdevfs_disconnectsignal32 = type { i32, i32 }
%struct.usbdevfs_urb32 = type { i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [0 x %struct.usbdevfs_iso_packet_desc] }
%struct.usbdevfs_ioctl32 = type { i32, i32, i32 }
%struct.usbdevfs_ioctl = type { i32, i32, i8* }
%struct.__large_struct = type { [100 x i64] }
%struct.usbdevfs_disconnectsignal = type { i32, i8* }
%struct.usbdevfs_disconnect_claim = type { i32, i32, [256 x i8] }
%struct.usbdevfs_streams = type { i32, i32, [0 x i8] }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%union.anon.63 = type { i64 }
%struct.usb_ctrlrequest = type { i8, i8, i16, i16, i16 }
%struct.anon.18 = type { i8*, i16, %union.anon.19 }
%union.anon.19 = type { %struct.anon.20 }
%struct.anon.20 = type { i8*, i8* }
%union.anon.64 = type { i8 }

@usbfs_mutex = global %struct.mutex { %struct.atomic64_t zeroinitializer, %struct.spinlock zeroinitializer, %struct.optimistic_spin_queue zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 16) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 16) to %struct.list_head*) } }, align 8
@__param_str_usbfs_snoop = internal constant [20 x i8] c"usbcore.usbfs_snoop\00", align 16
@param_ops_bool = external constant %struct.kernel_param_ops, align 8
@usbfs_snoop = internal global i8 0, align 1
@__param_usbfs_snoop = internal constant %struct.kernel_param { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__param_str_usbfs_snoop, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_bool, i16 420, i8 -1, i8 0, %union.anon.51 { i8* @usbfs_snoop } }, section "__param", align 8
@__param_str_usbfs_snoop_max = internal constant [24 x i8] c"usbcore.usbfs_snoop_max\00", align 16
@param_ops_uint = external constant %struct.kernel_param_ops, align 8
@usbfs_snoop_max = internal global i32 65536, align 4
@__param_usbfs_snoop_max = internal constant %struct.kernel_param { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__param_str_usbfs_snoop_max, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @usbfs_snoop_max to i8*) } }, section "__param", align 8
@__param_str_usbfs_memory_mb = internal constant [24 x i8] c"usbcore.usbfs_memory_mb\00", align 16
@usbfs_memory_mb = internal global i32 16, align 4
@__param_usbfs_memory_mb = internal constant %struct.kernel_param { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__param_str_usbfs_memory_mb, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @usbfs_memory_mb to i8*) } }, section "__param", align 8
@.str = private unnamed_addr constant [6 x i8] c"usbfs\00", align 1
@usbfs_driver = global %struct.usb_driver { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0), i32 (%struct.usb_interface*, %struct.usb_device_id*)* @driver_probe, void (%struct.usb_interface*)* @driver_disconnect, i32 (%struct.usb_interface*, i32, i8*)* null, i32 (%struct.usb_interface*, i32)* @driver_suspend, i32 (%struct.usb_interface*)* @driver_resume, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, %struct.usb_device_id* null, %struct.usb_dynids zeroinitializer, %struct.usbdrv_wrap zeroinitializer, i8 0 }, align 8
@usbdev_file_operations = constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @no_seek_end_llseek, i64 (%struct.file*, i8*, i64, i64*)* @usbdev_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i64 (%struct.kiocb*, %struct.iov_iter*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.dir_context*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @usbdev_poll, i64 (%struct.file*, i32, i64)* @usbdev_ioctl, i64 (%struct.file*, i32, i64)* @usbdev_compat_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* @usbdev_mmap, i32 (%struct.inode*, %struct.file*)* @usbdev_open, i32 (%struct.file*, i8*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**, i8**)* null, i64 (%struct.file*, i32, i64, i64)* null, void (%struct.seq_file*, %struct.file*)* null, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)* null, i32 (%struct.file*, i64, %struct.file*, i64, i64)* null, i64 (%struct.file*, i64, i64, %struct.file*, i64)* null }, align 8
@.str.1 = private unnamed_addr constant [11 x i8] c"usb_device\00", align 1
@.str.2 = private unnamed_addr constant [44 x i8] c"\013Unable to register minors for usb_device\0A\00", align 1
@usb_device_cdev = internal global %struct.cdev zeroinitializer, align 8
@.str.3 = private unnamed_addr constant [37 x i8] c"\013Unable to get usb_device major %d\0A\00", align 1
@usbdev_nb = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @usbdev_notify, %struct.notifier_block* null, i32 0 }, align 8
@.str.4 = private unnamed_addr constant [34 x i8] c"interface number %u out of range\0A\00", align 1
@.str.5 = private unnamed_addr constant [33 x i8] c"./arch/x86/include/asm/uaccess.h\00", align 1
@.str.6 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@.str.7 = private unnamed_addr constant [13 x i8] c"%s: REAPURB\0A\00", align 1
@__func__.usbdev_do_ioctl = private unnamed_addr constant [16 x i8] c"usbdev_do_ioctl\00", align 1
@.str.8 = private unnamed_addr constant [19 x i8] c"%s: REAPURBNDELAY\0A\00", align 1
@.str.9 = private unnamed_addr constant [15 x i8] c"%s: REAPURB32\0A\00", align 1
@.str.10 = private unnamed_addr constant [21 x i8] c"%s: REAPURBNDELAY32\0A\00", align 1
@.str.11 = private unnamed_addr constant [13 x i8] c"%s: CONTROL\0A\00", align 1
@.str.12 = private unnamed_addr constant [10 x i8] c"%s: BULK\0A\00", align 1
@.str.13 = private unnamed_addr constant [13 x i8] c"%s: RESETEP\0A\00", align 1
@.str.14 = private unnamed_addr constant [11 x i8] c"%s: RESET\0A\00", align 1
@.str.15 = private unnamed_addr constant [16 x i8] c"%s: CLEAR_HALT\0A\00", align 1
@.str.16 = private unnamed_addr constant [15 x i8] c"%s: GETDRIVER\0A\00", align 1
@.str.17 = private unnamed_addr constant [17 x i8] c"%s: CONNECTINFO\0A\00", align 1
@.str.18 = private unnamed_addr constant [18 x i8] c"%s: SETINTERFACE\0A\00", align 1
@.str.19 = private unnamed_addr constant [22 x i8] c"%s: SETCONFIGURATION\0A\00", align 1
@.str.20 = private unnamed_addr constant [15 x i8] c"%s: SUBMITURB\0A\00", align 1
@.str.21 = private unnamed_addr constant [15 x i8] c"%s: CONTROL32\0A\00", align 1
@.str.22 = private unnamed_addr constant [12 x i8] c"%s: BULK32\0A\00", align 1
@.str.23 = private unnamed_addr constant [18 x i8] c"%s: DISCSIGNAL32\0A\00", align 1
@.str.24 = private unnamed_addr constant [17 x i8] c"%s: SUBMITURB32\0A\00", align 1
@.str.25 = private unnamed_addr constant [13 x i8] c"%s: IOCTL32\0A\00", align 1
@.str.26 = private unnamed_addr constant [19 x i8] c"%s: DISCARDURB %p\0A\00", align 1
@.str.27 = private unnamed_addr constant [16 x i8] c"%s: DISCSIGNAL\0A\00", align 1
@.str.28 = private unnamed_addr constant [20 x i8] c"%s: CLAIMINTERFACE\0A\00", align 1
@.str.29 = private unnamed_addr constant [22 x i8] c"%s: RELEASEINTERFACE\0A\00", align 1
@.str.30 = private unnamed_addr constant [11 x i8] c"%s: IOCTL\0A\00", align 1
@.str.31 = private unnamed_addr constant [16 x i8] c"%s: CLAIM_PORT\0A\00", align 1
@.str.32 = private unnamed_addr constant [18 x i8] c"%s: RELEASE_PORT\0A\00", align 1
@.str.33 = private unnamed_addr constant [9 x i8] c"reap %p\0A\00", align 1
@usbfs_memory_usage = internal global %struct.atomic64_t zeroinitializer, align 8
@current_task = external global %struct.task_struct*, align 8
@.str.34 = private unnamed_addr constant [83 x i8] c"control urb: bRequestType=%02x bRequest=%02x wValue=%04x wIndex=%04x wLength=%04x\0A\00", align 1
@.str.35 = private unnamed_addr constant [3 x i8] c"\017\00", align 1
@.str.36 = private unnamed_addr constant [66 x i8] c"usbfs: USBDEVFS_CONTROL failed cmd %s rqt %u rq %u len %u ret %d\0A\00", align 1
@.str.37 = private unnamed_addr constant [55 x i8] c"%s: process %i (%s) requesting ep %02x but needs %02x\0A\00", align 1
@__func__.check_ctrlrecip = private unnamed_addr constant [16 x i8] c"check_ctrlrecip\00", align 1
@.str.38 = private unnamed_addr constant [62 x i8] c"usbfs: process %d (%s) did not claim interface %u before use\0A\00", align 1
@snoop_urb.types = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.39, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.40, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.41, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i32 0, i32 0)], align 16
@.str.39 = private unnamed_addr constant [5 x i8] c"isoc\00", align 1
@.str.40 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str.41 = private unnamed_addr constant [5 x i8] c"ctrl\00", align 1
@.str.42 = private unnamed_addr constant [5 x i8] c"bulk\00", align 1
@snoop_urb.dirs = internal global [2 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.43, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.44, i32 0, i32 0)], align 16
@.str.43 = private unnamed_addr constant [4 x i8] c"out\00", align 1
@.str.44 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.45 = private unnamed_addr constant [35 x i8] c"userurb %p, ep%d %s-%s, length %u\0A\00", align 1
@.str.46 = private unnamed_addr constant [52 x i8] c"userurb %p, ep%d %s-%s, actual_length %u status %d\0A\00", align 1
@.str.47 = private unnamed_addr constant [35 x i8] c"ep%d %s-%s, length %u, timeout %d\0A\00", align 1
@.str.48 = private unnamed_addr constant [41 x i8] c"ep%d %s-%s, actual_length %u, status %d\0A\00", align 1
@.str.49 = private unnamed_addr constant [7 x i8] c"data: \00", align 1
@.str.50 = private unnamed_addr constant [22 x i8] c"./include/linux/usb.h\00", align 1
@.str.51 = private unnamed_addr constant [8 x i8] c"RESETEP\00", align 1
@.str.52 = private unnamed_addr constant [63 x i8] c"Process %d (%s) called USBDEVFS_%s for active endpoint 0x%02x\0A\00", align 1
@.str.53 = private unnamed_addr constant [60 x i8] c"usbfs: interface %d claimed by %s while '%s' resets device\0A\00", align 1
@.str.54 = private unnamed_addr constant [11 x i8] c"CLEAR_HALT\00", align 1
@.str.55 = private unnamed_addr constant [62 x i8] c"usbfs: interface %d claimed by %s while '%s' sets config #%d\0A\00", align 1
@.str.56 = private unnamed_addr constant [35 x i8] c"usbfs: usb_submit_urb returned %d\0A\00", align 1
@.str.57 = private unnamed_addr constant [30 x i8] c"./include/linux/scatterlist.h\00", align 1
@phys_base = external global i64, align 8
@.str.58 = private unnamed_addr constant [14 x i8] c"urb complete\0A\00", align 1
@.str.59 = private unnamed_addr constant [35 x i8] c"port %d claimed by process %d: %s\0A\00", align 1
@usbdev_vm_ops = internal global %struct.vm_operations_struct { void (%struct.vm_area_struct*)* @usbdev_vm_open, void (%struct.vm_area_struct*)* @usbdev_vm_close, i32 (%struct.vm_area_struct*)* null, i32 (%struct.vm_fault*)* null, i32 (%struct.vm_fault*, i32)* null, void (%struct.vm_fault*, i64, i64)* null, i32 (%struct.vm_fault*)* null, i32 (%struct.vm_fault*)* null, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)* null, i8* (%struct.vm_area_struct*)* null, i32 (%struct.vm_area_struct*, %struct.mempolicy*)* null, %struct.mempolicy* (%struct.vm_area_struct*, i64)* null, %struct.page* (%struct.vm_area_struct*, i64)* null }, align 8
@usbdev_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.60 = private unnamed_addr constant [10 x i8] c"&ps->wait\00", align 1
@.str.61 = private unnamed_addr constant [26 x i8] c"opened by process %d: %s\0A\00", align 1
@usb_bus_type = external global %struct.bus_type, align 8
@llvm.used = appending global [3 x i8*] [i8* bitcast (%struct.kernel_param* @__param_usbfs_snoop to i8*), i8* bitcast (%struct.kernel_param* @__param_usbfs_snoop_max to i8*), i8* bitcast (%struct.kernel_param* @__param_usbfs_memory_mb to i8*)], section "llvm.metadata"

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @driver_probe(%struct.usb_interface* %intf, %struct.usb_device_id* %id) #0 {
entry:
  %intf.addr = alloca %struct.usb_interface*, align 8
  %id.addr = alloca %struct.usb_device_id*, align 8
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  store %struct.usb_device_id* %id, %struct.usb_device_id** %id.addr, align 8
  ret i32 -19
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @driver_disconnect(%struct.usb_interface* %intf) #0 {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %intf.addr = alloca %struct.usb_interface*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %ifnum = alloca i32, align 4
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  %0 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %0)
  %1 = bitcast i8* %call to %struct.usb_dev_state*
  store %struct.usb_dev_state* %1, %struct.usb_dev_state** %ps, align 8
  %2 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 0
  %3 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %3, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %4 = load i8, i8* %bInterfaceNumber, align 2
  %conv = zext i8 %4 to i32
  store i32 %conv, i32* %ifnum, align 4
  %5 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %tobool = icmp ne %struct.usb_dev_state* %5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, i32* %ifnum, align 4
  %conv1 = zext i32 %6 to i64
  %cmp = icmp ult i64 %conv1, 64
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %7 = load i32, i32* %ifnum, align 4
  %conv7 = zext i32 %7 to i64
  %8 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %8, i32 0, i32 12
  store i64 %conv7, i64* %nr.addr.i, align 8
  store i64* %ifclaimed, i64** %addr.addr.i, align 8
  %9 = load i64*, i64** %addr.addr.i, align 8
  %10 = load i64, i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %9, i64 %10, i64* %9) #4, !srcloc !2
  br label %if.end8

if.else:                                          ; preds = %if.end
  %11 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %11, i32 0, i32 7
  %12 = load i32, i32* %ifnum, align 4
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.4, i32 0, i32 0), i32 %12)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then6
  %13 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  call void @usb_set_intfdata(%struct.usb_interface* %13, i8* null)
  %14 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %15 = load i32, i32* %ifnum, align 4
  call void @destroy_async_on_interface(%struct.usb_dev_state* %14, i32 %15)
  br label %return

return:                                           ; preds = %if.end8, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @driver_suspend(%struct.usb_interface* %intf, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.pm_message, align 4
  %intf.addr = alloca %struct.usb_interface*, align 8
  %coerce.dive = getelementptr inbounds %struct.pm_message, %struct.pm_message* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @driver_resume(%struct.usb_interface* %intf) #0 {
entry:
  %intf.addr = alloca %struct.usb_interface*, align 8
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  ret i32 0
}

declare i64 @no_seek_end_llseek(%struct.file*, i64, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @usbdev_read(%struct.file* %file, i8* %buf, i64 %nbytes, i64* %ppos) #0 {
entry:
  %to.addr.i100 = alloca i8*, align 8
  %from.addr.i101 = alloca i8*, align 8
  %n.addr.i102 = alloca i64, align 8
  %sz.i103 = alloca i32, align 4
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %file.addr = alloca %struct.file*, align 8
  %buf.addr = alloca i8*, align 8
  %nbytes.addr = alloca i64, align 8
  %ppos.addr = alloca i64*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %ret = alloca i64, align 8
  %len = alloca i32, align 4
  %pos = alloca i64, align 8
  %i = alloca i32, align 4
  %temp_desc = alloca %struct.usb_device_descriptor, align 1
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  %tmp = alloca i8*, align 8
  %config = alloca %struct.usb_config_descriptor*, align 8
  %length = alloca i32, align 4
  %alloclen = alloca i32, align 4
  %__UNIQUE_ID_min1_24 = alloca i32, align 4
  %__UNIQUE_ID_min2_25 = alloca i32, align 4
  %tmp79 = alloca i32, align 4
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store i8* %buf, i8** %buf.addr, align 8
  store i64 %nbytes, i64* %nbytes.addr, align 8
  store i64* %ppos, i64** %ppos.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8
  %2 = bitcast i8* %1 to %struct.usb_dev_state*
  store %struct.usb_dev_state* %2, %struct.usb_dev_state** %ps, align 8
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %4, %struct.usb_device** %dev, align 8
  store i64 0, i64* %ret, align 8
  %5 = load i64*, i64** %ppos.addr, align 8
  %6 = load i64, i64* %5, align 8
  store i64 %6, i64* %pos, align 8
  %7 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  %8 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %call = call i32 @connected(%struct.usb_dev_state* %8)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i64 -19, i64* %ret, align 8
  br label %err

if.else:                                          ; preds = %entry
  %9 = load i64, i64* %pos, align 8
  %cmp = icmp slt i64 %9, 0
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  store i64 -22, i64* %ret, align 8
  br label %err

if.end:                                           ; preds = %if.else
  br label %if.end4

if.end4:                                          ; preds = %if.end
  %10 = load i64, i64* %pos, align 8
  %cmp5 = icmp ult i64 %10, 18
  br i1 %cmp5, label %if.then6, label %if.end36

if.then6:                                         ; preds = %if.end4
  store i64 18, i64* %__len, align 8
  %11 = load i64, i64* %__len, align 8
  %cmp7 = icmp uge i64 %11, 64
  br i1 %cmp7, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.then6
  %12 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %13 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 12
  %14 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  %15 = load i64, i64* %__len, align 8
  %call9 = call i8* @__memcpy(i8* %12, i8* %14, i64 %15)
  store i8* %call9, i8** %__ret, align 8
  br label %if.end12

if.else10:                                        ; preds = %if.then6
  %16 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %17 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %descriptor11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 12
  %18 = bitcast %struct.usb_device_descriptor* %descriptor11 to i8*
  %19 = load i64, i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %18, i64 %19, i32 1, i1 false)
  store i8* %16, i8** %__ret, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else10, %if.then8
  %20 = load i8*, i8** %__ret, align 8
  store i8* %20, i8** %tmp, align 8
  %21 = load i8*, i8** %tmp, align 8
  br label %do.body

do.body:                                          ; preds = %if.end12
  %bcdUSB = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 2
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body13

do.body13:                                        ; preds = %do.end
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 7
  br label %do.end14

do.end14:                                         ; preds = %do.body13
  br label %do.body15

do.body15:                                        ; preds = %do.end14
  %idProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 8
  br label %do.end16

do.end16:                                         ; preds = %do.body15
  br label %do.body17

do.body17:                                        ; preds = %do.end16
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 9
  br label %do.end18

do.end18:                                         ; preds = %do.body17
  %22 = load i64, i64* %pos, align 8
  %sub = sub i64 18, %22
  %conv = trunc i64 %sub to i32
  store i32 %conv, i32* %len, align 4
  %23 = load i32, i32* %len, align 4
  %conv19 = zext i32 %23 to i64
  %24 = load i64, i64* %nbytes.addr, align 8
  %cmp20 = icmp ugt i64 %conv19, %24
  br i1 %cmp20, label %if.then22, label %if.end24

if.then22:                                        ; preds = %do.end18
  %25 = load i64, i64* %nbytes.addr, align 8
  %conv23 = trunc i64 %25 to i32
  store i32 %conv23, i32* %len, align 4
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %do.end18
  %26 = load i8*, i8** %buf.addr, align 8
  %27 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %28 = load i64, i64* %pos, align 8
  %add.ptr = getelementptr inbounds i8, i8* %27, i64 %28
  %29 = load i32, i32* %len, align 4
  %conv25 = zext i32 %29 to i64
  store i8* %26, i8** %to.addr.i, align 8
  store i8* %add.ptr, i8** %from.addr.i, align 8
  store i64 %conv25, i64* %n.addr.i, align 8
  %30 = load i8*, i8** %from.addr.i, align 8
  %31 = call i64 @llvm.objectsize.i64.p0i8(i8* %30, i1 false, i1 true) #4
  %conv.i = trunc i64 %31 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  %32 = load i8*, i8** %from.addr.i, align 8
  %33 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %33 to i32
  call void @kasan_check_read(i8* %32, i32 %conv1.i) #4
  call void @might_fault() #4
  %34 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %34, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %if.end24
  %35 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %35 to i64
  %36 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %36
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %if.end24
  %37 = phi i1 [ true, %if.end24 ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %37, true
  %lnot.ext.i = zext i1 %37 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %37, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %38 = load i8*, i8** %from.addr.i, align 8
  %39 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %38, i64 %39, i1 zeroext true) #4
  %40 = load i8*, i8** %to.addr.i, align 8
  %41 = load i8*, i8** %from.addr.i, align 8
  %42 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %42 to i32
  %call.i = call i64 @_copy_to_user(i8* %40, i8* %41, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_to_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %43 = load i32, i32* %sz.i, align 4
  %44 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %43, i64 %44) #4
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i, %if.then.i
  %45 = load i64, i64* %n.addr.i, align 8
  %tobool27 = icmp ne i64 %45, 0
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %copy_to_user.exit
  store i64 -14, i64* %ret, align 8
  br label %err

if.end29:                                         ; preds = %copy_to_user.exit
  %46 = load i32, i32* %len, align 4
  %conv30 = zext i32 %46 to i64
  %47 = load i64*, i64** %ppos.addr, align 8
  %48 = load i64, i64* %47, align 8
  %add = add nsw i64 %48, %conv30
  store i64 %add, i64* %47, align 8
  %49 = load i32, i32* %len, align 4
  %50 = load i8*, i8** %buf.addr, align 8
  %idx.ext = zext i32 %49 to i64
  %add.ptr31 = getelementptr inbounds i8, i8* %50, i64 %idx.ext
  store i8* %add.ptr31, i8** %buf.addr, align 8
  %51 = load i32, i32* %len, align 4
  %conv32 = zext i32 %51 to i64
  %52 = load i64, i64* %nbytes.addr, align 8
  %sub33 = sub i64 %52, %conv32
  store i64 %sub33, i64* %nbytes.addr, align 8
  %53 = load i32, i32* %len, align 4
  %conv34 = zext i32 %53 to i64
  %54 = load i64, i64* %ret, align 8
  %add35 = add nsw i64 %54, %conv34
  store i64 %add35, i64* %ret, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.end29, %if.end4
  store i64 18, i64* %pos, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end36
  %55 = load i64, i64* %nbytes.addr, align 8
  %tobool37 = icmp ne i64 %55, 0
  br i1 %tobool37, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %56 = load i32, i32* %i, align 4
  %57 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %descriptor38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %57, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor38, i32 0, i32 13
  %58 = load i8, i8* %bNumConfigurations, align 1
  %conv39 = zext i8 %58 to i32
  %cmp40 = icmp slt i32 %56, %conv39
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %59 = phi i1 [ false, %for.cond ], [ %cmp40, %land.rhs ]
  br i1 %59, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %60 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %60, i32 0, i32 18
  %61 = load i8**, i8*** %rawdescriptors, align 8
  %62 = load i32, i32* %i, align 4
  %idxprom = sext i32 %62 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %61, i64 %idxprom
  %63 = load i8*, i8** %arrayidx, align 8
  %64 = bitcast i8* %63 to %struct.usb_config_descriptor*
  store %struct.usb_config_descriptor* %64, %struct.usb_config_descriptor** %config, align 8
  %65 = load %struct.usb_config_descriptor*, %struct.usb_config_descriptor** %config, align 8
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %65, i32 0, i32 2
  %66 = load i16, i16* %wTotalLength, align 1
  %conv42 = zext i16 %66 to i32
  store i32 %conv42, i32* %length, align 4
  %67 = load i64*, i64** %ppos.addr, align 8
  %68 = load i64, i64* %67, align 8
  %69 = load i64, i64* %pos, align 8
  %70 = load i32, i32* %length, align 4
  %conv43 = zext i32 %70 to i64
  %add44 = add nsw i64 %69, %conv43
  %cmp45 = icmp slt i64 %68, %add44
  br i1 %cmp45, label %if.then47, label %if.end96

if.then47:                                        ; preds = %for.body
  %71 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %config48 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %71, i32 0, i32 14
  %72 = load %struct.usb_host_config*, %struct.usb_host_config** %config48, align 8
  %73 = load i32, i32* %i, align 4
  %idxprom49 = sext i32 %73 to i64
  %arrayidx50 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %72, i64 %idxprom49
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx50, i32 0, i32 0
  %wTotalLength51 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 2
  %74 = load i16, i16* %wTotalLength51, align 2
  %conv52 = zext i16 %74 to i32
  store i32 %conv52, i32* %alloclen, align 4
  %75 = load i32, i32* %length, align 4
  %conv53 = zext i32 %75 to i64
  %76 = load i64*, i64** %ppos.addr, align 8
  %77 = load i64, i64* %76, align 8
  %78 = load i64, i64* %pos, align 8
  %sub54 = sub nsw i64 %77, %78
  %sub55 = sub nsw i64 %conv53, %sub54
  %conv56 = trunc i64 %sub55 to i32
  store i32 %conv56, i32* %len, align 4
  %79 = load i32, i32* %len, align 4
  %conv57 = zext i32 %79 to i64
  %80 = load i64, i64* %nbytes.addr, align 8
  %cmp58 = icmp ugt i64 %conv57, %80
  br i1 %cmp58, label %if.then60, label %if.end62

if.then60:                                        ; preds = %if.then47
  %81 = load i64, i64* %nbytes.addr, align 8
  %conv61 = trunc i64 %81 to i32
  store i32 %conv61, i32* %len, align 4
  br label %if.end62

if.end62:                                         ; preds = %if.then60, %if.then47
  %82 = load i32, i32* %alloclen, align 4
  %conv63 = zext i32 %82 to i64
  %83 = load i64*, i64** %ppos.addr, align 8
  %84 = load i64, i64* %83, align 8
  %85 = load i64, i64* %pos, align 8
  %sub64 = sub nsw i64 %84, %85
  %cmp65 = icmp sgt i64 %conv63, %sub64
  br i1 %cmp65, label %if.then67, label %if.end87

if.then67:                                        ; preds = %if.end62
  %86 = load i64*, i64** %ppos.addr, align 8
  %87 = load i64, i64* %86, align 8
  %88 = load i64, i64* %pos, align 8
  %sub68 = sub nsw i64 %87, %88
  %89 = load i32, i32* %alloclen, align 4
  %conv69 = zext i32 %89 to i64
  %sub70 = sub nsw i64 %conv69, %sub68
  %conv71 = trunc i64 %sub70 to i32
  store i32 %conv71, i32* %alloclen, align 4
  %90 = load i8*, i8** %buf.addr, align 8
  %91 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %rawdescriptors72 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %91, i32 0, i32 18
  %92 = load i8**, i8*** %rawdescriptors72, align 8
  %93 = load i32, i32* %i, align 4
  %idxprom73 = sext i32 %93 to i64
  %arrayidx74 = getelementptr inbounds i8*, i8** %92, i64 %idxprom73
  %94 = load i8*, i8** %arrayidx74, align 8
  %95 = load i64*, i64** %ppos.addr, align 8
  %96 = load i64, i64* %95, align 8
  %97 = load i64, i64* %pos, align 8
  %sub75 = sub nsw i64 %96, %97
  %add.ptr76 = getelementptr inbounds i8, i8* %94, i64 %sub75
  %98 = load i32, i32* %len, align 4
  store i32 %98, i32* %__UNIQUE_ID_min1_24, align 4
  %99 = load i32, i32* %alloclen, align 4
  store i32 %99, i32* %__UNIQUE_ID_min2_25, align 4
  %cmp77 = icmp eq i32* %__UNIQUE_ID_min1_24, %__UNIQUE_ID_min2_25
  %conv78 = zext i1 %cmp77 to i32
  %100 = load i32, i32* %__UNIQUE_ID_min1_24, align 4
  %101 = load i32, i32* %__UNIQUE_ID_min2_25, align 4
  %cmp80 = icmp ult i32 %100, %101
  br i1 %cmp80, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then67
  %102 = load i32, i32* %__UNIQUE_ID_min1_24, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then67
  %103 = load i32, i32* %__UNIQUE_ID_min2_25, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %102, %cond.true ], [ %103, %cond.false ]
  store i32 %cond, i32* %tmp79, align 4
  %104 = load i32, i32* %tmp79, align 4
  %conv82 = zext i32 %104 to i64
  store i8* %90, i8** %to.addr.i100, align 8
  store i8* %add.ptr76, i8** %from.addr.i101, align 8
  store i64 %conv82, i64* %n.addr.i102, align 8
  %105 = load i8*, i8** %from.addr.i101, align 8
  %106 = call i64 @llvm.objectsize.i64.p0i8(i8* %105, i1 false, i1 true) #4
  %conv.i104 = trunc i64 %106 to i32
  store i32 %conv.i104, i32* %sz.i103, align 4
  %107 = load i8*, i8** %from.addr.i101, align 8
  %108 = load i64, i64* %n.addr.i102, align 8
  %conv1.i105 = trunc i64 %108 to i32
  call void @kasan_check_read(i8* %107, i32 %conv1.i105) #4
  call void @might_fault() #4
  %109 = load i32, i32* %sz.i103, align 4
  %cmp.i106 = icmp slt i32 %109, 0
  br i1 %cmp.i106, label %lor.end.i113, label %lor.rhs.i109

lor.rhs.i109:                                     ; preds = %cond.end
  %110 = load i32, i32* %sz.i103, align 4
  %conv3.i107 = sext i32 %110 to i64
  %111 = load i64, i64* %n.addr.i102, align 8
  %cmp4.i108 = icmp uge i64 %conv3.i107, %111
  br label %lor.end.i113

lor.end.i113:                                     ; preds = %lor.rhs.i109, %cond.end
  %112 = phi i1 [ true, %cond.end ], [ %cmp4.i108, %lor.rhs.i109 ]
  %lnot.i110 = xor i1 %112, true
  %lnot.ext.i111 = zext i1 %112 to i32
  %conv7.i112 = sext i32 %lnot.ext.i111 to i64
  br i1 %112, label %if.then.i116, label %if.else.i117

if.then.i116:                                     ; preds = %lor.end.i113
  %113 = load i8*, i8** %from.addr.i101, align 8
  %114 = load i64, i64* %n.addr.i102, align 8
  call void @check_object_size(i8* %113, i64 %114, i1 zeroext true) #4
  %115 = load i8*, i8** %to.addr.i100, align 8
  %116 = load i8*, i8** %from.addr.i101, align 8
  %117 = load i64, i64* %n.addr.i102, align 8
  %conv8.i114 = trunc i64 %117 to i32
  %call.i115 = call i64 @_copy_to_user(i8* %115, i8* %116, i32 %conv8.i114) #4
  store i64 %call.i115, i64* %n.addr.i102, align 8
  br label %copy_to_user.exit118

if.else.i117:                                     ; preds = %lor.end.i113
  %118 = load i32, i32* %sz.i103, align 4
  %119 = load i64, i64* %n.addr.i102, align 8
  call void @copy_user_overflow(i32 %118, i64 %119) #4
  br label %copy_to_user.exit118

copy_to_user.exit118:                             ; preds = %if.else.i117, %if.then.i116
  %120 = load i64, i64* %n.addr.i102, align 8
  %tobool84 = icmp ne i64 %120, 0
  br i1 %tobool84, label %if.then85, label %if.end86

if.then85:                                        ; preds = %copy_to_user.exit118
  store i64 -14, i64* %ret, align 8
  br label %err

if.end86:                                         ; preds = %copy_to_user.exit118
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %if.end62
  %121 = load i32, i32* %len, align 4
  %conv88 = zext i32 %121 to i64
  %122 = load i64*, i64** %ppos.addr, align 8
  %123 = load i64, i64* %122, align 8
  %add89 = add nsw i64 %123, %conv88
  store i64 %add89, i64* %122, align 8
  %124 = load i32, i32* %len, align 4
  %125 = load i8*, i8** %buf.addr, align 8
  %idx.ext90 = zext i32 %124 to i64
  %add.ptr91 = getelementptr inbounds i8, i8* %125, i64 %idx.ext90
  store i8* %add.ptr91, i8** %buf.addr, align 8
  %126 = load i32, i32* %len, align 4
  %conv92 = zext i32 %126 to i64
  %127 = load i64, i64* %nbytes.addr, align 8
  %sub93 = sub i64 %127, %conv92
  store i64 %sub93, i64* %nbytes.addr, align 8
  %128 = load i32, i32* %len, align 4
  %conv94 = zext i32 %128 to i64
  %129 = load i64, i64* %ret, align 8
  %add95 = add nsw i64 %129, %conv94
  store i64 %add95, i64* %ret, align 8
  br label %if.end96

if.end96:                                         ; preds = %if.end87, %for.body
  %130 = load i32, i32* %length, align 4
  %conv97 = zext i32 %130 to i64
  %131 = load i64, i64* %pos, align 8
  %add98 = add nsw i64 %131, %conv97
  store i64 %add98, i64* %pos, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end96
  %132 = load i32, i32* %i, align 4
  %inc = add nsw i32 %132, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  br label %err

err:                                              ; preds = %for.end, %if.then85, %if.then28, %if.then3, %if.then
  %133 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev99 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %133, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev99)
  %134 = load i64, i64* %ret, align 8
  ret i64 %134
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbdev_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %file.addr = alloca %struct.file*, align 8
  %wait.addr = alloca %struct.poll_table_struct*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %mask = alloca i32, align 4
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store %struct.poll_table_struct* %wait, %struct.poll_table_struct** %wait.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8
  %2 = bitcast i8* %1 to %struct.usb_dev_state*
  store %struct.usb_dev_state* %2, %struct.usb_dev_state** %ps, align 8
  store i32 0, i32* %mask, align 4
  %3 = load %struct.file*, %struct.file** %file.addr, align 8
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %wait1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %4, i32 0, i32 7
  %5 = load %struct.poll_table_struct*, %struct.poll_table_struct** %wait.addr, align 8
  call void @poll_wait(%struct.file* %3, %struct.__wait_queue_head* %wait1, %struct.poll_table_struct* %5)
  %6 = load %struct.file*, %struct.file** %file.addr, align 8
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %6, i32 0, i32 7
  %7 = load i32, i32* %f_mode, align 4
  %and = and i32 %7, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %async_completed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %8, i32 0, i32 5
  %call = call i32 @list_empty(%struct.list_head* %async_completed)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %9 = load i32, i32* %mask, align 4
  %or = or i32 %9, 260
  store i32 %or, i32* %mask, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %10 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %call3 = call i32 @connected(%struct.usb_dev_state* %10)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %11 = load i32, i32* %mask, align 4
  %or6 = or i32 %11, 16
  store i32 %or6, i32* %mask, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %12 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %12, i32 0, i32 0
  %call8 = call i32 @list_empty(%struct.list_head* %list)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end7
  %13 = load i32, i32* %mask, align 4
  %or11 = or i32 %13, 8
  store i32 %or11, i32* %mask, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end7
  %14 = load i32, i32* %mask, align 4
  ret i32 %14
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @usbdev_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %file.addr = alloca %struct.file*, align 8
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %ret = alloca i32, align 4
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store i32 %cmd, i32* %cmd.addr, align 4
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %1 = load i32, i32* %cmd.addr, align 4
  %2 = load i64, i64* %arg.addr, align 8
  %3 = inttoptr i64 %2 to i8*
  %call = call i64 @usbdev_do_ioctl(%struct.file* %0, i32 %1, i8* %3)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %ret, align 4
  %4 = load i32, i32* %ret, align 4
  %conv1 = sext i32 %4 to i64
  ret i64 %conv1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @usbdev_compat_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %file.addr = alloca %struct.file*, align 8
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %ret = alloca i32, align 4
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store i32 %cmd, i32* %cmd.addr, align 4
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %1 = load i32, i32* %cmd.addr, align 4
  %2 = load i64, i64* %arg.addr, align 8
  %conv = trunc i64 %2 to i32
  %call = call i8* @compat_ptr(i32 %conv)
  %call1 = call i64 @usbdev_do_ioctl(%struct.file* %0, i32 %1, i8* %call)
  %conv2 = trunc i64 %call1 to i32
  store i32 %conv2, i32* %ret, align 4
  %3 = load i32, i32* %ret, align 4
  %conv3 = sext i32 %3 to i64
  ret i64 %conv3
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbdev_mmap(%struct.file* %file, %struct.vm_area_struct* %vma) #0 {
entry:
  %lock.addr.i34 = alloca %struct.spinlock*, align 8
  %flags.addr.i = alloca i64, align 8
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %tmp.i = alloca i32, align 4
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %retval = alloca i32, align 4
  %file.addr = alloca %struct.file*, align 8
  %vma.addr = alloca %struct.vm_area_struct*, align 8
  %usbm = alloca %struct.usb_memory*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %size = alloca i64, align 8
  %mem = alloca i8*, align 8
  %flags = alloca i64, align 8
  %dma_handle = alloca i64, align 8
  %ret = alloca i32, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store %struct.vm_area_struct* %vma, %struct.vm_area_struct** %vma.addr, align 8
  store %struct.usb_memory* null, %struct.usb_memory** %usbm, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8
  %2 = bitcast i8* %1 to %struct.usb_dev_state*
  store %struct.usb_dev_state* %2, %struct.usb_dev_state** %ps, align 8
  %3 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_end = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %3, i32 0, i32 1
  %4 = load i64, i64* %vm_end, align 8
  %5 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_start = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %5, i32 0, i32 0
  %6 = load i64, i64* %vm_start, align 8
  %sub = sub i64 %4, %6
  store i64 %sub, i64* %size, align 8
  %7 = load i64, i64* %size, align 8
  %add = add i64 %7, 64
  %call = call i32 @usbfs_increase_memory_usage(i64 %add)
  store i32 %call, i32* %ret, align 4
  %8 = load i32, i32* %ret, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %error

if.end:                                           ; preds = %entry
  %call1 = call i8* @kzalloc(i64 64, i32 20971712)
  %9 = bitcast i8* %call1 to %struct.usb_memory*
  store %struct.usb_memory* %9, %struct.usb_memory** %usbm, align 8
  %10 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %tobool2 = icmp ne %struct.usb_memory* %10, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store i32 -12, i32* %ret, align 4
  br label %error_decrease_mem

if.end4:                                          ; preds = %if.end
  %11 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %11, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %13 = load i64, i64* %size, align 8
  %call5 = call i8* @usb_alloc_coherent(%struct.usb_device* %12, i64 %13, i32 21103296, i64* %dma_handle)
  store i8* %call5, i8** %mem, align 8
  %14 = load i8*, i8** %mem, align 8
  %tobool6 = icmp ne i8* %14, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end4
  store i32 -12, i32* %ret, align 4
  br label %error_free_usbm

if.end8:                                          ; preds = %if.end4
  %15 = load i8*, i8** %mem, align 8
  %16 = load i64, i64* %size, align 8
  call void @llvm.memset.p0i8.i64(i8* %15, i8 0, i64 %16, i32 1, i1 false)
  %17 = load i8*, i8** %mem, align 8
  %18 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %mem9 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %18, i32 0, i32 4
  store i8* %17, i8** %mem9, align 8
  %19 = load i64, i64* %dma_handle, align 8
  %20 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %dma_handle10 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %20, i32 0, i32 5
  store i64 %19, i64* %dma_handle10, align 8
  %21 = load i64, i64* %size, align 8
  %conv = trunc i64 %21 to i32
  %22 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %size11 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %22, i32 0, i32 3
  store i32 %conv, i32* %size11, align 8
  %23 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %24 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %ps12 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %24, i32 0, i32 7
  store %struct.usb_dev_state* %23, %struct.usb_dev_state** %ps12, align 8
  %25 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_start13 = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %25, i32 0, i32 0
  %26 = load i64, i64* %vm_start13, align 8
  %27 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %vm_start14 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %27, i32 0, i32 6
  store i64 %26, i64* %vm_start14, align 8
  %28 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %28, i32 0, i32 1
  store i32 1, i32* %vma_use_count, align 8
  %29 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %memlist = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %29, i32 0, i32 0
  call void @INIT_LIST_HEAD(%struct.list_head* %memlist)
  %30 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %31 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_start15 = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %31, i32 0, i32 0
  %32 = load i64, i64* %vm_start15, align 8
  %33 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %mem16 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %33, i32 0, i32 4
  %34 = load i8*, i8** %mem16, align 8
  %call17 = call i64 @virt_to_phys(i8* %34)
  %shr = lshr i64 %call17, 12
  %35 = load i64, i64* %size, align 8
  %36 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_page_prot = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %36, i32 0, i32 7
  %coerce.dive = getelementptr inbounds %struct.pgprot, %struct.pgprot* %vm_page_prot, i32 0, i32 0
  %37 = load i64, i64* %coerce.dive, align 8
  %call18 = call i32 @remap_pfn_range(%struct.vm_area_struct* %30, i64 %32, i64 %shr, i64 %35, i64 %37)
  %cmp = icmp slt i32 %call18, 0
  br i1 %cmp, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end8
  %38 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %39 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %vma_use_count21 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %39, i32 0, i32 1
  call void @dec_usb_memory_use_count(%struct.usb_memory* %38, i32* %vma_use_count21)
  store i32 -11, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end8
  %40 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_flags = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %40, i32 0, i32 8
  %41 = load i64, i64* %vm_flags, align 8
  %or = or i64 %41, 16384
  store i64 %or, i64* %vm_flags, align 8
  %42 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_flags23 = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %42, i32 0, i32 8
  %43 = load i64, i64* %vm_flags23, align 8
  %or24 = or i64 %43, 67371008
  store i64 %or24, i64* %vm_flags23, align 8
  %44 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_ops = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %44, i32 0, i32 12
  store %struct.vm_operations_struct* @usbdev_vm_ops, %struct.vm_operations_struct** %vm_ops, align 8
  %45 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %46 = bitcast %struct.usb_memory* %45 to i8*
  %47 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_private_data = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %47, i32 0, i32 15
  store i8* %46, i8** %vm_private_data, align 8
  br label %do.body

do.body:                                          ; preds = %if.end22
  br label %do.body25

do.body25:                                        ; preds = %do.body
  %cmp26 = icmp eq i64* %__dummy, %__dummy2
  %conv27 = zext i1 %cmp26 to i32
  store i32 1, i32* %tmp, align 4
  %48 = load i32, i32* %tmp, align 4
  %49 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %49, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %50 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %51 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %50, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %51 to %struct.raw_spinlock*
  %call29 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  store i64 %call29, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body25
  br label %do.end30

do.end30:                                         ; preds = %do.end
  %52 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %memlist31 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %52, i32 0, i32 0
  %53 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %memory_list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %53, i32 0, i32 6
  call void @list_add_tail(%struct.list_head* %memlist31, %struct.list_head* %memory_list)
  %54 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock32 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %54, i32 0, i32 3
  %55 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock32, %struct.spinlock** %lock.addr.i34, align 8
  store i64 %55, i64* %flags.addr.i, align 8
  store i32 1, i32* %tmp.i, align 4
  %56 = load i32, i32* %tmp.i, align 4
  %57 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i34, align 8
  %58 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %57, i32 0, i32 0
  %rlock.i35 = bitcast %union.anon* %58 to %struct.raw_spinlock*
  %59 = load i64, i64* %flags.addr.i, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i35, i64 %59) #4
  store i32 0, i32* %retval, align 4
  br label %return

error_free_usbm:                                  ; preds = %if.then7
  %60 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %61 = bitcast %struct.usb_memory* %60 to i8*
  call void @kfree(i8* %61)
  br label %error_decrease_mem

error_decrease_mem:                               ; preds = %error_free_usbm, %if.then3
  %62 = load i64, i64* %size, align 8
  %add33 = add i64 %62, 64
  call void @usbfs_decrease_memory_usage(i64 %add33)
  br label %error

error:                                            ; preds = %error_decrease_mem, %if.then
  %63 = load i32, i32* %ret, align 4
  store i32 %63, i32* %retval, align 4
  br label %return

return:                                           ; preds = %error, %do.end30, %if.then20
  %64 = load i32, i32* %retval, align 4
  ret i32 %64
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbdev_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %pfo_ret__.i51 = alloca %struct.task_struct*, align 8
  %tmp.i52 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i49 = alloca %struct.task_struct*, align 8
  %tmp.i50 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i47 = alloca %struct.task_struct*, align 8
  %tmp.i48 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i45 = alloca %struct.task_struct*, align 8
  %tmp.i46 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %retval = alloca i32, align 4
  %inode.addr = alloca %struct.inode*, align 8
  %file.addr = alloca %struct.file*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %ret = alloca i32, align 4
  %.compoundliteral = alloca %struct.raw_spinlock, align 4
  %tmp = alloca %struct.cred*, align 8
  store %struct.inode* %inode, %struct.inode** %inode.addr, align 8
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store %struct.usb_device* null, %struct.usb_device** %dev, align 8
  store i32 -12, i32* %ret, align 4
  %call = call i8* @kzalloc(i64 176, i32 20971712)
  %0 = bitcast i8* %call to %struct.usb_dev_state*
  store %struct.usb_dev_state* %0, %struct.usb_dev_state** %ps, align 8
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %tobool = icmp ne %struct.usb_dev_state* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %out_free_ps

if.end:                                           ; preds = %entry
  store i32 -19, i32* %ret, align 4
  call void @mutex_lock(%struct.mutex* @usbfs_mutex)
  %2 = load %struct.inode*, %struct.inode** %inode.addr, align 8
  %call1 = call i32 @imajor(%struct.inode* %2)
  %cmp = icmp eq i32 %call1, 189
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %3 = load %struct.inode*, %struct.inode** %inode.addr, align 8
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %3, i32 0, i32 13
  %4 = load i32, i32* %i_rdev, align 4
  %call3 = call %struct.usb_device* @usbdev_lookup_by_devt(i32 %4)
  store %struct.usb_device* %call3, %struct.usb_device** %dev, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  call void @mutex_unlock(%struct.mutex* @usbfs_mutex)
  %5 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %tobool5 = icmp ne %struct.usb_device* %5, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end4
  br label %out_free_ps

if.end7:                                          ; preds = %if.end4
  %6 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 11
  call void @device_lock(%struct.device* %dev8)
  %7 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 3
  %8 = load i32, i32* %state, align 8
  %cmp9 = icmp eq i32 %8, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  br label %out_unlock_device

if.end11:                                         ; preds = %if.end7
  %9 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %call12 = call i32 @usb_autoresume_device(%struct.usb_device* %9)
  store i32 %call12, i32* %ret, align 4
  %10 = load i32, i32* %ret, align 4
  %tobool13 = icmp ne i32 %10, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end11
  br label %out_unlock_device

if.end15:                                         ; preds = %if.end11
  %11 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %12 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %dev16 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %12, i32 0, i32 1
  store %struct.usb_device* %11, %struct.usb_device** %dev16, align 8
  %13 = load %struct.file*, %struct.file** %file.addr, align 8
  %14 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %file17 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %14, i32 0, i32 2
  store %struct.file* %13, %struct.file** %file17, align 8
  %15 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %interface_allowed_mask = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %15, i32 0, i32 16
  store i64 4294967295, i64* %interface_allowed_mask, align 8
  br label %do.body

do.body:                                          ; preds = %if.end15
  %16 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %16, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %17 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %18 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %17, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %18 to %struct.raw_spinlock*
  br label %do.body19

do.body19:                                        ; preds = %do.body
  %19 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock20 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %19, i32 0, i32 3
  %20 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock20, i32 0, i32 0
  %rlock = bitcast %union.anon* %20 to %struct.raw_spinlock*
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %.compoundliteral, i32 0, i32 0
  %val = getelementptr inbounds %struct.qspinlock, %struct.qspinlock* %raw_lock, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %val, i32 0, i32 0
  store i32 0, i32* %counter, align 4
  %21 = bitcast %struct.raw_spinlock* %rlock to i8*
  %22 = bitcast %struct.raw_spinlock* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 4, i32 4, i1 false)
  br label %do.end

do.end:                                           ; preds = %do.body19
  br label %do.end21

do.end21:                                         ; preds = %do.end
  %23 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %23, i32 0, i32 0
  call void @INIT_LIST_HEAD(%struct.list_head* %list)
  %24 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %24, i32 0, i32 4
  call void @INIT_LIST_HEAD(%struct.list_head* %async_pending)
  %25 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %async_completed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %25, i32 0, i32 5
  call void @INIT_LIST_HEAD(%struct.list_head* %async_completed)
  %26 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %memory_list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %26, i32 0, i32 6
  call void @INIT_LIST_HEAD(%struct.list_head* %memory_list)
  br label %do.body22

do.body22:                                        ; preds = %do.end21
  %27 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %wait = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %27, i32 0, i32 7
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.60, i32 0, i32 0), %struct.lock_class_key* @usbdev_open.__key)
  br label %do.end23

do.end23:                                         ; preds = %do.body22
  %28 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %28, %struct.task_struct** %pfo_ret__.i, align 8
  %29 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %29, %struct.task_struct** %tmp.i, align 8
  %30 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call25 = call %struct.pid* @task_pid(%struct.task_struct* %30)
  %call26 = call %struct.pid* @get_pid(%struct.pid* %call25)
  %31 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %disc_pid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %31, i32 0, i32 9
  store %struct.pid* %call26, %struct.pid** %disc_pid, align 8
  br label %do.body27

do.body27:                                        ; preds = %do.end23
  br label %do.end28

do.end28:                                         ; preds = %do.body27
  %32 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %32, %struct.task_struct** %pfo_ret__.i45, align 8
  %33 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i45, align 8
  store %struct.task_struct* %33, %struct.task_struct** %tmp.i46, align 8
  %34 = load %struct.task_struct*, %struct.task_struct** %tmp.i46, align 8
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %34, i32 0, i32 76
  %35 = load %struct.cred*, %struct.cred** %cred, align 32
  store %struct.cred* %35, %struct.cred** %tmp, align 8
  %36 = load %struct.cred*, %struct.cred** %tmp, align 8
  %call30 = call %struct.cred* @get_cred(%struct.cred* %36)
  %37 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %cred31 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %37, i32 0, i32 10
  store %struct.cred* %call30, %struct.cred** %cred31, align 8
  %38 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %38, %struct.task_struct** %pfo_ret__.i47, align 8
  %39 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i47, align 8
  store %struct.task_struct* %39, %struct.task_struct** %tmp.i48, align 8
  %40 = load %struct.task_struct*, %struct.task_struct** %tmp.i48, align 8
  %41 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %secid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %41, i32 0, i32 13
  call void @security_task_getsecid(%struct.task_struct* %40, i32* %secid)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !4
  %42 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %list33 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %42, i32 0, i32 0
  %43 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %43, i32 0, i32 27
  call void @list_add_tail(%struct.list_head* %list33, %struct.list_head* %filelist)
  %44 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %45 = bitcast %struct.usb_dev_state* %44 to i8*
  %46 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %46, i32 0, i32 15
  store i8* %45, i8** %private_data, align 8
  %47 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %47, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev34)
  br label %do.body35

do.body35:                                        ; preds = %do.end28
  %48 = load i8, i8* @usbfs_snoop, align 1
  %tobool36 = trunc i8 %48 to i1
  br i1 %tobool36, label %if.then37, label %if.end42

if.then37:                                        ; preds = %do.body35
  %49 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %49, i32 0, i32 11
  %50 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %50, %struct.task_struct** %pfo_ret__.i49, align 8
  %51 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i49, align 8
  store %struct.task_struct* %51, %struct.task_struct** %tmp.i50, align 8
  %52 = load %struct.task_struct*, %struct.task_struct** %tmp.i50, align 8
  %call40 = call i32 @task_pid_nr(%struct.task_struct* %52)
  %53 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %53, %struct.task_struct** %pfo_ret__.i51, align 8
  %54 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i51, align 8
  store %struct.task_struct* %54, %struct.task_struct** %tmp.i52, align 8
  %55 = load %struct.task_struct*, %struct.task_struct** %tmp.i52, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %55, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev38, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.61, i32 0, i32 0), i32 %call40, i8* %arraydecay)
  br label %if.end42

if.end42:                                         ; preds = %if.then37, %do.body35
  br label %do.end43

do.end43:                                         ; preds = %if.end42
  %56 = load i32, i32* %ret, align 4
  store i32 %56, i32* %retval, align 4
  br label %return

out_unlock_device:                                ; preds = %if.then14, %if.then10
  %57 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev44 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %57, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev44)
  %58 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  call void @usb_put_dev(%struct.usb_device* %58)
  br label %out_free_ps

out_free_ps:                                      ; preds = %out_unlock_device, %if.then6, %if.then
  %59 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %60 = bitcast %struct.usb_dev_state* %59 to i8*
  call void @kfree(i8* %60)
  %61 = load i32, i32* %ret, align 4
  store i32 %61, i32* %retval, align 4
  br label %return

return:                                           ; preds = %out_free_ps, %do.end43
  %62 = load i32, i32* %retval, align 4
  ret i32 %62
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbdev_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %nr.addr.i16 = alloca i64, align 8
  %addr.addr.i17 = alloca i64*, align 8
  %oldbit.i = alloca i8, align 1
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %inode.addr = alloca %struct.inode*, align 8
  %file.addr = alloca %struct.file*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %ifnum = alloca i32, align 4
  %as = alloca %struct.async*, align 8
  store %struct.inode* %inode, %struct.inode** %inode.addr, align 8
  store %struct.file* %file, %struct.file** %file.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8
  %2 = bitcast i8* %1 to %struct.usb_dev_state*
  store %struct.usb_dev_state* %2, %struct.usb_dev_state** %ps, align 8
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %4, %struct.usb_device** %dev, align 8
  %5 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %5, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  %6 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %7 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  call void @usb_hub_release_all_ports(%struct.usb_device* %6, %struct.usb_dev_state* %7)
  %8 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %8, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %list)
  store i32 0, i32* %ifnum, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %9, i32 0, i32 12
  %10 = load i64, i64* %ifclaimed, align 8
  %tobool = icmp ne i64 %10, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %11 = load i32, i32* %ifnum, align 4
  %conv = zext i32 %11 to i64
  %cmp = icmp ult i64 %conv, 64
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %12 = phi i1 [ false, %for.cond ], [ %cmp, %land.rhs ]
  br i1 %12, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %13 = load i32, i32* %ifnum, align 4
  %conv4 = zext i32 %13 to i64
  %14 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %ifclaimed5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %14, i32 0, i32 12
  store i64 %conv4, i64* %nr.addr.i, align 8
  store i64* %ifclaimed5, i64** %addr.addr.i, align 8
  %15 = load i64, i64* %nr.addr.i, align 8
  %and.i = and i64 %15, 63
  %shl.i = shl i64 1, %and.i
  %16 = load i64*, i64** %addr.addr.i, align 8
  %17 = load i64, i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %17, 6
  %arrayidx.i = getelementptr inbounds i64, i64* %16, i64 %shr.i
  %18 = load volatile i64, i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %18
  %cmp.i = icmp ne i64 %and1.i, 0
  br i1 %cmp.i, label %if.then, label %if.end

cond.false:                                       ; preds = %for.body
  %19 = load i32, i32* %ifnum, align 4
  %conv7 = zext i32 %19 to i64
  %20 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %ifclaimed8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %20, i32 0, i32 12
  store i64 %conv7, i64* %nr.addr.i16, align 8
  store i64* %ifclaimed8, i64** %addr.addr.i17, align 8
  %21 = load i64*, i64** %addr.addr.i17, align 8
  %22 = load i64, i64* %nr.addr.i16, align 8
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %21, i64 %22) #4, !srcloc !5
  %23 = load i8, i8* %oldbit.i, align 1
  %tobool.i = trunc i8 %23 to i1
  br i1 %tobool.i, label %if.then, label %if.end

if.then:                                          ; preds = %cond.false, %cond.true
  %24 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %25 = load i32, i32* %ifnum, align 4
  %call11 = call i32 @releaseintf(%struct.usb_dev_state* %24, i32 %25)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.false, %cond.true
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %26 = load i32, i32* %ifnum, align 4
  %inc = add i32 %26, 1
  store i32 %inc, i32* %ifnum, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  %27 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  call void @destroy_all_async(%struct.usb_dev_state* %27)
  %28 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  call void @usb_autosuspend_device(%struct.usb_device* %28)
  %29 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %29, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev12)
  %30 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  call void @usb_put_dev(%struct.usb_device* %30)
  %31 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %disc_pid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %31, i32 0, i32 9
  %32 = load %struct.pid*, %struct.pid** %disc_pid, align 8
  call void @put_pid(%struct.pid* %32)
  %33 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %cred = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %33, i32 0, i32 10
  %34 = load %struct.cred*, %struct.cred** %cred, align 8
  call void @put_cred(%struct.cred* %34)
  %35 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %call13 = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %35)
  store %struct.async* %call13, %struct.async** %as, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %36 = load %struct.async*, %struct.async** %as, align 8
  %tobool14 = icmp ne %struct.async* %36, null
  br i1 %tobool14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %37 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %37)
  %38 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %call15 = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %38)
  store %struct.async* %call15, %struct.async** %as, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %39 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %40 = bitcast %struct.usb_dev_state* %39 to i8*
  call void @kfree(i8* %40)
  ret i32 0
}

; Function Attrs: noinline nounwind optnone uwtable
define i32 @usb_devio_init() #0 section ".init.text" {
entry:
  %retval1 = alloca i32, align 4
  %call = call i32 @register_chrdev_region(i32 198180864, i32 8192, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i32 0, i32 0))
  store i32 %call, i32* %retval1, align 4
  %0 = load i32, i32* %retval1, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.2, i32 0, i32 0))
  br label %out

if.end:                                           ; preds = %entry
  call void @cdev_init(%struct.cdev* @usb_device_cdev, %struct.file_operations* @usbdev_file_operations)
  %call3 = call i32 @cdev_add(%struct.cdev* @usb_device_cdev, i32 198180864, i32 8192)
  store i32 %call3, i32* %retval1, align 4
  %1 = load i32, i32* %retval1, align 4
  %tobool4 = icmp ne i32 %1, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.3, i32 0, i32 0), i32 189)
  br label %error_cdev

if.end7:                                          ; preds = %if.end
  call void @usb_register_notify(%struct.notifier_block* @usbdev_nb)
  br label %out

out:                                              ; preds = %error_cdev, %if.end7, %if.then
  %2 = load i32, i32* %retval1, align 4
  ret i32 %2

error_cdev:                                       ; preds = %if.then5
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  br label %out
}

declare i32 @register_chrdev_region(i32, i32, i8*) #1

declare i32 @printk(i8*, ...) #1

declare void @cdev_init(%struct.cdev*, %struct.file_operations*) #1

declare i32 @cdev_add(%struct.cdev*, i32, i32) #1

declare void @usb_register_notify(%struct.notifier_block*) #1

declare void @unregister_chrdev_region(i32, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define void @usb_devio_cleanup() #0 {
entry:
  call void @usb_unregister_notify(%struct.notifier_block* @usbdev_nb)
  call void @cdev_del(%struct.cdev* @usb_device_cdev)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  ret void
}

declare void @usb_unregister_notify(%struct.notifier_block*) #1

declare void @cdev_del(%struct.cdev*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @usb_get_intfdata(%struct.usb_interface* %intf) #0 {
entry:
  %intf.addr = alloca %struct.usb_interface*, align 8
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  %0 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 7
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare void @dev_warn(%struct.device*, i8*, ...) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @usb_set_intfdata(%struct.usb_interface* %intf, i8* %data) #0 {
entry:
  %intf.addr = alloca %struct.usb_interface*, align 8
  %data.addr = alloca i8*, align 8
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 7
  %1 = load i8*, i8** %data.addr, align 8
  call void @dev_set_drvdata(%struct.device* %dev, i8* %1)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @destroy_async_on_interface(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %lock.addr.i14 = alloca %struct.spinlock*, align 8
  %flags.addr.i = alloca i64, align 8
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %tmp.i = alloca i32, align 4
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %ifnum.addr = alloca i32, align 4
  %p = alloca %struct.list_head*, align 8
  %q = alloca %struct.list_head*, align 8
  %hitlist = alloca %struct.list_head, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__mptr = alloca %struct.list_head*, align 8
  %tmp8 = alloca %struct.async*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i32 %ifnum, i32* %ifnum.addr, align 4
  call void @INIT_LIST_HEAD(%struct.list_head* %hitlist)
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %0 = load i32, i32* %tmp, align 4
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %2 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %2, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %3 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  store i64 %call2, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.end
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %4, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %5, %struct.list_head** %p, align 8
  %6 = load %struct.list_head*, %struct.list_head** %p, align 8
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %6, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next4, align 8
  store %struct.list_head* %7, %struct.list_head** %q, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end3
  %8 = load %struct.list_head*, %struct.list_head** %p, align 8
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_pending5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %9, i32 0, i32 4
  %cmp6 = icmp ne %struct.list_head* %8, %async_pending5
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32, i32* %ifnum.addr, align 4
  %11 = load %struct.list_head*, %struct.list_head** %p, align 8
  store %struct.list_head* %11, %struct.list_head** %__mptr, align 8
  %12 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %13 = bitcast %struct.list_head* %12 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 0
  %14 = bitcast i8* %add.ptr to %struct.async*
  store %struct.async* %14, %struct.async** %tmp8, align 8
  %15 = load %struct.async*, %struct.async** %tmp8, align 8
  %ifnum9 = getelementptr inbounds %struct.async, %struct.async* %15, i32 0, i32 5
  %16 = load i32, i32* %ifnum9, align 4
  %cmp10 = icmp eq i32 %10, %16
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %17 = load %struct.list_head*, %struct.list_head** %p, align 8
  call void @list_move_tail(%struct.list_head* %17, %struct.list_head* %hitlist)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %18 = load %struct.list_head*, %struct.list_head** %q, align 8
  store %struct.list_head* %18, %struct.list_head** %p, align 8
  %19 = load %struct.list_head*, %struct.list_head** %p, align 8
  %next12 = getelementptr inbounds %struct.list_head, %struct.list_head* %19, i32 0, i32 0
  %20 = load %struct.list_head*, %struct.list_head** %next12, align 8
  store %struct.list_head* %20, %struct.list_head** %q, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %21 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock13 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %21, i32 0, i32 3
  %22 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock13, %struct.spinlock** %lock.addr.i14, align 8
  store i64 %22, i64* %flags.addr.i, align 8
  store i32 1, i32* %tmp.i, align 4
  %23 = load i32, i32* %tmp.i, align 4
  %24 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i14, align 8
  %25 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %24, i32 0, i32 0
  %rlock.i15 = bitcast %union.anon* %25 to %struct.raw_spinlock*
  %26 = load i64, i64* %flags.addr.i, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i15, i64 %26) #4
  %27 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  call void @destroy_async(%struct.usb_dev_state* %27, %struct.list_head* %hitlist)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #0 {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device*, %struct.device** %dev.addr, align 8
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 9
  %1 = load i8*, i8** %driver_data, align 8
  ret i8* %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #0 {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %data.addr = alloca i8*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load i8*, i8** %data.addr, align 8
  %1 = load %struct.device*, %struct.device** %dev.addr, align 8
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %1, i32 0, i32 9
  store i8* %0, i8** %driver_data, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #0 {
entry:
  %p.addr.i = alloca i8*, align 8
  %res.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %list.addr = alloca %struct.list_head*, align 8
  %__u = alloca %union.anon.58, align 8
  %tmp = alloca %struct.list_head*, align 8
  store %struct.list_head* %list, %struct.list_head** %list.addr, align 8
  %__val = bitcast %union.anon.58* %__u to %struct.list_head**
  %0 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  store %struct.list_head* %0, %struct.list_head** %__val, align 8
  %1 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 0
  %2 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.58* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  store i8* %2, i8** %p.addr.i, align 8
  store i8* %arraydecay, i8** %res.addr.i, align 8
  store i32 8, i32* %size.addr.i, align 4
  %3 = load i32, i32* %size.addr.i, align 4
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %3, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %3, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %3, 8
  br i1 %SwitchLeaf6, label %sw.bb3.i, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %3, 4
  br i1 %SwitchLeaf4, label %sw.bb2.i, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %3, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %3, 2
  br i1 %SwitchLeaf2, label %sw.bb1.i, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %3, 1
  br i1 %SwitchLeaf, label %sw.bb.i, label %NewDefault

sw.bb.i:                                          ; preds = %LeafBlock
  %4 = load i8*, i8** %res.addr.i, align 8
  %5 = load i8, i8* %4, align 1
  %6 = load i8*, i8** %p.addr.i, align 8
  store volatile i8 %5, i8* %6, align 1
  br label %__write_once_size.exit

sw.bb1.i:                                         ; preds = %LeafBlock1
  %7 = load i8*, i8** %res.addr.i, align 8
  %8 = bitcast i8* %7 to i16*
  %9 = load i16, i16* %8, align 2
  %10 = load i8*, i8** %p.addr.i, align 8
  %11 = bitcast i8* %10 to i16*
  store volatile i16 %9, i16* %11, align 2
  br label %__write_once_size.exit

sw.bb2.i:                                         ; preds = %LeafBlock3
  %12 = load i8*, i8** %res.addr.i, align 8
  %13 = bitcast i8* %12 to i32*
  %14 = load i32, i32* %13, align 4
  %15 = load i8*, i8** %p.addr.i, align 8
  %16 = bitcast i8* %15 to i32*
  store volatile i32 %14, i32* %16, align 4
  br label %__write_once_size.exit

sw.bb3.i:                                         ; preds = %LeafBlock5
  %17 = load i8*, i8** %res.addr.i, align 8
  %18 = bitcast i8* %17 to i64*
  %19 = load i64, i64* %18, align 8
  %20 = load i8*, i8** %p.addr.i, align 8
  %21 = bitcast i8* %20 to i64*
  store volatile i64 %19, i64* %21, align 8
  br label %__write_once_size.exit

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default.i

sw.default.i:                                     ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !6
  %22 = load i8*, i8** %p.addr.i, align 8
  %23 = load i8*, i8** %res.addr.i, align 8
  %24 = load i32, i32* %size.addr.i, align 4
  %conv.i = sext i32 %24 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %22, i8* %23, i64 %conv.i, i32 1, i1 false) #4
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !7
  br label %__write_once_size.exit

__write_once_size.exit:                           ; preds = %sw.default.i, %sw.bb3.i, %sw.bb2.i, %sw.bb1.i, %sw.bb.i
  %__val1 = bitcast %union.anon.58* %__u to %struct.list_head**
  %25 = load %struct.list_head*, %struct.list_head** %__val1, align 8
  store %struct.list_head* %25, %struct.list_head** %tmp, align 8
  %26 = load %struct.list_head*, %struct.list_head** %tmp, align 8
  %27 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %28 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %28, i32 0, i32 1
  store %struct.list_head* %27, %struct.list_head** %prev, align 8
  ret void
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: noinline nounwind optnone uwtable
define internal void @list_move_tail(%struct.list_head* %list, %struct.list_head* %head) #0 {
entry:
  %list.addr = alloca %struct.list_head*, align 8
  %head.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %list, %struct.list_head** %list.addr, align 8
  store %struct.list_head* %head, %struct.list_head** %head.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  call void @__list_del_entry(%struct.list_head* %0)
  %1 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %2 = load %struct.list_head*, %struct.list_head** %head.addr, align 8
  call void @list_add_tail(%struct.list_head* %1, %struct.list_head* %2)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @destroy_async(%struct.usb_dev_state* %ps, %struct.list_head* %list) #0 {
entry:
  %lock.addr.i30 = alloca %struct.spinlock*, align 8
  %lock.addr.i24 = alloca %struct.spinlock*, align 8
  %flags.addr.i25 = alloca i64, align 8
  %__dummy.i26 = alloca i64, align 8
  %__dummy2.i27 = alloca i64, align 8
  %tmp.i28 = alloca i32, align 4
  %lock.addr.i22 = alloca %struct.spinlock*, align 8
  %flags.addr.i = alloca i64, align 8
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %tmp.i = alloca i32, align 4
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %list.addr = alloca %struct.list_head*, align 8
  %urb = alloca %struct.urb*, align 8
  %as = alloca %struct.async*, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__mptr = alloca %struct.list_head*, align 8
  %tmp5 = alloca %struct.async*, align 8
  %__dummy11 = alloca i64, align 8
  %__dummy212 = alloca i64, align 8
  %tmp15 = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store %struct.list_head* %list, %struct.list_head** %list.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %0 = load i32, i32* %tmp, align 4
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %2 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %2, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %3 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  store i64 %call2, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.end
  br label %while.cond

while.cond:                                       ; preds = %do.end20, %do.end3
  %4 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %call4 = call i32 @list_empty(%struct.list_head* %4)
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %5, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %6, %struct.list_head** %__mptr, align 8
  %7 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr to %struct.async*
  store %struct.async* %9, %struct.async** %tmp5, align 8
  %10 = load %struct.async*, %struct.async** %tmp5, align 8
  store %struct.async* %10, %struct.async** %as, align 8
  %11 = load %struct.async*, %struct.async** %as, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  %12 = load %struct.async*, %struct.async** %as, align 8
  %urb6 = getelementptr inbounds %struct.async, %struct.async* %12, i32 0, i32 8
  %13 = load %struct.urb*, %struct.urb** %urb6, align 8
  store %struct.urb* %13, %struct.urb** %urb, align 8
  %14 = load %struct.urb*, %struct.urb** %urb, align 8
  %call7 = call %struct.urb* @usb_get_urb(%struct.urb* %14)
  %15 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %15, i32 0, i32 3
  %16 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock8, %struct.spinlock** %lock.addr.i24, align 8
  store i64 %16, i64* %flags.addr.i25, align 8
  store i32 1, i32* %tmp.i28, align 4
  %17 = load i32, i32* %tmp.i28, align 4
  %18 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i24, align 8
  %19 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %18, i32 0, i32 0
  %rlock.i29 = bitcast %union.anon* %19 to %struct.raw_spinlock*
  %20 = load i64, i64* %flags.addr.i25, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i29, i64 %20) #4
  %21 = load %struct.urb*, %struct.urb** %urb, align 8
  call void @usb_kill_urb(%struct.urb* %21)
  %22 = load %struct.urb*, %struct.urb** %urb, align 8
  call void @usb_free_urb(%struct.urb* %22)
  br label %do.body9

do.body9:                                         ; preds = %while.body
  br label %do.body10

do.body10:                                        ; preds = %do.body9
  %cmp13 = icmp eq i64* %__dummy11, %__dummy212
  %conv14 = zext i1 %cmp13 to i32
  store i32 1, i32* %tmp15, align 4
  %23 = load i32, i32* %tmp15, align 4
  %24 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock16 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %24, i32 0, i32 3
  store %struct.spinlock* %lock16, %struct.spinlock** %lock.addr.i30, align 8
  %25 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i30, align 8
  %26 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %25, i32 0, i32 0
  %rlock.i31 = bitcast %union.anon* %26 to %struct.raw_spinlock*
  %call18 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i31)
  store i64 %call18, i64* %flags, align 8
  br label %do.end19

do.end19:                                         ; preds = %do.body10
  br label %do.end20

do.end20:                                         ; preds = %do.end19
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %27 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock21 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %27, i32 0, i32 3
  %28 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock21, %struct.spinlock** %lock.addr.i22, align 8
  store i64 %28, i64* %flags.addr.i, align 8
  store i32 1, i32* %tmp.i, align 4
  %29 = load i32, i32* %tmp.i, align 4
  %30 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i22, align 8
  %31 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %30, i32 0, i32 0
  %rlock.i23 = bitcast %union.anon* %31 to %struct.raw_spinlock*
  %32 = load i64, i64* %flags.addr.i, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i23, i64 %32) #4
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: noinline nounwind optnone uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #0 {
entry:
  %entry.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %entry1, %struct.list_head** %entry.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  %call = call zeroext i1 @__list_del_entry_valid(%struct.list_head* %0)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 1
  %2 = load %struct.list_head*, %struct.list_head** %prev, align 8
  %3 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %3, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8
  call void @__list_del(%struct.list_head* %2, %struct.list_head* %4)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #0 {
entry:
  %new.addr = alloca %struct.list_head*, align 8
  %head.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %new, %struct.list_head** %new.addr, align 8
  store %struct.list_head* %head, %struct.list_head** %head.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  %1 = load %struct.list_head*, %struct.list_head** %head.addr, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 1
  %2 = load %struct.list_head*, %struct.list_head** %prev, align 8
  %3 = load %struct.list_head*, %struct.list_head** %head.addr, align 8
  call void @__list_add(%struct.list_head* %0, %struct.list_head* %2, %struct.list_head* %3)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal zeroext i1 @__list_del_entry_valid(%struct.list_head* %entry1) #0 {
entry:
  %entry.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %entry1, %struct.list_head** %entry.addr, align 8
  ret i1 true
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #0 {
entry:
  %p.addr.i = alloca i8*, align 8
  %res.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %prev.addr = alloca %struct.list_head*, align 8
  %next.addr = alloca %struct.list_head*, align 8
  %__u = alloca %union.anon.59, align 8
  %tmp = alloca %struct.list_head*, align 8
  store %struct.list_head* %prev, %struct.list_head** %prev.addr, align 8
  store %struct.list_head* %next, %struct.list_head** %next.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %prev.addr, align 8
  %1 = load %struct.list_head*, %struct.list_head** %next.addr, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 1
  store %struct.list_head* %0, %struct.list_head** %prev1, align 8
  %__val = bitcast %union.anon.59* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %next.addr, align 8
  store %struct.list_head* %2, %struct.list_head** %__val, align 8
  %3 = load %struct.list_head*, %struct.list_head** %prev.addr, align 8
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %3, i32 0, i32 0
  %4 = bitcast %struct.list_head** %next2 to i8*
  %__c = bitcast %union.anon.59* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  store i8* %4, i8** %p.addr.i, align 8
  store i8* %arraydecay, i8** %res.addr.i, align 8
  store i32 8, i32* %size.addr.i, align 4
  %5 = load i32, i32* %size.addr.i, align 4
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %5, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %5, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %5, 8
  br i1 %SwitchLeaf6, label %sw.bb3.i, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %5, 4
  br i1 %SwitchLeaf4, label %sw.bb2.i, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %5, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %5, 2
  br i1 %SwitchLeaf2, label %sw.bb1.i, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %5, 1
  br i1 %SwitchLeaf, label %sw.bb.i, label %NewDefault

sw.bb.i:                                          ; preds = %LeafBlock
  %6 = load i8*, i8** %res.addr.i, align 8
  %7 = load i8, i8* %6, align 1
  %8 = load i8*, i8** %p.addr.i, align 8
  store volatile i8 %7, i8* %8, align 1
  br label %__write_once_size.exit

sw.bb1.i:                                         ; preds = %LeafBlock1
  %9 = load i8*, i8** %res.addr.i, align 8
  %10 = bitcast i8* %9 to i16*
  %11 = load i16, i16* %10, align 2
  %12 = load i8*, i8** %p.addr.i, align 8
  %13 = bitcast i8* %12 to i16*
  store volatile i16 %11, i16* %13, align 2
  br label %__write_once_size.exit

sw.bb2.i:                                         ; preds = %LeafBlock3
  %14 = load i8*, i8** %res.addr.i, align 8
  %15 = bitcast i8* %14 to i32*
  %16 = load i32, i32* %15, align 4
  %17 = load i8*, i8** %p.addr.i, align 8
  %18 = bitcast i8* %17 to i32*
  store volatile i32 %16, i32* %18, align 4
  br label %__write_once_size.exit

sw.bb3.i:                                         ; preds = %LeafBlock5
  %19 = load i8*, i8** %res.addr.i, align 8
  %20 = bitcast i8* %19 to i64*
  %21 = load i64, i64* %20, align 8
  %22 = load i8*, i8** %p.addr.i, align 8
  %23 = bitcast i8* %22 to i64*
  store volatile i64 %21, i64* %23, align 8
  br label %__write_once_size.exit

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default.i

sw.default.i:                                     ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !6
  %24 = load i8*, i8** %p.addr.i, align 8
  %25 = load i8*, i8** %res.addr.i, align 8
  %26 = load i32, i32* %size.addr.i, align 4
  %conv.i = sext i32 %26 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* %25, i64 %conv.i, i32 1, i1 false) #4
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !7
  br label %__write_once_size.exit

__write_once_size.exit:                           ; preds = %sw.default.i, %sw.bb3.i, %sw.bb2.i, %sw.bb1.i, %sw.bb.i
  %__val3 = bitcast %union.anon.59* %__u to %struct.list_head**
  %27 = load %struct.list_head*, %struct.list_head** %__val3, align 8
  store %struct.list_head* %27, %struct.list_head** %tmp, align 8
  %28 = load %struct.list_head*, %struct.list_head** %tmp, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #0 {
entry:
  %p.addr.i = alloca i8*, align 8
  %res.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %new.addr = alloca %struct.list_head*, align 8
  %prev.addr = alloca %struct.list_head*, align 8
  %next.addr = alloca %struct.list_head*, align 8
  %__u = alloca %union.anon.60, align 8
  %tmp = alloca %struct.list_head*, align 8
  store %struct.list_head* %new, %struct.list_head** %new.addr, align 8
  store %struct.list_head* %prev, %struct.list_head** %prev.addr, align 8
  store %struct.list_head* %next, %struct.list_head** %next.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  %1 = load %struct.list_head*, %struct.list_head** %prev.addr, align 8
  %2 = load %struct.list_head*, %struct.list_head** %next.addr, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %0, %struct.list_head* %1, %struct.list_head* %2)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  %4 = load %struct.list_head*, %struct.list_head** %next.addr, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %4, i32 0, i32 1
  store %struct.list_head* %3, %struct.list_head** %prev1, align 8
  %5 = load %struct.list_head*, %struct.list_head** %next.addr, align 8
  %6 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %6, i32 0, i32 0
  store %struct.list_head* %5, %struct.list_head** %next2, align 8
  %7 = load %struct.list_head*, %struct.list_head** %prev.addr, align 8
  %8 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %8, i32 0, i32 1
  store %struct.list_head* %7, %struct.list_head** %prev3, align 8
  %__val = bitcast %union.anon.60* %__u to %struct.list_head**
  %9 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  store %struct.list_head* %9, %struct.list_head** %__val, align 8
  %10 = load %struct.list_head*, %struct.list_head** %prev.addr, align 8
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %10, i32 0, i32 0
  %11 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.60* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  store i8* %11, i8** %p.addr.i, align 8
  store i8* %arraydecay, i8** %res.addr.i, align 8
  store i32 8, i32* %size.addr.i, align 4
  %12 = load i32, i32* %size.addr.i, align 4
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %if.end
  %Pivot10 = icmp slt i32 %12, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %12, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %12, 8
  br i1 %SwitchLeaf6, label %sw.bb3.i, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %12, 4
  br i1 %SwitchLeaf4, label %sw.bb2.i, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %12, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %12, 2
  br i1 %SwitchLeaf2, label %sw.bb1.i, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %12, 1
  br i1 %SwitchLeaf, label %sw.bb.i, label %NewDefault

sw.bb.i:                                          ; preds = %LeafBlock
  %13 = load i8*, i8** %res.addr.i, align 8
  %14 = load i8, i8* %13, align 1
  %15 = load i8*, i8** %p.addr.i, align 8
  store volatile i8 %14, i8* %15, align 1
  br label %__write_once_size.exit

sw.bb1.i:                                         ; preds = %LeafBlock1
  %16 = load i8*, i8** %res.addr.i, align 8
  %17 = bitcast i8* %16 to i16*
  %18 = load i16, i16* %17, align 2
  %19 = load i8*, i8** %p.addr.i, align 8
  %20 = bitcast i8* %19 to i16*
  store volatile i16 %18, i16* %20, align 2
  br label %__write_once_size.exit

sw.bb2.i:                                         ; preds = %LeafBlock3
  %21 = load i8*, i8** %res.addr.i, align 8
  %22 = bitcast i8* %21 to i32*
  %23 = load i32, i32* %22, align 4
  %24 = load i8*, i8** %p.addr.i, align 8
  %25 = bitcast i8* %24 to i32*
  store volatile i32 %23, i32* %25, align 4
  br label %__write_once_size.exit

sw.bb3.i:                                         ; preds = %LeafBlock5
  %26 = load i8*, i8** %res.addr.i, align 8
  %27 = bitcast i8* %26 to i64*
  %28 = load i64, i64* %27, align 8
  %29 = load i8*, i8** %p.addr.i, align 8
  %30 = bitcast i8* %29 to i64*
  store volatile i64 %28, i64* %30, align 8
  br label %__write_once_size.exit

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default.i

sw.default.i:                                     ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !6
  %31 = load i8*, i8** %p.addr.i, align 8
  %32 = load i8*, i8** %res.addr.i, align 8
  %33 = load i32, i32* %size.addr.i, align 4
  %conv.i = sext i32 %33 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %31, i8* %32, i64 %conv.i, i32 1, i1 false) #4
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !7
  br label %__write_once_size.exit

__write_once_size.exit:                           ; preds = %sw.default.i, %sw.bb3.i, %sw.bb2.i, %sw.bb1.i, %sw.bb.i
  %__val5 = bitcast %union.anon.60* %__u to %struct.list_head**
  %34 = load %struct.list_head*, %struct.list_head** %__val5, align 8
  store %struct.list_head* %34, %struct.list_head** %tmp, align 8
  %35 = load %struct.list_head*, %struct.list_head** %tmp, align 8
  br label %return

return:                                           ; preds = %__write_once_size.exit, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #0 {
entry:
  %new.addr = alloca %struct.list_head*, align 8
  %prev.addr = alloca %struct.list_head*, align 8
  %next.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %new, %struct.list_head** %new.addr, align 8
  store %struct.list_head* %prev, %struct.list_head** %prev.addr, align 8
  store %struct.list_head* %next, %struct.list_head** %next.addr, align 8
  ret i1 true
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @list_empty(%struct.list_head* %head) #0 {
entry:
  %p.addr.i = alloca i8*, align 8
  %res.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %head.addr = alloca %struct.list_head*, align 8
  %__u = alloca %union.anon.61, align 8
  %tmp = alloca %struct.list_head*, align 8
  store %struct.list_head* %head, %struct.list_head** %head.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %head.addr, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.61* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  store i8* %1, i8** %p.addr.i, align 8
  store i8* %arraydecay, i8** %res.addr.i, align 8
  store i32 8, i32* %size.addr.i, align 4
  %2 = load i32, i32* %size.addr.i, align 4
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %2, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %2, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %2, 8
  br i1 %SwitchLeaf6, label %sw.bb3.i, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %2, 4
  br i1 %SwitchLeaf4, label %sw.bb2.i, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %2, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %2, 2
  br i1 %SwitchLeaf2, label %sw.bb1.i, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %2, 1
  br i1 %SwitchLeaf, label %sw.bb.i, label %NewDefault

sw.bb.i:                                          ; preds = %LeafBlock
  %3 = load i8*, i8** %p.addr.i, align 8
  %4 = load volatile i8, i8* %3, align 1
  %5 = load i8*, i8** %res.addr.i, align 8
  store i8 %4, i8* %5, align 1
  br label %__read_once_size.exit

sw.bb1.i:                                         ; preds = %LeafBlock1
  %6 = load i8*, i8** %p.addr.i, align 8
  %7 = bitcast i8* %6 to i16*
  %8 = load volatile i16, i16* %7, align 2
  %9 = load i8*, i8** %res.addr.i, align 8
  %10 = bitcast i8* %9 to i16*
  store i16 %8, i16* %10, align 2
  br label %__read_once_size.exit

sw.bb2.i:                                         ; preds = %LeafBlock3
  %11 = load i8*, i8** %p.addr.i, align 8
  %12 = bitcast i8* %11 to i32*
  %13 = load volatile i32, i32* %12, align 4
  %14 = load i8*, i8** %res.addr.i, align 8
  %15 = bitcast i8* %14 to i32*
  store i32 %13, i32* %15, align 4
  br label %__read_once_size.exit

sw.bb3.i:                                         ; preds = %LeafBlock5
  %16 = load i8*, i8** %p.addr.i, align 8
  %17 = bitcast i8* %16 to i64*
  %18 = load volatile i64, i64* %17, align 8
  %19 = load i8*, i8** %res.addr.i, align 8
  %20 = bitcast i8* %19 to i64*
  store i64 %18, i64* %20, align 8
  br label %__read_once_size.exit

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default.i

sw.default.i:                                     ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !8
  %21 = load i8*, i8** %res.addr.i, align 8
  %22 = load i8*, i8** %p.addr.i, align 8
  %23 = load i32, i32* %size.addr.i, align 4
  %conv.i = sext i32 %23 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 %conv.i, i32 1, i1 false) #4
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !9
  br label %__read_once_size.exit

__read_once_size.exit:                            ; preds = %sw.default.i, %sw.bb3.i, %sw.bb2.i, %sw.bb1.i, %sw.bb.i
  %__val = bitcast %union.anon.61* %__u to %struct.list_head**
  %24 = load %struct.list_head*, %struct.list_head** %__val, align 8
  store %struct.list_head* %24, %struct.list_head** %tmp, align 8
  %25 = load %struct.list_head*, %struct.list_head** %tmp, align 8
  %26 = load %struct.list_head*, %struct.list_head** %head.addr, align 8
  %cmp = icmp eq %struct.list_head* %25, %26
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #0 {
entry:
  %entry.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %entry1, %struct.list_head** %entry.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  call void @__list_del_entry(%struct.list_head* %0)
  %1 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  call void @INIT_LIST_HEAD(%struct.list_head* %1)
  ret void
}

declare %struct.urb* @usb_get_urb(%struct.urb*) #1

declare void @usb_kill_urb(%struct.urb*) #1

declare void @usb_free_urb(%struct.urb*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @device_lock(%struct.device* %dev) #0 {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device*, %struct.device** %dev.addr, align 8
  %mutex = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 5
  call void @mutex_lock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @connected(%struct.usb_dev_state* %ps) #0 {
entry:
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 0
  %call = call i32 @list_empty(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %3 = load i32, i32* %state, align 8
  %cmp = icmp ne i32 %3, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  ret i32 %land.ext
}

declare i8* @__memcpy(i8*, i8*, i64) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @device_unlock(%struct.device* %dev) #0 {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device*, %struct.device** %dev.addr, align 8
  %mutex = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

declare void @mutex_lock(%struct.mutex*) #1

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #3

; Function Attrs: noinline nounwind optnone uwtable
define internal void @kasan_check_read(i8* %p, i32 %size) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %size.addr = alloca i32, align 4
  store i8* %p, i8** %p.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @might_fault() #0 {
entry:
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @check_object_size(i8* %ptr, i64 %n, i1 zeroext %to_user) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %to_user.addr = alloca i8, align 1
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %frombool = zext i1 %to_user to i8
  store i8 %frombool, i8* %to_user.addr, align 1
  ret void
}

declare i64 @_copy_to_user(i8*, i8*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @copy_user_overflow(i32 %size, i64 %count) #0 {
entry:
  %size.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store i32 %size, i32* %size.addr, align 4
  store i64 %count, i64* %count.addr, align 8
  store i32 1, i32* %__ret_warn_on, align 4
  %0 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %2 = load i64, i64* %count.addr, align 8
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.5, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.6, i32 0, i32 0), i32 %1, i64 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, i32* %__ret_warn_on, align 4
  %tobool3 = icmp ne i32 %3, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  store i64 %conv8, i64* %tmp, align 8
  %4 = load i64, i64* %tmp, align 8
  ret void
}

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #1

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #0 {
entry:
  %filp.addr = alloca %struct.file*, align 8
  %wait_address.addr = alloca %struct.__wait_queue_head*, align 8
  %p.addr = alloca %struct.poll_table_struct*, align 8
  store %struct.file* %filp, %struct.file** %filp.addr, align 8
  store %struct.__wait_queue_head* %wait_address, %struct.__wait_queue_head** %wait_address.addr, align 8
  store %struct.poll_table_struct* %p, %struct.poll_table_struct** %p.addr, align 8
  %0 = load %struct.poll_table_struct*, %struct.poll_table_struct** %p.addr, align 8
  %tobool = icmp ne %struct.poll_table_struct* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.poll_table_struct*, %struct.poll_table_struct** %p.addr, align 8
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %1, i32 0, i32 0
  %2 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %2, null
  br i1 %tobool1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %3 = load %struct.__wait_queue_head*, %struct.__wait_queue_head** %wait_address.addr, align 8
  %tobool3 = icmp ne %struct.__wait_queue_head* %3, null
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true2
  %4 = load %struct.poll_table_struct*, %struct.poll_table_struct** %p.addr, align 8
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %4, i32 0, i32 0
  %5 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8
  %6 = load %struct.file*, %struct.file** %filp.addr, align 8
  %7 = load %struct.__wait_queue_head*, %struct.__wait_queue_head** %wait_address.addr, align 8
  %8 = load %struct.poll_table_struct*, %struct.poll_table_struct** %p.addr, align 8
  call void %5(%struct.file* %6, %struct.__wait_queue_head* %7, %struct.poll_table_struct* %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %p) #0 {
entry:
  %retval = alloca i64, align 8
  %file.addr = alloca %struct.file*, align 8
  %cmd.addr = alloca i32, align 4
  %p.addr = alloca i8*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %inode = alloca %struct.inode*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %ret = alloca i32, align 4
  %coerce = alloca %struct.timespec, align 8
  %coerce60 = alloca %struct.timespec, align 8
  %coerce74 = alloca %struct.timespec, align 8
  %coerce96 = alloca %struct.timespec, align 8
  %coerce142 = alloca %struct.timespec, align 8
  %coerce156 = alloca %struct.timespec, align 8
  %coerce170 = alloca %struct.timespec, align 8
  %coerce192 = alloca %struct.timespec, align 8
  %coerce274 = alloca %struct.timespec, align 8
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store i32 %cmd, i32* %cmd.addr, align 4
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8
  %2 = bitcast i8* %1 to %struct.usb_dev_state*
  store %struct.usb_dev_state* %2, %struct.usb_dev_state** %ps, align 8
  %3 = load %struct.file*, %struct.file** %file.addr, align 8
  %call = call %struct.inode* @file_inode(%struct.file* %3)
  store %struct.inode* %call, %struct.inode** %inode, align 8
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %4, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %5, %struct.usb_device** %dev, align 8
  store i32 -25, i32* %ret, align 4
  %6 = load %struct.file*, %struct.file** %file.addr, align 8
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %6, i32 0, i32 7
  %7 = load i32, i32* %f_mode, align 4
  %and = and i32 %7, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -1, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  %9 = load i32, i32* %cmd.addr, align 4
  br label %NodeBlock7

NodeBlock7:                                       ; preds = %if.end
  %Pivot8 = icmp slt i32 %9, 1074287884
  br i1 %Pivot8, label %NodeBlock, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %9, 1074287885
  br i1 %Pivot6, label %sw.bb, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %9, 1074287885
  br i1 %SwitchLeaf4, label %sw.bb8, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock7
  %Pivot = icmp slt i32 %9, 1074025741
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %9, 1074025741
  br i1 %SwitchLeaf2, label %sw.bb24, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %9, 1074025740
  br i1 %SwitchLeaf, label %sw.bb16, label %NewDefault

sw.bb:                                            ; preds = %NodeBlock5
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %10 = load i8, i8* @usbfs_snoop, align 1
  %tobool3 = trunc i8 %10 to i1
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %do.body
  %11 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %11, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev5, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end6
  %12 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %13 = load i8*, i8** %p.addr, align 8
  %call7 = call i32 @proc_reapurb(%struct.usb_dev_state* %12, i8* %13)
  store i32 %call7, i32* %ret, align 4
  br label %done

sw.bb8:                                           ; preds = %LeafBlock3
  br label %do.body9

do.body9:                                         ; preds = %sw.bb8
  %14 = load i8, i8* @usbfs_snoop, align 1
  %tobool10 = trunc i8 %14 to i1
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %do.body9
  %15 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev12, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %do.body9
  br label %do.end14

do.end14:                                         ; preds = %if.end13
  %16 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %17 = load i8*, i8** %p.addr, align 8
  %call15 = call i32 @proc_reapurbnonblock(%struct.usb_dev_state* %16, i8* %17)
  store i32 %call15, i32* %ret, align 4
  br label %done

sw.bb16:                                          ; preds = %LeafBlock
  br label %do.body17

do.body17:                                        ; preds = %sw.bb16
  %18 = load i8, i8* @usbfs_snoop, align 1
  %tobool18 = trunc i8 %18 to i1
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %do.body17
  %19 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %19, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev20, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %do.body17
  br label %do.end22

do.end22:                                         ; preds = %if.end21
  %20 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %21 = load i8*, i8** %p.addr, align 8
  %call23 = call i32 @proc_reapurb_compat(%struct.usb_dev_state* %20, i8* %21)
  store i32 %call23, i32* %ret, align 4
  br label %done

sw.bb24:                                          ; preds = %LeafBlock1
  br label %do.body25

do.body25:                                        ; preds = %sw.bb24
  %22 = load i8, i8* @usbfs_snoop, align 1
  %tobool26 = trunc i8 %22 to i1
  br i1 %tobool26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %do.body25
  %23 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev28 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %23, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev28, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %do.body25
  br label %do.end30

do.end30:                                         ; preds = %if.end29
  %24 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %25 = load i8*, i8** %p.addr, align 8
  %call31 = call i32 @proc_reapurbnonblock_compat(%struct.usb_dev_state* %24, i8* %25)
  store i32 %call31, i32* %ret, align 4
  br label %done

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault
  %26 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %call32 = call i32 @connected(%struct.usb_dev_state* %26)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.end36, label %if.then34

if.then34:                                        ; preds = %sw.epilog
  %27 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev35 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %27, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev35)
  store i64 -19, i64* %retval, align 8
  br label %return

if.end36:                                         ; preds = %sw.epilog
  %28 = load i32, i32* %cmd.addr, align 4
  br label %NodeBlock106

NodeBlock106:                                     ; preds = %if.end36
  %Pivot107 = icmp slt i32 %28, -2144578294
  br i1 %Pivot107, label %NodeBlock50, label %NodeBlock104

NodeBlock104:                                     ; preds = %NodeBlock106
  %Pivot105 = icmp slt i32 %28, -1072147200
  br i1 %Pivot105, label %NodeBlock76, label %NodeBlock102

NodeBlock102:                                     ; preds = %NodeBlock104
  %Pivot103 = icmp slt i32 %28, 21780
  br i1 %Pivot103, label %NodeBlock86, label %NodeBlock100

NodeBlock100:                                     ; preds = %NodeBlock102
  %Pivot101 = icmp slt i32 %28, 1074287889
  br i1 %Pivot101, label %NodeBlock92, label %NodeBlock98

NodeBlock98:                                      ; preds = %NodeBlock100
  %Pivot99 = icmp slt i32 %28, 1090802952
  br i1 %Pivot99, label %LeafBlock94, label %LeafBlock96

LeafBlock96:                                      ; preds = %NodeBlock98
  %SwitchLeaf97 = icmp eq i32 %28, 1090802952
  br i1 %SwitchLeaf97, label %sw.bb98, label %NewDefault9

LeafBlock94:                                      ; preds = %NodeBlock98
  %SwitchLeaf95 = icmp eq i32 %28, 1074287889
  br i1 %SwitchLeaf95, label %sw.bb106, label %NewDefault9

NodeBlock92:                                      ; preds = %NodeBlock100
  %Pivot93 = icmp slt i32 %28, 1074025758
  br i1 %Pivot93, label %LeafBlock88, label %LeafBlock90

LeafBlock90:                                      ; preds = %NodeBlock92
  %SwitchLeaf91 = icmp eq i32 %28, 1074025758
  br i1 %SwitchLeaf91, label %sw.bb267, label %NewDefault9

LeafBlock88:                                      ; preds = %NodeBlock92
  %SwitchLeaf89 = icmp eq i32 %28, 21780
  br i1 %SwitchLeaf89, label %sw.bb76, label %NewDefault9

NodeBlock86:                                      ; preds = %NodeBlock102
  %Pivot87 = icmp slt i32 %28, -1072147198
  br i1 %Pivot87, label %LeafBlock78, label %NodeBlock84

NodeBlock84:                                      ; preds = %NodeBlock86
  %Pivot85 = icmp slt i32 %28, 21771
  br i1 %Pivot85, label %LeafBlock80, label %LeafBlock82

LeafBlock82:                                      ; preds = %NodeBlock84
  %SwitchLeaf83 = icmp eq i32 %28, 21771
  br i1 %SwitchLeaf83, label %sw.bb203, label %NewDefault9

LeafBlock80:                                      ; preds = %NodeBlock84
  %SwitchLeaf81 = icmp eq i32 %28, -1072147198
  br i1 %SwitchLeaf81, label %sw.bb48, label %NewDefault9

LeafBlock78:                                      ; preds = %NodeBlock86
  %SwitchLeaf79 = icmp eq i32 %28, -1072147200
  br i1 %SwitchLeaf79, label %sw.bb37, label %NewDefault9

NodeBlock76:                                      ; preds = %NodeBlock104
  %Pivot77 = icmp slt i32 %28, -1072933614
  br i1 %Pivot77, label %NodeBlock60, label %NodeBlock74

NodeBlock74:                                      ; preds = %NodeBlock76
  %Pivot75 = icmp slt i32 %28, -1072671486
  br i1 %Pivot75, label %NodeBlock66, label %NodeBlock72

NodeBlock72:                                      ; preds = %NodeBlock74
  %Pivot73 = icmp slt i32 %28, -1072671470
  br i1 %Pivot73, label %LeafBlock68, label %LeafBlock70

LeafBlock70:                                      ; preds = %NodeBlock72
  %SwitchLeaf71 = icmp eq i32 %28, -1072671470
  br i1 %SwitchLeaf71, label %sw.bb235, label %NewDefault9

LeafBlock68:                                      ; preds = %NodeBlock72
  %SwitchLeaf69 = icmp eq i32 %28, -1072671486
  br i1 %SwitchLeaf69, label %sw.bb158, label %NewDefault9

NodeBlock66:                                      ; preds = %NodeBlock74
  %Pivot67 = icmp slt i32 %28, -1072671488
  br i1 %Pivot67, label %LeafBlock62, label %LeafBlock64

LeafBlock64:                                      ; preds = %NodeBlock66
  %SwitchLeaf65 = icmp eq i32 %28, -1072671488
  br i1 %SwitchLeaf65, label %sw.bb144, label %NewDefault9

LeafBlock62:                                      ; preds = %NodeBlock66
  %SwitchLeaf63 = icmp eq i32 %28, -1072933614
  br i1 %SwitchLeaf63, label %sw.bb194, label %NewDefault9

NodeBlock60:                                      ; preds = %NodeBlock76
  %Pivot61 = icmp slt i32 %28, -2143791862
  br i1 %Pivot61, label %LeafBlock52, label %NodeBlock58

NodeBlock58:                                      ; preds = %NodeBlock60
  %Pivot59 = icmp slt i32 %28, -2130160357
  br i1 %Pivot59, label %LeafBlock54, label %LeafBlock56

LeafBlock56:                                      ; preds = %NodeBlock58
  %SwitchLeaf57 = icmp eq i32 %28, -2130160357
  br i1 %SwitchLeaf57, label %sw.bb261, label %NewDefault9

LeafBlock54:                                      ; preds = %NodeBlock58
  %SwitchLeaf55 = icmp eq i32 %28, -2143791862
  br i1 %SwitchLeaf55, label %sw.bb130, label %NewDefault9

LeafBlock52:                                      ; preds = %NodeBlock60
  %SwitchLeaf53 = icmp eq i32 %28, -2144578294
  br i1 %SwitchLeaf53, label %sw.bb180, label %NewDefault9

NodeBlock50:                                      ; preds = %NodeBlock106
  %Pivot51 = icmp slt i32 %28, -2147199719
  br i1 %Pivot51, label %NodeBlock26, label %NodeBlock48

NodeBlock48:                                      ; preds = %NodeBlock50
  %Pivot49 = icmp slt i32 %28, -2146937586
  br i1 %Pivot49, label %NodeBlock34, label %NodeBlock46

NodeBlock46:                                      ; preds = %NodeBlock48
  %Pivot47 = icmp slt i32 %28, -2146937571
  br i1 %Pivot47, label %NodeBlock38, label %NodeBlock44

NodeBlock44:                                      ; preds = %NodeBlock46
  %Pivot45 = icmp slt i32 %28, -2146413298
  br i1 %Pivot45, label %LeafBlock40, label %LeafBlock42

LeafBlock42:                                      ; preds = %NodeBlock44
  %SwitchLeaf43 = icmp eq i32 %28, -2146413298
  br i1 %SwitchLeaf43, label %sw.bb211, label %NewDefault9

LeafBlock40:                                      ; preds = %NodeBlock44
  %SwitchLeaf41 = icmp eq i32 %28, -2146937571
  br i1 %SwitchLeaf41, label %sw.bb265, label %NewDefault9

NodeBlock38:                                      ; preds = %NodeBlock46
  %Pivot39 = icmp slt i32 %28, -2146937572
  br i1 %Pivot39, label %LeafBlock36, label %sw.bb263

LeafBlock36:                                      ; preds = %NodeBlock38
  %SwitchLeaf37 = icmp eq i32 %28, -2146937586
  br i1 %SwitchLeaf37, label %sw.bb172, label %NewDefault9

NodeBlock34:                                      ; preds = %NodeBlock48
  %Pivot35 = icmp slt i32 %28, -2147199718
  br i1 %Pivot35, label %sw.bb251, label %NodeBlock32

NodeBlock32:                                      ; preds = %NodeBlock34
  %Pivot33 = icmp slt i32 %28, -2146937596
  br i1 %Pivot33, label %LeafBlock28, label %LeafBlock30

LeafBlock30:                                      ; preds = %NodeBlock32
  %SwitchLeaf31 = icmp eq i32 %28, -2146937596
  br i1 %SwitchLeaf31, label %sw.bb114, label %NewDefault9

LeafBlock28:                                      ; preds = %NodeBlock32
  %SwitchLeaf29 = icmp eq i32 %28, -2147199718
  br i1 %SwitchLeaf29, label %sw.bb259, label %NewDefault9

NodeBlock26:                                      ; preds = %NodeBlock50
  %Pivot27 = icmp slt i32 %28, -2147199728
  br i1 %Pivot27, label %NodeBlock16, label %NodeBlock24

NodeBlock24:                                      ; preds = %NodeBlock26
  %Pivot25 = icmp slt i32 %28, -2147199723
  br i1 %Pivot25, label %LeafBlock18, label %NodeBlock22

NodeBlock22:                                      ; preds = %NodeBlock24
  %Pivot23 = icmp slt i32 %28, -2147199720
  br i1 %Pivot23, label %LeafBlock20, label %sw.bb243

LeafBlock20:                                      ; preds = %NodeBlock22
  %SwitchLeaf21 = icmp eq i32 %28, -2147199723
  br i1 %SwitchLeaf21, label %sw.bb84, label %NewDefault9

LeafBlock18:                                      ; preds = %NodeBlock24
  %SwitchLeaf19 = icmp eq i32 %28, -2147199728
  br i1 %SwitchLeaf19, label %sw.bb227, label %NewDefault9

NodeBlock16:                                      ; preds = %NodeBlock26
  %Pivot17 = icmp slt i32 %28, -2147199739
  br i1 %Pivot17, label %LeafBlock10, label %NodeBlock14

NodeBlock14:                                      ; preds = %NodeBlock16
  %Pivot15 = icmp slt i32 %28, -2147199729
  br i1 %Pivot15, label %LeafBlock12, label %sw.bb219

LeafBlock12:                                      ; preds = %NodeBlock14
  %SwitchLeaf13 = icmp eq i32 %28, -2147199739
  br i1 %SwitchLeaf13, label %sw.bb122, label %NewDefault9

LeafBlock10:                                      ; preds = %NodeBlock16
  %SwitchLeaf11 = icmp eq i32 %28, -2147199741
  br i1 %SwitchLeaf11, label %sw.bb62, label %NewDefault9

sw.bb37:                                          ; preds = %LeafBlock78
  br label %do.body38

do.body38:                                        ; preds = %sw.bb37
  %29 = load i8, i8* @usbfs_snoop, align 1
  %tobool39 = trunc i8 %29 to i1
  br i1 %tobool39, label %if.then40, label %if.end42

if.then40:                                        ; preds = %do.body38
  %30 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %30, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev41, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %do.body38
  br label %do.end43

do.end43:                                         ; preds = %if.end42
  %31 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %32 = load i8*, i8** %p.addr, align 8
  %call44 = call i32 @proc_control(%struct.usb_dev_state* %31, i8* %32)
  store i32 %call44, i32* %ret, align 4
  %33 = load i32, i32* %ret, align 4
  %cmp = icmp sge i32 %33, 0
  br i1 %cmp, label %if.then45, label %if.end47

if.then45:                                        ; preds = %do.end43
  %34 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime = getelementptr inbounds %struct.inode, %struct.inode* %34, i32 0, i32 16
  %35 = load %struct.inode*, %struct.inode** %inode, align 8
  %call46 = call { i64, i64 } @current_time(%struct.inode* %35)
  %36 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = extractvalue { i64, i64 } %call46, 0
  store i64 %38, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = extractvalue { i64, i64 } %call46, 1
  store i64 %40, i64* %39, align 8
  %41 = bitcast %struct.timespec* %i_mtime to i8*
  %42 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %41, i8* %42, i64 16, i32 8, i1 false)
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %do.end43
  br label %sw.epilog269

sw.bb48:                                          ; preds = %LeafBlock80
  br label %do.body49

do.body49:                                        ; preds = %sw.bb48
  %43 = load i8, i8* @usbfs_snoop, align 1
  %tobool50 = trunc i8 %43 to i1
  br i1 %tobool50, label %if.then51, label %if.end53

if.then51:                                        ; preds = %do.body49
  %44 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev52 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %44, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev52, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end53

if.end53:                                         ; preds = %if.then51, %do.body49
  br label %do.end54

do.end54:                                         ; preds = %if.end53
  %45 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %46 = load i8*, i8** %p.addr, align 8
  %call55 = call i32 @proc_bulk(%struct.usb_dev_state* %45, i8* %46)
  store i32 %call55, i32* %ret, align 4
  %47 = load i32, i32* %ret, align 4
  %cmp56 = icmp sge i32 %47, 0
  br i1 %cmp56, label %if.then57, label %if.end61

if.then57:                                        ; preds = %do.end54
  %48 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime58 = getelementptr inbounds %struct.inode, %struct.inode* %48, i32 0, i32 16
  %49 = load %struct.inode*, %struct.inode** %inode, align 8
  %call59 = call { i64, i64 } @current_time(%struct.inode* %49)
  %50 = bitcast %struct.timespec* %coerce60 to { i64, i64 }*
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 0
  %52 = extractvalue { i64, i64 } %call59, 0
  store i64 %52, i64* %51, align 8
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 1
  %54 = extractvalue { i64, i64 } %call59, 1
  store i64 %54, i64* %53, align 8
  %55 = bitcast %struct.timespec* %i_mtime58 to i8*
  %56 = bitcast %struct.timespec* %coerce60 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %55, i8* %56, i64 16, i32 8, i1 false)
  br label %if.end61

if.end61:                                         ; preds = %if.then57, %do.end54
  br label %sw.epilog269

sw.bb62:                                          ; preds = %LeafBlock10
  br label %do.body63

do.body63:                                        ; preds = %sw.bb62
  %57 = load i8, i8* @usbfs_snoop, align 1
  %tobool64 = trunc i8 %57 to i1
  br i1 %tobool64, label %if.then65, label %if.end67

if.then65:                                        ; preds = %do.body63
  %58 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev66 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %58, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev66, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end67

if.end67:                                         ; preds = %if.then65, %do.body63
  br label %do.end68

do.end68:                                         ; preds = %if.end67
  %59 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %60 = load i8*, i8** %p.addr, align 8
  %call69 = call i32 @proc_resetep(%struct.usb_dev_state* %59, i8* %60)
  store i32 %call69, i32* %ret, align 4
  %61 = load i32, i32* %ret, align 4
  %cmp70 = icmp sge i32 %61, 0
  br i1 %cmp70, label %if.then71, label %if.end75

if.then71:                                        ; preds = %do.end68
  %62 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime72 = getelementptr inbounds %struct.inode, %struct.inode* %62, i32 0, i32 16
  %63 = load %struct.inode*, %struct.inode** %inode, align 8
  %call73 = call { i64, i64 } @current_time(%struct.inode* %63)
  %64 = bitcast %struct.timespec* %coerce74 to { i64, i64 }*
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %64, i32 0, i32 0
  %66 = extractvalue { i64, i64 } %call73, 0
  store i64 %66, i64* %65, align 8
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %64, i32 0, i32 1
  %68 = extractvalue { i64, i64 } %call73, 1
  store i64 %68, i64* %67, align 8
  %69 = bitcast %struct.timespec* %i_mtime72 to i8*
  %70 = bitcast %struct.timespec* %coerce74 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %70, i64 16, i32 8, i1 false)
  br label %if.end75

if.end75:                                         ; preds = %if.then71, %do.end68
  br label %sw.epilog269

sw.bb76:                                          ; preds = %LeafBlock88
  br label %do.body77

do.body77:                                        ; preds = %sw.bb76
  %71 = load i8, i8* @usbfs_snoop, align 1
  %tobool78 = trunc i8 %71 to i1
  br i1 %tobool78, label %if.then79, label %if.end81

if.then79:                                        ; preds = %do.body77
  %72 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev80 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %72, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev80, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end81

if.end81:                                         ; preds = %if.then79, %do.body77
  br label %do.end82

do.end82:                                         ; preds = %if.end81
  %73 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %call83 = call i32 @proc_resetdevice(%struct.usb_dev_state* %73)
  store i32 %call83, i32* %ret, align 4
  br label %sw.epilog269

sw.bb84:                                          ; preds = %LeafBlock20
  br label %do.body85

do.body85:                                        ; preds = %sw.bb84
  %74 = load i8, i8* @usbfs_snoop, align 1
  %tobool86 = trunc i8 %74 to i1
  br i1 %tobool86, label %if.then87, label %if.end89

if.then87:                                        ; preds = %do.body85
  %75 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev88 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %75, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev88, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end89

if.end89:                                         ; preds = %if.then87, %do.body85
  br label %do.end90

do.end90:                                         ; preds = %if.end89
  %76 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %77 = load i8*, i8** %p.addr, align 8
  %call91 = call i32 @proc_clearhalt(%struct.usb_dev_state* %76, i8* %77)
  store i32 %call91, i32* %ret, align 4
  %78 = load i32, i32* %ret, align 4
  %cmp92 = icmp sge i32 %78, 0
  br i1 %cmp92, label %if.then93, label %if.end97

if.then93:                                        ; preds = %do.end90
  %79 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime94 = getelementptr inbounds %struct.inode, %struct.inode* %79, i32 0, i32 16
  %80 = load %struct.inode*, %struct.inode** %inode, align 8
  %call95 = call { i64, i64 } @current_time(%struct.inode* %80)
  %81 = bitcast %struct.timespec* %coerce96 to { i64, i64 }*
  %82 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 0
  %83 = extractvalue { i64, i64 } %call95, 0
  store i64 %83, i64* %82, align 8
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 1
  %85 = extractvalue { i64, i64 } %call95, 1
  store i64 %85, i64* %84, align 8
  %86 = bitcast %struct.timespec* %i_mtime94 to i8*
  %87 = bitcast %struct.timespec* %coerce96 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %86, i8* %87, i64 16, i32 8, i1 false)
  br label %if.end97

if.end97:                                         ; preds = %if.then93, %do.end90
  br label %sw.epilog269

sw.bb98:                                          ; preds = %LeafBlock96
  br label %do.body99

do.body99:                                        ; preds = %sw.bb98
  %88 = load i8, i8* @usbfs_snoop, align 1
  %tobool100 = trunc i8 %88 to i1
  br i1 %tobool100, label %if.then101, label %if.end103

if.then101:                                       ; preds = %do.body99
  %89 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev102 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %89, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev102, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end103

if.end103:                                        ; preds = %if.then101, %do.body99
  br label %do.end104

do.end104:                                        ; preds = %if.end103
  %90 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %91 = load i8*, i8** %p.addr, align 8
  %call105 = call i32 @proc_getdriver(%struct.usb_dev_state* %90, i8* %91)
  store i32 %call105, i32* %ret, align 4
  br label %sw.epilog269

sw.bb106:                                         ; preds = %LeafBlock94
  br label %do.body107

do.body107:                                       ; preds = %sw.bb106
  %92 = load i8, i8* @usbfs_snoop, align 1
  %tobool108 = trunc i8 %92 to i1
  br i1 %tobool108, label %if.then109, label %if.end111

if.then109:                                       ; preds = %do.body107
  %93 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev110 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %93, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev110, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end111

if.end111:                                        ; preds = %if.then109, %do.body107
  br label %do.end112

do.end112:                                        ; preds = %if.end111
  %94 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %95 = load i8*, i8** %p.addr, align 8
  %call113 = call i32 @proc_connectinfo(%struct.usb_dev_state* %94, i8* %95)
  store i32 %call113, i32* %ret, align 4
  br label %sw.epilog269

sw.bb114:                                         ; preds = %LeafBlock30
  br label %do.body115

do.body115:                                       ; preds = %sw.bb114
  %96 = load i8, i8* @usbfs_snoop, align 1
  %tobool116 = trunc i8 %96 to i1
  br i1 %tobool116, label %if.then117, label %if.end119

if.then117:                                       ; preds = %do.body115
  %97 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev118 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %97, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev118, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end119

if.end119:                                        ; preds = %if.then117, %do.body115
  br label %do.end120

do.end120:                                        ; preds = %if.end119
  %98 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %99 = load i8*, i8** %p.addr, align 8
  %call121 = call i32 @proc_setintf(%struct.usb_dev_state* %98, i8* %99)
  store i32 %call121, i32* %ret, align 4
  br label %sw.epilog269

sw.bb122:                                         ; preds = %LeafBlock12
  br label %do.body123

do.body123:                                       ; preds = %sw.bb122
  %100 = load i8, i8* @usbfs_snoop, align 1
  %tobool124 = trunc i8 %100 to i1
  br i1 %tobool124, label %if.then125, label %if.end127

if.then125:                                       ; preds = %do.body123
  %101 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev126 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %101, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev126, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end127

if.end127:                                        ; preds = %if.then125, %do.body123
  br label %do.end128

do.end128:                                        ; preds = %if.end127
  %102 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %103 = load i8*, i8** %p.addr, align 8
  %call129 = call i32 @proc_setconfig(%struct.usb_dev_state* %102, i8* %103)
  store i32 %call129, i32* %ret, align 4
  br label %sw.epilog269

sw.bb130:                                         ; preds = %LeafBlock54
  br label %do.body131

do.body131:                                       ; preds = %sw.bb130
  %104 = load i8, i8* @usbfs_snoop, align 1
  %tobool132 = trunc i8 %104 to i1
  br i1 %tobool132, label %if.then133, label %if.end135

if.then133:                                       ; preds = %do.body131
  %105 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev134 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %105, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev134, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end135

if.end135:                                        ; preds = %if.then133, %do.body131
  br label %do.end136

do.end136:                                        ; preds = %if.end135
  %106 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %107 = load i8*, i8** %p.addr, align 8
  %call137 = call i32 @proc_submiturb(%struct.usb_dev_state* %106, i8* %107)
  store i32 %call137, i32* %ret, align 4
  %108 = load i32, i32* %ret, align 4
  %cmp138 = icmp sge i32 %108, 0
  br i1 %cmp138, label %if.then139, label %if.end143

if.then139:                                       ; preds = %do.end136
  %109 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime140 = getelementptr inbounds %struct.inode, %struct.inode* %109, i32 0, i32 16
  %110 = load %struct.inode*, %struct.inode** %inode, align 8
  %call141 = call { i64, i64 } @current_time(%struct.inode* %110)
  %111 = bitcast %struct.timespec* %coerce142 to { i64, i64 }*
  %112 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %111, i32 0, i32 0
  %113 = extractvalue { i64, i64 } %call141, 0
  store i64 %113, i64* %112, align 8
  %114 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %111, i32 0, i32 1
  %115 = extractvalue { i64, i64 } %call141, 1
  store i64 %115, i64* %114, align 8
  %116 = bitcast %struct.timespec* %i_mtime140 to i8*
  %117 = bitcast %struct.timespec* %coerce142 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %116, i8* %117, i64 16, i32 8, i1 false)
  br label %if.end143

if.end143:                                        ; preds = %if.then139, %do.end136
  br label %sw.epilog269

sw.bb144:                                         ; preds = %LeafBlock64
  br label %do.body145

do.body145:                                       ; preds = %sw.bb144
  %118 = load i8, i8* @usbfs_snoop, align 1
  %tobool146 = trunc i8 %118 to i1
  br i1 %tobool146, label %if.then147, label %if.end149

if.then147:                                       ; preds = %do.body145
  %119 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev148 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %119, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev148, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.21, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end149

if.end149:                                        ; preds = %if.then147, %do.body145
  br label %do.end150

do.end150:                                        ; preds = %if.end149
  %120 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %121 = load i8*, i8** %p.addr, align 8
  %122 = bitcast i8* %121 to %struct.usbdevfs_ctrltransfer32*
  %call151 = call i32 @proc_control_compat(%struct.usb_dev_state* %120, %struct.usbdevfs_ctrltransfer32* %122)
  store i32 %call151, i32* %ret, align 4
  %123 = load i32, i32* %ret, align 4
  %cmp152 = icmp sge i32 %123, 0
  br i1 %cmp152, label %if.then153, label %if.end157

if.then153:                                       ; preds = %do.end150
  %124 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime154 = getelementptr inbounds %struct.inode, %struct.inode* %124, i32 0, i32 16
  %125 = load %struct.inode*, %struct.inode** %inode, align 8
  %call155 = call { i64, i64 } @current_time(%struct.inode* %125)
  %126 = bitcast %struct.timespec* %coerce156 to { i64, i64 }*
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %126, i32 0, i32 0
  %128 = extractvalue { i64, i64 } %call155, 0
  store i64 %128, i64* %127, align 8
  %129 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %126, i32 0, i32 1
  %130 = extractvalue { i64, i64 } %call155, 1
  store i64 %130, i64* %129, align 8
  %131 = bitcast %struct.timespec* %i_mtime154 to i8*
  %132 = bitcast %struct.timespec* %coerce156 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %131, i8* %132, i64 16, i32 8, i1 false)
  br label %if.end157

if.end157:                                        ; preds = %if.then153, %do.end150
  br label %sw.epilog269

sw.bb158:                                         ; preds = %LeafBlock68
  br label %do.body159

do.body159:                                       ; preds = %sw.bb158
  %133 = load i8, i8* @usbfs_snoop, align 1
  %tobool160 = trunc i8 %133 to i1
  br i1 %tobool160, label %if.then161, label %if.end163

if.then161:                                       ; preds = %do.body159
  %134 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev162 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %134, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev162, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end163

if.end163:                                        ; preds = %if.then161, %do.body159
  br label %do.end164

do.end164:                                        ; preds = %if.end163
  %135 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %136 = load i8*, i8** %p.addr, align 8
  %137 = bitcast i8* %136 to %struct.usbdevfs_bulktransfer32*
  %call165 = call i32 @proc_bulk_compat(%struct.usb_dev_state* %135, %struct.usbdevfs_bulktransfer32* %137)
  store i32 %call165, i32* %ret, align 4
  %138 = load i32, i32* %ret, align 4
  %cmp166 = icmp sge i32 %138, 0
  br i1 %cmp166, label %if.then167, label %if.end171

if.then167:                                       ; preds = %do.end164
  %139 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime168 = getelementptr inbounds %struct.inode, %struct.inode* %139, i32 0, i32 16
  %140 = load %struct.inode*, %struct.inode** %inode, align 8
  %call169 = call { i64, i64 } @current_time(%struct.inode* %140)
  %141 = bitcast %struct.timespec* %coerce170 to { i64, i64 }*
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %141, i32 0, i32 0
  %143 = extractvalue { i64, i64 } %call169, 0
  store i64 %143, i64* %142, align 8
  %144 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %141, i32 0, i32 1
  %145 = extractvalue { i64, i64 } %call169, 1
  store i64 %145, i64* %144, align 8
  %146 = bitcast %struct.timespec* %i_mtime168 to i8*
  %147 = bitcast %struct.timespec* %coerce170 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %146, i8* %147, i64 16, i32 8, i1 false)
  br label %if.end171

if.end171:                                        ; preds = %if.then167, %do.end164
  br label %sw.epilog269

sw.bb172:                                         ; preds = %LeafBlock36
  br label %do.body173

do.body173:                                       ; preds = %sw.bb172
  %148 = load i8, i8* @usbfs_snoop, align 1
  %tobool174 = trunc i8 %148 to i1
  br i1 %tobool174, label %if.then175, label %if.end177

if.then175:                                       ; preds = %do.body173
  %149 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev176 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %149, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev176, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end177

if.end177:                                        ; preds = %if.then175, %do.body173
  br label %do.end178

do.end178:                                        ; preds = %if.end177
  %150 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %151 = load i8*, i8** %p.addr, align 8
  %call179 = call i32 @proc_disconnectsignal_compat(%struct.usb_dev_state* %150, i8* %151)
  store i32 %call179, i32* %ret, align 4
  br label %sw.epilog269

sw.bb180:                                         ; preds = %LeafBlock52
  br label %do.body181

do.body181:                                       ; preds = %sw.bb180
  %152 = load i8, i8* @usbfs_snoop, align 1
  %tobool182 = trunc i8 %152 to i1
  br i1 %tobool182, label %if.then183, label %if.end185

if.then183:                                       ; preds = %do.body181
  %153 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev184 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %153, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev184, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end185

if.end185:                                        ; preds = %if.then183, %do.body181
  br label %do.end186

do.end186:                                        ; preds = %if.end185
  %154 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %155 = load i8*, i8** %p.addr, align 8
  %call187 = call i32 @proc_submiturb_compat(%struct.usb_dev_state* %154, i8* %155)
  store i32 %call187, i32* %ret, align 4
  %156 = load i32, i32* %ret, align 4
  %cmp188 = icmp sge i32 %156, 0
  br i1 %cmp188, label %if.then189, label %if.end193

if.then189:                                       ; preds = %do.end186
  %157 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime190 = getelementptr inbounds %struct.inode, %struct.inode* %157, i32 0, i32 16
  %158 = load %struct.inode*, %struct.inode** %inode, align 8
  %call191 = call { i64, i64 } @current_time(%struct.inode* %158)
  %159 = bitcast %struct.timespec* %coerce192 to { i64, i64 }*
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 0
  %161 = extractvalue { i64, i64 } %call191, 0
  store i64 %161, i64* %160, align 8
  %162 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 1
  %163 = extractvalue { i64, i64 } %call191, 1
  store i64 %163, i64* %162, align 8
  %164 = bitcast %struct.timespec* %i_mtime190 to i8*
  %165 = bitcast %struct.timespec* %coerce192 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %164, i8* %165, i64 16, i32 8, i1 false)
  br label %if.end193

if.end193:                                        ; preds = %if.then189, %do.end186
  br label %sw.epilog269

sw.bb194:                                         ; preds = %LeafBlock62
  br label %do.body195

do.body195:                                       ; preds = %sw.bb194
  %166 = load i8, i8* @usbfs_snoop, align 1
  %tobool196 = trunc i8 %166 to i1
  br i1 %tobool196, label %if.then197, label %if.end199

if.then197:                                       ; preds = %do.body195
  %167 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev198 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %167, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev198, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end199

if.end199:                                        ; preds = %if.then197, %do.body195
  br label %do.end200

do.end200:                                        ; preds = %if.end199
  %168 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %169 = load i8*, i8** %p.addr, align 8
  %call201 = call i32 @ptr_to_compat(i8* %169)
  %call202 = call i32 @proc_ioctl_compat(%struct.usb_dev_state* %168, i32 %call201)
  store i32 %call202, i32* %ret, align 4
  br label %sw.epilog269

sw.bb203:                                         ; preds = %LeafBlock82
  br label %do.body204

do.body204:                                       ; preds = %sw.bb203
  %170 = load i8, i8* @usbfs_snoop, align 1
  %tobool205 = trunc i8 %170 to i1
  br i1 %tobool205, label %if.then206, label %if.end208

if.then206:                                       ; preds = %do.body204
  %171 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev207 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %171, i32 0, i32 11
  %172 = load i8*, i8** %p.addr, align 8
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev207, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0), i8* %172)
  br label %if.end208

if.end208:                                        ; preds = %if.then206, %do.body204
  br label %do.end209

do.end209:                                        ; preds = %if.end208
  %173 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %174 = load i8*, i8** %p.addr, align 8
  %call210 = call i32 @proc_unlinkurb(%struct.usb_dev_state* %173, i8* %174)
  store i32 %call210, i32* %ret, align 4
  br label %sw.epilog269

sw.bb211:                                         ; preds = %LeafBlock42
  br label %do.body212

do.body212:                                       ; preds = %sw.bb211
  %175 = load i8, i8* @usbfs_snoop, align 1
  %tobool213 = trunc i8 %175 to i1
  br i1 %tobool213, label %if.then214, label %if.end216

if.then214:                                       ; preds = %do.body212
  %176 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev215 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %176, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev215, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end216

if.end216:                                        ; preds = %if.then214, %do.body212
  br label %do.end217

do.end217:                                        ; preds = %if.end216
  %177 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %178 = load i8*, i8** %p.addr, align 8
  %call218 = call i32 @proc_disconnectsignal(%struct.usb_dev_state* %177, i8* %178)
  store i32 %call218, i32* %ret, align 4
  br label %sw.epilog269

sw.bb219:                                         ; preds = %NodeBlock14
  br label %do.body220

do.body220:                                       ; preds = %sw.bb219
  %179 = load i8, i8* @usbfs_snoop, align 1
  %tobool221 = trunc i8 %179 to i1
  br i1 %tobool221, label %if.then222, label %if.end224

if.then222:                                       ; preds = %do.body220
  %180 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev223 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %180, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev223, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.28, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end224

if.end224:                                        ; preds = %if.then222, %do.body220
  br label %do.end225

do.end225:                                        ; preds = %if.end224
  %181 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %182 = load i8*, i8** %p.addr, align 8
  %call226 = call i32 @proc_claiminterface(%struct.usb_dev_state* %181, i8* %182)
  store i32 %call226, i32* %ret, align 4
  br label %sw.epilog269

sw.bb227:                                         ; preds = %LeafBlock18
  br label %do.body228

do.body228:                                       ; preds = %sw.bb227
  %183 = load i8, i8* @usbfs_snoop, align 1
  %tobool229 = trunc i8 %183 to i1
  br i1 %tobool229, label %if.then230, label %if.end232

if.then230:                                       ; preds = %do.body228
  %184 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev231 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %184, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev231, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.29, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end232

if.end232:                                        ; preds = %if.then230, %do.body228
  br label %do.end233

do.end233:                                        ; preds = %if.end232
  %185 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %186 = load i8*, i8** %p.addr, align 8
  %call234 = call i32 @proc_releaseinterface(%struct.usb_dev_state* %185, i8* %186)
  store i32 %call234, i32* %ret, align 4
  br label %sw.epilog269

sw.bb235:                                         ; preds = %LeafBlock70
  br label %do.body236

do.body236:                                       ; preds = %sw.bb235
  %187 = load i8, i8* @usbfs_snoop, align 1
  %tobool237 = trunc i8 %187 to i1
  br i1 %tobool237, label %if.then238, label %if.end240

if.then238:                                       ; preds = %do.body236
  %188 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev239 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %188, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev239, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.30, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end240

if.end240:                                        ; preds = %if.then238, %do.body236
  br label %do.end241

do.end241:                                        ; preds = %if.end240
  %189 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %190 = load i8*, i8** %p.addr, align 8
  %call242 = call i32 @proc_ioctl_default(%struct.usb_dev_state* %189, i8* %190)
  store i32 %call242, i32* %ret, align 4
  br label %sw.epilog269

sw.bb243:                                         ; preds = %NodeBlock22
  br label %do.body244

do.body244:                                       ; preds = %sw.bb243
  %191 = load i8, i8* @usbfs_snoop, align 1
  %tobool245 = trunc i8 %191 to i1
  br i1 %tobool245, label %if.then246, label %if.end248

if.then246:                                       ; preds = %do.body244
  %192 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev247 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %192, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev247, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.31, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end248

if.end248:                                        ; preds = %if.then246, %do.body244
  br label %do.end249

do.end249:                                        ; preds = %if.end248
  %193 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %194 = load i8*, i8** %p.addr, align 8
  %call250 = call i32 @proc_claim_port(%struct.usb_dev_state* %193, i8* %194)
  store i32 %call250, i32* %ret, align 4
  br label %sw.epilog269

sw.bb251:                                         ; preds = %NodeBlock34
  br label %do.body252

do.body252:                                       ; preds = %sw.bb251
  %195 = load i8, i8* @usbfs_snoop, align 1
  %tobool253 = trunc i8 %195 to i1
  br i1 %tobool253, label %if.then254, label %if.end256

if.then254:                                       ; preds = %do.body252
  %196 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev255 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %196, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev255, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end256

if.end256:                                        ; preds = %if.then254, %do.body252
  br label %do.end257

do.end257:                                        ; preds = %if.end256
  %197 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %198 = load i8*, i8** %p.addr, align 8
  %call258 = call i32 @proc_release_port(%struct.usb_dev_state* %197, i8* %198)
  store i32 %call258, i32* %ret, align 4
  br label %sw.epilog269

sw.bb259:                                         ; preds = %LeafBlock28
  %199 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %200 = load i8*, i8** %p.addr, align 8
  %call260 = call i32 @proc_get_capabilities(%struct.usb_dev_state* %199, i8* %200)
  store i32 %call260, i32* %ret, align 4
  br label %sw.epilog269

sw.bb261:                                         ; preds = %LeafBlock56
  %201 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %202 = load i8*, i8** %p.addr, align 8
  %call262 = call i32 @proc_disconnect_claim(%struct.usb_dev_state* %201, i8* %202)
  store i32 %call262, i32* %ret, align 4
  br label %sw.epilog269

sw.bb263:                                         ; preds = %NodeBlock38
  %203 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %204 = load i8*, i8** %p.addr, align 8
  %call264 = call i32 @proc_alloc_streams(%struct.usb_dev_state* %203, i8* %204)
  store i32 %call264, i32* %ret, align 4
  br label %sw.epilog269

sw.bb265:                                         ; preds = %LeafBlock40
  %205 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %206 = load i8*, i8** %p.addr, align 8
  %call266 = call i32 @proc_free_streams(%struct.usb_dev_state* %205, i8* %206)
  store i32 %call266, i32* %ret, align 4
  br label %sw.epilog269

sw.bb267:                                         ; preds = %LeafBlock90
  %207 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %208 = load i8*, i8** %p.addr, align 8
  %call268 = call i32 @proc_drop_privileges(%struct.usb_dev_state* %207, i8* %208)
  store i32 %call268, i32* %ret, align 4
  br label %sw.epilog269

NewDefault9:                                      ; preds = %LeafBlock96, %LeafBlock94, %LeafBlock90, %LeafBlock88, %LeafBlock82, %LeafBlock80, %LeafBlock78, %LeafBlock70, %LeafBlock68, %LeafBlock64, %LeafBlock62, %LeafBlock56, %LeafBlock54, %LeafBlock52, %LeafBlock42, %LeafBlock40, %LeafBlock36, %LeafBlock30, %LeafBlock28, %LeafBlock20, %LeafBlock18, %LeafBlock12, %LeafBlock10
  br label %sw.epilog269

sw.epilog269:                                     ; preds = %NewDefault9, %sw.bb267, %sw.bb265, %sw.bb263, %sw.bb261, %sw.bb259, %do.end257, %do.end249, %do.end241, %do.end233, %do.end225, %do.end217, %do.end209, %do.end200, %if.end193, %do.end178, %if.end171, %if.end157, %if.end143, %do.end128, %do.end120, %do.end112, %do.end104, %if.end97, %do.end82, %if.end75, %if.end61, %if.end47
  br label %done

done:                                             ; preds = %sw.epilog269, %do.end30, %do.end22, %do.end14, %do.end
  %209 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev270 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %209, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev270)
  %210 = load i32, i32* %ret, align 4
  %cmp271 = icmp sge i32 %210, 0
  br i1 %cmp271, label %if.then272, label %if.end275

if.then272:                                       ; preds = %done
  %211 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_atime = getelementptr inbounds %struct.inode, %struct.inode* %211, i32 0, i32 15
  %212 = load %struct.inode*, %struct.inode** %inode, align 8
  %call273 = call { i64, i64 } @current_time(%struct.inode* %212)
  %213 = bitcast %struct.timespec* %coerce274 to { i64, i64 }*
  %214 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %213, i32 0, i32 0
  %215 = extractvalue { i64, i64 } %call273, 0
  store i64 %215, i64* %214, align 8
  %216 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %213, i32 0, i32 1
  %217 = extractvalue { i64, i64 } %call273, 1
  store i64 %217, i64* %216, align 8
  %218 = bitcast %struct.timespec* %i_atime to i8*
  %219 = bitcast %struct.timespec* %coerce274 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %218, i8* %219, i64 16, i32 8, i1 false)
  br label %if.end275

if.end275:                                        ; preds = %if.then272, %done
  %220 = load i32, i32* %ret, align 4
  %conv = sext i32 %220 to i64
  store i64 %conv, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end275, %if.then34, %if.then
  %221 = load i64, i64* %retval, align 8
  ret i64 %221
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #0 {
entry:
  %f.addr = alloca %struct.file*, align 8
  store %struct.file* %f, %struct.file** %f.addr, align 8
  %0 = load %struct.file*, %struct.file** %f.addr, align 8
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 2
  %1 = load %struct.inode*, %struct.inode** %f_inode, align 8
  ret %struct.inode* %1
}

declare void @_dev_info(%struct.device*, i8*, ...) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_reapurb(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %as = alloca %struct.async*, align 8
  %retval1 = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call = call %struct.async* @reap_as(%struct.usb_dev_state* %0)
  store %struct.async* %call, %struct.async** %as, align 8
  %1 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %1, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load i8, i8* @usbfs_snoop, align 1
  %tobool2 = trunc i8 %2 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %do.body
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %5 = load %struct.async*, %struct.async** %as, align 8
  %userurb = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 7
  %6 = load i8*, i8** %userurb, align 8
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev4, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then3, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %7 = load %struct.async*, %struct.async** %as, align 8
  %8 = load i8*, i8** %arg.addr, align 8
  %9 = bitcast i8* %8 to i8**
  %call5 = call i32 @processcompl(%struct.async* %7, i8** %9)
  store i32 %call5, i32* %retval1, align 4
  %10 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %10)
  %11 = load i32, i32* %retval1, align 4
  store i32 %11, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %12 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %12, %struct.task_struct** %pfo_ret__.i, align 8
  %13 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %13, %struct.task_struct** %tmp.i, align 8
  %14 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call8 = call i32 @signal_pending(%struct.task_struct* %14)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end6
  store i32 -4, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end6
  store i32 -19, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then10, %do.end
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_reapurbnonblock(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %retval1 = alloca i32, align 4
  %as = alloca %struct.async*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %0)
  store %struct.async* %call, %struct.async** %as, align 8
  %1 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load i8, i8* @usbfs_snoop, align 1
  %tobool2 = trunc i8 %2 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %do.body
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %5 = load %struct.async*, %struct.async** %as, align 8
  %userurb = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 7
  %6 = load i8*, i8** %userurb, align 8
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev4, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then3, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %7 = load %struct.async*, %struct.async** %as, align 8
  %8 = load i8*, i8** %arg.addr, align 8
  %9 = bitcast i8* %8 to i8**
  %call5 = call i32 @processcompl(%struct.async* %7, i8** %9)
  store i32 %call5, i32* %retval1, align 4
  %10 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %10)
  br label %if.end8

if.else:                                          ; preds = %entry
  %11 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call6 = call i32 @connected(%struct.usb_dev_state* %11)
  %tobool7 = icmp ne i32 %call6, 0
  %12 = zext i1 %tobool7 to i64
  %cond = select i1 %tobool7, i32 -11, i32 -19
  store i32 %cond, i32* %retval1, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.else, %do.end
  %13 = load i32, i32* %retval1, align 4
  ret i32 %13
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_reapurb_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %as = alloca %struct.async*, align 8
  %retval1 = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call = call %struct.async* @reap_as(%struct.usb_dev_state* %0)
  store %struct.async* %call, %struct.async** %as, align 8
  %1 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %1, null
  br i1 %tobool, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load i8, i8* @usbfs_snoop, align 1
  %tobool2 = trunc i8 %2 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %do.body
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %5 = load %struct.async*, %struct.async** %as, align 8
  %userurb = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 7
  %6 = load i8*, i8** %userurb, align 8
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev4, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then3, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %7 = load %struct.async*, %struct.async** %as, align 8
  %8 = load i8*, i8** %arg.addr, align 8
  %9 = bitcast i8* %8 to i8**
  %call5 = call i32 @processcompl_compat(%struct.async* %7, i8** %9)
  store i32 %call5, i32* %retval1, align 4
  %10 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %10)
  %11 = load i32, i32* %retval1, align 4
  store i32 %11, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %12 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %12, %struct.task_struct** %pfo_ret__.i, align 8
  %13 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %13, %struct.task_struct** %tmp.i, align 8
  %14 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call8 = call i32 @signal_pending(%struct.task_struct* %14)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end6
  store i32 -4, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end6
  store i32 -19, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then10, %do.end
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_reapurbnonblock_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %retval1 = alloca i32, align 4
  %as = alloca %struct.async*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %0)
  store %struct.async* %call, %struct.async** %as, align 8
  %1 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load i8, i8* @usbfs_snoop, align 1
  %tobool2 = trunc i8 %2 to i1
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %do.body
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 11
  %5 = load %struct.async*, %struct.async** %as, align 8
  %userurb = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 7
  %6 = load i8*, i8** %userurb, align 8
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev4, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then3, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %7 = load %struct.async*, %struct.async** %as, align 8
  %8 = load i8*, i8** %arg.addr, align 8
  %9 = bitcast i8* %8 to i8**
  %call5 = call i32 @processcompl_compat(%struct.async* %7, i8** %9)
  store i32 %call5, i32* %retval1, align 4
  %10 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %10)
  br label %if.end8

if.else:                                          ; preds = %entry
  %11 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call6 = call i32 @connected(%struct.usb_dev_state* %11)
  %tobool7 = icmp ne i32 %call6, 0
  %12 = zext i1 %tobool7 to i64
  %cond = select i1 %tobool7, i32 -11, i32 -19
  store i32 %cond, i32* %retval1, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.else, %do.end
  %13 = load i32, i32* %retval1, align 4
  ret i32 %13
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_control(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %pfo_ret__.i201 = alloca %struct.task_struct*, align 8
  %tmp.i202 = alloca %struct.task_struct*, align 8
  %to.addr.i182 = alloca i8*, align 8
  %from.addr.i183 = alloca i8*, align 8
  %n.addr.i184 = alloca i64, align 8
  %sz.i185 = alloca i32, align 4
  %to.addr.i164 = alloca i8*, align 8
  %from.addr.i165 = alloca i8*, align 8
  %n.addr.i166 = alloca i64, align 8
  %sz.i167 = alloca i32, align 4
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %ctrl = alloca %struct.usbdevfs_ctrltransfer, align 8
  %tmo = alloca i32, align 4
  %tbuf = alloca i8*, align 8
  %wLength = alloca i32, align 4
  %i = alloca i32, align 4
  %pipe = alloca i32, align 4
  %ret = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp42 = alloca i8, align 1
  %__UNIQUE_ID_max1_30 = alloca i32, align 4
  %__UNIQUE_ID_max2_31 = alloca i32, align 4
  %tmp68 = alloca i32, align 4
  %__UNIQUE_ID_min1_32 = alloca i32, align 4
  %__UNIQUE_ID_min2_33 = alloca i32, align 4
  %tmp73 = alloca i32, align 4
  %__UNIQUE_ID_max1_34 = alloca i32, align 4
  %__UNIQUE_ID_max2_35 = alloca i32, align 4
  %tmp82 = alloca i32, align 4
  %__UNIQUE_ID_max1_36 = alloca i32, align 4
  %__UNIQUE_ID_max2_37 = alloca i32, align 4
  %tmp132 = alloca i32, align 4
  %__UNIQUE_ID_min1_38 = alloca i32, align 4
  %__UNIQUE_ID_min2_39 = alloca i32, align 4
  %tmp141 = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %1, %struct.usb_device** %dev, align 8
  %2 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  %3 = load i8*, i8** %arg.addr, align 8
  store i8* %2, i8** %to.addr.i, align 8
  store i8* %3, i8** %from.addr.i, align 8
  store i64 24, i64* %n.addr.i, align 8
  %4 = load i8*, i8** %to.addr.i, align 8
  %5 = call i64 @llvm.objectsize.i64.p0i8(i8* %4, i1 false, i1 true) #4
  %conv.i = trunc i64 %5 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %6 = load i8*, i8** %to.addr.i, align 8
  %7 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %7 to i32
  call void @kasan_check_write(i8* %6, i32 %conv1.i) #4
  %8 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %8, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %9 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %9 to i64
  %10 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %10
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %11 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %11, true
  %lnot.ext.i = zext i1 %11 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %11, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %12 = load i8*, i8** %to.addr.i, align 8
  %13 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %12, i64 %13, i1 zeroext false) #4
  %14 = load i8*, i8** %to.addr.i, align 8
  %15 = load i8*, i8** %from.addr.i, align 8
  %16 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %16 to i32
  %call.i = call i64 @_copy_from_user(i8* %14, i8* %15, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %17 = load i32, i32* %sz.i, align 4
  %18 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %17, i64 %18) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %19 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %19, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_from_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_from_user.exit
  %20 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %bRequestType = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %21 = load i8, i8* %bRequestType, align 8
  %conv = zext i8 %21 to i32
  %bRequest = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %22 = load i8, i8* %bRequest, align 1
  %conv2 = zext i8 %22 to i32
  %wIndex = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %23 = load i16, i16* %wIndex, align 4
  %conv3 = zext i16 %23 to i32
  %call4 = call i32 @check_ctrlrecip(%struct.usb_dev_state* %20, i32 %conv, i32 %conv2, i32 %conv3)
  store i32 %call4, i32* %ret, align 4
  %24 = load i32, i32* %ret, align 4
  %tobool5 = icmp ne i32 %24, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %25 = load i32, i32* %ret, align 4
  store i32 %25, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %wLength8 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %26 = load i16, i16* %wLength8, align 2
  %conv9 = zext i16 %26 to i32
  store i32 %conv9, i32* %wLength, align 4
  %27 = load i32, i32* %wLength, align 4
  %conv10 = zext i32 %27 to i64
  %cmp = icmp ugt i64 %conv10, 4096
  br i1 %cmp, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end7
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end7
  %call14 = call i32 @usbfs_increase_memory_usage(i64 4296)
  store i32 %call14, i32* %ret, align 4
  %28 = load i32, i32* %ret, align 4
  %tobool15 = icmp ne i32 %28, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  %29 = load i32, i32* %ret, align 4
  store i32 %29, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end13
  %call18 = call i64 @__get_free_pages(i32 20971712, i32 0)
  %30 = inttoptr i64 %call18 to i8*
  store i8* %30, i8** %tbuf, align 8
  %31 = load i8*, i8** %tbuf, align 8
  %tobool19 = icmp ne i8* %31, null
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end17
  store i32 -12, i32* %ret, align 4
  br label %done

if.end21:                                         ; preds = %if.end17
  %timeout = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 5
  %32 = load i32, i32* %timeout, align 8
  store i32 %32, i32* %tmo, align 4
  br label %do.body

do.body:                                          ; preds = %if.end21
  %33 = load i8, i8* @usbfs_snoop, align 1
  %tobool22 = trunc i8 %33 to i1
  br i1 %tobool22, label %if.then23, label %if.end34

if.then23:                                        ; preds = %do.body
  %34 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %34, i32 0, i32 11
  %bRequestType25 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %35 = load i8, i8* %bRequestType25, align 8
  %conv26 = zext i8 %35 to i32
  %bRequest27 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %36 = load i8, i8* %bRequest27, align 1
  %conv28 = zext i8 %36 to i32
  %wValue = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %37 = load i16, i16* %wValue, align 2
  %conv29 = zext i16 %37 to i32
  %wIndex30 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %38 = load i16, i16* %wIndex30, align 4
  %conv31 = zext i16 %38 to i32
  %wLength32 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %39 = load i16, i16* %wLength32, align 2
  %conv33 = zext i16 %39 to i32
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev24, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @.str.34, i32 0, i32 0), i32 %conv26, i32 %conv28, i32 %conv29, i32 %conv31, i32 %conv33)
  br label %if.end34

if.end34:                                         ; preds = %if.then23, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end34
  %bRequestType35 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %40 = load i8, i8* %bRequestType35, align 8
  %conv36 = zext i8 %40 to i32
  %and = and i32 %conv36, 128
  %tobool37 = icmp ne i32 %and, 0
  br i1 %tobool37, label %if.then38, label %if.else

if.then38:                                        ; preds = %do.end
  %wLength39 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %41 = load i16, i16* %wLength39, align 2
  %conv40 = zext i16 %41 to i32
  %tobool41 = icmp ne i32 %conv40, 0
  br i1 %tobool41, label %land.lhs.true, label %if.end53

land.lhs.true:                                    ; preds = %if.then38
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %42 = load i8*, i8** %data, align 8
  %43 = ptrtoint i8* %42 to i64
  %wLength43 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %44 = load i16, i16* %wLength43, align 2
  %conv44 = zext i16 %44 to i64
  %45 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %45, %struct.task_struct** %pfo_ret__.i, align 8
  %46 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %46, %struct.task_struct** %tmp.i, align 8
  %47 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %47, i32 0, i32 151
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %48 = load i64, i64* %seg, align 8
  %call46 = call zeroext i1 @__chk_range_not_ok(i64 %43, i64 %conv44, i64 %48)
  %frombool = zext i1 %call46 to i8
  store i8 %frombool, i8* %tmp42, align 1
  %49 = load i8, i8* %tmp42, align 1
  %tobool47 = trunc i8 %49 to i1
  %lnot = xor i1 %tobool47, true
  %lnot48 = xor i1 %lnot, true
  %lnot49 = xor i1 %lnot48, true
  %lnot.ext = zext i1 %lnot49 to i32
  %conv50 = sext i32 %lnot.ext to i64
  store i64 %conv50, i64* %tmp, align 8
  %50 = load i64, i64* %tmp, align 8
  %tobool51 = icmp ne i64 %50, 0
  br i1 %tobool51, label %if.end53, label %if.then52

if.then52:                                        ; preds = %land.lhs.true
  store i32 -22, i32* %ret, align 4
  br label %done

if.end53:                                         ; preds = %land.lhs.true, %if.then38
  %51 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %call54 = call i32 @__create_pipe(%struct.usb_device* %51, i32 0)
  %or = or i32 -2147483648, %call54
  %or55 = or i32 %or, 128
  store i32 %or55, i32* %pipe, align 4
  %52 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %53 = load i32, i32* %pipe, align 4
  %wLength56 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %54 = load i16, i16* %wLength56, align 2
  %conv57 = zext i16 %54 to i32
  %55 = load i32, i32* %tmo, align 4
  call void @snoop_urb(%struct.usb_device* %52, i8* null, i32 %53, i32 %conv57, i32 %55, i32 0, i8* null, i32 0)
  %56 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev58 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %56, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev58)
  %57 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %58 = load i32, i32* %pipe, align 4
  %bRequest59 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %59 = load i8, i8* %bRequest59, align 1
  %bRequestType60 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %60 = load i8, i8* %bRequestType60, align 8
  %wValue61 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %61 = load i16, i16* %wValue61, align 2
  %wIndex62 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %62 = load i16, i16* %wIndex62, align 4
  %63 = load i8*, i8** %tbuf, align 8
  %wLength63 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %64 = load i16, i16* %wLength63, align 2
  %65 = load i32, i32* %tmo, align 4
  %call64 = call i32 @usb_control_msg(%struct.usb_device* %57, i32 %58, i8 zeroext %59, i8 zeroext %60, i16 zeroext %61, i16 zeroext %62, i8* %63, i16 zeroext %64, i32 %65)
  store i32 %call64, i32* %i, align 4
  %66 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev65 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %66, i32 0, i32 11
  call void @device_lock(%struct.device* %dev65)
  %67 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %68 = load i32, i32* %pipe, align 4
  %69 = load i32, i32* %i, align 4
  store i32 %69, i32* %__UNIQUE_ID_max1_30, align 4
  store i32 0, i32* %__UNIQUE_ID_max2_31, align 4
  %cmp66 = icmp eq i32* %__UNIQUE_ID_max1_30, %__UNIQUE_ID_max2_31
  %conv67 = zext i1 %cmp66 to i32
  %70 = load i32, i32* %__UNIQUE_ID_max1_30, align 4
  %71 = load i32, i32* %__UNIQUE_ID_max2_31, align 4
  %cmp69 = icmp sgt i32 %70, %71
  br i1 %cmp69, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end53
  %72 = load i32, i32* %__UNIQUE_ID_max1_30, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end53
  %73 = load i32, i32* %__UNIQUE_ID_max2_31, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %72, %cond.true ], [ %73, %cond.false ]
  store i32 %cond, i32* %tmp68, align 4
  %74 = load i32, i32* %tmp68, align 4
  %75 = load i32, i32* %i, align 4
  store i32 %75, i32* %__UNIQUE_ID_min1_32, align 4
  store i32 0, i32* %__UNIQUE_ID_min2_33, align 4
  %cmp71 = icmp eq i32* %__UNIQUE_ID_min1_32, %__UNIQUE_ID_min2_33
  %conv72 = zext i1 %cmp71 to i32
  %76 = load i32, i32* %__UNIQUE_ID_min1_32, align 4
  %77 = load i32, i32* %__UNIQUE_ID_min2_33, align 4
  %cmp74 = icmp slt i32 %76, %77
  br i1 %cmp74, label %cond.true76, label %cond.false77

cond.true76:                                      ; preds = %cond.end
  %78 = load i32, i32* %__UNIQUE_ID_min1_32, align 4
  br label %cond.end78

cond.false77:                                     ; preds = %cond.end
  %79 = load i32, i32* %__UNIQUE_ID_min2_33, align 4
  br label %cond.end78

cond.end78:                                       ; preds = %cond.false77, %cond.true76
  %cond79 = phi i32 [ %78, %cond.true76 ], [ %79, %cond.false77 ]
  store i32 %cond79, i32* %tmp73, align 4
  %80 = load i32, i32* %tmp73, align 4
  %81 = load i8*, i8** %tbuf, align 8
  %82 = load i32, i32* %i, align 4
  store i32 %82, i32* %__UNIQUE_ID_max1_34, align 4
  store i32 0, i32* %__UNIQUE_ID_max2_35, align 4
  %cmp80 = icmp eq i32* %__UNIQUE_ID_max1_34, %__UNIQUE_ID_max2_35
  %conv81 = zext i1 %cmp80 to i32
  %83 = load i32, i32* %__UNIQUE_ID_max1_34, align 4
  %84 = load i32, i32* %__UNIQUE_ID_max2_35, align 4
  %cmp83 = icmp sgt i32 %83, %84
  br i1 %cmp83, label %cond.true85, label %cond.false86

cond.true85:                                      ; preds = %cond.end78
  %85 = load i32, i32* %__UNIQUE_ID_max1_34, align 4
  br label %cond.end87

cond.false86:                                     ; preds = %cond.end78
  %86 = load i32, i32* %__UNIQUE_ID_max2_35, align 4
  br label %cond.end87

cond.end87:                                       ; preds = %cond.false86, %cond.true85
  %cond88 = phi i32 [ %85, %cond.true85 ], [ %86, %cond.false86 ]
  store i32 %cond88, i32* %tmp82, align 4
  %87 = load i32, i32* %tmp82, align 4
  call void @snoop_urb(%struct.usb_device* %67, i8* null, i32 %68, i32 %74, i32 %80, i32 1, i8* %81, i32 %87)
  %88 = load i32, i32* %i, align 4
  %cmp89 = icmp sgt i32 %88, 0
  br i1 %cmp89, label %land.lhs.true91, label %if.end102

land.lhs.true91:                                  ; preds = %cond.end87
  %wLength92 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %89 = load i16, i16* %wLength92, align 2
  %conv93 = zext i16 %89 to i32
  %tobool94 = icmp ne i32 %conv93, 0
  br i1 %tobool94, label %if.then95, label %if.end102

if.then95:                                        ; preds = %land.lhs.true91
  %data96 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %90 = load i8*, i8** %data96, align 8
  %91 = load i8*, i8** %tbuf, align 8
  %92 = load i32, i32* %i, align 4
  %conv97 = sext i32 %92 to i64
  store i8* %90, i8** %to.addr.i164, align 8
  store i8* %91, i8** %from.addr.i165, align 8
  store i64 %conv97, i64* %n.addr.i166, align 8
  %93 = load i8*, i8** %from.addr.i165, align 8
  %94 = call i64 @llvm.objectsize.i64.p0i8(i8* %93, i1 false, i1 true) #4
  %conv.i168 = trunc i64 %94 to i32
  store i32 %conv.i168, i32* %sz.i167, align 4
  %95 = load i8*, i8** %from.addr.i165, align 8
  %96 = load i64, i64* %n.addr.i166, align 8
  %conv1.i169 = trunc i64 %96 to i32
  call void @kasan_check_read(i8* %95, i32 %conv1.i169) #4
  call void @might_fault() #4
  %97 = load i32, i32* %sz.i167, align 4
  %cmp.i170 = icmp slt i32 %97, 0
  br i1 %cmp.i170, label %lor.end.i177, label %lor.rhs.i173

lor.rhs.i173:                                     ; preds = %if.then95
  %98 = load i32, i32* %sz.i167, align 4
  %conv3.i171 = sext i32 %98 to i64
  %99 = load i64, i64* %n.addr.i166, align 8
  %cmp4.i172 = icmp uge i64 %conv3.i171, %99
  br label %lor.end.i177

lor.end.i177:                                     ; preds = %lor.rhs.i173, %if.then95
  %100 = phi i1 [ true, %if.then95 ], [ %cmp4.i172, %lor.rhs.i173 ]
  %lnot.i174 = xor i1 %100, true
  %lnot.ext.i175 = zext i1 %100 to i32
  %conv7.i176 = sext i32 %lnot.ext.i175 to i64
  br i1 %100, label %if.then.i180, label %if.else.i181

if.then.i180:                                     ; preds = %lor.end.i177
  %101 = load i8*, i8** %from.addr.i165, align 8
  %102 = load i64, i64* %n.addr.i166, align 8
  call void @check_object_size(i8* %101, i64 %102, i1 zeroext true) #4
  %103 = load i8*, i8** %to.addr.i164, align 8
  %104 = load i8*, i8** %from.addr.i165, align 8
  %105 = load i64, i64* %n.addr.i166, align 8
  %conv8.i178 = trunc i64 %105 to i32
  %call.i179 = call i64 @_copy_to_user(i8* %103, i8* %104, i32 %conv8.i178) #4
  store i64 %call.i179, i64* %n.addr.i166, align 8
  br label %copy_to_user.exit

if.else.i181:                                     ; preds = %lor.end.i177
  %106 = load i32, i32* %sz.i167, align 4
  %107 = load i64, i64* %n.addr.i166, align 8
  call void @copy_user_overflow(i32 %106, i64 %107) #4
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i181, %if.then.i180
  %108 = load i64, i64* %n.addr.i166, align 8
  %tobool99 = icmp ne i64 %108, 0
  br i1 %tobool99, label %if.then100, label %if.end101

if.then100:                                       ; preds = %copy_to_user.exit
  store i32 -14, i32* %ret, align 4
  br label %done

if.end101:                                        ; preds = %copy_to_user.exit
  br label %if.end102

if.end102:                                        ; preds = %if.end101, %land.lhs.true91, %cond.end87
  br label %if.end148

if.else:                                          ; preds = %do.end
  %wLength103 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %109 = load i16, i16* %wLength103, align 2
  %tobool104 = icmp ne i16 %109, 0
  br i1 %tobool104, label %if.then105, label %if.end113

if.then105:                                       ; preds = %if.else
  %110 = load i8*, i8** %tbuf, align 8
  %data106 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %111 = load i8*, i8** %data106, align 8
  %wLength107 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %112 = load i16, i16* %wLength107, align 2
  %conv108 = zext i16 %112 to i64
  store i8* %110, i8** %to.addr.i182, align 8
  store i8* %111, i8** %from.addr.i183, align 8
  store i64 %conv108, i64* %n.addr.i184, align 8
  %113 = load i8*, i8** %to.addr.i182, align 8
  %114 = call i64 @llvm.objectsize.i64.p0i8(i8* %113, i1 false, i1 true) #4
  %conv.i186 = trunc i64 %114 to i32
  store i32 %conv.i186, i32* %sz.i185, align 4
  call void @might_fault() #4
  %115 = load i8*, i8** %to.addr.i182, align 8
  %116 = load i64, i64* %n.addr.i184, align 8
  %conv1.i187 = trunc i64 %116 to i32
  call void @kasan_check_write(i8* %115, i32 %conv1.i187) #4
  %117 = load i32, i32* %sz.i185, align 4
  %cmp.i188 = icmp slt i32 %117, 0
  br i1 %cmp.i188, label %lor.end.i195, label %lor.rhs.i191

lor.rhs.i191:                                     ; preds = %if.then105
  %118 = load i32, i32* %sz.i185, align 4
  %conv3.i189 = sext i32 %118 to i64
  %119 = load i64, i64* %n.addr.i184, align 8
  %cmp4.i190 = icmp uge i64 %conv3.i189, %119
  br label %lor.end.i195

lor.end.i195:                                     ; preds = %lor.rhs.i191, %if.then105
  %120 = phi i1 [ true, %if.then105 ], [ %cmp4.i190, %lor.rhs.i191 ]
  %lnot.i192 = xor i1 %120, true
  %lnot.ext.i193 = zext i1 %120 to i32
  %conv7.i194 = sext i32 %lnot.ext.i193 to i64
  br i1 %120, label %if.then.i198, label %if.else.i199

if.then.i198:                                     ; preds = %lor.end.i195
  %121 = load i8*, i8** %to.addr.i182, align 8
  %122 = load i64, i64* %n.addr.i184, align 8
  call void @check_object_size(i8* %121, i64 %122, i1 zeroext false) #4
  %123 = load i8*, i8** %to.addr.i182, align 8
  %124 = load i8*, i8** %from.addr.i183, align 8
  %125 = load i64, i64* %n.addr.i184, align 8
  %conv8.i196 = trunc i64 %125 to i32
  %call.i197 = call i64 @_copy_from_user(i8* %123, i8* %124, i32 %conv8.i196) #4
  store i64 %call.i197, i64* %n.addr.i184, align 8
  br label %copy_from_user.exit200

if.else.i199:                                     ; preds = %lor.end.i195
  %126 = load i32, i32* %sz.i185, align 4
  %127 = load i64, i64* %n.addr.i184, align 8
  call void @copy_user_overflow(i32 %126, i64 %127) #4
  br label %copy_from_user.exit200

copy_from_user.exit200:                           ; preds = %if.else.i199, %if.then.i198
  %128 = load i64, i64* %n.addr.i184, align 8
  %tobool110 = icmp ne i64 %128, 0
  br i1 %tobool110, label %if.then111, label %if.end112

if.then111:                                       ; preds = %copy_from_user.exit200
  store i32 -14, i32* %ret, align 4
  br label %done

if.end112:                                        ; preds = %copy_from_user.exit200
  br label %if.end113

if.end113:                                        ; preds = %if.end112, %if.else
  %129 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %call114 = call i32 @__create_pipe(%struct.usb_device* %129, i32 0)
  %or115 = or i32 -2147483648, %call114
  store i32 %or115, i32* %pipe, align 4
  %130 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %131 = load i32, i32* %pipe, align 4
  %wLength116 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %132 = load i16, i16* %wLength116, align 2
  %conv117 = zext i16 %132 to i32
  %133 = load i32, i32* %tmo, align 4
  %134 = load i8*, i8** %tbuf, align 8
  %wLength118 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %135 = load i16, i16* %wLength118, align 2
  %conv119 = zext i16 %135 to i32
  call void @snoop_urb(%struct.usb_device* %130, i8* null, i32 %131, i32 %conv117, i32 %133, i32 0, i8* %134, i32 %conv119)
  %136 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev120 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %136, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev120)
  %137 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %138 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %call121 = call i32 @__create_pipe(%struct.usb_device* %138, i32 0)
  %or122 = or i32 -2147483648, %call121
  %bRequest123 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %139 = load i8, i8* %bRequest123, align 1
  %bRequestType124 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %140 = load i8, i8* %bRequestType124, align 8
  %wValue125 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %141 = load i16, i16* %wValue125, align 2
  %wIndex126 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %142 = load i16, i16* %wIndex126, align 4
  %143 = load i8*, i8** %tbuf, align 8
  %wLength127 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %144 = load i16, i16* %wLength127, align 2
  %145 = load i32, i32* %tmo, align 4
  %call128 = call i32 @usb_control_msg(%struct.usb_device* %137, i32 %or122, i8 zeroext %139, i8 zeroext %140, i16 zeroext %141, i16 zeroext %142, i8* %143, i16 zeroext %144, i32 %145)
  store i32 %call128, i32* %i, align 4
  %146 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev129 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %146, i32 0, i32 11
  call void @device_lock(%struct.device* %dev129)
  %147 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %148 = load i32, i32* %pipe, align 4
  %149 = load i32, i32* %i, align 4
  store i32 %149, i32* %__UNIQUE_ID_max1_36, align 4
  store i32 0, i32* %__UNIQUE_ID_max2_37, align 4
  %cmp130 = icmp eq i32* %__UNIQUE_ID_max1_36, %__UNIQUE_ID_max2_37
  %conv131 = zext i1 %cmp130 to i32
  %150 = load i32, i32* %__UNIQUE_ID_max1_36, align 4
  %151 = load i32, i32* %__UNIQUE_ID_max2_37, align 4
  %cmp133 = icmp sgt i32 %150, %151
  br i1 %cmp133, label %cond.true135, label %cond.false136

cond.true135:                                     ; preds = %if.end113
  %152 = load i32, i32* %__UNIQUE_ID_max1_36, align 4
  br label %cond.end137

cond.false136:                                    ; preds = %if.end113
  %153 = load i32, i32* %__UNIQUE_ID_max2_37, align 4
  br label %cond.end137

cond.end137:                                      ; preds = %cond.false136, %cond.true135
  %cond138 = phi i32 [ %152, %cond.true135 ], [ %153, %cond.false136 ]
  store i32 %cond138, i32* %tmp132, align 4
  %154 = load i32, i32* %tmp132, align 4
  %155 = load i32, i32* %i, align 4
  store i32 %155, i32* %__UNIQUE_ID_min1_38, align 4
  store i32 0, i32* %__UNIQUE_ID_min2_39, align 4
  %cmp139 = icmp eq i32* %__UNIQUE_ID_min1_38, %__UNIQUE_ID_min2_39
  %conv140 = zext i1 %cmp139 to i32
  %156 = load i32, i32* %__UNIQUE_ID_min1_38, align 4
  %157 = load i32, i32* %__UNIQUE_ID_min2_39, align 4
  %cmp142 = icmp slt i32 %156, %157
  br i1 %cmp142, label %cond.true144, label %cond.false145

cond.true144:                                     ; preds = %cond.end137
  %158 = load i32, i32* %__UNIQUE_ID_min1_38, align 4
  br label %cond.end146

cond.false145:                                    ; preds = %cond.end137
  %159 = load i32, i32* %__UNIQUE_ID_min2_39, align 4
  br label %cond.end146

cond.end146:                                      ; preds = %cond.false145, %cond.true144
  %cond147 = phi i32 [ %158, %cond.true144 ], [ %159, %cond.false145 ]
  store i32 %cond147, i32* %tmp141, align 4
  %160 = load i32, i32* %tmp141, align 4
  call void @snoop_urb(%struct.usb_device* %147, i8* null, i32 %148, i32 %154, i32 %160, i32 1, i8* null, i32 0)
  br label %if.end148

if.end148:                                        ; preds = %cond.end146, %if.end102
  %161 = load i32, i32* %i, align 4
  %cmp149 = icmp slt i32 %161, 0
  br i1 %cmp149, label %land.lhs.true151, label %if.end163

land.lhs.true151:                                 ; preds = %if.end148
  %162 = load i32, i32* %i, align 4
  %cmp152 = icmp ne i32 %162, -32
  br i1 %cmp152, label %if.then154, label %if.end163

if.then154:                                       ; preds = %land.lhs.true151
  %163 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev155 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %163, i32 0, i32 11
  %164 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %164, %struct.task_struct** %pfo_ret__.i201, align 8
  %165 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i201, align 8
  store %struct.task_struct* %165, %struct.task_struct** %tmp.i202, align 8
  %166 = load %struct.task_struct*, %struct.task_struct** %tmp.i202, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %166, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %bRequestType157 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %167 = load i8, i8* %bRequestType157, align 8
  %conv158 = zext i8 %167 to i32
  %bRequest159 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %168 = load i8, i8* %bRequest159, align 1
  %conv160 = zext i8 %168 to i32
  %wLength161 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %169 = load i16, i16* %wLength161, align 2
  %conv162 = zext i16 %169 to i32
  %170 = load i32, i32* %i, align 4
  call void (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), %struct.device* %dev155, i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.36, i32 0, i32 0), i8* %arraydecay, i32 %conv158, i32 %conv160, i32 %conv162, i32 %170)
  br label %if.end163

if.end163:                                        ; preds = %if.then154, %land.lhs.true151, %if.end148
  %171 = load i32, i32* %i, align 4
  store i32 %171, i32* %ret, align 4
  br label %done

done:                                             ; preds = %if.end163, %if.then111, %if.then100, %if.then52, %if.then20
  %172 = load i8*, i8** %tbuf, align 8
  %173 = ptrtoint i8* %172 to i64
  call void @free_pages(i64 %173, i32 0)
  call void @usbfs_decrease_memory_usage(i64 4296)
  %174 = load i32, i32* %ret, align 4
  store i32 %174, i32* %retval, align 4
  br label %return

return:                                           ; preds = %done, %if.then16, %if.then12, %if.then6, %if.then
  %175 = load i32, i32* %retval, align 4
  ret i32 %175
}

declare { i64, i64 } @current_time(%struct.inode*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_bulk(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %to.addr.i114 = alloca i8*, align 8
  %from.addr.i115 = alloca i8*, align 8
  %n.addr.i116 = alloca i64, align 8
  %sz.i117 = alloca i32, align 4
  %to.addr.i96 = alloca i8*, align 8
  %from.addr.i97 = alloca i8*, align 8
  %n.addr.i98 = alloca i64, align 8
  %sz.i99 = alloca i32, align 4
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %bulk = alloca %struct.usbdevfs_bulktransfer, align 8
  %tmo = alloca i32, align 4
  %len1 = alloca i32, align 4
  %pipe = alloca i32, align 4
  %len2 = alloca i32, align 4
  %tbuf = alloca i8*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp48 = alloca i8, align 1
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %1, %struct.usb_device** %dev, align 8
  %2 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  %3 = load i8*, i8** %arg.addr, align 8
  store i8* %2, i8** %to.addr.i, align 8
  store i8* %3, i8** %from.addr.i, align 8
  store i64 24, i64* %n.addr.i, align 8
  %4 = load i8*, i8** %to.addr.i, align 8
  %5 = call i64 @llvm.objectsize.i64.p0i8(i8* %4, i1 false, i1 true) #4
  %conv.i = trunc i64 %5 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %6 = load i8*, i8** %to.addr.i, align 8
  %7 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %7 to i32
  call void @kasan_check_write(i8* %6, i32 %conv1.i) #4
  %8 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %8, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %9 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %9 to i64
  %10 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %10
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %11 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %11, true
  %lnot.ext.i = zext i1 %11 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %11, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %12 = load i8*, i8** %to.addr.i, align 8
  %13 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %12, i64 %13, i1 zeroext false) #4
  %14 = load i8*, i8** %to.addr.i, align 8
  %15 = load i8*, i8** %from.addr.i, align 8
  %16 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %16 to i32
  %call.i = call i64 @_copy_from_user(i8* %14, i8* %15, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %17 = load i32, i32* %sz.i, align 4
  %18 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %17, i64 %18) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %19 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %19, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_from_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_from_user.exit
  %20 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %20, i32 0, i32 1
  %21 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8
  %ep = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %22 = load i32, i32* %ep, align 8
  %call3 = call i32 @findintfep(%struct.usb_device* %21, i32 %22)
  store i32 %call3, i32* %ret, align 4
  %23 = load i32, i32* %ret, align 4
  %cmp = icmp slt i32 %23, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %24 = load i32, i32* %ret, align 4
  store i32 %24, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %25 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %26 = load i32, i32* %ret, align 4
  %call6 = call i32 @checkintf(%struct.usb_dev_state* %25, i32 %26)
  store i32 %call6, i32* %ret, align 4
  %27 = load i32, i32* %ret, align 4
  %tobool7 = icmp ne i32 %27, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %28 = load i32, i32* %ret, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end5
  %ep10 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %29 = load i32, i32* %ep10, align 8
  %and = and i32 %29, 128
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end9
  %30 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %ep13 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %31 = load i32, i32* %ep13, align 8
  %and14 = and i32 %31, 127
  %call15 = call i32 @__create_pipe(%struct.usb_device* %30, i32 %and14)
  %or = or i32 -1073741824, %call15
  %or16 = or i32 %or, 128
  store i32 %or16, i32* %pipe, align 4
  br label %if.end21

if.else:                                          ; preds = %if.end9
  %32 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %ep17 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %33 = load i32, i32* %ep17, align 8
  %and18 = and i32 %33, 127
  %call19 = call i32 @__create_pipe(%struct.usb_device* %32, i32 %and18)
  %or20 = or i32 -1073741824, %call19
  store i32 %or20, i32* %pipe, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then12
  %34 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %35 = load i32, i32* %pipe, align 4
  %ep22 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %36 = load i32, i32* %ep22, align 8
  %and23 = and i32 %36, 128
  %tobool24 = icmp ne i32 %and23, 0
  %lnot = xor i1 %tobool24, true
  %lnot.ext = zext i1 %lnot to i32
  %call25 = call zeroext i16 @usb_maxpacket(%struct.usb_device* %34, i32 %35, i32 %lnot.ext)
  %tobool26 = icmp ne i16 %call25, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end21
  store i32 -22, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end21
  %len = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 1
  %37 = load i32, i32* %len, align 4
  store i32 %37, i32* %len1, align 4
  %38 = load i32, i32* %len1, align 4
  %conv = zext i32 %38 to i64
  %cmp29 = icmp uge i64 %conv, 2147483455
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  store i32 -22, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.end28
  %39 = load i32, i32* %len1, align 4
  %conv33 = zext i32 %39 to i64
  %add = add i64 %conv33, 192
  %call34 = call i32 @usbfs_increase_memory_usage(i64 %add)
  store i32 %call34, i32* %ret, align 4
  %40 = load i32, i32* %ret, align 4
  %tobool35 = icmp ne i32 %40, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end32
  %41 = load i32, i32* %ret, align 4
  store i32 %41, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end32
  %42 = load i32, i32* %len1, align 4
  %conv38 = zext i32 %42 to i64
  store i64 %conv38, i64* %size.addr.i, align 8
  store i32 20971712, i32* %flags.addr.i, align 4
  %43 = load i64, i64* %size.addr.i, align 8
  %44 = load i32, i32* %flags.addr.i, align 4
  %call.i95 = call noalias i8* @__kmalloc(i64 %43, i32 %44) #4
  store i8* %call.i95, i8** %tbuf, align 8
  %45 = load i8*, i8** %tbuf, align 8
  %tobool40 = icmp ne i8* %45, null
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.end37
  store i32 -12, i32* %ret, align 4
  br label %done

if.end42:                                         ; preds = %if.end37
  %timeout = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 2
  %46 = load i32, i32* %timeout, align 8
  store i32 %46, i32* %tmo, align 4
  %ep43 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %47 = load i32, i32* %ep43, align 8
  %and44 = and i32 %47, 128
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %if.then46, label %if.else77

if.then46:                                        ; preds = %if.end42
  %48 = load i32, i32* %len1, align 4
  %tobool47 = icmp ne i32 %48, 0
  br i1 %tobool47, label %land.lhs.true, label %if.end62

land.lhs.true:                                    ; preds = %if.then46
  %data = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %49 = load i8*, i8** %data, align 8
  %50 = ptrtoint i8* %49 to i64
  %51 = load i32, i32* %len1, align 4
  %conv49 = zext i32 %51 to i64
  %52 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %52, %struct.task_struct** %pfo_ret__.i, align 8
  %53 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %53, %struct.task_struct** %tmp.i, align 8
  %54 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %54, i32 0, i32 151
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %55 = load i64, i64* %seg, align 8
  %call51 = call zeroext i1 @__chk_range_not_ok(i64 %50, i64 %conv49, i64 %55)
  %frombool = zext i1 %call51 to i8
  store i8 %frombool, i8* %tmp48, align 1
  %56 = load i8, i8* %tmp48, align 1
  %tobool52 = trunc i8 %56 to i1
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  store i64 %conv59, i64* %tmp, align 8
  %57 = load i64, i64* %tmp, align 8
  %tobool60 = icmp ne i64 %57, 0
  br i1 %tobool60, label %if.end62, label %if.then61

if.then61:                                        ; preds = %land.lhs.true
  store i32 -22, i32* %ret, align 4
  br label %done

if.end62:                                         ; preds = %land.lhs.true, %if.then46
  %58 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %59 = load i32, i32* %pipe, align 4
  %60 = load i32, i32* %len1, align 4
  %61 = load i32, i32* %tmo, align 4
  call void @snoop_urb(%struct.usb_device* %58, i8* null, i32 %59, i32 %60, i32 %61, i32 0, i8* null, i32 0)
  %62 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev63 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %62, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev63)
  %63 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %64 = load i32, i32* %pipe, align 4
  %65 = load i8*, i8** %tbuf, align 8
  %66 = load i32, i32* %len1, align 4
  %67 = load i32, i32* %tmo, align 4
  %call64 = call i32 @usb_bulk_msg(%struct.usb_device* %63, i32 %64, i8* %65, i32 %66, i32* %len2, i32 %67)
  store i32 %call64, i32* %i, align 4
  %68 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev65 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %68, i32 0, i32 11
  call void @device_lock(%struct.device* %dev65)
  %69 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %70 = load i32, i32* %pipe, align 4
  %71 = load i32, i32* %len2, align 4
  %72 = load i32, i32* %i, align 4
  %73 = load i8*, i8** %tbuf, align 8
  %74 = load i32, i32* %len2, align 4
  call void @snoop_urb(%struct.usb_device* %69, i8* null, i32 %70, i32 %71, i32 %72, i32 1, i8* %73, i32 %74)
  %75 = load i32, i32* %i, align 4
  %tobool66 = icmp ne i32 %75, 0
  br i1 %tobool66, label %if.end76, label %land.lhs.true67

land.lhs.true67:                                  ; preds = %if.end62
  %76 = load i32, i32* %len2, align 4
  %tobool68 = icmp ne i32 %76, 0
  br i1 %tobool68, label %if.then69, label %if.end76

if.then69:                                        ; preds = %land.lhs.true67
  %data70 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %77 = load i8*, i8** %data70, align 8
  %78 = load i8*, i8** %tbuf, align 8
  %79 = load i32, i32* %len2, align 4
  %conv71 = sext i32 %79 to i64
  store i8* %77, i8** %to.addr.i96, align 8
  store i8* %78, i8** %from.addr.i97, align 8
  store i64 %conv71, i64* %n.addr.i98, align 8
  %80 = load i8*, i8** %from.addr.i97, align 8
  %81 = call i64 @llvm.objectsize.i64.p0i8(i8* %80, i1 false, i1 true) #4
  %conv.i100 = trunc i64 %81 to i32
  store i32 %conv.i100, i32* %sz.i99, align 4
  %82 = load i8*, i8** %from.addr.i97, align 8
  %83 = load i64, i64* %n.addr.i98, align 8
  %conv1.i101 = trunc i64 %83 to i32
  call void @kasan_check_read(i8* %82, i32 %conv1.i101) #4
  call void @might_fault() #4
  %84 = load i32, i32* %sz.i99, align 4
  %cmp.i102 = icmp slt i32 %84, 0
  br i1 %cmp.i102, label %lor.end.i109, label %lor.rhs.i105

lor.rhs.i105:                                     ; preds = %if.then69
  %85 = load i32, i32* %sz.i99, align 4
  %conv3.i103 = sext i32 %85 to i64
  %86 = load i64, i64* %n.addr.i98, align 8
  %cmp4.i104 = icmp uge i64 %conv3.i103, %86
  br label %lor.end.i109

lor.end.i109:                                     ; preds = %lor.rhs.i105, %if.then69
  %87 = phi i1 [ true, %if.then69 ], [ %cmp4.i104, %lor.rhs.i105 ]
  %lnot.i106 = xor i1 %87, true
  %lnot.ext.i107 = zext i1 %87 to i32
  %conv7.i108 = sext i32 %lnot.ext.i107 to i64
  br i1 %87, label %if.then.i112, label %if.else.i113

if.then.i112:                                     ; preds = %lor.end.i109
  %88 = load i8*, i8** %from.addr.i97, align 8
  %89 = load i64, i64* %n.addr.i98, align 8
  call void @check_object_size(i8* %88, i64 %89, i1 zeroext true) #4
  %90 = load i8*, i8** %to.addr.i96, align 8
  %91 = load i8*, i8** %from.addr.i97, align 8
  %92 = load i64, i64* %n.addr.i98, align 8
  %conv8.i110 = trunc i64 %92 to i32
  %call.i111 = call i64 @_copy_to_user(i8* %90, i8* %91, i32 %conv8.i110) #4
  store i64 %call.i111, i64* %n.addr.i98, align 8
  br label %copy_to_user.exit

if.else.i113:                                     ; preds = %lor.end.i109
  %93 = load i32, i32* %sz.i99, align 4
  %94 = load i64, i64* %n.addr.i98, align 8
  call void @copy_user_overflow(i32 %93, i64 %94) #4
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i113, %if.then.i112
  %95 = load i64, i64* %n.addr.i98, align 8
  %tobool73 = icmp ne i64 %95, 0
  br i1 %tobool73, label %if.then74, label %if.end75

if.then74:                                        ; preds = %copy_to_user.exit
  store i32 -14, i32* %ret, align 4
  br label %done

if.end75:                                         ; preds = %copy_to_user.exit
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %land.lhs.true67, %if.end62
  br label %if.end90

if.else77:                                        ; preds = %if.end42
  %96 = load i32, i32* %len1, align 4
  %tobool78 = icmp ne i32 %96, 0
  br i1 %tobool78, label %if.then79, label %if.end86

if.then79:                                        ; preds = %if.else77
  %97 = load i8*, i8** %tbuf, align 8
  %data80 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %98 = load i8*, i8** %data80, align 8
  %99 = load i32, i32* %len1, align 4
  %conv81 = zext i32 %99 to i64
  store i8* %97, i8** %to.addr.i114, align 8
  store i8* %98, i8** %from.addr.i115, align 8
  store i64 %conv81, i64* %n.addr.i116, align 8
  %100 = load i8*, i8** %to.addr.i114, align 8
  %101 = call i64 @llvm.objectsize.i64.p0i8(i8* %100, i1 false, i1 true) #4
  %conv.i118 = trunc i64 %101 to i32
  store i32 %conv.i118, i32* %sz.i117, align 4
  call void @might_fault() #4
  %102 = load i8*, i8** %to.addr.i114, align 8
  %103 = load i64, i64* %n.addr.i116, align 8
  %conv1.i119 = trunc i64 %103 to i32
  call void @kasan_check_write(i8* %102, i32 %conv1.i119) #4
  %104 = load i32, i32* %sz.i117, align 4
  %cmp.i120 = icmp slt i32 %104, 0
  br i1 %cmp.i120, label %lor.end.i127, label %lor.rhs.i123

lor.rhs.i123:                                     ; preds = %if.then79
  %105 = load i32, i32* %sz.i117, align 4
  %conv3.i121 = sext i32 %105 to i64
  %106 = load i64, i64* %n.addr.i116, align 8
  %cmp4.i122 = icmp uge i64 %conv3.i121, %106
  br label %lor.end.i127

lor.end.i127:                                     ; preds = %lor.rhs.i123, %if.then79
  %107 = phi i1 [ true, %if.then79 ], [ %cmp4.i122, %lor.rhs.i123 ]
  %lnot.i124 = xor i1 %107, true
  %lnot.ext.i125 = zext i1 %107 to i32
  %conv7.i126 = sext i32 %lnot.ext.i125 to i64
  br i1 %107, label %if.then.i130, label %if.else.i131

if.then.i130:                                     ; preds = %lor.end.i127
  %108 = load i8*, i8** %to.addr.i114, align 8
  %109 = load i64, i64* %n.addr.i116, align 8
  call void @check_object_size(i8* %108, i64 %109, i1 zeroext false) #4
  %110 = load i8*, i8** %to.addr.i114, align 8
  %111 = load i8*, i8** %from.addr.i115, align 8
  %112 = load i64, i64* %n.addr.i116, align 8
  %conv8.i128 = trunc i64 %112 to i32
  %call.i129 = call i64 @_copy_from_user(i8* %110, i8* %111, i32 %conv8.i128) #4
  store i64 %call.i129, i64* %n.addr.i116, align 8
  br label %copy_from_user.exit132

if.else.i131:                                     ; preds = %lor.end.i127
  %113 = load i32, i32* %sz.i117, align 4
  %114 = load i64, i64* %n.addr.i116, align 8
  call void @copy_user_overflow(i32 %113, i64 %114) #4
  br label %copy_from_user.exit132

copy_from_user.exit132:                           ; preds = %if.else.i131, %if.then.i130
  %115 = load i64, i64* %n.addr.i116, align 8
  %tobool83 = icmp ne i64 %115, 0
  br i1 %tobool83, label %if.then84, label %if.end85

if.then84:                                        ; preds = %copy_from_user.exit132
  store i32 -14, i32* %ret, align 4
  br label %done

if.end85:                                         ; preds = %copy_from_user.exit132
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %if.else77
  %116 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %117 = load i32, i32* %pipe, align 4
  %118 = load i32, i32* %len1, align 4
  %119 = load i32, i32* %tmo, align 4
  %120 = load i8*, i8** %tbuf, align 8
  %121 = load i32, i32* %len1, align 4
  call void @snoop_urb(%struct.usb_device* %116, i8* null, i32 %117, i32 %118, i32 %119, i32 0, i8* %120, i32 %121)
  %122 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev87 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %122, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev87)
  %123 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %124 = load i32, i32* %pipe, align 4
  %125 = load i8*, i8** %tbuf, align 8
  %126 = load i32, i32* %len1, align 4
  %127 = load i32, i32* %tmo, align 4
  %call88 = call i32 @usb_bulk_msg(%struct.usb_device* %123, i32 %124, i8* %125, i32 %126, i32* %len2, i32 %127)
  store i32 %call88, i32* %i, align 4
  %128 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev89 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %128, i32 0, i32 11
  call void @device_lock(%struct.device* %dev89)
  %129 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %130 = load i32, i32* %pipe, align 4
  %131 = load i32, i32* %len2, align 4
  %132 = load i32, i32* %i, align 4
  call void @snoop_urb(%struct.usb_device* %129, i8* null, i32 %130, i32 %131, i32 %132, i32 1, i8* null, i32 0)
  br label %if.end90

if.end90:                                         ; preds = %if.end86, %if.end76
  %133 = load i32, i32* %i, align 4
  %cmp91 = icmp slt i32 %133, 0
  br i1 %cmp91, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end90
  %134 = load i32, i32* %i, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end90
  %135 = load i32, i32* %len2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %134, %cond.true ], [ %135, %cond.false ]
  store i32 %cond, i32* %ret, align 4
  br label %done

done:                                             ; preds = %cond.end, %if.then84, %if.then74, %if.then61, %if.then41
  %136 = load i8*, i8** %tbuf, align 8
  call void @kfree(i8* %136)
  %137 = load i32, i32* %len1, align 4
  %conv93 = zext i32 %137 to i64
  %add94 = add i64 %conv93, 192
  call void @usbfs_decrease_memory_usage(i64 %add94)
  %138 = load i32, i32* %ret, align 4
  store i32 %138, i32* %retval, align 4
  br label %return

return:                                           ; preds = %done, %if.then36, %if.then31, %if.then27, %if.then8, %if.then4, %if.then
  %139 = load i32, i32* %retval, align 4
  ret i32 %139
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_resetep(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ep = alloca i32, align 4
  %ret = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %__sp = alloca i8*, align 8
  %tmp = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %__sp, align 8
  %1 = load i8*, i8** %arg.addr, align 8
  %2 = bitcast i8* %1 to i32*
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %2, i64 4, i8* %0) #4, !srcloc !10
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  store i32 %5, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  store i8* %asmresult2, i8** %__sp, align 8
  %6 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, i32* %ep, align 4
  %7 = load i32, i32* %__ret_gu, align 4
  %conv3 = sext i32 %7 to i64
  store i64 %conv3, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %9, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %11 = load i32, i32* %ep, align 4
  %call = call i32 @findintfep(%struct.usb_device* %10, i32 %11)
  store i32 %call, i32* %ret, align 4
  %12 = load i32, i32* %ret, align 4
  %cmp = icmp slt i32 %12, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %13 = load i32, i32* %ret, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %14 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %15 = load i32, i32* %ret, align 4
  %call7 = call i32 @checkintf(%struct.usb_dev_state* %14, i32 %15)
  store i32 %call7, i32* %ret, align 4
  %16 = load i32, i32* %ret, align 4
  %tobool8 = icmp ne i32 %16, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  %17 = load i32, i32* %ret, align 4
  store i32 %17, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %18 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev11 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %18, i32 0, i32 1
  %19 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8
  %20 = load i32, i32* %ep, align 4
  call void @check_reset_of_active_ep(%struct.usb_device* %19, i32 %20, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.51, i32 0, i32 0))
  %21 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev12 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %21, i32 0, i32 1
  %22 = load %struct.usb_device*, %struct.usb_device** %dev12, align 8
  %23 = load i32, i32* %ep, align 4
  call void @usb_reset_endpoint(%struct.usb_device* %22, i32 %23)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then9, %if.then5, %if.then
  %24 = load i32, i32* %retval, align 4
  ret i32 %24
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_resetdevice(%struct.usb_dev_state* %ps) #0 {
entry:
  %nr.addr.i24 = alloca i64, align 8
  %addr.addr.i25 = alloca i64*, align 8
  %oldbit.i = alloca i8, align 1
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %actconfig = alloca %struct.usb_host_config*, align 8
  %interface = alloca %struct.usb_interface*, align 8
  %i = alloca i32, align 4
  %number = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %actconfig1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig1, align 8
  store %struct.usb_host_config* %2, %struct.usb_host_config** %actconfig, align 8
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 15
  %4 = load i8, i8* %privileges_dropped, align 8
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end21

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %tobool2 = icmp ne %struct.usb_host_config* %5, null
  br i1 %tobool2, label %if.then, label %if.end21

if.then:                                          ; preds = %land.lhs.true
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %6 = load i32, i32* %i, align 4
  %7 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %7, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %8 = load i8, i8* %bNumInterfaces, align 4
  %conv = zext i8 %8 to i32
  %cmp = icmp slt i32 %6, %conv
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %interface4 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %9, i32 0, i32 3
  %10 = load i32, i32* %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface4, i64 0, i64 %idxprom
  %11 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8
  store %struct.usb_interface* %11, %struct.usb_interface** %interface, align 8
  %12 = load %struct.usb_interface*, %struct.usb_interface** %interface, align 8
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 1
  %13 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8
  %desc5 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %13, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc5, i32 0, i32 2
  %14 = load i8, i8* %bInterfaceNumber, align 2
  %conv6 = zext i8 %14 to i32
  store i32 %conv6, i32* %number, align 4
  %15 = load %struct.usb_interface*, %struct.usb_interface** %interface, align 8
  %call = call i32 @usb_interface_claimed(%struct.usb_interface* %15)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %land.lhs.true8, label %if.end

land.lhs.true8:                                   ; preds = %for.body
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true8
  %16 = load i32, i32* %number, align 4
  %conv9 = sext i32 %16 to i64
  %17 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %17, i32 0, i32 12
  store i64 %conv9, i64* %nr.addr.i, align 8
  store i64* %ifclaimed, i64** %addr.addr.i, align 8
  %18 = load i64, i64* %nr.addr.i, align 8
  %and.i = and i64 %18, 63
  %shl.i = shl i64 1, %and.i
  %19 = load i64*, i64** %addr.addr.i, align 8
  %20 = load i64, i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %20, 6
  %arrayidx.i = getelementptr inbounds i64, i64* %19, i64 %shr.i
  %21 = load volatile i64, i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %21
  %cmp.i = icmp ne i64 %and1.i, 0
  br i1 %cmp.i, label %if.end, label %if.then16

cond.false:                                       ; preds = %land.lhs.true8
  %22 = load i32, i32* %number, align 4
  %conv12 = sext i32 %22 to i64
  %23 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %ifclaimed13 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %23, i32 0, i32 12
  store i64 %conv12, i64* %nr.addr.i24, align 8
  store i64* %ifclaimed13, i64** %addr.addr.i25, align 8
  %24 = load i64*, i64** %addr.addr.i25, align 8
  %25 = load i64, i64* %nr.addr.i24, align 8
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %24, i64 %25) #4, !srcloc !5
  %26 = load i8, i8* %oldbit.i, align 1
  %tobool.i = trunc i8 %26 to i1
  br i1 %tobool.i, label %if.end, label %if.then16

if.then16:                                        ; preds = %cond.false, %cond.true
  %27 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev17 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %27, i32 0, i32 1
  %28 = load %struct.usb_device*, %struct.usb_device** %dev17, align 8
  %dev18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %28, i32 0, i32 11
  %29 = load i32, i32* %number, align 4
  %30 = load %struct.usb_interface*, %struct.usb_interface** %interface, align 8
  %dev19 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %30, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev19, i32 0, i32 7
  %31 = load %struct.device_driver*, %struct.device_driver** %driver, align 8
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %31, i32 0, i32 0
  %32 = load i8*, i8** %name, align 8
  %33 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %33, %struct.task_struct** %pfo_ret__.i, align 8
  %34 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %34, %struct.task_struct** %tmp.i, align 8
  %35 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %35, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev18, i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.53, i32 0, i32 0), i32 %29, i8* %32, i8* %arraydecay)
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.false, %cond.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %36 = load i32, i32* %i, align 4
  %inc = add nsw i32 %36, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end21

if.end21:                                         ; preds = %for.end, %land.lhs.true, %entry
  %37 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev22 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %37, i32 0, i32 1
  %38 = load %struct.usb_device*, %struct.usb_device** %dev22, align 8
  %call23 = call i32 @usb_reset_device(%struct.usb_device* %38)
  store i32 %call23, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end21, %if.then16
  %39 = load i32, i32* %retval, align 4
  ret i32 %39
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_clearhalt(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ep = alloca i32, align 4
  %pipe = alloca i32, align 4
  %ret = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %__sp = alloca i8*, align 8
  %tmp = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %__sp, align 8
  %1 = load i8*, i8** %arg.addr, align 8
  %2 = bitcast i8* %1 to i32*
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %2, i64 4, i8* %0) #4, !srcloc !11
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  store i32 %5, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  store i8* %asmresult2, i8** %__sp, align 8
  %6 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, i32* %ep, align 4
  %7 = load i32, i32* %__ret_gu, align 4
  %conv3 = sext i32 %7 to i64
  store i64 %conv3, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %9, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %11 = load i32, i32* %ep, align 4
  %call = call i32 @findintfep(%struct.usb_device* %10, i32 %11)
  store i32 %call, i32* %ret, align 4
  %12 = load i32, i32* %ret, align 4
  %cmp = icmp slt i32 %12, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %13 = load i32, i32* %ret, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %14 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %15 = load i32, i32* %ret, align 4
  %call7 = call i32 @checkintf(%struct.usb_dev_state* %14, i32 %15)
  store i32 %call7, i32* %ret, align 4
  %16 = load i32, i32* %ret, align 4
  %tobool8 = icmp ne i32 %16, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  %17 = load i32, i32* %ret, align 4
  store i32 %17, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %18 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev11 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %18, i32 0, i32 1
  %19 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8
  %20 = load i32, i32* %ep, align 4
  call void @check_reset_of_active_ep(%struct.usb_device* %19, i32 %20, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.54, i32 0, i32 0))
  %21 = load i32, i32* %ep, align 4
  %and = and i32 %21, 128
  %tobool12 = icmp ne i32 %and, 0
  br i1 %tobool12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end10
  %22 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev14 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %22, i32 0, i32 1
  %23 = load %struct.usb_device*, %struct.usb_device** %dev14, align 8
  %24 = load i32, i32* %ep, align 4
  %and15 = and i32 %24, 127
  %call16 = call i32 @__create_pipe(%struct.usb_device* %23, i32 %and15)
  %or = or i32 -1073741824, %call16
  %or17 = or i32 %or, 128
  store i32 %or17, i32* %pipe, align 4
  br label %if.end22

if.else:                                          ; preds = %if.end10
  %25 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev18 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %25, i32 0, i32 1
  %26 = load %struct.usb_device*, %struct.usb_device** %dev18, align 8
  %27 = load i32, i32* %ep, align 4
  %and19 = and i32 %27, 127
  %call20 = call i32 @__create_pipe(%struct.usb_device* %26, i32 %and19)
  %or21 = or i32 -1073741824, %call20
  store i32 %or21, i32* %pipe, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then13
  %28 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev23 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %28, i32 0, i32 1
  %29 = load %struct.usb_device*, %struct.usb_device** %dev23, align 8
  %30 = load i32, i32* %pipe, align 4
  %call24 = call i32 @usb_clear_halt(%struct.usb_device* %29, i32 %30)
  store i32 %call24, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end22, %if.then9, %if.then5, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_getdriver(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %to.addr.i13 = alloca i8*, align 8
  %from.addr.i14 = alloca i8*, align 8
  %n.addr.i15 = alloca i64, align 8
  %sz.i16 = alloca i32, align 4
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %gd = alloca %struct.usbdevfs_getdriver, align 4
  %intf = alloca %struct.usb_interface*, align 8
  %ret = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  store i8* %0, i8** %to.addr.i, align 8
  store i8* %1, i8** %from.addr.i, align 8
  store i64 260, i64* %n.addr.i, align 8
  %2 = load i8*, i8** %to.addr.i, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true) #4
  %conv.i = trunc i64 %3 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %4 = load i8*, i8** %to.addr.i, align 8
  %5 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %5 to i32
  call void @kasan_check_write(i8* %4, i32 %conv1.i) #4
  %6 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %6, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %7 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %7 to i64
  %8 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %8
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %9 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %9, true
  %lnot.ext.i = zext i1 %9 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %9, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %10 = load i8*, i8** %to.addr.i, align 8
  %11 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %10, i64 %11, i1 zeroext false) #4
  %12 = load i8*, i8** %to.addr.i, align 8
  %13 = load i8*, i8** %from.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %14 to i32
  %call.i = call i64 @_copy_from_user(i8* %12, i8* %13, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %15 = load i32, i32* %sz.i, align 4
  %16 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %15, i64 %16) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %17 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %17, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_from_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_from_user.exit
  %18 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %18, i32 0, i32 1
  %19 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %interface = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 0
  %20 = load i32, i32* %interface, align 4
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %19, i32 %20)
  store %struct.usb_interface* %call1, %struct.usb_interface** %intf, align 8
  %21 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %tobool2 = icmp ne %struct.usb_interface* %21, null
  br i1 %tobool2, label %lor.lhs.false, label %if.then5

lor.lhs.false:                                    ; preds = %if.end
  %22 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %22, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev3, i32 0, i32 7
  %23 = load %struct.device_driver*, %struct.device_driver** %driver, align 8
  %tobool4 = icmp ne %struct.device_driver* %23, null
  br i1 %tobool4, label %if.else, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  store i32 -61, i32* %ret, align 4
  br label %if.end12

if.else:                                          ; preds = %lor.lhs.false
  %driver6 = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 1
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver6, i32 0, i32 0
  %24 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev7 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  %driver8 = getelementptr inbounds %struct.device, %struct.device* %dev7, i32 0, i32 7
  %25 = load %struct.device_driver*, %struct.device_driver** %driver8, align 8
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %25, i32 0, i32 0
  %26 = load i8*, i8** %name, align 8
  %call9 = call i64 @strlcpy(i8* %arraydecay, i8* %26, i64 256)
  %27 = load i8*, i8** %arg.addr, align 8
  %28 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  store i8* %27, i8** %to.addr.i13, align 8
  store i8* %28, i8** %from.addr.i14, align 8
  store i64 260, i64* %n.addr.i15, align 8
  %29 = load i8*, i8** %from.addr.i14, align 8
  %30 = call i64 @llvm.objectsize.i64.p0i8(i8* %29, i1 false, i1 true) #4
  %conv.i17 = trunc i64 %30 to i32
  store i32 %conv.i17, i32* %sz.i16, align 4
  %31 = load i8*, i8** %from.addr.i14, align 8
  %32 = load i64, i64* %n.addr.i15, align 8
  %conv1.i18 = trunc i64 %32 to i32
  call void @kasan_check_read(i8* %31, i32 %conv1.i18) #4
  call void @might_fault() #4
  %33 = load i32, i32* %sz.i16, align 4
  %cmp.i19 = icmp slt i32 %33, 0
  br i1 %cmp.i19, label %lor.end.i26, label %lor.rhs.i22

lor.rhs.i22:                                      ; preds = %if.else
  %34 = load i32, i32* %sz.i16, align 4
  %conv3.i20 = sext i32 %34 to i64
  %35 = load i64, i64* %n.addr.i15, align 8
  %cmp4.i21 = icmp uge i64 %conv3.i20, %35
  br label %lor.end.i26

lor.end.i26:                                      ; preds = %lor.rhs.i22, %if.else
  %36 = phi i1 [ true, %if.else ], [ %cmp4.i21, %lor.rhs.i22 ]
  %lnot.i23 = xor i1 %36, true
  %lnot.ext.i24 = zext i1 %36 to i32
  %conv7.i25 = sext i32 %lnot.ext.i24 to i64
  br i1 %36, label %if.then.i29, label %if.else.i30

if.then.i29:                                      ; preds = %lor.end.i26
  %37 = load i8*, i8** %from.addr.i14, align 8
  %38 = load i64, i64* %n.addr.i15, align 8
  call void @check_object_size(i8* %37, i64 %38, i1 zeroext true) #4
  %39 = load i8*, i8** %to.addr.i13, align 8
  %40 = load i8*, i8** %from.addr.i14, align 8
  %41 = load i64, i64* %n.addr.i15, align 8
  %conv8.i27 = trunc i64 %41 to i32
  %call.i28 = call i64 @_copy_to_user(i8* %39, i8* %40, i32 %conv8.i27) #4
  store i64 %call.i28, i64* %n.addr.i15, align 8
  br label %copy_to_user.exit

if.else.i30:                                      ; preds = %lor.end.i26
  %42 = load i32, i32* %sz.i16, align 4
  %43 = load i64, i64* %n.addr.i15, align 8
  call void @copy_user_overflow(i32 %42, i64 %43) #4
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i30, %if.then.i29
  %44 = load i64, i64* %n.addr.i15, align 8
  %tobool11 = icmp ne i64 %44, 0
  %45 = zext i1 %tobool11 to i64
  %cond = select i1 %tobool11, i32 -14, i32 0
  store i32 %cond, i32* %ret, align 4
  br label %if.end12

if.end12:                                         ; preds = %copy_to_user.exit, %if.then5
  %46 = load i32, i32* %ret, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then
  %47 = load i32, i32* %retval, align 4
  ret i32 %47
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_connectinfo(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ci = alloca %struct.usbdevfs_connectinfo, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 8, i32 4, i1 false)
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 0
  %3 = load i32, i32* %devnum, align 8
  %devnum1 = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 0
  store i32 %3, i32* %devnum1, align 4
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %4, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %5, i32 0, i32 4
  %6 = load i32, i32* %speed, align 4
  %cmp = icmp eq i32 %6, 1
  %conv = zext i1 %cmp to i32
  %conv3 = trunc i32 %conv to i8
  %slow = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 1
  store i8 %conv3, i8* %slow, align 4
  %7 = load i8*, i8** %arg.addr, align 8
  %8 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  store i8* %7, i8** %to.addr.i, align 8
  store i8* %8, i8** %from.addr.i, align 8
  store i64 8, i64* %n.addr.i, align 8
  %9 = load i8*, i8** %from.addr.i, align 8
  %10 = call i64 @llvm.objectsize.i64.p0i8(i8* %9, i1 false, i1 true) #4
  %conv.i = trunc i64 %10 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  %11 = load i8*, i8** %from.addr.i, align 8
  %12 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %12 to i32
  call void @kasan_check_read(i8* %11, i32 %conv1.i) #4
  call void @might_fault() #4
  %13 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %13, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %14 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %14 to i64
  %15 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %15
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %16 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %16, true
  %lnot.ext.i = zext i1 %16 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %16, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %17 = load i8*, i8** %from.addr.i, align 8
  %18 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %17, i64 %18, i1 zeroext true) #4
  %19 = load i8*, i8** %to.addr.i, align 8
  %20 = load i8*, i8** %from.addr.i, align 8
  %21 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %21 to i32
  %call.i = call i64 @_copy_to_user(i8* %19, i8* %20, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_to_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %22 = load i32, i32* %sz.i, align 4
  %23 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %22, i64 %23) #4
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i, %if.then.i
  %24 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %24, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_to_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_to_user.exit
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %25 = load i32, i32* %retval, align 4
  ret i32 %25
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_setintf(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %setintf = alloca %struct.usbdevfs_setinterface, align 4
  %ret = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_setinterface* %setintf to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  store i8* %0, i8** %to.addr.i, align 8
  store i8* %1, i8** %from.addr.i, align 8
  store i64 8, i64* %n.addr.i, align 8
  %2 = load i8*, i8** %to.addr.i, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true) #4
  %conv.i = trunc i64 %3 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %4 = load i8*, i8** %to.addr.i, align 8
  %5 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %5 to i32
  call void @kasan_check_write(i8* %4, i32 %conv1.i) #4
  %6 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %6, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %7 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %7 to i64
  %8 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %8
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %9 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %9, true
  %lnot.ext.i = zext i1 %9 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %9, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %10 = load i8*, i8** %to.addr.i, align 8
  %11 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %10, i64 %11, i1 zeroext false) #4
  %12 = load i8*, i8** %to.addr.i, align 8
  %13 = load i8*, i8** %from.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %14 to i32
  %call.i = call i64 @_copy_from_user(i8* %12, i8* %13, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %15 = load i32, i32* %sz.i, align 4
  %16 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %15, i64 %16) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %17 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %17, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_from_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_from_user.exit
  %18 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %interface = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 0
  %19 = load i32, i32* %interface, align 4
  %call1 = call i32 @checkintf(%struct.usb_dev_state* %18, i32 %19)
  store i32 %call1, i32* %ret, align 4
  %20 = load i32, i32* %ret, align 4
  %tobool2 = icmp ne i32 %20, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %21 = load i32, i32* %ret, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %22 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %interface5 = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 0
  %23 = load i32, i32* %interface5, align 4
  call void @destroy_async_on_interface(%struct.usb_dev_state* %22, i32 %23)
  %24 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %24, i32 0, i32 1
  %25 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %interface6 = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 0
  %26 = load i32, i32* %interface6, align 4
  %altsetting = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 1
  %27 = load i32, i32* %altsetting, align 4
  %call7 = call i32 @usb_set_interface(%struct.usb_device* %25, i32 %26, i32 %27)
  store i32 %call7, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %28 = load i32, i32* %retval, align 4
  ret i32 %28
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_setconfig(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %u = alloca i32, align 4
  %status = alloca i32, align 4
  %actconfig = alloca %struct.usb_host_config*, align 8
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %__sp = alloca i8*, align 8
  %tmp = alloca i64, align 8
  %i = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  store i32 0, i32* %status, align 4
  call void @might_fault()
  %0 = load i8*, i8** %__sp, align 8
  %1 = load i8*, i8** %arg.addr, align 8
  %2 = bitcast i8* %1 to i32*
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %2, i64 4, i8* %0) #4, !srcloc !12
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  store i32 %5, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  store i8* %asmresult2, i8** %__sp, align 8
  %6 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, i32* %u, align 4
  %7 = load i32, i32* %__ret_gu, align 4
  %conv3 = sext i32 %7 to i64
  store i64 %conv3, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %9, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %10, i32 0, i32 15
  %11 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8
  store %struct.usb_host_config* %11, %struct.usb_host_config** %actconfig, align 8
  %12 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %tobool5 = icmp ne %struct.usb_host_config* %12, null
  br i1 %tobool5, label %if.then6, label %if.end24

if.then6:                                         ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then6
  %13 = load i32, i32* %i, align 4
  %14 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %14, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %15 = load i8, i8* %bNumInterfaces, align 4
  %conv7 = zext i8 %15 to i32
  %cmp = icmp slt i32 %13, %conv7
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.body:                                         ; preds = %for.cond
  %16 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %16, i32 0, i32 3
  %17 = load i32, i32* %i, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %18 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8
  %call = call i32 @usb_interface_claimed(%struct.usb_interface* %18)
  %tobool9 = icmp ne i32 %call, 0
  br i1 %tobool9, label %if.then10, label %if.end23

if.then10:                                        ; preds = %for.body
  %19 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev11 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %19, i32 0, i32 1
  %20 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %20, i32 0, i32 11
  %21 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %interface13 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %21, i32 0, i32 3
  %22 = load i32, i32* %i, align 4
  %idxprom14 = sext i32 %22 to i64
  %arrayidx15 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface13, i64 0, i64 %idxprom14
  %23 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx15, align 8
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %23, i32 0, i32 1
  %24 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8
  %desc16 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %24, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc16, i32 0, i32 2
  %25 = load i8, i8* %bInterfaceNumber, align 2
  %conv17 = zext i8 %25 to i32
  %26 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %interface18 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %26, i32 0, i32 3
  %27 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %27 to i64
  %arrayidx20 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface18, i64 0, i64 %idxprom19
  %28 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx20, align 8
  %dev21 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %28, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev21, i32 0, i32 7
  %29 = load %struct.device_driver*, %struct.device_driver** %driver, align 8
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %29, i32 0, i32 0
  %30 = load i8*, i8** %name, align 8
  %31 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %31, %struct.task_struct** %pfo_ret__.i, align 8
  %32 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %32, %struct.task_struct** %tmp.i, align 8
  %33 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %33, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %34 = load i32, i32* %u, align 4
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev12, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.55, i32 0, i32 0), i32 %conv17, i8* %30, i8* %arraydecay, i32 %34)
  store i32 -16, i32* %status, align 4
  br label %for.end

if.end23:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end23
  %35 = load i32, i32* %i, align 4
  %inc = add nsw i32 %35, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end.loopexit:                                 ; preds = %for.cond
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %if.then10
  br label %if.end24

if.end24:                                         ; preds = %for.end, %if.end
  %36 = load i32, i32* %status, align 4
  %cmp25 = icmp eq i32 %36, 0
  br i1 %cmp25, label %if.then27, label %if.end39

if.then27:                                        ; preds = %if.end24
  %37 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %tobool28 = icmp ne %struct.usb_host_config* %37, null
  br i1 %tobool28, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then27
  %38 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %desc29 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %38, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc29, i32 0, i32 4
  %39 = load i8, i8* %bConfigurationValue, align 1
  %conv30 = zext i8 %39 to i32
  %40 = load i32, i32* %u, align 4
  %cmp31 = icmp eq i32 %conv30, %40
  br i1 %cmp31, label %if.then33, label %if.else

if.then33:                                        ; preds = %land.lhs.true
  %41 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev34 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %41, i32 0, i32 1
  %42 = load %struct.usb_device*, %struct.usb_device** %dev34, align 8
  %call35 = call i32 @usb_reset_configuration(%struct.usb_device* %42)
  store i32 %call35, i32* %status, align 4
  br label %if.end38

if.else:                                          ; preds = %land.lhs.true, %if.then27
  %43 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev36 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %43, i32 0, i32 1
  %44 = load %struct.usb_device*, %struct.usb_device** %dev36, align 8
  %45 = load i32, i32* %u, align 4
  %call37 = call i32 @usb_set_configuration(%struct.usb_device* %44, i32 %45)
  store i32 %call37, i32* %status, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.else, %if.then33
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end24
  %46 = load i32, i32* %status, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end39, %if.then
  %47 = load i32, i32* %retval, align 4
  ret i32 %47
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_submiturb(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %uurb = alloca %struct.usbdevfs_urb, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  store i8* %0, i8** %to.addr.i, align 8
  store i8* %1, i8** %from.addr.i, align 8
  store i64 56, i64* %n.addr.i, align 8
  %2 = load i8*, i8** %to.addr.i, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true) #4
  %conv.i = trunc i64 %3 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %4 = load i8*, i8** %to.addr.i, align 8
  %5 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %5 to i32
  call void @kasan_check_write(i8* %4, i32 %conv1.i) #4
  %6 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %6, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %7 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %7 to i64
  %8 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %8
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %9 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %9, true
  %lnot.ext.i = zext i1 %9 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %9, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %10 = load i8*, i8** %to.addr.i, align 8
  %11 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %10, i64 %11, i1 zeroext false) #4
  %12 = load i8*, i8** %to.addr.i, align 8
  %13 = load i8*, i8** %from.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %14 to i32
  %call.i = call i64 @_copy_from_user(i8* %12, i8* %13, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %15 = load i32, i32* %sz.i, align 4
  %16 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %15, i64 %16) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %17 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %17, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_from_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_from_user.exit
  %18 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %19 = load i8*, i8** %arg.addr, align 8
  %20 = bitcast i8* %19 to %struct.usbdevfs_urb*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %20, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc, i32 0, i32 0
  %21 = load i8*, i8** %arg.addr, align 8
  %call1 = call i32 @proc_do_submiturb(%struct.usb_dev_state* %18, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %arraydecay, i8* %21)
  store i32 %call1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_control_compat(%struct.usb_dev_state* %ps, %struct.usbdevfs_ctrltransfer32* %p32) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %p32.addr = alloca %struct.usbdevfs_ctrltransfer32*, align 8
  %p = alloca %struct.usbdevfs_ctrltransfer*, align 8
  %udata = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %__sp = alloca i8*, align 8
  %tmp = alloca i64, align 8
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i8*, align 8
  %tmp9 = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store %struct.usbdevfs_ctrltransfer32* %p32, %struct.usbdevfs_ctrltransfer32** %p32.addr, align 8
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_ctrltransfer*
  store %struct.usbdevfs_ctrltransfer* %0, %struct.usbdevfs_ctrltransfer** %p, align 8
  %1 = load %struct.usbdevfs_ctrltransfer*, %struct.usbdevfs_ctrltransfer** %p, align 8
  %2 = bitcast %struct.usbdevfs_ctrltransfer* %1 to i8*
  %3 = load %struct.usbdevfs_ctrltransfer32*, %struct.usbdevfs_ctrltransfer32** %p32.addr, align 8
  %4 = bitcast %struct.usbdevfs_ctrltransfer32* %3 to i8*
  %call1 = call i64 @copy_in_user(i8* %2, i8* %4, i32 12)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %5 = load i8*, i8** %__sp, align 8
  %6 = load %struct.usbdevfs_ctrltransfer32*, %struct.usbdevfs_ctrltransfer32** %p32.addr, align 8
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer32, %struct.usbdevfs_ctrltransfer32* %6, i32 0, i32 6
  %7 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4, i8* %5) #4, !srcloc !13
  %asmresult = extractvalue { i32*, i64, i8* } %7, 0
  %asmresult2 = extractvalue { i32*, i64, i8* } %7, 1
  %asmresult3 = extractvalue { i32*, i64, i8* } %7, 2
  %8 = ptrtoint i32* %asmresult to i64
  %9 = trunc i64 %8 to i32
  store i32 %9, i32* %__ret_gu, align 4
  store i64 %asmresult2, i64* %__val_gu, align 8
  store i8* %asmresult3, i8** %__sp, align 8
  %10 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %10 to i32
  store i32 %conv, i32* %udata, align 4
  %11 = load i32, i32* %__ret_gu, align 4
  %conv4 = sext i32 %11 to i64
  store i64 %conv4, i64* %tmp, align 8
  %12 = load i64, i64* %tmp, align 8
  %tobool5 = icmp ne i64 %12, 0
  br i1 %tobool5, label %if.then, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  call void @might_fault()
  %13 = load i32, i32* %udata, align 4
  %call7 = call i8* @compat_ptr(i32 %13)
  store i8* %call7, i8** %__pu_val, align 8
  %14 = load i8*, i8** %__pu_val, align 8
  %15 = load %struct.usbdevfs_ctrltransfer*, %struct.usbdevfs_ctrltransfer** %p, align 8
  %data8 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %15, i32 0, i32 6
  %16 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %14, i8** %data8) #4, !srcloc !14
  %17 = ptrtoint i8* %16 to i64
  %18 = trunc i64 %17 to i32
  store i32 %18, i32* %__ret_pu, align 4
  %19 = load i32, i32* %__ret_pu, align 4
  %conv10 = sext i32 %19 to i64
  store i64 %conv10, i64* %tmp9, align 8
  %20 = load i64, i64* %tmp9, align 8
  %tobool11 = icmp ne i64 %20, 0
  br i1 %tobool11, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false6, %lor.lhs.false, %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false6
  %21 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %22 = load %struct.usbdevfs_ctrltransfer*, %struct.usbdevfs_ctrltransfer** %p, align 8
  %23 = bitcast %struct.usbdevfs_ctrltransfer* %22 to i8*
  %call12 = call i32 @proc_control(%struct.usb_dev_state* %21, i8* %23)
  store i32 %call12, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %24 = load i32, i32* %retval, align 4
  ret i32 %24
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_bulk_compat(%struct.usb_dev_state* %ps, %struct.usbdevfs_bulktransfer32* %p32) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %p32.addr = alloca %struct.usbdevfs_bulktransfer32*, align 8
  %p = alloca %struct.usbdevfs_bulktransfer*, align 8
  %n = alloca i32, align 4
  %addr = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %__sp = alloca i8*, align 8
  %tmp = alloca i64, align 8
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i32, align 4
  %tmp5 = alloca i64, align 8
  %__ret_gu9 = alloca i32, align 4
  %__val_gu10 = alloca i64, align 8
  %__sp11 = alloca i8*, align 8
  %tmp16 = alloca i64, align 8
  %__ret_pu20 = alloca i32, align 4
  %__pu_val21 = alloca i32, align 4
  %tmp23 = alloca i64, align 8
  %__ret_gu27 = alloca i32, align 4
  %__val_gu28 = alloca i64, align 8
  %__sp29 = alloca i8*, align 8
  %tmp34 = alloca i64, align 8
  %__ret_pu38 = alloca i32, align 4
  %__pu_val39 = alloca i32, align 4
  %tmp41 = alloca i64, align 8
  %__ret_gu45 = alloca i32, align 4
  %__val_gu46 = alloca i64, align 8
  %__sp47 = alloca i8*, align 8
  %tmp52 = alloca i64, align 8
  %__ret_pu56 = alloca i32, align 4
  %__pu_val57 = alloca i8*, align 8
  %tmp60 = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store %struct.usbdevfs_bulktransfer32* %p32, %struct.usbdevfs_bulktransfer32** %p32.addr, align 8
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_bulktransfer*
  store %struct.usbdevfs_bulktransfer* %0, %struct.usbdevfs_bulktransfer** %p, align 8
  call void @might_fault()
  %1 = load i8*, i8** %__sp, align 8
  %2 = load %struct.usbdevfs_bulktransfer32*, %struct.usbdevfs_bulktransfer32** %p32.addr, align 8
  %ep = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %2, i32 0, i32 0
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %ep, i64 4, i8* %1) #4, !srcloc !15
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  store i32 %5, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  store i8* %asmresult2, i8** %__sp, align 8
  %6 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, i32* %n, align 4
  %7 = load i32, i32* %__ret_gu, align 4
  %conv3 = sext i32 %7 to i64
  store i64 %conv3, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %8, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %9 = load i32, i32* %n, align 4
  store i32 %9, i32* %__pu_val, align 4
  %10 = load i32, i32* %__pu_val, align 4
  %11 = load %struct.usbdevfs_bulktransfer*, %struct.usbdevfs_bulktransfer** %p, align 8
  %ep4 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %11, i32 0, i32 0
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %10, i32* %ep4) #4, !srcloc !16
  store i32 %12, i32* %__ret_pu, align 4
  %13 = load i32, i32* %__ret_pu, align 4
  %conv6 = sext i32 %13 to i64
  store i64 %conv6, i64* %tmp5, align 8
  %14 = load i64, i64* %tmp5, align 8
  %tobool7 = icmp ne i64 %14, 0
  br i1 %tobool7, label %if.then, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false
  call void @might_fault()
  %15 = load i8*, i8** %__sp11, align 8
  %16 = load %struct.usbdevfs_bulktransfer32*, %struct.usbdevfs_bulktransfer32** %p32.addr, align 8
  %len = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %16, i32 0, i32 1
  %17 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %len, i64 4, i8* %15) #4, !srcloc !17
  %asmresult12 = extractvalue { i32*, i64, i8* } %17, 0
  %asmresult13 = extractvalue { i32*, i64, i8* } %17, 1
  %asmresult14 = extractvalue { i32*, i64, i8* } %17, 2
  %18 = ptrtoint i32* %asmresult12 to i64
  %19 = trunc i64 %18 to i32
  store i32 %19, i32* %__ret_gu9, align 4
  store i64 %asmresult13, i64* %__val_gu10, align 8
  store i8* %asmresult14, i8** %__sp11, align 8
  %20 = load i64, i64* %__val_gu10, align 8
  %conv15 = trunc i64 %20 to i32
  store i32 %conv15, i32* %n, align 4
  %21 = load i32, i32* %__ret_gu9, align 4
  %conv17 = sext i32 %21 to i64
  store i64 %conv17, i64* %tmp16, align 8
  %22 = load i64, i64* %tmp16, align 8
  %tobool18 = icmp ne i64 %22, 0
  br i1 %tobool18, label %if.then, label %lor.lhs.false19

lor.lhs.false19:                                  ; preds = %lor.lhs.false8
  call void @might_fault()
  %23 = load i32, i32* %n, align 4
  store i32 %23, i32* %__pu_val21, align 4
  %24 = load i32, i32* %__pu_val21, align 4
  %25 = load %struct.usbdevfs_bulktransfer*, %struct.usbdevfs_bulktransfer** %p, align 8
  %len22 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %25, i32 0, i32 1
  %26 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %24, i32* %len22) #4, !srcloc !18
  store i32 %26, i32* %__ret_pu20, align 4
  %27 = load i32, i32* %__ret_pu20, align 4
  %conv24 = sext i32 %27 to i64
  store i64 %conv24, i64* %tmp23, align 8
  %28 = load i64, i64* %tmp23, align 8
  %tobool25 = icmp ne i64 %28, 0
  br i1 %tobool25, label %if.then, label %lor.lhs.false26

lor.lhs.false26:                                  ; preds = %lor.lhs.false19
  call void @might_fault()
  %29 = load i8*, i8** %__sp29, align 8
  %30 = load %struct.usbdevfs_bulktransfer32*, %struct.usbdevfs_bulktransfer32** %p32.addr, align 8
  %timeout = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %30, i32 0, i32 2
  %31 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %timeout, i64 4, i8* %29) #4, !srcloc !19
  %asmresult30 = extractvalue { i32*, i64, i8* } %31, 0
  %asmresult31 = extractvalue { i32*, i64, i8* } %31, 1
  %asmresult32 = extractvalue { i32*, i64, i8* } %31, 2
  %32 = ptrtoint i32* %asmresult30 to i64
  %33 = trunc i64 %32 to i32
  store i32 %33, i32* %__ret_gu27, align 4
  store i64 %asmresult31, i64* %__val_gu28, align 8
  store i8* %asmresult32, i8** %__sp29, align 8
  %34 = load i64, i64* %__val_gu28, align 8
  %conv33 = trunc i64 %34 to i32
  store i32 %conv33, i32* %n, align 4
  %35 = load i32, i32* %__ret_gu27, align 4
  %conv35 = sext i32 %35 to i64
  store i64 %conv35, i64* %tmp34, align 8
  %36 = load i64, i64* %tmp34, align 8
  %tobool36 = icmp ne i64 %36, 0
  br i1 %tobool36, label %if.then, label %lor.lhs.false37

lor.lhs.false37:                                  ; preds = %lor.lhs.false26
  call void @might_fault()
  %37 = load i32, i32* %n, align 4
  store i32 %37, i32* %__pu_val39, align 4
  %38 = load i32, i32* %__pu_val39, align 4
  %39 = load %struct.usbdevfs_bulktransfer*, %struct.usbdevfs_bulktransfer** %p, align 8
  %timeout40 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %39, i32 0, i32 2
  %40 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %38, i32* %timeout40) #4, !srcloc !20
  store i32 %40, i32* %__ret_pu38, align 4
  %41 = load i32, i32* %__ret_pu38, align 4
  %conv42 = sext i32 %41 to i64
  store i64 %conv42, i64* %tmp41, align 8
  %42 = load i64, i64* %tmp41, align 8
  %tobool43 = icmp ne i64 %42, 0
  br i1 %tobool43, label %if.then, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %lor.lhs.false37
  call void @might_fault()
  %43 = load i8*, i8** %__sp47, align 8
  %44 = load %struct.usbdevfs_bulktransfer32*, %struct.usbdevfs_bulktransfer32** %p32.addr, align 8
  %data = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %44, i32 0, i32 3
  %45 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4, i8* %43) #4, !srcloc !21
  %asmresult48 = extractvalue { i32*, i64, i8* } %45, 0
  %asmresult49 = extractvalue { i32*, i64, i8* } %45, 1
  %asmresult50 = extractvalue { i32*, i64, i8* } %45, 2
  %46 = ptrtoint i32* %asmresult48 to i64
  %47 = trunc i64 %46 to i32
  store i32 %47, i32* %__ret_gu45, align 4
  store i64 %asmresult49, i64* %__val_gu46, align 8
  store i8* %asmresult50, i8** %__sp47, align 8
  %48 = load i64, i64* %__val_gu46, align 8
  %conv51 = trunc i64 %48 to i32
  store i32 %conv51, i32* %addr, align 4
  %49 = load i32, i32* %__ret_gu45, align 4
  %conv53 = sext i32 %49 to i64
  store i64 %conv53, i64* %tmp52, align 8
  %50 = load i64, i64* %tmp52, align 8
  %tobool54 = icmp ne i64 %50, 0
  br i1 %tobool54, label %if.then, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %lor.lhs.false44
  call void @might_fault()
  %51 = load i32, i32* %addr, align 4
  %call58 = call i8* @compat_ptr(i32 %51)
  store i8* %call58, i8** %__pu_val57, align 8
  %52 = load i8*, i8** %__pu_val57, align 8
  %53 = load %struct.usbdevfs_bulktransfer*, %struct.usbdevfs_bulktransfer** %p, align 8
  %data59 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %53, i32 0, i32 3
  %54 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %52, i8** %data59) #4, !srcloc !22
  %55 = ptrtoint i8* %54 to i64
  %56 = trunc i64 %55 to i32
  store i32 %56, i32* %__ret_pu56, align 4
  %57 = load i32, i32* %__ret_pu56, align 4
  %conv61 = sext i32 %57 to i64
  store i64 %conv61, i64* %tmp60, align 8
  %58 = load i64, i64* %tmp60, align 8
  %tobool62 = icmp ne i64 %58, 0
  br i1 %tobool62, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false55, %lor.lhs.false44, %lor.lhs.false37, %lor.lhs.false26, %lor.lhs.false19, %lor.lhs.false8, %lor.lhs.false, %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false55
  %59 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %60 = load %struct.usbdevfs_bulktransfer*, %struct.usbdevfs_bulktransfer** %p, align 8
  %61 = bitcast %struct.usbdevfs_bulktransfer* %60 to i8*
  %call63 = call i32 @proc_bulk(%struct.usb_dev_state* %59, i8* %61)
  store i32 %call63, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %62 = load i32, i32* %retval, align 4
  ret i32 %62
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_disconnectsignal_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ds = alloca %struct.usbdevfs_disconnectsignal32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_disconnectsignal32* %ds to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  store i8* %0, i8** %to.addr.i, align 8
  store i8* %1, i8** %from.addr.i, align 8
  store i64 8, i64* %n.addr.i, align 8
  %2 = load i8*, i8** %to.addr.i, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true) #4
  %conv.i = trunc i64 %3 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %4 = load i8*, i8** %to.addr.i, align 8
  %5 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %5 to i32
  call void @kasan_check_write(i8* %4, i32 %conv1.i) #4
  %6 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %6, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %7 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %7 to i64
  %8 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %8
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %9 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %9, true
  %lnot.ext.i = zext i1 %9 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %9, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %10 = load i8*, i8** %to.addr.i, align 8
  %11 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %10, i64 %11, i1 zeroext false) #4
  %12 = load i8*, i8** %to.addr.i, align 8
  %13 = load i8*, i8** %from.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %14 to i32
  %call.i = call i64 @_copy_from_user(i8* %12, i8* %13, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %15 = load i32, i32* %sz.i, align 4
  %16 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %15, i64 %16) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %17 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %17, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_from_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_from_user.exit
  %signr = getelementptr inbounds %struct.usbdevfs_disconnectsignal32, %struct.usbdevfs_disconnectsignal32* %ds, i32 0, i32 0
  %18 = load i32, i32* %signr, align 4
  %19 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %discsignr = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %19, i32 0, i32 8
  store i32 %18, i32* %discsignr, align 8
  %context = getelementptr inbounds %struct.usbdevfs_disconnectsignal32, %struct.usbdevfs_disconnectsignal32* %ds, i32 0, i32 1
  %20 = load i32, i32* %context, align 4
  %call1 = call i8* @compat_ptr(i32 %20)
  %21 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %disccontext = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %21, i32 0, i32 11
  store i8* %call1, i8** %disccontext, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_submiturb_compat(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %uurb = alloca %struct.usbdevfs_urb, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load i8*, i8** %arg.addr, align 8
  %1 = bitcast i8* %0 to %struct.usbdevfs_urb32*
  %call = call i32 @get_urb32(%struct.usbdevfs_urb* %uurb, %struct.usbdevfs_urb32* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %3 = load i8*, i8** %arg.addr, align 8
  %4 = bitcast i8* %3 to %struct.usbdevfs_urb32*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %4, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc, i32 0, i32 0
  %5 = load i8*, i8** %arg.addr, align 8
  %call1 = call i32 @proc_do_submiturb(%struct.usb_dev_state* %2, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %arraydecay, i8* %5)
  store i32 %call1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_ioctl_compat(%struct.usb_dev_state* %ps, i32 %arg) #0 {
entry:
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i32, align 4
  %uioc = alloca %struct.usbdevfs_ioctl32*, align 8
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  %udata = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp2 = alloca i8, align 1
  %__gu_err = alloca i32, align 4
  %__gu_val = alloca i64, align 8
  %tmp12 = alloca i64, align 8
  %__gu_err16 = alloca i32, align 4
  %__gu_val17 = alloca i64, align 8
  %tmp24 = alloca i64, align 8
  %__gu_err28 = alloca i32, align 4
  %__gu_val29 = alloca i64, align 8
  %tmp35 = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i32 %arg, i32* %arg.addr, align 4
  %0 = load i32, i32* %arg.addr, align 4
  %conv = zext i32 %0 to i64
  %conv1 = trunc i64 %conv to i32
  %call = call i8* @compat_ptr(i32 %conv1)
  %1 = bitcast i8* %call to %struct.usbdevfs_ioctl32*
  store %struct.usbdevfs_ioctl32* %1, %struct.usbdevfs_ioctl32** %uioc, align 8
  %2 = load %struct.usbdevfs_ioctl32*, %struct.usbdevfs_ioctl32** %uioc, align 8
  %3 = ptrtoint %struct.usbdevfs_ioctl32* %2 to i64
  %4 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %4, %struct.task_struct** %pfo_ret__.i, align 8
  %5 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %5, %struct.task_struct** %tmp.i, align 8
  %6 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %6, i32 0, i32 151
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %7 = load i64, i64* %seg, align 8
  %call4 = call zeroext i1 @__chk_range_not_ok(i64 %3, i64 12, i64 %7)
  %frombool = zext i1 %call4 to i8
  store i8 %frombool, i8* %tmp2, align 1
  %8 = load i8, i8* %tmp2, align 1
  %tobool = trunc i8 %8 to i1
  %lnot = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  store i64 %conv7, i64* %tmp, align 8
  %9 = load i64, i64* %tmp, align 8
  %tobool8 = icmp ne i64 %9, 0
  br i1 %tobool8, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body

do.body:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %__gu_err, align 4
  %10 = load %struct.usbdevfs_ioctl32*, %struct.usbdevfs_ioctl32** %uioc, align 8
  %ifno = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %10, i32 0, i32 0
  %11 = bitcast i32* %ifno to %struct.__large_struct*
  %12 = load i32, i32* %__gu_err, align 4
  %13 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %11, i32 -14, i32 %12) #4, !srcloc !24
  %asmresult = extractvalue { i32, i64 } %13, 0
  %asmresult9 = extractvalue { i32, i64 } %13, 1
  store i32 %asmresult, i32* %__gu_err, align 4
  store i64 %asmresult9, i64* %__gu_val, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %14 = load i64, i64* %__gu_val, align 8
  %conv10 = trunc i64 %14 to i32
  %ifno11 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 0
  store i32 %conv10, i32* %ifno11, align 8
  %15 = load i32, i32* %__gu_err, align 4
  %conv13 = sext i32 %15 to i64
  store i64 %conv13, i64* %tmp12, align 8
  %16 = load i64, i64* %tmp12, align 8
  %tobool14 = icmp ne i64 %16, 0
  br i1 %tobool14, label %if.then, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %do.end
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body18

do.body18:                                        ; preds = %lor.lhs.false15
  store i32 0, i32* %__gu_err16, align 4
  %17 = load %struct.usbdevfs_ioctl32*, %struct.usbdevfs_ioctl32** %uioc, align 8
  %ioctl_code = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %17, i32 0, i32 1
  %18 = bitcast i32* %ioctl_code to %struct.__large_struct*
  %19 = load i32, i32* %__gu_err16, align 4
  %20 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %18, i32 -14, i32 %19) #4, !srcloc !26
  %asmresult19 = extractvalue { i32, i64 } %20, 0
  %asmresult20 = extractvalue { i32, i64 } %20, 1
  store i32 %asmresult19, i32* %__gu_err16, align 4
  store i64 %asmresult20, i64* %__gu_val17, align 8
  br label %do.end21

do.end21:                                         ; preds = %do.body18
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %21 = load i64, i64* %__gu_val17, align 8
  %conv22 = trunc i64 %21 to i32
  %ioctl_code23 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 1
  store i32 %conv22, i32* %ioctl_code23, align 4
  %22 = load i32, i32* %__gu_err16, align 4
  %conv25 = sext i32 %22 to i64
  store i64 %conv25, i64* %tmp24, align 8
  %23 = load i64, i64* %tmp24, align 8
  %tobool26 = icmp ne i64 %23, 0
  br i1 %tobool26, label %if.then, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %do.end21
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body30

do.body30:                                        ; preds = %lor.lhs.false27
  store i32 0, i32* %__gu_err28, align 4
  %24 = load %struct.usbdevfs_ioctl32*, %struct.usbdevfs_ioctl32** %uioc, align 8
  %data = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %24, i32 0, i32 2
  %25 = bitcast i32* %data to %struct.__large_struct*
  %26 = load i32, i32* %__gu_err28, align 4
  %27 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %25, i32 -14, i32 %26) #4, !srcloc !27
  %asmresult31 = extractvalue { i32, i64 } %27, 0
  %asmresult32 = extractvalue { i32, i64 } %27, 1
  store i32 %asmresult31, i32* %__gu_err28, align 4
  store i64 %asmresult32, i64* %__gu_val29, align 8
  br label %do.end33

do.end33:                                         ; preds = %do.body30
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %28 = load i64, i64* %__gu_val29, align 8
  %conv34 = trunc i64 %28 to i32
  store i32 %conv34, i32* %udata, align 4
  %29 = load i32, i32* %__gu_err28, align 4
  %conv36 = sext i32 %29 to i64
  store i64 %conv36, i64* %tmp35, align 8
  %30 = load i64, i64* %tmp35, align 8
  %tobool37 = icmp ne i64 %30, 0
  br i1 %tobool37, label %if.then, label %if.end

if.then:                                          ; preds = %do.end33, %do.end21, %do.end, %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end33
  %31 = load i32, i32* %udata, align 4
  %call38 = call i8* @compat_ptr(i32 %31)
  %data39 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 2
  store i8* %call38, i8** %data39, align 8
  %32 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call40 = call i32 @proc_ioctl(%struct.usb_dev_state* %32, %struct.usbdevfs_ioctl* %ctrl)
  store i32 %call40, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %33 = load i32, i32* %retval, align 4
  ret i32 %33
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @ptr_to_compat(i8* %uptr) #0 {
entry:
  %uptr.addr = alloca i8*, align 8
  store i8* %uptr, i8** %uptr.addr, align 8
  %0 = load i8*, i8** %uptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %conv = trunc i64 %1 to i32
  ret i32 %conv
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_unlinkurb(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %lock.addr.i11 = alloca %struct.spinlock*, align 8
  %flags.addr.i12 = alloca i64, align 8
  %__dummy.i13 = alloca i64, align 8
  %__dummy2.i14 = alloca i64, align 8
  %tmp.i15 = alloca i32, align 4
  %lock.addr.i9 = alloca %struct.spinlock*, align 8
  %flags.addr.i = alloca i64, align 8
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %tmp.i = alloca i32, align 4
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %urb = alloca %struct.urb*, align 8
  %as = alloca %struct.async*, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %0 = load i32, i32* %tmp, align 4
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %2 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %2, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %3 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  store i64 %call2, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.end
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %5 = load i8*, i8** %arg.addr, align 8
  %call4 = call %struct.async* @async_getpending(%struct.usb_dev_state* %4, i8* %5)
  store %struct.async* %call4, %struct.async** %as, align 8
  %6 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end3
  %7 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %7, i32 0, i32 3
  %8 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock5, %struct.spinlock** %lock.addr.i11, align 8
  store i64 %8, i64* %flags.addr.i12, align 8
  store i32 1, i32* %tmp.i15, align 4
  %9 = load i32, i32* %tmp.i15, align 4
  %10 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i11, align 8
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %10, i32 0, i32 0
  %rlock.i16 = bitcast %union.anon* %11 to %struct.raw_spinlock*
  %12 = load i64, i64* %flags.addr.i12, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i16, i64 %12) #4
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end3
  %13 = load %struct.async*, %struct.async** %as, align 8
  %urb6 = getelementptr inbounds %struct.async, %struct.async* %13, i32 0, i32 8
  %14 = load %struct.urb*, %struct.urb** %urb6, align 8
  store %struct.urb* %14, %struct.urb** %urb, align 8
  %15 = load %struct.urb*, %struct.urb** %urb, align 8
  %call7 = call %struct.urb* @usb_get_urb(%struct.urb* %15)
  %16 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %16, i32 0, i32 3
  %17 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock8, %struct.spinlock** %lock.addr.i9, align 8
  store i64 %17, i64* %flags.addr.i, align 8
  store i32 1, i32* %tmp.i, align 4
  %18 = load i32, i32* %tmp.i, align 4
  %19 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i9, align 8
  %20 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %19, i32 0, i32 0
  %rlock.i10 = bitcast %union.anon* %20 to %struct.raw_spinlock*
  %21 = load i64, i64* %flags.addr.i, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i10, i64 %21) #4
  %22 = load %struct.urb*, %struct.urb** %urb, align 8
  call void @usb_kill_urb(%struct.urb* %22)
  %23 = load %struct.urb*, %struct.urb** %urb, align 8
  call void @usb_free_urb(%struct.urb* %23)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %24 = load i32, i32* %retval, align 4
  ret i32 %24
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_disconnectsignal(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ds = alloca %struct.usbdevfs_disconnectsignal, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  store i8* %0, i8** %to.addr.i, align 8
  store i8* %1, i8** %from.addr.i, align 8
  store i64 16, i64* %n.addr.i, align 8
  %2 = load i8*, i8** %to.addr.i, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true) #4
  %conv.i = trunc i64 %3 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %4 = load i8*, i8** %to.addr.i, align 8
  %5 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %5 to i32
  call void @kasan_check_write(i8* %4, i32 %conv1.i) #4
  %6 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %6, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %7 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %7 to i64
  %8 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %8
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %9 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %9, true
  %lnot.ext.i = zext i1 %9 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %9, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %10 = load i8*, i8** %to.addr.i, align 8
  %11 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %10, i64 %11, i1 zeroext false) #4
  %12 = load i8*, i8** %to.addr.i, align 8
  %13 = load i8*, i8** %from.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %14 to i32
  %call.i = call i64 @_copy_from_user(i8* %12, i8* %13, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %15 = load i32, i32* %sz.i, align 4
  %16 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %15, i64 %16) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %17 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %17, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_from_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_from_user.exit
  %signr = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 0
  %18 = load i32, i32* %signr, align 8
  %19 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %discsignr = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %19, i32 0, i32 8
  store i32 %18, i32* %discsignr, align 8
  %context = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 1
  %20 = load i8*, i8** %context, align 8
  %21 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %disccontext = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %21, i32 0, i32 11
  store i8* %20, i8** %disccontext, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_claiminterface(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ifnum = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %__sp = alloca i8*, align 8
  %tmp = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %__sp, align 8
  %1 = load i8*, i8** %arg.addr, align 8
  %2 = bitcast i8* %1 to i32*
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %2, i64 4, i8* %0) #4, !srcloc !28
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  store i32 %5, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  store i8* %asmresult2, i8** %__sp, align 8
  %6 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, i32* %ifnum, align 4
  %7 = load i32, i32* %__ret_gu, align 4
  %conv3 = sext i32 %7 to i64
  store i64 %conv3, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %10 = load i32, i32* %ifnum, align 4
  %call = call i32 @claimintf(%struct.usb_dev_state* %9, i32 %10)
  store i32 %call, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, i32* %retval, align 4
  ret i32 %11
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_releaseinterface(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ifnum = alloca i32, align 4
  %ret = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %__sp = alloca i8*, align 8
  %tmp = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %__sp, align 8
  %1 = load i8*, i8** %arg.addr, align 8
  %2 = bitcast i8* %1 to i32*
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %2, i64 4, i8* %0) #4, !srcloc !29
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  store i32 %5, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  store i8* %asmresult2, i8** %__sp, align 8
  %6 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, i32* %ifnum, align 4
  %7 = load i32, i32* %__ret_gu, align 4
  %conv3 = sext i32 %7 to i64
  store i64 %conv3, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %10 = load i32, i32* %ifnum, align 4
  %call = call i32 @releaseintf(%struct.usb_dev_state* %9, i32 %10)
  store i32 %call, i32* %ret, align 4
  %11 = load i32, i32* %ret, align 4
  %cmp = icmp slt i32 %11, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %12 = load i32, i32* %ret, align 4
  store i32 %12, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %13 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %14 = load i32, i32* %ifnum, align 4
  call void @destroy_async_on_interface(%struct.usb_dev_state* %13, i32 %14)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_ioctl_default(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  store i8* %0, i8** %to.addr.i, align 8
  store i8* %1, i8** %from.addr.i, align 8
  store i64 16, i64* %n.addr.i, align 8
  %2 = load i8*, i8** %to.addr.i, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true) #4
  %conv.i = trunc i64 %3 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %4 = load i8*, i8** %to.addr.i, align 8
  %5 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %5 to i32
  call void @kasan_check_write(i8* %4, i32 %conv1.i) #4
  %6 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %6, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %7 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %7 to i64
  %8 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %8
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %9 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %9, true
  %lnot.ext.i = zext i1 %9 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %9, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %10 = load i8*, i8** %to.addr.i, align 8
  %11 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %10, i64 %11, i1 zeroext false) #4
  %12 = load i8*, i8** %to.addr.i, align 8
  %13 = load i8*, i8** %from.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %14 to i32
  %call.i = call i64 @_copy_from_user(i8* %12, i8* %13, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %15 = load i32, i32* %sz.i, align 4
  %16 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %15, i64 %16) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %17 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %17, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_from_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_from_user.exit
  %18 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call1 = call i32 @proc_ioctl(%struct.usb_dev_state* %18, %struct.usbdevfs_ioctl* %ctrl)
  store i32 %call1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_claim_port(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %pfo_ret__.i15 = alloca %struct.task_struct*, align 8
  %tmp.i16 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %portnum = alloca i32, align 4
  %rc = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %__sp = alloca i8*, align 8
  %tmp = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %__sp, align 8
  %1 = load i8*, i8** %arg.addr, align 8
  %2 = bitcast i8* %1 to i32*
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %2, i64 4, i8* %0) #4, !srcloc !30
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  store i32 %5, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  store i8* %asmresult2, i8** %__sp, align 8
  %6 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, i32* %portnum, align 4
  %7 = load i32, i32* %__ret_gu, align 4
  %conv3 = sext i32 %7 to i64
  store i64 %conv3, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %9, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %11 = load i32, i32* %portnum, align 4
  %12 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call = call i32 @usb_hub_claim_port(%struct.usb_device* %10, i32 %11, %struct.usb_dev_state* %12)
  store i32 %call, i32* %rc, align 4
  %13 = load i32, i32* %rc, align 4
  %cmp = icmp eq i32 %13, 0
  br i1 %cmp, label %if.then5, label %if.end14

if.then5:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then5
  %14 = load i8, i8* @usbfs_snoop, align 1
  %tobool6 = trunc i8 %14 to i1
  br i1 %tobool6, label %if.then7, label %if.end13

if.then7:                                         ; preds = %do.body
  %15 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %15, i32 0, i32 1
  %16 = load %struct.usb_device*, %struct.usb_device** %dev8, align 8
  %dev9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %16, i32 0, i32 11
  %17 = load i32, i32* %portnum, align 4
  %18 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %18, %struct.task_struct** %pfo_ret__.i, align 8
  %19 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %19, %struct.task_struct** %tmp.i, align 8
  %20 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call11 = call i32 @task_pid_nr(%struct.task_struct* %20)
  %21 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %21, %struct.task_struct** %pfo_ret__.i15, align 8
  %22 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i15, align 8
  store %struct.task_struct* %22, %struct.task_struct** %tmp.i16, align 8
  %23 = load %struct.task_struct*, %struct.task_struct** %tmp.i16, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %23, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev9, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.59, i32 0, i32 0), i32 %17, i32 %call11, i8* %arraydecay)
  br label %if.end13

if.end13:                                         ; preds = %if.then7, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end13
  br label %if.end14

if.end14:                                         ; preds = %do.end, %if.end
  %24 = load i32, i32* %rc, align 4
  store i32 %24, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then
  %25 = load i32, i32* %retval, align 4
  ret i32 %25
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_release_port(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %portnum = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %__sp = alloca i8*, align 8
  %tmp = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %__sp, align 8
  %1 = load i8*, i8** %arg.addr, align 8
  %2 = bitcast i8* %1 to i32*
  %3 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %2, i64 4, i8* %0) #4, !srcloc !31
  %asmresult = extractvalue { i32*, i64, i8* } %3, 0
  %asmresult1 = extractvalue { i32*, i64, i8* } %3, 1
  %asmresult2 = extractvalue { i32*, i64, i8* } %3, 2
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  store i32 %5, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  store i8* %asmresult2, i8** %__sp, align 8
  %6 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %6 to i32
  store i32 %conv, i32* %portnum, align 4
  %7 = load i32, i32* %__ret_gu, align 4
  %conv3 = sext i32 %7 to i64
  store i64 %conv3, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %9, i32 0, i32 1
  %10 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %11 = load i32, i32* %portnum, align 4
  %12 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call = call i32 @usb_hub_release_port(%struct.usb_device* %10, i32 %11, %struct.usb_dev_state* %12)
  store i32 %call, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load i32, i32* %retval, align 4
  ret i32 %13
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_get_capabilities(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %caps = alloca i32, align 4
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  store i32 117, i32* %caps, align 4
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8
  %no_stop_on_short = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 6
  %bf.load = load i8, i8* %no_stop_on_short, align 1
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %caps, align 4
  %or = or i32 %3, 2
  store i32 %or, i32* %caps, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %4, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  %bus2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %5, i32 0, i32 9
  %6 = load %struct.usb_bus*, %struct.usb_bus** %bus2, align 8
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %6, i32 0, i32 7
  %7 = load i32, i32* %sg_tablesize, align 4
  %tobool3 = icmp ne i32 %7, 0
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %8 = load i32, i32* %caps, align 4
  %or5 = or i32 %8, 8
  store i32 %or5, i32* %caps, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  call void @might_fault()
  %9 = load i32, i32* %caps, align 4
  store i32 %9, i32* %__pu_val, align 4
  %10 = load i32, i32* %__pu_val, align 4
  %11 = load i8*, i8** %arg.addr, align 8
  %12 = bitcast i8* %11 to i32*
  %13 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %10, i32* %12) #4, !srcloc !32
  store i32 %13, i32* %__ret_pu, align 4
  %14 = load i32, i32* %__ret_pu, align 4
  %conv = sext i32 %14 to i64
  store i64 %conv, i64* %tmp, align 8
  %15 = load i64, i64* %tmp, align 8
  %tobool7 = icmp ne i64 %15, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  store i32 -14, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end6
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then8
  %16 = load i32, i32* %retval, align 4
  ret i32 %16
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_disconnect_claim(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %dc = alloca %struct.usbdevfs_disconnect_claim, align 4
  %intf = alloca %struct.usb_interface*, align 8
  %driver8 = alloca %struct.usb_driver*, align 8
  %__mptr = alloca %struct.device_driver*, align 8
  %tmp = alloca %struct.usb_driver*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  store i8* %0, i8** %to.addr.i, align 8
  store i8* %1, i8** %from.addr.i, align 8
  store i64 264, i64* %n.addr.i, align 8
  %2 = load i8*, i8** %to.addr.i, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true) #4
  %conv.i = trunc i64 %3 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %4 = load i8*, i8** %to.addr.i, align 8
  %5 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %5 to i32
  call void @kasan_check_write(i8* %4, i32 %conv1.i) #4
  %6 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %6, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %7 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %7 to i64
  %8 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %8
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %9 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %9, true
  %lnot.ext.i = zext i1 %9 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %9, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %10 = load i8*, i8** %to.addr.i, align 8
  %11 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %10, i64 %11, i1 zeroext false) #4
  %12 = load i8*, i8** %to.addr.i, align 8
  %13 = load i8*, i8** %from.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %14 to i32
  %call.i = call i64 @_copy_from_user(i8* %12, i8* %13, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %15 = load i32, i32* %sz.i, align 4
  %16 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %15, i64 %16) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %17 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %17, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_from_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_from_user.exit
  %18 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %18, i32 0, i32 1
  %19 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %interface = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %20 = load i32, i32* %interface, align 4
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %19, i32 %20)
  store %struct.usb_interface* %call1, %struct.usb_interface** %intf, align 8
  %21 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %tobool2 = icmp ne %struct.usb_interface* %21, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %22 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %22, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev5, i32 0, i32 7
  %23 = load %struct.device_driver*, %struct.device_driver** %driver, align 8
  %tobool6 = icmp ne %struct.device_driver* %23, null
  br i1 %tobool6, label %if.then7, label %if.end34

if.then7:                                         ; preds = %if.end4
  %24 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev9 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %24, i32 0, i32 7
  %driver10 = getelementptr inbounds %struct.device, %struct.device* %dev9, i32 0, i32 7
  %25 = load %struct.device_driver*, %struct.device_driver** %driver10, align 8
  store %struct.device_driver* %25, %struct.device_driver** %__mptr, align 8
  %26 = load %struct.device_driver*, %struct.device_driver** %__mptr, align 8
  %27 = bitcast %struct.device_driver* %26 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %27, i64 -104
  %28 = bitcast i8* %add.ptr to %struct.usb_driver*
  store %struct.usb_driver* %28, %struct.usb_driver** %tmp, align 8
  %29 = load %struct.usb_driver*, %struct.usb_driver** %tmp, align 8
  store %struct.usb_driver* %29, %struct.usb_driver** %driver8, align 8
  %30 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %30, i32 0, i32 15
  %31 = load i8, i8* %privileges_dropped, align 8
  %tobool11 = trunc i8 %31 to i1
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.then7
  store i32 -13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.then7
  %flags = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %32 = load i32, i32* %flags, align 4
  %and = and i32 %32, 1
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end13
  %driver15 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver15, i32 0, i32 0
  %33 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev16 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %33, i32 0, i32 7
  %driver17 = getelementptr inbounds %struct.device, %struct.device* %dev16, i32 0, i32 7
  %34 = load %struct.device_driver*, %struct.device_driver** %driver17, align 8
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %34, i32 0, i32 0
  %35 = load i8*, i8** %name, align 8
  %call18 = call i32 @strncmp(i8* %arraydecay, i8* %35, i64 256)
  %cmp = icmp ne i32 %call18, 0
  br i1 %cmp, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true
  store i32 -16, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %land.lhs.true, %if.end13
  %flags21 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %36 = load i32, i32* %flags21, align 4
  %and22 = and i32 %36, 2
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %land.lhs.true24, label %if.end33

land.lhs.true24:                                  ; preds = %if.end20
  %driver25 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay26 = getelementptr inbounds [256 x i8], [256 x i8]* %driver25, i32 0, i32 0
  %37 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev27 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %37, i32 0, i32 7
  %driver28 = getelementptr inbounds %struct.device, %struct.device* %dev27, i32 0, i32 7
  %38 = load %struct.device_driver*, %struct.device_driver** %driver28, align 8
  %name29 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %38, i32 0, i32 0
  %39 = load i8*, i8** %name29, align 8
  %call30 = call i32 @strncmp(i8* %arraydecay26, i8* %39, i64 256)
  %cmp31 = icmp eq i32 %call30, 0
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %land.lhs.true24
  store i32 -16, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %land.lhs.true24, %if.end20
  %40 = load %struct.usb_driver*, %struct.usb_driver** %driver8, align 8
  %41 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  call void @usb_driver_release_interface(%struct.usb_driver* %40, %struct.usb_interface* %41)
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.end4
  %42 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %interface35 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %43 = load i32, i32* %interface35, align 4
  %call36 = call i32 @claimintf(%struct.usb_dev_state* %42, i32 %43)
  store i32 %call36, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end34, %if.then32, %if.then19, %if.then12, %if.then3, %if.then
  %44 = load i32, i32* %retval, align 4
  ret i32 %44
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_alloc_streams(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %num_streams = alloca i32, align 4
  %num_eps = alloca i32, align 4
  %eps = alloca %struct.usb_host_endpoint**, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %r = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %1 = load i8*, i8** %arg.addr, align 8
  %2 = bitcast i8* %1 to %struct.usbdevfs_streams*
  %call = call i32 @parse_usbdevfs_streams(%struct.usb_dev_state* %0, %struct.usbdevfs_streams* %2, i32* %num_streams, i32* %num_eps, %struct.usb_host_endpoint*** %eps, %struct.usb_interface** %intf)
  store i32 %call, i32* %r, align 4
  %3 = load i32, i32* %r, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %r, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %6 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %6, i32 0, i32 0
  %7 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %7, i64 0
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %8 = load i8, i8* %bInterfaceNumber, align 2
  %conv = zext i8 %8 to i32
  call void @destroy_async_on_interface(%struct.usb_dev_state* %5, i32 %conv)
  %9 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %10 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8
  %11 = load i32, i32* %num_eps, align 4
  %12 = load i32, i32* %num_streams, align 4
  %call1 = call i32 @usb_alloc_streams(%struct.usb_interface* %9, %struct.usb_host_endpoint** %10, i32 %11, i32 %12, i32 20971712)
  store i32 %call1, i32* %r, align 4
  %13 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8
  %14 = bitcast %struct.usb_host_endpoint** %13 to i8*
  call void @kfree(i8* %14)
  %15 = load i32, i32* %r, align 4
  store i32 %15, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load i32, i32* %retval, align 4
  ret i32 %16
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_free_streams(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %num_eps = alloca i32, align 4
  %eps = alloca %struct.usb_host_endpoint**, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %r = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %1 = load i8*, i8** %arg.addr, align 8
  %2 = bitcast i8* %1 to %struct.usbdevfs_streams*
  %call = call i32 @parse_usbdevfs_streams(%struct.usb_dev_state* %0, %struct.usbdevfs_streams* %2, i32* null, i32* %num_eps, %struct.usb_host_endpoint*** %eps, %struct.usb_interface** %intf)
  store i32 %call, i32* %r, align 4
  %3 = load i32, i32* %r, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %r, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %6 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %6, i32 0, i32 0
  %7 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %7, i64 0
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %8 = load i8, i8* %bInterfaceNumber, align 2
  %conv = zext i8 %8 to i32
  call void @destroy_async_on_interface(%struct.usb_dev_state* %5, i32 %conv)
  %9 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %10 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8
  %11 = load i32, i32* %num_eps, align 4
  %call1 = call i32 @usb_free_streams(%struct.usb_interface* %9, %struct.usb_host_endpoint** %10, i32 %11, i32 20971712)
  store i32 %call1, i32* %r, align 4
  %12 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8
  %13 = bitcast %struct.usb_host_endpoint** %12 to i8*
  call void @kfree(i8* %13)
  %14 = load i32, i32* %r, align 4
  store i32 %14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_drop_privileges(%struct.usb_dev_state* %ps, i8* %arg) #0 {
entry:
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %data = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast i32* %data to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  store i8* %0, i8** %to.addr.i, align 8
  store i8* %1, i8** %from.addr.i, align 8
  store i64 4, i64* %n.addr.i, align 8
  %2 = load i8*, i8** %to.addr.i, align 8
  %3 = call i64 @llvm.objectsize.i64.p0i8(i8* %2, i1 false, i1 true) #4
  %conv.i = trunc i64 %3 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %4 = load i8*, i8** %to.addr.i, align 8
  %5 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %5 to i32
  call void @kasan_check_write(i8* %4, i32 %conv1.i) #4
  %6 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %6, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %entry
  %7 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %7 to i64
  %8 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %8
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %entry
  %9 = phi i1 [ true, %entry ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %9, true
  %lnot.ext.i = zext i1 %9 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %9, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %10 = load i8*, i8** %to.addr.i, align 8
  %11 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %10, i64 %11, i1 zeroext false) #4
  %12 = load i8*, i8** %to.addr.i, align 8
  %13 = load i8*, i8** %from.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %14 to i32
  %call.i = call i64 @_copy_from_user(i8* %12, i8* %13, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %15 = load i32, i32* %sz.i, align 4
  %16 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %15, i64 %16) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %17 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %17, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %copy_from_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %copy_from_user.exit
  %18 = load i32, i32* %data, align 4
  %conv = zext i32 %18 to i64
  %19 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %interface_allowed_mask = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %19, i32 0, i32 16
  %20 = load i64, i64* %interface_allowed_mask, align 8
  %and = and i64 %20, %conv
  store i64 %and, i64* %interface_allowed_mask, align 8
  %21 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %21, i32 0, i32 15
  store i8 1, i8* %privileges_dropped, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.async* @reap_as(%struct.usb_dev_state* %ps) #0 {
entry:
  %pfo_ret__.i23 = alloca %struct.task_struct*, align 8
  %tmp.i24 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i21 = alloca %struct.task_struct*, align 8
  %tmp.i22 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i19 = alloca %struct.task_struct*, align 8
  %tmp.i20 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %wait = alloca %struct.__wait_queue, align 8
  %as = alloca %struct.async*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 1
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %0, %struct.task_struct** %pfo_ret__.i, align 8
  %1 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %1, %struct.task_struct** %tmp.i, align 8
  %2 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %3 = bitcast %struct.task_struct* %2 to i8*
  store i8* %3, i8** %private, align 8
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  store %struct.list_head* null, %struct.list_head** %next, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  store %struct.list_head* null, %struct.list_head** %prev, align 8
  store %struct.async* null, %struct.async** %as, align 8
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %4, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %5, %struct.usb_device** %dev, align 8
  %6 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %wait2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %6, i32 0, i32 7
  call void @add_wait_queue(%struct.__wait_queue_head* %wait2, %struct.__wait_queue* %wait)
  br label %for.cond

for.cond:                                         ; preds = %if.end11, %entry
  br label %do.body

do.body:                                          ; preds = %for.cond
  %7 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %7, %struct.task_struct** %pfo_ret__.i19, align 8
  %8 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i19, align 8
  store %struct.task_struct* %8, %struct.task_struct** %tmp.i20, align 8
  %9 = load %struct.task_struct*, %struct.task_struct** %tmp.i20, align 8
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %9, i32 0, i32 1
  store volatile i64 1, i64* %state, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %10 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call4 = call %struct.async* @async_getcompleted(%struct.usb_dev_state* %10)
  store %struct.async* %call4, %struct.async** %as, align 8
  %11 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %11, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %12 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call5 = call i32 @connected(%struct.usb_dev_state* %12)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %do.end
  br label %for.end

if.end:                                           ; preds = %lor.lhs.false
  %13 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %13, %struct.task_struct** %pfo_ret__.i21, align 8
  %14 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i21, align 8
  store %struct.task_struct* %14, %struct.task_struct** %tmp.i22, align 8
  %15 = load %struct.task_struct*, %struct.task_struct** %tmp.i22, align 8
  %call8 = call i32 @signal_pending(%struct.task_struct* %15)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  br label %for.end

if.end11:                                         ; preds = %if.end
  %16 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %16, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev12)
  call void @schedule()
  %17 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 11
  call void @device_lock(%struct.device* %dev13)
  br label %for.cond

for.end:                                          ; preds = %if.then10, %if.then
  %18 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %wait14 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %18, i32 0, i32 7
  call void @remove_wait_queue(%struct.__wait_queue_head* %wait14, %struct.__wait_queue* %wait)
  br label %do.body15

do.body15:                                        ; preds = %for.end
  store volatile i64 0, i64* %__ret, align 8
  %19 = load volatile i64, i64* %__ret, align 8
  %20 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %20, %struct.task_struct** %pfo_ret__.i23, align 8
  %21 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i23, align 8
  store %struct.task_struct* %21, %struct.task_struct** %tmp.i24, align 8
  %22 = load %struct.task_struct*, %struct.task_struct** %tmp.i24, align 8
  %state17 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %22, i32 0, i32 1
  %23 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state17, i64 %19, i64* %state17) #4, !srcloc !33
  store volatile i64 %23, i64* %__ret, align 8
  %24 = load volatile i64, i64* %__ret, align 8
  store i64 %24, i64* %tmp, align 8
  %25 = load i64, i64* %tmp, align 8
  br label %do.end18

do.end18:                                         ; preds = %do.body15
  %26 = load %struct.async*, %struct.async** %as, align 8
  ret %struct.async* %26
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @processcompl(%struct.async* %as, i8** %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %as.addr = alloca %struct.async*, align 8
  %arg.addr = alloca i8**, align 8
  %urb = alloca %struct.urb*, align 8
  %userurb = alloca %struct.usbdevfs_urb*, align 8
  %addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_pu13 = alloca i32, align 4
  %__pu_val14 = alloca i32, align 4
  %tmp17 = alloca i64, align 8
  %__ret_pu22 = alloca i32, align 4
  %__pu_val23 = alloca i32, align 4
  %tmp25 = alloca i64, align 8
  %__ret_pu34 = alloca i32, align 4
  %__pu_val35 = alloca i32, align 4
  %tmp41 = alloca i64, align 8
  %__ret_pu46 = alloca i32, align 4
  %__pu_val47 = alloca i32, align 4
  %tmp56 = alloca i64, align 8
  %__ret_pu62 = alloca i32, align 4
  %__pu_val63 = alloca i8*, align 8
  %tmp64 = alloca i64, align 8
  store %struct.async* %as, %struct.async** %as.addr, align 8
  store i8** %arg, i8*** %arg.addr, align 8
  %0 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %1 = load %struct.urb*, %struct.urb** %urb1, align 8
  store %struct.urb* %1, %struct.urb** %urb, align 8
  %2 = load %struct.async*, %struct.async** %as.addr, align 8
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 7
  %3 = load i8*, i8** %userurb2, align 8
  %4 = bitcast i8* %3 to %struct.usbdevfs_urb*
  store %struct.usbdevfs_urb* %4, %struct.usbdevfs_urb** %userurb, align 8
  %5 = load %struct.async*, %struct.async** %as.addr, align 8
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 7
  %6 = load i8*, i8** %userurb3, align 8
  store i8* %6, i8** %addr, align 8
  %7 = load %struct.async*, %struct.async** %as.addr, align 8
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %7, i32 0, i32 6
  %8 = load i8*, i8** %userbuffer, align 8
  %tobool = icmp ne i8* %8, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %9 = load %struct.urb*, %struct.urb** %urb, align 8
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %9, i32 0, i32 20
  %10 = load i32, i32* %actual_length, align 4
  %tobool4 = icmp ne i32 %10, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %11 = load %struct.async*, %struct.async** %as.addr, align 8
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 6
  %12 = load i8*, i8** %userbuffer5, align 8
  %13 = load %struct.urb*, %struct.urb** %urb, align 8
  %call = call i32 @copy_urb_data_to_user(i8* %12, %struct.urb* %13)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  br label %err_out

if.end:                                           ; preds = %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end, %land.lhs.true, %entry
  call void @might_fault()
  %14 = load %struct.async*, %struct.async** %as.addr, align 8
  %status = getelementptr inbounds %struct.async, %struct.async* %14, i32 0, i32 11
  %15 = load i32, i32* %status, align 4
  store i32 %15, i32* %__pu_val, align 4
  %16 = load i32, i32* %__pu_val, align 4
  %17 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %userurb, align 8
  %status9 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %17, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %16, i32* %status9) #4, !srcloc !34
  store i32 %18, i32* %__ret_pu, align 4
  %19 = load i32, i32* %__ret_pu, align 4
  %conv = sext i32 %19 to i64
  store i64 %conv, i64* %tmp, align 8
  %20 = load i64, i64* %tmp, align 8
  %tobool10 = icmp ne i64 %20, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  br label %err_out

if.end12:                                         ; preds = %if.end8
  call void @might_fault()
  %21 = load %struct.urb*, %struct.urb** %urb, align 8
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %21, i32 0, i32 20
  %22 = load i32, i32* %actual_length15, align 4
  store i32 %22, i32* %__pu_val14, align 4
  %23 = load i32, i32* %__pu_val14, align 4
  %24 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %userurb, align 8
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %24, i32 0, i32 6
  %25 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %23, i32* %actual_length16) #4, !srcloc !35
  store i32 %25, i32* %__ret_pu13, align 4
  %26 = load i32, i32* %__ret_pu13, align 4
  %conv18 = sext i32 %26 to i64
  store i64 %conv18, i64* %tmp17, align 8
  %27 = load i64, i64* %tmp17, align 8
  %tobool19 = icmp ne i64 %27, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end12
  br label %err_out

if.end21:                                         ; preds = %if.end12
  call void @might_fault()
  %28 = load %struct.urb*, %struct.urb** %urb, align 8
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %28, i32 0, i32 26
  %29 = load i32, i32* %error_count, align 4
  store i32 %29, i32* %__pu_val23, align 4
  %30 = load i32, i32* %__pu_val23, align 4
  %31 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %userurb, align 8
  %error_count24 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %31, i32 0, i32 9
  %32 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %30, i32* %error_count24) #4, !srcloc !36
  store i32 %32, i32* %__ret_pu22, align 4
  %33 = load i32, i32* %__ret_pu22, align 4
  %conv26 = sext i32 %33 to i64
  store i64 %conv26, i64* %tmp25, align 8
  %34 = load i64, i64* %tmp25, align 8
  %tobool27 = icmp ne i64 %34, 0
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end21
  br label %err_out

if.end29:                                         ; preds = %if.end21
  %35 = load %struct.urb*, %struct.urb** %urb, align 8
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %35, i32 0, i32 9
  %36 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %36, i32 0, i32 0
  %call30 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then32, label %if.end61

if.then32:                                        ; preds = %if.end29
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then32
  %37 = load i32, i32* %i, align 4
  %38 = load %struct.urb*, %struct.urb** %urb, align 8
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %38, i32 0, i32 24
  %39 = load i32, i32* %number_of_packets, align 4
  %cmp = icmp ult i32 %37, %39
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %40 = load %struct.urb*, %struct.urb** %urb, align 8
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %40, i32 0, i32 29
  %41 = load i32, i32* %i, align 4
  %idxprom = zext i32 %41 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length36 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx, i32 0, i32 2
  %42 = load i32, i32* %actual_length36, align 8
  store i32 %42, i32* %__pu_val35, align 4
  %43 = load i32, i32* %__pu_val35, align 4
  %44 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %userurb, align 8
  %iso_frame_desc37 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %44, i32 0, i32 12
  %45 = load i32, i32* %i, align 4
  %idxprom38 = zext i32 %45 to i64
  %arrayidx39 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc37, i64 0, i64 %idxprom38
  %actual_length40 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx39, i32 0, i32 1
  %46 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %43, i32* %actual_length40) #4, !srcloc !37
  store i32 %46, i32* %__ret_pu34, align 4
  %47 = load i32, i32* %__ret_pu34, align 4
  %conv42 = sext i32 %47 to i64
  store i64 %conv42, i64* %tmp41, align 8
  %48 = load i64, i64* %tmp41, align 8
  %tobool43 = icmp ne i64 %48, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %for.body
  br label %err_out

if.end45:                                         ; preds = %for.body
  call void @might_fault()
  %49 = load %struct.urb*, %struct.urb** %urb, align 8
  %iso_frame_desc48 = getelementptr inbounds %struct.urb, %struct.urb* %49, i32 0, i32 29
  %50 = load i32, i32* %i, align 4
  %idxprom49 = zext i32 %50 to i64
  %arrayidx50 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc48, i64 0, i64 %idxprom49
  %status51 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx50, i32 0, i32 3
  %51 = load i32, i32* %status51, align 4
  store i32 %51, i32* %__pu_val47, align 4
  %52 = load i32, i32* %__pu_val47, align 4
  %53 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %userurb, align 8
  %iso_frame_desc52 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %53, i32 0, i32 12
  %54 = load i32, i32* %i, align 4
  %idxprom53 = zext i32 %54 to i64
  %arrayidx54 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc52, i64 0, i64 %idxprom53
  %status55 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx54, i32 0, i32 2
  %55 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %52, i32* %status55) #4, !srcloc !38
  store i32 %55, i32* %__ret_pu46, align 4
  %56 = load i32, i32* %__ret_pu46, align 4
  %conv57 = sext i32 %56 to i64
  store i64 %conv57, i64* %tmp56, align 8
  %57 = load i64, i64* %tmp56, align 8
  %tobool58 = icmp ne i64 %57, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end45
  br label %err_out

if.end60:                                         ; preds = %if.end45
  br label %for.inc

for.inc:                                          ; preds = %if.end60
  %58 = load i32, i32* %i, align 4
  %inc = add i32 %58, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end61

if.end61:                                         ; preds = %for.end, %if.end29
  call void @might_fault()
  %59 = load i8*, i8** %addr, align 8
  store i8* %59, i8** %__pu_val63, align 8
  %60 = load i8*, i8** %__pu_val63, align 8
  %61 = load i8**, i8*** %arg.addr, align 8
  %62 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %60, i8** %61) #4, !srcloc !39
  %63 = ptrtoint i8* %62 to i64
  %64 = trunc i64 %63 to i32
  store i32 %64, i32* %__ret_pu62, align 4
  %65 = load i32, i32* %__ret_pu62, align 4
  %conv65 = sext i32 %65 to i64
  store i64 %conv65, i64* %tmp64, align 8
  %66 = load i64, i64* %tmp64, align 8
  %tobool66 = icmp ne i64 %66, 0
  br i1 %tobool66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.end61
  store i32 -14, i32* %retval, align 4
  br label %return

if.end68:                                         ; preds = %if.end61
  store i32 0, i32* %retval, align 4
  br label %return

err_out:                                          ; preds = %if.then59, %if.then44, %if.then28, %if.then20, %if.then11, %if.then7
  store i32 -14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_out, %if.end68, %if.then67
  %67 = load i32, i32* %retval, align 4
  ret i32 %67
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @free_async(%struct.async* %as) #0 {
entry:
  %as.addr = alloca %struct.async*, align 8
  %i = alloca i32, align 4
  store %struct.async* %as, %struct.async** %as.addr, align 8
  %0 = load %struct.async*, %struct.async** %as.addr, align 8
  %pid = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 2
  %1 = load %struct.pid*, %struct.pid** %pid, align 8
  call void @put_pid(%struct.pid* %1)
  %2 = load %struct.async*, %struct.async** %as.addr, align 8
  %cred = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 3
  %3 = load %struct.cred*, %struct.cred** %cred, align 8
  %tobool = icmp ne %struct.cred* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.async*, %struct.async** %as.addr, align 8
  %cred1 = getelementptr inbounds %struct.async, %struct.async* %4, i32 0, i32 3
  %5 = load %struct.cred*, %struct.cred** %cred1, align 8
  call void @put_cred(%struct.cred* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %7 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb = getelementptr inbounds %struct.async, %struct.async* %7, i32 0, i32 8
  %8 = load %struct.urb*, %struct.urb** %urb, align 8
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %8, i32 0, i32 18
  %9 = load i32, i32* %num_sgs, align 4
  %cmp = icmp slt i32 %6, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %10, i32 0, i32 8
  %11 = load %struct.urb*, %struct.urb** %urb2, align 8
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %11, i32 0, i32 16
  %12 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %12, i64 %idxprom
  %call = call %struct.page* @sg_page(%struct.scatterlist* %arrayidx)
  %tobool3 = icmp ne %struct.page* %call, null
  br i1 %tobool3, label %if.then4, label %if.end10

if.then4:                                         ; preds = %for.body
  %14 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb5 = getelementptr inbounds %struct.async, %struct.async* %14, i32 0, i32 8
  %15 = load %struct.urb*, %struct.urb** %urb5, align 8
  %sg6 = getelementptr inbounds %struct.urb, %struct.urb* %15, i32 0, i32 16
  %16 = load %struct.scatterlist*, %struct.scatterlist** %sg6, align 8
  %17 = load i32, i32* %i, align 4
  %idxprom7 = sext i32 %17 to i64
  %arrayidx8 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %16, i64 %idxprom7
  %call9 = call i8* @sg_virt(%struct.scatterlist* %arrayidx8)
  call void @kfree(i8* %call9)
  br label %if.end10

if.end10:                                         ; preds = %if.then4, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end10
  %18 = load i32, i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb11 = getelementptr inbounds %struct.async, %struct.async* %19, i32 0, i32 8
  %20 = load %struct.urb*, %struct.urb** %urb11, align 8
  %sg12 = getelementptr inbounds %struct.urb, %struct.urb* %20, i32 0, i32 16
  %21 = load %struct.scatterlist*, %struct.scatterlist** %sg12, align 8
  %22 = bitcast %struct.scatterlist* %21 to i8*
  call void @kfree(i8* %22)
  %23 = load %struct.async*, %struct.async** %as.addr, align 8
  %usbm = getelementptr inbounds %struct.async, %struct.async* %23, i32 0, i32 9
  %24 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %cmp13 = icmp eq %struct.usb_memory* %24, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %for.end
  %25 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb15 = getelementptr inbounds %struct.async, %struct.async* %25, i32 0, i32 8
  %26 = load %struct.urb*, %struct.urb** %urb15, align 8
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %26, i32 0, i32 14
  %27 = load i8*, i8** %transfer_buffer, align 8
  call void @kfree(i8* %27)
  br label %if.end18

if.else:                                          ; preds = %for.end
  %28 = load %struct.async*, %struct.async** %as.addr, align 8
  %usbm16 = getelementptr inbounds %struct.async, %struct.async* %28, i32 0, i32 9
  %29 = load %struct.usb_memory*, %struct.usb_memory** %usbm16, align 8
  %30 = load %struct.async*, %struct.async** %as.addr, align 8
  %usbm17 = getelementptr inbounds %struct.async, %struct.async* %30, i32 0, i32 9
  %31 = load %struct.usb_memory*, %struct.usb_memory** %usbm17, align 8
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %31, i32 0, i32 2
  call void @dec_usb_memory_use_count(%struct.usb_memory* %29, i32* %urb_use_count)
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then14
  %32 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb19 = getelementptr inbounds %struct.async, %struct.async* %32, i32 0, i32 8
  %33 = load %struct.urb*, %struct.urb** %urb19, align 8
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %33, i32 0, i32 21
  %34 = load i8*, i8** %setup_packet, align 8
  call void @kfree(i8* %34)
  %35 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb20 = getelementptr inbounds %struct.async, %struct.async* %35, i32 0, i32 8
  %36 = load %struct.urb*, %struct.urb** %urb20, align 8
  call void @usb_free_urb(%struct.urb* %36)
  %37 = load %struct.async*, %struct.async** %as.addr, align 8
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %37, i32 0, i32 10
  %38 = load i32, i32* %mem_usage, align 8
  %conv = zext i32 %38 to i64
  call void @usbfs_decrease_memory_usage(i64 %conv)
  %39 = load %struct.async*, %struct.async** %as.addr, align 8
  %40 = bitcast %struct.async* %39 to i8*
  call void @kfree(i8* %40)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #0 {
entry:
  %p.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %p, %struct.task_struct** %p.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %p.addr, align 8
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %0, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %conv2 = trunc i64 %conv to i32
  ret i32 %conv2
}

declare i32 @default_wake_function(%struct.__wait_queue*, i32, i32, i8*) #1

declare void @add_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.async* @async_getcompleted(%struct.usb_dev_state* %ps) #0 {
entry:
  %lock.addr.i8 = alloca %struct.spinlock*, align 8
  %flags.addr.i = alloca i64, align 8
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %tmp.i = alloca i32, align 4
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %flags = alloca i64, align 8
  %as = alloca %struct.async*, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__mptr = alloca %struct.list_head*, align 8
  %tmp6 = alloca %struct.async*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store %struct.async* null, %struct.async** %as, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %0 = load i32, i32* %tmp, align 4
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %2 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %2, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %3 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  store i64 %call2, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.end
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_completed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %4, i32 0, i32 5
  %call4 = call i32 @list_empty(%struct.list_head* %async_completed)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end3
  %5 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_completed5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %5, i32 0, i32 5
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_completed5, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %6, %struct.list_head** %__mptr, align 8
  %7 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr to %struct.async*
  store %struct.async* %9, %struct.async** %tmp6, align 8
  %10 = load %struct.async*, %struct.async** %tmp6, align 8
  store %struct.async* %10, %struct.async** %as, align 8
  %11 = load %struct.async*, %struct.async** %as, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  br label %if.end

if.end:                                           ; preds = %if.then, %do.end3
  %12 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock7 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %12, i32 0, i32 3
  %13 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock7, %struct.spinlock** %lock.addr.i8, align 8
  store i64 %13, i64* %flags.addr.i, align 8
  store i32 1, i32* %tmp.i, align 4
  %14 = load i32, i32* %tmp.i, align 4
  %15 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i8, align 8
  %16 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %15, i32 0, i32 0
  %rlock.i9 = bitcast %union.anon* %16 to %struct.raw_spinlock*
  %17 = load i64, i64* %flags.addr.i, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i9, i64 %17) #4
  %18 = load %struct.async*, %struct.async** %as, align 8
  ret %struct.async* %18
}

declare void @schedule() #1

declare void @remove_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @copy_urb_data_to_user(i8* %userbuffer, %struct.urb* %urb) #0 {
entry:
  %to.addr.i18 = alloca i8*, align 8
  %from.addr.i19 = alloca i8*, align 8
  %n.addr.i20 = alloca i64, align 8
  %sz.i21 = alloca i32, align 4
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %userbuffer.addr = alloca i8*, align 8
  %urb.addr = alloca %struct.urb*, align 8
  %i = alloca i32, align 4
  %len = alloca i32, align 4
  %size = alloca i32, align 4
  store i8* %userbuffer, i8** %userbuffer.addr, align 8
  store %struct.urb* %urb, %struct.urb** %urb.addr, align 8
  %0 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 24
  %1 = load i32, i32* %number_of_packets, align 4
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %2, i32 0, i32 19
  %3 = load i32, i32* %transfer_buffer_length, align 8
  store i32 %3, i32* %len, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4
  store i32 %5, i32* %len, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %6, i32 0, i32 18
  %7 = load i32, i32* %num_sgs, align 4
  %cmp1 = icmp eq i32 %7, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %8 = load i8*, i8** %userbuffer.addr, align 8
  %9 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %9, i32 0, i32 14
  %10 = load i8*, i8** %transfer_buffer, align 8
  %11 = load i32, i32* %len, align 4
  %conv = zext i32 %11 to i64
  store i8* %8, i8** %to.addr.i, align 8
  store i8* %10, i8** %from.addr.i, align 8
  store i64 %conv, i64* %n.addr.i, align 8
  %12 = load i8*, i8** %from.addr.i, align 8
  %13 = call i64 @llvm.objectsize.i64.p0i8(i8* %12, i1 false, i1 true) #4
  %conv.i = trunc i64 %13 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  %14 = load i8*, i8** %from.addr.i, align 8
  %15 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %15 to i32
  call void @kasan_check_read(i8* %14, i32 %conv1.i) #4
  call void @might_fault() #4
  %16 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %16, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %if.then2
  %17 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %17 to i64
  %18 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %18
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %if.then2
  %19 = phi i1 [ true, %if.then2 ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %19, true
  %lnot.ext.i = zext i1 %19 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %19, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %20 = load i8*, i8** %from.addr.i, align 8
  %21 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %20, i64 %21, i1 zeroext true) #4
  %22 = load i8*, i8** %to.addr.i, align 8
  %23 = load i8*, i8** %from.addr.i, align 8
  %24 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %24 to i32
  %call.i = call i64 @_copy_to_user(i8* %22, i8* %23, i32 %conv8.i) #4
  store i64 %call.i, i64* %n.addr.i, align 8
  br label %copy_to_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %25 = load i32, i32* %sz.i, align 4
  %26 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %25, i64 %26) #4
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i, %if.then.i
  %27 = load i64, i64* %n.addr.i, align 8
  %tobool = icmp ne i64 %27, 0
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %copy_to_user.exit
  store i32 -14, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %copy_to_user.exit
  store i32 0, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %28 = load i32, i32* %i, align 4
  %29 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %num_sgs6 = getelementptr inbounds %struct.urb, %struct.urb* %29, i32 0, i32 18
  %30 = load i32, i32* %num_sgs6, align 4
  %cmp7 = icmp ult i32 %28, %30
  br i1 %cmp7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %31 = load i32, i32* %len, align 4
  %tobool9 = icmp ne i32 %31, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %32 = phi i1 [ false, %for.cond ], [ %tobool9, %land.rhs ]
  br i1 %32, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %33 = load i32, i32* %len, align 4
  %cmp10 = icmp ugt i32 %33, 16384
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %34 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 16384, %cond.true ], [ %34, %cond.false ]
  store i32 %cond, i32* %size, align 4
  %35 = load i8*, i8** %userbuffer.addr, align 8
  %36 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %36, i32 0, i32 16
  %37 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8
  %38 = load i32, i32* %i, align 4
  %idxprom = zext i32 %38 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %37, i64 %idxprom
  %call12 = call i8* @sg_virt(%struct.scatterlist* %arrayidx)
  %39 = load i32, i32* %size, align 4
  %conv13 = zext i32 %39 to i64
  store i8* %35, i8** %to.addr.i18, align 8
  store i8* %call12, i8** %from.addr.i19, align 8
  store i64 %conv13, i64* %n.addr.i20, align 8
  %40 = load i8*, i8** %from.addr.i19, align 8
  %41 = call i64 @llvm.objectsize.i64.p0i8(i8* %40, i1 false, i1 true) #4
  %conv.i22 = trunc i64 %41 to i32
  store i32 %conv.i22, i32* %sz.i21, align 4
  %42 = load i8*, i8** %from.addr.i19, align 8
  %43 = load i64, i64* %n.addr.i20, align 8
  %conv1.i23 = trunc i64 %43 to i32
  call void @kasan_check_read(i8* %42, i32 %conv1.i23) #4
  call void @might_fault() #4
  %44 = load i32, i32* %sz.i21, align 4
  %cmp.i24 = icmp slt i32 %44, 0
  br i1 %cmp.i24, label %lor.end.i31, label %lor.rhs.i27

lor.rhs.i27:                                      ; preds = %cond.end
  %45 = load i32, i32* %sz.i21, align 4
  %conv3.i25 = sext i32 %45 to i64
  %46 = load i64, i64* %n.addr.i20, align 8
  %cmp4.i26 = icmp uge i64 %conv3.i25, %46
  br label %lor.end.i31

lor.end.i31:                                      ; preds = %lor.rhs.i27, %cond.end
  %47 = phi i1 [ true, %cond.end ], [ %cmp4.i26, %lor.rhs.i27 ]
  %lnot.i28 = xor i1 %47, true
  %lnot.ext.i29 = zext i1 %47 to i32
  %conv7.i30 = sext i32 %lnot.ext.i29 to i64
  br i1 %47, label %if.then.i34, label %if.else.i35

if.then.i34:                                      ; preds = %lor.end.i31
  %48 = load i8*, i8** %from.addr.i19, align 8
  %49 = load i64, i64* %n.addr.i20, align 8
  call void @check_object_size(i8* %48, i64 %49, i1 zeroext true) #4
  %50 = load i8*, i8** %to.addr.i18, align 8
  %51 = load i8*, i8** %from.addr.i19, align 8
  %52 = load i64, i64* %n.addr.i20, align 8
  %conv8.i32 = trunc i64 %52 to i32
  %call.i33 = call i64 @_copy_to_user(i8* %50, i8* %51, i32 %conv8.i32) #4
  store i64 %call.i33, i64* %n.addr.i20, align 8
  br label %copy_to_user.exit36

if.else.i35:                                      ; preds = %lor.end.i31
  %53 = load i32, i32* %sz.i21, align 4
  %54 = load i64, i64* %n.addr.i20, align 8
  call void @copy_user_overflow(i32 %53, i64 %54) #4
  br label %copy_to_user.exit36

copy_to_user.exit36:                              ; preds = %if.else.i35, %if.then.i34
  %55 = load i64, i64* %n.addr.i20, align 8
  %tobool15 = icmp ne i64 %55, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %copy_to_user.exit36
  store i32 -14, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %copy_to_user.exit36
  %56 = load i32, i32* %size, align 4
  %57 = load i8*, i8** %userbuffer.addr, align 8
  %idx.ext = zext i32 %56 to i64
  %add.ptr = getelementptr inbounds i8, i8* %57, i64 %idx.ext
  store i8* %add.ptr, i8** %userbuffer.addr, align 8
  %58 = load i32, i32* %size, align 4
  %59 = load i32, i32* %len, align 4
  %sub = sub i32 %59, %58
  store i32 %sub, i32* %len, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %60 = load i32, i32* %i, align 4
  %inc = add i32 %60, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then16, %if.end4, %if.then3
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %1 = load i8, i8* %bmAttributes, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @sg_virt(%struct.scatterlist* %sg) #0 {
entry:
  %page.addr.i = alloca %struct.page*, align 8
  %sg.addr = alloca %struct.scatterlist*, align 8
  store %struct.scatterlist* %sg, %struct.scatterlist** %sg.addr, align 8
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %call = call %struct.page* @sg_page(%struct.scatterlist* %0)
  store %struct.page* %call, %struct.page** %page.addr.i, align 8
  %1 = load %struct.page*, %struct.page** %page.addr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %1 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %2 = inttoptr i64 %add.i to i8*
  %3 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %offset = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %3, i32 0, i32 1
  %4 = load i32, i32* %offset, align 8
  %idx.ext = zext i32 %4 to i64
  %add.ptr = getelementptr i8, i8* %2, i64 %idx.ext
  ret i8* %add.ptr
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.page* @sg_page(%struct.scatterlist* %sg) #0 {
entry:
  %sg.addr = alloca %struct.scatterlist*, align 8
  store %struct.scatterlist* %sg, %struct.scatterlist** %sg.addr, align 8
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %page_link = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %0, i32 0, i32 0
  %1 = load i64, i64* %page_link, align 8
  %and = and i64 %1, -4
  %2 = inttoptr i64 %and to %struct.page*
  ret %struct.page* %2
}

declare void @put_pid(%struct.pid*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @put_cred(%struct.cred* %_cred) #0 {
entry:
  %v.addr.i = alloca %struct.atomic_t*, align 8
  %c.i = alloca i8, align 1
  %_cred.addr = alloca %struct.cred*, align 8
  %cred = alloca %struct.cred*, align 8
  store %struct.cred* %_cred, %struct.cred** %_cred.addr, align 8
  %0 = load %struct.cred*, %struct.cred** %_cred.addr, align 8
  store %struct.cred* %0, %struct.cred** %cred, align 8
  %1 = load %struct.cred*, %struct.cred** %cred, align 8
  call void @validate_creds(%struct.cred* %1)
  %2 = load %struct.cred*, %struct.cred** %cred, align 8
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %2, i32 0, i32 0
  store %struct.atomic_t* %usage, %struct.atomic_t** %v.addr.i, align 8
  %3 = load %struct.atomic_t*, %struct.atomic_t** %v.addr.i, align 8
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %3, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0;\0A\09sete $1\0A", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i8* %c.i, i32* %counter.i) #4, !srcloc !40
  %4 = load i8, i8* %c.i, align 1
  %tobool.i = trunc i8 %4 to i1
  br i1 %tobool.i, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.cred*, %struct.cred** %cred, align 8
  call void @__put_cred(%struct.cred* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @kfree(i8*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @dec_usb_memory_use_count(%struct.usb_memory* %usbm, i32* %count) #0 {
entry:
  %lock.addr.i16 = alloca %struct.spinlock*, align 8
  %flags.addr.i17 = alloca i64, align 8
  %__dummy.i18 = alloca i64, align 8
  %__dummy2.i19 = alloca i64, align 8
  %tmp.i20 = alloca i32, align 4
  %lock.addr.i14 = alloca %struct.spinlock*, align 8
  %flags.addr.i = alloca i64, align 8
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %tmp.i = alloca i32, align 4
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %usbm.addr = alloca %struct.usb_memory*, align 8
  %count.addr = alloca i32*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.usb_memory* %usbm, %struct.usb_memory** %usbm.addr, align 8
  store i32* %count, i32** %count.addr, align 8
  %0 = load %struct.usb_memory*, %struct.usb_memory** %usbm.addr, align 8
  %ps1 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %0, i32 0, i32 7
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8
  store %struct.usb_dev_state* %1, %struct.usb_dev_state** %ps, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body2

do.body2:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %2 = load i32, i32* %tmp, align 4
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %4 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %4, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %5 to %struct.raw_spinlock*
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  store i64 %call3, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body2
  br label %do.end4

do.end4:                                          ; preds = %do.end
  %6 = load i32*, i32** %count.addr, align 8
  %7 = load i32, i32* %6, align 4
  %dec = add nsw i32 %7, -1
  store i32 %dec, i32* %6, align 4
  %8 = load %struct.usb_memory*, %struct.usb_memory** %usbm.addr, align 8
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %8, i32 0, i32 2
  %9 = load i32, i32* %urb_use_count, align 4
  %cmp5 = icmp eq i32 %9, 0
  br i1 %cmp5, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %do.end4
  %10 = load %struct.usb_memory*, %struct.usb_memory** %usbm.addr, align 8
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %10, i32 0, i32 1
  %11 = load i32, i32* %vma_use_count, align 8
  %cmp7 = icmp eq i32 %11, 0
  br i1 %cmp7, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %12 = load %struct.usb_memory*, %struct.usb_memory** %usbm.addr, align 8
  %memlist = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %12, i32 0, i32 0
  call void @list_del(%struct.list_head* %memlist)
  %13 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock9 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %13, i32 0, i32 3
  %14 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock9, %struct.spinlock** %lock.addr.i16, align 8
  store i64 %14, i64* %flags.addr.i17, align 8
  store i32 1, i32* %tmp.i20, align 4
  %15 = load i32, i32* %tmp.i20, align 4
  %16 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i16, align 8
  %17 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %16, i32 0, i32 0
  %rlock.i21 = bitcast %union.anon* %17 to %struct.raw_spinlock*
  %18 = load i64, i64* %flags.addr.i17, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i21, i64 %18) #4
  %19 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %19, i32 0, i32 1
  %20 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %21 = load %struct.usb_memory*, %struct.usb_memory** %usbm.addr, align 8
  %size = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %21, i32 0, i32 3
  %22 = load i32, i32* %size, align 8
  %conv10 = zext i32 %22 to i64
  %23 = load %struct.usb_memory*, %struct.usb_memory** %usbm.addr, align 8
  %mem = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %23, i32 0, i32 4
  %24 = load i8*, i8** %mem, align 8
  %25 = load %struct.usb_memory*, %struct.usb_memory** %usbm.addr, align 8
  %dma_handle = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %25, i32 0, i32 5
  %26 = load i64, i64* %dma_handle, align 8
  call void @usb_free_coherent(%struct.usb_device* %20, i64 %conv10, i8* %24, i64 %26)
  %27 = load %struct.usb_memory*, %struct.usb_memory** %usbm.addr, align 8
  %size11 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %27, i32 0, i32 3
  %28 = load i32, i32* %size11, align 8
  %conv12 = zext i32 %28 to i64
  %add = add i64 %conv12, 64
  call void @usbfs_decrease_memory_usage(i64 %add)
  %29 = load %struct.usb_memory*, %struct.usb_memory** %usbm.addr, align 8
  %30 = bitcast %struct.usb_memory* %29 to i8*
  call void @kfree(i8* %30)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %do.end4
  %31 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock13 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %31, i32 0, i32 3
  %32 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock13, %struct.spinlock** %lock.addr.i14, align 8
  store i64 %32, i64* %flags.addr.i, align 8
  store i32 1, i32* %tmp.i, align 4
  %33 = load i32, i32* %tmp.i, align 4
  %34 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i14, align 8
  %35 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %34, i32 0, i32 0
  %rlock.i15 = bitcast %union.anon* %35 to %struct.raw_spinlock*
  %36 = load i64, i64* %flags.addr.i, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i15, i64 %36) #4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @usbfs_decrease_memory_usage(i64 %amount) #0 {
entry:
  %amount.addr = alloca i64, align 8
  store i64 %amount, i64* %amount.addr, align 8
  %0 = load i64, i64* %amount.addr, align 8
  call void @atomic64_sub(i64 %0, %struct.atomic64_t* @usbfs_memory_usage)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @validate_creds(%struct.cred* %cred) #0 {
entry:
  %cred.addr = alloca %struct.cred*, align 8
  store %struct.cred* %cred, %struct.cred** %cred.addr, align 8
  ret void
}

declare void @__put_cred(%struct.cred*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @list_del(%struct.list_head* %entry1) #0 {
entry:
  %entry.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %entry1, %struct.list_head** %entry.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  call void @__list_del_entry(%struct.list_head* %0)
  %1 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 256 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next, align 8
  %2 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %2, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 512 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev, align 8
  ret void
}

declare void @usb_free_coherent(%struct.usb_device*, i64, i8*, i64) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @atomic64_sub(i64 %i, %struct.atomic64_t* %v) #0 {
entry:
  %i.addr = alloca i64, align 8
  %v.addr = alloca %struct.atomic64_t*, align 8
  store i64 %i, i64* %i.addr, align 8
  store %struct.atomic64_t* %v, %struct.atomic64_t** %v.addr, align 8
  %0 = load %struct.atomic64_t*, %struct.atomic64_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %0, i32 0, i32 0
  %1 = load i64, i64* %i.addr, align 8
  %2 = load %struct.atomic64_t*, %struct.atomic64_t** %v.addr, align 8
  %counter1 = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %2, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subq $1,$0", "=*m,er,*m,~{dirflag},~{fpsr},~{flags}"(i64* %counter, i64 %1, i64* %counter1) #4, !srcloc !41
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #0 {
entry:
  %tsk.addr = alloca %struct.task_struct*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.task_struct* %tsk, %struct.task_struct** %tsk.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load %struct.task_struct*, %struct.task_struct** %tsk.addr, align 8
  %call = call %struct.thread_info* @task_thread_info(%struct.task_struct* %0)
  %1 = load i32, i32* %flag.addr, align 4
  %call1 = call i32 @test_ti_thread_flag(%struct.thread_info* %call, i32 %1)
  ret i32 %call1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #0 {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %oldbit.i = alloca i8, align 1
  %ti.addr = alloca %struct.thread_info*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.thread_info* %ti, %struct.thread_info** %ti.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load i32, i32* %flag.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load %struct.thread_info*, %struct.thread_info** %ti.addr, align 8
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %1, i32 0, i32 0
  store i64 %conv, i64* %nr.addr.i, align 8
  store i64* %flags, i64** %addr.addr.i, align 8
  %2 = load i64*, i64** %addr.addr.i, align 8
  %3 = load i64, i64* %nr.addr.i, align 8
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %2, i64 %3) #4, !srcloc !5
  %4 = load i8, i8* %oldbit.i, align 1
  %tobool.i = trunc i8 %4 to i1
  %conv1 = zext i1 %tobool.i to i32
  ret i32 %conv1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.thread_info* @task_thread_info(%struct.task_struct* %task) #0 {
entry:
  %task.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %task, %struct.task_struct** %task.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %task.addr, align 8
  %thread_info = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 0
  ret %struct.thread_info* %thread_info
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @processcompl_compat(%struct.async* %as, i8** %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %as.addr = alloca %struct.async*, align 8
  %arg.addr = alloca i8**, align 8
  %urb = alloca %struct.urb*, align 8
  %userurb = alloca %struct.usbdevfs_urb32*, align 8
  %addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_pu13 = alloca i32, align 4
  %__pu_val14 = alloca i32, align 4
  %tmp17 = alloca i64, align 8
  %__ret_pu22 = alloca i32, align 4
  %__pu_val23 = alloca i32, align 4
  %tmp25 = alloca i64, align 8
  %__ret_pu34 = alloca i32, align 4
  %__pu_val35 = alloca i32, align 4
  %tmp41 = alloca i64, align 8
  %__ret_pu46 = alloca i32, align 4
  %__pu_val47 = alloca i32, align 4
  %tmp56 = alloca i64, align 8
  %__ret_pu62 = alloca i32, align 4
  %__pu_val63 = alloca i32, align 4
  %tmp65 = alloca i64, align 8
  store %struct.async* %as, %struct.async** %as.addr, align 8
  store i8** %arg, i8*** %arg.addr, align 8
  %0 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %1 = load %struct.urb*, %struct.urb** %urb1, align 8
  store %struct.urb* %1, %struct.urb** %urb, align 8
  %2 = load %struct.async*, %struct.async** %as.addr, align 8
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 7
  %3 = load i8*, i8** %userurb2, align 8
  %4 = bitcast i8* %3 to %struct.usbdevfs_urb32*
  store %struct.usbdevfs_urb32* %4, %struct.usbdevfs_urb32** %userurb, align 8
  %5 = load %struct.async*, %struct.async** %as.addr, align 8
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 7
  %6 = load i8*, i8** %userurb3, align 8
  store i8* %6, i8** %addr, align 8
  %7 = load %struct.async*, %struct.async** %as.addr, align 8
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %7, i32 0, i32 6
  %8 = load i8*, i8** %userbuffer, align 8
  %tobool = icmp ne i8* %8, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %9 = load %struct.urb*, %struct.urb** %urb, align 8
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %9, i32 0, i32 20
  %10 = load i32, i32* %actual_length, align 4
  %tobool4 = icmp ne i32 %10, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %11 = load %struct.async*, %struct.async** %as.addr, align 8
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 6
  %12 = load i8*, i8** %userbuffer5, align 8
  %13 = load %struct.urb*, %struct.urb** %urb, align 8
  %call = call i32 @copy_urb_data_to_user(i8* %12, %struct.urb* %13)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end, %land.lhs.true, %entry
  call void @might_fault()
  %14 = load %struct.async*, %struct.async** %as.addr, align 8
  %status = getelementptr inbounds %struct.async, %struct.async* %14, i32 0, i32 11
  %15 = load i32, i32* %status, align 4
  store i32 %15, i32* %__pu_val, align 4
  %16 = load i32, i32* %__pu_val, align 4
  %17 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %userurb, align 8
  %status9 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %17, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %16, i32* %status9) #4, !srcloc !42
  store i32 %18, i32* %__ret_pu, align 4
  %19 = load i32, i32* %__ret_pu, align 4
  %conv = sext i32 %19 to i64
  store i64 %conv, i64* %tmp, align 8
  %20 = load i64, i64* %tmp, align 8
  %tobool10 = icmp ne i64 %20, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end8
  call void @might_fault()
  %21 = load %struct.urb*, %struct.urb** %urb, align 8
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %21, i32 0, i32 20
  %22 = load i32, i32* %actual_length15, align 4
  store i32 %22, i32* %__pu_val14, align 4
  %23 = load i32, i32* %__pu_val14, align 4
  %24 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %userurb, align 8
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %24, i32 0, i32 6
  %25 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %23, i32* %actual_length16) #4, !srcloc !43
  store i32 %25, i32* %__ret_pu13, align 4
  %26 = load i32, i32* %__ret_pu13, align 4
  %conv18 = sext i32 %26 to i64
  store i64 %conv18, i64* %tmp17, align 8
  %27 = load i64, i64* %tmp17, align 8
  %tobool19 = icmp ne i64 %27, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end12
  store i32 -14, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end12
  call void @might_fault()
  %28 = load %struct.urb*, %struct.urb** %urb, align 8
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %28, i32 0, i32 26
  %29 = load i32, i32* %error_count, align 4
  store i32 %29, i32* %__pu_val23, align 4
  %30 = load i32, i32* %__pu_val23, align 4
  %31 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %userurb, align 8
  %error_count24 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %31, i32 0, i32 9
  %32 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %30, i32* %error_count24) #4, !srcloc !44
  store i32 %32, i32* %__ret_pu22, align 4
  %33 = load i32, i32* %__ret_pu22, align 4
  %conv26 = sext i32 %33 to i64
  store i64 %conv26, i64* %tmp25, align 8
  %34 = load i64, i64* %tmp25, align 8
  %tobool27 = icmp ne i64 %34, 0
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end21
  store i32 -14, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %if.end21
  %35 = load %struct.urb*, %struct.urb** %urb, align 8
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %35, i32 0, i32 9
  %36 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %36, i32 0, i32 0
  %call30 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then32, label %if.end61

if.then32:                                        ; preds = %if.end29
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then32
  %37 = load i32, i32* %i, align 4
  %38 = load %struct.urb*, %struct.urb** %urb, align 8
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %38, i32 0, i32 24
  %39 = load i32, i32* %number_of_packets, align 4
  %cmp = icmp ult i32 %37, %39
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %40 = load %struct.urb*, %struct.urb** %urb, align 8
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %40, i32 0, i32 29
  %41 = load i32, i32* %i, align 4
  %idxprom = zext i32 %41 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length36 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx, i32 0, i32 2
  %42 = load i32, i32* %actual_length36, align 8
  store i32 %42, i32* %__pu_val35, align 4
  %43 = load i32, i32* %__pu_val35, align 4
  %44 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %userurb, align 8
  %iso_frame_desc37 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %44, i32 0, i32 12
  %45 = load i32, i32* %i, align 4
  %idxprom38 = zext i32 %45 to i64
  %arrayidx39 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc37, i64 0, i64 %idxprom38
  %actual_length40 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx39, i32 0, i32 1
  %46 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %43, i32* %actual_length40) #4, !srcloc !45
  store i32 %46, i32* %__ret_pu34, align 4
  %47 = load i32, i32* %__ret_pu34, align 4
  %conv42 = sext i32 %47 to i64
  store i64 %conv42, i64* %tmp41, align 8
  %48 = load i64, i64* %tmp41, align 8
  %tobool43 = icmp ne i64 %48, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %for.body
  store i32 -14, i32* %retval, align 4
  br label %return

if.end45:                                         ; preds = %for.body
  call void @might_fault()
  %49 = load %struct.urb*, %struct.urb** %urb, align 8
  %iso_frame_desc48 = getelementptr inbounds %struct.urb, %struct.urb* %49, i32 0, i32 29
  %50 = load i32, i32* %i, align 4
  %idxprom49 = zext i32 %50 to i64
  %arrayidx50 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc48, i64 0, i64 %idxprom49
  %status51 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx50, i32 0, i32 3
  %51 = load i32, i32* %status51, align 4
  store i32 %51, i32* %__pu_val47, align 4
  %52 = load i32, i32* %__pu_val47, align 4
  %53 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %userurb, align 8
  %iso_frame_desc52 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %53, i32 0, i32 12
  %54 = load i32, i32* %i, align 4
  %idxprom53 = zext i32 %54 to i64
  %arrayidx54 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc52, i64 0, i64 %idxprom53
  %status55 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx54, i32 0, i32 2
  %55 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %52, i32* %status55) #4, !srcloc !46
  store i32 %55, i32* %__ret_pu46, align 4
  %56 = load i32, i32* %__ret_pu46, align 4
  %conv57 = sext i32 %56 to i64
  store i64 %conv57, i64* %tmp56, align 8
  %57 = load i64, i64* %tmp56, align 8
  %tobool58 = icmp ne i64 %57, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end45
  store i32 -14, i32* %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.end45
  br label %for.inc

for.inc:                                          ; preds = %if.end60
  %58 = load i32, i32* %i, align 4
  %inc = add i32 %58, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end61

if.end61:                                         ; preds = %for.end, %if.end29
  call void @might_fault()
  %59 = load i8*, i8** %addr, align 8
  %call64 = call i32 @ptr_to_compat(i8* %59)
  store i32 %call64, i32* %__pu_val63, align 4
  %60 = load i32, i32* %__pu_val63, align 4
  %61 = load i8**, i8*** %arg.addr, align 8
  %62 = bitcast i8** %61 to i32*
  %63 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %60, i32* %62) #4, !srcloc !47
  store i32 %63, i32* %__ret_pu62, align 4
  %64 = load i32, i32* %__ret_pu62, align 4
  %conv66 = sext i32 %64 to i64
  store i64 %conv66, i64* %tmp65, align 8
  %65 = load i64, i64* %tmp65, align 8
  %tobool67 = icmp ne i64 %65, 0
  br i1 %tobool67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.end61
  store i32 -14, i32* %retval, align 4
  br label %return

if.end69:                                         ; preds = %if.end61
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end69, %if.then68, %if.then59, %if.then44, %if.then28, %if.then20, %if.then11, %if.then7
  %66 = load i32, i32* %retval, align 4
  ret i32 %66
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @check_ctrlrecip(%struct.usb_dev_state* %ps, i32 %requesttype, i32 %request, i32 %index) #0 {
entry:
  %pfo_ret__.i55 = alloca %struct.task_struct*, align 8
  %tmp.i56 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %requesttype.addr = alloca i32, align 4
  %request.addr = alloca i32, align 4
  %index.addr = alloca i32, align 4
  %ret = alloca i32, align 4
  %alt_setting = alloca %struct.usb_host_interface*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i32 %requesttype, i32* %requesttype.addr, align 4
  store i32 %request, i32* %request.addr, align 4
  store i32 %index, i32* %index.addr, align 4
  store i32 0, i32* %ret, align 4
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8
  %cmp = icmp ne i32 %2, 4
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  %state2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 3
  %5 = load i32, i32* %state2, align 8
  %cmp3 = icmp ne i32 %5, 6
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %6, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %dev5, align 8
  %state6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 3
  %8 = load i32, i32* %state6, align 8
  %cmp7 = icmp ne i32 %8, 7
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  store i32 -113, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %entry
  %9 = load i32, i32* %requesttype.addr, align 4
  %and = and i32 96, %9
  %cmp8 = icmp eq i32 64, %and
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %10 = load i32, i32* %requesttype.addr, align 4
  %cmp11 = icmp eq i32 %10, 161
  br i1 %cmp11, label %land.lhs.true12, label %if.end22

land.lhs.true12:                                  ; preds = %if.end10
  %11 = load i32, i32* %request.addr, align 4
  %cmp13 = icmp eq i32 %11, 0
  br i1 %cmp13, label %if.then14, label %if.end22

if.then14:                                        ; preds = %land.lhs.true12
  %12 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev15 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %12, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %dev15, align 8
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 15
  %14 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %15 = load i32, i32* %index.addr, align 4
  %shr = lshr i32 %15, 8
  %16 = load i32, i32* %index.addr, align 4
  %and16 = and i32 %16, 255
  %call = call %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %14, i32 %shr, i32 %and16)
  store %struct.usb_host_interface* %call, %struct.usb_host_interface** %alt_setting, align 8
  %17 = load %struct.usb_host_interface*, %struct.usb_host_interface** %alt_setting, align 8
  %tobool = icmp ne %struct.usb_host_interface* %17, null
  br i1 %tobool, label %land.lhs.true17, label %if.end21

land.lhs.true17:                                  ; preds = %if.then14
  %18 = load %struct.usb_host_interface*, %struct.usb_host_interface** %alt_setting, align 8
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %18, i32 0, i32 0
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %19 = load i8, i8* %bInterfaceClass, align 1
  %conv = zext i8 %19 to i32
  %cmp18 = icmp eq i32 %conv, 7
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true17
  store i32 0, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %land.lhs.true17, %if.then14
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %land.lhs.true12, %if.end10
  %20 = load i32, i32* %index.addr, align 4
  %and23 = and i32 %20, 255
  store i32 %and23, i32* %index.addr, align 4
  %21 = load i32, i32* %requesttype.addr, align 4
  %and24 = and i32 %21, 31
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end22
  %Pivot = icmp slt i32 %and24, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and24, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %and24, 1
  br i1 %SwitchLeaf, label %sw.bb53, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %22 = load i32, i32* %index.addr, align 4
  %and25 = and i32 %22, -129
  %cmp26 = icmp eq i32 %and25, 0
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %sw.bb
  store i32 0, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %sw.bb
  %23 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev30 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %23, i32 0, i32 1
  %24 = load %struct.usb_device*, %struct.usb_device** %dev30, align 8
  %25 = load i32, i32* %index.addr, align 4
  %call31 = call i32 @findintfep(%struct.usb_device* %24, i32 %25)
  store i32 %call31, i32* %ret, align 4
  %26 = load i32, i32* %ret, align 4
  %cmp32 = icmp slt i32 %26, 0
  br i1 %cmp32, label %if.then34, label %if.end47

if.then34:                                        ; preds = %if.end29
  %27 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev35 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %27, i32 0, i32 1
  %28 = load %struct.usb_device*, %struct.usb_device** %dev35, align 8
  %29 = load i32, i32* %index.addr, align 4
  %xor = xor i32 %29, 128
  %call36 = call i32 @findintfep(%struct.usb_device* %28, i32 %xor)
  store i32 %call36, i32* %ret, align 4
  %30 = load i32, i32* %ret, align 4
  %cmp37 = icmp sge i32 %30, 0
  br i1 %cmp37, label %if.then39, label %if.end46

if.then39:                                        ; preds = %if.then34
  %31 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev40 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %31, i32 0, i32 1
  %32 = load %struct.usb_device*, %struct.usb_device** %dev40, align 8
  %dev41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %32, i32 0, i32 11
  %33 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %33, %struct.task_struct** %pfo_ret__.i, align 8
  %34 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %34, %struct.task_struct** %tmp.i, align 8
  %35 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call43 = call i32 @task_pid_nr(%struct.task_struct* %35)
  %36 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %36, %struct.task_struct** %pfo_ret__.i55, align 8
  %37 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i55, align 8
  store %struct.task_struct* %37, %struct.task_struct** %tmp.i56, align 8
  %38 = load %struct.task_struct*, %struct.task_struct** %tmp.i56, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %38, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %39 = load i32, i32* %index.addr, align 4
  %40 = load i32, i32* %index.addr, align 4
  %xor45 = xor i32 %40, 128
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev41, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.37, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.check_ctrlrecip, i32 0, i32 0), i32 %call43, i8* %arraydecay, i32 %39, i32 %xor45)
  br label %if.end46

if.end46:                                         ; preds = %if.then39, %if.then34
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.end29
  %41 = load i32, i32* %ret, align 4
  %cmp48 = icmp sge i32 %41, 0
  br i1 %cmp48, label %if.then50, label %if.end52

if.then50:                                        ; preds = %if.end47
  %42 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %43 = load i32, i32* %ret, align 4
  %call51 = call i32 @checkintf(%struct.usb_dev_state* %42, i32 %43)
  store i32 %call51, i32* %ret, align 4
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %if.end47
  br label %sw.epilog

sw.bb53:                                          ; preds = %LeafBlock
  %44 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %45 = load i32, i32* %index.addr, align 4
  %call54 = call i32 @checkintf(%struct.usb_dev_state* %44, i32 %45)
  store i32 %call54, i32* %ret, align 4
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %sw.bb53, %if.end52
  %46 = load i32, i32* %ret, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then28, %if.then20, %if.then9, %if.then
  %47 = load i32, i32* %retval, align 4
  ret i32 %47
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbfs_increase_memory_usage(i64 %amount) #0 {
entry:
  %i.addr.i = alloca i64, align 8
  %v.addr.i = alloca %struct.atomic64_t*, align 8
  %retval = alloca i32, align 4
  %amount.addr = alloca i64, align 8
  %lim = alloca i64, align 8
  %__var = alloca i32, align 4
  %tmp = alloca i32*, align 8
  store i64 %amount, i64* %amount.addr, align 8
  store i32 0, i32* %__var, align 4
  store i32* @usbfs_memory_mb, i32** %tmp, align 8
  %0 = load i32*, i32** %tmp, align 8
  %1 = load volatile i32, i32* %0, align 4
  %conv = zext i32 %1 to i64
  store i64 %conv, i64* %lim, align 8
  %2 = load i64, i64* %lim, align 8
  %shl = shl i64 %2, 20
  store i64 %shl, i64* %lim, align 8
  %3 = load i64, i64* %amount.addr, align 8
  store i64 %3, i64* %i.addr.i, align 8
  store %struct.atomic64_t* @usbfs_memory_usage, %struct.atomic64_t** %v.addr.i, align 8
  %4 = load %struct.atomic64_t*, %struct.atomic64_t** %v.addr.i, align 8
  %counter.i = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %4, i32 0, i32 0
  %5 = load i64, i64* %i.addr.i, align 8
  %6 = load %struct.atomic64_t*, %struct.atomic64_t** %v.addr.i, align 8
  %counter1.i = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %6, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; addq $1,$0", "=*m,er,*m,~{dirflag},~{fpsr},~{flags}"(i64* %counter.i, i64 %5, i64* %counter1.i) #4, !srcloc !48
  %7 = load i64, i64* %lim, align 8
  %cmp = icmp ugt i64 %7, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call = call i64 @atomic64_read(%struct.atomic64_t* @usbfs_memory_usage)
  %8 = load i64, i64* %lim, align 8
  %cmp2 = icmp ugt i64 %call, %8
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %9 = load i64, i64* %amount.addr, align 8
  call void @atomic64_sub(i64 %9, %struct.atomic64_t* @usbfs_memory_usage)
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

declare i64 @__get_free_pages(i32, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal zeroext i1 @__chk_range_not_ok(i64 %addr, i64 %size, i64 %limit) #0 {
entry:
  %retval = alloca i1, align 1
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %limit.addr = alloca i64, align 8
  store i64 %addr, i64* %addr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i64 %limit, i64* %limit.addr, align 8
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i64, i64* %addr.addr, align 8
  %add = add i64 %1, %0
  store i64 %add, i64* %addr.addr, align 8
  %2 = load i64, i64* %addr.addr, align 8
  %3 = load i64, i64* %size.addr, align 8
  %cmp = icmp ult i64 %2, %3
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i64, i64* %addr.addr, align 8
  %5 = load i64, i64* %limit.addr, align 8
  %cmp2 = icmp ugt i64 %4, %5
  %lnot4 = xor i1 %cmp2, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %tobool9 = icmp ne i64 %conv8, 0
  store i1 %tobool9, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i1, i1* %retval, align 1
  ret i1 %6
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @__create_pipe(%struct.usb_device* %dev, i32 %endpoint) #0 {
entry:
  %dev.addr = alloca %struct.usb_device*, align 8
  %endpoint.addr = alloca i32, align 4
  store %struct.usb_device* %dev, %struct.usb_device** %dev.addr, align 8
  store i32 %endpoint, i32* %endpoint.addr, align 4
  %0 = load %struct.usb_device*, %struct.usb_device** %dev.addr, align 8
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %1 = load i32, i32* %devnum, align 8
  %shl = shl i32 %1, 8
  %2 = load i32, i32* %endpoint.addr, align 4
  %shl1 = shl i32 %2, 15
  %or = or i32 %shl, %shl1
  ret i32 %or
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @snoop_urb(%struct.usb_device* %udev, i8* %userurb, i32 %pipe, i32 %length, i32 %timeout_or_status, i32 %when, i8* %data, i32 %data_len) #0 {
entry:
  %udev.addr = alloca %struct.usb_device*, align 8
  %userurb.addr = alloca i8*, align 8
  %pipe.addr = alloca i32, align 4
  %length.addr = alloca i32, align 4
  %timeout_or_status.addr = alloca i32, align 4
  %when.addr = alloca i32, align 4
  %data.addr = alloca i8*, align 8
  %data_len.addr = alloca i32, align 4
  %ep = alloca i32, align 4
  %t = alloca i8*, align 8
  %d = alloca i8*, align 8
  %__UNIQUE_ID_min1_26 = alloca i32, align 4
  %__UNIQUE_ID_min2_27 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.usb_device* %udev, %struct.usb_device** %udev.addr, align 8
  store i8* %userurb, i8** %userurb.addr, align 8
  store i32 %pipe, i32* %pipe.addr, align 4
  store i32 %length, i32* %length.addr, align 4
  store i32 %timeout_or_status, i32* %timeout_or_status.addr, align 4
  store i32 %when, i32* %when.addr, align 4
  store i8* %data, i8** %data.addr, align 8
  store i32 %data_len, i32* %data_len.addr, align 4
  %0 = load i8, i8* @usbfs_snoop, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end29

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pipe.addr, align 4
  %shr = ashr i32 %1, 15
  %and = and i32 %shr, 15
  store i32 %and, i32* %ep, align 4
  %2 = load i32, i32* %pipe.addr, align 4
  %shr1 = ashr i32 %2, 30
  %and2 = and i32 %shr1, 3
  %idxprom = sext i32 %and2 to i64
  %arrayidx = getelementptr inbounds [4 x i8*], [4 x i8*]* @snoop_urb.types, i64 0, i64 %idxprom
  %3 = load i8*, i8** %arrayidx, align 8
  store i8* %3, i8** %t, align 8
  %4 = load i32, i32* %pipe.addr, align 4
  %and3 = and i32 %4, 128
  %tobool4 = icmp ne i32 %and3, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %idxprom6 = sext i32 %lnot.ext to i64
  %arrayidx7 = getelementptr inbounds [2 x i8*], [2 x i8*]* @snoop_urb.dirs, i64 0, i64 %idxprom6
  %5 = load i8*, i8** %arrayidx7, align 8
  store i8* %5, i8** %d, align 8
  %6 = load i8*, i8** %userurb.addr, align 8
  %tobool8 = icmp ne i8* %6, null
  br i1 %tobool8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.end
  %7 = load i32, i32* %when.addr, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then9
  %8 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  %9 = load i8*, i8** %userurb.addr, align 8
  %10 = load i32, i32* %ep, align 4
  %11 = load i8*, i8** %t, align 8
  %12 = load i8*, i8** %d, align 8
  %13 = load i32, i32* %length.addr, align 4
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.45, i32 0, i32 0), i8* %9, i32 %10, i8* %11, i8* %12, i32 %13)
  br label %if.end12

if.else:                                          ; preds = %if.then9
  %14 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %dev11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %14, i32 0, i32 11
  %15 = load i8*, i8** %userurb.addr, align 8
  %16 = load i32, i32* %ep, align 4
  %17 = load i8*, i8** %t, align 8
  %18 = load i8*, i8** %d, align 8
  %19 = load i32, i32* %length.addr, align 4
  %20 = load i32, i32* %timeout_or_status.addr, align 4
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev11, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.46, i32 0, i32 0), i8* %15, i32 %16, i8* %17, i8* %18, i32 %19, i32 %20)
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then10
  br label %if.end20

if.else13:                                        ; preds = %if.end
  %21 = load i32, i32* %when.addr, align 4
  %cmp14 = icmp eq i32 %21, 0
  br i1 %cmp14, label %if.then15, label %if.else17

if.then15:                                        ; preds = %if.else13
  %22 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %dev16 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %22, i32 0, i32 11
  %23 = load i32, i32* %ep, align 4
  %24 = load i8*, i8** %t, align 8
  %25 = load i8*, i8** %d, align 8
  %26 = load i32, i32* %length.addr, align 4
  %27 = load i32, i32* %timeout_or_status.addr, align 4
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev16, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.47, i32 0, i32 0), i32 %23, i8* %24, i8* %25, i32 %26, i32 %27)
  br label %if.end19

if.else17:                                        ; preds = %if.else13
  %28 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %dev18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %28, i32 0, i32 11
  %29 = load i32, i32* %ep, align 4
  %30 = load i8*, i8** %t, align 8
  %31 = load i8*, i8** %d, align 8
  %32 = load i32, i32* %length.addr, align 4
  %33 = load i32, i32* %timeout_or_status.addr, align 4
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev18, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.48, i32 0, i32 0), i32 %29, i8* %30, i8* %31, i32 %32, i32 %33)
  br label %if.end19

if.end19:                                         ; preds = %if.else17, %if.then15
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.end12
  %34 = load i32, i32* %data_len.addr, align 4
  store i32 %34, i32* %__UNIQUE_ID_min1_26, align 4
  %35 = load i32, i32* @usbfs_snoop_max, align 4
  store i32 %35, i32* %__UNIQUE_ID_min2_27, align 4
  %cmp21 = icmp eq i32* %__UNIQUE_ID_min1_26, %__UNIQUE_ID_min2_27
  %conv = zext i1 %cmp21 to i32
  %36 = load i32, i32* %__UNIQUE_ID_min1_26, align 4
  %37 = load i32, i32* %__UNIQUE_ID_min2_27, align 4
  %cmp22 = icmp ult i32 %36, %37
  br i1 %cmp22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end20
  %38 = load i32, i32* %__UNIQUE_ID_min1_26, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end20
  %39 = load i32, i32* %__UNIQUE_ID_min2_27, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %38, %cond.true ], [ %39, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %40 = load i32, i32* %tmp, align 4
  store i32 %40, i32* %data_len.addr, align 4
  %41 = load i8*, i8** %data.addr, align 8
  %tobool24 = icmp ne i8* %41, null
  br i1 %tobool24, label %land.lhs.true, label %if.end29

land.lhs.true:                                    ; preds = %cond.end
  %42 = load i32, i32* %data_len.addr, align 4
  %cmp25 = icmp ugt i32 %42, 0
  br i1 %cmp25, label %if.then27, label %if.end29

if.then27:                                        ; preds = %land.lhs.true
  %43 = load i8*, i8** %data.addr, align 8
  %44 = load i32, i32* %data_len.addr, align 4
  %conv28 = zext i32 %44 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.49, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %43, i64 %conv28, i1 zeroext true)
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %land.lhs.true, %cond.end, %if.then
  ret void
}

declare i32 @usb_control_msg(%struct.usb_device*, i32, i8 zeroext, i8 zeroext, i16 zeroext, i16 zeroext, i8*, i16 zeroext, i32) #1

declare void @dev_printk(i8*, %struct.device*, i8*, ...) #1

declare void @free_pages(i64, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @kasan_check_write(i8* %p, i32 %size) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %size.addr = alloca i32, align 4
  store i8* %p, i8** %p.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  ret void
}

declare i64 @_copy_from_user(i8*, i8*, i32) #1

declare %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config*, i32, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @findintfep(%struct.usb_device* %dev, i32 %ep) #0 {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.usb_device*, align 8
  %ep.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %e = alloca i32, align 4
  %intf = alloca %struct.usb_interface*, align 8
  %alts = alloca %struct.usb_host_interface*, align 8
  %endpt = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_device* %dev, %struct.usb_device** %dev.addr, align 8
  store i32 %ep, i32* %ep.addr, align 4
  %0 = load i32, i32* %ep.addr, align 4
  %and = and i32 %0, -144
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.usb_device*, %struct.usb_device** %dev.addr, align 8
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %tobool1 = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i32 -3, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc32, %if.end3
  %3 = load i32, i32* %i, align 4
  %4 = load %struct.usb_device*, %struct.usb_device** %dev.addr, align 8
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 15
  %5 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %6 = load i8, i8* %bNumInterfaces, align 4
  %conv = zext i8 %6 to i32
  %cmp = icmp ult i32 %3, %conv
  br i1 %cmp, label %for.body, label %for.end34

for.body:                                         ; preds = %for.cond
  %7 = load %struct.usb_device*, %struct.usb_device** %dev.addr, align 8
  %actconfig6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 15
  %8 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig6, align 8
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %8, i32 0, i32 3
  %9 = load i32, i32* %i, align 4
  %idxprom = zext i32 %9 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %10 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8
  store %struct.usb_interface* %10, %struct.usb_interface** %intf, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc29, %for.body
  %11 = load i32, i32* %j, align 4
  %12 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 2
  %13 = load i32, i32* %num_altsetting, align 8
  %cmp8 = icmp ult i32 %11, %13
  br i1 %cmp8, label %for.body10, label %for.end31

for.body10:                                       ; preds = %for.cond7
  %14 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %14, i32 0, i32 0
  %15 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8
  %16 = load i32, i32* %j, align 4
  %idxprom11 = zext i32 %16 to i64
  %arrayidx12 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %15, i64 %idxprom11
  store %struct.usb_host_interface* %arrayidx12, %struct.usb_host_interface** %alts, align 8
  store i32 0, i32* %e, align 4
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc, %for.body10
  %17 = load i32, i32* %e, align 4
  %18 = load %struct.usb_host_interface*, %struct.usb_host_interface** %alts, align 8
  %desc14 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %18, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc14, i32 0, i32 4
  %19 = load i8, i8* %bNumEndpoints, align 4
  %conv15 = zext i8 %19 to i32
  %cmp16 = icmp ult i32 %17, %conv15
  br i1 %cmp16, label %for.body18, label %for.end

for.body18:                                       ; preds = %for.cond13
  %20 = load %struct.usb_host_interface*, %struct.usb_host_interface** %alts, align 8
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %20, i32 0, i32 3
  %21 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8
  %22 = load i32, i32* %e, align 4
  %idxprom19 = zext i32 %22 to i64
  %arrayidx20 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %21, i64 %idxprom19
  %desc21 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx20, i32 0, i32 0
  store %struct.usb_endpoint_descriptor* %desc21, %struct.usb_endpoint_descriptor** %endpt, align 8
  %23 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %endpt, align 8
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %23, i32 0, i32 2
  %24 = load i8, i8* %bEndpointAddress, align 1
  %conv22 = zext i8 %24 to i32
  %25 = load i32, i32* %ep.addr, align 4
  %cmp23 = icmp eq i32 %conv22, %25
  br i1 %cmp23, label %if.then25, label %if.end28

if.then25:                                        ; preds = %for.body18
  %26 = load %struct.usb_host_interface*, %struct.usb_host_interface** %alts, align 8
  %desc26 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %26, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc26, i32 0, i32 2
  %27 = load i8, i8* %bInterfaceNumber, align 2
  %conv27 = zext i8 %27 to i32
  store i32 %conv27, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %for.body18
  br label %for.inc

for.inc:                                          ; preds = %if.end28
  %28 = load i32, i32* %e, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %e, align 4
  br label %for.cond13

for.end:                                          ; preds = %for.cond13
  br label %for.inc29

for.inc29:                                        ; preds = %for.end
  %29 = load i32, i32* %j, align 4
  %inc30 = add i32 %29, 1
  store i32 %inc30, i32* %j, align 4
  br label %for.cond7

for.end31:                                        ; preds = %for.cond7
  br label %for.inc32

for.inc32:                                        ; preds = %for.end31
  %30 = load i32, i32* %i, align 4
  %inc33 = add i32 %30, 1
  store i32 %inc33, i32* %i, align 4
  br label %for.cond

for.end34:                                        ; preds = %for.cond
  store i32 -2, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end34, %if.then25, %if.then2, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @task_pid_nr(%struct.task_struct* %tsk) #0 {
entry:
  %tsk.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %tsk, %struct.task_struct** %tsk.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %tsk.addr, align 8
  %pid = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 47
  %1 = load i32, i32* %pid, align 8
  ret i32 %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @checkintf(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %pfo_ret__.i21 = alloca %struct.task_struct*, align 8
  %tmp.i22 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %nr.addr.i19 = alloca i64, align 8
  %addr.addr.i20 = alloca i64*, align 8
  %oldbit.i = alloca i8, align 1
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %ifnum.addr = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i32 %ifnum, i32* %ifnum.addr, align 4
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8
  %cmp = icmp ne i32 %2, 7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -113, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %ifnum.addr, align 4
  %conv = zext i32 %3 to i64
  %cmp1 = icmp uge i64 %conv, 64
  br i1 %cmp1, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end4
  %4 = load i32, i32* %ifnum.addr, align 4
  %conv5 = zext i32 %4 to i64
  %5 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %5, i32 0, i32 12
  store i64 %conv5, i64* %nr.addr.i, align 8
  store i64* %ifclaimed, i64** %addr.addr.i, align 8
  %6 = load i64, i64* %nr.addr.i, align 8
  %and.i = and i64 %6, 63
  %shl.i = shl i64 1, %and.i
  %7 = load i64*, i64** %addr.addr.i, align 8
  %8 = load i64, i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %8, 6
  %arrayidx.i = getelementptr inbounds i64, i64* %7, i64 %shr.i
  %9 = load volatile i64, i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %9
  %cmp.i = icmp ne i64 %and1.i, 0
  br i1 %cmp.i, label %if.then11, label %if.end12

cond.false:                                       ; preds = %if.end4
  %10 = load i32, i32* %ifnum.addr, align 4
  %conv7 = zext i32 %10 to i64
  %11 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %ifclaimed8 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %11, i32 0, i32 12
  store i64 %conv7, i64* %nr.addr.i19, align 8
  store i64* %ifclaimed8, i64** %addr.addr.i20, align 8
  %12 = load i64*, i64** %addr.addr.i20, align 8
  %13 = load i64, i64* %nr.addr.i19, align 8
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %12, i64 %13) #4, !srcloc !5
  %14 = load i8, i8* %oldbit.i, align 1
  %tobool.i = trunc i8 %14 to i1
  br i1 %tobool.i, label %if.then11, label %if.end12

if.then11:                                        ; preds = %cond.false, %cond.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %cond.false, %cond.true
  %15 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev13 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %15, i32 0, i32 1
  %16 = load %struct.usb_device*, %struct.usb_device** %dev13, align 8
  %dev14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %16, i32 0, i32 11
  %17 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %17, %struct.task_struct** %pfo_ret__.i, align 8
  %18 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %18, %struct.task_struct** %tmp.i, align 8
  %19 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call16 = call i32 @task_pid_nr(%struct.task_struct* %19)
  %20 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %20, %struct.task_struct** %pfo_ret__.i21, align 8
  %21 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i21, align 8
  store %struct.task_struct* %21, %struct.task_struct** %tmp.i22, align 8
  %22 = load %struct.task_struct*, %struct.task_struct** %tmp.i22, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %22, i32 0, i32 77
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %23 = load i32, i32* %ifnum.addr, align 4
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev14, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.38, i32 0, i32 0), i32 %call16, i8* %arraydecay, i32 %23)
  %24 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %25 = load i32, i32* %ifnum.addr, align 4
  %call18 = call i32 @claimintf(%struct.usb_dev_state* %24, i32 %25)
  store i32 %call18, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then11, %if.then3, %if.then
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @claimintf(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %nr.addr.i46 = alloca i64, align 8
  %addr.addr.i47 = alloca i64*, align 8
  %oldbit.i48 = alloca i8, align 1
  %nr.addr.i38 = alloca i64, align 8
  %addr.addr.i39 = alloca i64*, align 8
  %nr.addr.i36 = alloca i64, align 8
  %addr.addr.i37 = alloca i64*, align 8
  %oldbit.i = alloca i8, align 1
  %nr.addr.i34 = alloca i64, align 8
  %addr.addr.i35 = alloca i64*, align 8
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %ifnum.addr = alloca i32, align 4
  %dev = alloca %struct.usb_device*, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %err = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i32 %ifnum, i32* %ifnum.addr, align 4
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %1, %struct.usb_device** %dev, align 8
  %2 = load i32, i32* %ifnum.addr, align 4
  %conv = zext i32 %2 to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %3 = load i32, i32* %ifnum.addr, align 4
  %conv3 = zext i32 %3 to i64
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %4, i32 0, i32 12
  store i64 %conv3, i64* %nr.addr.i, align 8
  store i64* %ifclaimed, i64** %addr.addr.i, align 8
  %5 = load i64, i64* %nr.addr.i, align 8
  %and.i = and i64 %5, 63
  %shl.i = shl i64 1, %and.i
  %6 = load i64*, i64** %addr.addr.i, align 8
  %7 = load i64, i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %7, 6
  %arrayidx.i = getelementptr inbounds i64, i64* %6, i64 %shr.i
  %8 = load volatile i64, i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %8
  %cmp.i = icmp ne i64 %and1.i, 0
  br i1 %cmp.i, label %if.then9, label %if.end10

cond.false:                                       ; preds = %if.end
  %9 = load i32, i32* %ifnum.addr, align 4
  %conv5 = zext i32 %9 to i64
  %10 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %ifclaimed6 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %10, i32 0, i32 12
  store i64 %conv5, i64* %nr.addr.i36, align 8
  store i64* %ifclaimed6, i64** %addr.addr.i37, align 8
  %11 = load i64*, i64** %addr.addr.i37, align 8
  %12 = load i64, i64* %nr.addr.i36, align 8
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i, i64* %11, i64 %12) #4, !srcloc !5
  %13 = load i8, i8* %oldbit.i, align 1
  %tobool.i = trunc i8 %13 to i1
  br i1 %tobool.i, label %if.then9, label %if.end10

if.then9:                                         ; preds = %cond.false, %cond.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %cond.false, %cond.true
  %14 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %14, i32 0, i32 15
  %15 = load i8, i8* %privileges_dropped, align 8
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %if.end10
  br i1 false, label %cond.true12, label %cond.false16

cond.true12:                                      ; preds = %land.lhs.true
  %16 = load i32, i32* %ifnum.addr, align 4
  %conv13 = zext i32 %16 to i64
  %17 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %interface_allowed_mask = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %17, i32 0, i32 16
  store i64 %conv13, i64* %nr.addr.i38, align 8
  store i64* %interface_allowed_mask, i64** %addr.addr.i39, align 8
  %18 = load i64, i64* %nr.addr.i38, align 8
  %and.i40 = and i64 %18, 63
  %shl.i41 = shl i64 1, %and.i40
  %19 = load i64*, i64** %addr.addr.i39, align 8
  %20 = load i64, i64* %nr.addr.i38, align 8
  %shr.i42 = ashr i64 %20, 6
  %arrayidx.i43 = getelementptr inbounds i64, i64* %19, i64 %shr.i42
  %21 = load volatile i64, i64* %arrayidx.i43, align 8
  %and1.i44 = and i64 %shl.i41, %21
  %cmp.i45 = icmp ne i64 %and1.i44, 0
  br i1 %cmp.i45, label %if.end22, label %if.then21

cond.false16:                                     ; preds = %land.lhs.true
  %22 = load i32, i32* %ifnum.addr, align 4
  %conv17 = zext i32 %22 to i64
  %23 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %interface_allowed_mask18 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %23, i32 0, i32 16
  store i64 %conv17, i64* %nr.addr.i46, align 8
  store i64* %interface_allowed_mask18, i64** %addr.addr.i47, align 8
  %24 = load i64*, i64** %addr.addr.i47, align 8
  %25 = load i64, i64* %nr.addr.i46, align 8
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit.i48, i64* %24, i64 %25) #4, !srcloc !5
  %26 = load i8, i8* %oldbit.i48, align 1
  %tobool.i49 = trunc i8 %26 to i1
  br i1 %tobool.i49, label %if.end22, label %if.then21

if.then21:                                        ; preds = %cond.false16, %cond.true12
  store i32 -13, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %cond.false16, %cond.true12, %if.end10
  %27 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %28 = load i32, i32* %ifnum.addr, align 4
  %call23 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %27, i32 %28)
  store %struct.usb_interface* %call23, %struct.usb_interface** %intf, align 8
  %29 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %tobool24 = icmp ne %struct.usb_interface* %29, null
  br i1 %tobool24, label %if.else, label %if.then25

if.then25:                                        ; preds = %if.end22
  store i32 -2, i32* %err, align 4
  br label %if.end27

if.else:                                          ; preds = %if.end22
  %30 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %31 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %32 = bitcast %struct.usb_dev_state* %31 to i8*
  %call26 = call i32 @usb_driver_claim_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %30, i8* %32)
  store i32 %call26, i32* %err, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.else, %if.then25
  %33 = load i32, i32* %err, align 4
  %cmp28 = icmp eq i32 %33, 0
  br i1 %cmp28, label %if.then30, label %if.end33

if.then30:                                        ; preds = %if.end27
  %34 = load i32, i32* %ifnum.addr, align 4
  %conv31 = zext i32 %34 to i64
  %35 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %ifclaimed32 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %35, i32 0, i32 12
  store i64 %conv31, i64* %nr.addr.i34, align 8
  store i64* %ifclaimed32, i64** %addr.addr.i35, align 8
  %36 = load i64*, i64** %addr.addr.i35, align 8
  %37 = load i64, i64* %nr.addr.i34, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %36, i64 %37, i64* %36) #4, !srcloc !49
  br label %if.end33

if.end33:                                         ; preds = %if.then30, %if.end27
  %38 = load i32, i32* %err, align 4
  store i32 %38, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end33, %if.then21, %if.then9, %if.then
  %39 = load i32, i32* %retval, align 4
  ret i32 %39
}

declare %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device*, i32) #1

declare i32 @usb_driver_claim_interface(%struct.usb_driver*, %struct.usb_interface*, i8*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @atomic64_read(%struct.atomic64_t* %v) #0 {
entry:
  %p.addr.i = alloca i8*, align 8
  %res.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %v.addr = alloca %struct.atomic64_t*, align 8
  %__u = alloca %union.anon.63, align 8
  %tmp = alloca i64, align 8
  store %struct.atomic64_t* %v, %struct.atomic64_t** %v.addr, align 8
  %0 = load %struct.atomic64_t*, %struct.atomic64_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %0, i32 0, i32 0
  %1 = bitcast i64* %counter to i8*
  %__c = bitcast %union.anon.63* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  store i8* %1, i8** %p.addr.i, align 8
  store i8* %arraydecay, i8** %res.addr.i, align 8
  store i32 8, i32* %size.addr.i, align 4
  %2 = load i32, i32* %size.addr.i, align 4
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %2, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %2, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %2, 8
  br i1 %SwitchLeaf6, label %sw.bb3.i, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %2, 4
  br i1 %SwitchLeaf4, label %sw.bb2.i, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %2, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %2, 2
  br i1 %SwitchLeaf2, label %sw.bb1.i, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %2, 1
  br i1 %SwitchLeaf, label %sw.bb.i, label %NewDefault

sw.bb.i:                                          ; preds = %LeafBlock
  %3 = load i8*, i8** %p.addr.i, align 8
  %4 = load volatile i8, i8* %3, align 1
  %5 = load i8*, i8** %res.addr.i, align 8
  store i8 %4, i8* %5, align 1
  br label %__read_once_size.exit

sw.bb1.i:                                         ; preds = %LeafBlock1
  %6 = load i8*, i8** %p.addr.i, align 8
  %7 = bitcast i8* %6 to i16*
  %8 = load volatile i16, i16* %7, align 2
  %9 = load i8*, i8** %res.addr.i, align 8
  %10 = bitcast i8* %9 to i16*
  store i16 %8, i16* %10, align 2
  br label %__read_once_size.exit

sw.bb2.i:                                         ; preds = %LeafBlock3
  %11 = load i8*, i8** %p.addr.i, align 8
  %12 = bitcast i8* %11 to i32*
  %13 = load volatile i32, i32* %12, align 4
  %14 = load i8*, i8** %res.addr.i, align 8
  %15 = bitcast i8* %14 to i32*
  store i32 %13, i32* %15, align 4
  br label %__read_once_size.exit

sw.bb3.i:                                         ; preds = %LeafBlock5
  %16 = load i8*, i8** %p.addr.i, align 8
  %17 = bitcast i8* %16 to i64*
  %18 = load volatile i64, i64* %17, align 8
  %19 = load i8*, i8** %res.addr.i, align 8
  %20 = bitcast i8* %19 to i64*
  store i64 %18, i64* %20, align 8
  br label %__read_once_size.exit

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default.i

sw.default.i:                                     ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !8
  %21 = load i8*, i8** %res.addr.i, align 8
  %22 = load i8*, i8** %p.addr.i, align 8
  %23 = load i32, i32* %size.addr.i, align 4
  %conv.i = sext i32 %23 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 %conv.i, i32 1, i1 false) #4
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !9
  br label %__read_once_size.exit

__read_once_size.exit:                            ; preds = %sw.default.i, %sw.bb3.i, %sw.bb2.i, %sw.bb1.i, %sw.bb.i
  %__val = bitcast %union.anon.63* %__u to i64*
  %24 = load i64, i64* %__val, align 8
  store i64 %24, i64* %tmp, align 8
  %25 = load i64, i64* %tmp, align 8
  ret i64 %25
}

declare void @print_hex_dump(i8*, i8*, i32, i32, i32, i8*, i64, i1 zeroext) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal zeroext i16 @usb_maxpacket(%struct.usb_device* %udev, i32 %pipe, i32 %is_out) #0 {
entry:
  %retval = alloca i16, align 2
  %udev.addr = alloca %struct.usb_device*, align 8
  %pipe.addr = alloca i32, align 4
  %is_out.addr = alloca i32, align 4
  %ep = alloca %struct.usb_host_endpoint*, align 8
  %epnum = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on17 = alloca i32, align 4
  %tmp35 = alloca i64, align 8
  store %struct.usb_device* %udev, %struct.usb_device** %udev.addr, align 8
  store i32 %pipe, i32* %pipe.addr, align 4
  store i32 %is_out, i32* %is_out.addr, align 4
  %0 = load i32, i32* %pipe.addr, align 4
  %shr = ashr i32 %0, 15
  %and = and i32 %shr, 15
  store i32 %and, i32* %epnum, align 4
  %1 = load i32, i32* %is_out.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %pipe.addr, align 4
  %and1 = and i32 %2, 128
  %tobool2 = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %3 = load i32, i32* %__ret_warn_on, align 4
  %tobool4 = icmp ne i32 %3, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %tobool9 = icmp ne i64 %conv, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.50, i32 0, i32 0), i32 1854)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %4 = load i32, i32* %__ret_warn_on, align 4
  %tobool11 = icmp ne i32 %4, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  store i64 %conv16, i64* %tmp, align 8
  %5 = load i64, i64* %tmp, align 8
  %6 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 17
  %7 = load i32, i32* %epnum, align 4
  %idxprom = zext i32 %7 to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom
  %8 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8
  store %struct.usb_host_endpoint* %8, %struct.usb_host_endpoint** %ep, align 8
  br label %if.end44

if.else:                                          ; preds = %entry
  %9 = load i32, i32* %pipe.addr, align 4
  %and18 = and i32 %9, 128
  %tobool19 = icmp ne i32 %and18, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  store i32 %lnot.ext25, i32* %__ret_warn_on17, align 4
  %10 = load i32, i32* %__ret_warn_on17, align 4
  %tobool26 = icmp ne i32 %10, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %tobool32 = icmp ne i64 %conv31, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.else
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.50, i32 0, i32 0), i32 1857)
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.else
  %11 = load i32, i32* %__ret_warn_on17, align 4
  %tobool36 = icmp ne i32 %11, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  store i64 %conv41, i64* %tmp35, align 8
  %12 = load i64, i64* %tmp35, align 8
  %13 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 16
  %14 = load i32, i32* %epnum, align 4
  %idxprom42 = zext i32 %14 to i64
  %arrayidx43 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom42
  %15 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx43, align 8
  store %struct.usb_host_endpoint* %15, %struct.usb_host_endpoint** %ep, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.end34, %if.end
  %16 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %tobool45 = icmp ne %struct.usb_host_endpoint* %16, null
  br i1 %tobool45, label %if.end47, label %if.then46

if.then46:                                        ; preds = %if.end44
  store i16 0, i16* %retval, align 2
  br label %return

if.end47:                                         ; preds = %if.end44
  %17 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %17, i32 0, i32 0
  %call = call i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %desc)
  %conv48 = trunc i32 %call to i16
  store i16 %conv48, i16* %retval, align 2
  br label %return

return:                                           ; preds = %if.end47, %if.then46
  %18 = load i16, i16* %retval, align 2
  ret i16 %18
}

declare i32 @usb_bulk_msg(%struct.usb_device*, i32, i8*, i32, i32*, i32) #1

declare void @warn_slowpath_null(i8*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 4
  %1 = load i16, i16* %wMaxPacketSize, align 1
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 2047
  ret i32 %and
}

declare noalias i8* @__kmalloc(i64, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @check_reset_of_active_ep(%struct.usb_device* %udev, i32 %epnum, i8* %ioctl_name) #0 {
entry:
  %pfo_ret__.i9 = alloca %struct.task_struct*, align 8
  %tmp.i10 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %udev.addr = alloca %struct.usb_device*, align 8
  %epnum.addr = alloca i32, align 4
  %ioctl_name.addr = alloca i8*, align 8
  %eps = alloca %struct.usb_host_endpoint**, align 8
  %ep = alloca %struct.usb_host_endpoint*, align 8
  store %struct.usb_device* %udev, %struct.usb_device** %udev.addr, align 8
  store i32 %epnum, i32* %epnum.addr, align 4
  store i8* %ioctl_name, i8** %ioctl_name.addr, align 8
  %0 = load i32, i32* %epnum.addr, align 4
  %and = and i32 %0, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 16
  %arraydecay = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 17
  %arraydecay1 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i32 0, i32 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.usb_host_endpoint** [ %arraydecay, %cond.true ], [ %arraydecay1, %cond.false ]
  store %struct.usb_host_endpoint** %cond, %struct.usb_host_endpoint*** %eps, align 8
  %3 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8
  %4 = load i32, i32* %epnum.addr, align 4
  %and2 = and i32 %4, 15
  %idxprom = zext i32 %and2 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %3, i64 %idxprom
  %5 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8
  store %struct.usb_host_endpoint* %5, %struct.usb_host_endpoint** %ep, align 8
  %6 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %tobool3 = icmp ne %struct.usb_host_endpoint* %6, null
  br i1 %tobool3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end
  %7 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %urb_list = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %7, i32 0, i32 4
  %call = call i32 @list_empty(%struct.list_head* %urb_list)
  %tobool4 = icmp ne i32 %call, 0
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  %9 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %9, %struct.task_struct** %pfo_ret__.i, align 8
  %10 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %10, %struct.task_struct** %tmp.i, align 8
  %11 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call6 = call i32 @task_pid_nr(%struct.task_struct* %11)
  %12 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %12, %struct.task_struct** %pfo_ret__.i9, align 8
  %13 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i9, align 8
  store %struct.task_struct* %13, %struct.task_struct** %tmp.i10, align 8
  %14 = load %struct.task_struct*, %struct.task_struct** %tmp.i10, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %14, i32 0, i32 77
  %arraydecay8 = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %15 = load i8*, i8** %ioctl_name.addr, align 8
  %16 = load i32, i32* %epnum.addr, align 4
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.52, i32 0, i32 0), i32 %call6, i8* %arraydecay8, i8* %15, i32 %16)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %cond.end
  ret void
}

declare void @usb_reset_endpoint(%struct.usb_device*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_interface_claimed(%struct.usb_interface* %iface) #0 {
entry:
  %iface.addr = alloca %struct.usb_interface*, align 8
  store %struct.usb_interface* %iface, %struct.usb_interface** %iface.addr, align 8
  %0 = load %struct.usb_interface*, %struct.usb_interface** %iface.addr, align 8
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %1 = load %struct.device_driver*, %struct.device_driver** %driver, align 8
  %cmp = icmp ne %struct.device_driver* %1, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i32 @usb_reset_device(%struct.usb_device*) #1

declare i32 @usb_clear_halt(%struct.usb_device*, i32) #1

declare i64 @strlcpy(i8*, i8*, i64) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

declare i32 @usb_set_interface(%struct.usb_device*, i32, i32) #1

declare i32 @usb_reset_configuration(%struct.usb_device*) #1

declare i32 @usb_set_configuration(%struct.usb_device*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_do_submiturb(%struct.usb_dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %iso_frame_desc, i8* %arg) #0 {
entry:
  %lock.addr.i610 = alloca %struct.spinlock*, align 8
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %pfo_ret__.i608 = alloca %struct.task_struct*, align 8
  %tmp.i609 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i606 = alloca %struct.task_struct*, align 8
  %tmp.i607 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i604 = alloca %struct.task_struct*, align 8
  %tmp.i605 = alloca %struct.task_struct*, align 8
  %to.addr.i585 = alloca i8*, align 8
  %from.addr.i586 = alloca i8*, align 8
  %n.addr.i587 = alloca i64, align 8
  %sz.i588 = alloca i32, align 4
  %size.addr.i582 = alloca i64, align 8
  %flags.addr.i583 = alloca i32, align 4
  %to.addr.i563 = alloca i8*, align 8
  %from.addr.i564 = alloca i8*, align 8
  %n.addr.i565 = alloca i64, align 8
  %sz.i566 = alloca i32, align 4
  %size.addr.i560 = alloca i64, align 8
  %flags.addr.i561 = alloca i32, align 4
  %size.addr.i557 = alloca i64, align 8
  %flags.addr.i558 = alloca i32, align 4
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %p.addr.i556 = alloca i16*, align 8
  %p.addr.i555 = alloca i16*, align 8
  %p.addr.i554 = alloca i16*, align 8
  %p.addr.i553 = alloca i16*, align 8
  %p.addr.i552 = alloca i16*, align 8
  %p.addr.i = alloca i16*, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %uurb.addr = alloca %struct.usbdevfs_urb*, align 8
  %iso_frame_desc.addr = alloca %struct.usbdevfs_iso_packet_desc*, align 8
  %arg.addr = alloca i8*, align 8
  %isopkt = alloca %struct.usbdevfs_iso_packet_desc*, align 8
  %ep = alloca %struct.usb_host_endpoint*, align 8
  %as = alloca %struct.async*, align 8
  %dr = alloca %struct.usb_ctrlrequest*, align 8
  %u = alloca i32, align 4
  %totlen = alloca i32, align 4
  %isofrmlen = alloca i32, align 4
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %is_in = alloca i32, align 4
  %num_sgs = alloca i32, align 4
  %ifnum = alloca i32, align 4
  %number_of_packets = alloca i32, align 4
  %stream_id = alloca i32, align 4
  %buf = alloca i8*, align 8
  %tmp = alloca i64, align 8
  %tmp176 = alloca i8, align 1
  %uurb_start = alloca i64, align 8
  %__UNIQUE_ID_min1_40 = alloca i32, align 4
  %__UNIQUE_ID_min2_41 = alloca i32, align 4
  %tmp403 = alloca i32, align 4
  %uurb_start449 = alloca i64, align 8
  %tmp477 = alloca %struct.cred*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_urb** %uurb.addr, align 8
  store %struct.usbdevfs_iso_packet_desc* %iso_frame_desc, %struct.usbdevfs_iso_packet_desc** %iso_frame_desc.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  store %struct.usbdevfs_iso_packet_desc* null, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  store %struct.async* null, %struct.async** %as, align 8
  store %struct.usb_ctrlrequest* null, %struct.usb_ctrlrequest** %dr, align 8
  store i32 0, i32* %num_sgs, align 4
  store i32 -1, i32* %ifnum, align 4
  store i32 0, i32* %number_of_packets, align 4
  store i32 0, i32* %stream_id, align 4
  %0 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 3
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, -232
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 5
  %3 = load i32, i32* %buffer_length, align 8
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %land.lhs.true, label %if.end3

land.lhs.true:                                    ; preds = %if.end
  %4 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %4, i32 0, i32 4
  %5 = load i8*, i8** %buffer, align 8
  %tobool1 = icmp ne i8* %5, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %land.lhs.true
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %land.lhs.true, %if.end
  %6 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %6, i32 0, i32 0
  %7 = load i8, i8* %type, align 8
  %conv = zext i8 %7 to i32
  %cmp4 = icmp eq i32 %conv, 2
  br i1 %cmp4, label %land.lhs.true6, label %if.then11

land.lhs.true6:                                   ; preds = %if.end3
  %8 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %8, i32 0, i32 1
  %9 = load i8, i8* %endpoint, align 1
  %conv7 = zext i8 %9 to i32
  %and8 = and i32 %conv7, -129
  %cmp9 = icmp eq i32 %and8, 0
  br i1 %cmp9, label %if.end22, label %if.then11

if.then11:                                        ; preds = %land.lhs.true6, %if.end3
  %10 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %10, i32 0, i32 1
  %11 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %12 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint12 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %12, i32 0, i32 1
  %13 = load i8, i8* %endpoint12, align 1
  %conv13 = zext i8 %13 to i32
  %call = call i32 @findintfep(%struct.usb_device* %11, i32 %conv13)
  store i32 %call, i32* %ifnum, align 4
  %14 = load i32, i32* %ifnum, align 4
  %cmp14 = icmp slt i32 %14, 0
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then11
  %15 = load i32, i32* %ifnum, align 4
  store i32 %15, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.then11
  %16 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %17 = load i32, i32* %ifnum, align 4
  %call18 = call i32 @checkintf(%struct.usb_dev_state* %16, i32 %17)
  store i32 %call18, i32* %ret, align 4
  %18 = load i32, i32* %ret, align 4
  %tobool19 = icmp ne i32 %18, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  %19 = load i32, i32* %ret, align 4
  store i32 %19, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %land.lhs.true6
  %20 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev23 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %20, i32 0, i32 1
  %21 = load %struct.usb_device*, %struct.usb_device** %dev23, align 8
  %22 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint24 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %22, i32 0, i32 1
  %23 = load i8, i8* %endpoint24, align 1
  %call25 = call %struct.usb_host_endpoint* @ep_to_host_endpoint(%struct.usb_device* %21, i8 zeroext %23)
  store %struct.usb_host_endpoint* %call25, %struct.usb_host_endpoint** %ep, align 8
  %24 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %tobool26 = icmp ne %struct.usb_host_endpoint* %24, null
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end22
  store i32 -2, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end22
  %25 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint29 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %25, i32 0, i32 1
  %26 = load i8, i8* %endpoint29, align 1
  %conv30 = zext i8 %26 to i32
  %and31 = and i32 %conv30, 128
  %cmp32 = icmp ne i32 %and31, 0
  %conv33 = zext i1 %cmp32 to i32
  store i32 %conv33, i32* %is_in, align 4
  store i32 0, i32* %u, align 4
  %27 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type34 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %27, i32 0, i32 0
  %28 = load i8, i8* %type34, align 8
  %conv35 = zext i8 %28 to i32
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end28
  %Pivot6 = icmp slt i32 %conv35, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %conv35, 3
  br i1 %Pivot4, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %conv35, 3
  br i1 %SwitchLeaf2, label %sw.bb107, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv35, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb126

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv35, 0
  br i1 %SwitchLeaf, label %sw.bb132, label %NewDefault

sw.bb:                                            ; preds = %NodeBlock3
  %29 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %29, i32 0, i32 0
  %call36 = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %desc)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.end39, label %if.then38

if.then38:                                        ; preds = %sw.bb
  store i32 -22, i32* %retval, align 4
  br label %return

if.end39:                                         ; preds = %sw.bb
  %30 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length40 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %30, i32 0, i32 5
  %31 = load i32, i32* %buffer_length40, align 8
  %cmp41 = icmp slt i32 %31, 8
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end39
  store i32 -22, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.end39
  store i64 8, i64* %size.addr.i, align 8
  store i32 20971712, i32* %flags.addr.i, align 4
  %32 = load i64, i64* %size.addr.i, align 8
  %33 = load i32, i32* %flags.addr.i, align 4
  %call.i = call noalias i8* @__kmalloc(i64 %32, i32 %33) #4
  %34 = bitcast i8* %call.i to %struct.usb_ctrlrequest*
  store %struct.usb_ctrlrequest* %34, %struct.usb_ctrlrequest** %dr, align 8
  %35 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %tobool46 = icmp ne %struct.usb_ctrlrequest* %35, null
  br i1 %tobool46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %if.end44
  store i32 -12, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end44
  %36 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %37 = bitcast %struct.usb_ctrlrequest* %36 to i8*
  %38 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer49 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %38, i32 0, i32 4
  %39 = load i8*, i8** %buffer49, align 8
  store i8* %37, i8** %to.addr.i, align 8
  store i8* %39, i8** %from.addr.i, align 8
  store i64 8, i64* %n.addr.i, align 8
  %40 = load i8*, i8** %to.addr.i, align 8
  %41 = call i64 @llvm.objectsize.i64.p0i8(i8* %40, i1 false, i1 true) #4
  %conv.i = trunc i64 %41 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %42 = load i8*, i8** %to.addr.i, align 8
  %43 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %43 to i32
  call void @kasan_check_write(i8* %42, i32 %conv1.i) #4
  %44 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %44, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %if.end48
  %45 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %45 to i64
  %46 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %46
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %if.end48
  %47 = phi i1 [ true, %if.end48 ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %47, true
  %lnot.ext.i = zext i1 %47 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %47, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %48 = load i8*, i8** %to.addr.i, align 8
  %49 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %48, i64 %49, i1 zeroext false) #4
  %50 = load i8*, i8** %to.addr.i, align 8
  %51 = load i8*, i8** %from.addr.i, align 8
  %52 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %52 to i32
  %call.i551 = call i64 @_copy_from_user(i8* %50, i8* %51, i32 %conv8.i) #4
  store i64 %call.i551, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %53 = load i32, i32* %sz.i, align 4
  %54 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %53, i64 %54) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %55 = load i64, i64* %n.addr.i, align 8
  %tobool51 = icmp ne i64 %55, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %copy_from_user.exit
  store i32 -14, i32* %ret, align 4
  br label %error

if.end53:                                         ; preds = %copy_from_user.exit
  %56 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length54 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %56, i32 0, i32 5
  %57 = load i32, i32* %buffer_length54, align 8
  %58 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wLength = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %58, i32 0, i32 4
  store i16* %wLength, i16** %p.addr.i, align 8
  %59 = load i16*, i16** %p.addr.i, align 8
  %60 = load i16, i16* %59, align 2
  %conv56 = zext i16 %60 to i32
  %add = add nsw i32 %conv56, 8
  %cmp57 = icmp slt i32 %57, %add
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end53
  store i32 -22, i32* %ret, align 4
  br label %error

if.end60:                                         ; preds = %if.end53
  %61 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %62 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %62, i32 0, i32 0
  %63 = load i8, i8* %bRequestType, align 1
  %conv61 = zext i8 %63 to i32
  %64 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %bRequest = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %64, i32 0, i32 1
  %65 = load i8, i8* %bRequest, align 1
  %conv62 = zext i8 %65 to i32
  %66 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wIndex = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %66, i32 0, i32 3
  store i16* %wIndex, i16** %p.addr.i552, align 8
  %67 = load i16*, i16** %p.addr.i552, align 8
  %68 = load i16, i16* %67, align 2
  %conv64 = zext i16 %68 to i32
  %call65 = call i32 @check_ctrlrecip(%struct.usb_dev_state* %61, i32 %conv61, i32 %conv62, i32 %conv64)
  store i32 %call65, i32* %ret, align 4
  %69 = load i32, i32* %ret, align 4
  %tobool66 = icmp ne i32 %69, 0
  br i1 %tobool66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.end60
  br label %error

if.end68:                                         ; preds = %if.end60
  %70 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wLength69 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %70, i32 0, i32 4
  store i16* %wLength69, i16** %p.addr.i553, align 8
  %71 = load i16*, i16** %p.addr.i553, align 8
  %72 = load i16, i16* %71, align 2
  %conv71 = zext i16 %72 to i32
  %73 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length72 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %73, i32 0, i32 5
  store i32 %conv71, i32* %buffer_length72, align 8
  %74 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer73 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %74, i32 0, i32 4
  %75 = load i8*, i8** %buffer73, align 8
  %add.ptr = getelementptr i8, i8* %75, i64 8
  store i8* %add.ptr, i8** %buffer73, align 8
  %76 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %bRequestType74 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %76, i32 0, i32 0
  %77 = load i8, i8* %bRequestType74, align 1
  %conv75 = zext i8 %77 to i32
  %and76 = and i32 %conv75, 128
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %land.lhs.true78, label %if.else

land.lhs.true78:                                  ; preds = %if.end68
  %78 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length79 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %78, i32 0, i32 5
  %79 = load i32, i32* %buffer_length79, align 8
  %tobool80 = icmp ne i32 %79, 0
  br i1 %tobool80, label %if.then81, label %if.else

if.then81:                                        ; preds = %land.lhs.true78
  store i32 1, i32* %is_in, align 4
  %80 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint82 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %80, i32 0, i32 1
  %81 = load i8, i8* %endpoint82, align 1
  %conv83 = zext i8 %81 to i32
  %or = or i32 %conv83, 128
  %conv84 = trunc i32 %or to i8
  store i8 %conv84, i8* %endpoint82, align 1
  br label %if.end89

if.else:                                          ; preds = %land.lhs.true78, %if.end68
  store i32 0, i32* %is_in, align 4
  %82 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint85 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %82, i32 0, i32 1
  %83 = load i8, i8* %endpoint85, align 1
  %conv86 = zext i8 %83 to i32
  %and87 = and i32 %conv86, -129
  %conv88 = trunc i32 %and87 to i8
  store i8 %conv88, i8* %endpoint85, align 1
  br label %if.end89

if.end89:                                         ; preds = %if.else, %if.then81
  br label %do.body

do.body:                                          ; preds = %if.end89
  %84 = load i8, i8* @usbfs_snoop, align 1
  %tobool90 = trunc i8 %84 to i1
  br i1 %tobool90, label %if.then91, label %if.end106

if.then91:                                        ; preds = %do.body
  %85 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev92 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %85, i32 0, i32 1
  %86 = load %struct.usb_device*, %struct.usb_device** %dev92, align 8
  %dev93 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %86, i32 0, i32 11
  %87 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %bRequestType94 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %87, i32 0, i32 0
  %88 = load i8, i8* %bRequestType94, align 1
  %conv95 = zext i8 %88 to i32
  %89 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %bRequest96 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %89, i32 0, i32 1
  %90 = load i8, i8* %bRequest96, align 1
  %conv97 = zext i8 %90 to i32
  %91 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wValue = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %91, i32 0, i32 2
  store i16* %wValue, i16** %p.addr.i554, align 8
  %92 = load i16*, i16** %p.addr.i554, align 8
  %93 = load i16, i16* %92, align 2
  %conv99 = zext i16 %93 to i32
  %94 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wIndex100 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %94, i32 0, i32 3
  store i16* %wIndex100, i16** %p.addr.i555, align 8
  %95 = load i16*, i16** %p.addr.i555, align 8
  %96 = load i16, i16* %95, align 2
  %conv102 = zext i16 %96 to i32
  %97 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wLength103 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %97, i32 0, i32 4
  store i16* %wLength103, i16** %p.addr.i556, align 8
  %98 = load i16*, i16** %p.addr.i556, align 8
  %99 = load i16, i16* %98, align 2
  %conv105 = zext i16 %99 to i32
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev93, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @.str.34, i32 0, i32 0), i32 %conv95, i32 %conv97, i32 %conv99, i32 %conv102, i32 %conv105)
  br label %if.end106

if.end106:                                        ; preds = %if.then91, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end106
  store i32 8, i32* %u, align 4
  br label %sw.epilog171

sw.bb107:                                         ; preds = %LeafBlock1
  %100 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc108 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %100, i32 0, i32 0
  %call109 = call i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %desc108)
  br label %NodeBlock12

NodeBlock12:                                      ; preds = %sw.bb107
  %Pivot13 = icmp slt i32 %call109, 3
  br i1 %Pivot13, label %LeafBlock8, label %LeafBlock10

LeafBlock10:                                      ; preds = %NodeBlock12
  %SwitchLeaf11 = icmp eq i32 %call109, 3
  br i1 %SwitchLeaf11, label %sw.bb111, label %NewDefault7

LeafBlock8:                                       ; preds = %NodeBlock12
  %SwitchLeaf9 = icmp ule i32 %call109, 1
  br i1 %SwitchLeaf9, label %sw.bb110, label %NewDefault7

sw.bb110:                                         ; preds = %LeafBlock8
  store i32 -22, i32* %retval, align 4
  br label %return

sw.bb111:                                         ; preds = %LeafBlock10
  %101 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type112 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %101, i32 0, i32 0
  store i8 1, i8* %type112, align 8
  br label %interrupt_urb

NewDefault7:                                      ; preds = %LeafBlock10, %LeafBlock8
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault7
  %102 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length113 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %102, i32 0, i32 5
  %103 = load i32, i32* %buffer_length113, align 8
  %add114 = add nsw i32 %103, 16384
  %sub = sub nsw i32 %add114, 1
  %div = sdiv i32 %sub, 16384
  store i32 %div, i32* %num_sgs, align 4
  %104 = load i32, i32* %num_sgs, align 4
  %cmp115 = icmp eq i32 %104, 1
  br i1 %cmp115, label %if.then120, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %105 = load i32, i32* %num_sgs, align 4
  %106 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev117 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %106, i32 0, i32 1
  %107 = load %struct.usb_device*, %struct.usb_device** %dev117, align 8
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %107, i32 0, i32 9
  %108 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %108, i32 0, i32 7
  %109 = load i32, i32* %sg_tablesize, align 4
  %cmp118 = icmp ugt i32 %105, %109
  br i1 %cmp118, label %if.then120, label %if.end121

if.then120:                                       ; preds = %lor.lhs.false, %sw.epilog
  store i32 0, i32* %num_sgs, align 4
  br label %if.end121

if.end121:                                        ; preds = %if.then120, %lor.lhs.false
  %110 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %streams = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %110, i32 0, i32 10
  %111 = load i32, i32* %streams, align 8
  %tobool122 = icmp ne i32 %111, 0
  br i1 %tobool122, label %if.then123, label %if.end125

if.then123:                                       ; preds = %if.end121
  %112 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %113 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %112, i32 0, i32 8
  %stream_id124 = bitcast %union.anon.62* %113 to i32*
  %114 = load i32, i32* %stream_id124, align 4
  store i32 %114, i32* %stream_id, align 4
  br label %if.end125

if.end125:                                        ; preds = %if.then123, %if.end121
  br label %sw.epilog171

sw.bb126:                                         ; preds = %NodeBlock
  %115 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc127 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %115, i32 0, i32 0
  %call128 = call i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %desc127)
  %tobool129 = icmp ne i32 %call128, 0
  br i1 %tobool129, label %if.end131, label %if.then130

if.then130:                                       ; preds = %sw.bb126
  store i32 -22, i32* %retval, align 4
  br label %return

if.end131:                                        ; preds = %sw.bb126
  br label %interrupt_urb

interrupt_urb:                                    ; preds = %if.end131, %sw.bb111
  br label %sw.epilog171

sw.bb132:                                         ; preds = %LeafBlock
  %116 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %117 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %116, i32 0, i32 8
  %number_of_packets133 = bitcast %union.anon.62* %117 to i32*
  %118 = load i32, i32* %number_of_packets133, align 4
  %cmp134 = icmp slt i32 %118, 1
  br i1 %cmp134, label %if.then140, label %lor.lhs.false136

lor.lhs.false136:                                 ; preds = %sw.bb132
  %119 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %120 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %119, i32 0, i32 8
  %number_of_packets137 = bitcast %union.anon.62* %120 to i32*
  %121 = load i32, i32* %number_of_packets137, align 4
  %cmp138 = icmp sgt i32 %121, 128
  br i1 %cmp138, label %if.then140, label %if.end141

if.then140:                                       ; preds = %lor.lhs.false136, %sw.bb132
  store i32 -22, i32* %retval, align 4
  br label %return

if.end141:                                        ; preds = %lor.lhs.false136
  %122 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc142 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %122, i32 0, i32 0
  %call143 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc142)
  %tobool144 = icmp ne i32 %call143, 0
  br i1 %tobool144, label %if.end146, label %if.then145

if.then145:                                       ; preds = %if.end141
  store i32 -22, i32* %retval, align 4
  br label %return

if.end146:                                        ; preds = %if.end141
  %123 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %124 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %123, i32 0, i32 8
  %number_of_packets147 = bitcast %union.anon.62* %124 to i32*
  %125 = load i32, i32* %number_of_packets147, align 4
  store i32 %125, i32* %number_of_packets, align 4
  %126 = load i32, i32* %number_of_packets, align 4
  %conv148 = sext i32 %126 to i64
  %mul = mul i64 12, %conv148
  %conv149 = trunc i64 %mul to i32
  store i32 %conv149, i32* %isofrmlen, align 4
  %127 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %iso_frame_desc.addr, align 8
  %128 = bitcast %struct.usbdevfs_iso_packet_desc* %127 to i8*
  %129 = load i32, i32* %isofrmlen, align 4
  %conv150 = zext i32 %129 to i64
  %call151 = call i8* @memdup_user(i8* %128, i64 %conv150)
  %130 = bitcast i8* %call151 to %struct.usbdevfs_iso_packet_desc*
  store %struct.usbdevfs_iso_packet_desc* %130, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %131 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %132 = bitcast %struct.usbdevfs_iso_packet_desc* %131 to i8*
  %call152 = call zeroext i1 @IS_ERR(i8* %132)
  br i1 %call152, label %if.then153, label %if.end156

if.then153:                                       ; preds = %if.end146
  %133 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %134 = bitcast %struct.usbdevfs_iso_packet_desc* %133 to i8*
  %call154 = call i64 @PTR_ERR(i8* %134)
  %conv155 = trunc i64 %call154 to i32
  store i32 %conv155, i32* %ret, align 4
  store %struct.usbdevfs_iso_packet_desc* null, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  br label %error

if.end156:                                        ; preds = %if.end146
  store i32 0, i32* %u, align 4
  store i32 0, i32* %totlen, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end156
  %135 = load i32, i32* %u, align 4
  %136 = load i32, i32* %number_of_packets, align 4
  %cmp157 = icmp ult i32 %135, %136
  br i1 %cmp157, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %137 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %138 = load i32, i32* %u, align 4
  %idxprom = zext i32 %138 to i64
  %arrayidx = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %137, i64 %idxprom
  %length = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx, i32 0, i32 0
  %139 = load i32, i32* %length, align 4
  %cmp159 = icmp ugt i32 %139, 49152
  br i1 %cmp159, label %if.then161, label %if.end162

if.then161:                                       ; preds = %for.body
  store i32 -22, i32* %ret, align 4
  br label %error

if.end162:                                        ; preds = %for.body
  %140 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %141 = load i32, i32* %u, align 4
  %idxprom163 = zext i32 %141 to i64
  %arrayidx164 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %140, i64 %idxprom163
  %length165 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx164, i32 0, i32 0
  %142 = load i32, i32* %length165, align 4
  %143 = load i32, i32* %totlen, align 4
  %add166 = add i32 %143, %142
  store i32 %add166, i32* %totlen, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end162
  %144 = load i32, i32* %u, align 4
  %inc = add i32 %144, 1
  store i32 %inc, i32* %u, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %145 = load i32, i32* %u, align 4
  %conv167 = zext i32 %145 to i64
  %mul168 = mul i64 %conv167, 16
  %conv169 = trunc i64 %mul168 to i32
  store i32 %conv169, i32* %u, align 4
  %146 = load i32, i32* %totlen, align 4
  %147 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length170 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %147, i32 0, i32 5
  store i32 %146, i32* %buffer_length170, align 8
  br label %sw.epilog171

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog171:                                     ; preds = %for.end, %interrupt_urb, %if.end125, %do.end
  %148 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length172 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %148, i32 0, i32 5
  %149 = load i32, i32* %buffer_length172, align 8
  %cmp173 = icmp sgt i32 %149, 0
  br i1 %cmp173, label %land.lhs.true175, label %if.end188

land.lhs.true175:                                 ; preds = %sw.epilog171
  %150 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer177 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %150, i32 0, i32 4
  %151 = load i8*, i8** %buffer177, align 8
  %152 = ptrtoint i8* %151 to i64
  %153 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length178 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %153, i32 0, i32 5
  %154 = load i32, i32* %buffer_length178, align 8
  %conv179 = sext i32 %154 to i64
  %155 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %155, %struct.task_struct** %pfo_ret__.i, align 8
  %156 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %156, %struct.task_struct** %tmp.i, align 8
  %157 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %157, i32 0, i32 151
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %158 = load i64, i64* %seg, align 8
  %call181 = call zeroext i1 @__chk_range_not_ok(i64 %152, i64 %conv179, i64 %158)
  %frombool = zext i1 %call181 to i8
  store i8 %frombool, i8* %tmp176, align 1
  %159 = load i8, i8* %tmp176, align 1
  %tobool182 = trunc i8 %159 to i1
  %lnot = xor i1 %tobool182, true
  %lnot183 = xor i1 %lnot, true
  %lnot184 = xor i1 %lnot183, true
  %lnot.ext = zext i1 %lnot184 to i32
  %conv185 = sext i32 %lnot.ext to i64
  store i64 %conv185, i64* %tmp, align 8
  %160 = load i64, i64* %tmp, align 8
  %tobool186 = icmp ne i64 %160, 0
  br i1 %tobool186, label %if.end188, label %if.then187

if.then187:                                       ; preds = %land.lhs.true175
  store i32 -14, i32* %ret, align 4
  br label %error

if.end188:                                        ; preds = %land.lhs.true175, %sw.epilog171
  %161 = load i32, i32* %number_of_packets, align 4
  %call189 = call %struct.async* @alloc_async(i32 %161)
  store %struct.async* %call189, %struct.async** %as, align 8
  %162 = load %struct.async*, %struct.async** %as, align 8
  %tobool190 = icmp ne %struct.async* %162, null
  br i1 %tobool190, label %if.end192, label %if.then191

if.then191:                                       ; preds = %if.end188
  store i32 -12, i32* %ret, align 4
  br label %error

if.end192:                                        ; preds = %if.end188
  %163 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %164 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %call193 = call %struct.usb_memory* @find_memory_area(%struct.usb_dev_state* %163, %struct.usbdevfs_urb* %164)
  %165 = load %struct.async*, %struct.async** %as, align 8
  %usbm = getelementptr inbounds %struct.async, %struct.async* %165, i32 0, i32 9
  store %struct.usb_memory* %call193, %struct.usb_memory** %usbm, align 8
  %166 = load %struct.async*, %struct.async** %as, align 8
  %usbm194 = getelementptr inbounds %struct.async, %struct.async* %166, i32 0, i32 9
  %167 = load %struct.usb_memory*, %struct.usb_memory** %usbm194, align 8
  %168 = bitcast %struct.usb_memory* %167 to i8*
  %call195 = call zeroext i1 @IS_ERR(i8* %168)
  br i1 %call195, label %if.then196, label %if.end201

if.then196:                                       ; preds = %if.end192
  %169 = load %struct.async*, %struct.async** %as, align 8
  %usbm197 = getelementptr inbounds %struct.async, %struct.async* %169, i32 0, i32 9
  %170 = load %struct.usb_memory*, %struct.usb_memory** %usbm197, align 8
  %171 = bitcast %struct.usb_memory* %170 to i8*
  %call198 = call i64 @PTR_ERR(i8* %171)
  %conv199 = trunc i64 %call198 to i32
  store i32 %conv199, i32* %ret, align 4
  %172 = load %struct.async*, %struct.async** %as, align 8
  %usbm200 = getelementptr inbounds %struct.async, %struct.async* %172, i32 0, i32 9
  store %struct.usb_memory* null, %struct.usb_memory** %usbm200, align 8
  br label %error

if.end201:                                        ; preds = %if.end192
  %173 = load %struct.async*, %struct.async** %as, align 8
  %usbm202 = getelementptr inbounds %struct.async, %struct.async* %173, i32 0, i32 9
  %174 = load %struct.usb_memory*, %struct.usb_memory** %usbm202, align 8
  %tobool203 = icmp ne %struct.usb_memory* %174, null
  br i1 %tobool203, label %if.then204, label %if.end205

if.then204:                                       ; preds = %if.end201
  store i32 0, i32* %num_sgs, align 4
  br label %if.end205

if.end205:                                        ; preds = %if.then204, %if.end201
  %175 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length206 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %175, i32 0, i32 5
  %176 = load i32, i32* %buffer_length206, align 8
  %conv207 = sext i32 %176 to i64
  %add208 = add i64 288, %conv207
  %177 = load i32, i32* %num_sgs, align 4
  %conv209 = sext i32 %177 to i64
  %mul210 = mul i64 %conv209, 32
  %add211 = add i64 %add208, %mul210
  %178 = load i32, i32* %u, align 4
  %conv212 = zext i32 %178 to i64
  %add213 = add i64 %conv212, %add211
  %conv214 = trunc i64 %add213 to i32
  store i32 %conv214, i32* %u, align 4
  %179 = load i32, i32* %u, align 4
  %conv215 = zext i32 %179 to i64
  %call216 = call i32 @usbfs_increase_memory_usage(i64 %conv215)
  store i32 %call216, i32* %ret, align 4
  %180 = load i32, i32* %ret, align 4
  %tobool217 = icmp ne i32 %180, 0
  br i1 %tobool217, label %if.then218, label %if.end219

if.then218:                                       ; preds = %if.end205
  br label %error

if.end219:                                        ; preds = %if.end205
  %181 = load i32, i32* %u, align 4
  %182 = load %struct.async*, %struct.async** %as, align 8
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %182, i32 0, i32 10
  store i32 %181, i32* %mem_usage, align 8
  %183 = load i32, i32* %num_sgs, align 4
  %tobool220 = icmp ne i32 %183, 0
  br i1 %tobool220, label %if.then221, label %if.else269

if.then221:                                       ; preds = %if.end219
  %184 = load i32, i32* %num_sgs, align 4
  %conv222 = sext i32 %184 to i64
  %mul223 = mul i64 %conv222, 32
  store i64 %mul223, i64* %size.addr.i557, align 8
  store i32 20971712, i32* %flags.addr.i558, align 4
  %185 = load i64, i64* %size.addr.i557, align 8
  %186 = load i32, i32* %flags.addr.i558, align 4
  %call.i559 = call noalias i8* @__kmalloc(i64 %185, i32 %186) #4
  %187 = bitcast i8* %call.i559 to %struct.scatterlist*
  %188 = load %struct.async*, %struct.async** %as, align 8
  %urb = getelementptr inbounds %struct.async, %struct.async* %188, i32 0, i32 8
  %189 = load %struct.urb*, %struct.urb** %urb, align 8
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %189, i32 0, i32 16
  store %struct.scatterlist* %187, %struct.scatterlist** %sg, align 8
  %190 = load %struct.async*, %struct.async** %as, align 8
  %urb225 = getelementptr inbounds %struct.async, %struct.async* %190, i32 0, i32 8
  %191 = load %struct.urb*, %struct.urb** %urb225, align 8
  %sg226 = getelementptr inbounds %struct.urb, %struct.urb* %191, i32 0, i32 16
  %192 = load %struct.scatterlist*, %struct.scatterlist** %sg226, align 8
  %tobool227 = icmp ne %struct.scatterlist* %192, null
  br i1 %tobool227, label %if.end229, label %if.then228

if.then228:                                       ; preds = %if.then221
  store i32 -12, i32* %ret, align 4
  br label %error

if.end229:                                        ; preds = %if.then221
  %193 = load i32, i32* %num_sgs, align 4
  %194 = load %struct.async*, %struct.async** %as, align 8
  %urb230 = getelementptr inbounds %struct.async, %struct.async* %194, i32 0, i32 8
  %195 = load %struct.urb*, %struct.urb** %urb230, align 8
  %num_sgs231 = getelementptr inbounds %struct.urb, %struct.urb* %195, i32 0, i32 18
  store i32 %193, i32* %num_sgs231, align 4
  %196 = load %struct.async*, %struct.async** %as, align 8
  %urb232 = getelementptr inbounds %struct.async, %struct.async* %196, i32 0, i32 8
  %197 = load %struct.urb*, %struct.urb** %urb232, align 8
  %sg233 = getelementptr inbounds %struct.urb, %struct.urb* %197, i32 0, i32 16
  %198 = load %struct.scatterlist*, %struct.scatterlist** %sg233, align 8
  %199 = load %struct.async*, %struct.async** %as, align 8
  %urb234 = getelementptr inbounds %struct.async, %struct.async* %199, i32 0, i32 8
  %200 = load %struct.urb*, %struct.urb** %urb234, align 8
  %num_sgs235 = getelementptr inbounds %struct.urb, %struct.urb* %200, i32 0, i32 18
  %201 = load i32, i32* %num_sgs235, align 4
  call void @sg_init_table(%struct.scatterlist* %198, i32 %201)
  %202 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length236 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %202, i32 0, i32 5
  %203 = load i32, i32* %buffer_length236, align 8
  store i32 %203, i32* %totlen, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond237

for.cond237:                                      ; preds = %for.inc266, %if.end229
  %204 = load i32, i32* %i, align 4
  %205 = load %struct.async*, %struct.async** %as, align 8
  %urb238 = getelementptr inbounds %struct.async, %struct.async* %205, i32 0, i32 8
  %206 = load %struct.urb*, %struct.urb** %urb238, align 8
  %num_sgs239 = getelementptr inbounds %struct.urb, %struct.urb* %206, i32 0, i32 18
  %207 = load i32, i32* %num_sgs239, align 4
  %cmp240 = icmp slt i32 %204, %207
  br i1 %cmp240, label %for.body242, label %for.end268

for.body242:                                      ; preds = %for.cond237
  %208 = load i32, i32* %totlen, align 4
  %cmp243 = icmp ugt i32 %208, 16384
  br i1 %cmp243, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body242
  br label %cond.end

cond.false:                                       ; preds = %for.body242
  %209 = load i32, i32* %totlen, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 16384, %cond.true ], [ %209, %cond.false ]
  store i32 %cond, i32* %u, align 4
  %210 = load i32, i32* %u, align 4
  %conv245 = zext i32 %210 to i64
  store i64 %conv245, i64* %size.addr.i560, align 8
  store i32 20971712, i32* %flags.addr.i561, align 4
  %211 = load i64, i64* %size.addr.i560, align 8
  %212 = load i32, i32* %flags.addr.i561, align 4
  %call.i562 = call noalias i8* @__kmalloc(i64 %211, i32 %212) #4
  store i8* %call.i562, i8** %buf, align 8
  %213 = load i8*, i8** %buf, align 8
  %tobool247 = icmp ne i8* %213, null
  br i1 %tobool247, label %if.end249, label %if.then248

if.then248:                                       ; preds = %cond.end
  store i32 -12, i32* %ret, align 4
  br label %error

if.end249:                                        ; preds = %cond.end
  %214 = load %struct.async*, %struct.async** %as, align 8
  %urb250 = getelementptr inbounds %struct.async, %struct.async* %214, i32 0, i32 8
  %215 = load %struct.urb*, %struct.urb** %urb250, align 8
  %sg251 = getelementptr inbounds %struct.urb, %struct.urb* %215, i32 0, i32 16
  %216 = load %struct.scatterlist*, %struct.scatterlist** %sg251, align 8
  %217 = load i32, i32* %i, align 4
  %idxprom252 = sext i32 %217 to i64
  %arrayidx253 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %216, i64 %idxprom252
  %218 = load i8*, i8** %buf, align 8
  %219 = load i32, i32* %u, align 4
  call void @sg_set_buf(%struct.scatterlist* %arrayidx253, i8* %218, i32 %219)
  %220 = load i32, i32* %is_in, align 4
  %tobool254 = icmp ne i32 %220, 0
  br i1 %tobool254, label %if.end264, label %if.then255

if.then255:                                       ; preds = %if.end249
  %221 = load i8*, i8** %buf, align 8
  %222 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer256 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %222, i32 0, i32 4
  %223 = load i8*, i8** %buffer256, align 8
  %224 = load i32, i32* %u, align 4
  %conv257 = zext i32 %224 to i64
  store i8* %221, i8** %to.addr.i563, align 8
  store i8* %223, i8** %from.addr.i564, align 8
  store i64 %conv257, i64* %n.addr.i565, align 8
  %225 = load i8*, i8** %to.addr.i563, align 8
  %226 = call i64 @llvm.objectsize.i64.p0i8(i8* %225, i1 false, i1 true) #4
  %conv.i567 = trunc i64 %226 to i32
  store i32 %conv.i567, i32* %sz.i566, align 4
  call void @might_fault() #4
  %227 = load i8*, i8** %to.addr.i563, align 8
  %228 = load i64, i64* %n.addr.i565, align 8
  %conv1.i568 = trunc i64 %228 to i32
  call void @kasan_check_write(i8* %227, i32 %conv1.i568) #4
  %229 = load i32, i32* %sz.i566, align 4
  %cmp.i569 = icmp slt i32 %229, 0
  br i1 %cmp.i569, label %lor.end.i576, label %lor.rhs.i572

lor.rhs.i572:                                     ; preds = %if.then255
  %230 = load i32, i32* %sz.i566, align 4
  %conv3.i570 = sext i32 %230 to i64
  %231 = load i64, i64* %n.addr.i565, align 8
  %cmp4.i571 = icmp uge i64 %conv3.i570, %231
  br label %lor.end.i576

lor.end.i576:                                     ; preds = %lor.rhs.i572, %if.then255
  %232 = phi i1 [ true, %if.then255 ], [ %cmp4.i571, %lor.rhs.i572 ]
  %lnot.i573 = xor i1 %232, true
  %lnot.ext.i574 = zext i1 %232 to i32
  %conv7.i575 = sext i32 %lnot.ext.i574 to i64
  br i1 %232, label %if.then.i579, label %if.else.i580

if.then.i579:                                     ; preds = %lor.end.i576
  %233 = load i8*, i8** %to.addr.i563, align 8
  %234 = load i64, i64* %n.addr.i565, align 8
  call void @check_object_size(i8* %233, i64 %234, i1 zeroext false) #4
  %235 = load i8*, i8** %to.addr.i563, align 8
  %236 = load i8*, i8** %from.addr.i564, align 8
  %237 = load i64, i64* %n.addr.i565, align 8
  %conv8.i577 = trunc i64 %237 to i32
  %call.i578 = call i64 @_copy_from_user(i8* %235, i8* %236, i32 %conv8.i577) #4
  store i64 %call.i578, i64* %n.addr.i565, align 8
  br label %copy_from_user.exit581

if.else.i580:                                     ; preds = %lor.end.i576
  %238 = load i32, i32* %sz.i566, align 4
  %239 = load i64, i64* %n.addr.i565, align 8
  call void @copy_user_overflow(i32 %238, i64 %239) #4
  br label %copy_from_user.exit581

copy_from_user.exit581:                           ; preds = %if.else.i580, %if.then.i579
  %240 = load i64, i64* %n.addr.i565, align 8
  %tobool259 = icmp ne i64 %240, 0
  br i1 %tobool259, label %if.then260, label %if.end261

if.then260:                                       ; preds = %copy_from_user.exit581
  store i32 -14, i32* %ret, align 4
  br label %error

if.end261:                                        ; preds = %copy_from_user.exit581
  %241 = load i32, i32* %u, align 4
  %242 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer262 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %242, i32 0, i32 4
  %243 = load i8*, i8** %buffer262, align 8
  %idx.ext = zext i32 %241 to i64
  %add.ptr263 = getelementptr i8, i8* %243, i64 %idx.ext
  store i8* %add.ptr263, i8** %buffer262, align 8
  br label %if.end264

if.end264:                                        ; preds = %if.end261, %if.end249
  %244 = load i32, i32* %u, align 4
  %245 = load i32, i32* %totlen, align 4
  %sub265 = sub i32 %245, %244
  store i32 %sub265, i32* %totlen, align 4
  br label %for.inc266

for.inc266:                                       ; preds = %if.end264
  %246 = load i32, i32* %i, align 4
  %inc267 = add nsw i32 %246, 1
  store i32 %inc267, i32* %i, align 4
  br label %for.cond237

for.end268:                                       ; preds = %for.cond237
  br label %if.end319

if.else269:                                       ; preds = %if.end219
  %247 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length270 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %247, i32 0, i32 5
  %248 = load i32, i32* %buffer_length270, align 8
  %cmp271 = icmp sgt i32 %248, 0
  br i1 %cmp271, label %if.then273, label %if.end318

if.then273:                                       ; preds = %if.else269
  %249 = load %struct.async*, %struct.async** %as, align 8
  %usbm274 = getelementptr inbounds %struct.async, %struct.async* %249, i32 0, i32 9
  %250 = load %struct.usb_memory*, %struct.usb_memory** %usbm274, align 8
  %tobool275 = icmp ne %struct.usb_memory* %250, null
  br i1 %tobool275, label %if.then276, label %if.else283

if.then276:                                       ; preds = %if.then273
  %251 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer277 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %251, i32 0, i32 4
  %252 = load i8*, i8** %buffer277, align 8
  %253 = ptrtoint i8* %252 to i64
  store i64 %253, i64* %uurb_start, align 8
  %254 = load %struct.async*, %struct.async** %as, align 8
  %usbm278 = getelementptr inbounds %struct.async, %struct.async* %254, i32 0, i32 9
  %255 = load %struct.usb_memory*, %struct.usb_memory** %usbm278, align 8
  %mem = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %255, i32 0, i32 4
  %256 = load i8*, i8** %mem, align 8
  %257 = load i64, i64* %uurb_start, align 8
  %258 = load %struct.async*, %struct.async** %as, align 8
  %usbm279 = getelementptr inbounds %struct.async, %struct.async* %258, i32 0, i32 9
  %259 = load %struct.usb_memory*, %struct.usb_memory** %usbm279, align 8
  %vm_start = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %259, i32 0, i32 6
  %260 = load i64, i64* %vm_start, align 8
  %sub280 = sub i64 %257, %260
  %add.ptr281 = getelementptr i8, i8* %256, i64 %sub280
  %261 = load %struct.async*, %struct.async** %as, align 8
  %urb282 = getelementptr inbounds %struct.async, %struct.async* %261, i32 0, i32 8
  %262 = load %struct.urb*, %struct.urb** %urb282, align 8
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %262, i32 0, i32 14
  store i8* %add.ptr281, i8** %transfer_buffer, align 8
  br label %if.end317

if.else283:                                       ; preds = %if.then273
  %263 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length284 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %263, i32 0, i32 5
  %264 = load i32, i32* %buffer_length284, align 8
  %conv285 = sext i32 %264 to i64
  store i64 %conv285, i64* %size.addr.i582, align 8
  store i32 20971712, i32* %flags.addr.i583, align 4
  %265 = load i64, i64* %size.addr.i582, align 8
  %266 = load i32, i32* %flags.addr.i583, align 4
  %call.i584 = call noalias i8* @__kmalloc(i64 %265, i32 %266) #4
  %267 = load %struct.async*, %struct.async** %as, align 8
  %urb287 = getelementptr inbounds %struct.async, %struct.async* %267, i32 0, i32 8
  %268 = load %struct.urb*, %struct.urb** %urb287, align 8
  %transfer_buffer288 = getelementptr inbounds %struct.urb, %struct.urb* %268, i32 0, i32 14
  store i8* %call.i584, i8** %transfer_buffer288, align 8
  %269 = load %struct.async*, %struct.async** %as, align 8
  %urb289 = getelementptr inbounds %struct.async, %struct.async* %269, i32 0, i32 8
  %270 = load %struct.urb*, %struct.urb** %urb289, align 8
  %transfer_buffer290 = getelementptr inbounds %struct.urb, %struct.urb* %270, i32 0, i32 14
  %271 = load i8*, i8** %transfer_buffer290, align 8
  %tobool291 = icmp ne i8* %271, null
  br i1 %tobool291, label %if.end293, label %if.then292

if.then292:                                       ; preds = %if.else283
  store i32 -12, i32* %ret, align 4
  br label %error

if.end293:                                        ; preds = %if.else283
  %272 = load i32, i32* %is_in, align 4
  %tobool294 = icmp ne i32 %272, 0
  br i1 %tobool294, label %if.else305, label %if.then295

if.then295:                                       ; preds = %if.end293
  %273 = load %struct.async*, %struct.async** %as, align 8
  %urb296 = getelementptr inbounds %struct.async, %struct.async* %273, i32 0, i32 8
  %274 = load %struct.urb*, %struct.urb** %urb296, align 8
  %transfer_buffer297 = getelementptr inbounds %struct.urb, %struct.urb* %274, i32 0, i32 14
  %275 = load i8*, i8** %transfer_buffer297, align 8
  %276 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer298 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %276, i32 0, i32 4
  %277 = load i8*, i8** %buffer298, align 8
  %278 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length299 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %278, i32 0, i32 5
  %279 = load i32, i32* %buffer_length299, align 8
  %conv300 = sext i32 %279 to i64
  store i8* %275, i8** %to.addr.i585, align 8
  store i8* %277, i8** %from.addr.i586, align 8
  store i64 %conv300, i64* %n.addr.i587, align 8
  %280 = load i8*, i8** %to.addr.i585, align 8
  %281 = call i64 @llvm.objectsize.i64.p0i8(i8* %280, i1 false, i1 true) #4
  %conv.i589 = trunc i64 %281 to i32
  store i32 %conv.i589, i32* %sz.i588, align 4
  call void @might_fault() #4
  %282 = load i8*, i8** %to.addr.i585, align 8
  %283 = load i64, i64* %n.addr.i587, align 8
  %conv1.i590 = trunc i64 %283 to i32
  call void @kasan_check_write(i8* %282, i32 %conv1.i590) #4
  %284 = load i32, i32* %sz.i588, align 4
  %cmp.i591 = icmp slt i32 %284, 0
  br i1 %cmp.i591, label %lor.end.i598, label %lor.rhs.i594

lor.rhs.i594:                                     ; preds = %if.then295
  %285 = load i32, i32* %sz.i588, align 4
  %conv3.i592 = sext i32 %285 to i64
  %286 = load i64, i64* %n.addr.i587, align 8
  %cmp4.i593 = icmp uge i64 %conv3.i592, %286
  br label %lor.end.i598

lor.end.i598:                                     ; preds = %lor.rhs.i594, %if.then295
  %287 = phi i1 [ true, %if.then295 ], [ %cmp4.i593, %lor.rhs.i594 ]
  %lnot.i595 = xor i1 %287, true
  %lnot.ext.i596 = zext i1 %287 to i32
  %conv7.i597 = sext i32 %lnot.ext.i596 to i64
  br i1 %287, label %if.then.i601, label %if.else.i602

if.then.i601:                                     ; preds = %lor.end.i598
  %288 = load i8*, i8** %to.addr.i585, align 8
  %289 = load i64, i64* %n.addr.i587, align 8
  call void @check_object_size(i8* %288, i64 %289, i1 zeroext false) #4
  %290 = load i8*, i8** %to.addr.i585, align 8
  %291 = load i8*, i8** %from.addr.i586, align 8
  %292 = load i64, i64* %n.addr.i587, align 8
  %conv8.i599 = trunc i64 %292 to i32
  %call.i600 = call i64 @_copy_from_user(i8* %290, i8* %291, i32 %conv8.i599) #4
  store i64 %call.i600, i64* %n.addr.i587, align 8
  br label %copy_from_user.exit603

if.else.i602:                                     ; preds = %lor.end.i598
  %293 = load i32, i32* %sz.i588, align 4
  %294 = load i64, i64* %n.addr.i587, align 8
  call void @copy_user_overflow(i32 %293, i64 %294) #4
  br label %copy_from_user.exit603

copy_from_user.exit603:                           ; preds = %if.else.i602, %if.then.i601
  %295 = load i64, i64* %n.addr.i587, align 8
  %tobool302 = icmp ne i64 %295, 0
  br i1 %tobool302, label %if.then303, label %if.end304

if.then303:                                       ; preds = %copy_from_user.exit603
  store i32 -14, i32* %ret, align 4
  br label %error

if.end304:                                        ; preds = %copy_from_user.exit603
  br label %if.end316

if.else305:                                       ; preds = %if.end293
  %296 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type306 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %296, i32 0, i32 0
  %297 = load i8, i8* %type306, align 8
  %conv307 = zext i8 %297 to i32
  %cmp308 = icmp eq i32 %conv307, 0
  br i1 %cmp308, label %if.then310, label %if.end315

if.then310:                                       ; preds = %if.else305
  %298 = load %struct.async*, %struct.async** %as, align 8
  %urb311 = getelementptr inbounds %struct.async, %struct.async* %298, i32 0, i32 8
  %299 = load %struct.urb*, %struct.urb** %urb311, align 8
  %transfer_buffer312 = getelementptr inbounds %struct.urb, %struct.urb* %299, i32 0, i32 14
  %300 = load i8*, i8** %transfer_buffer312, align 8
  %301 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length313 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %301, i32 0, i32 5
  %302 = load i32, i32* %buffer_length313, align 8
  %conv314 = sext i32 %302 to i64
  call void @llvm.memset.p0i8.i64(i8* %300, i8 0, i64 %conv314, i32 1, i1 false)
  br label %if.end315

if.end315:                                        ; preds = %if.then310, %if.else305
  br label %if.end316

if.end316:                                        ; preds = %if.end315, %if.end304
  br label %if.end317

if.end317:                                        ; preds = %if.end316, %if.then276
  br label %if.end318

if.end318:                                        ; preds = %if.end317, %if.else269
  br label %if.end319

if.end319:                                        ; preds = %if.end318, %for.end268
  %303 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev320 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %303, i32 0, i32 1
  %304 = load %struct.usb_device*, %struct.usb_device** %dev320, align 8
  %305 = load %struct.async*, %struct.async** %as, align 8
  %urb321 = getelementptr inbounds %struct.async, %struct.async* %305, i32 0, i32 8
  %306 = load %struct.urb*, %struct.urb** %urb321, align 8
  %dev322 = getelementptr inbounds %struct.urb, %struct.urb* %306, i32 0, i32 8
  store %struct.usb_device* %304, %struct.usb_device** %dev322, align 8
  %307 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type323 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %307, i32 0, i32 0
  %308 = load i8, i8* %type323, align 8
  %conv324 = zext i8 %308 to i32
  %shl = shl i32 %conv324, 30
  %309 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev325 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %309, i32 0, i32 1
  %310 = load %struct.usb_device*, %struct.usb_device** %dev325, align 8
  %311 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint326 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %311, i32 0, i32 1
  %312 = load i8, i8* %endpoint326, align 1
  %conv327 = zext i8 %312 to i32
  %and328 = and i32 %conv327, 15
  %call329 = call i32 @__create_pipe(%struct.usb_device* %310, i32 %and328)
  %or330 = or i32 %shl, %call329
  %313 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint331 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %313, i32 0, i32 1
  %314 = load i8, i8* %endpoint331, align 1
  %conv332 = zext i8 %314 to i32
  %and333 = and i32 %conv332, 128
  %or334 = or i32 %or330, %and333
  %315 = load %struct.async*, %struct.async** %as, align 8
  %urb335 = getelementptr inbounds %struct.async, %struct.async* %315, i32 0, i32 8
  %316 = load %struct.urb*, %struct.urb** %urb335, align 8
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %316, i32 0, i32 10
  store i32 %or334, i32* %pipe, align 8
  %317 = load i32, i32* %is_in, align 4
  %tobool336 = icmp ne i32 %317, 0
  %318 = zext i1 %tobool336 to i64
  %cond337 = select i1 %tobool336, i32 512, i32 0
  store i32 %cond337, i32* %u, align 4
  %319 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags338 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %319, i32 0, i32 3
  %320 = load i32, i32* %flags338, align 8
  %and339 = and i32 %320, 2
  %tobool340 = icmp ne i32 %and339, 0
  br i1 %tobool340, label %if.then341, label %if.end343

if.then341:                                       ; preds = %if.end319
  %321 = load i32, i32* %u, align 4
  %or342 = or i32 %321, 2
  store i32 %or342, i32* %u, align 4
  br label %if.end343

if.end343:                                        ; preds = %if.then341, %if.end319
  %322 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags344 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %322, i32 0, i32 3
  %323 = load i32, i32* %flags344, align 8
  %and345 = and i32 %323, 1
  %tobool346 = icmp ne i32 %and345, 0
  br i1 %tobool346, label %land.lhs.true347, label %if.end351

land.lhs.true347:                                 ; preds = %if.end343
  %324 = load i32, i32* %is_in, align 4
  %tobool348 = icmp ne i32 %324, 0
  br i1 %tobool348, label %if.then349, label %if.end351

if.then349:                                       ; preds = %land.lhs.true347
  %325 = load i32, i32* %u, align 4
  %or350 = or i32 %325, 1
  store i32 %or350, i32* %u, align 4
  br label %if.end351

if.end351:                                        ; preds = %if.then349, %land.lhs.true347, %if.end343
  %326 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags352 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %326, i32 0, i32 3
  %327 = load i32, i32* %flags352, align 8
  %and353 = and i32 %327, 32
  %tobool354 = icmp ne i32 %and353, 0
  br i1 %tobool354, label %if.then355, label %if.end357

if.then355:                                       ; preds = %if.end351
  %328 = load i32, i32* %u, align 4
  %or356 = or i32 %328, 32
  store i32 %or356, i32* %u, align 4
  br label %if.end357

if.end357:                                        ; preds = %if.then355, %if.end351
  %329 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags358 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %329, i32 0, i32 3
  %330 = load i32, i32* %flags358, align 8
  %and359 = and i32 %330, 64
  %tobool360 = icmp ne i32 %and359, 0
  br i1 %tobool360, label %if.then361, label %if.end363

if.then361:                                       ; preds = %if.end357
  %331 = load i32, i32* %u, align 4
  %or362 = or i32 %331, 64
  store i32 %or362, i32* %u, align 4
  br label %if.end363

if.end363:                                        ; preds = %if.then361, %if.end357
  %332 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags364 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %332, i32 0, i32 3
  %333 = load i32, i32* %flags364, align 8
  %and365 = and i32 %333, 128
  %tobool366 = icmp ne i32 %and365, 0
  br i1 %tobool366, label %if.then367, label %if.end369

if.then367:                                       ; preds = %if.end363
  %334 = load i32, i32* %u, align 4
  %or368 = or i32 %334, 128
  store i32 %or368, i32* %u, align 4
  br label %if.end369

if.end369:                                        ; preds = %if.then367, %if.end363
  %335 = load i32, i32* %u, align 4
  %336 = load %struct.async*, %struct.async** %as, align 8
  %urb370 = getelementptr inbounds %struct.async, %struct.async* %336, i32 0, i32 8
  %337 = load %struct.urb*, %struct.urb** %urb370, align 8
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %337, i32 0, i32 13
  store i32 %335, i32* %transfer_flags, align 4
  %338 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length371 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %338, i32 0, i32 5
  %339 = load i32, i32* %buffer_length371, align 8
  %340 = load %struct.async*, %struct.async** %as, align 8
  %urb372 = getelementptr inbounds %struct.async, %struct.async* %340, i32 0, i32 8
  %341 = load %struct.urb*, %struct.urb** %urb372, align 8
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %341, i32 0, i32 19
  store i32 %339, i32* %transfer_buffer_length, align 8
  %342 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %343 = bitcast %struct.usb_ctrlrequest* %342 to i8*
  %344 = load %struct.async*, %struct.async** %as, align 8
  %urb373 = getelementptr inbounds %struct.async, %struct.async* %344, i32 0, i32 8
  %345 = load %struct.urb*, %struct.urb** %urb373, align 8
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %345, i32 0, i32 21
  store i8* %343, i8** %setup_packet, align 8
  store %struct.usb_ctrlrequest* null, %struct.usb_ctrlrequest** %dr, align 8
  %346 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %346, i32 0, i32 7
  %347 = load i32, i32* %start_frame, align 8
  %348 = load %struct.async*, %struct.async** %as, align 8
  %urb374 = getelementptr inbounds %struct.async, %struct.async* %348, i32 0, i32 8
  %349 = load %struct.urb*, %struct.urb** %urb374, align 8
  %start_frame375 = getelementptr inbounds %struct.urb, %struct.urb* %349, i32 0, i32 23
  store i32 %347, i32* %start_frame375, align 8
  %350 = load i32, i32* %number_of_packets, align 4
  %351 = load %struct.async*, %struct.async** %as, align 8
  %urb376 = getelementptr inbounds %struct.async, %struct.async* %351, i32 0, i32 8
  %352 = load %struct.urb*, %struct.urb** %urb376, align 8
  %number_of_packets377 = getelementptr inbounds %struct.urb, %struct.urb* %352, i32 0, i32 24
  store i32 %350, i32* %number_of_packets377, align 4
  %353 = load i32, i32* %stream_id, align 4
  %354 = load %struct.async*, %struct.async** %as, align 8
  %urb378 = getelementptr inbounds %struct.async, %struct.async* %354, i32 0, i32 8
  %355 = load %struct.urb*, %struct.urb** %urb378, align 8
  %stream_id379 = getelementptr inbounds %struct.urb, %struct.urb* %355, i32 0, i32 11
  store i32 %353, i32* %stream_id379, align 4
  %356 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc380 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %356, i32 0, i32 0
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc380, i32 0, i32 5
  %357 = load i8, i8* %bInterval, align 2
  %tobool381 = icmp ne i8 %357, 0
  br i1 %tobool381, label %if.then382, label %if.end419

if.then382:                                       ; preds = %if.end369
  %358 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type383 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %358, i32 0, i32 0
  %359 = load i8, i8* %type383, align 8
  %conv384 = zext i8 %359 to i32
  %cmp385 = icmp eq i32 %conv384, 0
  br i1 %cmp385, label %if.then396, label %lor.lhs.false387

lor.lhs.false387:                                 ; preds = %if.then382
  %360 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev388 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %360, i32 0, i32 1
  %361 = load %struct.usb_device*, %struct.usb_device** %dev388, align 8
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %361, i32 0, i32 4
  %362 = load i32, i32* %speed, align 4
  %cmp389 = icmp eq i32 %362, 3
  br i1 %cmp389, label %if.then396, label %lor.lhs.false391

lor.lhs.false391:                                 ; preds = %lor.lhs.false387
  %363 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev392 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %363, i32 0, i32 1
  %364 = load %struct.usb_device*, %struct.usb_device** %dev392, align 8
  %speed393 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %364, i32 0, i32 4
  %365 = load i32, i32* %speed393, align 4
  %cmp394 = icmp uge i32 %365, 5
  br i1 %cmp394, label %if.then396, label %if.else412

if.then396:                                       ; preds = %lor.lhs.false391, %lor.lhs.false387, %if.then382
  store i32 15, i32* %__UNIQUE_ID_min1_40, align 4
  %366 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc397 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %366, i32 0, i32 0
  %bInterval398 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc397, i32 0, i32 5
  %367 = load i8, i8* %bInterval398, align 2
  %conv399 = zext i8 %367 to i32
  %sub400 = sub nsw i32 %conv399, 1
  store i32 %sub400, i32* %__UNIQUE_ID_min2_41, align 4
  %cmp401 = icmp eq i32* %__UNIQUE_ID_min1_40, %__UNIQUE_ID_min2_41
  %conv402 = zext i1 %cmp401 to i32
  %368 = load i32, i32* %__UNIQUE_ID_min1_40, align 4
  %369 = load i32, i32* %__UNIQUE_ID_min2_41, align 4
  %cmp404 = icmp slt i32 %368, %369
  br i1 %cmp404, label %cond.true406, label %cond.false407

cond.true406:                                     ; preds = %if.then396
  %370 = load i32, i32* %__UNIQUE_ID_min1_40, align 4
  br label %cond.end408

cond.false407:                                    ; preds = %if.then396
  %371 = load i32, i32* %__UNIQUE_ID_min2_41, align 4
  br label %cond.end408

cond.end408:                                      ; preds = %cond.false407, %cond.true406
  %cond409 = phi i32 [ %370, %cond.true406 ], [ %371, %cond.false407 ]
  store i32 %cond409, i32* %tmp403, align 4
  %372 = load i32, i32* %tmp403, align 4
  %shl410 = shl i32 1, %372
  %373 = load %struct.async*, %struct.async** %as, align 8
  %urb411 = getelementptr inbounds %struct.async, %struct.async* %373, i32 0, i32 8
  %374 = load %struct.urb*, %struct.urb** %urb411, align 8
  %interval = getelementptr inbounds %struct.urb, %struct.urb* %374, i32 0, i32 25
  store i32 %shl410, i32* %interval, align 8
  br label %if.end418

if.else412:                                       ; preds = %lor.lhs.false391
  %375 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc413 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %375, i32 0, i32 0
  %bInterval414 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc413, i32 0, i32 5
  %376 = load i8, i8* %bInterval414, align 2
  %conv415 = zext i8 %376 to i32
  %377 = load %struct.async*, %struct.async** %as, align 8
  %urb416 = getelementptr inbounds %struct.async, %struct.async* %377, i32 0, i32 8
  %378 = load %struct.urb*, %struct.urb** %urb416, align 8
  %interval417 = getelementptr inbounds %struct.urb, %struct.urb* %378, i32 0, i32 25
  store i32 %conv415, i32* %interval417, align 8
  br label %if.end418

if.end418:                                        ; preds = %if.else412, %cond.end408
  br label %if.end419

if.end419:                                        ; preds = %if.end418, %if.end369
  %379 = load %struct.async*, %struct.async** %as, align 8
  %380 = bitcast %struct.async* %379 to i8*
  %381 = load %struct.async*, %struct.async** %as, align 8
  %urb420 = getelementptr inbounds %struct.async, %struct.async* %381, i32 0, i32 8
  %382 = load %struct.urb*, %struct.urb** %urb420, align 8
  %context = getelementptr inbounds %struct.urb, %struct.urb* %382, i32 0, i32 27
  store i8* %380, i8** %context, align 8
  %383 = load %struct.async*, %struct.async** %as, align 8
  %urb421 = getelementptr inbounds %struct.async, %struct.async* %383, i32 0, i32 8
  %384 = load %struct.urb*, %struct.urb** %urb421, align 8
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %384, i32 0, i32 28
  store void (%struct.urb*)* @async_completed, void (%struct.urb*)** %complete, align 8
  store i32 0, i32* %u, align 4
  store i32 0, i32* %totlen, align 4
  br label %for.cond422

for.cond422:                                      ; preds = %for.inc442, %if.end419
  %385 = load i32, i32* %u, align 4
  %386 = load i32, i32* %number_of_packets, align 4
  %cmp423 = icmp ult i32 %385, %386
  br i1 %cmp423, label %for.body425, label %for.end444

for.body425:                                      ; preds = %for.cond422
  %387 = load i32, i32* %totlen, align 4
  %388 = load %struct.async*, %struct.async** %as, align 8
  %urb426 = getelementptr inbounds %struct.async, %struct.async* %388, i32 0, i32 8
  %389 = load %struct.urb*, %struct.urb** %urb426, align 8
  %iso_frame_desc427 = getelementptr inbounds %struct.urb, %struct.urb* %389, i32 0, i32 29
  %390 = load i32, i32* %u, align 4
  %idxprom428 = zext i32 %390 to i64
  %arrayidx429 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc427, i64 0, i64 %idxprom428
  %offset = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx429, i32 0, i32 0
  store i32 %387, i32* %offset, align 8
  %391 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %392 = load i32, i32* %u, align 4
  %idxprom430 = zext i32 %392 to i64
  %arrayidx431 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %391, i64 %idxprom430
  %length432 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx431, i32 0, i32 0
  %393 = load i32, i32* %length432, align 4
  %394 = load %struct.async*, %struct.async** %as, align 8
  %urb433 = getelementptr inbounds %struct.async, %struct.async* %394, i32 0, i32 8
  %395 = load %struct.urb*, %struct.urb** %urb433, align 8
  %iso_frame_desc434 = getelementptr inbounds %struct.urb, %struct.urb* %395, i32 0, i32 29
  %396 = load i32, i32* %u, align 4
  %idxprom435 = zext i32 %396 to i64
  %arrayidx436 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc434, i64 0, i64 %idxprom435
  %length437 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx436, i32 0, i32 1
  store i32 %393, i32* %length437, align 4
  %397 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %398 = load i32, i32* %u, align 4
  %idxprom438 = zext i32 %398 to i64
  %arrayidx439 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %397, i64 %idxprom438
  %length440 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx439, i32 0, i32 0
  %399 = load i32, i32* %length440, align 4
  %400 = load i32, i32* %totlen, align 4
  %add441 = add i32 %400, %399
  store i32 %add441, i32* %totlen, align 4
  br label %for.inc442

for.inc442:                                       ; preds = %for.body425
  %401 = load i32, i32* %u, align 4
  %inc443 = add i32 %401, 1
  store i32 %inc443, i32* %u, align 4
  br label %for.cond422

for.end444:                                       ; preds = %for.cond422
  %402 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %403 = bitcast %struct.usbdevfs_iso_packet_desc* %402 to i8*
  call void @kfree(i8* %403)
  store %struct.usbdevfs_iso_packet_desc* null, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %404 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %405 = load %struct.async*, %struct.async** %as, align 8
  %ps445 = getelementptr inbounds %struct.async, %struct.async* %405, i32 0, i32 1
  store %struct.usb_dev_state* %404, %struct.usb_dev_state** %ps445, align 8
  %406 = load i8*, i8** %arg.addr, align 8
  %407 = load %struct.async*, %struct.async** %as, align 8
  %userurb = getelementptr inbounds %struct.async, %struct.async* %407, i32 0, i32 7
  store i8* %406, i8** %userurb, align 8
  %408 = load %struct.async*, %struct.async** %as, align 8
  %usbm446 = getelementptr inbounds %struct.async, %struct.async* %408, i32 0, i32 9
  %409 = load %struct.usb_memory*, %struct.usb_memory** %usbm446, align 8
  %tobool447 = icmp ne %struct.usb_memory* %409, null
  br i1 %tobool447, label %if.then448, label %if.else460

if.then448:                                       ; preds = %for.end444
  %410 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer450 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %410, i32 0, i32 4
  %411 = load i8*, i8** %buffer450, align 8
  %412 = ptrtoint i8* %411 to i64
  store i64 %412, i64* %uurb_start449, align 8
  %413 = load %struct.async*, %struct.async** %as, align 8
  %urb451 = getelementptr inbounds %struct.async, %struct.async* %413, i32 0, i32 8
  %414 = load %struct.urb*, %struct.urb** %urb451, align 8
  %transfer_flags452 = getelementptr inbounds %struct.urb, %struct.urb* %414, i32 0, i32 13
  %415 = load i32, i32* %transfer_flags452, align 4
  %or453 = or i32 %415, 4
  store i32 %or453, i32* %transfer_flags452, align 4
  %416 = load %struct.async*, %struct.async** %as, align 8
  %usbm454 = getelementptr inbounds %struct.async, %struct.async* %416, i32 0, i32 9
  %417 = load %struct.usb_memory*, %struct.usb_memory** %usbm454, align 8
  %dma_handle = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %417, i32 0, i32 5
  %418 = load i64, i64* %dma_handle, align 8
  %419 = load i64, i64* %uurb_start449, align 8
  %420 = load %struct.async*, %struct.async** %as, align 8
  %usbm455 = getelementptr inbounds %struct.async, %struct.async* %420, i32 0, i32 9
  %421 = load %struct.usb_memory*, %struct.usb_memory** %usbm455, align 8
  %vm_start456 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %421, i32 0, i32 6
  %422 = load i64, i64* %vm_start456, align 8
  %sub457 = sub i64 %419, %422
  %add458 = add i64 %418, %sub457
  %423 = load %struct.async*, %struct.async** %as, align 8
  %urb459 = getelementptr inbounds %struct.async, %struct.async* %423, i32 0, i32 8
  %424 = load %struct.urb*, %struct.urb** %urb459, align 8
  %transfer_dma = getelementptr inbounds %struct.urb, %struct.urb* %424, i32 0, i32 15
  store i64 %add458, i64* %transfer_dma, align 8
  br label %if.end469

if.else460:                                       ; preds = %for.end444
  %425 = load i32, i32* %is_in, align 4
  %tobool461 = icmp ne i32 %425, 0
  br i1 %tobool461, label %land.lhs.true462, label %if.end468

land.lhs.true462:                                 ; preds = %if.else460
  %426 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length463 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %426, i32 0, i32 5
  %427 = load i32, i32* %buffer_length463, align 8
  %cmp464 = icmp sgt i32 %427, 0
  br i1 %cmp464, label %if.then466, label %if.end468

if.then466:                                       ; preds = %land.lhs.true462
  %428 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer467 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %428, i32 0, i32 4
  %429 = load i8*, i8** %buffer467, align 8
  %430 = load %struct.async*, %struct.async** %as, align 8
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %430, i32 0, i32 6
  store i8* %429, i8** %userbuffer, align 8
  br label %if.end468

if.end468:                                        ; preds = %if.then466, %land.lhs.true462, %if.else460
  br label %if.end469

if.end469:                                        ; preds = %if.end468, %if.then448
  %431 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %signr = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %431, i32 0, i32 10
  %432 = load i32, i32* %signr, align 4
  %433 = load %struct.async*, %struct.async** %as, align 8
  %signr470 = getelementptr inbounds %struct.async, %struct.async* %433, i32 0, i32 4
  store i32 %432, i32* %signr470, align 8
  %434 = load i32, i32* %ifnum, align 4
  %435 = load %struct.async*, %struct.async** %as, align 8
  %ifnum471 = getelementptr inbounds %struct.async, %struct.async* %435, i32 0, i32 5
  store i32 %434, i32* %ifnum471, align 4
  %436 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %436, %struct.task_struct** %pfo_ret__.i604, align 8
  %437 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i604, align 8
  store %struct.task_struct* %437, %struct.task_struct** %tmp.i605, align 8
  %438 = load %struct.task_struct*, %struct.task_struct** %tmp.i605, align 8
  %call473 = call %struct.pid* @task_pid(%struct.task_struct* %438)
  %call474 = call %struct.pid* @get_pid(%struct.pid* %call473)
  %439 = load %struct.async*, %struct.async** %as, align 8
  %pid = getelementptr inbounds %struct.async, %struct.async* %439, i32 0, i32 2
  store %struct.pid* %call474, %struct.pid** %pid, align 8
  br label %do.body475

do.body475:                                       ; preds = %if.end469
  br label %do.end476

do.end476:                                        ; preds = %do.body475
  %440 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %440, %struct.task_struct** %pfo_ret__.i606, align 8
  %441 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i606, align 8
  store %struct.task_struct* %441, %struct.task_struct** %tmp.i607, align 8
  %442 = load %struct.task_struct*, %struct.task_struct** %tmp.i607, align 8
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %442, i32 0, i32 76
  %443 = load %struct.cred*, %struct.cred** %cred, align 32
  store %struct.cred* %443, %struct.cred** %tmp477, align 8
  %444 = load %struct.cred*, %struct.cred** %tmp477, align 8
  %call479 = call %struct.cred* @get_cred(%struct.cred* %444)
  %445 = load %struct.async*, %struct.async** %as, align 8
  %cred480 = getelementptr inbounds %struct.async, %struct.async* %445, i32 0, i32 3
  store %struct.cred* %call479, %struct.cred** %cred480, align 8
  %446 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %446, %struct.task_struct** %pfo_ret__.i608, align 8
  %447 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i608, align 8
  store %struct.task_struct* %447, %struct.task_struct** %tmp.i609, align 8
  %448 = load %struct.task_struct*, %struct.task_struct** %tmp.i609, align 8
  %449 = load %struct.async*, %struct.async** %as, align 8
  %secid = getelementptr inbounds %struct.async, %struct.async* %449, i32 0, i32 12
  call void @security_task_getsecid(%struct.task_struct* %448, i32* %secid)
  %450 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev482 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %450, i32 0, i32 1
  %451 = load %struct.usb_device*, %struct.usb_device** %dev482, align 8
  %452 = load %struct.async*, %struct.async** %as, align 8
  %userurb483 = getelementptr inbounds %struct.async, %struct.async* %452, i32 0, i32 7
  %453 = load i8*, i8** %userurb483, align 8
  %454 = load %struct.async*, %struct.async** %as, align 8
  %urb484 = getelementptr inbounds %struct.async, %struct.async* %454, i32 0, i32 8
  %455 = load %struct.urb*, %struct.urb** %urb484, align 8
  %pipe485 = getelementptr inbounds %struct.urb, %struct.urb* %455, i32 0, i32 10
  %456 = load i32, i32* %pipe485, align 8
  %457 = load %struct.async*, %struct.async** %as, align 8
  %urb486 = getelementptr inbounds %struct.async, %struct.async* %457, i32 0, i32 8
  %458 = load %struct.urb*, %struct.urb** %urb486, align 8
  %transfer_buffer_length487 = getelementptr inbounds %struct.urb, %struct.urb* %458, i32 0, i32 19
  %459 = load i32, i32* %transfer_buffer_length487, align 8
  call void @snoop_urb(%struct.usb_device* %451, i8* %453, i32 %456, i32 %459, i32 0, i32 0, i8* null, i32 0)
  %460 = load i32, i32* %is_in, align 4
  %tobool488 = icmp ne i32 %460, 0
  br i1 %tobool488, label %if.end493, label %if.then489

if.then489:                                       ; preds = %do.end476
  %461 = load %struct.async*, %struct.async** %as, align 8
  %urb490 = getelementptr inbounds %struct.async, %struct.async* %461, i32 0, i32 8
  %462 = load %struct.urb*, %struct.urb** %urb490, align 8
  %463 = load %struct.async*, %struct.async** %as, align 8
  %urb491 = getelementptr inbounds %struct.async, %struct.async* %463, i32 0, i32 8
  %464 = load %struct.urb*, %struct.urb** %urb491, align 8
  %transfer_buffer_length492 = getelementptr inbounds %struct.urb, %struct.urb* %464, i32 0, i32 19
  %465 = load i32, i32* %transfer_buffer_length492, align 8
  call void @snoop_urb_data(%struct.urb* %462, i32 %465)
  br label %if.end493

if.end493:                                        ; preds = %if.then489, %do.end476
  %466 = load %struct.async*, %struct.async** %as, align 8
  call void @async_newpending(%struct.async* %466)
  %467 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc494 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %467, i32 0, i32 0
  %call495 = call i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %desc494)
  %tobool496 = icmp ne i32 %call495, 0
  br i1 %tobool496, label %if.then497, label %if.else527

if.then497:                                       ; preds = %if.end493
  %468 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %468, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %469 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %470 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %469, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %470 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock.i) #4
  %471 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc498 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %471, i32 0, i32 0
  %call499 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %desc498)
  %472 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc500 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %472, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc500, i32 0, i32 2
  %473 = load i8, i8* %bEndpointAddress, align 2
  %conv501 = zext i8 %473 to i32
  %and502 = and i32 %conv501, 128
  %shr = ashr i32 %and502, 3
  %or503 = or i32 %call499, %shr
  %conv504 = trunc i32 %or503 to i8
  %474 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr = getelementptr inbounds %struct.async, %struct.async* %474, i32 0, i32 13
  store i8 %conv504, i8* %bulk_addr, align 4
  %475 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags505 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %475, i32 0, i32 3
  %476 = load i32, i32* %flags505, align 8
  %and506 = and i32 %476, 4
  %tobool507 = icmp ne i32 %and506, 0
  br i1 %tobool507, label %if.then508, label %if.else509

if.then508:                                       ; preds = %if.then497
  %477 = load %struct.async*, %struct.async** %as, align 8
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %477, i32 0, i32 14
  store i8 1, i8* %bulk_status, align 1
  br label %if.end514

if.else509:                                       ; preds = %if.then497
  %478 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr510 = getelementptr inbounds %struct.async, %struct.async* %478, i32 0, i32 13
  %479 = load i8, i8* %bulk_addr510, align 4
  %conv511 = zext i8 %479 to i32
  %shl512 = shl i32 1, %conv511
  %neg = xor i32 %shl512, -1
  %480 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %disabled_bulk_eps = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %480, i32 0, i32 14
  %481 = load i32, i32* %disabled_bulk_eps, align 4
  %and513 = and i32 %481, %neg
  store i32 %and513, i32* %disabled_bulk_eps, align 4
  br label %if.end514

if.end514:                                        ; preds = %if.else509, %if.then508
  %482 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %disabled_bulk_eps515 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %482, i32 0, i32 14
  %483 = load i32, i32* %disabled_bulk_eps515, align 4
  %484 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr516 = getelementptr inbounds %struct.async, %struct.async* %484, i32 0, i32 13
  %485 = load i8, i8* %bulk_addr516, align 4
  %conv517 = zext i8 %485 to i32
  %shl518 = shl i32 1, %conv517
  %and519 = and i32 %483, %shl518
  %tobool520 = icmp ne i32 %and519, 0
  br i1 %tobool520, label %if.then521, label %if.else522

if.then521:                                       ; preds = %if.end514
  store i32 -121, i32* %ret, align 4
  br label %if.end525

if.else522:                                       ; preds = %if.end514
  %486 = load %struct.async*, %struct.async** %as, align 8
  %urb523 = getelementptr inbounds %struct.async, %struct.async* %486, i32 0, i32 8
  %487 = load %struct.urb*, %struct.urb** %urb523, align 8
  %call524 = call i32 @usb_submit_urb(%struct.urb* %487, i32 17301536)
  store i32 %call524, i32* %ret, align 4
  br label %if.end525

if.end525:                                        ; preds = %if.else522, %if.then521
  %488 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock526 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %488, i32 0, i32 3
  store %struct.spinlock* %lock526, %struct.spinlock** %lock.addr.i610, align 8
  %489 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i610, align 8
  %490 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %489, i32 0, i32 0
  %rlock.i611 = bitcast %union.anon* %490 to %struct.raw_spinlock*
  call void @__raw_spin_unlock_irq(%struct.raw_spinlock* %rlock.i611) #4
  br label %if.end530

if.else527:                                       ; preds = %if.end493
  %491 = load %struct.async*, %struct.async** %as, align 8
  %urb528 = getelementptr inbounds %struct.async, %struct.async* %491, i32 0, i32 8
  %492 = load %struct.urb*, %struct.urb** %urb528, align 8
  %call529 = call i32 @usb_submit_urb(%struct.urb* %492, i32 20971712)
  store i32 %call529, i32* %ret, align 4
  br label %if.end530

if.end530:                                        ; preds = %if.else527, %if.end525
  %493 = load i32, i32* %ret, align 4
  %tobool531 = icmp ne i32 %493, 0
  br i1 %tobool531, label %if.then532, label %if.end539

if.then532:                                       ; preds = %if.end530
  %494 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev533 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %494, i32 0, i32 1
  %495 = load %struct.usb_device*, %struct.usb_device** %dev533, align 8
  %dev534 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %495, i32 0, i32 11
  %496 = load i32, i32* %ret, align 4
  call void (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), %struct.device* %dev534, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.56, i32 0, i32 0), i32 %496)
  %497 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev535 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %497, i32 0, i32 1
  %498 = load %struct.usb_device*, %struct.usb_device** %dev535, align 8
  %499 = load %struct.async*, %struct.async** %as, align 8
  %userurb536 = getelementptr inbounds %struct.async, %struct.async* %499, i32 0, i32 7
  %500 = load i8*, i8** %userurb536, align 8
  %501 = load %struct.async*, %struct.async** %as, align 8
  %urb537 = getelementptr inbounds %struct.async, %struct.async* %501, i32 0, i32 8
  %502 = load %struct.urb*, %struct.urb** %urb537, align 8
  %pipe538 = getelementptr inbounds %struct.urb, %struct.urb* %502, i32 0, i32 10
  %503 = load i32, i32* %pipe538, align 8
  %504 = load i32, i32* %ret, align 4
  call void @snoop_urb(%struct.usb_device* %498, i8* %500, i32 %503, i32 0, i32 %504, i32 1, i8* null, i32 0)
  %505 = load %struct.async*, %struct.async** %as, align 8
  call void @async_removepending(%struct.async* %505)
  br label %error

if.end539:                                        ; preds = %if.end530
  store i32 0, i32* %retval, align 4
  br label %return

error:                                            ; preds = %if.then532, %if.then303, %if.then292, %if.then260, %if.then248, %if.then228, %if.then218, %if.then196, %if.then191, %if.then187, %if.then161, %if.then153, %if.then67, %if.then59, %if.then52
  %506 = load %struct.async*, %struct.async** %as, align 8
  %tobool540 = icmp ne %struct.async* %506, null
  br i1 %tobool540, label %land.lhs.true541, label %if.end547

land.lhs.true541:                                 ; preds = %error
  %507 = load %struct.async*, %struct.async** %as, align 8
  %usbm542 = getelementptr inbounds %struct.async, %struct.async* %507, i32 0, i32 9
  %508 = load %struct.usb_memory*, %struct.usb_memory** %usbm542, align 8
  %tobool543 = icmp ne %struct.usb_memory* %508, null
  br i1 %tobool543, label %if.then544, label %if.end547

if.then544:                                       ; preds = %land.lhs.true541
  %509 = load %struct.async*, %struct.async** %as, align 8
  %usbm545 = getelementptr inbounds %struct.async, %struct.async* %509, i32 0, i32 9
  %510 = load %struct.usb_memory*, %struct.usb_memory** %usbm545, align 8
  %511 = load %struct.async*, %struct.async** %as, align 8
  %usbm546 = getelementptr inbounds %struct.async, %struct.async* %511, i32 0, i32 9
  %512 = load %struct.usb_memory*, %struct.usb_memory** %usbm546, align 8
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %512, i32 0, i32 2
  call void @dec_usb_memory_use_count(%struct.usb_memory* %510, i32* %urb_use_count)
  br label %if.end547

if.end547:                                        ; preds = %if.then544, %land.lhs.true541, %error
  %513 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %514 = bitcast %struct.usbdevfs_iso_packet_desc* %513 to i8*
  call void @kfree(i8* %514)
  %515 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %516 = bitcast %struct.usb_ctrlrequest* %515 to i8*
  call void @kfree(i8* %516)
  %517 = load %struct.async*, %struct.async** %as, align 8
  %tobool548 = icmp ne %struct.async* %517, null
  br i1 %tobool548, label %if.then549, label %if.end550

if.then549:                                       ; preds = %if.end547
  %518 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %518)
  br label %if.end550

if.end550:                                        ; preds = %if.then549, %if.end547
  %519 = load i32, i32* %ret, align 4
  store i32 %519, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end550, %if.end539, %sw.default, %if.then145, %if.then140, %if.then130, %sw.bb110, %if.then47, %if.then43, %if.then38, %if.then27, %if.then20, %if.then16, %if.then2, %if.then
  %520 = load i32, i32* %retval, align 4
  ret i32 %520
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.usb_host_endpoint* @ep_to_host_endpoint(%struct.usb_device* %dev, i8 zeroext %ep) #0 {
entry:
  %retval = alloca %struct.usb_host_endpoint*, align 8
  %dev.addr = alloca %struct.usb_device*, align 8
  %ep.addr = alloca i8, align 1
  store %struct.usb_device* %dev, %struct.usb_device** %dev.addr, align 8
  store i8 %ep, i8* %ep.addr, align 1
  %0 = load i8, i8* %ep.addr, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.usb_device*, %struct.usb_device** %dev.addr, align 8
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 16
  %2 = load i8, i8* %ep.addr, align 1
  %conv1 = zext i8 %2 to i32
  %and2 = and i32 %conv1, 15
  %idxprom = sext i32 %and2 to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom
  %3 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8
  store %struct.usb_host_endpoint* %3, %struct.usb_host_endpoint** %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %4 = load %struct.usb_device*, %struct.usb_device** %dev.addr, align 8
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 17
  %5 = load i8, i8* %ep.addr, align 1
  %conv3 = zext i8 %5 to i32
  %and4 = and i32 %conv3, 15
  %idxprom5 = sext i32 %and4 to i64
  %arrayidx6 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom5
  %6 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx6, align 8
  store %struct.usb_host_endpoint* %6, %struct.usb_host_endpoint** %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %7 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %retval, align 8
  ret %struct.usb_host_endpoint* %7
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %1 = load i8, i8* %bmAttributes, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %1 = load i8, i8* %bmAttributes, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %1 = load i8, i8* %bmAttributes, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare i8* @memdup_user(i8*, i64) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %2 = inttoptr i64 %1 to i8*
  %3 = ptrtoint i8* %2 to i64
  %cmp = icmp uge i64 %3, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  ret i1 %tobool
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @PTR_ERR(i8* %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  ret i64 %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.async* @alloc_async(i32 %numisoframes) #0 {
entry:
  %retval = alloca %struct.async*, align 8
  %numisoframes.addr = alloca i32, align 4
  %as = alloca %struct.async*, align 8
  store i32 %numisoframes, i32* %numisoframes.addr, align 4
  %call = call i8* @kzalloc(i64 96, i32 20971712)
  %0 = bitcast i8* %call to %struct.async*
  store %struct.async* %0, %struct.async** %as, align 8
  %1 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.async* null, %struct.async** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %numisoframes.addr, align 4
  %call1 = call %struct.urb* @usb_alloc_urb(i32 %2, i32 20971712)
  %3 = load %struct.async*, %struct.async** %as, align 8
  %urb = getelementptr inbounds %struct.async, %struct.async* %3, i32 0, i32 8
  store %struct.urb* %call1, %struct.urb** %urb, align 8
  %4 = load %struct.async*, %struct.async** %as, align 8
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %4, i32 0, i32 8
  %5 = load %struct.urb*, %struct.urb** %urb2, align 8
  %tobool3 = icmp ne %struct.urb* %5, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %6 = load %struct.async*, %struct.async** %as, align 8
  %7 = bitcast %struct.async* %6 to i8*
  call void @kfree(i8* %7)
  store %struct.async* null, %struct.async** %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %8 = load %struct.async*, %struct.async** %as, align 8
  store %struct.async* %8, %struct.async** %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %9 = load %struct.async*, %struct.async** %retval, align 8
  ret %struct.async* %9
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.usb_memory* @find_memory_area(%struct.usb_dev_state* %ps, %struct.usbdevfs_urb* %uurb) #0 {
entry:
  %lock.addr.i30 = alloca %struct.spinlock*, align 8
  %flags.addr.i = alloca i64, align 8
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %tmp.i = alloca i32, align 4
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %uurb.addr = alloca %struct.usbdevfs_urb*, align 8
  %usbm = alloca %struct.usb_memory*, align 8
  %iter = alloca %struct.usb_memory*, align 8
  %flags = alloca i64, align 8
  %uurb_start = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__mptr = alloca %struct.list_head*, align 8
  %tmp4 = alloca %struct.usb_memory*, align 8
  %__mptr24 = alloca %struct.list_head*, align 8
  %tmp27 = alloca %struct.usb_memory*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_urb** %uurb.addr, align 8
  store %struct.usb_memory* null, %struct.usb_memory** %usbm, align 8
  %0 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 4
  %1 = load i8*, i8** %buffer, align 8
  %2 = ptrtoint i8* %1 to i64
  store i64 %2, i64* %uurb_start, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %3 = load i32, i32* %tmp, align 4
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %4, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %5 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %6 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %5, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %6 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  store i64 %call2, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.end
  %7 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %memory_list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %7, i32 0, i32 6
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %memory_list, i32 0, i32 0
  %8 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %8, %struct.list_head** %__mptr, align 8
  %9 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %10 = bitcast %struct.list_head* %9 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %10, i64 0
  %11 = bitcast i8* %add.ptr to %struct.usb_memory*
  store %struct.usb_memory* %11, %struct.usb_memory** %tmp4, align 8
  %12 = load %struct.usb_memory*, %struct.usb_memory** %tmp4, align 8
  store %struct.usb_memory* %12, %struct.usb_memory** %iter, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end3
  %13 = load %struct.usb_memory*, %struct.usb_memory** %iter, align 8
  %memlist = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %13, i32 0, i32 0
  %14 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %memory_list5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %14, i32 0, i32 6
  %cmp6 = icmp ne %struct.list_head* %memlist, %memory_list5
  br i1 %cmp6, label %for.body, label %for.end.loopexit

for.body:                                         ; preds = %for.cond
  %15 = load i64, i64* %uurb_start, align 8
  %16 = load %struct.usb_memory*, %struct.usb_memory** %iter, align 8
  %vm_start = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %16, i32 0, i32 6
  %17 = load i64, i64* %vm_start, align 8
  %cmp8 = icmp uge i64 %15, %17
  br i1 %cmp8, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %for.body
  %18 = load i64, i64* %uurb_start, align 8
  %19 = load %struct.usb_memory*, %struct.usb_memory** %iter, align 8
  %vm_start10 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %19, i32 0, i32 6
  %20 = load i64, i64* %vm_start10, align 8
  %21 = load %struct.usb_memory*, %struct.usb_memory** %iter, align 8
  %size = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %21, i32 0, i32 3
  %22 = load i32, i32* %size, align 8
  %conv11 = zext i32 %22 to i64
  %add = add i64 %20, %conv11
  %cmp12 = icmp ult i64 %18, %add
  br i1 %cmp12, label %if.then, label %if.end23

if.then:                                          ; preds = %land.lhs.true
  %23 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %23, i32 0, i32 5
  %24 = load i32, i32* %buffer_length, align 8
  %conv14 = sext i32 %24 to i64
  %25 = load %struct.usb_memory*, %struct.usb_memory** %iter, align 8
  %vm_start15 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %25, i32 0, i32 6
  %26 = load i64, i64* %vm_start15, align 8
  %27 = load %struct.usb_memory*, %struct.usb_memory** %iter, align 8
  %size16 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %27, i32 0, i32 3
  %28 = load i32, i32* %size16, align 8
  %conv17 = zext i32 %28 to i64
  %add18 = add i64 %26, %conv17
  %29 = load i64, i64* %uurb_start, align 8
  %sub = sub i64 %add18, %29
  %cmp19 = icmp ugt i64 %conv14, %sub
  br i1 %cmp19, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.then
  %call22 = call i8* @ERR_PTR(i64 -22)
  %30 = bitcast i8* %call22 to %struct.usb_memory*
  store %struct.usb_memory* %30, %struct.usb_memory** %usbm, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %31 = load %struct.usb_memory*, %struct.usb_memory** %iter, align 8
  store %struct.usb_memory* %31, %struct.usb_memory** %usbm, align 8
  %32 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %urb_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %32, i32 0, i32 2
  %33 = load i32, i32* %urb_use_count, align 4
  %inc = add nsw i32 %33, 1
  store i32 %inc, i32* %urb_use_count, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then21
  br label %for.end

if.end23:                                         ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end23
  %34 = load %struct.usb_memory*, %struct.usb_memory** %iter, align 8
  %memlist25 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %34, i32 0, i32 0
  %next26 = getelementptr inbounds %struct.list_head, %struct.list_head* %memlist25, i32 0, i32 0
  %35 = load %struct.list_head*, %struct.list_head** %next26, align 8
  store %struct.list_head* %35, %struct.list_head** %__mptr24, align 8
  %36 = load %struct.list_head*, %struct.list_head** %__mptr24, align 8
  %37 = bitcast %struct.list_head* %36 to i8*
  %add.ptr28 = getelementptr inbounds i8, i8* %37, i64 0
  %38 = bitcast i8* %add.ptr28 to %struct.usb_memory*
  store %struct.usb_memory* %38, %struct.usb_memory** %tmp27, align 8
  %39 = load %struct.usb_memory*, %struct.usb_memory** %tmp27, align 8
  store %struct.usb_memory* %39, %struct.usb_memory** %iter, align 8
  br label %for.cond

for.end.loopexit:                                 ; preds = %for.cond
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %if.end
  %40 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock29 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %40, i32 0, i32 3
  %41 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock29, %struct.spinlock** %lock.addr.i30, align 8
  store i64 %41, i64* %flags.addr.i, align 8
  store i32 1, i32* %tmp.i, align 4
  %42 = load i32, i32* %tmp.i, align 4
  %43 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i30, align 8
  %44 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %43, i32 0, i32 0
  %rlock.i31 = bitcast %union.anon* %44 to %struct.raw_spinlock*
  %45 = load i64, i64* %flags.addr.i, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i31, i64 %45) #4
  %46 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  ret %struct.usb_memory* %46
}

declare void @sg_init_table(%struct.scatterlist*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @sg_set_buf(%struct.scatterlist* %sg, i8* %buf, i32 %buflen) #0 {
entry:
  %sg.addr = alloca %struct.scatterlist*, align 8
  %buf.addr = alloca i8*, align 8
  %buflen.addr = alloca i32, align 4
  store %struct.scatterlist* %sg, %struct.scatterlist** %sg.addr, align 8
  store i8* %buf, i8** %buf.addr, align 8
  store i32 %buflen, i32* %buflen.addr, align 4
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %1 = load i8*, i8** %buf.addr, align 8
  %2 = ptrtoint i8* %1 to i64
  %call = call i64 @__phys_addr_nodebug(i64 %2)
  %shr = lshr i64 %call, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %3 = load i32, i32* %buflen.addr, align 4
  %4 = load i8*, i8** %buf.addr, align 8
  %5 = ptrtoint i8* %4 to i64
  %and = and i64 %5, 4095
  %conv = trunc i64 %and to i32
  call void @sg_set_page(%struct.scatterlist* %0, %struct.page* %add.ptr, i32 %3, i32 %conv)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @async_completed(%struct.urb* %urb) #0 {
entry:
  %lock.addr.i41 = alloca %struct.spinlock*, align 8
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %urb.addr = alloca %struct.urb*, align 8
  %as = alloca %struct.async*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %sinfo = alloca %struct.siginfo, align 8
  %pid = alloca %struct.pid*, align 8
  %secid = alloca i32, align 4
  %cred = alloca %struct.cred*, align 8
  %signr = alloca i32, align 4
  store %struct.urb* %urb, %struct.urb** %urb.addr, align 8
  %0 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %context = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 27
  %1 = load i8*, i8** %context, align 8
  %2 = bitcast i8* %1 to %struct.async*
  store %struct.async* %2, %struct.async** %as, align 8
  %3 = load %struct.async*, %struct.async** %as, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %3, i32 0, i32 1
  %4 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8
  store %struct.usb_dev_state* %4, %struct.usb_dev_state** %ps, align 8
  store %struct.pid* null, %struct.pid** %pid, align 8
  store i32 0, i32* %secid, align 4
  store %struct.cred* null, %struct.cred** %cred, align 8
  %5 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %5, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %6 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %7 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %6, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %7 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i) #4
  %8 = load %struct.async*, %struct.async** %as, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 0
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %async_completed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %9, i32 0, i32 5
  call void @list_move_tail(%struct.list_head* %asynclist, %struct.list_head* %async_completed)
  %10 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %status = getelementptr inbounds %struct.urb, %struct.urb* %10, i32 0, i32 12
  %11 = load i32, i32* %status, align 8
  %12 = load %struct.async*, %struct.async** %as, align 8
  %status2 = getelementptr inbounds %struct.async, %struct.async* %12, i32 0, i32 11
  store i32 %11, i32* %status2, align 4
  %13 = load %struct.async*, %struct.async** %as, align 8
  %signr3 = getelementptr inbounds %struct.async, %struct.async* %13, i32 0, i32 4
  %14 = load i32, i32* %signr3, align 8
  store i32 %14, i32* %signr, align 4
  %15 = load i32, i32* %signr, align 4
  %tobool = icmp ne i32 %15, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %16 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.memset.p0i8.i64(i8* %16, i8 0, i64 128, i32 8, i1 false)
  %17 = load %struct.async*, %struct.async** %as, align 8
  %signr4 = getelementptr inbounds %struct.async, %struct.async* %17, i32 0, i32 4
  %18 = load i32, i32* %signr4, align 8
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %18, i32* %si_signo, align 8
  %19 = load %struct.async*, %struct.async** %as, align 8
  %status5 = getelementptr inbounds %struct.async, %struct.async* %19, i32 0, i32 11
  %20 = load i32, i32* %status5, align 4
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 %20, i32* %si_errno, align 4
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8
  %21 = load %struct.async*, %struct.async** %as, align 8
  %userurb = getelementptr inbounds %struct.async, %struct.async* %21, i32 0, i32 7
  %22 = load i8*, i8** %userurb, align 8
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.13* %_sifields to %struct.anon.18*
  %_addr = getelementptr inbounds %struct.anon.18, %struct.anon.18* %_sigfault, i32 0, i32 0
  store i8* %22, i8** %_addr, align 8
  %23 = load %struct.async*, %struct.async** %as, align 8
  %pid6 = getelementptr inbounds %struct.async, %struct.async* %23, i32 0, i32 2
  %24 = load %struct.pid*, %struct.pid** %pid6, align 8
  %call = call %struct.pid* @get_pid(%struct.pid* %24)
  store %struct.pid* %call, %struct.pid** %pid, align 8
  %25 = load %struct.async*, %struct.async** %as, align 8
  %cred7 = getelementptr inbounds %struct.async, %struct.async* %25, i32 0, i32 3
  %26 = load %struct.cred*, %struct.cred** %cred7, align 8
  %call8 = call %struct.cred* @get_cred(%struct.cred* %26)
  store %struct.cred* %call8, %struct.cred** %cred, align 8
  %27 = load %struct.async*, %struct.async** %as, align 8
  %secid9 = getelementptr inbounds %struct.async, %struct.async* %27, i32 0, i32 12
  %28 = load i32, i32* %secid9, align 8
  store i32 %28, i32* %secid, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %29 = load i8, i8* @usbfs_snoop, align 1
  %tobool10 = trunc i8 %29 to i1
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %do.body
  %30 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %30, i32 0, i32 8
  %31 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %31, i32 0, i32 11
  call void (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev12, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.58, i32 0, i32 0))
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end13
  %32 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %dev14 = getelementptr inbounds %struct.urb, %struct.urb* %32, i32 0, i32 8
  %33 = load %struct.usb_device*, %struct.usb_device** %dev14, align 8
  %34 = load %struct.async*, %struct.async** %as, align 8
  %userurb15 = getelementptr inbounds %struct.async, %struct.async* %34, i32 0, i32 7
  %35 = load i8*, i8** %userurb15, align 8
  %36 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %36, i32 0, i32 10
  %37 = load i32, i32* %pipe, align 8
  %38 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %38, i32 0, i32 20
  %39 = load i32, i32* %actual_length, align 4
  %40 = load %struct.async*, %struct.async** %as, align 8
  %status16 = getelementptr inbounds %struct.async, %struct.async* %40, i32 0, i32 11
  %41 = load i32, i32* %status16, align 4
  call void @snoop_urb(%struct.usb_device* %33, i8* %35, i32 %37, i32 %39, i32 %41, i32 1, i8* null, i32 0)
  %42 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %42, i32 0, i32 13
  %43 = load i32, i32* %transfer_flags, align 4
  %and = and i32 %43, 512
  %cmp = icmp eq i32 %and, 512
  br i1 %cmp, label %if.then17, label %if.end19

if.then17:                                        ; preds = %do.end
  %44 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %45 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %actual_length18 = getelementptr inbounds %struct.urb, %struct.urb* %45, i32 0, i32 20
  %46 = load i32, i32* %actual_length18, align 4
  call void @snoop_urb_data(%struct.urb* %44, i32 %46)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %do.end
  %47 = load %struct.async*, %struct.async** %as, align 8
  %status20 = getelementptr inbounds %struct.async, %struct.async* %47, i32 0, i32 11
  %48 = load i32, i32* %status20, align 4
  %cmp21 = icmp slt i32 %48, 0
  br i1 %cmp21, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %if.end19
  %49 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr = getelementptr inbounds %struct.async, %struct.async* %49, i32 0, i32 13
  %50 = load i8, i8* %bulk_addr, align 4
  %conv = zext i8 %50 to i32
  %tobool22 = icmp ne i32 %conv, 0
  br i1 %tobool22, label %land.lhs.true23, label %if.end34

land.lhs.true23:                                  ; preds = %land.lhs.true
  %51 = load %struct.async*, %struct.async** %as, align 8
  %status24 = getelementptr inbounds %struct.async, %struct.async* %51, i32 0, i32 11
  %52 = load i32, i32* %status24, align 4
  %cmp25 = icmp ne i32 %52, -104
  br i1 %cmp25, label %land.lhs.true27, label %if.end34

land.lhs.true27:                                  ; preds = %land.lhs.true23
  %53 = load %struct.async*, %struct.async** %as, align 8
  %status28 = getelementptr inbounds %struct.async, %struct.async* %53, i32 0, i32 11
  %54 = load i32, i32* %status28, align 4
  %cmp29 = icmp ne i32 %54, -2
  br i1 %cmp29, label %if.then31, label %if.end34

if.then31:                                        ; preds = %land.lhs.true27
  %55 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %56 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr32 = getelementptr inbounds %struct.async, %struct.async* %56, i32 0, i32 13
  %57 = load i8, i8* %bulk_addr32, align 4
  %conv33 = zext i8 %57 to i32
  call void @cancel_bulk_urbs(%struct.usb_dev_state* %55, i32 %conv33)
  br label %if.end34

if.end34:                                         ; preds = %if.then31, %land.lhs.true27, %land.lhs.true23, %land.lhs.true, %if.end19
  %58 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock35 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %58, i32 0, i32 3
  store %struct.spinlock* %lock35, %struct.spinlock** %lock.addr.i41, align 8
  %59 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i41, align 8
  %60 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %59, i32 0, i32 0
  %rlock.i42 = bitcast %union.anon* %60 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %rlock.i42) #4
  %61 = load i32, i32* %signr, align 4
  %tobool36 = icmp ne i32 %61, 0
  br i1 %tobool36, label %if.then37, label %if.end40

if.then37:                                        ; preds = %if.end34
  %si_signo38 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  %62 = load i32, i32* %si_signo38, align 8
  %63 = load %struct.pid*, %struct.pid** %pid, align 8
  %64 = load %struct.cred*, %struct.cred** %cred, align 8
  %65 = load i32, i32* %secid, align 4
  %call39 = call i32 @kill_pid_info_as_cred(i32 %62, %struct.siginfo* %sinfo, %struct.pid* %63, %struct.cred* %64, i32 %65)
  %66 = load %struct.pid*, %struct.pid** %pid, align 8
  call void @put_pid(%struct.pid* %66)
  %67 = load %struct.cred*, %struct.cred** %cred, align 8
  call void @put_cred(%struct.cred* %67)
  br label %if.end40

if.end40:                                         ; preds = %if.then37, %if.end34
  %68 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %wait = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %68, i32 0, i32 7
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 1, i8* null)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.pid* @get_pid(%struct.pid* %pid) #0 {
entry:
  %v.addr.i = alloca %struct.atomic_t*, align 8
  %pid.addr = alloca %struct.pid*, align 8
  store %struct.pid* %pid, %struct.pid** %pid.addr, align 8
  %0 = load %struct.pid*, %struct.pid** %pid.addr, align 8
  %tobool = icmp ne %struct.pid* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.pid*, %struct.pid** %pid.addr, align 8
  %count = getelementptr inbounds %struct.pid, %struct.pid* %1, i32 0, i32 0
  store %struct.atomic_t* %count, %struct.atomic_t** %v.addr.i, align 8
  %2 = load %struct.atomic_t*, %struct.atomic_t** %v.addr.i, align 8
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %2, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #4, !srcloc !50
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct.pid*, %struct.pid** %pid.addr, align 8
  ret %struct.pid* %3
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.pid* @task_pid(%struct.task_struct* %task) #0 {
entry:
  %task.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %task, %struct.task_struct** %task.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %task.addr, align 8
  %pids = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 56
  %arrayidx = getelementptr inbounds [3 x %struct.pid_link], [3 x %struct.pid_link]* %pids, i64 0, i64 0
  %pid = getelementptr inbounds %struct.pid_link, %struct.pid_link* %arrayidx, i32 0, i32 1
  %1 = load %struct.pid*, %struct.pid** %pid, align 8
  ret %struct.pid* %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.cred* @get_cred(%struct.cred* %cred) #0 {
entry:
  %cred.addr = alloca %struct.cred*, align 8
  %nonconst_cred = alloca %struct.cred*, align 8
  store %struct.cred* %cred, %struct.cred** %cred.addr, align 8
  %0 = load %struct.cred*, %struct.cred** %cred.addr, align 8
  store %struct.cred* %0, %struct.cred** %nonconst_cred, align 8
  %1 = load %struct.cred*, %struct.cred** %cred.addr, align 8
  call void @validate_creds(%struct.cred* %1)
  %2 = load %struct.cred*, %struct.cred** %nonconst_cred, align 8
  %call = call %struct.cred* @get_new_cred(%struct.cred* %2)
  ret %struct.cred* %call
}

declare void @security_task_getsecid(%struct.task_struct*, i32*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @snoop_urb_data(%struct.urb* %urb, i32 %len) #0 {
entry:
  %urb.addr = alloca %struct.urb*, align 8
  %len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %size = alloca i32, align 4
  %__UNIQUE_ID_min1_28 = alloca i32, align 4
  %__UNIQUE_ID_min2_29 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.urb* %urb, %struct.urb** %urb.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load i32, i32* %len.addr, align 4
  store i32 %0, i32* %__UNIQUE_ID_min1_28, align 4
  %1 = load i32, i32* @usbfs_snoop_max, align 4
  store i32 %1, i32* %__UNIQUE_ID_min2_29, align 4
  %cmp = icmp eq i32* %__UNIQUE_ID_min1_28, %__UNIQUE_ID_min2_29
  %conv = zext i1 %cmp to i32
  %2 = load i32, i32* %__UNIQUE_ID_min1_28, align 4
  %3 = load i32, i32* %__UNIQUE_ID_min2_29, align 4
  %cmp1 = icmp ult i32 %2, %3
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i32, i32* %__UNIQUE_ID_min1_28, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i32, i32* %__UNIQUE_ID_min2_29, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %4, %cond.true ], [ %5, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %6 = load i32, i32* %tmp, align 4
  store i32 %6, i32* %len.addr, align 4
  %7 = load i8, i8* @usbfs_snoop, align 1
  %tobool = trunc i8 %7 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %cond.end
  %8 = load i32, i32* %len.addr, align 4
  %cmp3 = icmp eq i32 %8, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end
  br label %for.end

if.end:                                           ; preds = %lor.lhs.false
  %9 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %9, i32 0, i32 18
  %10 = load i32, i32* %num_sgs, align 4
  %cmp5 = icmp eq i32 %10, 0
  br i1 %cmp5, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %11 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %11, i32 0, i32 14
  %12 = load i8*, i8** %transfer_buffer, align 8
  %13 = load i32, i32* %len.addr, align 4
  %conv8 = zext i32 %13 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.49, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %12, i64 %conv8, i1 zeroext true)
  br label %for.end

if.end9:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %14 = load i32, i32* %i, align 4
  %15 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %num_sgs10 = getelementptr inbounds %struct.urb, %struct.urb* %15, i32 0, i32 18
  %16 = load i32, i32* %num_sgs10, align 4
  %cmp11 = icmp slt i32 %14, %16
  br i1 %cmp11, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %17 = load i32, i32* %len.addr, align 4
  %tobool13 = icmp ne i32 %17, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %18 = phi i1 [ false, %for.cond ], [ %tobool13, %land.rhs ]
  br i1 %18, label %for.body, label %for.end.loopexit

for.body:                                         ; preds = %land.end
  %19 = load i32, i32* %len.addr, align 4
  %cmp14 = icmp ugt i32 %19, 16384
  br i1 %cmp14, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %for.body
  br label %cond.end18

cond.false17:                                     ; preds = %for.body
  %20 = load i32, i32* %len.addr, align 4
  br label %cond.end18

cond.end18:                                       ; preds = %cond.false17, %cond.true16
  %cond19 = phi i32 [ 16384, %cond.true16 ], [ %20, %cond.false17 ]
  store i32 %cond19, i32* %size, align 4
  %21 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %21, i32 0, i32 16
  %22 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8
  %23 = load i32, i32* %i, align 4
  %idxprom = sext i32 %23 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %22, i64 %idxprom
  %call = call i8* @sg_virt(%struct.scatterlist* %arrayidx)
  %24 = load i32, i32* %size, align 4
  %conv20 = sext i32 %24 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.49, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %call, i64 %conv20, i1 zeroext true)
  %25 = load i32, i32* %size, align 4
  %26 = load i32, i32* %len.addr, align 4
  %sub = sub i32 %26, %25
  store i32 %sub, i32* %len.addr, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end18
  %27 = load i32, i32* %i, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end.loopexit:                                 ; preds = %land.end
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %if.then7, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @async_newpending(%struct.async* %as) #0 {
entry:
  %lock.addr.i6 = alloca %struct.spinlock*, align 8
  %flags.addr.i = alloca i64, align 8
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %tmp.i = alloca i32, align 4
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %as.addr = alloca %struct.async*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.async* %as, %struct.async** %as.addr, align 8
  %0 = load %struct.async*, %struct.async** %as.addr, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 1
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8
  store %struct.usb_dev_state* %1, %struct.usb_dev_state** %ps, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body2

do.body2:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %2 = load i32, i32* %tmp, align 4
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %4 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %4, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %5 to %struct.raw_spinlock*
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  store i64 %call3, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body2
  br label %do.end4

do.end4:                                          ; preds = %do.end
  %6 = load %struct.async*, %struct.async** %as.addr, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  %7 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %7, i32 0, i32 4
  call void @list_add_tail(%struct.list_head* %asynclist, %struct.list_head* %async_pending)
  %8 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %8, i32 0, i32 3
  %9 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock5, %struct.spinlock** %lock.addr.i6, align 8
  store i64 %9, i64* %flags.addr.i, align 8
  store i32 1, i32* %tmp.i, align 4
  %10 = load i32, i32* %tmp.i, align 4
  %11 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i6, align 8
  %12 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %11, i32 0, i32 0
  %rlock.i7 = bitcast %union.anon* %12 to %struct.raw_spinlock*
  %13 = load i64, i64* %flags.addr.i, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i7, i64 %13) #4
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %1 = load i8, i8* %bmAttributes, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 2
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 2
  %1 = load i8, i8* %bEndpointAddress, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

declare i32 @usb_submit_urb(%struct.urb*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @async_removepending(%struct.async* %as) #0 {
entry:
  %lock.addr.i6 = alloca %struct.spinlock*, align 8
  %flags.addr.i = alloca i64, align 8
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %tmp.i = alloca i32, align 4
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %as.addr = alloca %struct.async*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.async* %as, %struct.async** %as.addr, align 8
  %0 = load %struct.async*, %struct.async** %as.addr, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 1
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps1, align 8
  store %struct.usb_dev_state* %1, %struct.usb_dev_state** %ps, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body2

do.body2:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %2 = load i32, i32* %tmp, align 4
  %3 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %3, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %4 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %5 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %4, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %5 to %struct.raw_spinlock*
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  store i64 %call3, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body2
  br label %do.end4

do.end4:                                          ; preds = %do.end
  %6 = load %struct.async*, %struct.async** %as.addr, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  %7 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %7, i32 0, i32 3
  %8 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock5, %struct.spinlock** %lock.addr.i6, align 8
  store i64 %8, i64* %flags.addr.i, align 8
  store i32 1, i32* %tmp.i, align 4
  %9 = load i32, i32* %tmp.i, align 4
  %10 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i6, align 8
  %11 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %10, i32 0, i32 0
  %rlock.i7 = bitcast %union.anon* %11 to %struct.raw_spinlock*
  %12 = load i64, i64* %flags.addr.i, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i7, i64 %12) #4
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #0 {
entry:
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %or = or i32 %1, 32768
  store i64 %0, i64* %size.addr.i, align 8
  store i32 %or, i32* %flags.addr.i, align 4
  %2 = load i64, i64* %size.addr.i, align 8
  %3 = load i32, i32* %flags.addr.i, align 4
  %call.i = call noalias i8* @__kmalloc(i64 %2, i32 %3) #4
  ret i8* %call.i
}

declare %struct.urb* @usb_alloc_urb(i32, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @ERR_PTR(i64 %error) #0 {
entry:
  %error.addr = alloca i64, align 8
  store i64 %error, i64* %error.addr, align 8
  %0 = load i64, i64* %error.addr, align 8
  %1 = inttoptr i64 %0 to i8*
  ret i8* %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %page, i32 %len, i32 %offset) #0 {
entry:
  %sg.addr = alloca %struct.scatterlist*, align 8
  %page.addr = alloca %struct.page*, align 8
  %len.addr = alloca i32, align 4
  %offset.addr = alloca i32, align 4
  store %struct.scatterlist* %sg, %struct.scatterlist** %sg.addr, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  store i32 %offset, i32* %offset.addr, align 4
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %1 = load %struct.page*, %struct.page** %page.addr, align 8
  call void @sg_assign_page(%struct.scatterlist* %0, %struct.page* %1)
  %2 = load i32, i32* %offset.addr, align 4
  %3 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %offset1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %3, i32 0, i32 1
  store i32 %2, i32* %offset1, align 8
  %4 = load i32, i32* %len.addr, align 4
  %5 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %length = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %5, i32 0, i32 2
  store i32 %4, i32* %length, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @__phys_addr_nodebug(i64 %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  %y = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8
  %0 = load i64, i64* %x.addr, align 8
  %sub = sub i64 %0, -2147483648
  store i64 %sub, i64* %y, align 8
  %1 = load i64, i64* %y, align 8
  %2 = load i64, i64* %x.addr, align 8
  %3 = load i64, i64* %y, align 8
  %cmp = icmp ugt i64 %2, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64, i64* @phys_base, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %4, %cond.true ], [ 131939247849472, %cond.false ]
  %add = add i64 %1, %cond
  store i64 %add, i64* %x.addr, align 8
  %5 = load i64, i64* %x.addr, align 8
  ret i64 %5
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page) #0 {
entry:
  %sg.addr = alloca %struct.scatterlist*, align 8
  %page.addr = alloca %struct.page*, align 8
  %page_link = alloca i64, align 8
  store %struct.scatterlist* %sg, %struct.scatterlist** %sg.addr, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %page_link1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %0, i32 0, i32 0
  %1 = load i64, i64* %page_link1, align 8
  %and = and i64 %1, 3
  store i64 %and, i64* %page_link, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %2 = load %struct.page*, %struct.page** %page.addr, align 8
  %3 = ptrtoint %struct.page* %2 to i64
  %and2 = and i64 %3, 3
  %tobool = icmp ne i64 %and2, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool4 = icmp ne i64 %conv, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body5

do.body5:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.57, i32 0, i32 0), i32 90, i64 12) #4, !srcloc !51
  br label %do.body6

do.body6:                                         ; preds = %do.cond, %do.body5
  br label %do.cond

do.cond:                                          ; preds = %do.body6
  br i1 true, label %do.body6, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end8

do.end8:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end8, %do.body
  br label %do.end10

do.end10:                                         ; preds = %if.end
  %4 = load i64, i64* %page_link, align 8
  %5 = load %struct.page*, %struct.page** %page.addr, align 8
  %6 = ptrtoint %struct.page* %5 to i64
  %or = or i64 %4, %6
  %7 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %page_link11 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %7, i32 0, i32 0
  store i64 %or, i64* %page_link11, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @cancel_bulk_urbs(%struct.usb_dev_state* %ps, i32 %bulk_addr) #0 {
entry:
  %lock.addr.i45 = alloca %struct.spinlock*, align 8
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %bulk_addr.addr = alloca i32, align 4
  %urb = alloca %struct.urb*, align 8
  %as = alloca %struct.async*, align 8
  %__mptr = alloca %struct.list_head*, align 8
  %tmp = alloca %struct.async*, align 8
  %__mptr12 = alloca %struct.list_head*, align 8
  %tmp15 = alloca %struct.async*, align 8
  %__mptr17 = alloca %struct.list_head*, align 8
  %tmp20 = alloca %struct.async*, align 8
  %__mptr39 = alloca %struct.list_head*, align 8
  %tmp42 = alloca %struct.async*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i32 %bulk_addr, i32* %bulk_addr.addr, align 4
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %1, %struct.list_head** %__mptr, align 8
  %2 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.async*
  store %struct.async* %4, %struct.async** %tmp, align 8
  %5 = load %struct.async*, %struct.async** %tmp, align 8
  store %struct.async* %5, %struct.async** %as, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load %struct.async*, %struct.async** %as, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  %7 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_pending1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %7, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr2 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 13
  %9 = load i8, i8* %bulk_addr2, align 4
  %conv = zext i8 %9 to i32
  %10 = load i32, i32* %bulk_addr.addr, align 4
  %cmp3 = icmp eq i32 %conv, %10
  br i1 %cmp3, label %if.then, label %if.end11

if.then:                                          ; preds = %for.body
  %11 = load %struct.async*, %struct.async** %as, align 8
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 14
  %12 = load i8, i8* %bulk_status, align 1
  %conv5 = zext i8 %12 to i32
  %cmp6 = icmp ne i32 %conv5, 1
  br i1 %cmp6, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  br label %rescan.preheader

if.end:                                           ; preds = %if.then
  %13 = load %struct.async*, %struct.async** %as, align 8
  %bulk_status9 = getelementptr inbounds %struct.async, %struct.async* %13, i32 0, i32 14
  store i8 2, i8* %bulk_status9, align 1
  %14 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr10 = getelementptr inbounds %struct.async, %struct.async* %14, i32 0, i32 13
  store i8 0, i8* %bulk_addr10, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end11
  %15 = load %struct.async*, %struct.async** %as, align 8
  %asynclist13 = getelementptr inbounds %struct.async, %struct.async* %15, i32 0, i32 0
  %next14 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist13, i32 0, i32 0
  %16 = load %struct.list_head*, %struct.list_head** %next14, align 8
  store %struct.list_head* %16, %struct.list_head** %__mptr12, align 8
  %17 = load %struct.list_head*, %struct.list_head** %__mptr12, align 8
  %18 = bitcast %struct.list_head* %17 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %18, i64 0
  %19 = bitcast i8* %add.ptr16 to %struct.async*
  store %struct.async* %19, %struct.async** %tmp15, align 8
  %20 = load %struct.async*, %struct.async** %tmp15, align 8
  store %struct.async* %20, %struct.async** %as, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %21 = load i32, i32* %bulk_addr.addr, align 4
  %shl = shl i32 1, %21
  %22 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %disabled_bulk_eps = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %22, i32 0, i32 14
  %23 = load i32, i32* %disabled_bulk_eps, align 4
  %or = or i32 %23, %shl
  store i32 %or, i32* %disabled_bulk_eps, align 4
  br label %rescan.preheader

rescan.preheader:                                 ; preds = %if.then8, %for.end
  br label %rescan

rescan:                                           ; preds = %rescan.preheader, %if.then32
  %24 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_pending18 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %24, i32 0, i32 4
  %next19 = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending18, i32 0, i32 0
  %25 = load %struct.list_head*, %struct.list_head** %next19, align 8
  store %struct.list_head* %25, %struct.list_head** %__mptr17, align 8
  %26 = load %struct.list_head*, %struct.list_head** %__mptr17, align 8
  %27 = bitcast %struct.list_head* %26 to i8*
  %add.ptr21 = getelementptr inbounds i8, i8* %27, i64 0
  %28 = bitcast i8* %add.ptr21 to %struct.async*
  store %struct.async* %28, %struct.async** %tmp20, align 8
  %29 = load %struct.async*, %struct.async** %tmp20, align 8
  store %struct.async* %29, %struct.async** %as, align 8
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc38, %rescan
  %30 = load %struct.async*, %struct.async** %as, align 8
  %asynclist23 = getelementptr inbounds %struct.async, %struct.async* %30, i32 0, i32 0
  %31 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_pending24 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %31, i32 0, i32 4
  %cmp25 = icmp ne %struct.list_head* %asynclist23, %async_pending24
  br i1 %cmp25, label %for.body27, label %for.end44

for.body27:                                       ; preds = %for.cond22
  %32 = load %struct.async*, %struct.async** %as, align 8
  %bulk_status28 = getelementptr inbounds %struct.async, %struct.async* %32, i32 0, i32 14
  %33 = load i8, i8* %bulk_status28, align 1
  %conv29 = zext i8 %33 to i32
  %cmp30 = icmp eq i32 %conv29, 2
  br i1 %cmp30, label %if.then32, label %if.end37

if.then32:                                        ; preds = %for.body27
  %34 = load %struct.async*, %struct.async** %as, align 8
  %bulk_status33 = getelementptr inbounds %struct.async, %struct.async* %34, i32 0, i32 14
  store i8 0, i8* %bulk_status33, align 1
  %35 = load %struct.async*, %struct.async** %as, align 8
  %urb34 = getelementptr inbounds %struct.async, %struct.async* %35, i32 0, i32 8
  %36 = load %struct.urb*, %struct.urb** %urb34, align 8
  store %struct.urb* %36, %struct.urb** %urb, align 8
  %37 = load %struct.urb*, %struct.urb** %urb, align 8
  %call = call %struct.urb* @usb_get_urb(%struct.urb* %37)
  %38 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %38, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %39 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %40 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %39, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %40 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %rlock.i) #4
  %41 = load %struct.urb*, %struct.urb** %urb, align 8
  %call35 = call i32 @usb_unlink_urb(%struct.urb* %41)
  %42 = load %struct.urb*, %struct.urb** %urb, align 8
  call void @usb_free_urb(%struct.urb* %42)
  %43 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %lock36 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %43, i32 0, i32 3
  store %struct.spinlock* %lock36, %struct.spinlock** %lock.addr.i45, align 8
  %44 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i45, align 8
  %45 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %44, i32 0, i32 0
  %rlock.i46 = bitcast %union.anon* %45 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock.i46) #4
  br label %rescan

if.end37:                                         ; preds = %for.body27
  br label %for.inc38

for.inc38:                                        ; preds = %if.end37
  %46 = load %struct.async*, %struct.async** %as, align 8
  %asynclist40 = getelementptr inbounds %struct.async, %struct.async* %46, i32 0, i32 0
  %next41 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist40, i32 0, i32 0
  %47 = load %struct.list_head*, %struct.list_head** %next41, align 8
  store %struct.list_head* %47, %struct.list_head** %__mptr39, align 8
  %48 = load %struct.list_head*, %struct.list_head** %__mptr39, align 8
  %49 = bitcast %struct.list_head* %48 to i8*
  %add.ptr43 = getelementptr inbounds i8, i8* %49, i64 0
  %50 = bitcast i8* %add.ptr43 to %struct.async*
  store %struct.async* %50, %struct.async** %tmp42, align 8
  %51 = load %struct.async*, %struct.async** %tmp42, align 8
  store %struct.async* %51, %struct.async** %as, align 8
  br label %for.cond22

for.end44:                                        ; preds = %for.cond22
  ret void
}

declare i32 @kill_pid_info_as_cred(i32, %struct.siginfo*, %struct.pid*, %struct.cred*, i32) #1

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

declare void @_raw_spin_lock(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare i32 @usb_unlink_urb(%struct.urb*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @__raw_spin_unlock(%struct.raw_spinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.raw_spinlock*, align 8
  store %struct.raw_spinlock* %lock, %struct.raw_spinlock** %lock.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.raw_spinlock*, %struct.raw_spinlock** %lock.addr, align 8
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %0)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !52
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @do_raw_spin_unlock(%struct.raw_spinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.raw_spinlock*, align 8
  store %struct.raw_spinlock* %lock, %struct.raw_spinlock** %lock.addr, align 8
  %0 = load %struct.raw_spinlock*, %struct.raw_spinlock** %lock.addr, align 8
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %0, i32 0, i32 0
  call void @queued_spin_unlock(%struct.qspinlock* %raw_lock)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @queued_spin_unlock(%struct.qspinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.qspinlock*, align 8
  store %struct.qspinlock* %lock, %struct.qspinlock** %lock.addr, align 8
  %0 = load %struct.qspinlock*, %struct.qspinlock** %lock.addr, align 8
  call void @native_queued_spin_unlock(%struct.qspinlock* %0)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @native_queued_spin_unlock(%struct.qspinlock* %lock) #0 {
entry:
  %p.addr.i = alloca i8*, align 8
  %res.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %lock.addr = alloca %struct.qspinlock*, align 8
  %__cond = alloca i8, align 1
  %__u = alloca %union.anon.64, align 1
  %tmp = alloca i8, align 1
  store %struct.qspinlock* %lock, %struct.qspinlock** %lock.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  store i8 0, i8* %__cond, align 1
  %0 = load i8, i8* %__cond, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body1
  call void @__compiletime_assert_17()
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body1
  br label %do.body2

do.body2:                                         ; preds = %if.end
  %1 = load i8, i8* %__cond, align 1
  %tobool3 = trunc i8 %1 to i1
  %conv = zext i1 %tobool3 to i32
  %mul = mul nsw i32 2, %conv
  %sub = sub nsw i32 1, %mul
  %2 = zext i32 %sub to i64
  br label %do.end

do.end:                                           ; preds = %do.body2
  br label %do.end4

do.end4:                                          ; preds = %do.end
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !53
  %3 = bitcast %union.anon.64* %__u to i8*
  call void @llvm.memset.p0i8.i64(i8* %3, i8 0, i64 1, i32 1, i1 false)
  %4 = load %struct.qspinlock*, %struct.qspinlock** %lock.addr, align 8
  %5 = bitcast %struct.qspinlock* %4 to i8*
  %__c = bitcast %union.anon.64* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  store i8* %5, i8** %p.addr.i, align 8
  store i8* %arraydecay, i8** %res.addr.i, align 8
  store i32 1, i32* %size.addr.i, align 4
  %6 = load i32, i32* %size.addr.i, align 4
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %do.end4
  %Pivot10 = icmp slt i32 %6, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %6, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %6, 8
  br i1 %SwitchLeaf6, label %sw.bb3.i, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %6, 4
  br i1 %SwitchLeaf4, label %sw.bb2.i, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %6, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %6, 2
  br i1 %SwitchLeaf2, label %sw.bb1.i, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %6, 1
  br i1 %SwitchLeaf, label %sw.bb.i, label %NewDefault

sw.bb.i:                                          ; preds = %LeafBlock
  %7 = load i8*, i8** %res.addr.i, align 8
  %8 = load i8, i8* %7, align 1
  %9 = load i8*, i8** %p.addr.i, align 8
  store volatile i8 %8, i8* %9, align 1
  br label %__write_once_size.exit

sw.bb1.i:                                         ; preds = %LeafBlock1
  %10 = load i8*, i8** %res.addr.i, align 8
  %11 = bitcast i8* %10 to i16*
  %12 = load i16, i16* %11, align 2
  %13 = load i8*, i8** %p.addr.i, align 8
  %14 = bitcast i8* %13 to i16*
  store volatile i16 %12, i16* %14, align 2
  br label %__write_once_size.exit

sw.bb2.i:                                         ; preds = %LeafBlock3
  %15 = load i8*, i8** %res.addr.i, align 8
  %16 = bitcast i8* %15 to i32*
  %17 = load i32, i32* %16, align 4
  %18 = load i8*, i8** %p.addr.i, align 8
  %19 = bitcast i8* %18 to i32*
  store volatile i32 %17, i32* %19, align 4
  br label %__write_once_size.exit

sw.bb3.i:                                         ; preds = %LeafBlock5
  %20 = load i8*, i8** %res.addr.i, align 8
  %21 = bitcast i8* %20 to i64*
  %22 = load i64, i64* %21, align 8
  %23 = load i8*, i8** %p.addr.i, align 8
  %24 = bitcast i8* %23 to i64*
  store volatile i64 %22, i64* %24, align 8
  br label %__write_once_size.exit

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default.i

sw.default.i:                                     ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !6
  %25 = load i8*, i8** %p.addr.i, align 8
  %26 = load i8*, i8** %res.addr.i, align 8
  %27 = load i32, i32* %size.addr.i, align 4
  %conv.i = sext i32 %27 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %25, i8* %26, i64 %conv.i, i32 1, i1 false) #4
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !7
  br label %__write_once_size.exit

__write_once_size.exit:                           ; preds = %sw.default.i, %sw.bb3.i, %sw.bb2.i, %sw.bb1.i, %sw.bb.i
  %__val = bitcast %union.anon.64* %__u to i8*
  %28 = load i8, i8* %__val, align 1
  store i8 %28, i8* %tmp, align 1
  %29 = load i8, i8* %tmp, align 1
  br label %do.end5

do.end5:                                          ; preds = %__write_once_size.exit
  ret void
}

declare void @__compiletime_assert_17() #1

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.cred* @get_new_cred(%struct.cred* %cred) #0 {
entry:
  %v.addr.i = alloca %struct.atomic_t*, align 8
  %cred.addr = alloca %struct.cred*, align 8
  store %struct.cred* %cred, %struct.cred** %cred.addr, align 8
  %0 = load %struct.cred*, %struct.cred** %cred.addr, align 8
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %0, i32 0, i32 0
  store %struct.atomic_t* %usage, %struct.atomic_t** %v.addr.i, align 8
  %1 = load %struct.atomic_t*, %struct.atomic_t** %v.addr.i, align 8
  %counter.i = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %1, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter.i, i32* %counter.i) #4, !srcloc !50
  %2 = load %struct.cred*, %struct.cred** %cred.addr, align 8
  ret %struct.cred* %2
}

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: noinline nounwind optnone uwtable
define internal void @__raw_spin_unlock_irq(%struct.raw_spinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.raw_spinlock*, align 8
  store %struct.raw_spinlock* %lock, %struct.raw_spinlock** %lock.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.raw_spinlock*, %struct.raw_spinlock** %lock.addr, align 8
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %0)
  br label %do.body1

do.body1:                                         ; preds = %do.end
  call void @arch_local_irq_enable()
  br label %do.end2

do.end2:                                          ; preds = %do.body1
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !54
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @arch_local_irq_enable() #0 {
entry:
  call void @native_irq_enable()
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @native_irq_enable() #0 {
entry:
  call void asm sideeffect "sti", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !55
  ret void
}

declare i8* @compat_alloc_user_space(i64) #1

declare i64 @copy_in_user(i8*, i8*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @compat_ptr(i32 %uptr) #0 {
entry:
  %uptr.addr = alloca i32, align 4
  store i32 %uptr, i32* %uptr.addr, align 4
  %0 = load i32, i32* %uptr.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = inttoptr i64 %conv to i8*
  ret i8* %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @get_urb32(%struct.usbdevfs_urb* %kurb, %struct.usbdevfs_urb32* %uurb) #0 {
entry:
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %kurb.addr = alloca %struct.usbdevfs_urb*, align 8
  %uurb.addr = alloca %struct.usbdevfs_urb32*, align 8
  %uptr = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp1 = alloca i8, align 1
  %__gu_err = alloca i32, align 4
  %__gu_val = alloca i64, align 8
  %tmp9 = alloca i64, align 8
  %__gu_err13 = alloca i32, align 4
  %__gu_val14 = alloca i64, align 8
  %tmp21 = alloca i64, align 8
  %__gu_err25 = alloca i32, align 4
  %__gu_val26 = alloca i64, align 8
  %tmp33 = alloca i64, align 8
  %__gu_err37 = alloca i32, align 4
  %__gu_val38 = alloca i64, align 8
  %tmp45 = alloca i64, align 8
  %__gu_err49 = alloca i32, align 4
  %__gu_val50 = alloca i64, align 8
  %tmp57 = alloca i64, align 8
  %__gu_err61 = alloca i32, align 4
  %__gu_val62 = alloca i64, align 8
  %tmp69 = alloca i64, align 8
  %__gu_err73 = alloca i32, align 4
  %__gu_val74 = alloca i64, align 8
  %tmp81 = alloca i64, align 8
  %__gu_err85 = alloca i32, align 4
  %__gu_val86 = alloca i64, align 8
  %tmp93 = alloca i64, align 8
  %__gu_err97 = alloca i32, align 4
  %__gu_val98 = alloca i64, align 8
  %tmp105 = alloca i64, align 8
  %__gu_err109 = alloca i32, align 4
  %__gu_val110 = alloca i64, align 8
  %tmp117 = alloca i64, align 8
  %__gu_err120 = alloca i32, align 4
  %__gu_val121 = alloca i64, align 8
  %tmp127 = alloca i64, align 8
  %__gu_err134 = alloca i32, align 4
  %__gu_val135 = alloca i64, align 8
  %tmp141 = alloca i64, align 8
  store %struct.usbdevfs_urb* %kurb, %struct.usbdevfs_urb** %kurb.addr, align 8
  store %struct.usbdevfs_urb32* %uurb, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %0 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %1 = ptrtoint %struct.usbdevfs_urb32* %0 to i64
  %2 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !3
  store %struct.task_struct* %2, %struct.task_struct** %pfo_ret__.i, align 8
  %3 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %3, %struct.task_struct** %tmp.i, align 8
  %4 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %thread = getelementptr inbounds %struct.task_struct, %struct.task_struct* %4, i32 0, i32 151
  %addr_limit = getelementptr inbounds %struct.thread_struct, %struct.thread_struct* %thread, i32 0, i32 19
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %5 = load i64, i64* %seg, align 8
  %call2 = call zeroext i1 @__chk_range_not_ok(i64 %1, i64 44, i64 %5)
  %frombool = zext i1 %call2 to i8
  store i8 %frombool, i8* %tmp1, align 1
  %6 = load i8, i8* %tmp1, align 1
  %tobool = trunc i8 %6 to i1
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  store i64 %conv, i64* %tmp, align 8
  %7 = load i64, i64* %tmp, align 8
  %tobool5 = icmp ne i64 %7, 0
  br i1 %tobool5, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body

do.body:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %__gu_err, align 4
  %8 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %type = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %8, i32 0, i32 0
  %9 = bitcast i8* %type to %struct.__large_struct*
  %10 = load i32, i32* %__gu_err, align 4
  %11 = call { i32, i64 } asm sideeffect "\0A1:\09movb $2,${1:b}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %9, i32 -14, i32 %10) #4, !srcloc !56
  %asmresult = extractvalue { i32, i64 } %11, 0
  %asmresult6 = extractvalue { i32, i64 } %11, 1
  store i32 %asmresult, i32* %__gu_err, align 4
  store i64 %asmresult6, i64* %__gu_val, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %12 = load i64, i64* %__gu_val, align 8
  %conv7 = trunc i64 %12 to i8
  %13 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %type8 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %13, i32 0, i32 0
  store i8 %conv7, i8* %type8, align 8
  %14 = load i32, i32* %__gu_err, align 4
  %conv10 = sext i32 %14 to i64
  store i64 %conv10, i64* %tmp9, align 8
  %15 = load i64, i64* %tmp9, align 8
  %tobool11 = icmp ne i64 %15, 0
  br i1 %tobool11, label %if.then, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %do.end
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body15

do.body15:                                        ; preds = %lor.lhs.false12
  store i32 0, i32* %__gu_err13, align 4
  %16 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %16, i32 0, i32 1
  %17 = bitcast i8* %endpoint to %struct.__large_struct*
  %18 = load i32, i32* %__gu_err13, align 4
  %19 = call { i32, i64 } asm sideeffect "\0A1:\09movb $2,${1:b}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %17, i32 -14, i32 %18) #4, !srcloc !57
  %asmresult16 = extractvalue { i32, i64 } %19, 0
  %asmresult17 = extractvalue { i32, i64 } %19, 1
  store i32 %asmresult16, i32* %__gu_err13, align 4
  store i64 %asmresult17, i64* %__gu_val14, align 8
  br label %do.end18

do.end18:                                         ; preds = %do.body15
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %20 = load i64, i64* %__gu_val14, align 8
  %conv19 = trunc i64 %20 to i8
  %21 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %endpoint20 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %21, i32 0, i32 1
  store i8 %conv19, i8* %endpoint20, align 1
  %22 = load i32, i32* %__gu_err13, align 4
  %conv22 = sext i32 %22 to i64
  store i64 %conv22, i64* %tmp21, align 8
  %23 = load i64, i64* %tmp21, align 8
  %tobool23 = icmp ne i64 %23, 0
  br i1 %tobool23, label %if.then, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %do.end18
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body27

do.body27:                                        ; preds = %lor.lhs.false24
  store i32 0, i32* %__gu_err25, align 4
  %24 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %status = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %24, i32 0, i32 2
  %25 = bitcast i32* %status to %struct.__large_struct*
  %26 = load i32, i32* %__gu_err25, align 4
  %27 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %25, i32 -14, i32 %26) #4, !srcloc !58
  %asmresult28 = extractvalue { i32, i64 } %27, 0
  %asmresult29 = extractvalue { i32, i64 } %27, 1
  store i32 %asmresult28, i32* %__gu_err25, align 4
  store i64 %asmresult29, i64* %__gu_val26, align 8
  br label %do.end30

do.end30:                                         ; preds = %do.body27
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %28 = load i64, i64* %__gu_val26, align 8
  %conv31 = trunc i64 %28 to i32
  %29 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %status32 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %29, i32 0, i32 2
  store i32 %conv31, i32* %status32, align 4
  %30 = load i32, i32* %__gu_err25, align 4
  %conv34 = sext i32 %30 to i64
  store i64 %conv34, i64* %tmp33, align 8
  %31 = load i64, i64* %tmp33, align 8
  %tobool35 = icmp ne i64 %31, 0
  br i1 %tobool35, label %if.then, label %lor.lhs.false36

lor.lhs.false36:                                  ; preds = %do.end30
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body39

do.body39:                                        ; preds = %lor.lhs.false36
  store i32 0, i32* %__gu_err37, align 4
  %32 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %flags = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %32, i32 0, i32 3
  %33 = bitcast i32* %flags to %struct.__large_struct*
  %34 = load i32, i32* %__gu_err37, align 4
  %35 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %33, i32 -14, i32 %34) #4, !srcloc !59
  %asmresult40 = extractvalue { i32, i64 } %35, 0
  %asmresult41 = extractvalue { i32, i64 } %35, 1
  store i32 %asmresult40, i32* %__gu_err37, align 4
  store i64 %asmresult41, i64* %__gu_val38, align 8
  br label %do.end42

do.end42:                                         ; preds = %do.body39
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %36 = load i64, i64* %__gu_val38, align 8
  %conv43 = trunc i64 %36 to i32
  %37 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %flags44 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %37, i32 0, i32 3
  store i32 %conv43, i32* %flags44, align 8
  %38 = load i32, i32* %__gu_err37, align 4
  %conv46 = sext i32 %38 to i64
  store i64 %conv46, i64* %tmp45, align 8
  %39 = load i64, i64* %tmp45, align 8
  %tobool47 = icmp ne i64 %39, 0
  br i1 %tobool47, label %if.then, label %lor.lhs.false48

lor.lhs.false48:                                  ; preds = %do.end42
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body51

do.body51:                                        ; preds = %lor.lhs.false48
  store i32 0, i32* %__gu_err49, align 4
  %40 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %40, i32 0, i32 5
  %41 = bitcast i32* %buffer_length to %struct.__large_struct*
  %42 = load i32, i32* %__gu_err49, align 4
  %43 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %41, i32 -14, i32 %42) #4, !srcloc !60
  %asmresult52 = extractvalue { i32, i64 } %43, 0
  %asmresult53 = extractvalue { i32, i64 } %43, 1
  store i32 %asmresult52, i32* %__gu_err49, align 4
  store i64 %asmresult53, i64* %__gu_val50, align 8
  br label %do.end54

do.end54:                                         ; preds = %do.body51
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %44 = load i64, i64* %__gu_val50, align 8
  %conv55 = trunc i64 %44 to i32
  %45 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %buffer_length56 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %45, i32 0, i32 5
  store i32 %conv55, i32* %buffer_length56, align 8
  %46 = load i32, i32* %__gu_err49, align 4
  %conv58 = sext i32 %46 to i64
  store i64 %conv58, i64* %tmp57, align 8
  %47 = load i64, i64* %tmp57, align 8
  %tobool59 = icmp ne i64 %47, 0
  br i1 %tobool59, label %if.then, label %lor.lhs.false60

lor.lhs.false60:                                  ; preds = %do.end54
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body63

do.body63:                                        ; preds = %lor.lhs.false60
  store i32 0, i32* %__gu_err61, align 4
  %48 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %actual_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %48, i32 0, i32 6
  %49 = bitcast i32* %actual_length to %struct.__large_struct*
  %50 = load i32, i32* %__gu_err61, align 4
  %51 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %49, i32 -14, i32 %50) #4, !srcloc !61
  %asmresult64 = extractvalue { i32, i64 } %51, 0
  %asmresult65 = extractvalue { i32, i64 } %51, 1
  store i32 %asmresult64, i32* %__gu_err61, align 4
  store i64 %asmresult65, i64* %__gu_val62, align 8
  br label %do.end66

do.end66:                                         ; preds = %do.body63
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %52 = load i64, i64* %__gu_val62, align 8
  %conv67 = trunc i64 %52 to i32
  %53 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %actual_length68 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %53, i32 0, i32 6
  store i32 %conv67, i32* %actual_length68, align 4
  %54 = load i32, i32* %__gu_err61, align 4
  %conv70 = sext i32 %54 to i64
  store i64 %conv70, i64* %tmp69, align 8
  %55 = load i64, i64* %tmp69, align 8
  %tobool71 = icmp ne i64 %55, 0
  br i1 %tobool71, label %if.then, label %lor.lhs.false72

lor.lhs.false72:                                  ; preds = %do.end66
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body75

do.body75:                                        ; preds = %lor.lhs.false72
  store i32 0, i32* %__gu_err73, align 4
  %56 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %56, i32 0, i32 7
  %57 = bitcast i32* %start_frame to %struct.__large_struct*
  %58 = load i32, i32* %__gu_err73, align 4
  %59 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %57, i32 -14, i32 %58) #4, !srcloc !62
  %asmresult76 = extractvalue { i32, i64 } %59, 0
  %asmresult77 = extractvalue { i32, i64 } %59, 1
  store i32 %asmresult76, i32* %__gu_err73, align 4
  store i64 %asmresult77, i64* %__gu_val74, align 8
  br label %do.end78

do.end78:                                         ; preds = %do.body75
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %60 = load i64, i64* %__gu_val74, align 8
  %conv79 = trunc i64 %60 to i32
  %61 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %start_frame80 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %61, i32 0, i32 7
  store i32 %conv79, i32* %start_frame80, align 8
  %62 = load i32, i32* %__gu_err73, align 4
  %conv82 = sext i32 %62 to i64
  store i64 %conv82, i64* %tmp81, align 8
  %63 = load i64, i64* %tmp81, align 8
  %tobool83 = icmp ne i64 %63, 0
  br i1 %tobool83, label %if.then, label %lor.lhs.false84

lor.lhs.false84:                                  ; preds = %do.end78
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body87

do.body87:                                        ; preds = %lor.lhs.false84
  store i32 0, i32* %__gu_err85, align 4
  %64 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %number_of_packets = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %64, i32 0, i32 8
  %65 = bitcast i32* %number_of_packets to %struct.__large_struct*
  %66 = load i32, i32* %__gu_err85, align 4
  %67 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %65, i32 -14, i32 %66) #4, !srcloc !63
  %asmresult88 = extractvalue { i32, i64 } %67, 0
  %asmresult89 = extractvalue { i32, i64 } %67, 1
  store i32 %asmresult88, i32* %__gu_err85, align 4
  store i64 %asmresult89, i64* %__gu_val86, align 8
  br label %do.end90

do.end90:                                         ; preds = %do.body87
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %68 = load i64, i64* %__gu_val86, align 8
  %conv91 = trunc i64 %68 to i32
  %69 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %70 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %69, i32 0, i32 8
  %number_of_packets92 = bitcast %union.anon.62* %70 to i32*
  store i32 %conv91, i32* %number_of_packets92, align 4
  %71 = load i32, i32* %__gu_err85, align 4
  %conv94 = sext i32 %71 to i64
  store i64 %conv94, i64* %tmp93, align 8
  %72 = load i64, i64* %tmp93, align 8
  %tobool95 = icmp ne i64 %72, 0
  br i1 %tobool95, label %if.then, label %lor.lhs.false96

lor.lhs.false96:                                  ; preds = %do.end90
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body99

do.body99:                                        ; preds = %lor.lhs.false96
  store i32 0, i32* %__gu_err97, align 4
  %73 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %error_count = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %73, i32 0, i32 9
  %74 = bitcast i32* %error_count to %struct.__large_struct*
  %75 = load i32, i32* %__gu_err97, align 4
  %76 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %74, i32 -14, i32 %75) #4, !srcloc !64
  %asmresult100 = extractvalue { i32, i64 } %76, 0
  %asmresult101 = extractvalue { i32, i64 } %76, 1
  store i32 %asmresult100, i32* %__gu_err97, align 4
  store i64 %asmresult101, i64* %__gu_val98, align 8
  br label %do.end102

do.end102:                                        ; preds = %do.body99
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %77 = load i64, i64* %__gu_val98, align 8
  %conv103 = trunc i64 %77 to i32
  %78 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %error_count104 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %78, i32 0, i32 9
  store i32 %conv103, i32* %error_count104, align 8
  %79 = load i32, i32* %__gu_err97, align 4
  %conv106 = sext i32 %79 to i64
  store i64 %conv106, i64* %tmp105, align 8
  %80 = load i64, i64* %tmp105, align 8
  %tobool107 = icmp ne i64 %80, 0
  br i1 %tobool107, label %if.then, label %lor.lhs.false108

lor.lhs.false108:                                 ; preds = %do.end102
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body111

do.body111:                                       ; preds = %lor.lhs.false108
  store i32 0, i32* %__gu_err109, align 4
  %81 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %signr = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %81, i32 0, i32 10
  %82 = bitcast i32* %signr to %struct.__large_struct*
  %83 = load i32, i32* %__gu_err109, align 4
  %84 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %82, i32 -14, i32 %83) #4, !srcloc !65
  %asmresult112 = extractvalue { i32, i64 } %84, 0
  %asmresult113 = extractvalue { i32, i64 } %84, 1
  store i32 %asmresult112, i32* %__gu_err109, align 4
  store i64 %asmresult113, i64* %__gu_val110, align 8
  br label %do.end114

do.end114:                                        ; preds = %do.body111
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %85 = load i64, i64* %__gu_val110, align 8
  %conv115 = trunc i64 %85 to i32
  %86 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %signr116 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %86, i32 0, i32 10
  store i32 %conv115, i32* %signr116, align 4
  %87 = load i32, i32* %__gu_err109, align 4
  %conv118 = sext i32 %87 to i64
  store i64 %conv118, i64* %tmp117, align 8
  %88 = load i64, i64* %tmp117, align 8
  %tobool119 = icmp ne i64 %88, 0
  br i1 %tobool119, label %if.then, label %if.end

if.then:                                          ; preds = %do.end114, %do.end102, %do.end90, %do.end78, %do.end66, %do.end54, %do.end42, %do.end30, %do.end18, %do.end, %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end114
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body122

do.body122:                                       ; preds = %if.end
  store i32 0, i32* %__gu_err120, align 4
  %89 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %buffer = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %89, i32 0, i32 4
  %90 = bitcast i32* %buffer to %struct.__large_struct*
  %91 = load i32, i32* %__gu_err120, align 4
  %92 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %90, i32 -14, i32 %91) #4, !srcloc !66
  %asmresult123 = extractvalue { i32, i64 } %92, 0
  %asmresult124 = extractvalue { i32, i64 } %92, 1
  store i32 %asmresult123, i32* %__gu_err120, align 4
  store i64 %asmresult124, i64* %__gu_val121, align 8
  br label %do.end125

do.end125:                                        ; preds = %do.body122
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %93 = load i64, i64* %__gu_val121, align 8
  %conv126 = trunc i64 %93 to i32
  store i32 %conv126, i32* %uptr, align 4
  %94 = load i32, i32* %__gu_err120, align 4
  %conv128 = sext i32 %94 to i64
  store i64 %conv128, i64* %tmp127, align 8
  %95 = load i64, i64* %tmp127, align 8
  %tobool129 = icmp ne i64 %95, 0
  br i1 %tobool129, label %if.then130, label %if.end131

if.then130:                                       ; preds = %do.end125
  store i32 -14, i32* %retval, align 4
  br label %return

if.end131:                                        ; preds = %do.end125
  %96 = load i32, i32* %uptr, align 4
  %call132 = call i8* @compat_ptr(i32 %96)
  %97 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %buffer133 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %97, i32 0, i32 4
  store i8* %call132, i8** %buffer133, align 8
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xcb\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !23
  br label %do.body136

do.body136:                                       ; preds = %if.end131
  store i32 0, i32* %__gu_err134, align 4
  %98 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %usercontext = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %98, i32 0, i32 11
  %99 = bitcast i32* %usercontext to %struct.__large_struct*
  %100 = load i32, i32* %__gu_err134, align 4
  %101 = call { i32, i64 } asm sideeffect "\0A1:\09movl $2,${1:k}\0A2:\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 4\0A .long (1b) - .\0A .long (3b) - .\0A .long (ex_handler_default) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %99, i32 -14, i32 %100) #4, !srcloc !67
  %asmresult137 = extractvalue { i32, i64 } %101, 0
  %asmresult138 = extractvalue { i32, i64 } %101, 1
  store i32 %asmresult137, i32* %__gu_err134, align 4
  store i64 %asmresult138, i64* %__gu_val135, align 8
  br label %do.end139

do.end139:                                        ; preds = %do.body136
  call void asm sideeffect "661:\0A\09\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 9*32+20)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0x0f,0x01,0xca\0A6651:\0A\09.popsection", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !25
  %102 = load i64, i64* %__gu_val135, align 8
  %conv140 = trunc i64 %102 to i32
  store i32 %conv140, i32* %uptr, align 4
  %103 = load i32, i32* %__gu_err134, align 4
  %conv142 = sext i32 %103 to i64
  store i64 %conv142, i64* %tmp141, align 8
  %104 = load i64, i64* %tmp141, align 8
  %tobool143 = icmp ne i64 %104, 0
  br i1 %tobool143, label %if.then144, label %if.end145

if.then144:                                       ; preds = %do.end139
  store i32 -14, i32* %retval, align 4
  br label %return

if.end145:                                        ; preds = %do.end139
  %105 = load i32, i32* %uptr, align 4
  %call146 = call i8* @compat_ptr(i32 %105)
  %106 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %usercontext147 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %106, i32 0, i32 11
  store i8* %call146, i8** %usercontext147, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end145, %if.then144, %if.then130, %if.then
  %107 = load i32, i32* %retval, align 4
  ret i32 %107
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_ioctl(%struct.usb_dev_state* %ps, %struct.usbdevfs_ioctl* %ctl) #0 {
entry:
  %to.addr.i98 = alloca i8*, align 8
  %from.addr.i99 = alloca i8*, align 8
  %n.addr.i100 = alloca i64, align 8
  %sz.i101 = alloca i32, align 4
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %sz.i = alloca i32, align 4
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %ctl.addr = alloca %struct.usbdevfs_ioctl*, align 8
  %size = alloca i32, align 4
  %buf = alloca i8*, align 8
  %retval1 = alloca i32, align 4
  %intf = alloca %struct.usb_interface*, align 8
  %driver = alloca %struct.usb_driver*, align 8
  %__mptr = alloca %struct.device_driver*, align 8
  %tmp = alloca %struct.usb_driver*, align 8
  %__mptr56 = alloca %struct.device_driver*, align 8
  %tmp59 = alloca %struct.usb_driver*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store %struct.usbdevfs_ioctl* %ctl, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  store i8* null, i8** %buf, align 8
  store i32 0, i32* %retval1, align 4
  store %struct.usb_interface* null, %struct.usb_interface** %intf, align 8
  store %struct.usb_driver* null, %struct.usb_driver** %driver, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %privileges_dropped = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 15
  %1 = load i8, i8* %privileges_dropped, align 8
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ioctl_code = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %2, i32 0, i32 1
  %3 = load i32, i32* %ioctl_code, align 4
  %shr = ashr i32 %3, 16
  %and = and i32 %shr, 16383
  store i32 %and, i32* %size, align 4
  %4 = load i32, i32* %size, align 4
  %cmp = icmp sgt i32 %4, 0
  br i1 %cmp, label %if.then2, label %if.end20

if.then2:                                         ; preds = %if.end
  %5 = load i32, i32* %size, align 4
  %conv = sext i32 %5 to i64
  store i64 %conv, i64* %size.addr.i, align 8
  store i32 20971712, i32* %flags.addr.i, align 4
  %6 = load i64, i64* %size.addr.i, align 8
  %7 = load i32, i32* %flags.addr.i, align 4
  %call.i = call noalias i8* @__kmalloc(i64 %6, i32 %7) #4
  store i8* %call.i, i8** %buf, align 8
  %8 = load i8*, i8** %buf, align 8
  %cmp3 = icmp eq i8* %8, null
  br i1 %cmp3, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then2
  store i32 -12, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.then2
  %9 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ioctl_code7 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %9, i32 0, i32 1
  %10 = load i32, i32* %ioctl_code7, align 4
  %shr8 = ashr i32 %10, 30
  %and9 = and i32 %shr8, 3
  %and10 = and i32 %and9, 1
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end6
  %11 = load i8*, i8** %buf, align 8
  %12 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %data = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %12, i32 0, i32 2
  %13 = load i8*, i8** %data, align 8
  %14 = load i32, i32* %size, align 4
  %conv13 = sext i32 %14 to i64
  store i8* %11, i8** %to.addr.i, align 8
  store i8* %13, i8** %from.addr.i, align 8
  store i64 %conv13, i64* %n.addr.i, align 8
  %15 = load i8*, i8** %to.addr.i, align 8
  %16 = call i64 @llvm.objectsize.i64.p0i8(i8* %15, i1 false, i1 true) #4
  %conv.i = trunc i64 %16 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  call void @might_fault() #4
  %17 = load i8*, i8** %to.addr.i, align 8
  %18 = load i64, i64* %n.addr.i, align 8
  %conv1.i = trunc i64 %18 to i32
  call void @kasan_check_write(i8* %17, i32 %conv1.i) #4
  %19 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp slt i32 %19, 0
  br i1 %cmp.i, label %lor.end.i, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %if.then12
  %20 = load i32, i32* %sz.i, align 4
  %conv3.i = sext i32 %20 to i64
  %21 = load i64, i64* %n.addr.i, align 8
  %cmp4.i = icmp uge i64 %conv3.i, %21
  br label %lor.end.i

lor.end.i:                                        ; preds = %lor.rhs.i, %if.then12
  %22 = phi i1 [ true, %if.then12 ], [ %cmp4.i, %lor.rhs.i ]
  %lnot.i = xor i1 %22, true
  %lnot.ext.i = zext i1 %22 to i32
  %conv7.i = sext i32 %lnot.ext.i to i64
  br i1 %22, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %lor.end.i
  %23 = load i8*, i8** %to.addr.i, align 8
  %24 = load i64, i64* %n.addr.i, align 8
  call void @check_object_size(i8* %23, i64 %24, i1 zeroext false) #4
  %25 = load i8*, i8** %to.addr.i, align 8
  %26 = load i8*, i8** %from.addr.i, align 8
  %27 = load i64, i64* %n.addr.i, align 8
  %conv8.i = trunc i64 %27 to i32
  %call.i97 = call i64 @_copy_from_user(i8* %25, i8* %26, i32 %conv8.i) #4
  store i64 %call.i97, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

if.else.i:                                        ; preds = %lor.end.i
  %28 = load i32, i32* %sz.i, align 4
  %29 = load i64, i64* %n.addr.i, align 8
  call void @copy_user_overflow(i32 %28, i64 %29) #4
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.else.i, %if.then.i
  %30 = load i64, i64* %n.addr.i, align 8
  %tobool15 = icmp ne i64 %30, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %copy_from_user.exit
  %31 = load i8*, i8** %buf, align 8
  call void @kfree(i8* %31)
  store i32 -14, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %copy_from_user.exit
  br label %if.end19

if.else:                                          ; preds = %if.end6
  %32 = load i8*, i8** %buf, align 8
  %33 = load i32, i32* %size, align 4
  %conv18 = sext i32 %33 to i64
  call void @llvm.memset.p0i8.i64(i8* %32, i8 0, i64 %conv18, i32 1, i1 false)
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.end17
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.end
  %34 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %call21 = call i32 @connected(%struct.usb_dev_state* %34)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end20
  %35 = load i8*, i8** %buf, align 8
  call void @kfree(i8* %35)
  store i32 -19, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end20
  %36 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %36, i32 0, i32 1
  %37 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %37, i32 0, i32 3
  %38 = load i32, i32* %state, align 8
  %cmp25 = icmp ne i32 %38, 7
  br i1 %cmp25, label %if.then27, label %if.else28

if.then27:                                        ; preds = %if.end24
  store i32 -113, i32* %retval1, align 4
  br label %if.end77

if.else28:                                        ; preds = %if.end24
  %39 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev29 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %39, i32 0, i32 1
  %40 = load %struct.usb_device*, %struct.usb_device** %dev29, align 8
  %41 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ifno = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %41, i32 0, i32 0
  %42 = load i32, i32* %ifno, align 8
  %call30 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %40, i32 %42)
  store %struct.usb_interface* %call30, %struct.usb_interface** %intf, align 8
  %tobool31 = icmp ne %struct.usb_interface* %call30, null
  br i1 %tobool31, label %if.else33, label %if.then32

if.then32:                                        ; preds = %if.else28
  store i32 -22, i32* %retval1, align 4
  br label %if.end76

if.else33:                                        ; preds = %if.else28
  %43 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ioctl_code34 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %43, i32 0, i32 1
  %44 = load i32, i32* %ioctl_code34, align 4
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.else33
  %Pivot = icmp slt i32 %44, 21783
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %44, 21783
  br i1 %SwitchLeaf2, label %sw.bb43, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %44, 21782
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %45 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev35 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %45, i32 0, i32 7
  %driver36 = getelementptr inbounds %struct.device, %struct.device* %dev35, i32 0, i32 7
  %46 = load %struct.device_driver*, %struct.device_driver** %driver36, align 8
  %tobool37 = icmp ne %struct.device_driver* %46, null
  br i1 %tobool37, label %if.then38, label %if.else41

if.then38:                                        ; preds = %sw.bb
  %47 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev39 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %47, i32 0, i32 7
  %driver40 = getelementptr inbounds %struct.device, %struct.device* %dev39, i32 0, i32 7
  %48 = load %struct.device_driver*, %struct.device_driver** %driver40, align 8
  store %struct.device_driver* %48, %struct.device_driver** %__mptr, align 8
  %49 = load %struct.device_driver*, %struct.device_driver** %__mptr, align 8
  %50 = bitcast %struct.device_driver* %49 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %50, i64 -104
  %51 = bitcast i8* %add.ptr to %struct.usb_driver*
  store %struct.usb_driver* %51, %struct.usb_driver** %tmp, align 8
  %52 = load %struct.usb_driver*, %struct.usb_driver** %tmp, align 8
  store %struct.usb_driver* %52, %struct.usb_driver** %driver, align 8
  %53 = load %struct.usb_driver*, %struct.usb_driver** %driver, align 8
  %54 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  call void @usb_driver_release_interface(%struct.usb_driver* %53, %struct.usb_interface* %54)
  br label %if.end42

if.else41:                                        ; preds = %sw.bb
  store i32 -61, i32* %retval1, align 4
  br label %if.end42

if.end42:                                         ; preds = %if.else41, %if.then38
  br label %sw.epilog

sw.bb43:                                          ; preds = %LeafBlock1
  %55 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev44 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %55, i32 0, i32 7
  %driver45 = getelementptr inbounds %struct.device, %struct.device* %dev44, i32 0, i32 7
  %56 = load %struct.device_driver*, %struct.device_driver** %driver45, align 8
  %tobool46 = icmp ne %struct.device_driver* %56, null
  br i1 %tobool46, label %if.else50, label %if.then47

if.then47:                                        ; preds = %sw.bb43
  %57 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev48 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %57, i32 0, i32 7
  %call49 = call i32 @device_attach(%struct.device* %dev48)
  store i32 %call49, i32* %retval1, align 4
  br label %if.end51

if.else50:                                        ; preds = %sw.bb43
  store i32 -16, i32* %retval1, align 4
  br label %if.end51

if.end51:                                         ; preds = %if.else50, %if.then47
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %58 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev52 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %58, i32 0, i32 7
  %driver53 = getelementptr inbounds %struct.device, %struct.device* %dev52, i32 0, i32 7
  %59 = load %struct.device_driver*, %struct.device_driver** %driver53, align 8
  %tobool54 = icmp ne %struct.device_driver* %59, null
  br i1 %tobool54, label %if.then55, label %if.end61

if.then55:                                        ; preds = %sw.default
  %60 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev57 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %60, i32 0, i32 7
  %driver58 = getelementptr inbounds %struct.device, %struct.device* %dev57, i32 0, i32 7
  %61 = load %struct.device_driver*, %struct.device_driver** %driver58, align 8
  store %struct.device_driver* %61, %struct.device_driver** %__mptr56, align 8
  %62 = load %struct.device_driver*, %struct.device_driver** %__mptr56, align 8
  %63 = bitcast %struct.device_driver* %62 to i8*
  %add.ptr60 = getelementptr inbounds i8, i8* %63, i64 -104
  %64 = bitcast i8* %add.ptr60 to %struct.usb_driver*
  store %struct.usb_driver* %64, %struct.usb_driver** %tmp59, align 8
  %65 = load %struct.usb_driver*, %struct.usb_driver** %tmp59, align 8
  store %struct.usb_driver* %65, %struct.usb_driver** %driver, align 8
  br label %if.end61

if.end61:                                         ; preds = %if.then55, %sw.default
  %66 = load %struct.usb_driver*, %struct.usb_driver** %driver, align 8
  %cmp62 = icmp eq %struct.usb_driver* %66, null
  br i1 %cmp62, label %if.then66, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end61
  %67 = load %struct.usb_driver*, %struct.usb_driver** %driver, align 8
  %unlocked_ioctl = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %67, i32 0, i32 3
  %68 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl, align 8
  %cmp64 = icmp eq i32 (%struct.usb_interface*, i32, i8*)* %68, null
  br i1 %cmp64, label %if.then66, label %if.else67

if.then66:                                        ; preds = %lor.lhs.false, %if.end61
  store i32 -25, i32* %retval1, align 4
  br label %if.end75

if.else67:                                        ; preds = %lor.lhs.false
  %69 = load %struct.usb_driver*, %struct.usb_driver** %driver, align 8
  %unlocked_ioctl68 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %69, i32 0, i32 3
  %70 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl68, align 8
  %71 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %72 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ioctl_code69 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %72, i32 0, i32 1
  %73 = load i32, i32* %ioctl_code69, align 4
  %74 = load i8*, i8** %buf, align 8
  %call70 = call i32 %70(%struct.usb_interface* %71, i32 %73, i8* %74)
  store i32 %call70, i32* %retval1, align 4
  %75 = load i32, i32* %retval1, align 4
  %cmp71 = icmp eq i32 %75, -515
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.else67
  store i32 -25, i32* %retval1, align 4
  br label %if.end74

if.end74:                                         ; preds = %if.then73, %if.else67
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.then66
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end75, %if.end51, %if.end42
  br label %if.end76

if.end76:                                         ; preds = %sw.epilog, %if.then32
  br label %if.end77

if.end77:                                         ; preds = %if.end76, %if.then27
  %76 = load i32, i32* %retval1, align 4
  %cmp78 = icmp sge i32 %76, 0
  br i1 %cmp78, label %land.lhs.true, label %if.end96

land.lhs.true:                                    ; preds = %if.end77
  %77 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ioctl_code80 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %77, i32 0, i32 1
  %78 = load i32, i32* %ioctl_code80, align 4
  %shr81 = ashr i32 %78, 30
  %and82 = and i32 %shr81, 3
  %and83 = and i32 %and82, 2
  %cmp84 = icmp ne i32 %and83, 0
  br i1 %cmp84, label %land.lhs.true86, label %if.end96

land.lhs.true86:                                  ; preds = %land.lhs.true
  %79 = load i32, i32* %size, align 4
  %cmp87 = icmp sgt i32 %79, 0
  br i1 %cmp87, label %land.lhs.true89, label %if.end96

land.lhs.true89:                                  ; preds = %land.lhs.true86
  %80 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %data90 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %80, i32 0, i32 2
  %81 = load i8*, i8** %data90, align 8
  %82 = load i8*, i8** %buf, align 8
  %83 = load i32, i32* %size, align 4
  %conv91 = sext i32 %83 to i64
  store i8* %81, i8** %to.addr.i98, align 8
  store i8* %82, i8** %from.addr.i99, align 8
  store i64 %conv91, i64* %n.addr.i100, align 8
  %84 = load i8*, i8** %from.addr.i99, align 8
  %85 = call i64 @llvm.objectsize.i64.p0i8(i8* %84, i1 false, i1 true) #4
  %conv.i102 = trunc i64 %85 to i32
  store i32 %conv.i102, i32* %sz.i101, align 4
  %86 = load i8*, i8** %from.addr.i99, align 8
  %87 = load i64, i64* %n.addr.i100, align 8
  %conv1.i103 = trunc i64 %87 to i32
  call void @kasan_check_read(i8* %86, i32 %conv1.i103) #4
  call void @might_fault() #4
  %88 = load i32, i32* %sz.i101, align 4
  %cmp.i104 = icmp slt i32 %88, 0
  br i1 %cmp.i104, label %lor.end.i111, label %lor.rhs.i107

lor.rhs.i107:                                     ; preds = %land.lhs.true89
  %89 = load i32, i32* %sz.i101, align 4
  %conv3.i105 = sext i32 %89 to i64
  %90 = load i64, i64* %n.addr.i100, align 8
  %cmp4.i106 = icmp uge i64 %conv3.i105, %90
  br label %lor.end.i111

lor.end.i111:                                     ; preds = %lor.rhs.i107, %land.lhs.true89
  %91 = phi i1 [ true, %land.lhs.true89 ], [ %cmp4.i106, %lor.rhs.i107 ]
  %lnot.i108 = xor i1 %91, true
  %lnot.ext.i109 = zext i1 %91 to i32
  %conv7.i110 = sext i32 %lnot.ext.i109 to i64
  br i1 %91, label %if.then.i114, label %if.else.i115

if.then.i114:                                     ; preds = %lor.end.i111
  %92 = load i8*, i8** %from.addr.i99, align 8
  %93 = load i64, i64* %n.addr.i100, align 8
  call void @check_object_size(i8* %92, i64 %93, i1 zeroext true) #4
  %94 = load i8*, i8** %to.addr.i98, align 8
  %95 = load i8*, i8** %from.addr.i99, align 8
  %96 = load i64, i64* %n.addr.i100, align 8
  %conv8.i112 = trunc i64 %96 to i32
  %call.i113 = call i64 @_copy_to_user(i8* %94, i8* %95, i32 %conv8.i112) #4
  store i64 %call.i113, i64* %n.addr.i100, align 8
  br label %copy_to_user.exit

if.else.i115:                                     ; preds = %lor.end.i111
  %97 = load i32, i32* %sz.i101, align 4
  %98 = load i64, i64* %n.addr.i100, align 8
  call void @copy_user_overflow(i32 %97, i64 %98) #4
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.else.i115, %if.then.i114
  %99 = load i64, i64* %n.addr.i100, align 8
  %cmp93 = icmp ne i64 %99, 0
  br i1 %cmp93, label %if.then95, label %if.end96

if.then95:                                        ; preds = %copy_to_user.exit
  store i32 -14, i32* %retval1, align 4
  br label %if.end96

if.end96:                                         ; preds = %if.then95, %copy_to_user.exit, %land.lhs.true86, %land.lhs.true, %if.end77
  %100 = load i8*, i8** %buf, align 8
  call void @kfree(i8* %100)
  %101 = load i32, i32* %retval1, align 4
  store i32 %101, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end96, %if.then23, %if.then16, %if.then5, %if.then
  %102 = load i32, i32* %retval, align 4
  ret i32 %102
}

declare void @usb_driver_release_interface(%struct.usb_driver*, %struct.usb_interface*) #1

declare i32 @device_attach(%struct.device*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.async* @async_getpending(%struct.usb_dev_state* %ps, i8* %userurb) #0 {
entry:
  %retval = alloca %struct.async*, align 8
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %userurb.addr = alloca i8*, align 8
  %as = alloca %struct.async*, align 8
  %__mptr = alloca %struct.list_head*, align 8
  %tmp = alloca %struct.async*, align 8
  %__mptr5 = alloca %struct.list_head*, align 8
  %tmp8 = alloca %struct.async*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i8* %userurb, i8** %userurb.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %0, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %1, %struct.list_head** %__mptr, align 8
  %2 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.async*
  store %struct.async* %4, %struct.async** %tmp, align 8
  %5 = load %struct.async*, %struct.async** %tmp, align 8
  store %struct.async* %5, %struct.async** %as, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load %struct.async*, %struct.async** %as, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  %7 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_pending1 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %7, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.async*, %struct.async** %as, align 8
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 7
  %9 = load i8*, i8** %userurb2, align 8
  %10 = load i8*, i8** %userurb.addr, align 8
  %cmp3 = icmp eq i8* %9, %10
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %11 = load %struct.async*, %struct.async** %as, align 8
  %asynclist4 = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist4)
  %12 = load %struct.async*, %struct.async** %as, align 8
  store %struct.async* %12, %struct.async** %retval, align 8
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %13 = load %struct.async*, %struct.async** %as, align 8
  %asynclist6 = getelementptr inbounds %struct.async, %struct.async* %13, i32 0, i32 0
  %next7 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist6, i32 0, i32 0
  %14 = load %struct.list_head*, %struct.list_head** %next7, align 8
  store %struct.list_head* %14, %struct.list_head** %__mptr5, align 8
  %15 = load %struct.list_head*, %struct.list_head** %__mptr5, align 8
  %16 = bitcast %struct.list_head* %15 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %16, i64 0
  %17 = bitcast i8* %add.ptr9 to %struct.async*
  store %struct.async* %17, %struct.async** %tmp8, align 8
  %18 = load %struct.async*, %struct.async** %tmp8, align 8
  store %struct.async* %18, %struct.async** %as, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store %struct.async* null, %struct.async** %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %19 = load %struct.async*, %struct.async** %retval, align 8
  ret %struct.async* %19
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @releaseintf(%struct.usb_dev_state* %ps, i32 %ifnum) #0 {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %c.i = alloca i8, align 1
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %ifnum.addr = alloca i32, align 4
  %dev = alloca %struct.usb_device*, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %err = alloca i32, align 4
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store i32 %ifnum, i32* %ifnum.addr, align 4
  store i32 -22, i32* %err, align 4
  %0 = load i32, i32* %ifnum.addr, align 4
  %conv = zext i32 %0 to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %err, align 4
  store i32 %1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev2 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %2, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8
  store %struct.usb_device* %3, %struct.usb_device** %dev, align 8
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %5 = load i32, i32* %ifnum.addr, align 4
  %call = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %4, i32 %5)
  store %struct.usb_interface* %call, %struct.usb_interface** %intf, align 8
  %6 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %tobool = icmp ne %struct.usb_interface* %6, null
  br i1 %tobool, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.end
  store i32 -2, i32* %err, align 4
  br label %if.end8

if.else:                                          ; preds = %if.end
  %7 = load i32, i32* %ifnum.addr, align 4
  %conv4 = zext i32 %7 to i64
  %8 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %ifclaimed = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %8, i32 0, i32 12
  store i64 %conv4, i64* %nr.addr.i, align 8
  store i64* %ifclaimed, i64** %addr.addr.i, align 8
  %9 = load i64*, i64** %addr.addr.i, align 8
  %10 = load i64, i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %9, i8* %c.i, i64 %10, i64* %9) #4, !srcloc !68
  %11 = load i8, i8* %c.i, align 1
  %tobool.i = trunc i8 %11 to i1
  br i1 %tobool.i, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.else
  %12 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  call void @usb_driver_release_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %12)
  store i32 0, i32* %err, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.then3
  %13 = load i32, i32* %err, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

declare i32 @usb_hub_claim_port(%struct.usb_device*, i32, %struct.usb_dev_state*) #1

declare i32 @usb_hub_release_port(%struct.usb_device*, i32, %struct.usb_dev_state*) #1

declare i32 @strncmp(i8*, i8*, i64) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @parse_usbdevfs_streams(%struct.usb_dev_state* %ps, %struct.usbdevfs_streams* %streams, i32* %num_streams_ret, i32* %num_eps_ret, %struct.usb_host_endpoint*** %eps_ret, %struct.usb_interface** %intf_ret) #0 {
entry:
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  %streams.addr = alloca %struct.usbdevfs_streams*, align 8
  %num_streams_ret.addr = alloca i32*, align 8
  %num_eps_ret.addr = alloca i32*, align 8
  %eps_ret.addr = alloca %struct.usb_host_endpoint***, align 8
  %intf_ret.addr = alloca %struct.usb_interface**, align 8
  %i = alloca i32, align 4
  %num_streams = alloca i32, align 4
  %num_eps = alloca i32, align 4
  %eps = alloca %struct.usb_host_endpoint**, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %ep = alloca i8, align 1
  %ifnum = alloca i32, align 4
  %ret = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %__sp = alloca i8*, align 8
  %tmp = alloca i64, align 8
  %__ret_gu5 = alloca i32, align 4
  %__val_gu6 = alloca i64, align 8
  %__sp7 = alloca i8*, align 8
  %tmp13 = alloca i64, align 8
  %__ret_gu36 = alloca i32, align 4
  %__val_gu37 = alloca i64, align 8
  %__sp38 = alloca i8*, align 8
  %tmp44 = alloca i64, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  store %struct.usbdevfs_streams* %streams, %struct.usbdevfs_streams** %streams.addr, align 8
  store i32* %num_streams_ret, i32** %num_streams_ret.addr, align 8
  store i32* %num_eps_ret, i32** %num_eps_ret.addr, align 8
  store %struct.usb_host_endpoint*** %eps_ret, %struct.usb_host_endpoint**** %eps_ret.addr, align 8
  store %struct.usb_interface** %intf_ret, %struct.usb_interface*** %intf_ret.addr, align 8
  store %struct.usb_interface* null, %struct.usb_interface** %intf, align 8
  call void @might_fault()
  %0 = load i8*, i8** %__sp, align 8
  %1 = load %struct.usbdevfs_streams*, %struct.usbdevfs_streams** %streams.addr, align 8
  %num_streams1 = getelementptr inbounds %struct.usbdevfs_streams, %struct.usbdevfs_streams* %1, i32 0, i32 0
  %2 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %num_streams1, i64 4, i8* %0) #4, !srcloc !69
  %asmresult = extractvalue { i32*, i64, i8* } %2, 0
  %asmresult2 = extractvalue { i32*, i64, i8* } %2, 1
  %asmresult3 = extractvalue { i32*, i64, i8* } %2, 2
  %3 = ptrtoint i32* %asmresult to i64
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %__ret_gu, align 4
  store i64 %asmresult2, i64* %__val_gu, align 8
  store i8* %asmresult3, i8** %__sp, align 8
  %5 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, i32* %num_streams, align 4
  %6 = load i32, i32* %__ret_gu, align 4
  %conv4 = sext i32 %6 to i64
  store i64 %conv4, i64* %tmp, align 8
  %7 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %7, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %8 = load i8*, i8** %__sp7, align 8
  %9 = load %struct.usbdevfs_streams*, %struct.usbdevfs_streams** %streams.addr, align 8
  %num_eps8 = getelementptr inbounds %struct.usbdevfs_streams, %struct.usbdevfs_streams* %9, i32 0, i32 1
  %10 = call { i32*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i32* %num_eps8, i64 4, i8* %8) #4, !srcloc !70
  %asmresult9 = extractvalue { i32*, i64, i8* } %10, 0
  %asmresult10 = extractvalue { i32*, i64, i8* } %10, 1
  %asmresult11 = extractvalue { i32*, i64, i8* } %10, 2
  %11 = ptrtoint i32* %asmresult9 to i64
  %12 = trunc i64 %11 to i32
  store i32 %12, i32* %__ret_gu5, align 4
  store i64 %asmresult10, i64* %__val_gu6, align 8
  store i8* %asmresult11, i8** %__sp7, align 8
  %13 = load i64, i64* %__val_gu6, align 8
  %conv12 = trunc i64 %13 to i32
  store i32 %conv12, i32* %num_eps, align 4
  %14 = load i32, i32* %__ret_gu5, align 4
  %conv14 = sext i32 %14 to i64
  store i64 %conv14, i64* %tmp13, align 8
  %15 = load i64, i64* %tmp13, align 8
  %tobool15 = icmp ne i64 %15, 0
  br i1 %tobool15, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %16 = load i32, i32* %num_eps, align 4
  %cmp = icmp ult i32 %16, 1
  br i1 %cmp, label %if.then20, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %if.end
  %17 = load i32, i32* %num_eps, align 4
  %cmp18 = icmp ugt i32 %17, 30
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false17, %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %lor.lhs.false17
  %18 = load i32*, i32** %num_streams_ret.addr, align 8
  %tobool22 = icmp ne i32* %18, null
  br i1 %tobool22, label %land.lhs.true, label %if.end29

land.lhs.true:                                    ; preds = %if.end21
  %19 = load i32, i32* %num_streams, align 4
  %cmp23 = icmp ult i32 %19, 2
  br i1 %cmp23, label %if.then28, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %land.lhs.true
  %20 = load i32, i32* %num_streams, align 4
  %cmp26 = icmp ugt i32 %20, 65536
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %lor.lhs.false25, %land.lhs.true
  store i32 -22, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %lor.lhs.false25, %if.end21
  %21 = load i32, i32* %num_eps, align 4
  %conv30 = zext i32 %21 to i64
  %mul = mul i64 %conv30, 8
  store i64 %mul, i64* %size.addr.i, align 8
  store i32 20971712, i32* %flags.addr.i, align 4
  %22 = load i64, i64* %size.addr.i, align 8
  %23 = load i32, i32* %flags.addr.i, align 4
  %call.i = call noalias i8* @__kmalloc(i64 %22, i32 %23) #4
  %24 = bitcast i8* %call.i to %struct.usb_host_endpoint**
  store %struct.usb_host_endpoint** %24, %struct.usb_host_endpoint*** %eps, align 8
  %25 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8
  %tobool31 = icmp ne %struct.usb_host_endpoint** %25, null
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.end29
  store i32 -12, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end29
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end33
  %26 = load i32, i32* %i, align 4
  %27 = load i32, i32* %num_eps, align 4
  %cmp34 = icmp ult i32 %26, %27
  br i1 %cmp34, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %28 = load i8*, i8** %__sp38, align 8
  %29 = load %struct.usbdevfs_streams*, %struct.usbdevfs_streams** %streams.addr, align 8
  %eps39 = getelementptr inbounds %struct.usbdevfs_streams, %struct.usbdevfs_streams* %29, i32 0, i32 2
  %30 = load i32, i32* %i, align 4
  %idxprom = zext i32 %30 to i64
  %arrayidx = getelementptr inbounds [0 x i8], [0 x i8]* %eps39, i64 0, i64 %idxprom
  %31 = call { i8*, i64, i8* } asm sideeffect "call __get_user_${4:P}", "={ax},={rdx},={rsp},0,i,2,~{dirflag},~{fpsr},~{flags}"(i8* %arrayidx, i64 1, i8* %28) #4, !srcloc !71
  %asmresult40 = extractvalue { i8*, i64, i8* } %31, 0
  %asmresult41 = extractvalue { i8*, i64, i8* } %31, 1
  %asmresult42 = extractvalue { i8*, i64, i8* } %31, 2
  %32 = ptrtoint i8* %asmresult40 to i64
  %33 = trunc i64 %32 to i32
  store i32 %33, i32* %__ret_gu36, align 4
  store i64 %asmresult41, i64* %__val_gu37, align 8
  store i8* %asmresult42, i8** %__sp38, align 8
  %34 = load i64, i64* %__val_gu37, align 8
  %conv43 = trunc i64 %34 to i8
  store i8 %conv43, i8* %ep, align 1
  %35 = load i32, i32* %__ret_gu36, align 4
  %conv45 = sext i32 %35 to i64
  store i64 %conv45, i64* %tmp44, align 8
  %36 = load i64, i64* %tmp44, align 8
  %tobool46 = icmp ne i64 %36, 0
  br i1 %tobool46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %for.body
  store i32 -14, i32* %ret, align 4
  br label %error

if.end48:                                         ; preds = %for.body
  %37 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %37, i32 0, i32 1
  %38 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %39 = load i8, i8* %ep, align 1
  %call49 = call %struct.usb_host_endpoint* @ep_to_host_endpoint(%struct.usb_device* %38, i8 zeroext %39)
  %40 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8
  %41 = load i32, i32* %i, align 4
  %idxprom50 = zext i32 %41 to i64
  %arrayidx51 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %40, i64 %idxprom50
  store %struct.usb_host_endpoint* %call49, %struct.usb_host_endpoint** %arrayidx51, align 8
  %42 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8
  %43 = load i32, i32* %i, align 4
  %idxprom52 = zext i32 %43 to i64
  %arrayidx53 = getelementptr inbounds %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %42, i64 %idxprom52
  %44 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx53, align 8
  %tobool54 = icmp ne %struct.usb_host_endpoint* %44, null
  br i1 %tobool54, label %if.end56, label %if.then55

if.then55:                                        ; preds = %if.end48
  store i32 -22, i32* %ret, align 4
  br label %error

if.end56:                                         ; preds = %if.end48
  %45 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev57 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %45, i32 0, i32 1
  %46 = load %struct.usb_device*, %struct.usb_device** %dev57, align 8
  %47 = load i8, i8* %ep, align 1
  %conv58 = zext i8 %47 to i32
  %call59 = call i32 @findintfep(%struct.usb_device* %46, i32 %conv58)
  store i32 %call59, i32* %ifnum, align 4
  %48 = load i32, i32* %ifnum, align 4
  %cmp60 = icmp slt i32 %48, 0
  br i1 %cmp60, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end56
  %49 = load i32, i32* %ifnum, align 4
  store i32 %49, i32* %ret, align 4
  br label %error

if.end63:                                         ; preds = %if.end56
  %50 = load i32, i32* %i, align 4
  %cmp64 = icmp eq i32 %50, 0
  br i1 %cmp64, label %if.then66, label %if.else

if.then66:                                        ; preds = %if.end63
  %51 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %52 = load i32, i32* %ifnum, align 4
  %call67 = call i32 @checkintf(%struct.usb_dev_state* %51, i32 %52)
  store i32 %call67, i32* %ret, align 4
  %53 = load i32, i32* %ret, align 4
  %cmp68 = icmp slt i32 %53, 0
  br i1 %cmp68, label %if.then70, label %if.end71

if.then70:                                        ; preds = %if.then66
  br label %error

if.end71:                                         ; preds = %if.then66
  %54 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %dev72 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %54, i32 0, i32 1
  %55 = load %struct.usb_device*, %struct.usb_device** %dev72, align 8
  %56 = load i32, i32* %ifnum, align 4
  %call73 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %55, i32 %56)
  store %struct.usb_interface* %call73, %struct.usb_interface** %intf, align 8
  br label %if.end79

if.else:                                          ; preds = %if.end63
  %57 = load i32, i32* %ifnum, align 4
  %58 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %58, i32 0, i32 0
  %59 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %59, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %60 = load i8, i8* %bInterfaceNumber, align 2
  %conv74 = zext i8 %60 to i32
  %cmp75 = icmp ne i32 %57, %conv74
  br i1 %cmp75, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.else
  store i32 -22, i32* %ret, align 4
  br label %error

if.end78:                                         ; preds = %if.else
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %if.end71
  br label %for.inc

for.inc:                                          ; preds = %if.end79
  %61 = load i32, i32* %i, align 4
  %inc = add i32 %61, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %62 = load i32*, i32** %num_streams_ret.addr, align 8
  %tobool80 = icmp ne i32* %62, null
  br i1 %tobool80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %for.end
  %63 = load i32, i32* %num_streams, align 4
  %64 = load i32*, i32** %num_streams_ret.addr, align 8
  store i32 %63, i32* %64, align 4
  br label %if.end82

if.end82:                                         ; preds = %if.then81, %for.end
  %65 = load i32, i32* %num_eps, align 4
  %66 = load i32*, i32** %num_eps_ret.addr, align 8
  store i32 %65, i32* %66, align 4
  %67 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8
  %68 = load %struct.usb_host_endpoint***, %struct.usb_host_endpoint**** %eps_ret.addr, align 8
  store %struct.usb_host_endpoint** %67, %struct.usb_host_endpoint*** %68, align 8
  %69 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %70 = load %struct.usb_interface**, %struct.usb_interface*** %intf_ret.addr, align 8
  store %struct.usb_interface* %69, %struct.usb_interface** %70, align 8
  store i32 0, i32* %retval, align 4
  br label %return

error:                                            ; preds = %if.then77, %if.then70, %if.then62, %if.then55, %if.then47
  %71 = load %struct.usb_host_endpoint**, %struct.usb_host_endpoint*** %eps, align 8
  %72 = bitcast %struct.usb_host_endpoint** %71 to i8*
  call void @kfree(i8* %72)
  %73 = load i32, i32* %ret, align 4
  store i32 %73, i32* %retval, align 4
  br label %return

return:                                           ; preds = %error, %if.end82, %if.then32, %if.then28, %if.then20, %if.then
  %74 = load i32, i32* %retval, align 4
  ret i32 %74
}

declare i32 @usb_alloc_streams(%struct.usb_interface*, %struct.usb_host_endpoint**, i32, i32, i32) #1

declare i32 @usb_free_streams(%struct.usb_interface*, %struct.usb_host_endpoint**, i32, i32) #1

declare i8* @usb_alloc_coherent(%struct.usb_device*, i64, i32, i64*) #1

declare i32 @remap_pfn_range(%struct.vm_area_struct*, i64, i64, i64, i64) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @virt_to_phys(i8* %address) #0 {
entry:
  %address.addr = alloca i8*, align 8
  store i8* %address, i8** %address.addr, align 8
  %0 = load i8*, i8** %address.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %call = call i64 @__phys_addr_nodebug(i64 %1)
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @usbdev_vm_open(%struct.vm_area_struct* %vma) #0 {
entry:
  %lock.addr.i6 = alloca %struct.spinlock*, align 8
  %flags.addr.i = alloca i64, align 8
  %__dummy.i = alloca i64, align 8
  %__dummy2.i = alloca i64, align 8
  %tmp.i = alloca i32, align 4
  %lock.addr.i = alloca %struct.spinlock*, align 8
  %vma.addr = alloca %struct.vm_area_struct*, align 8
  %usbm = alloca %struct.usb_memory*, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.vm_area_struct* %vma, %struct.vm_area_struct** %vma.addr, align 8
  %0 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_private_data = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %0, i32 0, i32 15
  %1 = load i8*, i8** %vm_private_data, align 8
  %2 = bitcast i8* %1 to %struct.usb_memory*
  store %struct.usb_memory* %2, %struct.usb_memory** %usbm, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %3 = load i32, i32* %tmp, align 4
  %4 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %ps = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 7
  %5 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %5, i32 0, i32 3
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr.i, align 8
  %6 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i, align 8
  %7 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %6, i32 0, i32 0
  %rlock.i = bitcast %union.anon* %7 to %struct.raw_spinlock*
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %rlock.i)
  store i64 %call2, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.end
  %8 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %8, i32 0, i32 1
  %9 = load i32, i32* %vma_use_count, align 8
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %vma_use_count, align 8
  %10 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %ps4 = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %10, i32 0, i32 7
  %11 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps4, align 8
  %lock5 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %11, i32 0, i32 3
  %12 = load i64, i64* %flags, align 8
  store %struct.spinlock* %lock5, %struct.spinlock** %lock.addr.i6, align 8
  store i64 %12, i64* %flags.addr.i, align 8
  store i32 1, i32* %tmp.i, align 4
  %13 = load i32, i32* %tmp.i, align 4
  %14 = load %struct.spinlock*, %struct.spinlock** %lock.addr.i6, align 8
  %15 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %14, i32 0, i32 0
  %rlock.i7 = bitcast %union.anon* %15 to %struct.raw_spinlock*
  %16 = load i64, i64* %flags.addr.i, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock.i7, i64 %16) #4
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @usbdev_vm_close(%struct.vm_area_struct* %vma) #0 {
entry:
  %vma.addr = alloca %struct.vm_area_struct*, align 8
  %usbm = alloca %struct.usb_memory*, align 8
  store %struct.vm_area_struct* %vma, %struct.vm_area_struct** %vma.addr, align 8
  %0 = load %struct.vm_area_struct*, %struct.vm_area_struct** %vma.addr, align 8
  %vm_private_data = getelementptr inbounds %struct.vm_area_struct, %struct.vm_area_struct* %0, i32 0, i32 15
  %1 = load i8*, i8** %vm_private_data, align 8
  %2 = bitcast i8* %1 to %struct.usb_memory*
  store %struct.usb_memory* %2, %struct.usb_memory** %usbm, align 8
  %3 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %4 = load %struct.usb_memory*, %struct.usb_memory** %usbm, align 8
  %vma_use_count = getelementptr inbounds %struct.usb_memory, %struct.usb_memory* %4, i32 0, i32 1
  call void @dec_usb_memory_use_count(%struct.usb_memory* %3, i32* %vma_use_count)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @imajor(%struct.inode* %inode) #0 {
entry:
  %inode.addr = alloca %struct.inode*, align 8
  store %struct.inode* %inode, %struct.inode** %inode.addr, align 8
  %0 = load %struct.inode*, %struct.inode** %inode.addr, align 8
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 13
  %1 = load i32, i32* %i_rdev, align 4
  %shr = lshr i32 %1, 20
  ret i32 %shr
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.usb_device* @usbdev_lookup_by_devt(i32 %devt) #0 {
entry:
  %retval = alloca %struct.usb_device*, align 8
  %devt.addr = alloca i32, align 4
  %dev = alloca %struct.device*, align 8
  %__mptr = alloca %struct.device*, align 8
  %tmp = alloca %struct.usb_device*, align 8
  store i32 %devt, i32* %devt.addr, align 4
  %0 = load i32, i32* %devt.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = inttoptr i64 %conv to i8*
  %call = call %struct.device* @bus_find_device(%struct.bus_type* @usb_bus_type, %struct.device* null, i8* %1, i32 (%struct.device*, i8*)* @match_devt)
  store %struct.device* %call, %struct.device** %dev, align 8
  %2 = load %struct.device*, %struct.device** %dev, align 8
  %tobool = icmp ne %struct.device* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.usb_device* null, %struct.usb_device** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.device*, %struct.device** %dev, align 8
  store %struct.device* %3, %struct.device** %__mptr, align 8
  %4 = load %struct.device*, %struct.device** %__mptr, align 8
  %5 = bitcast %struct.device* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -152
  %6 = bitcast i8* %add.ptr to %struct.usb_device*
  store %struct.usb_device* %6, %struct.usb_device** %tmp, align 8
  %7 = load %struct.usb_device*, %struct.usb_device** %tmp, align 8
  store %struct.usb_device* %7, %struct.usb_device** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load %struct.usb_device*, %struct.usb_device** %retval, align 8
  ret %struct.usb_device* %8
}

declare i32 @usb_autoresume_device(%struct.usb_device*) #1

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

declare void @usb_put_dev(%struct.usb_device*) #1

declare %struct.device* @bus_find_device(%struct.bus_type*, %struct.device*, i8*, i32 (%struct.device*, i8*)*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @match_devt(%struct.device* %dev, i8* %data) #0 {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %data.addr = alloca i8*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load %struct.device*, %struct.device** %dev.addr, align 8
  %devt = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 26
  %1 = load i32, i32* %devt, align 8
  %2 = load i8*, i8** %data.addr, align 8
  %3 = ptrtoint i8* %2 to i64
  %conv = trunc i64 %3 to i32
  %cmp = icmp eq i32 %1, %conv
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare void @usb_hub_release_all_ports(%struct.usb_device*, %struct.usb_dev_state*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @destroy_all_async(%struct.usb_dev_state* %ps) #0 {
entry:
  %ps.addr = alloca %struct.usb_dev_state*, align 8
  store %struct.usb_dev_state* %ps, %struct.usb_dev_state** %ps.addr, align 8
  %0 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %1 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps.addr, align 8
  %async_pending = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %1, i32 0, i32 4
  call void @destroy_async(%struct.usb_dev_state* %0, %struct.list_head* %async_pending)
  ret void
}

declare void @usb_autosuspend_device(%struct.usb_device*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbdev_notify(%struct.notifier_block* %self, i64 %action, i8* %dev) #0 {
entry:
  %self.addr = alloca %struct.notifier_block*, align 8
  %action.addr = alloca i64, align 8
  %dev.addr = alloca i8*, align 8
  store %struct.notifier_block* %self, %struct.notifier_block** %self.addr, align 8
  store i64 %action, i64* %action.addr, align 8
  store i8* %dev, i8** %dev.addr, align 8
  %0 = load i64, i64* %action.addr, align 8
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i64 %0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i64 %0, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i64 %0, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = load i8*, i8** %dev.addr, align 8
  %2 = bitcast i8* %1 to %struct.usb_device*
  call void @usbdev_remove(%struct.usb_device* %2)
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %sw.bb1, %sw.bb
  ret i32 1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @usbdev_remove(%struct.usb_device* %udev) #0 {
entry:
  %udev.addr = alloca %struct.usb_device*, align 8
  %ps = alloca %struct.usb_dev_state*, align 8
  %sinfo = alloca %struct.siginfo, align 8
  %__mptr = alloca %struct.list_head*, align 8
  %tmp = alloca %struct.usb_dev_state*, align 8
  store %struct.usb_device* %udev, %struct.usb_device** %udev.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 27
  %call = call i32 @list_empty(%struct.list_head* %filelist)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %filelist1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 27
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %filelist1, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %2, %struct.list_head** %__mptr, align 8
  %3 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.usb_dev_state*
  store %struct.usb_dev_state* %5, %struct.usb_dev_state** %tmp, align 8
  %6 = load %struct.usb_dev_state*, %struct.usb_dev_state** %tmp, align 8
  store %struct.usb_dev_state* %6, %struct.usb_dev_state** %ps, align 8
  %7 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  call void @destroy_all_async(%struct.usb_dev_state* %7)
  %8 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %wait = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %8, i32 0, i32 7
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 0, i8* null)
  %9 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %list = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %9, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %list)
  %10 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %discsignr = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %10, i32 0, i32 8
  %11 = load i32, i32* %discsignr, align 8
  %tobool2 = icmp ne i32 %11, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %12 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.memset.p0i8.i64(i8* %12, i8 0, i64 128, i32 8, i1 false)
  %13 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %discsignr3 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %13, i32 0, i32 8
  %14 = load i32, i32* %discsignr3, align 8
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %14, i32* %si_signo, align 8
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 32, i32* %si_errno, align 4
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8
  %15 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %disccontext = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %15, i32 0, i32 11
  %16 = load i8*, i8** %disccontext, align 8
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.13* %_sifields to %struct.anon.18*
  %_addr = getelementptr inbounds %struct.anon.18, %struct.anon.18* %_sigfault, i32 0, i32 0
  store i8* %16, i8** %_addr, align 8
  %17 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %discsignr4 = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %17, i32 0, i32 8
  %18 = load i32, i32* %discsignr4, align 8
  %19 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %disc_pid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %19, i32 0, i32 9
  %20 = load %struct.pid*, %struct.pid** %disc_pid, align 8
  %21 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %cred = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %21, i32 0, i32 10
  %22 = load %struct.cred*, %struct.cred** %cred, align 8
  %23 = load %struct.usb_dev_state*, %struct.usb_dev_state** %ps, align 8
  %secid = getelementptr inbounds %struct.usb_dev_state, %struct.usb_dev_state* %23, i32 0, i32 13
  %24 = load i32, i32* %secid, align 8
  %call5 = call i32 @kill_pid_info_as_cred(i32 %18, %struct.siginfo* %sinfo, %struct.pid* %20, %struct.cred* %22, i32 %24)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

attributes #0 = { noinline nounwind optnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { nounwind readnone speculatable }
attributes #4 = { nounwind }
attributes #5 = { nounwind readnone }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{i32 -2147034057, i32 -2147034018, i32 -2147033997, i32 -2147033960, i32 -2147033937, i32 -2147034067}
!3 = !{i32 -2146798037}
!4 = !{i32 -2142957425}
!5 = !{i32 418403, i32 418414, i32 -2147024743}
!6 = !{i32 -2147194063}
!7 = !{i32 -2147194025}
!8 = !{i32 -2147194800}
!9 = !{i32 -2147194762}
!10 = !{i32 -2142949291}
!11 = !{i32 -2142948437}
!12 = !{i32 -2142947229}
!13 = !{i32 -2142926793}
!14 = !{i32 -2142924985}
!15 = !{i32 -2142924487}
!16 = !{i32 -2142922949}
!17 = !{i32 -2142918193}
!18 = !{i32 -2142916637}
!19 = !{i32 -2142915935}
!20 = !{i32 -2142914307}
!21 = !{i32 -2142913577}
!22 = !{i32 -2142911771}
!23 = !{i32 -2144296973, i32 -2144296966, i32 -2144296950, i32 -2144296934, i32 -2144296645, i32 -2144297298, i32 -2144296639, i32 -2144296591, i32 -2144296527, i32 -2144296465, i32 -2144296408, i32 -2144296352, i32 -2144297218, i32 -2144297193, i32 -2144296024, i32 -2144296097, i32 -2144296010, i32 -2144296056}
!24 = !{i32 -2142833368, i32 -2142833348, i32 -2142833307, i32 -2142833286, i32 -2142833247, i32 -2142833218, i32 -2142833172, i32 -2142833147, i32 -2142832875, i32 -2142832831, i32 -2142832808, i32 -2142832775, i32 -2142832744, i32 -2142832688}
!25 = !{i32 -2144298603, i32 -2144298596, i32 -2144298580, i32 -2144298564, i32 -2144298275, i32 -2144298928, i32 -2144298269, i32 -2144298221, i32 -2144298157, i32 -2144298095, i32 -2144298038, i32 -2144297982, i32 -2144298848, i32 -2144298823, i32 -2144297654, i32 -2144297727, i32 -2144297640, i32 -2144297686}
!26 = !{i32 -2142828537, i32 -2142828517, i32 -2142828476, i32 -2142828455, i32 -2142828416, i32 -2142828387, i32 -2142828341, i32 -2142828316, i32 -2142828038, i32 -2142827994, i32 -2142827971, i32 -2142827938, i32 -2142827907, i32 -2142827851}
!27 = !{i32 -2142823798, i32 -2142823778, i32 -2142823737, i32 -2142823716, i32 -2142823677, i32 -2142823648, i32 -2142823602, i32 -2142823577, i32 -2142823305, i32 -2142823261, i32 -2142823238, i32 -2142823205, i32 -2142823174, i32 -2142823118}
!28 = !{i32 -2142840958}
!29 = !{i32 -2142840101}
!30 = !{i32 -2142821863}
!31 = !{i32 -2142820686}
!32 = !{i32 -2142818855}
!33 = !{i32 -2142927462}
!34 = !{i32 -2142939417}
!35 = !{i32 -2142937635}
!36 = !{i32 -2142935830}
!37 = !{i32 -2142933779}
!38 = !{i32 -2142931679}
!39 = !{i32 -2142929466}
!40 = !{i32 -2146533296, i32 -2146533257, i32 -2146533236, i32 -2146533199, i32 -2146533176, i32 -2146533167, i32 -2146533123}
!41 = !{i32 -2146511517, i32 -2146511478, i32 -2146511457, i32 -2146511420, i32 -2146511397, i32 -2146511527}
!42 = !{i32 -2142851731}
!43 = !{i32 -2142849946}
!44 = !{i32 -2142848138}
!45 = !{i32 -2142846084}
!46 = !{i32 -2142843981}
!47 = !{i32 -2142842141}
!48 = !{i32 -2146511729, i32 -2146511690, i32 -2146511669, i32 -2146511632, i32 -2146511609, i32 -2146511739}
!49 = !{i32 -2147034803, i32 -2147034764, i32 -2147034743, i32 -2147034706, i32 -2147034683, i32 -2147034813}
!50 = !{i32 -2146534298, i32 -2146534259, i32 -2146534238, i32 -2146534201, i32 -2146534178, i32 -2146534308}
!51 = !{i32 -2143501572, i32 -2143501547, i32 -2143501277, i32 -2143501480, i32 -2143501449, i32 -2143501419}
!52 = !{i32 -2146253830}
!53 = !{i32 -2146281805}
!54 = !{i32 -2146253003}
!55 = !{i32 1113472}
!56 = !{i32 -2142909600, i32 -2142909580, i32 -2142909539, i32 -2142909518, i32 -2142909479, i32 -2142909450, i32 -2142909404, i32 -2142909379, i32 -2142909107, i32 -2142909063, i32 -2142909040, i32 -2142909007, i32 -2142908976, i32 -2142908920}
!57 = !{i32 -2142904821, i32 -2142904801, i32 -2142904760, i32 -2142904739, i32 -2142904700, i32 -2142904671, i32 -2142904625, i32 -2142904600, i32 -2142904324, i32 -2142904280, i32 -2142904257, i32 -2142904224, i32 -2142904193, i32 -2142904137}
!58 = !{i32 -2142898386, i32 -2142898366, i32 -2142898325, i32 -2142898304, i32 -2142898265, i32 -2142898236, i32 -2142898190, i32 -2142898165, i32 -2142897891, i32 -2142897847, i32 -2142897824, i32 -2142897791, i32 -2142897760, i32 -2142897704}
!59 = !{i32 -2142893638, i32 -2142893618, i32 -2142893577, i32 -2142893556, i32 -2142893517, i32 -2142893488, i32 -2142893442, i32 -2142893417, i32 -2142893144, i32 -2142893100, i32 -2142893077, i32 -2142893044, i32 -2142893013, i32 -2142892957}
!60 = !{i32 -2142888743, i32 -2142888723, i32 -2142888682, i32 -2142888661, i32 -2142888622, i32 -2142888593, i32 -2142888547, i32 -2142888522, i32 -2142888241, i32 -2142888197, i32 -2142888174, i32 -2142888141, i32 -2142888110, i32 -2142888054}
!61 = !{i32 -2142883808, i32 -2142883788, i32 -2142883747, i32 -2142883726, i32 -2142883687, i32 -2142883658, i32 -2142883612, i32 -2142883587, i32 -2142883306, i32 -2142883262, i32 -2142883239, i32 -2142883206, i32 -2142883175, i32 -2142883119}
!62 = !{i32 -2142878911, i32 -2142878891, i32 -2142878850, i32 -2142878829, i32 -2142878790, i32 -2142878761, i32 -2142878715, i32 -2142878690, i32 -2142878411, i32 -2142878367, i32 -2142878344, i32 -2142878311, i32 -2142878280, i32 -2142878224}
!63 = !{i32 -2142873910, i32 -2142873890, i32 -2142873849, i32 -2142873828, i32 -2142873789, i32 -2142873760, i32 -2142873714, i32 -2142873689, i32 -2142873404, i32 -2142873360, i32 -2142873337, i32 -2142873304, i32 -2142873273, i32 -2142873217}
!64 = !{i32 -2142868993, i32 -2142868973, i32 -2142868932, i32 -2142868911, i32 -2142868872, i32 -2142868843, i32 -2142868797, i32 -2142868772, i32 -2142868493, i32 -2142868449, i32 -2142868426, i32 -2142868393, i32 -2142868362, i32 -2142868306}
!65 = !{i32 -2142864220, i32 -2142864200, i32 -2142864159, i32 -2142864138, i32 -2142864099, i32 -2142864070, i32 -2142864024, i32 -2142863999, i32 -2142863726, i32 -2142863682, i32 -2142863659, i32 -2142863626, i32 -2142863595, i32 -2142863539}
!66 = !{i32 -2142859471, i32 -2142859451, i32 -2142859410, i32 -2142859389, i32 -2142859350, i32 -2142859321, i32 -2142859275, i32 -2142859250, i32 -2142858976, i32 -2142858932, i32 -2142858909, i32 -2142858876, i32 -2142858845, i32 -2142858789}
!67 = !{i32 -2142854632, i32 -2142854612, i32 -2142854571, i32 -2142854550, i32 -2142854511, i32 -2142854482, i32 -2142854436, i32 -2142854411, i32 -2142854132, i32 -2142854088, i32 -2142854065, i32 -2142854032, i32 -2142854001, i32 -2142853945}
!68 = !{i32 -2147026483, i32 -2147026444, i32 -2147026423, i32 -2147026386, i32 -2147026363, i32 -2147026354, i32 -2147026300}
!69 = !{i32 -2142961559}
!70 = !{i32 -2142960729}
!71 = !{i32 -2142959724}
