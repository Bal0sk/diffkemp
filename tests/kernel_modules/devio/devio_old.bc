; ModuleID = 'drivers/usb/core/devio.bc'
source_filename = "drivers/usb/core/devio.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.atomic_t = type { i32 }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i16 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.atomic_t }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.file*, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.page = type { i64, %struct.address_space*, %struct.anon.15, %union.anon.21, %union.anon.23, [8 x i8] }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.40, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.41, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.42, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.7, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.vfsmount = type opaque
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%union.anon.7 = type { %struct.list_head }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [28 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.5 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.5 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.6, i32 }
%union.anon.6 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%struct.atomic64_t = type { i64 }
%union.anon.40 = type { i32 }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%union.anon.41 = type { %struct.callback_head }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type { i8*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.8 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.8 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.42 = type { %struct.pipe_inode_info* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.read_descriptor_t = type { i64, i64, %union.anon.14, i32 }
%union.anon.14 = type { i8* }
%struct.swap_info_struct = type opaque
%struct.anon.15 = type { %union.anon.16, %union.anon.17 }
%union.anon.16 = type { i64 }
%union.anon.17 = type { i64 }
%union.anon.21 = type { %struct.list_head }
%union.anon.23 = type { i64 }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.list_head }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t }
%union.arch_rwlock_t = type { i32 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.uprobes_state = type {}
%struct.task_rss_stat = type { i32, [3 x i32] }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.10, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.11, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.12, %union.anon.13 }
%union.anon.10 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.11 = type { i64 }
%union.anon.12 = type { %struct.list_head }
%union.anon.13 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, i32, i32, i8, i8 }
%struct.uid_gid_map = type { i32, [5 x %struct.uid_gid_extent] }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.24 }
%union.anon.24 = type { %struct.anon.25 }
%struct.anon.25 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.27, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.30 }
%union.anon.27 = type { %struct.anon.28 }
%struct.anon.28 = type { i64, i64 }
%union.anon.30 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.32 }
%union.anon.32 = type { %struct.anon.36, [80 x i8] }
%struct.anon.36 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.compat_robust_list, i32, i32 }
%struct.compat_robust_list = type { i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.usb_driver = type { i8*, i32 (%struct.usb_interface*, %struct.usb_device_id*)*, void (%struct.usb_interface*)*, i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, %struct.usb_device_id*, %struct.usb_dynids, %struct.usbdrv_wrap, i8 }
%struct.usb_interface = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device, %struct.device*, %struct.atomic_t, %struct.work_struct }
%struct.usb_host_interface = type { %struct.usb_interface_descriptor, i32, i8*, %struct.usb_host_endpoint*, i8* }
%struct.usb_interface_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.usb_host_endpoint = type <{ %struct.usb_endpoint_descriptor, %struct.usb_ss_ep_comp_descriptor, i8, %struct.list_head, i8*, %struct.ep_device*, i8*, i32, i32 }>
%struct.usb_endpoint_descriptor = type <{ i8, i8, i8, i8, i16, i8, i8, i8 }>
%struct.usb_ss_ep_comp_descriptor = type { i8, i8, i8, i8, i16 }
%struct.ep_device = type opaque
%struct.usb_interface_assoc_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.usb_device_id = type { i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8, i64 }
%struct.usb_dynids = type { %struct.spinlock, %struct.list_head }
%struct.usbdrv_wrap = type { %struct.device_driver, i32 }
%struct.cdev = type { %struct.kobject, %struct.module*, %struct.file_operations*, %struct.list_head, i32, i32 }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, i32, [64 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page* }
%struct.kmem_cache_order_objects = type { i64 }
%struct.kmem_cache_node = type opaque
%struct.dev_state = type { %struct.list_head, %struct.usb_device*, %struct.file*, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.__wait_queue_head, i32, %struct.pid*, %struct.cred*, i8*, i64, i32, i32 }
%struct.usb_device = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt*, i32, [2 x i32], %struct.usb_device*, %struct.usb_bus*, %struct.usb_host_endpoint, %struct.device, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config*, %struct.usb_host_config*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %struct.atomic_t, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_tt = type { %struct.usb_device*, i32, i32, %struct.spinlock, %struct.list_head, %struct.work_struct }
%struct.usb_bus = type { %struct.device*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.usb_devmap, %struct.usb_device*, %struct.usb_bus*, %struct.list_head, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_devmap = type { [2 x i64] }
%struct.mon_bus = type opaque
%struct.usb_device_descriptor = type { i8, i8, i16, i8, i8, i8, i8, i16, i16, i16, i8, i8, i8, i8 }
%struct.usb_host_bos = type { %struct.usb_bos_descriptor*, %struct.usb_ext_cap_descriptor*, %struct.usb_ss_cap_descriptor*, %struct.usb_ss_container_id_descriptor* }
%struct.usb_bos_descriptor = type <{ i8, i8, i16, i8 }>
%struct.usb_ext_cap_descriptor = type <{ i8, i8, i8, i32 }>
%struct.usb_ss_cap_descriptor = type { i8, i8, i8, i8, i16, i8, i8, i16 }
%struct.usb_ss_container_id_descriptor = type { i8, i8, i8, i8, [16 x i8] }
%struct.usb_host_config = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_config_descriptor = type <{ i8, i8, i16, i8, i8, i8, i8, i8 }>
%struct.usb_interface_cache = type { i32, %struct.kref, [0 x %struct.usb_host_interface] }
%struct.wusb_dev = type opaque
%struct.usb3_lpm_parameters = type { i32, i32, i32, i32 }
%struct.async = type { %struct.list_head, %struct.dev_state*, %struct.pid*, %struct.cred*, i32, i32, i8*, i8*, %struct.urb*, i32, i32, i32, i8, i8 }
%struct.urb = type { %struct.kref, i8*, %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, void (%struct.urb*)*, [0 x %struct.usb_iso_packet_descriptor] }
%struct.usb_anchor = type { %struct.list_head, %struct.__wait_queue_head, %struct.spinlock, i8 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.usb_iso_packet_descriptor = type { i32, i32, i32, i32 }
%struct.usbdevfs_ctrltransfer32 = type { i8, i8, i16, i16, i16, i32, i32 }
%struct.usbdevfs_bulktransfer32 = type { i32, i32, i32, i32 }
%struct.usbdevfs_ctrltransfer = type { i8, i8, i16, i16, i16, i32, i8* }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.mm_segment_t, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.map_segment = type opaque
%struct.mm_segment_t = type { i64 }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.43 }
%union.anon.43 = type { %struct.anon.44 }
%struct.anon.44 = type { i32*, i32, i32, i32, i64, i32* }
%struct.usbdevfs_bulktransfer = type { i32, i32, i32, i8* }
%struct.usbdevfs_getdriver = type { i32, [256 x i8] }
%struct.usbdevfs_connectinfo = type { i32, i8 }
%struct.usbdevfs_setinterface = type { i32, i32 }
%struct.usbdevfs_urb = type { i8, i8, i32, i32, i8*, i32, i32, i32, i32, i32, i32, i8*, [0 x %struct.usbdevfs_iso_packet_desc] }
%struct.usbdevfs_iso_packet_desc = type { i32, i32, i32 }
%struct.usbdevfs_disconnectsignal32 = type { i32, i32 }
%struct.usbdevfs_urb32 = type { i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [0 x %struct.usbdevfs_iso_packet_desc] }
%struct.usbdevfs_ioctl32 = type { i32, i32, i32 }
%struct.usbdevfs_ioctl = type { i32, i32, i8* }
%struct.__large_struct = type { [100 x i64] }
%struct.usbdevfs_disconnectsignal = type { i32, i8* }
%struct.usbdevfs_disconnect_claim = type { i32, i32, [256 x i8] }
%struct.usb_ctrlrequest = type { i8, i8, i16, i16, i16 }
%struct.anon.37 = type { i8*, i16 }
%struct.__raw_tickets = type { i8, i8 }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }

@usbfs_mutex = global %struct.mutex { %struct.atomic_t { i32 1 }, %struct.spinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 8) to %struct.list_head*) }, %struct.task_struct* null, i8* null }, align 8
@__param_str_usbfs_snoop = internal constant [20 x i8] c"usbcore.usbfs_snoop\00", align 16
@param_ops_bool = external global %struct.kernel_param_ops, align 8
@usbfs_snoop = internal global i8 0, align 1
@__param_usbfs_snoop = internal constant %struct.kernel_param { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__param_str_usbfs_snoop, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 420, i16 -1, %union.anon.5 { i8* @usbfs_snoop } }, section "__param", align 8
@__param_str_usbfs_memory_mb = internal constant [24 x i8] c"usbcore.usbfs_memory_mb\00", align 16
@param_ops_uint = external global %struct.kernel_param_ops, align 8
@usbfs_memory_mb = internal global i32 16, align 4
@__param_usbfs_memory_mb = internal constant %struct.kernel_param { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__param_str_usbfs_memory_mb, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_uint, i16 420, i16 -1, %union.anon.5 { i8* bitcast (i32* @usbfs_memory_mb to i8*) } }, section "__param", align 8
@.str = private unnamed_addr constant [6 x i8] c"usbfs\00", align 1
@usbfs_driver = global %struct.usb_driver { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0), i32 (%struct.usb_interface*, %struct.usb_device_id*)* @driver_probe, void (%struct.usb_interface*)* @driver_disconnect, i32 (%struct.usb_interface*, i32, i8*)* null, i32 (%struct.usb_interface*, i32)* @driver_suspend, i32 (%struct.usb_interface*)* @driver_resume, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, %struct.usb_device_id* null, %struct.usb_dynids zeroinitializer, %struct.usbdrv_wrap zeroinitializer, i8 0 }, align 8
@usbdev_file_operations = constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @usbdev_lseek, i64 (%struct.file*, i8*, i64, i64*)* @usbdev_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @usbdev_poll, i64 (%struct.file*, i32, i64)* @usbdev_ioctl, i64 (%struct.file*, i32, i64)* @usbdev_compat_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.1 = private unnamed_addr constant [11 x i8] c"usb_device\00", align 1
@.str.2 = private unnamed_addr constant [44 x i8] c"\013Unable to register minors for usb_device\0A\00", align 1
@usb_device_cdev = internal global %struct.cdev zeroinitializer, align 8
@.str.3 = private unnamed_addr constant [37 x i8] c"\013Unable to get usb_device major %d\0A\00", align 1
@usbdev_nb = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @usbdev_notify, %struct.notifier_block* null, i32 0 }, align 8
@smp_ops = external global %struct.smp_ops, align 8
@current_task = external global %struct.task_struct*, align 8
@.str.4 = private unnamed_addr constant [34 x i8] c"interface number %u out of range\0A\00", align 1
@.str.5 = private unnamed_addr constant [13 x i8] c"%s: CONTROL\0A\00", align 1
@__func__.usbdev_do_ioctl = private unnamed_addr constant [16 x i8] c"usbdev_do_ioctl\00", align 1
@.str.6 = private unnamed_addr constant [10 x i8] c"%s: BULK\0A\00", align 1
@.str.7 = private unnamed_addr constant [13 x i8] c"%s: RESETEP\0A\00", align 1
@.str.8 = private unnamed_addr constant [11 x i8] c"%s: RESET\0A\00", align 1
@.str.9 = private unnamed_addr constant [16 x i8] c"%s: CLEAR_HALT\0A\00", align 1
@.str.10 = private unnamed_addr constant [15 x i8] c"%s: GETDRIVER\0A\00", align 1
@.str.11 = private unnamed_addr constant [17 x i8] c"%s: CONNECTINFO\0A\00", align 1
@.str.12 = private unnamed_addr constant [18 x i8] c"%s: SETINTERFACE\0A\00", align 1
@.str.13 = private unnamed_addr constant [22 x i8] c"%s: SETCONFIGURATION\0A\00", align 1
@.str.14 = private unnamed_addr constant [15 x i8] c"%s: SUBMITURB\0A\00", align 1
@.str.15 = private unnamed_addr constant [15 x i8] c"%s: CONTROL32\0A\00", align 1
@.str.16 = private unnamed_addr constant [12 x i8] c"%s: BULK32\0A\00", align 1
@.str.17 = private unnamed_addr constant [18 x i8] c"%s: DISCSIGNAL32\0A\00", align 1
@.str.18 = private unnamed_addr constant [17 x i8] c"%s: SUBMITURB32\0A\00", align 1
@.str.19 = private unnamed_addr constant [15 x i8] c"%s: REAPURB32\0A\00", align 1
@.str.20 = private unnamed_addr constant [21 x i8] c"%s: REAPURBNDELAY32\0A\00", align 1
@.str.21 = private unnamed_addr constant [13 x i8] c"%s: IOCTL32\0A\00", align 1
@.str.22 = private unnamed_addr constant [16 x i8] c"%s: DISCARDURB\0A\00", align 1
@.str.23 = private unnamed_addr constant [13 x i8] c"%s: REAPURB\0A\00", align 1
@.str.24 = private unnamed_addr constant [19 x i8] c"%s: REAPURBNDELAY\0A\00", align 1
@.str.25 = private unnamed_addr constant [16 x i8] c"%s: DISCSIGNAL\0A\00", align 1
@.str.26 = private unnamed_addr constant [20 x i8] c"%s: CLAIMINTERFACE\0A\00", align 1
@.str.27 = private unnamed_addr constant [22 x i8] c"%s: RELEASEINTERFACE\0A\00", align 1
@.str.28 = private unnamed_addr constant [11 x i8] c"%s: IOCTL\0A\00", align 1
@.str.29 = private unnamed_addr constant [16 x i8] c"%s: CLAIM_PORT\0A\00", align 1
@.str.30 = private unnamed_addr constant [18 x i8] c"%s: RELEASE_PORT\0A\00", align 1
@.str.31 = private unnamed_addr constant [83 x i8] c"control urb: bRequestType=%02x bRequest=%02x wValue=%04x wIndex=%04x wLength=%04x\0A\00", align 1
@.str.32 = private unnamed_addr constant [3 x i8] c"\017\00", align 1
@.str.33 = private unnamed_addr constant [66 x i8] c"usbfs: USBDEVFS_CONTROL failed cmd %s rqt %u rq %u len %u ret %d\0A\00", align 1
@.str.34 = private unnamed_addr constant [62 x i8] c"usbfs: process %d (%s) did not claim interface %u before use\0A\00", align 1
@usbfs_memory_usage = internal global %struct.atomic_t zeroinitializer, align 4
@kernel_stack = external global i64, align 8
@snoop_urb.types = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.36, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0)], align 16
@.str.35 = private unnamed_addr constant [5 x i8] c"isoc\00", align 1
@.str.36 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str.37 = private unnamed_addr constant [5 x i8] c"ctrl\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"bulk\00", align 1
@snoop_urb.dirs = internal global [2 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.39, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.40, i32 0, i32 0)], align 16
@.str.39 = private unnamed_addr constant [4 x i8] c"out\00", align 1
@.str.40 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.41 = private unnamed_addr constant [35 x i8] c"userurb %p, ep%d %s-%s, length %u\0A\00", align 1
@.str.42 = private unnamed_addr constant [52 x i8] c"userurb %p, ep%d %s-%s, actual_length %u status %d\0A\00", align 1
@.str.43 = private unnamed_addr constant [35 x i8] c"ep%d %s-%s, length %u, timeout %d\0A\00", align 1
@.str.44 = private unnamed_addr constant [41 x i8] c"ep%d %s-%s, actual_length %u, status %d\0A\00", align 1
@.str.45 = private unnamed_addr constant [7 x i8] c"data: \00", align 1
@.str.46 = private unnamed_addr constant [20 x i8] c"include/linux/usb.h\00", align 1
@.str.47 = private unnamed_addr constant [62 x i8] c"usbfs: interface %d claimed by %s while '%s' sets config #%d\0A\00", align 1
@.str.48 = private unnamed_addr constant [35 x i8] c"usbfs: usb_submit_urb returned %d\0A\00", align 1
@.str.49 = private unnamed_addr constant [28 x i8] c"include/linux/scatterlist.h\00", align 1
@phys_base = external global i64, align 8
@.str.50 = private unnamed_addr constant [14 x i8] c"urb complete\0A\00", align 1
@.str.51 = private unnamed_addr constant [21 x i8] c"disconnect by usbfs\0A\00", align 1
@.str.52 = private unnamed_addr constant [35 x i8] c"port %d claimed by process %d: %s\0A\00", align 1
@usbdev_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.53 = private unnamed_addr constant [10 x i8] c"&ps->wait\00", align 1
@.str.54 = private unnamed_addr constant [26 x i8] c"opened by process %d: %s\0A\00", align 1
@usb_bus_type = external global %struct.bus_type, align 8
@llvm.used = appending global [2 x i8*] [i8* bitcast (%struct.kernel_param* @__param_usbfs_snoop to i8*), i8* bitcast (%struct.kernel_param* @__param_usbfs_memory_mb to i8*)], section "llvm.metadata"

; Function Attrs: noinline nounwind optnone uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8
  call void %0(i32 0)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %cpu.addr = alloca i32, align 4
  store i32 %cpu, i32* %cpu.addr, align 4
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8
  %1 = load i32, i32* %cpu.addr, align 4
  call void %0(i32 %1)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %max_cpus.addr = alloca i32, align 4
  store i32 %max_cpus, i32* %max_cpus.addr, align 4
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8
  %1 = load i32, i32* %max_cpus.addr, align 4
  call void %0(i32 %1)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %cpu.addr = alloca i32, align 4
  %tidle.addr = alloca %struct.task_struct*, align 8
  store i32 %cpu, i32* %cpu.addr, align 4
  store %struct.task_struct* %tidle, %struct.task_struct** %tidle.addr, align 8
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8
  %1 = load i32, i32* %cpu.addr, align 4
  %2 = load %struct.task_struct*, %struct.task_struct** %tidle.addr, align 8
  %call = call i32 %0(i32 %1, %struct.task_struct* %2)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %max_cpus.addr = alloca i32, align 4
  store i32 %max_cpus, i32* %max_cpus.addr, align 4
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8
  %1 = load i32, i32* %max_cpus.addr, align 4
  call void %0(i32 %1)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8
  call void %0()
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @acpi_os_allocate(i64 %size) #0 {
entry:
  %size.addr = alloca i64, align 8
  %_flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %tmp1 = alloca i32, align 4
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %tmp7 = alloca i32, align 4
  %tmp8 = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  %0 = load i64, i64* %size.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %1 = load i32, i32* %tmp, align 4
  %call = call i64 @arch_local_save_flags()
  store i64 %call, i64* %_flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  store i32 1, i32* %tmp7, align 4
  %2 = load i32, i32* %tmp7, align 4
  %3 = load i64, i64* %_flags, align 8
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %3)
  store i32 %call9, i32* %tmp8, align 4
  %4 = load i32, i32* %tmp8, align 4
  store i32 %4, i32* %tmp1, align 4
  %5 = load i32, i32* %tmp1, align 4
  %tobool = icmp ne i32 %5, 0
  %6 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32, i32 208
  %call10 = call i8* @kmalloc(i64 %0, i32 %cond)
  ret i8* %call10
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @acpi_os_acquire_object(%struct.kmem_cache* %cache) #0 {
entry:
  %cache.addr = alloca %struct.kmem_cache*, align 8
  %_flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %tmp1 = alloca i32, align 4
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %tmp7 = alloca i32, align 4
  %tmp8 = alloca i32, align 4
  store %struct.kmem_cache* %cache, %struct.kmem_cache** %cache.addr, align 8
  %0 = load %struct.kmem_cache*, %struct.kmem_cache** %cache.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %1 = load i32, i32* %tmp, align 4
  %call = call i64 @arch_local_save_flags()
  store i64 %call, i64* %_flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  store i32 1, i32* %tmp7, align 4
  %2 = load i32, i32* %tmp7, align 4
  %3 = load i64, i64* %_flags, align 8
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %3)
  store i32 %call9, i32* %tmp8, align 4
  %4 = load i32, i32* %tmp8, align 4
  store i32 %4, i32* %tmp1, align 4
  %5 = load i32, i32* %tmp1, align 4
  %tobool = icmp ne i32 %5, 0
  %6 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32, i32 208
  %call10 = call i8* @kmem_cache_zalloc(%struct.kmem_cache* %0, i32 %cond)
  ret i8* %call10
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @acpi_os_get_thread_id() #0 {
entry:
  %call = call %struct.task_struct* @get_current()
  %0 = ptrtoint %struct.task_struct* %call to i64
  ret i64 %0
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @driver_probe(%struct.usb_interface* %intf, %struct.usb_device_id* %id) #0 {
entry:
  %intf.addr = alloca %struct.usb_interface*, align 8
  %id.addr = alloca %struct.usb_device_id*, align 8
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  store %struct.usb_device_id* %id, %struct.usb_device_id** %id.addr, align 8
  ret i32 -19
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @driver_disconnect(%struct.usb_interface* %intf) #0 {
entry:
  %nr.addr.i = alloca i32, align 4
  %addr.addr.i = alloca i64*, align 8
  %intf.addr = alloca %struct.usb_interface*, align 8
  %ps = alloca %struct.dev_state*, align 8
  %ifnum = alloca i32, align 4
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  %0 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %0)
  %1 = bitcast i8* %call to %struct.dev_state*
  store %struct.dev_state* %1, %struct.dev_state** %ps, align 8
  %2 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %2, i32 0, i32 0
  %3 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %3, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %4 = load i8, i8* %bInterfaceNumber, align 2
  %conv = zext i8 %4 to i32
  store i32 %conv, i32* %ifnum, align 4
  %5 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %tobool = icmp ne %struct.dev_state* %5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, i32* %ifnum, align 4
  %conv1 = zext i32 %6 to i64
  %cmp = icmp ult i64 %conv1, 64
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %7 = load i32, i32* %ifnum, align 4
  %8 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %8, i32 0, i32 11
  store i32 %7, i32* %nr.addr.i, align 4
  store i64* %ifclaimed, i64** %addr.addr.i, align 8
  %9 = load i64*, i64** %addr.addr.i, align 8
  %10 = load i32, i32* %nr.addr.i, align 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %9, i32 %10, i64* %9) #5, !srcloc !2
  br label %if.end8

if.else:                                          ; preds = %if.end
  %11 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %11, i32 0, i32 7
  %12 = load i32, i32* %ifnum, align 4
  %call7 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.4, i32 0, i32 0), i32 %12)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then6
  %13 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  call void @usb_set_intfdata(%struct.usb_interface* %13, i8* null)
  %14 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %15 = load i32, i32* %ifnum, align 4
  call void @destroy_async_on_interface(%struct.dev_state* %14, i32 %15)
  br label %return

return:                                           ; preds = %if.end8, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @driver_suspend(%struct.usb_interface* %intf, i32 %msg.coerce) #0 {
entry:
  %msg = alloca %struct.pm_message, align 4
  %intf.addr = alloca %struct.usb_interface*, align 8
  %coerce.dive = getelementptr inbounds %struct.pm_message, %struct.pm_message* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @driver_resume(%struct.usb_interface* %intf) #0 {
entry:
  %intf.addr = alloca %struct.usb_interface*, align 8
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @usbdev_lseek(%struct.file* %file, i64 %offset, i32 %orig) #0 {
entry:
  %file.addr = alloca %struct.file*, align 8
  %offset.addr = alloca i64, align 8
  %orig.addr = alloca i32, align 4
  %ret = alloca i64, align 8
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i32 %orig, i32* %orig.addr, align 4
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %call = call %struct.inode* @file_inode(%struct.file* %0)
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_lock(%struct.mutex* %i_mutex)
  %1 = load i32, i32* %orig.addr, align 4
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %1, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %1, 2
  br i1 %Pivot, label %sw.bb2, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %1, 2
  br i1 %SwitchLeaf2, label %sw.bb5, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %1, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %2 = load i64, i64* %offset.addr, align 8
  %3 = load %struct.file*, %struct.file** %file.addr, align 8
  %f_pos = getelementptr inbounds %struct.file, %struct.file* %3, i32 0, i32 9
  store i64 %2, i64* %f_pos, align 8
  %4 = load %struct.file*, %struct.file** %file.addr, align 8
  %f_pos1 = getelementptr inbounds %struct.file, %struct.file* %4, i32 0, i32 9
  %5 = load i64, i64* %f_pos1, align 8
  store i64 %5, i64* %ret, align 8
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock
  %6 = load i64, i64* %offset.addr, align 8
  %7 = load %struct.file*, %struct.file** %file.addr, align 8
  %f_pos3 = getelementptr inbounds %struct.file, %struct.file* %7, i32 0, i32 9
  %8 = load i64, i64* %f_pos3, align 8
  %add = add nsw i64 %8, %6
  store i64 %add, i64* %f_pos3, align 8
  %9 = load %struct.file*, %struct.file** %file.addr, align 8
  %f_pos4 = getelementptr inbounds %struct.file, %struct.file* %9, i32 0, i32 9
  %10 = load i64, i64* %f_pos4, align 8
  store i64 %10, i64* %ret, align 8
  br label %sw.epilog

sw.bb5:                                           ; preds = %LeafBlock1
  br label %sw.default

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault, %sw.bb5
  store i64 -22, i64* %ret, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb2, %sw.bb
  %11 = load %struct.file*, %struct.file** %file.addr, align 8
  %call6 = call %struct.inode* @file_inode(%struct.file* %11)
  %i_mutex7 = getelementptr inbounds %struct.inode, %struct.inode* %call6, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex7)
  %12 = load i64, i64* %ret, align 8
  ret i64 %12
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @usbdev_read(%struct.file* %file, i8* %buf, i64 %nbytes, i64* %ppos) #0 {
entry:
  %dst.addr.i98 = alloca i8*, align 8
  %src.addr.i99 = alloca i8*, align 8
  %size.addr.i100 = alloca i32, align 4
  %dst.addr.i = alloca i8*, align 8
  %src.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %file.addr = alloca %struct.file*, align 8
  %buf.addr = alloca i8*, align 8
  %nbytes.addr = alloca i64, align 8
  %ppos.addr = alloca i64*, align 8
  %ps = alloca %struct.dev_state*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %ret = alloca i64, align 8
  %len = alloca i32, align 4
  %pos = alloca i64, align 8
  %i = alloca i32, align 4
  %temp_desc = alloca %struct.usb_device_descriptor, align 1
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  %tmp = alloca i8*, align 8
  %config = alloca %struct.usb_config_descriptor*, align 8
  %length = alloca i32, align 4
  %alloclen = alloca i32, align 4
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %tmp78 = alloca i32, align 4
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store i8* %buf, i8** %buf.addr, align 8
  store i64 %nbytes, i64* %nbytes.addr, align 8
  store i64* %ppos, i64** %ppos.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8
  %2 = bitcast i8* %1 to %struct.dev_state*
  store %struct.dev_state* %2, %struct.dev_state** %ps, align 8
  %3 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %4, %struct.usb_device** %dev, align 8
  store i64 0, i64* %ret, align 8
  %5 = load i64*, i64** %ppos.addr, align 8
  %6 = load i64, i64* %5, align 8
  store i64 %6, i64* %pos, align 8
  %7 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  %8 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %call = call i32 @connected(%struct.dev_state* %8)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i64 -19, i64* %ret, align 8
  br label %err

if.else:                                          ; preds = %entry
  %9 = load i64, i64* %pos, align 8
  %cmp = icmp slt i64 %9, 0
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  store i64 -22, i64* %ret, align 8
  br label %err

if.end:                                           ; preds = %if.else
  br label %if.end4

if.end4:                                          ; preds = %if.end
  %10 = load i64, i64* %pos, align 8
  %cmp5 = icmp ult i64 %10, 18
  br i1 %cmp5, label %if.then6, label %if.end35

if.then6:                                         ; preds = %if.end4
  store i64 18, i64* %__len, align 8
  %11 = load i64, i64* %__len, align 8
  %cmp7 = icmp uge i64 %11, 64
  br i1 %cmp7, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.then6
  %12 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %13 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 12
  %14 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  %15 = load i64, i64* %__len, align 8
  %call9 = call i8* @__memcpy(i8* %12, i8* %14, i64 %15)
  store i8* %call9, i8** %__ret, align 8
  br label %if.end12

if.else10:                                        ; preds = %if.then6
  %16 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %17 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %descriptor11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 12
  %18 = bitcast %struct.usb_device_descriptor* %descriptor11 to i8*
  %19 = load i64, i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %18, i64 %19, i32 1, i1 false)
  store i8* %16, i8** %__ret, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.else10, %if.then8
  %20 = load i8*, i8** %__ret, align 8
  store i8* %20, i8** %tmp, align 8
  %21 = load i8*, i8** %tmp, align 8
  br label %do.body

do.body:                                          ; preds = %if.end12
  %bcdUSB = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 2
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body13

do.body13:                                        ; preds = %do.end
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 7
  br label %do.end14

do.end14:                                         ; preds = %do.body13
  br label %do.body15

do.body15:                                        ; preds = %do.end14
  %idProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 8
  br label %do.end16

do.end16:                                         ; preds = %do.body15
  br label %do.body17

do.body17:                                        ; preds = %do.end16
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 9
  br label %do.end18

do.end18:                                         ; preds = %do.body17
  %22 = load i64, i64* %pos, align 8
  %sub = sub i64 18, %22
  %conv = trunc i64 %sub to i32
  store i32 %conv, i32* %len, align 4
  %23 = load i32, i32* %len, align 4
  %conv19 = zext i32 %23 to i64
  %24 = load i64, i64* %nbytes.addr, align 8
  %cmp20 = icmp ugt i64 %conv19, %24
  br i1 %cmp20, label %if.then22, label %if.end24

if.then22:                                        ; preds = %do.end18
  %25 = load i64, i64* %nbytes.addr, align 8
  %conv23 = trunc i64 %25 to i32
  store i32 %conv23, i32* %len, align 4
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %do.end18
  %26 = load i8*, i8** %buf.addr, align 8
  %27 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %28 = load i64, i64* %pos, align 8
  %add.ptr = getelementptr inbounds i8, i8* %27, i64 %28
  %29 = load i32, i32* %len, align 4
  store i8* %26, i8** %dst.addr.i, align 8
  store i8* %add.ptr, i8** %src.addr.i, align 8
  store i32 %29, i32* %size.addr.i, align 4
  call void @might_fault() #5
  %30 = load i8*, i8** %dst.addr.i, align 8
  %31 = load i8*, i8** %src.addr.i, align 8
  %32 = load i32, i32* %size.addr.i, align 4
  %call.i = call i64 @_copy_to_user(i8* %30, i8* %31, i32 %32) #5
  %conv.i = trunc i64 %call.i to i32
  %tobool26 = icmp ne i32 %conv.i, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end24
  store i64 -14, i64* %ret, align 8
  br label %err

if.end28:                                         ; preds = %if.end24
  %33 = load i32, i32* %len, align 4
  %conv29 = zext i32 %33 to i64
  %34 = load i64*, i64** %ppos.addr, align 8
  %35 = load i64, i64* %34, align 8
  %add = add nsw i64 %35, %conv29
  store i64 %add, i64* %34, align 8
  %36 = load i32, i32* %len, align 4
  %37 = load i8*, i8** %buf.addr, align 8
  %idx.ext = zext i32 %36 to i64
  %add.ptr30 = getelementptr inbounds i8, i8* %37, i64 %idx.ext
  store i8* %add.ptr30, i8** %buf.addr, align 8
  %38 = load i32, i32* %len, align 4
  %conv31 = zext i32 %38 to i64
  %39 = load i64, i64* %nbytes.addr, align 8
  %sub32 = sub i64 %39, %conv31
  store i64 %sub32, i64* %nbytes.addr, align 8
  %40 = load i32, i32* %len, align 4
  %conv33 = zext i32 %40 to i64
  %41 = load i64, i64* %ret, align 8
  %add34 = add nsw i64 %41, %conv33
  store i64 %add34, i64* %ret, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.end28, %if.end4
  store i64 18, i64* %pos, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end35
  %42 = load i64, i64* %nbytes.addr, align 8
  %tobool36 = icmp ne i64 %42, 0
  br i1 %tobool36, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %43 = load i32, i32* %i, align 4
  %44 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %descriptor37 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %44, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor37, i32 0, i32 13
  %45 = load i8, i8* %bNumConfigurations, align 1
  %conv38 = zext i8 %45 to i32
  %cmp39 = icmp slt i32 %43, %conv38
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %46 = phi i1 [ false, %for.cond ], [ %cmp39, %land.rhs ]
  br i1 %46, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %47 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %47, i32 0, i32 18
  %48 = load i8**, i8*** %rawdescriptors, align 8
  %49 = load i32, i32* %i, align 4
  %idxprom = sext i32 %49 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %48, i64 %idxprom
  %50 = load i8*, i8** %arrayidx, align 8
  %51 = bitcast i8* %50 to %struct.usb_config_descriptor*
  store %struct.usb_config_descriptor* %51, %struct.usb_config_descriptor** %config, align 8
  %52 = load %struct.usb_config_descriptor*, %struct.usb_config_descriptor** %config, align 8
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %52, i32 0, i32 2
  %53 = load i16, i16* %wTotalLength, align 1
  %conv41 = zext i16 %53 to i32
  store i32 %conv41, i32* %length, align 4
  %54 = load i64*, i64** %ppos.addr, align 8
  %55 = load i64, i64* %54, align 8
  %56 = load i64, i64* %pos, align 8
  %57 = load i32, i32* %length, align 4
  %conv42 = zext i32 %57 to i64
  %add43 = add nsw i64 %56, %conv42
  %cmp44 = icmp slt i64 %55, %add43
  br i1 %cmp44, label %if.then46, label %if.end94

if.then46:                                        ; preds = %for.body
  %58 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %config47 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %58, i32 0, i32 14
  %59 = load %struct.usb_host_config*, %struct.usb_host_config** %config47, align 8
  %60 = load i32, i32* %i, align 4
  %idxprom48 = sext i32 %60 to i64
  %arrayidx49 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %59, i64 %idxprom48
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx49, i32 0, i32 0
  %wTotalLength50 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 2
  %61 = load i16, i16* %wTotalLength50, align 2
  %conv51 = zext i16 %61 to i32
  store i32 %conv51, i32* %alloclen, align 4
  %62 = load i32, i32* %length, align 4
  %conv52 = zext i32 %62 to i64
  %63 = load i64*, i64** %ppos.addr, align 8
  %64 = load i64, i64* %63, align 8
  %65 = load i64, i64* %pos, align 8
  %sub53 = sub nsw i64 %64, %65
  %sub54 = sub nsw i64 %conv52, %sub53
  %conv55 = trunc i64 %sub54 to i32
  store i32 %conv55, i32* %len, align 4
  %66 = load i32, i32* %len, align 4
  %conv56 = zext i32 %66 to i64
  %67 = load i64, i64* %nbytes.addr, align 8
  %cmp57 = icmp ugt i64 %conv56, %67
  br i1 %cmp57, label %if.then59, label %if.end61

if.then59:                                        ; preds = %if.then46
  %68 = load i64, i64* %nbytes.addr, align 8
  %conv60 = trunc i64 %68 to i32
  store i32 %conv60, i32* %len, align 4
  br label %if.end61

if.end61:                                         ; preds = %if.then59, %if.then46
  %69 = load i32, i32* %alloclen, align 4
  %conv62 = zext i32 %69 to i64
  %70 = load i64*, i64** %ppos.addr, align 8
  %71 = load i64, i64* %70, align 8
  %72 = load i64, i64* %pos, align 8
  %sub63 = sub nsw i64 %71, %72
  %cmp64 = icmp sgt i64 %conv62, %sub63
  br i1 %cmp64, label %if.then66, label %if.end85

if.then66:                                        ; preds = %if.end61
  %73 = load i64*, i64** %ppos.addr, align 8
  %74 = load i64, i64* %73, align 8
  %75 = load i64, i64* %pos, align 8
  %sub67 = sub nsw i64 %74, %75
  %76 = load i32, i32* %alloclen, align 4
  %conv68 = zext i32 %76 to i64
  %sub69 = sub nsw i64 %conv68, %sub67
  %conv70 = trunc i64 %sub69 to i32
  store i32 %conv70, i32* %alloclen, align 4
  %77 = load i8*, i8** %buf.addr, align 8
  %78 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %rawdescriptors71 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %78, i32 0, i32 18
  %79 = load i8**, i8*** %rawdescriptors71, align 8
  %80 = load i32, i32* %i, align 4
  %idxprom72 = sext i32 %80 to i64
  %arrayidx73 = getelementptr inbounds i8*, i8** %79, i64 %idxprom72
  %81 = load i8*, i8** %arrayidx73, align 8
  %82 = load i64*, i64** %ppos.addr, align 8
  %83 = load i64, i64* %82, align 8
  %84 = load i64, i64* %pos, align 8
  %sub74 = sub nsw i64 %83, %84
  %add.ptr75 = getelementptr inbounds i8, i8* %81, i64 %sub74
  %85 = load i32, i32* %len, align 4
  store i32 %85, i32* %_min1, align 4
  %86 = load i32, i32* %alloclen, align 4
  store i32 %86, i32* %_min2, align 4
  %cmp76 = icmp eq i32* %_min1, %_min2
  %conv77 = zext i1 %cmp76 to i32
  %87 = load i32, i32* %_min1, align 4
  %88 = load i32, i32* %_min2, align 4
  %cmp79 = icmp ult i32 %87, %88
  br i1 %cmp79, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then66
  %89 = load i32, i32* %_min1, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then66
  %90 = load i32, i32* %_min2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %89, %cond.true ], [ %90, %cond.false ]
  store i32 %cond, i32* %tmp78, align 4
  %91 = load i32, i32* %tmp78, align 4
  store i8* %77, i8** %dst.addr.i98, align 8
  store i8* %add.ptr75, i8** %src.addr.i99, align 8
  store i32 %91, i32* %size.addr.i100, align 4
  call void @might_fault() #5
  %92 = load i8*, i8** %dst.addr.i98, align 8
  %93 = load i8*, i8** %src.addr.i99, align 8
  %94 = load i32, i32* %size.addr.i100, align 4
  %call.i101 = call i64 @_copy_to_user(i8* %92, i8* %93, i32 %94) #5
  %conv.i102 = trunc i64 %call.i101 to i32
  %tobool82 = icmp ne i32 %conv.i102, 0
  br i1 %tobool82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %cond.end
  store i64 -14, i64* %ret, align 8
  br label %err

if.end84:                                         ; preds = %cond.end
  br label %if.end85

if.end85:                                         ; preds = %if.end84, %if.end61
  %95 = load i32, i32* %len, align 4
  %conv86 = zext i32 %95 to i64
  %96 = load i64*, i64** %ppos.addr, align 8
  %97 = load i64, i64* %96, align 8
  %add87 = add nsw i64 %97, %conv86
  store i64 %add87, i64* %96, align 8
  %98 = load i32, i32* %len, align 4
  %99 = load i8*, i8** %buf.addr, align 8
  %idx.ext88 = zext i32 %98 to i64
  %add.ptr89 = getelementptr inbounds i8, i8* %99, i64 %idx.ext88
  store i8* %add.ptr89, i8** %buf.addr, align 8
  %100 = load i32, i32* %len, align 4
  %conv90 = zext i32 %100 to i64
  %101 = load i64, i64* %nbytes.addr, align 8
  %sub91 = sub i64 %101, %conv90
  store i64 %sub91, i64* %nbytes.addr, align 8
  %102 = load i32, i32* %len, align 4
  %conv92 = zext i32 %102 to i64
  %103 = load i64, i64* %ret, align 8
  %add93 = add nsw i64 %103, %conv92
  store i64 %add93, i64* %ret, align 8
  br label %if.end94

if.end94:                                         ; preds = %if.end85, %for.body
  %104 = load i32, i32* %length, align 4
  %conv95 = zext i32 %104 to i64
  %105 = load i64, i64* %pos, align 8
  %add96 = add nsw i64 %105, %conv95
  store i64 %add96, i64* %pos, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end94
  %106 = load i32, i32* %i, align 4
  %inc = add nsw i32 %106, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  br label %err

err:                                              ; preds = %for.end, %if.then83, %if.then27, %if.then3, %if.then
  %107 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev97 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %107, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev97)
  %108 = load i64, i64* %ret, align 8
  ret i64 %108
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbdev_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %file.addr = alloca %struct.file*, align 8
  %wait.addr = alloca %struct.poll_table_struct*, align 8
  %ps = alloca %struct.dev_state*, align 8
  %mask = alloca i32, align 4
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store %struct.poll_table_struct* %wait, %struct.poll_table_struct** %wait.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8
  %2 = bitcast i8* %1 to %struct.dev_state*
  store %struct.dev_state* %2, %struct.dev_state** %ps, align 8
  store i32 0, i32* %mask, align 4
  %3 = load %struct.file*, %struct.file** %file.addr, align 8
  %4 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %wait1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %4, i32 0, i32 6
  %5 = load %struct.poll_table_struct*, %struct.poll_table_struct** %wait.addr, align 8
  call void @poll_wait(%struct.file* %3, %struct.__wait_queue_head* %wait1, %struct.poll_table_struct* %5)
  %6 = load %struct.file*, %struct.file** %file.addr, align 8
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %6, i32 0, i32 8
  %7 = load i32, i32* %f_mode, align 4
  %and = and i32 %7, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %8, i32 0, i32 5
  %call = call i32 @list_empty(%struct.list_head* %async_completed)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %9 = load i32, i32* %mask, align 4
  %or = or i32 %9, 260
  store i32 %or, i32* %mask, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %10 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %call3 = call i32 @connected(%struct.dev_state* %10)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %11 = load i32, i32* %mask, align 4
  %or6 = or i32 %11, 24
  store i32 %or6, i32* %mask, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %12 = load i32, i32* %mask, align 4
  ret i32 %12
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @usbdev_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %file.addr = alloca %struct.file*, align 8
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %ret = alloca i32, align 4
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store i32 %cmd, i32* %cmd.addr, align 4
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %1 = load i32, i32* %cmd.addr, align 4
  %2 = load i64, i64* %arg.addr, align 8
  %3 = inttoptr i64 %2 to i8*
  %call = call i64 @usbdev_do_ioctl(%struct.file* %0, i32 %1, i8* %3)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %ret, align 4
  %4 = load i32, i32* %ret, align 4
  %conv1 = sext i32 %4 to i64
  ret i64 %conv1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @usbdev_compat_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %file.addr = alloca %struct.file*, align 8
  %cmd.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %ret = alloca i32, align 4
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store i32 %cmd, i32* %cmd.addr, align 4
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %1 = load i32, i32* %cmd.addr, align 4
  %2 = load i64, i64* %arg.addr, align 8
  %conv = trunc i64 %2 to i32
  %call = call i8* @compat_ptr(i32 %conv)
  %call1 = call i64 @usbdev_do_ioctl(%struct.file* %0, i32 %1, i8* %call)
  %conv2 = trunc i64 %call1 to i32
  store i32 %conv2, i32* %ret, align 4
  %3 = load i32, i32* %ret, align 4
  %conv3 = sext i32 %3 to i64
  ret i64 %conv3
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbdev_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %pfo_ret__.i52 = alloca %struct.task_struct*, align 8
  %tmp.i53 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i50 = alloca %struct.task_struct*, align 8
  %tmp.i51 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i48 = alloca %struct.task_struct*, align 8
  %tmp.i49 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i46 = alloca %struct.task_struct*, align 8
  %tmp.i47 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %inode.addr = alloca %struct.inode*, align 8
  %file.addr = alloca %struct.file*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %ps = alloca %struct.dev_state*, align 8
  %ret = alloca i32, align 4
  %.compoundliteral = alloca %struct.raw_spinlock, align 2
  %tmp = alloca %struct.cred*, align 8
  store %struct.inode* %inode, %struct.inode** %inode.addr, align 8
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store %struct.usb_device* null, %struct.usb_device** %dev, align 8
  store i32 -12, i32* %ret, align 4
  store i64 144, i64* %size.addr.i, align 8
  store i32 208, i32* %flags.addr.i, align 4
  %0 = load i64, i64* %size.addr.i, align 8
  %1 = load i32, i32* %flags.addr.i, align 4
  %call.i = call i8* @__kmalloc(i64 %0, i32 %1) #5
  %2 = bitcast i8* %call.i to %struct.dev_state*
  store %struct.dev_state* %2, %struct.dev_state** %ps, align 8
  %3 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %tobool = icmp ne %struct.dev_state* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %out_free_ps

if.end:                                           ; preds = %entry
  store i32 -19, i32* %ret, align 4
  call void @mutex_lock(%struct.mutex* @usbfs_mutex)
  %4 = load %struct.inode*, %struct.inode** %inode.addr, align 8
  %call1 = call i32 @imajor(%struct.inode* %4)
  %cmp = icmp eq i32 %call1, 189
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %5 = load %struct.inode*, %struct.inode** %inode.addr, align 8
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %5, i32 0, i32 13
  %6 = load i32, i32* %i_rdev, align 4
  %call3 = call %struct.usb_device* @usbdev_lookup_by_devt(i32 %6)
  store %struct.usb_device* %call3, %struct.usb_device** %dev, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  call void @mutex_unlock(%struct.mutex* @usbfs_mutex)
  %7 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %tobool5 = icmp ne %struct.usb_device* %7, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end4
  br label %out_free_ps

if.end7:                                          ; preds = %if.end4
  %8 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  call void @device_lock(%struct.device* %dev8)
  %9 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %9, i32 0, i32 3
  %10 = load i32, i32* %state, align 8
  %cmp9 = icmp eq i32 %10, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  br label %out_unlock_device

if.end11:                                         ; preds = %if.end7
  %11 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %call12 = call i32 @usb_autoresume_device(%struct.usb_device* %11)
  store i32 %call12, i32* %ret, align 4
  %12 = load i32, i32* %ret, align 4
  %tobool13 = icmp ne i32 %12, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end11
  br label %out_unlock_device

if.end15:                                         ; preds = %if.end11
  %13 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %14 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %dev16 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 1
  store %struct.usb_device* %13, %struct.usb_device** %dev16, align 8
  %15 = load %struct.file*, %struct.file** %file.addr, align 8
  %16 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %file17 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %16, i32 0, i32 2
  store %struct.file* %15, %struct.file** %file17, align 8
  br label %do.body

do.body:                                          ; preds = %if.end15
  %17 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %17, i32 0, i32 3
  %call18 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  br label %do.body19

do.body19:                                        ; preds = %do.body
  %18 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %lock20 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %18, i32 0, i32 3
  %19 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock20, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %19 to %struct.raw_spinlock*
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %.compoundliteral, i32 0, i32 0
  %20 = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %raw_lock, i32 0, i32 0
  %head_tail = bitcast %union.anon.1* %20 to i16*
  store i16 0, i16* %head_tail, align 2
  %21 = bitcast %struct.raw_spinlock* %rlock to i8*
  %22 = bitcast %struct.raw_spinlock* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 2, i32 2, i1 false)
  br label %do.end

do.end:                                           ; preds = %do.body19
  br label %do.end21

do.end21:                                         ; preds = %do.end
  %23 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %23, i32 0, i32 0
  call void @INIT_LIST_HEAD(%struct.list_head* %list)
  %24 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %24, i32 0, i32 4
  call void @INIT_LIST_HEAD(%struct.list_head* %async_pending)
  %25 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %25, i32 0, i32 5
  call void @INIT_LIST_HEAD(%struct.list_head* %async_completed)
  br label %do.body22

do.body22:                                        ; preds = %do.end21
  %26 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %wait = getelementptr inbounds %struct.dev_state, %struct.dev_state* %26, i32 0, i32 6
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.53, i32 0, i32 0), %struct.lock_class_key* @usbdev_open.__key)
  br label %do.end23

do.end23:                                         ; preds = %do.body22
  %27 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %27, i32 0, i32 7
  store i32 0, i32* %discsignr, align 8
  %28 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %28, %struct.task_struct** %pfo_ret__.i, align 8
  %29 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %29, %struct.task_struct** %tmp.i, align 8
  %30 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call25 = call %struct.pid* @task_pid(%struct.task_struct* %30)
  %call26 = call %struct.pid* @get_pid(%struct.pid* %call25)
  %31 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %disc_pid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %31, i32 0, i32 8
  store %struct.pid* %call26, %struct.pid** %disc_pid, align 8
  br label %do.body27

do.body27:                                        ; preds = %do.end23
  br label %do.end28

do.end28:                                         ; preds = %do.body27
  %32 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %32, %struct.task_struct** %pfo_ret__.i46, align 8
  %33 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i46, align 8
  store %struct.task_struct* %33, %struct.task_struct** %tmp.i47, align 8
  %34 = load %struct.task_struct*, %struct.task_struct** %tmp.i47, align 8
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %34, i32 0, i32 63
  %35 = load %struct.cred*, %struct.cred** %cred, align 8
  store %struct.cred* %35, %struct.cred** %tmp, align 8
  %36 = load %struct.cred*, %struct.cred** %tmp, align 8
  %call30 = call %struct.cred* @get_cred(%struct.cred* %36)
  %37 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %cred31 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %37, i32 0, i32 9
  store %struct.cred* %call30, %struct.cred** %cred31, align 8
  %38 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %38, i32 0, i32 10
  store i8* null, i8** %disccontext, align 8
  %39 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %39, i32 0, i32 11
  store i64 0, i64* %ifclaimed, align 8
  %40 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %40, %struct.task_struct** %pfo_ret__.i48, align 8
  %41 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i48, align 8
  store %struct.task_struct* %41, %struct.task_struct** %tmp.i49, align 8
  %42 = load %struct.task_struct*, %struct.task_struct** %tmp.i49, align 8
  %43 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %secid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %43, i32 0, i32 12
  call void @security_task_getsecid(%struct.task_struct* %42, i32* %secid)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !4
  %44 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %list33 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %44, i32 0, i32 0
  %45 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %45, i32 0, i32 27
  call void @list_add_tail(%struct.list_head* %list33, %struct.list_head* %filelist)
  %46 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %47 = bitcast %struct.dev_state* %46 to i8*
  %48 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %48, i32 0, i32 15
  store i8* %47, i8** %private_data, align 8
  %49 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %49, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev34)
  br label %do.body35

do.body35:                                        ; preds = %do.end28
  %50 = load i8, i8* @usbfs_snoop, align 1
  %tobool36 = trunc i8 %50 to i1
  br i1 %tobool36, label %if.then37, label %if.end43

if.then37:                                        ; preds = %do.body35
  %51 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev38 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %51, i32 0, i32 11
  %52 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %52, %struct.task_struct** %pfo_ret__.i50, align 8
  %53 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i50, align 8
  store %struct.task_struct* %53, %struct.task_struct** %tmp.i51, align 8
  %54 = load %struct.task_struct*, %struct.task_struct** %tmp.i51, align 8
  %call40 = call i32 @task_pid_nr(%struct.task_struct* %54)
  %55 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %55, %struct.task_struct** %pfo_ret__.i52, align 8
  %56 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i52, align 8
  store %struct.task_struct* %56, %struct.task_struct** %tmp.i53, align 8
  %57 = load %struct.task_struct*, %struct.task_struct** %tmp.i53, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %57, i32 0, i32 64
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %call42 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev38, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.54, i32 0, i32 0), i32 %call40, i8* %arraydecay)
  br label %if.end43

if.end43:                                         ; preds = %if.then37, %do.body35
  br label %do.end44

do.end44:                                         ; preds = %if.end43
  %58 = load i32, i32* %ret, align 4
  store i32 %58, i32* %retval, align 4
  br label %return

out_unlock_device:                                ; preds = %if.then14, %if.then10
  %59 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev45 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %59, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev45)
  %60 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  call void @usb_put_dev(%struct.usb_device* %60)
  br label %out_free_ps

out_free_ps:                                      ; preds = %out_unlock_device, %if.then6, %if.then
  %61 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %62 = bitcast %struct.dev_state* %61 to i8*
  call void @kfree(i8* %62)
  %63 = load i32, i32* %ret, align 4
  store i32 %63, i32* %retval, align 4
  br label %return

return:                                           ; preds = %out_free_ps, %do.end44
  %64 = load i32, i32* %retval, align 4
  ret i32 %64
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbdev_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %nr.addr.i = alloca i32, align 4
  %addr.addr.i = alloca i64*, align 8
  %inode.addr = alloca %struct.inode*, align 8
  %file.addr = alloca %struct.file*, align 8
  %ps = alloca %struct.dev_state*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %ifnum = alloca i32, align 4
  %as = alloca %struct.async*, align 8
  store %struct.inode* %inode, %struct.inode** %inode.addr, align 8
  store %struct.file* %file, %struct.file** %file.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8
  %2 = bitcast i8* %1 to %struct.dev_state*
  store %struct.dev_state* %2, %struct.dev_state** %ps, align 8
  %3 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %4, %struct.usb_device** %dev, align 8
  %5 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %5, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  %6 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %7 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  call void @usb_hub_release_all_ports(%struct.usb_device* %6, %struct.dev_state* %7)
  %8 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %8, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %list)
  store i32 0, i32* %ifnum, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %9, i32 0, i32 11
  %10 = load i64, i64* %ifclaimed, align 8
  %tobool = icmp ne i64 %10, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %11 = load i32, i32* %ifnum, align 4
  %conv = zext i32 %11 to i64
  %cmp = icmp ult i64 %conv, 64
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %12 = phi i1 [ false, %for.cond ], [ %cmp, %land.rhs ]
  br i1 %12, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %13 = load i32, i32* %ifnum, align 4
  %14 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %ifclaimed4 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 11
  store i32 %13, i32* %nr.addr.i, align 4
  store i64* %ifclaimed4, i64** %addr.addr.i, align 8
  %15 = load i32, i32* %nr.addr.i, align 4
  %rem.i = urem i32 %15, 64
  %sh_prom.i = zext i32 %rem.i to i64
  %shl.i = shl i64 1, %sh_prom.i
  %16 = load i64*, i64** %addr.addr.i, align 8
  %17 = load i32, i32* %nr.addr.i, align 4
  %div.i = udiv i32 %17, 64
  %idxprom.i = zext i32 %div.i to i64
  %arrayidx.i = getelementptr inbounds i64, i64* %16, i64 %idxprom.i
  %18 = load volatile i64, i64* %arrayidx.i, align 8
  %and.i = and i64 %shl.i, %18
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool5 = icmp ne i32 %conv.i, 0
  br i1 %tobool5, label %if.then, label %if.end

cond.false:                                       ; preds = %for.body
  %19 = load i32, i32* %ifnum, align 4
  %20 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %ifclaimed6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %20, i32 0, i32 11
  %call7 = call i32 @variable_test_bit(i32 %19, i64* %ifclaimed6)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %cond.false, %cond.true
  %21 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %22 = load i32, i32* %ifnum, align 4
  %call9 = call i32 @releaseintf(%struct.dev_state* %21, i32 %22)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.false, %cond.true
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %23 = load i32, i32* %ifnum, align 4
  %inc = add i32 %23, 1
  store i32 %inc, i32* %ifnum, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  %24 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  call void @destroy_all_async(%struct.dev_state* %24)
  br label %do.body

do.body:                                          ; preds = %for.end
  br label %do.end

do.end:                                           ; preds = %do.body
  %25 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %25, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev10)
  %26 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  call void @usb_put_dev(%struct.usb_device* %26)
  %27 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %disc_pid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %27, i32 0, i32 8
  %28 = load %struct.pid*, %struct.pid** %disc_pid, align 8
  call void @put_pid(%struct.pid* %28)
  %29 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %cred = getelementptr inbounds %struct.dev_state, %struct.dev_state* %29, i32 0, i32 9
  %30 = load %struct.cred*, %struct.cred** %cred, align 8
  call void @put_cred(%struct.cred* %30)
  %31 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %call11 = call %struct.async* @async_getcompleted(%struct.dev_state* %31)
  store %struct.async* %call11, %struct.async** %as, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %do.end
  %32 = load %struct.async*, %struct.async** %as, align 8
  %tobool12 = icmp ne %struct.async* %32, null
  br i1 %tobool12, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %33 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %33)
  %34 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %call13 = call %struct.async* @async_getcompleted(%struct.dev_state* %34)
  store %struct.async* %call13, %struct.async** %as, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %35 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %36 = bitcast %struct.dev_state* %35 to i8*
  call void @kfree(i8* %36)
  ret i32 0
}

; Function Attrs: noinline nounwind optnone uwtable
define i32 @usb_devio_init() #0 section ".init.text" {
entry:
  %retval1 = alloca i32, align 4
  %call = call i32 @register_chrdev_region(i32 198180864, i32 8192, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i32 0, i32 0))
  store i32 %call, i32* %retval1, align 4
  %0 = load i32, i32* %retval1, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.2, i32 0, i32 0))
  br label %out

if.end:                                           ; preds = %entry
  call void @cdev_init(%struct.cdev* @usb_device_cdev, %struct.file_operations* @usbdev_file_operations)
  %call3 = call i32 @cdev_add(%struct.cdev* @usb_device_cdev, i32 198180864, i32 8192)
  store i32 %call3, i32* %retval1, align 4
  %1 = load i32, i32* %retval1, align 4
  %tobool4 = icmp ne i32 %1, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.3, i32 0, i32 0), i32 189)
  br label %error_cdev

if.end7:                                          ; preds = %if.end
  call void @usb_register_notify(%struct.notifier_block* @usbdev_nb)
  br label %out

out:                                              ; preds = %error_cdev, %if.end7, %if.then
  %2 = load i32, i32* %retval1, align 4
  ret i32 %2

error_cdev:                                       ; preds = %if.then5
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  br label %out
}

declare i32 @register_chrdev_region(i32, i32, i8*) #1

declare i32 @printk(i8*, ...) #1

declare void @cdev_init(%struct.cdev*, %struct.file_operations*) #1

declare i32 @cdev_add(%struct.cdev*, i32, i32) #1

declare void @usb_register_notify(%struct.notifier_block*) #1

declare void @unregister_chrdev_region(i32, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define void @usb_devio_cleanup() #0 {
entry:
  call void @usb_unregister_notify(%struct.notifier_block* @usbdev_nb)
  call void @cdev_del(%struct.cdev* @usb_device_cdev)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  ret void
}

declare void @usb_unregister_notify(%struct.notifier_block*) #1

declare void @cdev_del(%struct.cdev*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #2 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @arch_local_save_flags() #0 {
entry:
  %call = call i64 @native_save_fl()
  ret i64 %call
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @arch_irqs_disabled_flags(i64 %flags) #0 {
entry:
  %flags.addr = alloca i64, align 8
  store i64 %flags, i64* %flags.addr, align 8
  %0 = load i64, i64* %flags.addr, align 8
  %and = and i64 %0, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare i8* @__kmalloc(i64, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @native_save_fl() #0 {
entry:
  %flags = alloca i64, align 8
  call void asm sideeffect "# __raw_save_flags\0A\09pushf ; pop $0", "=*rm,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags) #5, !srcloc !5
  %0 = load i64, i64* %flags, align 8
  ret i64 %0
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @kmem_cache_zalloc(%struct.kmem_cache* %k, i32 %flags) #0 {
entry:
  %k.addr = alloca %struct.kmem_cache*, align 8
  %flags.addr = alloca i32, align 4
  store %struct.kmem_cache* %k, %struct.kmem_cache** %k.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load %struct.kmem_cache*, %struct.kmem_cache** %k.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %or = or i32 %1, 32768
  %call = call i8* @kmem_cache_alloc(%struct.kmem_cache* %0, i32 %or)
  ret i8* %call
}

declare i8* @kmem_cache_alloc(%struct.kmem_cache*, i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #2 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  ret %struct.task_struct* %0
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @usb_get_intfdata(%struct.usb_interface* %intf) #0 {
entry:
  %intf.addr = alloca %struct.usb_interface*, align 8
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  %0 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 7
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare i32 @dev_warn(%struct.device*, i8*, ...) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @usb_set_intfdata(%struct.usb_interface* %intf, i8* %data) #0 {
entry:
  %intf.addr = alloca %struct.usb_interface*, align 8
  %data.addr = alloca i8*, align 8
  store %struct.usb_interface* %intf, %struct.usb_interface** %intf.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load %struct.usb_interface*, %struct.usb_interface** %intf.addr, align 8
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 7
  %1 = load i8*, i8** %data.addr, align 8
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %1)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @destroy_async_on_interface(%struct.dev_state* %ps, i32 %ifnum) #0 {
entry:
  %ps.addr = alloca %struct.dev_state*, align 8
  %ifnum.addr = alloca i32, align 4
  %p = alloca %struct.list_head*, align 8
  %q = alloca %struct.list_head*, align 8
  %hitlist = alloca %struct.list_head, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__mptr = alloca %struct.list_head*, align 8
  %tmp8 = alloca %struct.async*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i32 %ifnum, i32* %ifnum.addr, align 4
  call void @INIT_LIST_HEAD(%struct.list_head* %hitlist)
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %0 = load i32, i32* %tmp, align 4
  %1 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  store i64 %call2, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.end
  %2 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %3, %struct.list_head** %p, align 8
  %4 = load %struct.list_head*, %struct.list_head** %p, align 8
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %4, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next4, align 8
  store %struct.list_head* %5, %struct.list_head** %q, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end3
  %6 = load %struct.list_head*, %struct.list_head** %p, align 8
  %7 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_pending5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %7, i32 0, i32 4
  %cmp6 = icmp ne %struct.list_head* %6, %async_pending5
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32, i32* %ifnum.addr, align 4
  %9 = load %struct.list_head*, %struct.list_head** %p, align 8
  store %struct.list_head* %9, %struct.list_head** %__mptr, align 8
  %10 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %11 = bitcast %struct.list_head* %10 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 0
  %12 = bitcast i8* %add.ptr to %struct.async*
  store %struct.async* %12, %struct.async** %tmp8, align 8
  %13 = load %struct.async*, %struct.async** %tmp8, align 8
  %ifnum9 = getelementptr inbounds %struct.async, %struct.async* %13, i32 0, i32 5
  %14 = load i32, i32* %ifnum9, align 4
  %cmp10 = icmp eq i32 %8, %14
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %15 = load %struct.list_head*, %struct.list_head** %p, align 8
  call void @list_move_tail(%struct.list_head* %15, %struct.list_head* %hitlist)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %16 = load %struct.list_head*, %struct.list_head** %q, align 8
  store %struct.list_head* %16, %struct.list_head** %p, align 8
  %17 = load %struct.list_head*, %struct.list_head** %p, align 8
  %next12 = getelementptr inbounds %struct.list_head, %struct.list_head* %17, i32 0, i32 0
  %18 = load %struct.list_head*, %struct.list_head** %next12, align 8
  store %struct.list_head* %18, %struct.list_head** %q, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock13 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %19, i32 0, i32 3
  %20 = load i64, i64* %flags, align 8
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock13, i64 %20)
  %21 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  call void @destroy_async(%struct.dev_state* %21, %struct.list_head* %hitlist)
  ret void
}

declare i8* @dev_get_drvdata(%struct.device*) #1

declare i32 @dev_set_drvdata(%struct.device*, i8*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #0 {
entry:
  %list.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %list, %struct.list_head** %list.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %1 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %next, align 8
  %2 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %3 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %3, i32 0, i32 1
  store %struct.list_head* %2, %struct.list_head** %prev, align 8
  ret void
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.spinlock*, align 8
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr, align 8
  %0 = load %struct.spinlock*, %struct.spinlock** %lock.addr, align 8
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %1 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @list_move_tail(%struct.list_head* %list, %struct.list_head* %head) #0 {
entry:
  %list.addr = alloca %struct.list_head*, align 8
  %head.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %list, %struct.list_head** %list.addr, align 8
  store %struct.list_head* %head, %struct.list_head** %head.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  call void @__list_del_entry(%struct.list_head* %0)
  %1 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %2 = load %struct.list_head*, %struct.list_head** %head.addr, align 8
  call void @list_add_tail(%struct.list_head* %1, %struct.list_head* %2)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #0 {
entry:
  %lock.addr = alloca %struct.spinlock*, align 8
  %flags.addr = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr, align 8
  store i64 %flags, i64* %flags.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %0 = load i32, i32* %tmp, align 4
  %1 = load %struct.spinlock*, %struct.spinlock** %lock.addr, align 8
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %1, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  %3 = load i64, i64* %flags.addr, align 8
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %3)
  br label %do.end

do.end:                                           ; preds = %do.body
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @destroy_async(%struct.dev_state* %ps, %struct.list_head* %list) #0 {
entry:
  %ps.addr = alloca %struct.dev_state*, align 8
  %list.addr = alloca %struct.list_head*, align 8
  %urb = alloca %struct.urb*, align 8
  %as = alloca %struct.async*, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__mptr = alloca %struct.list_head*, align 8
  %tmp5 = alloca %struct.async*, align 8
  %__dummy11 = alloca i64, align 8
  %__dummy212 = alloca i64, align 8
  %tmp15 = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store %struct.list_head* %list, %struct.list_head** %list.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %0 = load i32, i32* %tmp, align 4
  %1 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  store i64 %call2, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.end
  br label %while.cond

while.cond:                                       ; preds = %do.end20, %do.end3
  %2 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %call4 = call i32 @list_empty(%struct.list_head* %2)
  %tobool = icmp ne i32 %call4, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %struct.list_head*, %struct.list_head** %list.addr, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %3, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %4, %struct.list_head** %__mptr, align 8
  %5 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 0
  %7 = bitcast i8* %add.ptr to %struct.async*
  store %struct.async* %7, %struct.async** %tmp5, align 8
  %8 = load %struct.async*, %struct.async** %tmp5, align 8
  store %struct.async* %8, %struct.async** %as, align 8
  %9 = load %struct.async*, %struct.async** %as, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  %10 = load %struct.async*, %struct.async** %as, align 8
  %urb6 = getelementptr inbounds %struct.async, %struct.async* %10, i32 0, i32 8
  %11 = load %struct.urb*, %struct.urb** %urb6, align 8
  store %struct.urb* %11, %struct.urb** %urb, align 8
  %12 = load %struct.urb*, %struct.urb** %urb, align 8
  %call7 = call %struct.urb* @usb_get_urb(%struct.urb* %12)
  %13 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %13, i32 0, i32 3
  %14 = load i64, i64* %flags, align 8
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock8, i64 %14)
  %15 = load %struct.urb*, %struct.urb** %urb, align 8
  call void @usb_kill_urb(%struct.urb* %15)
  %16 = load %struct.urb*, %struct.urb** %urb, align 8
  call void @usb_free_urb(%struct.urb* %16)
  br label %do.body9

do.body9:                                         ; preds = %while.body
  br label %do.body10

do.body10:                                        ; preds = %do.body9
  %cmp13 = icmp eq i64* %__dummy11, %__dummy212
  %conv14 = zext i1 %cmp13 to i32
  store i32 1, i32* %tmp15, align 4
  %17 = load i32, i32* %tmp15, align 4
  %18 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock16 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %18, i32 0, i32 3
  %call17 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock16)
  %call18 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call17)
  store i64 %call18, i64* %flags, align 8
  br label %do.end19

do.end19:                                         ; preds = %do.body10
  br label %do.end20

do.end20:                                         ; preds = %do.end19
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %19 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock21 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %19, i32 0, i32 3
  %20 = load i64, i64* %flags, align 8
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock21, i64 %20)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #0 {
entry:
  %entry.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %entry1, %struct.list_head** %entry.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 1
  %1 = load %struct.list_head*, %struct.list_head** %prev, align 8
  %2 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %2, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next, align 8
  call void @__list_del(%struct.list_head* %1, %struct.list_head* %3)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #0 {
entry:
  %new.addr = alloca %struct.list_head*, align 8
  %head.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %new, %struct.list_head** %new.addr, align 8
  store %struct.list_head* %head, %struct.list_head** %head.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  %1 = load %struct.list_head*, %struct.list_head** %head.addr, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 1
  %2 = load %struct.list_head*, %struct.list_head** %prev, align 8
  %3 = load %struct.list_head*, %struct.list_head** %head.addr, align 8
  call void @__list_add(%struct.list_head* %0, %struct.list_head* %2, %struct.list_head* %3)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #0 {
entry:
  %prev.addr = alloca %struct.list_head*, align 8
  %next.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %prev, %struct.list_head** %prev.addr, align 8
  store %struct.list_head* %next, %struct.list_head** %next.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %prev.addr, align 8
  %1 = load %struct.list_head*, %struct.list_head** %next.addr, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 1
  store %struct.list_head* %0, %struct.list_head** %prev1, align 8
  %2 = load %struct.list_head*, %struct.list_head** %next.addr, align 8
  %3 = load %struct.list_head*, %struct.list_head** %prev.addr, align 8
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %3, i32 0, i32 0
  store %struct.list_head* %2, %struct.list_head** %next2, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #0 {
entry:
  %new.addr = alloca %struct.list_head*, align 8
  %prev.addr = alloca %struct.list_head*, align 8
  %next.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %new, %struct.list_head** %new.addr, align 8
  store %struct.list_head* %prev, %struct.list_head** %prev.addr, align 8
  store %struct.list_head* %next, %struct.list_head** %next.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  %1 = load %struct.list_head*, %struct.list_head** %next.addr, align 8
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 1
  store %struct.list_head* %0, %struct.list_head** %prev1, align 8
  %2 = load %struct.list_head*, %struct.list_head** %next.addr, align 8
  %3 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %3, i32 0, i32 0
  store %struct.list_head* %2, %struct.list_head** %next2, align 8
  %4 = load %struct.list_head*, %struct.list_head** %prev.addr, align 8
  %5 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %5, i32 0, i32 1
  store %struct.list_head* %4, %struct.list_head** %prev3, align 8
  %6 = load %struct.list_head*, %struct.list_head** %new.addr, align 8
  %7 = load %struct.list_head*, %struct.list_head** %prev.addr, align 8
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %7, i32 0, i32 0
  store %struct.list_head* %6, %struct.list_head** %next4, align 8
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @list_empty(%struct.list_head* %head) #0 {
entry:
  %head.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %head, %struct.list_head** %head.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %head.addr, align 8
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8
  %2 = load %struct.list_head*, %struct.list_head** %head.addr, align 8
  %cmp = icmp eq %struct.list_head* %1, %2
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #0 {
entry:
  %entry.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %entry1, %struct.list_head** %entry.addr, align 8
  %0 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  call void @__list_del_entry(%struct.list_head* %0)
  %1 = load %struct.list_head*, %struct.list_head** %entry.addr, align 8
  call void @INIT_LIST_HEAD(%struct.list_head* %1)
  ret void
}

declare %struct.urb* @usb_get_urb(%struct.urb*) #1

declare void @usb_kill_urb(%struct.urb*) #1

declare void @usb_free_urb(%struct.urb*) #1

declare void @mutex_lock(%struct.mutex*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #0 {
entry:
  %f.addr = alloca %struct.file*, align 8
  store %struct.file* %f, %struct.file** %f.addr, align 8
  %0 = load %struct.file*, %struct.file** %f.addr, align 8
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 2
  %1 = load %struct.inode*, %struct.inode** %f_inode, align 8
  ret %struct.inode* %1
}

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @device_lock(%struct.device* %dev) #0 {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device*, %struct.device** %dev.addr, align 8
  %mutex = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 5
  call void @mutex_lock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @connected(%struct.dev_state* %ps) #0 {
entry:
  %ps.addr = alloca %struct.dev_state*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 0
  %call = call i32 @list_empty(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %1 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %3 = load i32, i32* %state, align 8
  %cmp = icmp ne i32 %3, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  ret i32 %land.ext
}

declare i8* @__memcpy(i8*, i8*, i64) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #3

; Function Attrs: noinline nounwind optnone uwtable
define internal void @device_unlock(%struct.device* %dev) #0 {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device*, %struct.device** %dev.addr, align 8
  %mutex = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @might_fault() #0 {
entry:
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call i32 @_cond_resched()
  br label %do.end

do.end:                                           ; preds = %do.body
  ret void
}

declare i64 @_copy_to_user(i8*, i8*, i32) #1

declare i32 @_cond_resched() #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #0 {
entry:
  %filp.addr = alloca %struct.file*, align 8
  %wait_address.addr = alloca %struct.__wait_queue_head*, align 8
  %p.addr = alloca %struct.poll_table_struct*, align 8
  store %struct.file* %filp, %struct.file** %filp.addr, align 8
  store %struct.__wait_queue_head* %wait_address, %struct.__wait_queue_head** %wait_address.addr, align 8
  store %struct.poll_table_struct* %p, %struct.poll_table_struct** %p.addr, align 8
  %0 = load %struct.poll_table_struct*, %struct.poll_table_struct** %p.addr, align 8
  %tobool = icmp ne %struct.poll_table_struct* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.poll_table_struct*, %struct.poll_table_struct** %p.addr, align 8
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %1, i32 0, i32 0
  %2 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %2, null
  br i1 %tobool1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %3 = load %struct.__wait_queue_head*, %struct.__wait_queue_head** %wait_address.addr, align 8
  %tobool3 = icmp ne %struct.__wait_queue_head* %3, null
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true2
  %4 = load %struct.poll_table_struct*, %struct.poll_table_struct** %p.addr, align 8
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %4, i32 0, i32 0
  %5 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8
  %6 = load %struct.file*, %struct.file** %filp.addr, align 8
  %7 = load %struct.__wait_queue_head*, %struct.__wait_queue_head** %wait_address.addr, align 8
  %8 = load %struct.poll_table_struct*, %struct.poll_table_struct** %p.addr, align 8
  call void %5(%struct.file* %6, %struct.__wait_queue_head* %7, %struct.poll_table_struct* %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %p) #0 {
entry:
  %retval = alloca i64, align 8
  %file.addr = alloca %struct.file*, align 8
  %cmd.addr = alloca i32, align 4
  %p.addr = alloca i8*, align 8
  %ps = alloca %struct.dev_state*, align 8
  %inode = alloca %struct.inode*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %ret = alloca i32, align 4
  %coerce = alloca %struct.timespec, align 8
  %coerce30 = alloca %struct.timespec, align 8
  %coerce45 = alloca %struct.timespec, align 8
  %coerce69 = alloca %struct.timespec, align 8
  %coerce120 = alloca %struct.timespec, align 8
  %coerce135 = alloca %struct.timespec, align 8
  %coerce150 = alloca %struct.timespec, align 8
  %coerce174 = alloca %struct.timespec, align 8
  %coerce293 = alloca %struct.timespec, align 8
  store %struct.file* %file, %struct.file** %file.addr, align 8
  store i32 %cmd, i32* %cmd.addr, align 4
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct.file*, %struct.file** %file.addr, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8
  %2 = bitcast i8* %1 to %struct.dev_state*
  store %struct.dev_state* %2, %struct.dev_state** %ps, align 8
  %3 = load %struct.file*, %struct.file** %file.addr, align 8
  %call = call %struct.inode* @file_inode(%struct.file* %3)
  store %struct.inode* %call, %struct.inode** %inode, align 8
  %4 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %4, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %5, %struct.usb_device** %dev, align 8
  store i32 -25, i32* %ret, align 4
  %6 = load %struct.file*, %struct.file** %file.addr, align 8
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %6, i32 0, i32 8
  %7 = load i32, i32* %f_mode, align 4
  %and = and i32 %7, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -1, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  %9 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %call3 = call i32 @connected(%struct.dev_state* %9)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %10 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %10, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev6)
  store i64 -19, i64* %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end
  %11 = load i32, i32* %cmd.addr, align 4
  br label %NodeBlock95

NodeBlock95:                                      ; preds = %if.end7
  %Pivot96 = icmp slt i32 %11, -1072933614
  br i1 %Pivot96, label %NodeBlock43, label %NodeBlock93

NodeBlock93:                                      ; preds = %NodeBlock95
  %Pivot94 = icmp slt i32 %11, 21780
  br i1 %Pivot94, label %NodeBlock69, label %NodeBlock91

NodeBlock91:                                      ; preds = %NodeBlock93
  %Pivot92 = icmp slt i32 %11, 1074287884
  br i1 %Pivot92, label %NodeBlock77, label %NodeBlock89

NodeBlock89:                                      ; preds = %NodeBlock91
  %Pivot90 = icmp slt i32 %11, 1074287889
  br i1 %Pivot90, label %NodeBlock81, label %NodeBlock87

NodeBlock87:                                      ; preds = %NodeBlock89
  %Pivot88 = icmp slt i32 %11, 1090802952
  br i1 %Pivot88, label %LeafBlock83, label %LeafBlock85

LeafBlock85:                                      ; preds = %NodeBlock87
  %SwitchLeaf86 = icmp eq i32 %11, 1090802952
  br i1 %SwitchLeaf86, label %sw.bb71, label %NewDefault

LeafBlock83:                                      ; preds = %NodeBlock87
  %SwitchLeaf84 = icmp eq i32 %11, 1074287889
  br i1 %SwitchLeaf84, label %sw.bb80, label %NewDefault

NodeBlock81:                                      ; preds = %NodeBlock89
  %Pivot82 = icmp slt i32 %11, 1074287885
  br i1 %Pivot82, label %sw.bb213, label %LeafBlock79

LeafBlock79:                                      ; preds = %NodeBlock81
  %SwitchLeaf80 = icmp eq i32 %11, 1074287885
  br i1 %SwitchLeaf80, label %sw.bb222, label %NewDefault

NodeBlock77:                                      ; preds = %NodeBlock91
  %Pivot78 = icmp slt i32 %11, 1074025740
  br i1 %Pivot78, label %LeafBlock71, label %NodeBlock75

NodeBlock75:                                      ; preds = %NodeBlock77
  %Pivot76 = icmp slt i32 %11, 1074025741
  br i1 %Pivot76, label %sw.bb176, label %LeafBlock73

LeafBlock73:                                      ; preds = %NodeBlock75
  %SwitchLeaf74 = icmp eq i32 %11, 1074025741
  br i1 %SwitchLeaf74, label %sw.bb185, label %NewDefault

LeafBlock71:                                      ; preds = %NodeBlock77
  %SwitchLeaf72 = icmp eq i32 %11, 21780
  br i1 %SwitchLeaf72, label %sw.bb47, label %NewDefault

NodeBlock69:                                      ; preds = %NodeBlock93
  %Pivot70 = icmp slt i32 %11, -1072671470
  br i1 %Pivot70, label %NodeBlock53, label %NodeBlock67

NodeBlock67:                                      ; preds = %NodeBlock69
  %Pivot68 = icmp slt i32 %11, -1072147198
  br i1 %Pivot68, label %NodeBlock59, label %NodeBlock65

NodeBlock65:                                      ; preds = %NodeBlock67
  %Pivot66 = icmp slt i32 %11, 21771
  br i1 %Pivot66, label %LeafBlock61, label %LeafBlock63

LeafBlock63:                                      ; preds = %NodeBlock65
  %SwitchLeaf64 = icmp eq i32 %11, 21771
  br i1 %SwitchLeaf64, label %sw.bb204, label %NewDefault

LeafBlock61:                                      ; preds = %NodeBlock65
  %SwitchLeaf62 = icmp eq i32 %11, -1072147198
  br i1 %SwitchLeaf62, label %sw.bb17, label %NewDefault

NodeBlock59:                                      ; preds = %NodeBlock67
  %Pivot60 = icmp slt i32 %11, -1072147200
  br i1 %Pivot60, label %LeafBlock55, label %LeafBlock57

LeafBlock57:                                      ; preds = %NodeBlock59
  %SwitchLeaf58 = icmp eq i32 %11, -1072147200
  br i1 %SwitchLeaf58, label %sw.bb, label %NewDefault

LeafBlock55:                                      ; preds = %NodeBlock59
  %SwitchLeaf56 = icmp eq i32 %11, -1072671470
  br i1 %SwitchLeaf56, label %sw.bb258, label %NewDefault

NodeBlock53:                                      ; preds = %NodeBlock69
  %Pivot54 = icmp slt i32 %11, -1072671488
  br i1 %Pivot54, label %LeafBlock45, label %NodeBlock51

NodeBlock51:                                      ; preds = %NodeBlock53
  %Pivot52 = icmp slt i32 %11, -1072671486
  br i1 %Pivot52, label %LeafBlock47, label %LeafBlock49

LeafBlock49:                                      ; preds = %NodeBlock51
  %SwitchLeaf50 = icmp eq i32 %11, -1072671486
  br i1 %SwitchLeaf50, label %sw.bb137, label %NewDefault

LeafBlock47:                                      ; preds = %NodeBlock51
  %SwitchLeaf48 = icmp eq i32 %11, -1072671488
  br i1 %SwitchLeaf48, label %sw.bb122, label %NewDefault

LeafBlock45:                                      ; preds = %NodeBlock53
  %SwitchLeaf46 = icmp eq i32 %11, -1072933614
  br i1 %SwitchLeaf46, label %sw.bb194, label %NewDefault

NodeBlock43:                                      ; preds = %NodeBlock95
  %Pivot44 = icmp slt i32 %11, -2147199718
  br i1 %Pivot44, label %NodeBlock15, label %NodeBlock41

NodeBlock41:                                      ; preds = %NodeBlock43
  %Pivot42 = icmp slt i32 %11, -2146413298
  br i1 %Pivot42, label %NodeBlock25, label %NodeBlock39

NodeBlock39:                                      ; preds = %NodeBlock41
  %Pivot40 = icmp slt i32 %11, -2143791862
  br i1 %Pivot40, label %NodeBlock31, label %NodeBlock37

NodeBlock37:                                      ; preds = %NodeBlock39
  %Pivot38 = icmp slt i32 %11, -2130160357
  br i1 %Pivot38, label %LeafBlock33, label %LeafBlock35

LeafBlock35:                                      ; preds = %NodeBlock37
  %SwitchLeaf36 = icmp eq i32 %11, -2130160357
  br i1 %SwitchLeaf36, label %sw.bb287, label %NewDefault

LeafBlock33:                                      ; preds = %NodeBlock37
  %SwitchLeaf34 = icmp eq i32 %11, -2143791862
  br i1 %SwitchLeaf34, label %sw.bb107, label %NewDefault

NodeBlock31:                                      ; preds = %NodeBlock39
  %Pivot32 = icmp slt i32 %11, -2144578294
  br i1 %Pivot32, label %LeafBlock27, label %LeafBlock29

LeafBlock29:                                      ; preds = %NodeBlock31
  %SwitchLeaf30 = icmp eq i32 %11, -2144578294
  br i1 %SwitchLeaf30, label %sw.bb161, label %NewDefault

LeafBlock27:                                      ; preds = %NodeBlock31
  %SwitchLeaf28 = icmp eq i32 %11, -2146413298
  br i1 %SwitchLeaf28, label %sw.bb231, label %NewDefault

NodeBlock25:                                      ; preds = %NodeBlock41
  %Pivot26 = icmp slt i32 %11, -2146937596
  br i1 %Pivot26, label %LeafBlock17, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %11, -2146937586
  br i1 %Pivot24, label %LeafBlock19, label %LeafBlock21

LeafBlock21:                                      ; preds = %NodeBlock23
  %SwitchLeaf22 = icmp eq i32 %11, -2146937586
  br i1 %SwitchLeaf22, label %sw.bb152, label %NewDefault

LeafBlock19:                                      ; preds = %NodeBlock23
  %SwitchLeaf20 = icmp eq i32 %11, -2146937596
  br i1 %SwitchLeaf20, label %sw.bb89, label %NewDefault

LeafBlock17:                                      ; preds = %NodeBlock25
  %SwitchLeaf18 = icmp eq i32 %11, -2147199718
  br i1 %SwitchLeaf18, label %sw.bb285, label %NewDefault

NodeBlock15:                                      ; preds = %NodeBlock43
  %Pivot16 = icmp slt i32 %11, -2147199728
  br i1 %Pivot16, label %NodeBlock3, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %11, -2147199720
  br i1 %Pivot14, label %NodeBlock9, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %11, -2147199719
  br i1 %Pivot12, label %sw.bb267, label %sw.bb276

NodeBlock9:                                       ; preds = %NodeBlock13
  %Pivot10 = icmp slt i32 %11, -2147199723
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %11, -2147199723
  br i1 %SwitchLeaf8, label %sw.bb56, label %NewDefault

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %11, -2147199728
  br i1 %SwitchLeaf6, label %sw.bb249, label %NewDefault

NodeBlock3:                                       ; preds = %NodeBlock15
  %Pivot4 = icmp slt i32 %11, -2147199739
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %11, -2147199729
  br i1 %Pivot, label %LeafBlock1, label %sw.bb240

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %11, -2147199739
  br i1 %SwitchLeaf2, label %sw.bb98, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %11, -2147199741
  br i1 %SwitchLeaf, label %sw.bb32, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock57
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %12 = load i8, i8* @usbfs_snoop, align 1
  %tobool8 = trunc i8 %12 to i1
  br i1 %tobool8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %do.body
  %13 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 11
  %call11 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev10, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end12
  %14 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %15 = load i8*, i8** %p.addr, align 8
  %call13 = call i32 @proc_control(%struct.dev_state* %14, i8* %15)
  store i32 %call13, i32* %ret, align 4
  %16 = load i32, i32* %ret, align 4
  %cmp = icmp sge i32 %16, 0
  br i1 %cmp, label %if.then14, label %if.end16

if.then14:                                        ; preds = %do.end
  %17 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime = getelementptr inbounds %struct.inode, %struct.inode* %17, i32 0, i32 16
  %call15 = call { i64, i64 } @current_kernel_time()
  %18 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call15, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call15, 1
  store i64 %22, i64* %21, align 8
  %23 = bitcast %struct.timespec* %i_mtime to i8*
  %24 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %24, i64 16, i32 8, i1 false)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %do.end
  br label %sw.epilog

sw.bb17:                                          ; preds = %LeafBlock61
  br label %do.body18

do.body18:                                        ; preds = %sw.bb17
  %25 = load i8, i8* @usbfs_snoop, align 1
  %tobool19 = trunc i8 %25 to i1
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %do.body18
  %26 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %26, i32 0, i32 11
  %call22 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev21, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end23

if.end23:                                         ; preds = %if.then20, %do.body18
  br label %do.end24

do.end24:                                         ; preds = %if.end23
  %27 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %28 = load i8*, i8** %p.addr, align 8
  %call25 = call i32 @proc_bulk(%struct.dev_state* %27, i8* %28)
  store i32 %call25, i32* %ret, align 4
  %29 = load i32, i32* %ret, align 4
  %cmp26 = icmp sge i32 %29, 0
  br i1 %cmp26, label %if.then27, label %if.end31

if.then27:                                        ; preds = %do.end24
  %30 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime28 = getelementptr inbounds %struct.inode, %struct.inode* %30, i32 0, i32 16
  %call29 = call { i64, i64 } @current_kernel_time()
  %31 = bitcast %struct.timespec* %coerce30 to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = extractvalue { i64, i64 } %call29, 0
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = extractvalue { i64, i64 } %call29, 1
  store i64 %35, i64* %34, align 8
  %36 = bitcast %struct.timespec* %i_mtime28 to i8*
  %37 = bitcast %struct.timespec* %coerce30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %36, i8* %37, i64 16, i32 8, i1 false)
  br label %if.end31

if.end31:                                         ; preds = %if.then27, %do.end24
  br label %sw.epilog

sw.bb32:                                          ; preds = %LeafBlock
  br label %do.body33

do.body33:                                        ; preds = %sw.bb32
  %38 = load i8, i8* @usbfs_snoop, align 1
  %tobool34 = trunc i8 %38 to i1
  br i1 %tobool34, label %if.then35, label %if.end38

if.then35:                                        ; preds = %do.body33
  %39 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev36 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %39, i32 0, i32 11
  %call37 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev36, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end38

if.end38:                                         ; preds = %if.then35, %do.body33
  br label %do.end39

do.end39:                                         ; preds = %if.end38
  %40 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %41 = load i8*, i8** %p.addr, align 8
  %call40 = call i32 @proc_resetep(%struct.dev_state* %40, i8* %41)
  store i32 %call40, i32* %ret, align 4
  %42 = load i32, i32* %ret, align 4
  %cmp41 = icmp sge i32 %42, 0
  br i1 %cmp41, label %if.then42, label %if.end46

if.then42:                                        ; preds = %do.end39
  %43 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime43 = getelementptr inbounds %struct.inode, %struct.inode* %43, i32 0, i32 16
  %call44 = call { i64, i64 } @current_kernel_time()
  %44 = bitcast %struct.timespec* %coerce45 to { i64, i64 }*
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 0
  %46 = extractvalue { i64, i64 } %call44, 0
  store i64 %46, i64* %45, align 8
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %44, i32 0, i32 1
  %48 = extractvalue { i64, i64 } %call44, 1
  store i64 %48, i64* %47, align 8
  %49 = bitcast %struct.timespec* %i_mtime43 to i8*
  %50 = bitcast %struct.timespec* %coerce45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %49, i8* %50, i64 16, i32 8, i1 false)
  br label %if.end46

if.end46:                                         ; preds = %if.then42, %do.end39
  br label %sw.epilog

sw.bb47:                                          ; preds = %LeafBlock71
  br label %do.body48

do.body48:                                        ; preds = %sw.bb47
  %51 = load i8, i8* @usbfs_snoop, align 1
  %tobool49 = trunc i8 %51 to i1
  br i1 %tobool49, label %if.then50, label %if.end53

if.then50:                                        ; preds = %do.body48
  %52 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev51 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %52, i32 0, i32 11
  %call52 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev51, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end53

if.end53:                                         ; preds = %if.then50, %do.body48
  br label %do.end54

do.end54:                                         ; preds = %if.end53
  %53 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %call55 = call i32 @proc_resetdevice(%struct.dev_state* %53)
  store i32 %call55, i32* %ret, align 4
  br label %sw.epilog

sw.bb56:                                          ; preds = %LeafBlock7
  br label %do.body57

do.body57:                                        ; preds = %sw.bb56
  %54 = load i8, i8* @usbfs_snoop, align 1
  %tobool58 = trunc i8 %54 to i1
  br i1 %tobool58, label %if.then59, label %if.end62

if.then59:                                        ; preds = %do.body57
  %55 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev60 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %55, i32 0, i32 11
  %call61 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev60, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end62

if.end62:                                         ; preds = %if.then59, %do.body57
  br label %do.end63

do.end63:                                         ; preds = %if.end62
  %56 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %57 = load i8*, i8** %p.addr, align 8
  %call64 = call i32 @proc_clearhalt(%struct.dev_state* %56, i8* %57)
  store i32 %call64, i32* %ret, align 4
  %58 = load i32, i32* %ret, align 4
  %cmp65 = icmp sge i32 %58, 0
  br i1 %cmp65, label %if.then66, label %if.end70

if.then66:                                        ; preds = %do.end63
  %59 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime67 = getelementptr inbounds %struct.inode, %struct.inode* %59, i32 0, i32 16
  %call68 = call { i64, i64 } @current_kernel_time()
  %60 = bitcast %struct.timespec* %coerce69 to { i64, i64 }*
  %61 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %60, i32 0, i32 0
  %62 = extractvalue { i64, i64 } %call68, 0
  store i64 %62, i64* %61, align 8
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %60, i32 0, i32 1
  %64 = extractvalue { i64, i64 } %call68, 1
  store i64 %64, i64* %63, align 8
  %65 = bitcast %struct.timespec* %i_mtime67 to i8*
  %66 = bitcast %struct.timespec* %coerce69 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %65, i8* %66, i64 16, i32 8, i1 false)
  br label %if.end70

if.end70:                                         ; preds = %if.then66, %do.end63
  br label %sw.epilog

sw.bb71:                                          ; preds = %LeafBlock85
  br label %do.body72

do.body72:                                        ; preds = %sw.bb71
  %67 = load i8, i8* @usbfs_snoop, align 1
  %tobool73 = trunc i8 %67 to i1
  br i1 %tobool73, label %if.then74, label %if.end77

if.then74:                                        ; preds = %do.body72
  %68 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev75 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %68, i32 0, i32 11
  %call76 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev75, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end77

if.end77:                                         ; preds = %if.then74, %do.body72
  br label %do.end78

do.end78:                                         ; preds = %if.end77
  %69 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %70 = load i8*, i8** %p.addr, align 8
  %call79 = call i32 @proc_getdriver(%struct.dev_state* %69, i8* %70)
  store i32 %call79, i32* %ret, align 4
  br label %sw.epilog

sw.bb80:                                          ; preds = %LeafBlock83
  br label %do.body81

do.body81:                                        ; preds = %sw.bb80
  %71 = load i8, i8* @usbfs_snoop, align 1
  %tobool82 = trunc i8 %71 to i1
  br i1 %tobool82, label %if.then83, label %if.end86

if.then83:                                        ; preds = %do.body81
  %72 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev84 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %72, i32 0, i32 11
  %call85 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev84, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end86

if.end86:                                         ; preds = %if.then83, %do.body81
  br label %do.end87

do.end87:                                         ; preds = %if.end86
  %73 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %74 = load i8*, i8** %p.addr, align 8
  %call88 = call i32 @proc_connectinfo(%struct.dev_state* %73, i8* %74)
  store i32 %call88, i32* %ret, align 4
  br label %sw.epilog

sw.bb89:                                          ; preds = %LeafBlock19
  br label %do.body90

do.body90:                                        ; preds = %sw.bb89
  %75 = load i8, i8* @usbfs_snoop, align 1
  %tobool91 = trunc i8 %75 to i1
  br i1 %tobool91, label %if.then92, label %if.end95

if.then92:                                        ; preds = %do.body90
  %76 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev93 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %76, i32 0, i32 11
  %call94 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev93, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end95

if.end95:                                         ; preds = %if.then92, %do.body90
  br label %do.end96

do.end96:                                         ; preds = %if.end95
  %77 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %78 = load i8*, i8** %p.addr, align 8
  %call97 = call i32 @proc_setintf(%struct.dev_state* %77, i8* %78)
  store i32 %call97, i32* %ret, align 4
  br label %sw.epilog

sw.bb98:                                          ; preds = %LeafBlock1
  br label %do.body99

do.body99:                                        ; preds = %sw.bb98
  %79 = load i8, i8* @usbfs_snoop, align 1
  %tobool100 = trunc i8 %79 to i1
  br i1 %tobool100, label %if.then101, label %if.end104

if.then101:                                       ; preds = %do.body99
  %80 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev102 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %80, i32 0, i32 11
  %call103 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev102, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end104

if.end104:                                        ; preds = %if.then101, %do.body99
  br label %do.end105

do.end105:                                        ; preds = %if.end104
  %81 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %82 = load i8*, i8** %p.addr, align 8
  %call106 = call i32 @proc_setconfig(%struct.dev_state* %81, i8* %82)
  store i32 %call106, i32* %ret, align 4
  br label %sw.epilog

sw.bb107:                                         ; preds = %LeafBlock33
  br label %do.body108

do.body108:                                       ; preds = %sw.bb107
  %83 = load i8, i8* @usbfs_snoop, align 1
  %tobool109 = trunc i8 %83 to i1
  br i1 %tobool109, label %if.then110, label %if.end113

if.then110:                                       ; preds = %do.body108
  %84 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev111 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %84, i32 0, i32 11
  %call112 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev111, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end113

if.end113:                                        ; preds = %if.then110, %do.body108
  br label %do.end114

do.end114:                                        ; preds = %if.end113
  %85 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %86 = load i8*, i8** %p.addr, align 8
  %call115 = call i32 @proc_submiturb(%struct.dev_state* %85, i8* %86)
  store i32 %call115, i32* %ret, align 4
  %87 = load i32, i32* %ret, align 4
  %cmp116 = icmp sge i32 %87, 0
  br i1 %cmp116, label %if.then117, label %if.end121

if.then117:                                       ; preds = %do.end114
  %88 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime118 = getelementptr inbounds %struct.inode, %struct.inode* %88, i32 0, i32 16
  %call119 = call { i64, i64 } @current_kernel_time()
  %89 = bitcast %struct.timespec* %coerce120 to { i64, i64 }*
  %90 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 0
  %91 = extractvalue { i64, i64 } %call119, 0
  store i64 %91, i64* %90, align 8
  %92 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 1
  %93 = extractvalue { i64, i64 } %call119, 1
  store i64 %93, i64* %92, align 8
  %94 = bitcast %struct.timespec* %i_mtime118 to i8*
  %95 = bitcast %struct.timespec* %coerce120 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %94, i8* %95, i64 16, i32 8, i1 false)
  br label %if.end121

if.end121:                                        ; preds = %if.then117, %do.end114
  br label %sw.epilog

sw.bb122:                                         ; preds = %LeafBlock47
  br label %do.body123

do.body123:                                       ; preds = %sw.bb122
  %96 = load i8, i8* @usbfs_snoop, align 1
  %tobool124 = trunc i8 %96 to i1
  br i1 %tobool124, label %if.then125, label %if.end128

if.then125:                                       ; preds = %do.body123
  %97 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev126 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %97, i32 0, i32 11
  %call127 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev126, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end128

if.end128:                                        ; preds = %if.then125, %do.body123
  br label %do.end129

do.end129:                                        ; preds = %if.end128
  %98 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %99 = load i8*, i8** %p.addr, align 8
  %100 = bitcast i8* %99 to %struct.usbdevfs_ctrltransfer32*
  %call130 = call i32 @proc_control_compat(%struct.dev_state* %98, %struct.usbdevfs_ctrltransfer32* %100)
  store i32 %call130, i32* %ret, align 4
  %101 = load i32, i32* %ret, align 4
  %cmp131 = icmp sge i32 %101, 0
  br i1 %cmp131, label %if.then132, label %if.end136

if.then132:                                       ; preds = %do.end129
  %102 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime133 = getelementptr inbounds %struct.inode, %struct.inode* %102, i32 0, i32 16
  %call134 = call { i64, i64 } @current_kernel_time()
  %103 = bitcast %struct.timespec* %coerce135 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call134, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call134, 1
  store i64 %107, i64* %106, align 8
  %108 = bitcast %struct.timespec* %i_mtime133 to i8*
  %109 = bitcast %struct.timespec* %coerce135 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %108, i8* %109, i64 16, i32 8, i1 false)
  br label %if.end136

if.end136:                                        ; preds = %if.then132, %do.end129
  br label %sw.epilog

sw.bb137:                                         ; preds = %LeafBlock49
  br label %do.body138

do.body138:                                       ; preds = %sw.bb137
  %110 = load i8, i8* @usbfs_snoop, align 1
  %tobool139 = trunc i8 %110 to i1
  br i1 %tobool139, label %if.then140, label %if.end143

if.then140:                                       ; preds = %do.body138
  %111 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev141 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %111, i32 0, i32 11
  %call142 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev141, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end143

if.end143:                                        ; preds = %if.then140, %do.body138
  br label %do.end144

do.end144:                                        ; preds = %if.end143
  %112 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %113 = load i8*, i8** %p.addr, align 8
  %114 = bitcast i8* %113 to %struct.usbdevfs_bulktransfer32*
  %call145 = call i32 @proc_bulk_compat(%struct.dev_state* %112, %struct.usbdevfs_bulktransfer32* %114)
  store i32 %call145, i32* %ret, align 4
  %115 = load i32, i32* %ret, align 4
  %cmp146 = icmp sge i32 %115, 0
  br i1 %cmp146, label %if.then147, label %if.end151

if.then147:                                       ; preds = %do.end144
  %116 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime148 = getelementptr inbounds %struct.inode, %struct.inode* %116, i32 0, i32 16
  %call149 = call { i64, i64 } @current_kernel_time()
  %117 = bitcast %struct.timespec* %coerce150 to { i64, i64 }*
  %118 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %117, i32 0, i32 0
  %119 = extractvalue { i64, i64 } %call149, 0
  store i64 %119, i64* %118, align 8
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %117, i32 0, i32 1
  %121 = extractvalue { i64, i64 } %call149, 1
  store i64 %121, i64* %120, align 8
  %122 = bitcast %struct.timespec* %i_mtime148 to i8*
  %123 = bitcast %struct.timespec* %coerce150 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %122, i8* %123, i64 16, i32 8, i1 false)
  br label %if.end151

if.end151:                                        ; preds = %if.then147, %do.end144
  br label %sw.epilog

sw.bb152:                                         ; preds = %LeafBlock21
  br label %do.body153

do.body153:                                       ; preds = %sw.bb152
  %124 = load i8, i8* @usbfs_snoop, align 1
  %tobool154 = trunc i8 %124 to i1
  br i1 %tobool154, label %if.then155, label %if.end158

if.then155:                                       ; preds = %do.body153
  %125 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev156 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %125, i32 0, i32 11
  %call157 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev156, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end158

if.end158:                                        ; preds = %if.then155, %do.body153
  br label %do.end159

do.end159:                                        ; preds = %if.end158
  %126 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %127 = load i8*, i8** %p.addr, align 8
  %call160 = call i32 @proc_disconnectsignal_compat(%struct.dev_state* %126, i8* %127)
  store i32 %call160, i32* %ret, align 4
  br label %sw.epilog

sw.bb161:                                         ; preds = %LeafBlock29
  br label %do.body162

do.body162:                                       ; preds = %sw.bb161
  %128 = load i8, i8* @usbfs_snoop, align 1
  %tobool163 = trunc i8 %128 to i1
  br i1 %tobool163, label %if.then164, label %if.end167

if.then164:                                       ; preds = %do.body162
  %129 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev165 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %129, i32 0, i32 11
  %call166 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev165, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end167

if.end167:                                        ; preds = %if.then164, %do.body162
  br label %do.end168

do.end168:                                        ; preds = %if.end167
  %130 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %131 = load i8*, i8** %p.addr, align 8
  %call169 = call i32 @proc_submiturb_compat(%struct.dev_state* %130, i8* %131)
  store i32 %call169, i32* %ret, align 4
  %132 = load i32, i32* %ret, align 4
  %cmp170 = icmp sge i32 %132, 0
  br i1 %cmp170, label %if.then171, label %if.end175

if.then171:                                       ; preds = %do.end168
  %133 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_mtime172 = getelementptr inbounds %struct.inode, %struct.inode* %133, i32 0, i32 16
  %call173 = call { i64, i64 } @current_kernel_time()
  %134 = bitcast %struct.timespec* %coerce174 to { i64, i64 }*
  %135 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %134, i32 0, i32 0
  %136 = extractvalue { i64, i64 } %call173, 0
  store i64 %136, i64* %135, align 8
  %137 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %134, i32 0, i32 1
  %138 = extractvalue { i64, i64 } %call173, 1
  store i64 %138, i64* %137, align 8
  %139 = bitcast %struct.timespec* %i_mtime172 to i8*
  %140 = bitcast %struct.timespec* %coerce174 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %139, i8* %140, i64 16, i32 8, i1 false)
  br label %if.end175

if.end175:                                        ; preds = %if.then171, %do.end168
  br label %sw.epilog

sw.bb176:                                         ; preds = %NodeBlock75
  br label %do.body177

do.body177:                                       ; preds = %sw.bb176
  %141 = load i8, i8* @usbfs_snoop, align 1
  %tobool178 = trunc i8 %141 to i1
  br i1 %tobool178, label %if.then179, label %if.end182

if.then179:                                       ; preds = %do.body177
  %142 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev180 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %142, i32 0, i32 11
  %call181 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev180, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end182

if.end182:                                        ; preds = %if.then179, %do.body177
  br label %do.end183

do.end183:                                        ; preds = %if.end182
  %143 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %144 = load i8*, i8** %p.addr, align 8
  %call184 = call i32 @proc_reapurb_compat(%struct.dev_state* %143, i8* %144)
  store i32 %call184, i32* %ret, align 4
  br label %sw.epilog

sw.bb185:                                         ; preds = %LeafBlock73
  br label %do.body186

do.body186:                                       ; preds = %sw.bb185
  %145 = load i8, i8* @usbfs_snoop, align 1
  %tobool187 = trunc i8 %145 to i1
  br i1 %tobool187, label %if.then188, label %if.end191

if.then188:                                       ; preds = %do.body186
  %146 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev189 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %146, i32 0, i32 11
  %call190 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev189, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end191

if.end191:                                        ; preds = %if.then188, %do.body186
  br label %do.end192

do.end192:                                        ; preds = %if.end191
  %147 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %148 = load i8*, i8** %p.addr, align 8
  %call193 = call i32 @proc_reapurbnonblock_compat(%struct.dev_state* %147, i8* %148)
  store i32 %call193, i32* %ret, align 4
  br label %sw.epilog

sw.bb194:                                         ; preds = %LeafBlock45
  br label %do.body195

do.body195:                                       ; preds = %sw.bb194
  %149 = load i8, i8* @usbfs_snoop, align 1
  %tobool196 = trunc i8 %149 to i1
  br i1 %tobool196, label %if.then197, label %if.end200

if.then197:                                       ; preds = %do.body195
  %150 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev198 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %150, i32 0, i32 11
  %call199 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev198, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.21, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end200

if.end200:                                        ; preds = %if.then197, %do.body195
  br label %do.end201

do.end201:                                        ; preds = %if.end200
  %151 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %152 = load i8*, i8** %p.addr, align 8
  %call202 = call i32 @ptr_to_compat(i8* %152)
  %call203 = call i32 @proc_ioctl_compat(%struct.dev_state* %151, i32 %call202)
  store i32 %call203, i32* %ret, align 4
  br label %sw.epilog

sw.bb204:                                         ; preds = %LeafBlock63
  br label %do.body205

do.body205:                                       ; preds = %sw.bb204
  %153 = load i8, i8* @usbfs_snoop, align 1
  %tobool206 = trunc i8 %153 to i1
  br i1 %tobool206, label %if.then207, label %if.end210

if.then207:                                       ; preds = %do.body205
  %154 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev208 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %154, i32 0, i32 11
  %call209 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev208, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end210

if.end210:                                        ; preds = %if.then207, %do.body205
  br label %do.end211

do.end211:                                        ; preds = %if.end210
  %155 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %156 = load i8*, i8** %p.addr, align 8
  %call212 = call i32 @proc_unlinkurb(%struct.dev_state* %155, i8* %156)
  store i32 %call212, i32* %ret, align 4
  br label %sw.epilog

sw.bb213:                                         ; preds = %NodeBlock81
  br label %do.body214

do.body214:                                       ; preds = %sw.bb213
  %157 = load i8, i8* @usbfs_snoop, align 1
  %tobool215 = trunc i8 %157 to i1
  br i1 %tobool215, label %if.then216, label %if.end219

if.then216:                                       ; preds = %do.body214
  %158 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev217 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %158, i32 0, i32 11
  %call218 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev217, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end219

if.end219:                                        ; preds = %if.then216, %do.body214
  br label %do.end220

do.end220:                                        ; preds = %if.end219
  %159 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %160 = load i8*, i8** %p.addr, align 8
  %call221 = call i32 @proc_reapurb(%struct.dev_state* %159, i8* %160)
  store i32 %call221, i32* %ret, align 4
  br label %sw.epilog

sw.bb222:                                         ; preds = %LeafBlock79
  br label %do.body223

do.body223:                                       ; preds = %sw.bb222
  %161 = load i8, i8* @usbfs_snoop, align 1
  %tobool224 = trunc i8 %161 to i1
  br i1 %tobool224, label %if.then225, label %if.end228

if.then225:                                       ; preds = %do.body223
  %162 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev226 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %162, i32 0, i32 11
  %call227 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev226, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end228

if.end228:                                        ; preds = %if.then225, %do.body223
  br label %do.end229

do.end229:                                        ; preds = %if.end228
  %163 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %164 = load i8*, i8** %p.addr, align 8
  %call230 = call i32 @proc_reapurbnonblock(%struct.dev_state* %163, i8* %164)
  store i32 %call230, i32* %ret, align 4
  br label %sw.epilog

sw.bb231:                                         ; preds = %LeafBlock27
  br label %do.body232

do.body232:                                       ; preds = %sw.bb231
  %165 = load i8, i8* @usbfs_snoop, align 1
  %tobool233 = trunc i8 %165 to i1
  br i1 %tobool233, label %if.then234, label %if.end237

if.then234:                                       ; preds = %do.body232
  %166 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev235 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %166, i32 0, i32 11
  %call236 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev235, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end237

if.end237:                                        ; preds = %if.then234, %do.body232
  br label %do.end238

do.end238:                                        ; preds = %if.end237
  %167 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %168 = load i8*, i8** %p.addr, align 8
  %call239 = call i32 @proc_disconnectsignal(%struct.dev_state* %167, i8* %168)
  store i32 %call239, i32* %ret, align 4
  br label %sw.epilog

sw.bb240:                                         ; preds = %NodeBlock
  br label %do.body241

do.body241:                                       ; preds = %sw.bb240
  %169 = load i8, i8* @usbfs_snoop, align 1
  %tobool242 = trunc i8 %169 to i1
  br i1 %tobool242, label %if.then243, label %if.end246

if.then243:                                       ; preds = %do.body241
  %170 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev244 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %170, i32 0, i32 11
  %call245 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev244, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end246

if.end246:                                        ; preds = %if.then243, %do.body241
  br label %do.end247

do.end247:                                        ; preds = %if.end246
  %171 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %172 = load i8*, i8** %p.addr, align 8
  %call248 = call i32 @proc_claiminterface(%struct.dev_state* %171, i8* %172)
  store i32 %call248, i32* %ret, align 4
  br label %sw.epilog

sw.bb249:                                         ; preds = %LeafBlock5
  br label %do.body250

do.body250:                                       ; preds = %sw.bb249
  %173 = load i8, i8* @usbfs_snoop, align 1
  %tobool251 = trunc i8 %173 to i1
  br i1 %tobool251, label %if.then252, label %if.end255

if.then252:                                       ; preds = %do.body250
  %174 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev253 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %174, i32 0, i32 11
  %call254 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev253, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end255

if.end255:                                        ; preds = %if.then252, %do.body250
  br label %do.end256

do.end256:                                        ; preds = %if.end255
  %175 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %176 = load i8*, i8** %p.addr, align 8
  %call257 = call i32 @proc_releaseinterface(%struct.dev_state* %175, i8* %176)
  store i32 %call257, i32* %ret, align 4
  br label %sw.epilog

sw.bb258:                                         ; preds = %LeafBlock55
  br label %do.body259

do.body259:                                       ; preds = %sw.bb258
  %177 = load i8, i8* @usbfs_snoop, align 1
  %tobool260 = trunc i8 %177 to i1
  br i1 %tobool260, label %if.then261, label %if.end264

if.then261:                                       ; preds = %do.body259
  %178 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev262 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %178, i32 0, i32 11
  %call263 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev262, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.28, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end264

if.end264:                                        ; preds = %if.then261, %do.body259
  br label %do.end265

do.end265:                                        ; preds = %if.end264
  %179 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %180 = load i8*, i8** %p.addr, align 8
  %call266 = call i32 @proc_ioctl_default(%struct.dev_state* %179, i8* %180)
  store i32 %call266, i32* %ret, align 4
  br label %sw.epilog

sw.bb267:                                         ; preds = %NodeBlock11
  br label %do.body268

do.body268:                                       ; preds = %sw.bb267
  %181 = load i8, i8* @usbfs_snoop, align 1
  %tobool269 = trunc i8 %181 to i1
  br i1 %tobool269, label %if.then270, label %if.end273

if.then270:                                       ; preds = %do.body268
  %182 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev271 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %182, i32 0, i32 11
  %call272 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev271, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.29, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end273

if.end273:                                        ; preds = %if.then270, %do.body268
  br label %do.end274

do.end274:                                        ; preds = %if.end273
  %183 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %184 = load i8*, i8** %p.addr, align 8
  %call275 = call i32 @proc_claim_port(%struct.dev_state* %183, i8* %184)
  store i32 %call275, i32* %ret, align 4
  br label %sw.epilog

sw.bb276:                                         ; preds = %NodeBlock11
  br label %do.body277

do.body277:                                       ; preds = %sw.bb276
  %185 = load i8, i8* @usbfs_snoop, align 1
  %tobool278 = trunc i8 %185 to i1
  br i1 %tobool278, label %if.then279, label %if.end282

if.then279:                                       ; preds = %do.body277
  %186 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev280 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %186, i32 0, i32 11
  %call281 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev280, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %if.end282

if.end282:                                        ; preds = %if.then279, %do.body277
  br label %do.end283

do.end283:                                        ; preds = %if.end282
  %187 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %188 = load i8*, i8** %p.addr, align 8
  %call284 = call i32 @proc_release_port(%struct.dev_state* %187, i8* %188)
  store i32 %call284, i32* %ret, align 4
  br label %sw.epilog

sw.bb285:                                         ; preds = %LeafBlock17
  %189 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %190 = load i8*, i8** %p.addr, align 8
  %call286 = call i32 @proc_get_capabilities(%struct.dev_state* %189, i8* %190)
  store i32 %call286, i32* %ret, align 4
  br label %sw.epilog

sw.bb287:                                         ; preds = %LeafBlock35
  %191 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %192 = load i8*, i8** %p.addr, align 8
  %call288 = call i32 @proc_disconnect_claim(%struct.dev_state* %191, i8* %192)
  store i32 %call288, i32* %ret, align 4
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock85, %LeafBlock83, %LeafBlock79, %LeafBlock73, %LeafBlock71, %LeafBlock63, %LeafBlock61, %LeafBlock57, %LeafBlock55, %LeafBlock49, %LeafBlock47, %LeafBlock45, %LeafBlock35, %LeafBlock33, %LeafBlock29, %LeafBlock27, %LeafBlock21, %LeafBlock19, %LeafBlock17, %LeafBlock7, %LeafBlock5, %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %sw.bb287, %sw.bb285, %do.end283, %do.end274, %do.end265, %do.end256, %do.end247, %do.end238, %do.end229, %do.end220, %do.end211, %do.end201, %do.end192, %do.end183, %if.end175, %do.end159, %if.end151, %if.end136, %if.end121, %do.end105, %do.end96, %do.end87, %do.end78, %if.end70, %do.end54, %if.end46, %if.end31, %if.end16
  %193 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev289 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %193, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev289)
  %194 = load i32, i32* %ret, align 4
  %cmp290 = icmp sge i32 %194, 0
  br i1 %cmp290, label %if.then291, label %if.end294

if.then291:                                       ; preds = %sw.epilog
  %195 = load %struct.inode*, %struct.inode** %inode, align 8
  %i_atime = getelementptr inbounds %struct.inode, %struct.inode* %195, i32 0, i32 15
  %call292 = call { i64, i64 } @current_kernel_time()
  %196 = bitcast %struct.timespec* %coerce293 to { i64, i64 }*
  %197 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %196, i32 0, i32 0
  %198 = extractvalue { i64, i64 } %call292, 0
  store i64 %198, i64* %197, align 8
  %199 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %196, i32 0, i32 1
  %200 = extractvalue { i64, i64 } %call292, 1
  store i64 %200, i64* %199, align 8
  %201 = bitcast %struct.timespec* %i_atime to i8*
  %202 = bitcast %struct.timespec* %coerce293 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %201, i8* %202, i64 16, i32 8, i1 false)
  br label %if.end294

if.end294:                                        ; preds = %if.then291, %sw.epilog
  %203 = load i32, i32* %ret, align 4
  %conv = sext i32 %203 to i64
  store i64 %conv, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end294, %if.then5, %if.then
  %204 = load i64, i64* %retval, align 8
  ret i64 %204
}

declare i32 @_dev_info(%struct.device*, i8*, ...) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_control(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %dst.addr.i = alloca i8*, align 8
  %src.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %ctrl = alloca %struct.usbdevfs_ctrltransfer, align 8
  %tmo = alloca i32, align 4
  %tbuf = alloca i8*, align 8
  %wLength = alloca i32, align 4
  %i = alloca i32, align 4
  %pipe = alloca i32, align 4
  %ret = alloca i32, align 4
  %flag = alloca i64, align 8
  %roksum = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_max1 = alloca i32, align 4
  %_max2 = alloca i32, align 4
  %tmp71 = alloca i32, align 4
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %tmp76 = alloca i32, align 4
  %_max183 = alloca i32, align 4
  %_max284 = alloca i32, align 4
  %tmp87 = alloca i32, align 4
  %_max1134 = alloca i32, align 4
  %_max2135 = alloca i32, align 4
  %tmp138 = alloca i32, align 4
  %_min1145 = alloca i32, align 4
  %_min2146 = alloca i32, align 4
  %tmp149 = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %1, %struct.usb_device** %dev, align 8
  %2 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  %3 = load i8*, i8** %arg.addr, align 8
  %call = call i64 @copy_from_user(i8* %2, i8* %3, i64 24)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %bRequestType = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %5 = load i8, i8* %bRequestType, align 8
  %conv = zext i8 %5 to i32
  %bRequest = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %6 = load i8, i8* %bRequest, align 1
  %conv2 = zext i8 %6 to i32
  %wIndex = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %7 = load i16, i16* %wIndex, align 4
  %conv3 = zext i16 %7 to i32
  %call4 = call i32 @check_ctrlrecip(%struct.dev_state* %4, i32 %conv, i32 %conv2, i32 %conv3)
  store i32 %call4, i32* %ret, align 4
  %8 = load i32, i32* %ret, align 4
  %tobool5 = icmp ne i32 %8, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %9 = load i32, i32* %ret, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %wLength8 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %10 = load i16, i16* %wLength8, align 2
  %conv9 = zext i16 %10 to i32
  store i32 %conv9, i32* %wLength, align 4
  %11 = load i32, i32* %wLength, align 4
  %conv10 = zext i32 %11 to i64
  %cmp = icmp ugt i64 %conv10, 4096
  br i1 %cmp, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end7
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end7
  %call14 = call i32 @usbfs_increase_memory_usage(i32 4296)
  store i32 %call14, i32* %ret, align 4
  %12 = load i32, i32* %ret, align 4
  %tobool15 = icmp ne i32 %12, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  %13 = load i32, i32* %ret, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end13
  %call18 = call i64 @__get_free_pages(i32 208, i32 0)
  %14 = inttoptr i64 %call18 to i8*
  store i8* %14, i8** %tbuf, align 8
  %15 = load i8*, i8** %tbuf, align 8
  %tobool19 = icmp ne i8* %15, null
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end17
  store i32 -12, i32* %ret, align 4
  br label %done

if.end21:                                         ; preds = %if.end17
  %timeout = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 5
  %16 = load i32, i32* %timeout, align 8
  store i32 %16, i32* %tmo, align 4
  br label %do.body

do.body:                                          ; preds = %if.end21
  %17 = load i8, i8* @usbfs_snoop, align 1
  %tobool22 = trunc i8 %17 to i1
  br i1 %tobool22, label %if.then23, label %if.end38

if.then23:                                        ; preds = %do.body
  %18 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %bRequestType25 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %19 = load i8, i8* %bRequestType25, align 8
  %conv26 = zext i8 %19 to i32
  %bRequest27 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %20 = load i8, i8* %bRequest27, align 1
  %conv28 = zext i8 %20 to i32
  %wValue = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %call29 = call zeroext i16 @__le16_to_cpup(i16* %wValue)
  %conv30 = zext i16 %call29 to i32
  %wIndex31 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %call32 = call zeroext i16 @__le16_to_cpup(i16* %wIndex31)
  %conv33 = zext i16 %call32 to i32
  %wLength34 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %call35 = call zeroext i16 @__le16_to_cpup(i16* %wLength34)
  %conv36 = zext i16 %call35 to i32
  %call37 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev24, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @.str.31, i32 0, i32 0), i32 %conv26, i32 %conv28, i32 %conv30, i32 %conv33, i32 %conv36)
  br label %if.end38

if.end38:                                         ; preds = %if.then23, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end38
  %bRequestType39 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %21 = load i8, i8* %bRequestType39, align 8
  %conv40 = zext i8 %21 to i32
  %and = and i32 %conv40, 128
  %tobool41 = icmp ne i32 %and, 0
  br i1 %tobool41, label %if.then42, label %if.else

if.then42:                                        ; preds = %do.end
  %wLength43 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %22 = load i16, i16* %wLength43, align 2
  %conv44 = zext i16 %22 to i32
  %tobool45 = icmp ne i32 %conv44, 0
  br i1 %tobool45, label %land.lhs.true, label %if.end56

land.lhs.true:                                    ; preds = %if.then42
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %23 = load i8*, i8** %data, align 8
  %wLength46 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %24 = load i16, i16* %wLength46, align 2
  %conv47 = zext i16 %24 to i64
  %call48 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call48, i32 0, i32 6
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %25 = load i64, i64* %seg, align 8
  %26 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %23, i64 %conv47, i64 %25) #7, !srcloc !6
  %asmresult = extractvalue { i64, i64 } %26, 0
  %asmresult49 = extractvalue { i64, i64 } %26, 1
  store i64 %asmresult, i64* %flag, align 8
  store i64 %asmresult49, i64* %roksum, align 8
  %27 = load i64, i64* %flag, align 8
  store i64 %27, i64* %tmp, align 8
  %28 = load i64, i64* %tmp, align 8
  %cmp50 = icmp eq i64 %28, 0
  %lnot = xor i1 %cmp50, true
  %lnot52 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot52 to i32
  %conv53 = sext i32 %lnot.ext to i64
  %tobool54 = icmp ne i64 %conv53, 0
  br i1 %tobool54, label %if.end56, label %if.then55

if.then55:                                        ; preds = %land.lhs.true
  store i32 -22, i32* %ret, align 4
  br label %done

if.end56:                                         ; preds = %land.lhs.true, %if.then42
  %29 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %call57 = call i32 @__create_pipe(%struct.usb_device* %29, i32 0)
  %or = or i32 -2147483648, %call57
  %or58 = or i32 %or, 128
  store i32 %or58, i32* %pipe, align 4
  %30 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %31 = load i32, i32* %pipe, align 4
  %wLength59 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %32 = load i16, i16* %wLength59, align 2
  %conv60 = zext i16 %32 to i32
  %33 = load i32, i32* %tmo, align 4
  call void @snoop_urb(%struct.usb_device* %30, i8* null, i32 %31, i32 %conv60, i32 %33, i32 0, i8* null, i32 0)
  %34 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev61 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %34, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev61)
  %35 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %36 = load i32, i32* %pipe, align 4
  %bRequest62 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %37 = load i8, i8* %bRequest62, align 1
  %bRequestType63 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %38 = load i8, i8* %bRequestType63, align 8
  %wValue64 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %39 = load i16, i16* %wValue64, align 2
  %wIndex65 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %40 = load i16, i16* %wIndex65, align 4
  %41 = load i8*, i8** %tbuf, align 8
  %wLength66 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %42 = load i16, i16* %wLength66, align 2
  %43 = load i32, i32* %tmo, align 4
  %call67 = call i32 @usb_control_msg(%struct.usb_device* %35, i32 %36, i8 zeroext %37, i8 zeroext %38, i16 zeroext %39, i16 zeroext %40, i8* %41, i16 zeroext %42, i32 %43)
  store i32 %call67, i32* %i, align 4
  %44 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev68 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %44, i32 0, i32 11
  call void @device_lock(%struct.device* %dev68)
  %45 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %46 = load i32, i32* %pipe, align 4
  %47 = load i32, i32* %i, align 4
  store i32 %47, i32* %_max1, align 4
  store i32 0, i32* %_max2, align 4
  %cmp69 = icmp eq i32* %_max1, %_max2
  %conv70 = zext i1 %cmp69 to i32
  %48 = load i32, i32* %_max1, align 4
  %49 = load i32, i32* %_max2, align 4
  %cmp72 = icmp sgt i32 %48, %49
  br i1 %cmp72, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end56
  %50 = load i32, i32* %_max1, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end56
  %51 = load i32, i32* %_max2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %50, %cond.true ], [ %51, %cond.false ]
  store i32 %cond, i32* %tmp71, align 4
  %52 = load i32, i32* %tmp71, align 4
  %53 = load i32, i32* %i, align 4
  store i32 %53, i32* %_min1, align 4
  store i32 0, i32* %_min2, align 4
  %cmp74 = icmp eq i32* %_min1, %_min2
  %conv75 = zext i1 %cmp74 to i32
  %54 = load i32, i32* %_min1, align 4
  %55 = load i32, i32* %_min2, align 4
  %cmp77 = icmp slt i32 %54, %55
  br i1 %cmp77, label %cond.true79, label %cond.false80

cond.true79:                                      ; preds = %cond.end
  %56 = load i32, i32* %_min1, align 4
  br label %cond.end81

cond.false80:                                     ; preds = %cond.end
  %57 = load i32, i32* %_min2, align 4
  br label %cond.end81

cond.end81:                                       ; preds = %cond.false80, %cond.true79
  %cond82 = phi i32 [ %56, %cond.true79 ], [ %57, %cond.false80 ]
  store i32 %cond82, i32* %tmp76, align 4
  %58 = load i32, i32* %tmp76, align 4
  %59 = load i8*, i8** %tbuf, align 8
  %60 = load i32, i32* %i, align 4
  store i32 %60, i32* %_max183, align 4
  store i32 0, i32* %_max284, align 4
  %cmp85 = icmp eq i32* %_max183, %_max284
  %conv86 = zext i1 %cmp85 to i32
  %61 = load i32, i32* %_max183, align 4
  %62 = load i32, i32* %_max284, align 4
  %cmp88 = icmp sgt i32 %61, %62
  br i1 %cmp88, label %cond.true90, label %cond.false91

cond.true90:                                      ; preds = %cond.end81
  %63 = load i32, i32* %_max183, align 4
  br label %cond.end92

cond.false91:                                     ; preds = %cond.end81
  %64 = load i32, i32* %_max284, align 4
  br label %cond.end92

cond.end92:                                       ; preds = %cond.false91, %cond.true90
  %cond93 = phi i32 [ %63, %cond.true90 ], [ %64, %cond.false91 ]
  store i32 %cond93, i32* %tmp87, align 4
  %65 = load i32, i32* %tmp87, align 4
  call void @snoop_urb(%struct.usb_device* %45, i8* null, i32 %46, i32 %52, i32 %58, i32 1, i8* %59, i32 %65)
  %66 = load i32, i32* %i, align 4
  %cmp94 = icmp sgt i32 %66, 0
  br i1 %cmp94, label %land.lhs.true96, label %if.end106

land.lhs.true96:                                  ; preds = %cond.end92
  %wLength97 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %67 = load i16, i16* %wLength97, align 2
  %conv98 = zext i16 %67 to i32
  %tobool99 = icmp ne i32 %conv98, 0
  br i1 %tobool99, label %if.then100, label %if.end106

if.then100:                                       ; preds = %land.lhs.true96
  %data101 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %68 = load i8*, i8** %data101, align 8
  %69 = load i8*, i8** %tbuf, align 8
  %70 = load i32, i32* %i, align 4
  store i8* %68, i8** %dst.addr.i, align 8
  store i8* %69, i8** %src.addr.i, align 8
  store i32 %70, i32* %size.addr.i, align 4
  call void @might_fault() #5
  %71 = load i8*, i8** %dst.addr.i, align 8
  %72 = load i8*, i8** %src.addr.i, align 8
  %73 = load i32, i32* %size.addr.i, align 4
  %call.i = call i64 @_copy_to_user(i8* %71, i8* %72, i32 %73) #5
  %conv.i = trunc i64 %call.i to i32
  %tobool103 = icmp ne i32 %conv.i, 0
  br i1 %tobool103, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.then100
  store i32 -14, i32* %ret, align 4
  br label %done

if.end105:                                        ; preds = %if.then100
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %land.lhs.true96, %cond.end92
  br label %if.end156

if.else:                                          ; preds = %do.end
  %wLength107 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %74 = load i16, i16* %wLength107, align 2
  %tobool108 = icmp ne i16 %74, 0
  br i1 %tobool108, label %if.then109, label %if.end117

if.then109:                                       ; preds = %if.else
  %75 = load i8*, i8** %tbuf, align 8
  %data110 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %76 = load i8*, i8** %data110, align 8
  %wLength111 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %77 = load i16, i16* %wLength111, align 2
  %conv112 = zext i16 %77 to i64
  %call113 = call i64 @copy_from_user(i8* %75, i8* %76, i64 %conv112)
  %tobool114 = icmp ne i64 %call113, 0
  br i1 %tobool114, label %if.then115, label %if.end116

if.then115:                                       ; preds = %if.then109
  store i32 -14, i32* %ret, align 4
  br label %done

if.end116:                                        ; preds = %if.then109
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.else
  %78 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %call118 = call i32 @__create_pipe(%struct.usb_device* %78, i32 0)
  %or119 = or i32 -2147483648, %call118
  store i32 %or119, i32* %pipe, align 4
  %79 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %80 = load i32, i32* %pipe, align 4
  %wLength120 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %81 = load i16, i16* %wLength120, align 2
  %conv121 = zext i16 %81 to i32
  %82 = load i32, i32* %tmo, align 4
  %83 = load i8*, i8** %tbuf, align 8
  %wLength122 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %84 = load i16, i16* %wLength122, align 2
  %conv123 = zext i16 %84 to i32
  call void @snoop_urb(%struct.usb_device* %79, i8* null, i32 %80, i32 %conv121, i32 %82, i32 0, i8* %83, i32 %conv123)
  %85 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev124 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %85, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev124)
  %86 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %87 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %call125 = call i32 @__create_pipe(%struct.usb_device* %87, i32 0)
  %or126 = or i32 -2147483648, %call125
  %bRequest127 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %88 = load i8, i8* %bRequest127, align 1
  %bRequestType128 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %89 = load i8, i8* %bRequestType128, align 8
  %wValue129 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %90 = load i16, i16* %wValue129, align 2
  %wIndex130 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %91 = load i16, i16* %wIndex130, align 4
  %92 = load i8*, i8** %tbuf, align 8
  %wLength131 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %93 = load i16, i16* %wLength131, align 2
  %94 = load i32, i32* %tmo, align 4
  %call132 = call i32 @usb_control_msg(%struct.usb_device* %86, i32 %or126, i8 zeroext %88, i8 zeroext %89, i16 zeroext %90, i16 zeroext %91, i8* %92, i16 zeroext %93, i32 %94)
  store i32 %call132, i32* %i, align 4
  %95 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev133 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %95, i32 0, i32 11
  call void @device_lock(%struct.device* %dev133)
  %96 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %97 = load i32, i32* %pipe, align 4
  %98 = load i32, i32* %i, align 4
  store i32 %98, i32* %_max1134, align 4
  store i32 0, i32* %_max2135, align 4
  %cmp136 = icmp eq i32* %_max1134, %_max2135
  %conv137 = zext i1 %cmp136 to i32
  %99 = load i32, i32* %_max1134, align 4
  %100 = load i32, i32* %_max2135, align 4
  %cmp139 = icmp sgt i32 %99, %100
  br i1 %cmp139, label %cond.true141, label %cond.false142

cond.true141:                                     ; preds = %if.end117
  %101 = load i32, i32* %_max1134, align 4
  br label %cond.end143

cond.false142:                                    ; preds = %if.end117
  %102 = load i32, i32* %_max2135, align 4
  br label %cond.end143

cond.end143:                                      ; preds = %cond.false142, %cond.true141
  %cond144 = phi i32 [ %101, %cond.true141 ], [ %102, %cond.false142 ]
  store i32 %cond144, i32* %tmp138, align 4
  %103 = load i32, i32* %tmp138, align 4
  %104 = load i32, i32* %i, align 4
  store i32 %104, i32* %_min1145, align 4
  store i32 0, i32* %_min2146, align 4
  %cmp147 = icmp eq i32* %_min1145, %_min2146
  %conv148 = zext i1 %cmp147 to i32
  %105 = load i32, i32* %_min1145, align 4
  %106 = load i32, i32* %_min2146, align 4
  %cmp150 = icmp slt i32 %105, %106
  br i1 %cmp150, label %cond.true152, label %cond.false153

cond.true152:                                     ; preds = %cond.end143
  %107 = load i32, i32* %_min1145, align 4
  br label %cond.end154

cond.false153:                                    ; preds = %cond.end143
  %108 = load i32, i32* %_min2146, align 4
  br label %cond.end154

cond.end154:                                      ; preds = %cond.false153, %cond.true152
  %cond155 = phi i32 [ %107, %cond.true152 ], [ %108, %cond.false153 ]
  store i32 %cond155, i32* %tmp149, align 4
  %109 = load i32, i32* %tmp149, align 4
  call void @snoop_urb(%struct.usb_device* %96, i8* null, i32 %97, i32 %103, i32 %109, i32 1, i8* null, i32 0)
  br label %if.end156

if.end156:                                        ; preds = %cond.end154, %if.end106
  %110 = load i32, i32* %i, align 4
  %cmp157 = icmp slt i32 %110, 0
  br i1 %cmp157, label %land.lhs.true159, label %if.end172

land.lhs.true159:                                 ; preds = %if.end156
  %111 = load i32, i32* %i, align 4
  %cmp160 = icmp ne i32 %111, -32
  br i1 %cmp160, label %if.then162, label %if.end172

if.then162:                                       ; preds = %land.lhs.true159
  %112 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev163 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %112, i32 0, i32 11
  %113 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %113, %struct.task_struct** %pfo_ret__.i, align 8
  %114 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %114, %struct.task_struct** %tmp.i, align 8
  %115 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %115, i32 0, i32 64
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %bRequestType165 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %116 = load i8, i8* %bRequestType165, align 8
  %conv166 = zext i8 %116 to i32
  %bRequest167 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %117 = load i8, i8* %bRequest167, align 1
  %conv168 = zext i8 %117 to i32
  %wLength169 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %118 = load i16, i16* %wLength169, align 2
  %conv170 = zext i16 %118 to i32
  %119 = load i32, i32* %i, align 4
  %call171 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %dev163, i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.33, i32 0, i32 0), i8* %arraydecay, i32 %conv166, i32 %conv168, i32 %conv170, i32 %119)
  br label %if.end172

if.end172:                                        ; preds = %if.then162, %land.lhs.true159, %if.end156
  %120 = load i32, i32* %i, align 4
  store i32 %120, i32* %ret, align 4
  br label %done

done:                                             ; preds = %if.end172, %if.then115, %if.then104, %if.then55, %if.then20
  %121 = load i8*, i8** %tbuf, align 8
  %122 = ptrtoint i8* %121 to i64
  call void @free_pages(i64 %122, i32 0)
  call void @usbfs_decrease_memory_usage(i32 4296)
  %123 = load i32, i32* %ret, align 4
  store i32 %123, i32* %retval, align 4
  br label %return

return:                                           ; preds = %done, %if.then16, %if.then12, %if.then6, %if.then
  %124 = load i32, i32* %retval, align 4
  ret i32 %124
}

declare { i64, i64 } @current_kernel_time() #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_bulk(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %dst.addr.i = alloca i8*, align 8
  %src.addr.i = alloca i8*, align 8
  %size.addr.i92 = alloca i32, align 4
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %bulk = alloca %struct.usbdevfs_bulktransfer, align 8
  %tmo = alloca i32, align 4
  %len1 = alloca i32, align 4
  %pipe = alloca i32, align 4
  %len2 = alloca i32, align 4
  %tbuf = alloca i8*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %flag = alloca i64, align 8
  %roksum = alloca i64, align 8
  %tmp = alloca i64, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %1, %struct.usb_device** %dev, align 8
  %2 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  %3 = load i8*, i8** %arg.addr, align 8
  %call = call i64 @copy_from_user(i8* %2, i8* %3, i64 24)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %4, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8
  %ep = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %6 = load i32, i32* %ep, align 8
  %call3 = call i32 @findintfep(%struct.usb_device* %5, i32 %6)
  store i32 %call3, i32* %ret, align 4
  %7 = load i32, i32* %ret, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %8 = load i32, i32* %ret, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %9 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %10 = load i32, i32* %ret, align 4
  %call6 = call i32 @checkintf(%struct.dev_state* %9, i32 %10)
  store i32 %call6, i32* %ret, align 4
  %11 = load i32, i32* %ret, align 4
  %tobool7 = icmp ne i32 %11, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %12 = load i32, i32* %ret, align 4
  store i32 %12, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end5
  %ep10 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %13 = load i32, i32* %ep10, align 8
  %and = and i32 %13, 128
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end9
  %14 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %ep13 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %15 = load i32, i32* %ep13, align 8
  %and14 = and i32 %15, 127
  %call15 = call i32 @__create_pipe(%struct.usb_device* %14, i32 %and14)
  %or = or i32 -1073741824, %call15
  %or16 = or i32 %or, 128
  store i32 %or16, i32* %pipe, align 4
  br label %if.end21

if.else:                                          ; preds = %if.end9
  %16 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %ep17 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %17 = load i32, i32* %ep17, align 8
  %and18 = and i32 %17, 127
  %call19 = call i32 @__create_pipe(%struct.usb_device* %16, i32 %and18)
  %or20 = or i32 -1073741824, %call19
  store i32 %or20, i32* %pipe, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then12
  %18 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %19 = load i32, i32* %pipe, align 4
  %ep22 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %20 = load i32, i32* %ep22, align 8
  %and23 = and i32 %20, 128
  %tobool24 = icmp ne i32 %and23, 0
  %lnot = xor i1 %tobool24, true
  %lnot.ext = zext i1 %lnot to i32
  %call25 = call zeroext i16 @usb_maxpacket(%struct.usb_device* %18, i32 %19, i32 %lnot.ext)
  %tobool26 = icmp ne i16 %call25, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end21
  store i32 -22, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end21
  %len = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 1
  %21 = load i32, i32* %len, align 4
  store i32 %21, i32* %len1, align 4
  %22 = load i32, i32* %len1, align 4
  %cmp29 = icmp uge i32 %22, 2146483647
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end28
  store i32 -22, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end28
  %23 = load i32, i32* %len1, align 4
  %conv = zext i32 %23 to i64
  %add = add i64 %conv, 192
  %conv32 = trunc i64 %add to i32
  %call33 = call i32 @usbfs_increase_memory_usage(i32 %conv32)
  store i32 %call33, i32* %ret, align 4
  %24 = load i32, i32* %ret, align 4
  %tobool34 = icmp ne i32 %24, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end31
  %25 = load i32, i32* %ret, align 4
  store i32 %25, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.end31
  %26 = load i32, i32* %len1, align 4
  %conv37 = zext i32 %26 to i64
  store i64 %conv37, i64* %size.addr.i, align 8
  store i32 208, i32* %flags.addr.i, align 4
  %27 = load i64, i64* %size.addr.i, align 8
  %28 = load i32, i32* %flags.addr.i, align 4
  %call.i = call i8* @__kmalloc(i64 %27, i32 %28) #5
  store i8* %call.i, i8** %tbuf, align 8
  %tobool39 = icmp ne i8* %call.i, null
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.end36
  store i32 -12, i32* %ret, align 4
  br label %done

if.end41:                                         ; preds = %if.end36
  %timeout = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 2
  %29 = load i32, i32* %timeout, align 8
  store i32 %29, i32* %tmo, align 4
  %ep42 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %30 = load i32, i32* %ep42, align 8
  %and43 = and i32 %30, 128
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then45, label %if.else73

if.then45:                                        ; preds = %if.end41
  %31 = load i32, i32* %len1, align 4
  %tobool46 = icmp ne i32 %31, 0
  br i1 %tobool46, label %land.lhs.true, label %if.end59

land.lhs.true:                                    ; preds = %if.then45
  %data = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %32 = load i8*, i8** %data, align 8
  %33 = load i32, i32* %len1, align 4
  %conv47 = zext i32 %33 to i64
  %call48 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call48, i32 0, i32 6
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %34 = load i64, i64* %seg, align 8
  %35 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %32, i64 %conv47, i64 %34) #7, !srcloc !7
  %asmresult = extractvalue { i64, i64 } %35, 0
  %asmresult49 = extractvalue { i64, i64 } %35, 1
  store i64 %asmresult, i64* %flag, align 8
  store i64 %asmresult49, i64* %roksum, align 8
  %36 = load i64, i64* %flag, align 8
  store i64 %36, i64* %tmp, align 8
  %37 = load i64, i64* %tmp, align 8
  %cmp50 = icmp eq i64 %37, 0
  %lnot52 = xor i1 %cmp50, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %conv56 = sext i32 %lnot.ext55 to i64
  %tobool57 = icmp ne i64 %conv56, 0
  br i1 %tobool57, label %if.end59, label %if.then58

if.then58:                                        ; preds = %land.lhs.true
  store i32 -22, i32* %ret, align 4
  br label %done

if.end59:                                         ; preds = %land.lhs.true, %if.then45
  %38 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %39 = load i32, i32* %pipe, align 4
  %40 = load i32, i32* %len1, align 4
  %41 = load i32, i32* %tmo, align 4
  call void @snoop_urb(%struct.usb_device* %38, i8* null, i32 %39, i32 %40, i32 %41, i32 0, i8* null, i32 0)
  %42 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev60 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %42, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev60)
  %43 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %44 = load i32, i32* %pipe, align 4
  %45 = load i8*, i8** %tbuf, align 8
  %46 = load i32, i32* %len1, align 4
  %47 = load i32, i32* %tmo, align 4
  %call61 = call i32 @usb_bulk_msg(%struct.usb_device* %43, i32 %44, i8* %45, i32 %46, i32* %len2, i32 %47)
  store i32 %call61, i32* %i, align 4
  %48 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %48, i32 0, i32 11
  call void @device_lock(%struct.device* %dev62)
  %49 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %50 = load i32, i32* %pipe, align 4
  %51 = load i32, i32* %len2, align 4
  %52 = load i32, i32* %i, align 4
  %53 = load i8*, i8** %tbuf, align 8
  %54 = load i32, i32* %len2, align 4
  call void @snoop_urb(%struct.usb_device* %49, i8* null, i32 %50, i32 %51, i32 %52, i32 1, i8* %53, i32 %54)
  %55 = load i32, i32* %i, align 4
  %tobool63 = icmp ne i32 %55, 0
  br i1 %tobool63, label %if.end72, label %land.lhs.true64

land.lhs.true64:                                  ; preds = %if.end59
  %56 = load i32, i32* %len2, align 4
  %tobool65 = icmp ne i32 %56, 0
  br i1 %tobool65, label %if.then66, label %if.end72

if.then66:                                        ; preds = %land.lhs.true64
  %data67 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %57 = load i8*, i8** %data67, align 8
  %58 = load i8*, i8** %tbuf, align 8
  %59 = load i32, i32* %len2, align 4
  store i8* %57, i8** %dst.addr.i, align 8
  store i8* %58, i8** %src.addr.i, align 8
  store i32 %59, i32* %size.addr.i92, align 4
  call void @might_fault() #5
  %60 = load i8*, i8** %dst.addr.i, align 8
  %61 = load i8*, i8** %src.addr.i, align 8
  %62 = load i32, i32* %size.addr.i92, align 4
  %call.i93 = call i64 @_copy_to_user(i8* %60, i8* %61, i32 %62) #5
  %conv.i = trunc i64 %call.i93 to i32
  %tobool69 = icmp ne i32 %conv.i, 0
  br i1 %tobool69, label %if.then70, label %if.end71

if.then70:                                        ; preds = %if.then66
  store i32 -14, i32* %ret, align 4
  br label %done

if.end71:                                         ; preds = %if.then66
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %land.lhs.true64, %if.end59
  br label %if.end86

if.else73:                                        ; preds = %if.end41
  %63 = load i32, i32* %len1, align 4
  %tobool74 = icmp ne i32 %63, 0
  br i1 %tobool74, label %if.then75, label %if.end82

if.then75:                                        ; preds = %if.else73
  %64 = load i8*, i8** %tbuf, align 8
  %data76 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %65 = load i8*, i8** %data76, align 8
  %66 = load i32, i32* %len1, align 4
  %conv77 = zext i32 %66 to i64
  %call78 = call i64 @copy_from_user(i8* %64, i8* %65, i64 %conv77)
  %tobool79 = icmp ne i64 %call78, 0
  br i1 %tobool79, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.then75
  store i32 -14, i32* %ret, align 4
  br label %done

if.end81:                                         ; preds = %if.then75
  br label %if.end82

if.end82:                                         ; preds = %if.end81, %if.else73
  %67 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %68 = load i32, i32* %pipe, align 4
  %69 = load i32, i32* %len1, align 4
  %70 = load i32, i32* %tmo, align 4
  %71 = load i8*, i8** %tbuf, align 8
  %72 = load i32, i32* %len1, align 4
  call void @snoop_urb(%struct.usb_device* %67, i8* null, i32 %68, i32 %69, i32 %70, i32 0, i8* %71, i32 %72)
  %73 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev83 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %73, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev83)
  %74 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %75 = load i32, i32* %pipe, align 4
  %76 = load i8*, i8** %tbuf, align 8
  %77 = load i32, i32* %len1, align 4
  %78 = load i32, i32* %tmo, align 4
  %call84 = call i32 @usb_bulk_msg(%struct.usb_device* %74, i32 %75, i8* %76, i32 %77, i32* %len2, i32 %78)
  store i32 %call84, i32* %i, align 4
  %79 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev85 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %79, i32 0, i32 11
  call void @device_lock(%struct.device* %dev85)
  %80 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %81 = load i32, i32* %pipe, align 4
  %82 = load i32, i32* %len2, align 4
  %83 = load i32, i32* %i, align 4
  call void @snoop_urb(%struct.usb_device* %80, i8* null, i32 %81, i32 %82, i32 %83, i32 1, i8* null, i32 0)
  br label %if.end86

if.end86:                                         ; preds = %if.end82, %if.end72
  %84 = load i32, i32* %i, align 4
  %cmp87 = icmp slt i32 %84, 0
  br i1 %cmp87, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end86
  %85 = load i32, i32* %i, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end86
  %86 = load i32, i32* %len2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %85, %cond.true ], [ %86, %cond.false ]
  store i32 %cond, i32* %ret, align 4
  br label %done

done:                                             ; preds = %cond.end, %if.then80, %if.then70, %if.then58, %if.then40
  %87 = load i8*, i8** %tbuf, align 8
  call void @kfree(i8* %87)
  %88 = load i32, i32* %len1, align 4
  %conv89 = zext i32 %88 to i64
  %add90 = add i64 %conv89, 192
  %conv91 = trunc i64 %add90 to i32
  call void @usbfs_decrease_memory_usage(i32 %conv91)
  %89 = load i32, i32* %ret, align 4
  store i32 %89, i32* %retval, align 4
  br label %return

return:                                           ; preds = %done, %if.then35, %if.then30, %if.then27, %if.then8, %if.then4, %if.then
  %90 = load i32, i32* %retval, align 4
  ret i32 %90
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_resetep(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ep = alloca i32, align 4
  %ret = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %arg.addr, align 8
  %1 = bitcast i8* %0 to i32*
  %2 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %1, i64 4) #5, !srcloc !8
  %asmresult = extractvalue { i32*, i64 } %2, 0
  %asmresult1 = extractvalue { i32*, i64 } %2, 1
  %3 = ptrtoint i32* %asmresult to i64
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  %5 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, i32* %ep, align 4
  %6 = load i32, i32* %__ret_gu, align 4
  store i32 %6, i32* %tmp, align 4
  %7 = load i32, i32* %tmp, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %8, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %10 = load i32, i32* %ep, align 4
  %call = call i32 @findintfep(%struct.usb_device* %9, i32 %10)
  store i32 %call, i32* %ret, align 4
  %11 = load i32, i32* %ret, align 4
  %cmp = icmp slt i32 %11, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %12 = load i32, i32* %ret, align 4
  store i32 %12, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %13 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %14 = load i32, i32* %ret, align 4
  %call5 = call i32 @checkintf(%struct.dev_state* %13, i32 %14)
  store i32 %call5, i32* %ret, align 4
  %15 = load i32, i32* %ret, align 4
  %tobool6 = icmp ne i32 %15, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %16 = load i32, i32* %ret, align 4
  store i32 %16, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end4
  %17 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %17, i32 0, i32 1
  %18 = load %struct.usb_device*, %struct.usb_device** %dev9, align 8
  %19 = load i32, i32* %ep, align 4
  call void @usb_reset_endpoint(%struct.usb_device* %18, i32 %19)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then7, %if.then3, %if.then
  %20 = load i32, i32* %retval, align 4
  ret i32 %20
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_resetdevice(%struct.dev_state* %ps) #0 {
entry:
  %ps.addr = alloca %struct.dev_state*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %call = call i32 @usb_reset_device(%struct.usb_device* %1)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_clearhalt(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ep = alloca i32, align 4
  %pipe = alloca i32, align 4
  %ret = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %arg.addr, align 8
  %1 = bitcast i8* %0 to i32*
  %2 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %1, i64 4) #5, !srcloc !9
  %asmresult = extractvalue { i32*, i64 } %2, 0
  %asmresult1 = extractvalue { i32*, i64 } %2, 1
  %3 = ptrtoint i32* %asmresult to i64
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  %5 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, i32* %ep, align 4
  %6 = load i32, i32* %__ret_gu, align 4
  store i32 %6, i32* %tmp, align 4
  %7 = load i32, i32* %tmp, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %8, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %10 = load i32, i32* %ep, align 4
  %call = call i32 @findintfep(%struct.usb_device* %9, i32 %10)
  store i32 %call, i32* %ret, align 4
  %11 = load i32, i32* %ret, align 4
  %cmp = icmp slt i32 %11, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %12 = load i32, i32* %ret, align 4
  store i32 %12, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %13 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %14 = load i32, i32* %ret, align 4
  %call5 = call i32 @checkintf(%struct.dev_state* %13, i32 %14)
  store i32 %call5, i32* %ret, align 4
  %15 = load i32, i32* %ret, align 4
  %tobool6 = icmp ne i32 %15, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %16 = load i32, i32* %ret, align 4
  store i32 %16, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end4
  %17 = load i32, i32* %ep, align 4
  %and = and i32 %17, 128
  %tobool9 = icmp ne i32 %and, 0
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end8
  %18 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %18, i32 0, i32 1
  %19 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8
  %20 = load i32, i32* %ep, align 4
  %and12 = and i32 %20, 127
  %call13 = call i32 @__create_pipe(%struct.usb_device* %19, i32 %and12)
  %or = or i32 -1073741824, %call13
  %or14 = or i32 %or, 128
  store i32 %or14, i32* %pipe, align 4
  br label %if.end19

if.else:                                          ; preds = %if.end8
  %21 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev15 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %21, i32 0, i32 1
  %22 = load %struct.usb_device*, %struct.usb_device** %dev15, align 8
  %23 = load i32, i32* %ep, align 4
  %and16 = and i32 %23, 127
  %call17 = call i32 @__create_pipe(%struct.usb_device* %22, i32 %and16)
  %or18 = or i32 -1073741824, %call17
  store i32 %or18, i32* %pipe, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then10
  %24 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev20 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %24, i32 0, i32 1
  %25 = load %struct.usb_device*, %struct.usb_device** %dev20, align 8
  %26 = load i32, i32* %pipe, align 4
  %call21 = call i32 @usb_clear_halt(%struct.usb_device* %25, i32 %26)
  store i32 %call21, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end19, %if.then7, %if.then3, %if.then
  %27 = load i32, i32* %retval, align 4
  ret i32 %27
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_getdriver(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %dst.addr.i = alloca i8*, align 8
  %src.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %gd = alloca %struct.usbdevfs_getdriver, align 4
  %intf = alloca %struct.usb_interface*, align 8
  %ret = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  %call = call i64 @copy_from_user(i8* %0, i8* %1, i64 260)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %interface = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 0
  %4 = load i32, i32* %interface, align 4
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %3, i32 %4)
  store %struct.usb_interface* %call1, %struct.usb_interface** %intf, align 8
  %5 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %tobool2 = icmp ne %struct.usb_interface* %5, null
  br i1 %tobool2, label %lor.lhs.false, label %if.then5

lor.lhs.false:                                    ; preds = %if.end
  %6 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %6, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev3, i32 0, i32 7
  %7 = load %struct.device_driver*, %struct.device_driver** %driver, align 8
  %tobool4 = icmp ne %struct.device_driver* %7, null
  br i1 %tobool4, label %if.else, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  store i32 -61, i32* %ret, align 4
  br label %if.end12

if.else:                                          ; preds = %lor.lhs.false
  %driver6 = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 1
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver6, i32 0, i32 0
  %8 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev7 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %8, i32 0, i32 7
  %driver8 = getelementptr inbounds %struct.device, %struct.device* %dev7, i32 0, i32 7
  %9 = load %struct.device_driver*, %struct.device_driver** %driver8, align 8
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %9, i32 0, i32 0
  %10 = load i8*, i8** %name, align 8
  %call9 = call i64 @strlcpy(i8* %arraydecay, i8* %10, i64 256)
  %11 = load i8*, i8** %arg.addr, align 8
  %12 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  store i8* %11, i8** %dst.addr.i, align 8
  store i8* %12, i8** %src.addr.i, align 8
  store i32 260, i32* %size.addr.i, align 4
  call void @might_fault() #5
  %13 = load i8*, i8** %dst.addr.i, align 8
  %14 = load i8*, i8** %src.addr.i, align 8
  %15 = load i32, i32* %size.addr.i, align 4
  %call.i = call i64 @_copy_to_user(i8* %13, i8* %14, i32 %15) #5
  %conv.i = trunc i64 %call.i to i32
  %tobool11 = icmp ne i32 %conv.i, 0
  %16 = zext i1 %tobool11 to i64
  %cond = select i1 %tobool11, i32 -14, i32 0
  store i32 %cond, i32* %ret, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then5
  %17 = load i32, i32* %ret, align 4
  store i32 %17, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_connectinfo(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %dst.addr.i = alloca i8*, align 8
  %src.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ci = alloca %struct.usbdevfs_connectinfo, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %devnum = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 0
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %devnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 0
  %2 = load i32, i32* %devnum1, align 8
  store i32 %2, i32* %devnum, align 4
  %slow = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 1
  %3 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 4
  %5 = load i32, i32* %speed, align 4
  %cmp = icmp eq i32 %5, 1
  %conv = zext i1 %cmp to i32
  %conv3 = trunc i32 %conv to i8
  store i8 %conv3, i8* %slow, align 4
  %6 = load i8*, i8** %arg.addr, align 8
  %7 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  store i8* %6, i8** %dst.addr.i, align 8
  store i8* %7, i8** %src.addr.i, align 8
  store i32 8, i32* %size.addr.i, align 4
  call void @might_fault() #5
  %8 = load i8*, i8** %dst.addr.i, align 8
  %9 = load i8*, i8** %src.addr.i, align 8
  %10 = load i32, i32* %size.addr.i, align 4
  %call.i = call i64 @_copy_to_user(i8* %8, i8* %9, i32 %10) #5
  %conv.i = trunc i64 %call.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, i32* %retval, align 4
  ret i32 %11
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_setintf(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %setintf = alloca %struct.usbdevfs_setinterface, align 4
  %ret = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_setinterface* %setintf to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  %call = call i64 @copy_from_user(i8* %0, i8* %1, i64 8)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %interface = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 0
  %3 = load i32, i32* %interface, align 4
  %call1 = call i32 @checkintf(%struct.dev_state* %2, i32 %3)
  store i32 %call1, i32* %ret, align 4
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %4 = load i32, i32* %ret, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %5 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %interface5 = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 0
  %7 = load i32, i32* %interface5, align 4
  %altsetting = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 1
  %8 = load i32, i32* %altsetting, align 4
  %call6 = call i32 @usb_set_interface(%struct.usb_device* %6, i32 %7, i32 %8)
  store i32 %call6, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_setconfig(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %u = alloca i32, align 4
  %status = alloca i32, align 4
  %actconfig = alloca %struct.usb_host_config*, align 8
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %tmp = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  store i32 0, i32* %status, align 4
  call void @might_fault()
  %0 = load i8*, i8** %arg.addr, align 8
  %1 = bitcast i8* %0 to i32*
  %2 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %1, i64 4) #5, !srcloc !10
  %asmresult = extractvalue { i32*, i64 } %2, 0
  %asmresult1 = extractvalue { i32*, i64 } %2, 1
  %3 = ptrtoint i32* %asmresult to i64
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  %5 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, i32* %u, align 4
  %6 = load i32, i32* %__ret_gu, align 4
  store i32 %6, i32* %tmp, align 4
  %7 = load i32, i32* %tmp, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %8, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %actconfig2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %9, i32 0, i32 15
  %10 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig2, align 8
  store %struct.usb_host_config* %10, %struct.usb_host_config** %actconfig, align 8
  %11 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %tobool3 = icmp ne %struct.usb_host_config* %11, null
  br i1 %tobool3, label %if.then4, label %if.end23

if.then4:                                         ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then4
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %13, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %14 = load i8, i8* %bNumInterfaces, align 4
  %conv5 = zext i8 %14 to i32
  %cmp = icmp slt i32 %12, %conv5
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.body:                                         ; preds = %for.cond
  %15 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %15, i32 0, i32 3
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %17 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8
  %call = call i32 @usb_interface_claimed(%struct.usb_interface* %17)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.then8, label %if.end22

if.then8:                                         ; preds = %for.body
  %18 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %18, i32 0, i32 1
  %19 = load %struct.usb_device*, %struct.usb_device** %dev9, align 8
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %19, i32 0, i32 11
  %20 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %interface11 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %20, i32 0, i32 3
  %21 = load i32, i32* %i, align 4
  %idxprom12 = sext i32 %21 to i64
  %arrayidx13 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface11, i64 0, i64 %idxprom12
  %22 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx13, align 8
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %22, i32 0, i32 1
  %23 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8
  %desc14 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %23, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc14, i32 0, i32 2
  %24 = load i8, i8* %bInterfaceNumber, align 2
  %conv15 = zext i8 %24 to i32
  %25 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %interface16 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %25, i32 0, i32 3
  %26 = load i32, i32* %i, align 4
  %idxprom17 = sext i32 %26 to i64
  %arrayidx18 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface16, i64 0, i64 %idxprom17
  %27 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx18, align 8
  %dev19 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %27, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev19, i32 0, i32 7
  %28 = load %struct.device_driver*, %struct.device_driver** %driver, align 8
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %28, i32 0, i32 0
  %29 = load i8*, i8** %name, align 8
  %30 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %30, %struct.task_struct** %pfo_ret__.i, align 8
  %31 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %31, %struct.task_struct** %tmp.i, align 8
  %32 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %32, i32 0, i32 64
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %33 = load i32, i32* %u, align 4
  %call21 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev10, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.47, i32 0, i32 0), i32 %conv15, i8* %29, i8* %arraydecay, i32 %33)
  store i32 -16, i32* %status, align 4
  br label %for.end

if.end22:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end22
  %34 = load i32, i32* %i, align 4
  %inc = add nsw i32 %34, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end.loopexit:                                 ; preds = %for.cond
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %if.then8
  br label %if.end23

if.end23:                                         ; preds = %for.end, %if.end
  %35 = load i32, i32* %status, align 4
  %cmp24 = icmp eq i32 %35, 0
  br i1 %cmp24, label %if.then26, label %if.end38

if.then26:                                        ; preds = %if.end23
  %36 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %tobool27 = icmp ne %struct.usb_host_config* %36, null
  br i1 %tobool27, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then26
  %37 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %desc28 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %37, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc28, i32 0, i32 4
  %38 = load i8, i8* %bConfigurationValue, align 1
  %conv29 = zext i8 %38 to i32
  %39 = load i32, i32* %u, align 4
  %cmp30 = icmp eq i32 %conv29, %39
  br i1 %cmp30, label %if.then32, label %if.else

if.then32:                                        ; preds = %land.lhs.true
  %40 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev33 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %40, i32 0, i32 1
  %41 = load %struct.usb_device*, %struct.usb_device** %dev33, align 8
  %call34 = call i32 @usb_reset_configuration(%struct.usb_device* %41)
  store i32 %call34, i32* %status, align 4
  br label %if.end37

if.else:                                          ; preds = %land.lhs.true, %if.then26
  %42 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev35 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %42, i32 0, i32 1
  %43 = load %struct.usb_device*, %struct.usb_device** %dev35, align 8
  %44 = load i32, i32* %u, align 4
  %call36 = call i32 @usb_set_configuration(%struct.usb_device* %43, i32 %44)
  store i32 %call36, i32* %status, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.else, %if.then32
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.end23
  %45 = load i32, i32* %status, align 4
  store i32 %45, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end38, %if.then
  %46 = load i32, i32* %retval, align 4
  ret i32 %46
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_submiturb(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %uurb = alloca %struct.usbdevfs_urb, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  %call = call i64 @copy_from_user(i8* %0, i8* %1, i64 56)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %3 = load i8*, i8** %arg.addr, align 8
  %4 = bitcast i8* %3 to %struct.usbdevfs_urb*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %4, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc, i32 0, i32 0
  %5 = load i8*, i8** %arg.addr, align 8
  %call1 = call i32 @proc_do_submiturb(%struct.dev_state* %2, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %arraydecay, i8* %5)
  store i32 %call1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_control_compat(%struct.dev_state* %ps, %struct.usbdevfs_ctrltransfer32* %p32) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %p32.addr = alloca %struct.usbdevfs_ctrltransfer32*, align 8
  %p = alloca %struct.usbdevfs_ctrltransfer*, align 8
  %udata = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i8*, align 8
  %tmp7 = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store %struct.usbdevfs_ctrltransfer32* %p32, %struct.usbdevfs_ctrltransfer32** %p32.addr, align 8
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_ctrltransfer*
  store %struct.usbdevfs_ctrltransfer* %0, %struct.usbdevfs_ctrltransfer** %p, align 8
  %1 = load %struct.usbdevfs_ctrltransfer*, %struct.usbdevfs_ctrltransfer** %p, align 8
  %2 = bitcast %struct.usbdevfs_ctrltransfer* %1 to i8*
  %3 = load %struct.usbdevfs_ctrltransfer32*, %struct.usbdevfs_ctrltransfer32** %p32.addr, align 8
  %4 = bitcast %struct.usbdevfs_ctrltransfer32* %3 to i8*
  %call1 = call i64 @copy_in_user(i8* %2, i8* %4, i32 12)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %5 = load %struct.usbdevfs_ctrltransfer32*, %struct.usbdevfs_ctrltransfer32** %p32.addr, align 8
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer32, %struct.usbdevfs_ctrltransfer32* %5, i32 0, i32 6
  %6 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4) #5, !srcloc !11
  %asmresult = extractvalue { i32*, i64 } %6, 0
  %asmresult2 = extractvalue { i32*, i64 } %6, 1
  %7 = ptrtoint i32* %asmresult to i64
  %8 = trunc i64 %7 to i32
  store i32 %8, i32* %__ret_gu, align 4
  store i64 %asmresult2, i64* %__val_gu, align 8
  %9 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %9 to i32
  store i32 %conv, i32* %udata, align 4
  %10 = load i32, i32* %__ret_gu, align 4
  store i32 %10, i32* %tmp, align 4
  %11 = load i32, i32* %tmp, align 4
  %tobool3 = icmp ne i32 %11, 0
  br i1 %tobool3, label %if.then, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  call void @might_fault()
  %12 = load i32, i32* %udata, align 4
  %call5 = call i8* @compat_ptr(i32 %12)
  store i8* %call5, i8** %__pu_val, align 8
  %13 = load i8*, i8** %__pu_val, align 8
  %14 = load %struct.usbdevfs_ctrltransfer*, %struct.usbdevfs_ctrltransfer** %p, align 8
  %data6 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %14, i32 0, i32 6
  %15 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %13, i8** %data6) #5, !srcloc !12
  %16 = ptrtoint i8* %15 to i64
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %__ret_pu, align 4
  %18 = load i32, i32* %__ret_pu, align 4
  store i32 %18, i32* %tmp7, align 4
  %19 = load i32, i32* %tmp7, align 4
  %tobool8 = icmp ne i32 %19, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false4, %lor.lhs.false, %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false4
  %20 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %21 = load %struct.usbdevfs_ctrltransfer*, %struct.usbdevfs_ctrltransfer** %p, align 8
  %22 = bitcast %struct.usbdevfs_ctrltransfer* %21 to i8*
  %call9 = call i32 @proc_control(%struct.dev_state* %20, i8* %22)
  store i32 %call9, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_bulk_compat(%struct.dev_state* %ps, %struct.usbdevfs_bulktransfer32* %p32) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %p32.addr = alloca %struct.usbdevfs_bulktransfer32*, align 8
  %p = alloca %struct.usbdevfs_bulktransfer*, align 8
  %n = alloca i32, align 4
  %addr = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i32, align 4
  %tmp3 = alloca i32, align 4
  %__ret_gu6 = alloca i32, align 4
  %__val_gu7 = alloca i64, align 8
  %tmp11 = alloca i32, align 4
  %__ret_pu14 = alloca i32, align 4
  %__pu_val15 = alloca i32, align 4
  %tmp17 = alloca i32, align 4
  %__ret_gu20 = alloca i32, align 4
  %__val_gu21 = alloca i64, align 8
  %tmp25 = alloca i32, align 4
  %__ret_pu28 = alloca i32, align 4
  %__pu_val29 = alloca i32, align 4
  %tmp31 = alloca i32, align 4
  %__ret_gu34 = alloca i32, align 4
  %__val_gu35 = alloca i64, align 8
  %tmp39 = alloca i32, align 4
  %__ret_pu42 = alloca i32, align 4
  %__pu_val43 = alloca i8*, align 8
  %tmp46 = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store %struct.usbdevfs_bulktransfer32* %p32, %struct.usbdevfs_bulktransfer32** %p32.addr, align 8
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_bulktransfer*
  store %struct.usbdevfs_bulktransfer* %0, %struct.usbdevfs_bulktransfer** %p, align 8
  call void @might_fault()
  %1 = load %struct.usbdevfs_bulktransfer32*, %struct.usbdevfs_bulktransfer32** %p32.addr, align 8
  %ep = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %1, i32 0, i32 0
  %2 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %ep, i64 4) #5, !srcloc !13
  %asmresult = extractvalue { i32*, i64 } %2, 0
  %asmresult1 = extractvalue { i32*, i64 } %2, 1
  %3 = ptrtoint i32* %asmresult to i64
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  %5 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, i32* %n, align 4
  %6 = load i32, i32* %__ret_gu, align 4
  store i32 %6, i32* %tmp, align 4
  %7 = load i32, i32* %tmp, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %8 = load i32, i32* %n, align 4
  store i32 %8, i32* %__pu_val, align 4
  %9 = load i32, i32* %__pu_val, align 4
  %10 = load %struct.usbdevfs_bulktransfer*, %struct.usbdevfs_bulktransfer** %p, align 8
  %ep2 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %10, i32 0, i32 0
  %11 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %9, i32* %ep2) #5, !srcloc !14
  store i32 %11, i32* %__ret_pu, align 4
  %12 = load i32, i32* %__ret_pu, align 4
  store i32 %12, i32* %tmp3, align 4
  %13 = load i32, i32* %tmp3, align 4
  %tobool4 = icmp ne i32 %13, 0
  br i1 %tobool4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  call void @might_fault()
  %14 = load %struct.usbdevfs_bulktransfer32*, %struct.usbdevfs_bulktransfer32** %p32.addr, align 8
  %len = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %14, i32 0, i32 1
  %15 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %len, i64 4) #5, !srcloc !15
  %asmresult8 = extractvalue { i32*, i64 } %15, 0
  %asmresult9 = extractvalue { i32*, i64 } %15, 1
  %16 = ptrtoint i32* %asmresult8 to i64
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %__ret_gu6, align 4
  store i64 %asmresult9, i64* %__val_gu7, align 8
  %18 = load i64, i64* %__val_gu7, align 8
  %conv10 = trunc i64 %18 to i32
  store i32 %conv10, i32* %n, align 4
  %19 = load i32, i32* %__ret_gu6, align 4
  store i32 %19, i32* %tmp11, align 4
  %20 = load i32, i32* %tmp11, align 4
  %tobool12 = icmp ne i32 %20, 0
  br i1 %tobool12, label %if.then, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false5
  call void @might_fault()
  %21 = load i32, i32* %n, align 4
  store i32 %21, i32* %__pu_val15, align 4
  %22 = load i32, i32* %__pu_val15, align 4
  %23 = load %struct.usbdevfs_bulktransfer*, %struct.usbdevfs_bulktransfer** %p, align 8
  %len16 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %23, i32 0, i32 1
  %24 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %22, i32* %len16) #5, !srcloc !16
  store i32 %24, i32* %__ret_pu14, align 4
  %25 = load i32, i32* %__ret_pu14, align 4
  store i32 %25, i32* %tmp17, align 4
  %26 = load i32, i32* %tmp17, align 4
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then, label %lor.lhs.false19

lor.lhs.false19:                                  ; preds = %lor.lhs.false13
  call void @might_fault()
  %27 = load %struct.usbdevfs_bulktransfer32*, %struct.usbdevfs_bulktransfer32** %p32.addr, align 8
  %timeout = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %27, i32 0, i32 2
  %28 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %timeout, i64 4) #5, !srcloc !17
  %asmresult22 = extractvalue { i32*, i64 } %28, 0
  %asmresult23 = extractvalue { i32*, i64 } %28, 1
  %29 = ptrtoint i32* %asmresult22 to i64
  %30 = trunc i64 %29 to i32
  store i32 %30, i32* %__ret_gu20, align 4
  store i64 %asmresult23, i64* %__val_gu21, align 8
  %31 = load i64, i64* %__val_gu21, align 8
  %conv24 = trunc i64 %31 to i32
  store i32 %conv24, i32* %n, align 4
  %32 = load i32, i32* %__ret_gu20, align 4
  store i32 %32, i32* %tmp25, align 4
  %33 = load i32, i32* %tmp25, align 4
  %tobool26 = icmp ne i32 %33, 0
  br i1 %tobool26, label %if.then, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %lor.lhs.false19
  call void @might_fault()
  %34 = load i32, i32* %n, align 4
  store i32 %34, i32* %__pu_val29, align 4
  %35 = load i32, i32* %__pu_val29, align 4
  %36 = load %struct.usbdevfs_bulktransfer*, %struct.usbdevfs_bulktransfer** %p, align 8
  %timeout30 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %36, i32 0, i32 2
  %37 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %35, i32* %timeout30) #5, !srcloc !18
  store i32 %37, i32* %__ret_pu28, align 4
  %38 = load i32, i32* %__ret_pu28, align 4
  store i32 %38, i32* %tmp31, align 4
  %39 = load i32, i32* %tmp31, align 4
  %tobool32 = icmp ne i32 %39, 0
  br i1 %tobool32, label %if.then, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %lor.lhs.false27
  call void @might_fault()
  %40 = load %struct.usbdevfs_bulktransfer32*, %struct.usbdevfs_bulktransfer32** %p32.addr, align 8
  %data = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %40, i32 0, i32 3
  %41 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4) #5, !srcloc !19
  %asmresult36 = extractvalue { i32*, i64 } %41, 0
  %asmresult37 = extractvalue { i32*, i64 } %41, 1
  %42 = ptrtoint i32* %asmresult36 to i64
  %43 = trunc i64 %42 to i32
  store i32 %43, i32* %__ret_gu34, align 4
  store i64 %asmresult37, i64* %__val_gu35, align 8
  %44 = load i64, i64* %__val_gu35, align 8
  %conv38 = trunc i64 %44 to i32
  store i32 %conv38, i32* %addr, align 4
  %45 = load i32, i32* %__ret_gu34, align 4
  store i32 %45, i32* %tmp39, align 4
  %46 = load i32, i32* %tmp39, align 4
  %tobool40 = icmp ne i32 %46, 0
  br i1 %tobool40, label %if.then, label %lor.lhs.false41

lor.lhs.false41:                                  ; preds = %lor.lhs.false33
  call void @might_fault()
  %47 = load i32, i32* %addr, align 4
  %call44 = call i8* @compat_ptr(i32 %47)
  store i8* %call44, i8** %__pu_val43, align 8
  %48 = load i8*, i8** %__pu_val43, align 8
  %49 = load %struct.usbdevfs_bulktransfer*, %struct.usbdevfs_bulktransfer** %p, align 8
  %data45 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %49, i32 0, i32 3
  %50 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %48, i8** %data45) #5, !srcloc !20
  %51 = ptrtoint i8* %50 to i64
  %52 = trunc i64 %51 to i32
  store i32 %52, i32* %__ret_pu42, align 4
  %53 = load i32, i32* %__ret_pu42, align 4
  store i32 %53, i32* %tmp46, align 4
  %54 = load i32, i32* %tmp46, align 4
  %tobool47 = icmp ne i32 %54, 0
  br i1 %tobool47, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false41, %lor.lhs.false33, %lor.lhs.false27, %lor.lhs.false19, %lor.lhs.false13, %lor.lhs.false5, %lor.lhs.false, %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false41
  %55 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %56 = load %struct.usbdevfs_bulktransfer*, %struct.usbdevfs_bulktransfer** %p, align 8
  %57 = bitcast %struct.usbdevfs_bulktransfer* %56 to i8*
  %call48 = call i32 @proc_bulk(%struct.dev_state* %55, i8* %57)
  store i32 %call48, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %58 = load i32, i32* %retval, align 4
  ret i32 %58
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_disconnectsignal_compat(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ds = alloca %struct.usbdevfs_disconnectsignal32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_disconnectsignal32* %ds to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  %call = call i64 @copy_from_user(i8* %0, i8* %1, i64 8)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %signr = getelementptr inbounds %struct.usbdevfs_disconnectsignal32, %struct.usbdevfs_disconnectsignal32* %ds, i32 0, i32 0
  %2 = load i32, i32* %signr, align 4
  %3 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 7
  store i32 %2, i32* %discsignr, align 8
  %context = getelementptr inbounds %struct.usbdevfs_disconnectsignal32, %struct.usbdevfs_disconnectsignal32* %ds, i32 0, i32 1
  %4 = load i32, i32* %context, align 4
  %call1 = call i8* @compat_ptr(i32 %4)
  %5 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 10
  store i8* %call1, i8** %disccontext, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_submiturb_compat(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %uurb = alloca %struct.usbdevfs_urb, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load i8*, i8** %arg.addr, align 8
  %1 = bitcast i8* %0 to %struct.usbdevfs_urb32*
  %call = call i32 @get_urb32(%struct.usbdevfs_urb* %uurb, %struct.usbdevfs_urb32* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %3 = load i8*, i8** %arg.addr, align 8
  %4 = bitcast i8* %3 to %struct.usbdevfs_urb32*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %4, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc, i32 0, i32 0
  %5 = load i8*, i8** %arg.addr, align 8
  %call1 = call i32 @proc_do_submiturb(%struct.dev_state* %2, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %arraydecay, i8* %5)
  store i32 %call1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_reapurb_compat(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %as = alloca %struct.async*, align 8
  %retval1 = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %call = call %struct.async* @reap_as(%struct.dev_state* %0)
  store %struct.async* %call, %struct.async** %as, align 8
  %1 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.async*, %struct.async** %as, align 8
  %3 = load i8*, i8** %arg.addr, align 8
  %4 = bitcast i8* %3 to i8**
  %call2 = call i32 @processcompl_compat(%struct.async* %2, i8** %4)
  store i32 %call2, i32* %retval1, align 4
  %5 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %5)
  %6 = load i32, i32* %retval1, align 4
  store i32 %6, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %7, %struct.task_struct** %pfo_ret__.i, align 8
  %8 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %8, %struct.task_struct** %tmp.i, align 8
  %9 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call4 = call i32 @signal_pending(%struct.task_struct* %9)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i32 -4, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  store i32 -5, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_reapurbnonblock_compat(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %retval1 = alloca i32, align 4
  %as = alloca %struct.async*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  store i32 -11, i32* %retval1, align 4
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %call = call %struct.async* @async_getcompleted(%struct.dev_state* %0)
  store %struct.async* %call, %struct.async** %as, align 8
  %1 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.async*, %struct.async** %as, align 8
  %3 = load i8*, i8** %arg.addr, align 8
  %4 = bitcast i8* %3 to i8**
  %call2 = call i32 @processcompl_compat(%struct.async* %2, i8** %4)
  store i32 %call2, i32* %retval1, align 4
  %5 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %retval1, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_ioctl_compat(%struct.dev_state* %ps, i32 %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i32, align 4
  %uioc = alloca %struct.usbdevfs_ioctl32*, align 8
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  %udata = alloca i32, align 4
  %flag = alloca i64, align 8
  %roksum = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__gu_err = alloca i32, align 4
  %__gu_val = alloca i64, align 8
  %tmp11 = alloca i32, align 4
  %__gu_err14 = alloca i32, align 4
  %__gu_val15 = alloca i64, align 8
  %tmp22 = alloca i32, align 4
  %__gu_err25 = alloca i32, align 4
  %__gu_val26 = alloca i64, align 8
  %tmp32 = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i32 %arg, i32* %arg.addr, align 4
  %0 = load i32, i32* %arg.addr, align 4
  %conv = zext i32 %0 to i64
  %conv1 = trunc i64 %conv to i32
  %call = call i8* @compat_ptr(i32 %conv1)
  %1 = bitcast i8* %call to %struct.usbdevfs_ioctl32*
  store %struct.usbdevfs_ioctl32* %1, %struct.usbdevfs_ioctl32** %uioc, align 8
  %2 = load %struct.usbdevfs_ioctl32*, %struct.usbdevfs_ioctl32** %uioc, align 8
  %call2 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call2, i32 0, i32 6
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %3 = load i64, i64* %seg, align 8
  %4 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(%struct.usbdevfs_ioctl32* %2, i64 12, i64 %3) #7, !srcloc !21
  %asmresult = extractvalue { i64, i64 } %4, 0
  %asmresult3 = extractvalue { i64, i64 } %4, 1
  store i64 %asmresult, i64* %flag, align 8
  store i64 %asmresult3, i64* %roksum, align 8
  %5 = load i64, i64* %flag, align 8
  store i64 %5, i64* %tmp, align 8
  %6 = load i64, i64* %tmp, align 8
  %cmp = icmp eq i64 %6, 0
  %lnot = xor i1 %cmp, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv6, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %__gu_err, align 4
  %7 = load %struct.usbdevfs_ioctl32*, %struct.usbdevfs_ioctl32** %uioc, align 8
  %ifno = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %7, i32 0, i32 0
  %8 = bitcast i32* %ifno to %struct.__large_struct*
  %9 = load i32, i32* %__gu_err, align 4
  %10 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %8, i32 -14, i32 %9) #5, !srcloc !22
  %asmresult7 = extractvalue { i32, i64 } %10, 0
  %asmresult8 = extractvalue { i32, i64 } %10, 1
  store i32 %asmresult7, i32* %__gu_err, align 4
  store i64 %asmresult8, i64* %__gu_val, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %11 = load i64, i64* %__gu_val, align 8
  %conv9 = trunc i64 %11 to i32
  %ifno10 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 0
  store i32 %conv9, i32* %ifno10, align 8
  %12 = load i32, i32* %__gu_err, align 4
  store i32 %12, i32* %tmp11, align 4
  %13 = load i32, i32* %tmp11, align 4
  %tobool12 = icmp ne i32 %13, 0
  br i1 %tobool12, label %if.then, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %do.end
  br label %do.body16

do.body16:                                        ; preds = %lor.lhs.false13
  store i32 0, i32* %__gu_err14, align 4
  %14 = load %struct.usbdevfs_ioctl32*, %struct.usbdevfs_ioctl32** %uioc, align 8
  %ioctl_code = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %14, i32 0, i32 1
  %15 = bitcast i32* %ioctl_code to %struct.__large_struct*
  %16 = load i32, i32* %__gu_err14, align 4
  %17 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %15, i32 -14, i32 %16) #5, !srcloc !23
  %asmresult17 = extractvalue { i32, i64 } %17, 0
  %asmresult18 = extractvalue { i32, i64 } %17, 1
  store i32 %asmresult17, i32* %__gu_err14, align 4
  store i64 %asmresult18, i64* %__gu_val15, align 8
  br label %do.end19

do.end19:                                         ; preds = %do.body16
  %18 = load i64, i64* %__gu_val15, align 8
  %conv20 = trunc i64 %18 to i32
  %ioctl_code21 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 1
  store i32 %conv20, i32* %ioctl_code21, align 4
  %19 = load i32, i32* %__gu_err14, align 4
  store i32 %19, i32* %tmp22, align 4
  %20 = load i32, i32* %tmp22, align 4
  %tobool23 = icmp ne i32 %20, 0
  br i1 %tobool23, label %if.then, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %do.end19
  br label %do.body27

do.body27:                                        ; preds = %lor.lhs.false24
  store i32 0, i32* %__gu_err25, align 4
  %21 = load %struct.usbdevfs_ioctl32*, %struct.usbdevfs_ioctl32** %uioc, align 8
  %data = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %21, i32 0, i32 2
  %22 = bitcast i32* %data to %struct.__large_struct*
  %23 = load i32, i32* %__gu_err25, align 4
  %24 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %22, i32 -14, i32 %23) #5, !srcloc !24
  %asmresult28 = extractvalue { i32, i64 } %24, 0
  %asmresult29 = extractvalue { i32, i64 } %24, 1
  store i32 %asmresult28, i32* %__gu_err25, align 4
  store i64 %asmresult29, i64* %__gu_val26, align 8
  br label %do.end30

do.end30:                                         ; preds = %do.body27
  %25 = load i64, i64* %__gu_val26, align 8
  %conv31 = trunc i64 %25 to i32
  store i32 %conv31, i32* %udata, align 4
  %26 = load i32, i32* %__gu_err25, align 4
  store i32 %26, i32* %tmp32, align 4
  %27 = load i32, i32* %tmp32, align 4
  %tobool33 = icmp ne i32 %27, 0
  br i1 %tobool33, label %if.then, label %if.end

if.then:                                          ; preds = %do.end30, %do.end19, %do.end, %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end30
  %28 = load i32, i32* %udata, align 4
  %call34 = call i8* @compat_ptr(i32 %28)
  %data35 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 2
  store i8* %call34, i8** %data35, align 8
  %29 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %call36 = call i32 @proc_ioctl(%struct.dev_state* %29, %struct.usbdevfs_ioctl* %ctrl)
  store i32 %call36, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %30 = load i32, i32* %retval, align 4
  ret i32 %30
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @ptr_to_compat(i8* %uptr) #0 {
entry:
  %uptr.addr = alloca i8*, align 8
  store i8* %uptr, i8** %uptr.addr, align 8
  %0 = load i8*, i8** %uptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %conv = trunc i64 %1 to i32
  ret i32 %conv
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_unlinkurb(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %urb = alloca %struct.urb*, align 8
  %as = alloca %struct.async*, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %0 = load i32, i32* %tmp, align 4
  %1 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  store i64 %call2, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.end
  %2 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %3 = load i8*, i8** %arg.addr, align 8
  %call4 = call %struct.async* @async_getpending(%struct.dev_state* %2, i8* %3)
  store %struct.async* %call4, %struct.async** %as, align 8
  %4 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end3
  %5 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 3
  %6 = load i64, i64* %flags, align 8
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock5, i64 %6)
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end3
  %7 = load %struct.async*, %struct.async** %as, align 8
  %urb6 = getelementptr inbounds %struct.async, %struct.async* %7, i32 0, i32 8
  %8 = load %struct.urb*, %struct.urb** %urb6, align 8
  store %struct.urb* %8, %struct.urb** %urb, align 8
  %9 = load %struct.urb*, %struct.urb** %urb, align 8
  %call7 = call %struct.urb* @usb_get_urb(%struct.urb* %9)
  %10 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %10, i32 0, i32 3
  %11 = load i64, i64* %flags, align 8
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock8, i64 %11)
  %12 = load %struct.urb*, %struct.urb** %urb, align 8
  call void @usb_kill_urb(%struct.urb* %12)
  %13 = load %struct.urb*, %struct.urb** %urb, align 8
  call void @usb_free_urb(%struct.urb* %13)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_reapurb(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %as = alloca %struct.async*, align 8
  %retval1 = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %call = call %struct.async* @reap_as(%struct.dev_state* %0)
  store %struct.async* %call, %struct.async** %as, align 8
  %1 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.async*, %struct.async** %as, align 8
  %3 = load i8*, i8** %arg.addr, align 8
  %4 = bitcast i8* %3 to i8**
  %call2 = call i32 @processcompl(%struct.async* %2, i8** %4)
  store i32 %call2, i32* %retval1, align 4
  %5 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %5)
  %6 = load i32, i32* %retval1, align 4
  store i32 %6, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %7, %struct.task_struct** %pfo_ret__.i, align 8
  %8 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %8, %struct.task_struct** %tmp.i, align 8
  %9 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call4 = call i32 @signal_pending(%struct.task_struct* %9)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i32 -4, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  store i32 -5, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_reapurbnonblock(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %retval1 = alloca i32, align 4
  %as = alloca %struct.async*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %call = call %struct.async* @async_getcompleted(%struct.dev_state* %0)
  store %struct.async* %call, %struct.async** %as, align 8
  store i32 -11, i32* %retval1, align 4
  %1 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.async*, %struct.async** %as, align 8
  %3 = load i8*, i8** %arg.addr, align 8
  %4 = bitcast i8* %3 to i8**
  %call2 = call i32 @processcompl(%struct.async* %2, i8** %4)
  store i32 %call2, i32* %retval1, align 4
  %5 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, i32* %retval1, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_disconnectsignal(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ds = alloca %struct.usbdevfs_disconnectsignal, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  %call = call i64 @copy_from_user(i8* %0, i8* %1, i64 16)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %signr = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 0
  %2 = load i32, i32* %signr, align 8
  %3 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 7
  store i32 %2, i32* %discsignr, align 8
  %context = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 1
  %4 = load i8*, i8** %context, align 8
  %5 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 10
  store i8* %4, i8** %disccontext, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_claiminterface(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ifnum = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %arg.addr, align 8
  %1 = bitcast i8* %0 to i32*
  %2 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %1, i64 4) #5, !srcloc !25
  %asmresult = extractvalue { i32*, i64 } %2, 0
  %asmresult1 = extractvalue { i32*, i64 } %2, 1
  %3 = ptrtoint i32* %asmresult to i64
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  %5 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, i32* %ifnum, align 4
  %6 = load i32, i32* %__ret_gu, align 4
  store i32 %6, i32* %tmp, align 4
  %7 = load i32, i32* %tmp, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %9 = load i32, i32* %ifnum, align 4
  %call = call i32 @claimintf(%struct.dev_state* %8, i32 %9)
  store i32 %call, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_releaseinterface(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ifnum = alloca i32, align 4
  %ret = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %arg.addr, align 8
  %1 = bitcast i8* %0 to i32*
  %2 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %1, i64 4) #5, !srcloc !26
  %asmresult = extractvalue { i32*, i64 } %2, 0
  %asmresult1 = extractvalue { i32*, i64 } %2, 1
  %3 = ptrtoint i32* %asmresult to i64
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  %5 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, i32* %ifnum, align 4
  %6 = load i32, i32* %__ret_gu, align 4
  store i32 %6, i32* %tmp, align 4
  %7 = load i32, i32* %tmp, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %9 = load i32, i32* %ifnum, align 4
  %call = call i32 @releaseintf(%struct.dev_state* %8, i32 %9)
  store i32 %call, i32* %ret, align 4
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %10 = load i32, i32* %ret, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %11 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %12 = load i32, i32* %ifnum, align 4
  call void @destroy_async_on_interface(%struct.dev_state* %11, i32 %12)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %13 = load i32, i32* %retval, align 4
  ret i32 %13
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_ioctl_default(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  %call = call i64 @copy_from_user(i8* %0, i8* %1, i64 16)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %call1 = call i32 @proc_ioctl(%struct.dev_state* %2, %struct.usbdevfs_ioctl* %ctrl)
  store i32 %call1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i32, i32* %retval, align 4
  ret i32 %3
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_claim_port(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %pfo_ret__.i14 = alloca %struct.task_struct*, align 8
  %tmp.i15 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %portnum = alloca i32, align 4
  %rc = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %arg.addr, align 8
  %1 = bitcast i8* %0 to i32*
  %2 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %1, i64 4) #5, !srcloc !27
  %asmresult = extractvalue { i32*, i64 } %2, 0
  %asmresult1 = extractvalue { i32*, i64 } %2, 1
  %3 = ptrtoint i32* %asmresult to i64
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  %5 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, i32* %portnum, align 4
  %6 = load i32, i32* %__ret_gu, align 4
  store i32 %6, i32* %tmp, align 4
  %7 = load i32, i32* %tmp, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %8, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %10 = load i32, i32* %portnum, align 4
  %11 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %call = call i32 @usb_hub_claim_port(%struct.usb_device* %9, i32 %10, %struct.dev_state* %11)
  store i32 %call, i32* %rc, align 4
  %12 = load i32, i32* %rc, align 4
  %cmp = icmp eq i32 %12, 0
  br i1 %cmp, label %if.then3, label %if.end13

if.then3:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then3
  %13 = load i8, i8* @usbfs_snoop, align 1
  %tobool4 = trunc i8 %13 to i1
  br i1 %tobool4, label %if.then5, label %if.end12

if.then5:                                         ; preds = %do.body
  %14 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 1
  %15 = load %struct.usb_device*, %struct.usb_device** %dev6, align 8
  %dev7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  %16 = load i32, i32* %portnum, align 4
  %17 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %17, %struct.task_struct** %pfo_ret__.i, align 8
  %18 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %18, %struct.task_struct** %tmp.i, align 8
  %19 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call9 = call i32 @task_pid_nr(%struct.task_struct* %19)
  %20 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %20, %struct.task_struct** %pfo_ret__.i14, align 8
  %21 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i14, align 8
  store %struct.task_struct* %21, %struct.task_struct** %tmp.i15, align 8
  %22 = load %struct.task_struct*, %struct.task_struct** %tmp.i15, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %22, i32 0, i32 64
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %call11 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev7, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.52, i32 0, i32 0), i32 %16, i32 %call9, i8* %arraydecay)
  br label %if.end12

if.end12:                                         ; preds = %if.then5, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end12
  br label %if.end13

if.end13:                                         ; preds = %do.end, %if.end
  %23 = load i32, i32* %rc, align 4
  store i32 %23, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then
  %24 = load i32, i32* %retval, align 4
  ret i32 %24
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_release_port(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %portnum = alloca i32, align 4
  %__ret_gu = alloca i32, align 4
  %__val_gu = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  call void @might_fault()
  %0 = load i8*, i8** %arg.addr, align 8
  %1 = bitcast i8* %0 to i32*
  %2 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %1, i64 4) #5, !srcloc !28
  %asmresult = extractvalue { i32*, i64 } %2, 0
  %asmresult1 = extractvalue { i32*, i64 } %2, 1
  %3 = ptrtoint i32* %asmresult to i64
  %4 = trunc i64 %3 to i32
  store i32 %4, i32* %__ret_gu, align 4
  store i64 %asmresult1, i64* %__val_gu, align 8
  %5 = load i64, i64* %__val_gu, align 8
  %conv = trunc i64 %5 to i32
  store i32 %conv, i32* %portnum, align 4
  %6 = load i32, i32* %__ret_gu, align 4
  store i32 %6, i32* %tmp, align 4
  %7 = load i32, i32* %tmp, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %8, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %10 = load i32, i32* %portnum, align 4
  %11 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %call = call i32 @usb_hub_release_port(%struct.usb_device* %9, i32 %10, %struct.dev_state* %11)
  store i32 %call, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_get_capabilities(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %caps = alloca i32, align 4
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  store i32 5, i32* %caps, align 4
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 9
  %2 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8
  %no_stop_on_short = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %2, i32 0, i32 6
  %bf.load = load i8, i8* %no_stop_on_short, align 1
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %caps, align 4
  %or = or i32 %3, 2
  store i32 %or, i32* %caps, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %4, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  %bus2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %5, i32 0, i32 9
  %6 = load %struct.usb_bus*, %struct.usb_bus** %bus2, align 8
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %6, i32 0, i32 7
  %7 = load i32, i32* %sg_tablesize, align 4
  %tobool3 = icmp ne i32 %7, 0
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %8 = load i32, i32* %caps, align 4
  %or5 = or i32 %8, 8
  store i32 %or5, i32* %caps, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  call void @might_fault()
  %9 = load i32, i32* %caps, align 4
  store i32 %9, i32* %__pu_val, align 4
  %10 = load i32, i32* %__pu_val, align 4
  %11 = load i8*, i8** %arg.addr, align 8
  %12 = bitcast i8* %11 to i32*
  %13 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %10, i32* %12) #5, !srcloc !29
  store i32 %13, i32* %__ret_pu, align 4
  %14 = load i32, i32* %__ret_pu, align 4
  store i32 %14, i32* %tmp, align 4
  %15 = load i32, i32* %tmp, align 4
  %tobool7 = icmp ne i32 %15, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  store i32 -14, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end6
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then8
  %16 = load i32, i32* %retval, align 4
  ret i32 %16
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_disconnect_claim(%struct.dev_state* %ps, i8* %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %arg.addr = alloca i8*, align 8
  %dc = alloca %struct.usbdevfs_disconnect_claim, align 4
  %intf = alloca %struct.usb_interface*, align 8
  %driver8 = alloca %struct.usb_driver*, align 8
  %__mptr = alloca %struct.device_driver*, align 8
  %tmp = alloca %struct.usb_driver*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  %1 = load i8*, i8** %arg.addr, align 8
  %call = call i64 @copy_from_user(i8* %0, i8* %1, i64 264)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %interface = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %4 = load i32, i32* %interface, align 4
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %3, i32 %4)
  store %struct.usb_interface* %call1, %struct.usb_interface** %intf, align 8
  %5 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %tobool2 = icmp ne %struct.usb_interface* %5, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %6, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev5, i32 0, i32 7
  %7 = load %struct.device_driver*, %struct.device_driver** %driver, align 8
  %tobool6 = icmp ne %struct.device_driver* %7, null
  br i1 %tobool6, label %if.then7, label %if.end33

if.then7:                                         ; preds = %if.end4
  %8 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev9 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %8, i32 0, i32 7
  %driver10 = getelementptr inbounds %struct.device, %struct.device* %dev9, i32 0, i32 7
  %9 = load %struct.device_driver*, %struct.device_driver** %driver10, align 8
  store %struct.device_driver* %9, %struct.device_driver** %__mptr, align 8
  %10 = load %struct.device_driver*, %struct.device_driver** %__mptr, align 8
  %11 = bitcast %struct.device_driver* %10 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 -104
  %12 = bitcast i8* %add.ptr to %struct.usb_driver*
  store %struct.usb_driver* %12, %struct.usb_driver** %tmp, align 8
  %13 = load %struct.usb_driver*, %struct.usb_driver** %tmp, align 8
  store %struct.usb_driver* %13, %struct.usb_driver** %driver8, align 8
  %flags = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %14 = load i32, i32* %flags, align 4
  %and = and i32 %14, 1
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.then7
  %driver12 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver12, i32 0, i32 0
  %15 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev13 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %15, i32 0, i32 7
  %driver14 = getelementptr inbounds %struct.device, %struct.device* %dev13, i32 0, i32 7
  %16 = load %struct.device_driver*, %struct.device_driver** %driver14, align 8
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %16, i32 0, i32 0
  %17 = load i8*, i8** %name, align 8
  %call15 = call i32 @strncmp(i8* %arraydecay, i8* %17, i64 256)
  %cmp = icmp ne i32 %call15, 0
  br i1 %cmp, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true
  store i32 -16, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %land.lhs.true, %if.then7
  %flags18 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %18 = load i32, i32* %flags18, align 4
  %and19 = and i32 %18, 2
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %land.lhs.true21, label %if.end30

land.lhs.true21:                                  ; preds = %if.end17
  %driver22 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay23 = getelementptr inbounds [256 x i8], [256 x i8]* %driver22, i32 0, i32 0
  %19 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev24 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %19, i32 0, i32 7
  %driver25 = getelementptr inbounds %struct.device, %struct.device* %dev24, i32 0, i32 7
  %20 = load %struct.device_driver*, %struct.device_driver** %driver25, align 8
  %name26 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %20, i32 0, i32 0
  %21 = load i8*, i8** %name26, align 8
  %call27 = call i32 @strncmp(i8* %arraydecay23, i8* %21, i64 256)
  %cmp28 = icmp eq i32 %call27, 0
  br i1 %cmp28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %land.lhs.true21
  store i32 -16, i32* %retval, align 4
  br label %return

if.end30:                                         ; preds = %land.lhs.true21, %if.end17
  %22 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev31 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %22, i32 0, i32 7
  %call32 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %dev31, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.51, i32 0, i32 0))
  %23 = load %struct.usb_driver*, %struct.usb_driver** %driver8, align 8
  %24 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  call void @usb_driver_release_interface(%struct.usb_driver* %23, %struct.usb_interface* %24)
  br label %if.end33

if.end33:                                         ; preds = %if.end30, %if.end4
  %25 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %interface34 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %26 = load i32, i32* %interface34, align 4
  %call35 = call i32 @claimintf(%struct.dev_state* %25, i32 %26)
  store i32 %call35, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end33, %if.then29, %if.then16, %if.then3, %if.then
  %27 = load i32, i32* %retval, align 4
  ret i32 %27
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #0 {
entry:
  %to.addr = alloca i8*, align 8
  %from.addr = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %sz = alloca i32, align 4
  store i8* %to, i8** %to.addr, align 8
  store i8* %from, i8** %from.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i8*, i8** %to.addr, align 8
  %1 = call i64 @llvm.objectsize.i64.p0i8(i8* %0, i1 false, i1 true)
  %conv = trunc i64 %1 to i32
  store i32 %conv, i32* %sz, align 4
  call void @might_fault()
  %2 = load i32, i32* %sz, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %3 = load i32, i32* %sz, align 4
  %conv2 = sext i32 %3 to i64
  %4 = load i64, i64* %n.addr, align 8
  %cmp3 = icmp uge i64 %conv2, %4
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %5 = phi i1 [ true, %entry ], [ %cmp3, %lor.rhs ]
  %lnot = xor i1 %5, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %6 = load i8*, i8** %to.addr, align 8
  %7 = load i8*, i8** %from.addr, align 8
  %8 = load i64, i64* %n.addr, align 8
  %conv7 = trunc i64 %8 to i32
  %call = call i64 @_copy_from_user(i8* %6, i8* %7, i32 %conv7)
  store i64 %call, i64* %n.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %9 = load i64, i64* %n.addr, align 8
  ret i64 %9
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @check_ctrlrecip(%struct.dev_state* %ps, i32 %requesttype, i32 %request, i32 %index) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %requesttype.addr = alloca i32, align 4
  %request.addr = alloca i32, align 4
  %index.addr = alloca i32, align 4
  %ret = alloca i32, align 4
  %alt_setting = alloca %struct.usb_host_interface*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i32 %requesttype, i32* %requesttype.addr, align 4
  store i32 %request, i32* %request.addr, align 4
  store i32 %index, i32* %index.addr, align 4
  store i32 0, i32* %ret, align 4
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8
  %cmp = icmp ne i32 %2, 4
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  %state2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 3
  %5 = load i32, i32* %state2, align 8
  %cmp3 = icmp ne i32 %5, 6
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %6 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %6, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %dev5, align 8
  %state6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 3
  %8 = load i32, i32* %state6, align 8
  %cmp7 = icmp ne i32 %8, 7
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  store i32 -113, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %entry
  %9 = load i32, i32* %requesttype.addr, align 4
  %and = and i32 96, %9
  %cmp8 = icmp eq i32 64, %and
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %10 = load i32, i32* %requesttype.addr, align 4
  %cmp11 = icmp eq i32 %10, 161
  br i1 %cmp11, label %land.lhs.true12, label %if.end23

land.lhs.true12:                                  ; preds = %if.end10
  %11 = load i32, i32* %request.addr, align 4
  %cmp13 = icmp eq i32 %11, 0
  br i1 %cmp13, label %if.then14, label %if.end23

if.then14:                                        ; preds = %land.lhs.true12
  %12 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev15 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %12, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %dev15, align 8
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 15
  %14 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %15 = load i32, i32* %index.addr, align 4
  %shr = lshr i32 %15, 8
  %16 = load i32, i32* %index.addr, align 4
  %and16 = and i32 %16, 255
  %call = call %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %14, i32 %shr, i32 %and16)
  store %struct.usb_host_interface* %call, %struct.usb_host_interface** %alt_setting, align 8
  %17 = load %struct.usb_host_interface*, %struct.usb_host_interface** %alt_setting, align 8
  %tobool = icmp ne %struct.usb_host_interface* %17, null
  br i1 %tobool, label %land.lhs.true17, label %if.end22

land.lhs.true17:                                  ; preds = %if.then14
  %18 = load %struct.usb_host_interface*, %struct.usb_host_interface** %alt_setting, align 8
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %18, i32 0, i32 0
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %19 = load i8, i8* %bInterfaceClass, align 1
  %conv = zext i8 %19 to i32
  %cmp18 = icmp eq i32 %conv, 7
  br i1 %cmp18, label %if.then20, label %if.end22

if.then20:                                        ; preds = %land.lhs.true17
  %20 = load i32, i32* %index.addr, align 4
  %shr21 = lshr i32 %20, 8
  store i32 %shr21, i32* %index.addr, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %land.lhs.true17, %if.then14
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %land.lhs.true12, %if.end10
  %21 = load i32, i32* %index.addr, align 4
  %and24 = and i32 %21, 255
  store i32 %and24, i32* %index.addr, align 4
  %22 = load i32, i32* %requesttype.addr, align 4
  %and25 = and i32 %22, 31
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end23
  %Pivot = icmp slt i32 %and25, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and25, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %and25, 1
  br i1 %SwitchLeaf, label %sw.bb38, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %23 = load i32, i32* %index.addr, align 4
  %and26 = and i32 %23, -129
  %cmp27 = icmp eq i32 %and26, 0
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %sw.bb
  store i32 0, i32* %retval, align 4
  br label %return

if.end30:                                         ; preds = %sw.bb
  %24 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev31 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %24, i32 0, i32 1
  %25 = load %struct.usb_device*, %struct.usb_device** %dev31, align 8
  %26 = load i32, i32* %index.addr, align 4
  %call32 = call i32 @findintfep(%struct.usb_device* %25, i32 %26)
  store i32 %call32, i32* %ret, align 4
  %27 = load i32, i32* %ret, align 4
  %cmp33 = icmp sge i32 %27, 0
  br i1 %cmp33, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end30
  %28 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %29 = load i32, i32* %ret, align 4
  %call36 = call i32 @checkintf(%struct.dev_state* %28, i32 %29)
  store i32 %call36, i32* %ret, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end30
  br label %sw.epilog

sw.bb38:                                          ; preds = %LeafBlock
  %30 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %31 = load i32, i32* %index.addr, align 4
  %call39 = call i32 @checkintf(%struct.dev_state* %30, i32 %31)
  store i32 %call39, i32* %ret, align 4
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %sw.bb38, %if.end37
  %32 = load i32, i32* %ret, align 4
  store i32 %32, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then29, %if.then9, %if.then
  %33 = load i32, i32* %retval, align 4
  ret i32 %33
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbfs_increase_memory_usage(i32 %amount) #0 {
entry:
  %retval = alloca i32, align 4
  %amount.addr = alloca i32, align 4
  %lim = alloca i32, align 4
  store i32 %amount, i32* %amount.addr, align 4
  %0 = load volatile i32, i32* @usbfs_memory_mb, align 4
  store i32 %0, i32* %lim, align 4
  %1 = load i32, i32* %lim, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, i32* %lim, align 4
  %cmp1 = icmp ugt i32 %2, 2047
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 2146483647, i32* %lim, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %3 = load i32, i32* %lim, align 4
  %shl = shl i32 %3, 20
  store i32 %shl, i32* %lim, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %4 = load i32, i32* %amount.addr, align 4
  call void @atomic_add(i32 %4, %struct.atomic_t* @usbfs_memory_usage)
  %call = call i32 @atomic_read(%struct.atomic_t* @usbfs_memory_usage)
  %5 = load i32, i32* %lim, align 4
  %cmp2 = icmp ule i32 %call, %5
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load i32, i32* %amount.addr, align 4
  call void @atomic_sub(i32 %6, %struct.atomic_t* @usbfs_memory_usage)
  store i32 -12, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3
  %7 = load i32, i32* %retval, align 4
  ret i32 %7
}

declare i64 @__get_free_pages(i32, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal zeroext i16 @__le16_to_cpup(i16* %p) #0 {
entry:
  %p.addr = alloca i16*, align 8
  store i16* %p, i16** %p.addr, align 8
  %0 = load i16*, i16** %p.addr, align 8
  %1 = load i16, i16* %0, align 2
  ret i16 %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.thread_info* @current_thread_info() #0 {
entry:
  %ti = alloca %struct.thread_info*, align 8
  %pfo_ret__ = alloca i64, align 8
  %tmp = alloca i64, align 8
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #6, !srcloc !30
  store i64 %0, i64* %pfo_ret__, align 8
  %1 = load i64, i64* %pfo_ret__, align 8
  store i64 %1, i64* %tmp, align 8
  %2 = load i64, i64* %tmp, align 8
  %add = add i64 %2, 40
  %sub = sub i64 %add, 8192
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.thread_info*
  store %struct.thread_info* %4, %struct.thread_info** %ti, align 8
  %5 = load %struct.thread_info*, %struct.thread_info** %ti, align 8
  ret %struct.thread_info* %5
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @__create_pipe(%struct.usb_device* %dev, i32 %endpoint) #0 {
entry:
  %dev.addr = alloca %struct.usb_device*, align 8
  %endpoint.addr = alloca i32, align 4
  store %struct.usb_device* %dev, %struct.usb_device** %dev.addr, align 8
  store i32 %endpoint, i32* %endpoint.addr, align 4
  %0 = load %struct.usb_device*, %struct.usb_device** %dev.addr, align 8
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %1 = load i32, i32* %devnum, align 8
  %shl = shl i32 %1, 8
  %2 = load i32, i32* %endpoint.addr, align 4
  %shl1 = shl i32 %2, 15
  %or = or i32 %shl, %shl1
  ret i32 %or
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @snoop_urb(%struct.usb_device* %udev, i8* %userurb, i32 %pipe, i32 %length, i32 %timeout_or_status, i32 %when, i8* %data, i32 %data_len) #0 {
entry:
  %udev.addr = alloca %struct.usb_device*, align 8
  %userurb.addr = alloca i8*, align 8
  %pipe.addr = alloca i32, align 4
  %length.addr = alloca i32, align 4
  %timeout_or_status.addr = alloca i32, align 4
  %when.addr = alloca i32, align 4
  %data.addr = alloca i8*, align 8
  %data_len.addr = alloca i32, align 4
  %ep = alloca i32, align 4
  %t = alloca i8*, align 8
  %d = alloca i8*, align 8
  store %struct.usb_device* %udev, %struct.usb_device** %udev.addr, align 8
  store i8* %userurb, i8** %userurb.addr, align 8
  store i32 %pipe, i32* %pipe.addr, align 4
  store i32 %length, i32* %length.addr, align 4
  store i32 %timeout_or_status, i32* %timeout_or_status.addr, align 4
  store i32 %when, i32* %when.addr, align 4
  store i8* %data, i8** %data.addr, align 8
  store i32 %data_len, i32* %data_len.addr, align 4
  %0 = load i8, i8* @usbfs_snoop, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end27

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pipe.addr, align 4
  %shr = ashr i32 %1, 15
  %and = and i32 %shr, 15
  store i32 %and, i32* %ep, align 4
  %2 = load i32, i32* %pipe.addr, align 4
  %shr1 = ashr i32 %2, 30
  %and2 = and i32 %shr1, 3
  %idxprom = sext i32 %and2 to i64
  %arrayidx = getelementptr inbounds [4 x i8*], [4 x i8*]* @snoop_urb.types, i64 0, i64 %idxprom
  %3 = load i8*, i8** %arrayidx, align 8
  store i8* %3, i8** %t, align 8
  %4 = load i32, i32* %pipe.addr, align 4
  %and3 = and i32 %4, 128
  %tobool4 = icmp ne i32 %and3, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %idxprom6 = sext i32 %lnot.ext to i64
  %arrayidx7 = getelementptr inbounds [2 x i8*], [2 x i8*]* @snoop_urb.dirs, i64 0, i64 %idxprom6
  %5 = load i8*, i8** %arrayidx7, align 8
  store i8* %5, i8** %d, align 8
  %6 = load i8*, i8** %userurb.addr, align 8
  %tobool8 = icmp ne i8* %6, null
  br i1 %tobool8, label %if.then9, label %if.else14

if.then9:                                         ; preds = %if.end
  %7 = load i32, i32* %when.addr, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then9
  %8 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  %9 = load i8*, i8** %userurb.addr, align 8
  %10 = load i32, i32* %ep, align 4
  %11 = load i8*, i8** %t, align 8
  %12 = load i8*, i8** %d, align 8
  %13 = load i32, i32* %length.addr, align 4
  %call = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.41, i32 0, i32 0), i8* %9, i32 %10, i8* %11, i8* %12, i32 %13)
  br label %if.end13

if.else:                                          ; preds = %if.then9
  %14 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %dev11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %14, i32 0, i32 11
  %15 = load i8*, i8** %userurb.addr, align 8
  %16 = load i32, i32* %ep, align 4
  %17 = load i8*, i8** %t, align 8
  %18 = load i8*, i8** %d, align 8
  %19 = load i32, i32* %length.addr, align 4
  %20 = load i32, i32* %timeout_or_status.addr, align 4
  %call12 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev11, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.42, i32 0, i32 0), i8* %15, i32 %16, i8* %17, i8* %18, i32 %19, i32 %20)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then10
  br label %if.end23

if.else14:                                        ; preds = %if.end
  %21 = load i32, i32* %when.addr, align 4
  %cmp15 = icmp eq i32 %21, 0
  br i1 %cmp15, label %if.then16, label %if.else19

if.then16:                                        ; preds = %if.else14
  %22 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %dev17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %22, i32 0, i32 11
  %23 = load i32, i32* %ep, align 4
  %24 = load i8*, i8** %t, align 8
  %25 = load i8*, i8** %d, align 8
  %26 = load i32, i32* %length.addr, align 4
  %27 = load i32, i32* %timeout_or_status.addr, align 4
  %call18 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev17, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.43, i32 0, i32 0), i32 %23, i8* %24, i8* %25, i32 %26, i32 %27)
  br label %if.end22

if.else19:                                        ; preds = %if.else14
  %28 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %dev20 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %28, i32 0, i32 11
  %29 = load i32, i32* %ep, align 4
  %30 = load i8*, i8** %t, align 8
  %31 = load i8*, i8** %d, align 8
  %32 = load i32, i32* %length.addr, align 4
  %33 = load i32, i32* %timeout_or_status.addr, align 4
  %call21 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev20, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.44, i32 0, i32 0), i32 %29, i8* %30, i8* %31, i32 %32, i32 %33)
  br label %if.end22

if.end22:                                         ; preds = %if.else19, %if.then16
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end13
  %34 = load i8*, i8** %data.addr, align 8
  %tobool24 = icmp ne i8* %34, null
  br i1 %tobool24, label %land.lhs.true, label %if.end27

land.lhs.true:                                    ; preds = %if.end23
  %35 = load i32, i32* %data_len.addr, align 4
  %cmp25 = icmp ugt i32 %35, 0
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %land.lhs.true
  %36 = load i8*, i8** %data.addr, align 8
  %37 = load i32, i32* %data_len.addr, align 4
  %conv = zext i32 %37 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %36, i64 %conv, i1 zeroext true)
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %land.lhs.true, %if.end23, %if.then
  ret void
}

declare i32 @usb_control_msg(%struct.usb_device*, i32, i8 zeroext, i8 zeroext, i16 zeroext, i16 zeroext, i8*, i16 zeroext, i32) #1

declare i32 @dev_printk(i8*, %struct.device*, i8*, ...) #1

declare void @free_pages(i64, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @usbfs_decrease_memory_usage(i32 %amount) #0 {
entry:
  %amount.addr = alloca i32, align 4
  store i32 %amount, i32* %amount.addr, align 4
  %0 = load i32, i32* %amount.addr, align 4
  call void @atomic_sub(i32 %0, %struct.atomic_t* @usbfs_memory_usage)
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #4

declare i64 @_copy_from_user(i8*, i8*, i32) #1

declare %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config*, i32, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @findintfep(%struct.usb_device* %dev, i32 %ep) #0 {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.usb_device*, align 8
  %ep.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %e = alloca i32, align 4
  %intf = alloca %struct.usb_interface*, align 8
  %alts = alloca %struct.usb_host_interface*, align 8
  %endpt = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_device* %dev, %struct.usb_device** %dev.addr, align 8
  store i32 %ep, i32* %ep.addr, align 4
  %0 = load i32, i32* %ep.addr, align 4
  %and = and i32 %0, -144
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.usb_device*, %struct.usb_device** %dev.addr, align 8
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 15
  %2 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8
  %tobool1 = icmp ne %struct.usb_host_config* %2, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i32 -3, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc32, %if.end3
  %3 = load i32, i32* %i, align 4
  %4 = load %struct.usb_device*, %struct.usb_device** %dev.addr, align 8
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 15
  %5 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %6 = load i8, i8* %bNumInterfaces, align 4
  %conv = zext i8 %6 to i32
  %cmp = icmp ult i32 %3, %conv
  br i1 %cmp, label %for.body, label %for.end34

for.body:                                         ; preds = %for.cond
  %7 = load %struct.usb_device*, %struct.usb_device** %dev.addr, align 8
  %actconfig6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 15
  %8 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig6, align 8
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %8, i32 0, i32 3
  %9 = load i32, i32* %i, align 4
  %idxprom = zext i32 %9 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %10 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8
  store %struct.usb_interface* %10, %struct.usb_interface** %intf, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc29, %for.body
  %11 = load i32, i32* %j, align 4
  %12 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 2
  %13 = load i32, i32* %num_altsetting, align 8
  %cmp8 = icmp ult i32 %11, %13
  br i1 %cmp8, label %for.body10, label %for.end31

for.body10:                                       ; preds = %for.cond7
  %14 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %14, i32 0, i32 0
  %15 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8
  %16 = load i32, i32* %j, align 4
  %idxprom11 = zext i32 %16 to i64
  %arrayidx12 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %15, i64 %idxprom11
  store %struct.usb_host_interface* %arrayidx12, %struct.usb_host_interface** %alts, align 8
  store i32 0, i32* %e, align 4
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc, %for.body10
  %17 = load i32, i32* %e, align 4
  %18 = load %struct.usb_host_interface*, %struct.usb_host_interface** %alts, align 8
  %desc14 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %18, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc14, i32 0, i32 4
  %19 = load i8, i8* %bNumEndpoints, align 4
  %conv15 = zext i8 %19 to i32
  %cmp16 = icmp ult i32 %17, %conv15
  br i1 %cmp16, label %for.body18, label %for.end

for.body18:                                       ; preds = %for.cond13
  %20 = load %struct.usb_host_interface*, %struct.usb_host_interface** %alts, align 8
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %20, i32 0, i32 3
  %21 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8
  %22 = load i32, i32* %e, align 4
  %idxprom19 = zext i32 %22 to i64
  %arrayidx20 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %21, i64 %idxprom19
  %desc21 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx20, i32 0, i32 0
  store %struct.usb_endpoint_descriptor* %desc21, %struct.usb_endpoint_descriptor** %endpt, align 8
  %23 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %endpt, align 8
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %23, i32 0, i32 2
  %24 = load i8, i8* %bEndpointAddress, align 1
  %conv22 = zext i8 %24 to i32
  %25 = load i32, i32* %ep.addr, align 4
  %cmp23 = icmp eq i32 %conv22, %25
  br i1 %cmp23, label %if.then25, label %if.end28

if.then25:                                        ; preds = %for.body18
  %26 = load %struct.usb_host_interface*, %struct.usb_host_interface** %alts, align 8
  %desc26 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %26, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc26, i32 0, i32 2
  %27 = load i8, i8* %bInterfaceNumber, align 2
  %conv27 = zext i8 %27 to i32
  store i32 %conv27, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %for.body18
  br label %for.inc

for.inc:                                          ; preds = %if.end28
  %28 = load i32, i32* %e, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %e, align 4
  br label %for.cond13

for.end:                                          ; preds = %for.cond13
  br label %for.inc29

for.inc29:                                        ; preds = %for.end
  %29 = load i32, i32* %j, align 4
  %inc30 = add i32 %29, 1
  store i32 %inc30, i32* %j, align 4
  br label %for.cond7

for.end31:                                        ; preds = %for.cond7
  br label %for.inc32

for.inc32:                                        ; preds = %for.end31
  %30 = load i32, i32* %i, align 4
  %inc33 = add i32 %30, 1
  store i32 %inc33, i32* %i, align 4
  br label %for.cond

for.end34:                                        ; preds = %for.cond
  store i32 -2, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end34, %if.then25, %if.then2, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @checkintf(%struct.dev_state* %ps, i32 %ifnum) #0 {
entry:
  %pfo_ret__.i17 = alloca %struct.task_struct*, align 8
  %tmp.i18 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %nr.addr.i = alloca i32, align 4
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %ifnum.addr = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i32 %ifnum, i32* %ifnum.addr, align 4
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 3
  %2 = load i32, i32* %state, align 8
  %cmp = icmp ne i32 %2, 7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -113, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %ifnum.addr, align 4
  %conv = zext i32 %3 to i64
  %cmp1 = icmp uge i64 %conv, 64
  br i1 %cmp1, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end4
  %4 = load i32, i32* %ifnum.addr, align 4
  %5 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 11
  store i32 %4, i32* %nr.addr.i, align 4
  store i64* %ifclaimed, i64** %addr.addr.i, align 8
  %6 = load i32, i32* %nr.addr.i, align 4
  %rem.i = urem i32 %6, 64
  %sh_prom.i = zext i32 %rem.i to i64
  %shl.i = shl i64 1, %sh_prom.i
  %7 = load i64*, i64** %addr.addr.i, align 8
  %8 = load i32, i32* %nr.addr.i, align 4
  %div.i = udiv i32 %8, 64
  %idxprom.i = zext i32 %div.i to i64
  %arrayidx.i = getelementptr inbounds i64, i64* %7, i64 %idxprom.i
  %9 = load volatile i64, i64* %arrayidx.i, align 8
  %and.i = and i64 %shl.i, %9
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then8, label %if.end9

cond.false:                                       ; preds = %if.end4
  %10 = load i32, i32* %ifnum.addr, align 4
  %11 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %ifclaimed5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %11, i32 0, i32 11
  %call6 = call i32 @variable_test_bit(i32 %10, i64* %ifclaimed5)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %cond.false, %cond.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %cond.false, %cond.true
  %12 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev10 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %12, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %dev10, align 8
  %dev11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 11
  %14 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %14, %struct.task_struct** %pfo_ret__.i, align 8
  %15 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %15, %struct.task_struct** %tmp.i, align 8
  %16 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call13 = call i32 @task_pid_nr(%struct.task_struct* %16)
  %17 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %17, %struct.task_struct** %pfo_ret__.i17, align 8
  %18 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i17, align 8
  store %struct.task_struct* %18, %struct.task_struct** %tmp.i18, align 8
  %19 = load %struct.task_struct*, %struct.task_struct** %tmp.i18, align 8
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %19, i32 0, i32 64
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %20 = load i32, i32* %ifnum.addr, align 4
  %call15 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev11, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.34, i32 0, i32 0), i32 %call13, i8* %arraydecay, i32 %20)
  %21 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %22 = load i32, i32* %ifnum.addr, align 4
  %call16 = call i32 @claimintf(%struct.dev_state* %21, i32 %22)
  store i32 %call16, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then8, %if.then3, %if.then
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #0 {
entry:
  %nr.addr = alloca i32, align 4
  %addr.addr = alloca i64*, align 8
  %oldbit = alloca i32, align 4
  store i32 %nr, i32* %nr.addr, align 4
  store i64* %addr, i64** %addr.addr, align 8
  %0 = load i64*, i64** %addr.addr, align 8
  %1 = load i32, i32* %nr.addr, align 4
  %2 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %0, i32 %1) #5, !srcloc !31
  store i32 %2, i32* %oldbit, align 4
  %3 = load i32, i32* %oldbit, align 4
  ret i32 %3
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @task_pid_nr(%struct.task_struct* %tsk) #0 {
entry:
  %tsk.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %tsk, %struct.task_struct** %tsk.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %tsk.addr, align 8
  %pid = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 34
  %1 = load i32, i32* %pid, align 4
  ret i32 %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @claimintf(%struct.dev_state* %ps, i32 %ifnum) #0 {
entry:
  %nr.addr.i18 = alloca i32, align 4
  %addr.addr.i19 = alloca i64*, align 8
  %nr.addr.i = alloca i32, align 4
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %ifnum.addr = alloca i32, align 4
  %dev = alloca %struct.usb_device*, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %err = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i32 %ifnum, i32* %ifnum.addr, align 4
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %1, %struct.usb_device** %dev, align 8
  %2 = load i32, i32* %ifnum.addr, align 4
  %conv = zext i32 %2 to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %3 = load i32, i32* %ifnum.addr, align 4
  %4 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %4, i32 0, i32 11
  store i32 %3, i32* %nr.addr.i, align 4
  store i64* %ifclaimed, i64** %addr.addr.i, align 8
  %5 = load i32, i32* %nr.addr.i, align 4
  %rem.i = urem i32 %5, 64
  %sh_prom.i = zext i32 %rem.i to i64
  %shl.i = shl i64 1, %sh_prom.i
  %6 = load i64*, i64** %addr.addr.i, align 8
  %7 = load i32, i32* %nr.addr.i, align 4
  %div.i = udiv i32 %7, 64
  %idxprom.i = zext i32 %div.i to i64
  %arrayidx.i = getelementptr inbounds i64, i64* %6, i64 %idxprom.i
  %8 = load volatile i64, i64* %arrayidx.i, align 8
  %and.i = and i64 %shl.i, %8
  %cmp.i = icmp ne i64 %and.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then6, label %if.end7

cond.false:                                       ; preds = %if.end
  %9 = load i32, i32* %ifnum.addr, align 4
  %10 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %ifclaimed3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %10, i32 0, i32 11
  %call4 = call i32 @variable_test_bit(i32 %9, i64* %ifclaimed3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %cond.false, %cond.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %cond.false, %cond.true
  %11 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %12 = load i32, i32* %ifnum.addr, align 4
  %call8 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %11, i32 %12)
  store %struct.usb_interface* %call8, %struct.usb_interface** %intf, align 8
  %13 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %tobool9 = icmp ne %struct.usb_interface* %13, null
  br i1 %tobool9, label %if.else, label %if.then10

if.then10:                                        ; preds = %if.end7
  store i32 -2, i32* %err, align 4
  br label %if.end12

if.else:                                          ; preds = %if.end7
  %14 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %15 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %16 = bitcast %struct.dev_state* %15 to i8*
  %call11 = call i32 @usb_driver_claim_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %14, i8* %16)
  store i32 %call11, i32* %err, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then10
  %17 = load i32, i32* %err, align 4
  %cmp13 = icmp eq i32 %17, 0
  br i1 %cmp13, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end12
  %18 = load i32, i32* %ifnum.addr, align 4
  %19 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %ifclaimed16 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %19, i32 0, i32 11
  store i32 %18, i32* %nr.addr.i18, align 4
  store i64* %ifclaimed16, i64** %addr.addr.i19, align 8
  %20 = load i64*, i64** %addr.addr.i19, align 8
  %21 = load i32, i32* %nr.addr.i18, align 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %20, i32 %21, i64* %20) #5, !srcloc !32
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end12
  %22 = load i32, i32* %err, align 4
  store i32 %22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end17, %if.then6, %if.then
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

declare %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device*, i32) #1

declare i32 @usb_driver_claim_interface(%struct.usb_driver*, %struct.usb_interface*, i8*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @atomic_add(i32 %i, %struct.atomic_t* %v) #0 {
entry:
  %i.addr = alloca i32, align 4
  %v.addr = alloca %struct.atomic_t*, align 8
  store i32 %i, i32* %i.addr, align 4
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  %0 = load %struct.atomic_t*, %struct.atomic_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %0, i32 0, i32 0
  %1 = load i32, i32* %i.addr, align 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; addl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %1, i32* %counter) #5, !srcloc !33
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @atomic_read(%struct.atomic_t* %v) #0 {
entry:
  %v.addr = alloca %struct.atomic_t*, align 8
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  %0 = load %struct.atomic_t*, %struct.atomic_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %0, i32 0, i32 0
  %1 = load volatile i32, i32* %counter, align 4
  ret i32 %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @atomic_sub(i32 %i, %struct.atomic_t* %v) #0 {
entry:
  %i.addr = alloca i32, align 4
  %v.addr = alloca %struct.atomic_t*, align 8
  store i32 %i, i32* %i.addr, align 4
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  %0 = load %struct.atomic_t*, %struct.atomic_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %0, i32 0, i32 0
  %1 = load i32, i32* %i.addr, align 4
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %1, i32* %counter) #5, !srcloc !34
  ret void
}

declare void @print_hex_dump(i8*, i8*, i32, i32, i32, i8*, i64, i1 zeroext) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal zeroext i16 @usb_maxpacket(%struct.usb_device* %udev, i32 %pipe, i32 %is_out) #0 {
entry:
  %retval = alloca i16, align 2
  %udev.addr = alloca %struct.usb_device*, align 8
  %pipe.addr = alloca i32, align 4
  %is_out.addr = alloca i32, align 4
  %ep = alloca %struct.usb_host_endpoint*, align 8
  %epnum = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on17 = alloca i32, align 4
  %tmp35 = alloca i64, align 8
  store %struct.usb_device* %udev, %struct.usb_device** %udev.addr, align 8
  store i32 %pipe, i32* %pipe.addr, align 4
  store i32 %is_out, i32* %is_out.addr, align 4
  %0 = load i32, i32* %pipe.addr, align 4
  %shr = ashr i32 %0, 15
  %and = and i32 %shr, 15
  store i32 %and, i32* %epnum, align 4
  %1 = load i32, i32* %is_out.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %pipe.addr, align 4
  %and1 = and i32 %2, 128
  %tobool2 = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %3 = load i32, i32* %__ret_warn_on, align 4
  %tobool4 = icmp ne i32 %3, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %tobool9 = icmp ne i64 %conv, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.46, i32 0, i32 0), i32 1773)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %4 = load i32, i32* %__ret_warn_on, align 4
  %tobool11 = icmp ne i32 %4, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  store i64 %conv16, i64* %tmp, align 8
  %5 = load i64, i64* %tmp, align 8
  %6 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 17
  %7 = load i32, i32* %epnum, align 4
  %idxprom = zext i32 %7 to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom
  %8 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8
  store %struct.usb_host_endpoint* %8, %struct.usb_host_endpoint** %ep, align 8
  br label %if.end44

if.else:                                          ; preds = %entry
  %9 = load i32, i32* %pipe.addr, align 4
  %and18 = and i32 %9, 128
  %tobool19 = icmp ne i32 %and18, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  store i32 %lnot.ext25, i32* %__ret_warn_on17, align 4
  %10 = load i32, i32* %__ret_warn_on17, align 4
  %tobool26 = icmp ne i32 %10, 0
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %tobool32 = icmp ne i64 %conv31, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.else
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.46, i32 0, i32 0), i32 1776)
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.else
  %11 = load i32, i32* %__ret_warn_on17, align 4
  %tobool36 = icmp ne i32 %11, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  store i64 %conv41, i64* %tmp35, align 8
  %12 = load i64, i64* %tmp35, align 8
  %13 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 16
  %14 = load i32, i32* %epnum, align 4
  %idxprom42 = zext i32 %14 to i64
  %arrayidx43 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom42
  %15 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx43, align 8
  store %struct.usb_host_endpoint* %15, %struct.usb_host_endpoint** %ep, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.end34, %if.end
  %16 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %tobool45 = icmp ne %struct.usb_host_endpoint* %16, null
  br i1 %tobool45, label %if.end47, label %if.then46

if.then46:                                        ; preds = %if.end44
  store i16 0, i16* %retval, align 2
  br label %return

if.end47:                                         ; preds = %if.end44
  %17 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %17, i32 0, i32 0
  %call = call i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %desc)
  %conv48 = trunc i32 %call to i16
  store i16 %conv48, i16* %retval, align 2
  br label %return

return:                                           ; preds = %if.end47, %if.then46
  %18 = load i16, i16* %retval, align 2
  ret i16 %18
}

declare i32 @usb_bulk_msg(%struct.usb_device*, i32, i8*, i32, i32*, i32) #1

declare void @kfree(i8*) #1

declare void @warn_slowpath_null(i8*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 4
  %1 = load i16, i16* %wMaxPacketSize, align 1
  %conv = zext i16 %1 to i32
  ret i32 %conv
}

declare void @usb_reset_endpoint(%struct.usb_device*, i32) #1

declare i32 @usb_reset_device(%struct.usb_device*) #1

declare i32 @usb_clear_halt(%struct.usb_device*, i32) #1

declare i64 @strlcpy(i8*, i8*, i64) #1

declare i32 @usb_set_interface(%struct.usb_device*, i32, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_interface_claimed(%struct.usb_interface* %iface) #0 {
entry:
  %iface.addr = alloca %struct.usb_interface*, align 8
  store %struct.usb_interface* %iface, %struct.usb_interface** %iface.addr, align 8
  %0 = load %struct.usb_interface*, %struct.usb_interface** %iface.addr, align 8
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %1 = load %struct.device_driver*, %struct.device_driver** %driver, align 8
  %cmp = icmp ne %struct.device_driver* %1, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i32 @usb_reset_configuration(%struct.usb_device*) #1

declare i32 @usb_set_configuration(%struct.usb_device*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_do_submiturb(%struct.dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %iso_frame_desc, i8* %arg) #0 {
entry:
  %pfo_ret__.i526 = alloca %struct.task_struct*, align 8
  %tmp.i527 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i524 = alloca %struct.task_struct*, align 8
  %tmp.i525 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %size.addr.i521 = alloca i64, align 8
  %flags.addr.i522 = alloca i32, align 4
  %size.addr.i518 = alloca i64, align 8
  %flags.addr.i519 = alloca i32, align 4
  %size.addr.i515 = alloca i64, align 8
  %flags.addr.i516 = alloca i32, align 4
  %size.addr.i512 = alloca i64, align 8
  %flags.addr.i513 = alloca i32, align 4
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %uurb.addr = alloca %struct.usbdevfs_urb*, align 8
  %iso_frame_desc.addr = alloca %struct.usbdevfs_iso_packet_desc*, align 8
  %arg.addr = alloca i8*, align 8
  %isopkt = alloca %struct.usbdevfs_iso_packet_desc*, align 8
  %ep = alloca %struct.usb_host_endpoint*, align 8
  %as = alloca %struct.async*, align 8
  %dr = alloca %struct.usb_ctrlrequest*, align 8
  %u = alloca i32, align 4
  %totlen = alloca i32, align 4
  %isofrmlen = alloca i32, align 4
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %is_in = alloca i32, align 4
  %num_sgs = alloca i32, align 4
  %ifnum = alloca i32, align 4
  %buf = alloca i8*, align 8
  %flag = alloca i64, align 8
  %roksum = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %tmp385 = alloca i32, align 4
  %tmp445 = alloca %struct.cred*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_urb** %uurb.addr, align 8
  store %struct.usbdevfs_iso_packet_desc* %iso_frame_desc, %struct.usbdevfs_iso_packet_desc** %iso_frame_desc.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  store %struct.usbdevfs_iso_packet_desc* null, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  store %struct.async* null, %struct.async** %as, align 8
  store %struct.usb_ctrlrequest* null, %struct.usb_ctrlrequest** %dr, align 8
  store i32 0, i32* %num_sgs, align 4
  store i32 -1, i32* %ifnum, align 4
  %0 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 3
  %1 = load i32, i32* %flags, align 8
  %and = and i32 %1, -232
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 5
  %3 = load i32, i32* %buffer_length, align 8
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %land.lhs.true, label %if.end3

land.lhs.true:                                    ; preds = %if.end
  %4 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %4, i32 0, i32 4
  %5 = load i8*, i8** %buffer, align 8
  %tobool1 = icmp ne i8* %5, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %land.lhs.true
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %land.lhs.true, %if.end
  %6 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %6, i32 0, i32 0
  %7 = load i8, i8* %type, align 8
  %conv = zext i8 %7 to i32
  %cmp4 = icmp eq i32 %conv, 2
  br i1 %cmp4, label %land.lhs.true6, label %if.then11

land.lhs.true6:                                   ; preds = %if.end3
  %8 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %8, i32 0, i32 1
  %9 = load i8, i8* %endpoint, align 1
  %conv7 = zext i8 %9 to i32
  %and8 = and i32 %conv7, -129
  %cmp9 = icmp eq i32 %and8, 0
  br i1 %cmp9, label %if.end22, label %if.then11

if.then11:                                        ; preds = %land.lhs.true6, %if.end3
  %10 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %10, i32 0, i32 1
  %11 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %12 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint12 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %12, i32 0, i32 1
  %13 = load i8, i8* %endpoint12, align 1
  %conv13 = zext i8 %13 to i32
  %call = call i32 @findintfep(%struct.usb_device* %11, i32 %conv13)
  store i32 %call, i32* %ifnum, align 4
  %14 = load i32, i32* %ifnum, align 4
  %cmp14 = icmp slt i32 %14, 0
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then11
  %15 = load i32, i32* %ifnum, align 4
  store i32 %15, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.then11
  %16 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %17 = load i32, i32* %ifnum, align 4
  %call18 = call i32 @checkintf(%struct.dev_state* %16, i32 %17)
  store i32 %call18, i32* %ret, align 4
  %18 = load i32, i32* %ret, align 4
  %tobool19 = icmp ne i32 %18, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  %19 = load i32, i32* %ret, align 4
  store i32 %19, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %land.lhs.true6
  %20 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint23 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %20, i32 0, i32 1
  %21 = load i8, i8* %endpoint23, align 1
  %conv24 = zext i8 %21 to i32
  %and25 = and i32 %conv24, 128
  %cmp26 = icmp ne i32 %and25, 0
  br i1 %cmp26, label %if.then28, label %if.else

if.then28:                                        ; preds = %if.end22
  store i32 1, i32* %is_in, align 4
  %22 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev29 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %22, i32 0, i32 1
  %23 = load %struct.usb_device*, %struct.usb_device** %dev29, align 8
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %23, i32 0, i32 16
  %24 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint30 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %24, i32 0, i32 1
  %25 = load i8, i8* %endpoint30, align 1
  %conv31 = zext i8 %25 to i32
  %and32 = and i32 %conv31, 15
  %idxprom = sext i32 %and32 to i64
  %arrayidx = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in, i64 0, i64 %idxprom
  %26 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx, align 8
  store %struct.usb_host_endpoint* %26, %struct.usb_host_endpoint** %ep, align 8
  br label %if.end39

if.else:                                          ; preds = %if.end22
  store i32 0, i32* %is_in, align 4
  %27 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev33 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %27, i32 0, i32 1
  %28 = load %struct.usb_device*, %struct.usb_device** %dev33, align 8
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %28, i32 0, i32 17
  %29 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint34 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %29, i32 0, i32 1
  %30 = load i8, i8* %endpoint34, align 1
  %conv35 = zext i8 %30 to i32
  %and36 = and i32 %conv35, 15
  %idxprom37 = sext i32 %and36 to i64
  %arrayidx38 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out, i64 0, i64 %idxprom37
  %31 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx38, align 8
  store %struct.usb_host_endpoint* %31, %struct.usb_host_endpoint** %ep, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.else, %if.then28
  %32 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %tobool40 = icmp ne %struct.usb_host_endpoint* %32, null
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.end39
  store i32 -2, i32* %retval, align 4
  br label %return

if.end42:                                         ; preds = %if.end39
  store i32 0, i32* %u, align 4
  %33 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type43 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %33, i32 0, i32 0
  %34 = load i8, i8* %type43, align 8
  %conv44 = zext i8 %34 to i32
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end42
  %Pivot6 = icmp slt i32 %conv44, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %conv44, 3
  br i1 %Pivot4, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %conv44, 3
  br i1 %SwitchLeaf2, label %sw.bb118, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv44, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb134

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv44, 0
  br i1 %SwitchLeaf, label %sw.bb141, label %NewDefault

sw.bb:                                            ; preds = %NodeBlock3
  %35 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %35, i32 0, i32 0
  %call45 = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %desc)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %sw.bb
  store i32 -22, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %sw.bb
  %36 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length49 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %36, i32 0, i32 5
  %37 = load i32, i32* %buffer_length49, align 8
  %cmp50 = icmp slt i32 %37, 8
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end48
  store i32 -22, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.end48
  store i64 8, i64* %size.addr.i, align 8
  store i32 208, i32* %flags.addr.i, align 4
  %38 = load i64, i64* %size.addr.i, align 8
  %39 = load i32, i32* %flags.addr.i, align 4
  %call.i = call i8* @__kmalloc(i64 %38, i32 %39) #5
  %40 = bitcast i8* %call.i to %struct.usb_ctrlrequest*
  store %struct.usb_ctrlrequest* %40, %struct.usb_ctrlrequest** %dr, align 8
  %41 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %tobool55 = icmp ne %struct.usb_ctrlrequest* %41, null
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %if.end53
  store i32 -12, i32* %retval, align 4
  br label %return

if.end57:                                         ; preds = %if.end53
  %42 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %43 = bitcast %struct.usb_ctrlrequest* %42 to i8*
  %44 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer58 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %44, i32 0, i32 4
  %45 = load i8*, i8** %buffer58, align 8
  %call59 = call i64 @copy_from_user(i8* %43, i8* %45, i64 8)
  %tobool60 = icmp ne i64 %call59, 0
  br i1 %tobool60, label %if.then61, label %if.end62

if.then61:                                        ; preds = %if.end57
  store i32 -14, i32* %ret, align 4
  br label %error

if.end62:                                         ; preds = %if.end57
  %46 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length63 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %46, i32 0, i32 5
  %47 = load i32, i32* %buffer_length63, align 8
  %48 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wLength = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %48, i32 0, i32 4
  %call64 = call zeroext i16 @__le16_to_cpup(i16* %wLength)
  %conv65 = zext i16 %call64 to i32
  %add = add nsw i32 %conv65, 8
  %cmp66 = icmp slt i32 %47, %add
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.end62
  store i32 -22, i32* %ret, align 4
  br label %error

if.end69:                                         ; preds = %if.end62
  %49 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %50 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %50, i32 0, i32 0
  %51 = load i8, i8* %bRequestType, align 1
  %conv70 = zext i8 %51 to i32
  %52 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %bRequest = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %52, i32 0, i32 1
  %53 = load i8, i8* %bRequest, align 1
  %conv71 = zext i8 %53 to i32
  %54 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wIndex = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %54, i32 0, i32 3
  %call72 = call zeroext i16 @__le16_to_cpup(i16* %wIndex)
  %conv73 = zext i16 %call72 to i32
  %call74 = call i32 @check_ctrlrecip(%struct.dev_state* %49, i32 %conv70, i32 %conv71, i32 %conv73)
  store i32 %call74, i32* %ret, align 4
  %55 = load i32, i32* %ret, align 4
  %tobool75 = icmp ne i32 %55, 0
  br i1 %tobool75, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.end69
  br label %error

if.end77:                                         ; preds = %if.end69
  %56 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %number_of_packets = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %56, i32 0, i32 8
  store i32 0, i32* %number_of_packets, align 4
  %57 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wLength78 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %57, i32 0, i32 4
  %call79 = call zeroext i16 @__le16_to_cpup(i16* %wLength78)
  %conv80 = zext i16 %call79 to i32
  %58 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length81 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %58, i32 0, i32 5
  store i32 %conv80, i32* %buffer_length81, align 8
  %59 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer82 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %59, i32 0, i32 4
  %60 = load i8*, i8** %buffer82, align 8
  %add.ptr = getelementptr i8, i8* %60, i64 8
  store i8* %add.ptr, i8** %buffer82, align 8
  %61 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %bRequestType83 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %61, i32 0, i32 0
  %62 = load i8, i8* %bRequestType83, align 1
  %conv84 = zext i8 %62 to i32
  %and85 = and i32 %conv84, 128
  %tobool86 = icmp ne i32 %and85, 0
  br i1 %tobool86, label %land.lhs.true87, label %if.else94

land.lhs.true87:                                  ; preds = %if.end77
  %63 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length88 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %63, i32 0, i32 5
  %64 = load i32, i32* %buffer_length88, align 8
  %tobool89 = icmp ne i32 %64, 0
  br i1 %tobool89, label %if.then90, label %if.else94

if.then90:                                        ; preds = %land.lhs.true87
  store i32 1, i32* %is_in, align 4
  %65 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint91 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %65, i32 0, i32 1
  %66 = load i8, i8* %endpoint91, align 1
  %conv92 = zext i8 %66 to i32
  %or = or i32 %conv92, 128
  %conv93 = trunc i32 %or to i8
  store i8 %conv93, i8* %endpoint91, align 1
  br label %if.end99

if.else94:                                        ; preds = %land.lhs.true87, %if.end77
  store i32 0, i32* %is_in, align 4
  %67 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint95 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %67, i32 0, i32 1
  %68 = load i8, i8* %endpoint95, align 1
  %conv96 = zext i8 %68 to i32
  %and97 = and i32 %conv96, -129
  %conv98 = trunc i32 %and97 to i8
  store i8 %conv98, i8* %endpoint95, align 1
  br label %if.end99

if.end99:                                         ; preds = %if.else94, %if.then90
  br label %do.body

do.body:                                          ; preds = %if.end99
  %69 = load i8, i8* @usbfs_snoop, align 1
  %tobool100 = trunc i8 %69 to i1
  br i1 %tobool100, label %if.then101, label %if.end117

if.then101:                                       ; preds = %do.body
  %70 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev102 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %70, i32 0, i32 1
  %71 = load %struct.usb_device*, %struct.usb_device** %dev102, align 8
  %dev103 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %71, i32 0, i32 11
  %72 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %bRequestType104 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %72, i32 0, i32 0
  %73 = load i8, i8* %bRequestType104, align 1
  %conv105 = zext i8 %73 to i32
  %74 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %bRequest106 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %74, i32 0, i32 1
  %75 = load i8, i8* %bRequest106, align 1
  %conv107 = zext i8 %75 to i32
  %76 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wValue = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %76, i32 0, i32 2
  %call108 = call zeroext i16 @__le16_to_cpup(i16* %wValue)
  %conv109 = zext i16 %call108 to i32
  %77 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wIndex110 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %77, i32 0, i32 3
  %call111 = call zeroext i16 @__le16_to_cpup(i16* %wIndex110)
  %conv112 = zext i16 %call111 to i32
  %78 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %wLength113 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %78, i32 0, i32 4
  %call114 = call zeroext i16 @__le16_to_cpup(i16* %wLength113)
  %conv115 = zext i16 %call114 to i32
  %call116 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev103, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @.str.31, i32 0, i32 0), i32 %conv105, i32 %conv107, i32 %conv109, i32 %conv112, i32 %conv115)
  br label %if.end117

if.end117:                                        ; preds = %if.then101, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end117
  store i32 8, i32* %u, align 4
  br label %sw.epilog186

sw.bb118:                                         ; preds = %LeafBlock1
  %79 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc119 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %79, i32 0, i32 0
  %call120 = call i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %desc119)
  br label %NodeBlock12

NodeBlock12:                                      ; preds = %sw.bb118
  %Pivot13 = icmp slt i32 %call120, 3
  br i1 %Pivot13, label %LeafBlock8, label %LeafBlock10

LeafBlock10:                                      ; preds = %NodeBlock12
  %SwitchLeaf11 = icmp eq i32 %call120, 3
  br i1 %SwitchLeaf11, label %sw.bb122, label %NewDefault7

LeafBlock8:                                       ; preds = %NodeBlock12
  %SwitchLeaf9 = icmp ule i32 %call120, 1
  br i1 %SwitchLeaf9, label %sw.bb121, label %NewDefault7

sw.bb121:                                         ; preds = %LeafBlock8
  store i32 -22, i32* %retval, align 4
  br label %return

sw.bb122:                                         ; preds = %LeafBlock10
  %80 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type123 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %80, i32 0, i32 0
  store i8 1, i8* %type123, align 8
  br label %interrupt_urb

NewDefault7:                                      ; preds = %LeafBlock10, %LeafBlock8
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault7
  %81 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %number_of_packets124 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %81, i32 0, i32 8
  store i32 0, i32* %number_of_packets124, align 4
  %82 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length125 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %82, i32 0, i32 5
  %83 = load i32, i32* %buffer_length125, align 8
  %add126 = add nsw i32 %83, 16384
  %sub = sub nsw i32 %add126, 1
  %div = sdiv i32 %sub, 16384
  store i32 %div, i32* %num_sgs, align 4
  %84 = load i32, i32* %num_sgs, align 4
  %cmp127 = icmp eq i32 %84, 1
  br i1 %cmp127, label %if.then132, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %85 = load i32, i32* %num_sgs, align 4
  %86 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev129 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %86, i32 0, i32 1
  %87 = load %struct.usb_device*, %struct.usb_device** %dev129, align 8
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %87, i32 0, i32 9
  %88 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %88, i32 0, i32 7
  %89 = load i32, i32* %sg_tablesize, align 4
  %cmp130 = icmp ugt i32 %85, %89
  br i1 %cmp130, label %if.then132, label %if.end133

if.then132:                                       ; preds = %lor.lhs.false, %sw.epilog
  store i32 0, i32* %num_sgs, align 4
  br label %if.end133

if.end133:                                        ; preds = %if.then132, %lor.lhs.false
  br label %sw.epilog186

sw.bb134:                                         ; preds = %NodeBlock
  %90 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc135 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %90, i32 0, i32 0
  %call136 = call i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %desc135)
  %tobool137 = icmp ne i32 %call136, 0
  br i1 %tobool137, label %if.end139, label %if.then138

if.then138:                                       ; preds = %sw.bb134
  store i32 -22, i32* %retval, align 4
  br label %return

if.end139:                                        ; preds = %sw.bb134
  br label %interrupt_urb

interrupt_urb:                                    ; preds = %if.end139, %sw.bb122
  %91 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %number_of_packets140 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %91, i32 0, i32 8
  store i32 0, i32* %number_of_packets140, align 4
  br label %sw.epilog186

sw.bb141:                                         ; preds = %LeafBlock
  %92 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %number_of_packets142 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %92, i32 0, i32 8
  %93 = load i32, i32* %number_of_packets142, align 4
  %cmp143 = icmp slt i32 %93, 1
  br i1 %cmp143, label %if.then149, label %lor.lhs.false145

lor.lhs.false145:                                 ; preds = %sw.bb141
  %94 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %number_of_packets146 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %94, i32 0, i32 8
  %95 = load i32, i32* %number_of_packets146, align 4
  %cmp147 = icmp sgt i32 %95, 128
  br i1 %cmp147, label %if.then149, label %if.end150

if.then149:                                       ; preds = %lor.lhs.false145, %sw.bb141
  store i32 -22, i32* %retval, align 4
  br label %return

if.end150:                                        ; preds = %lor.lhs.false145
  %96 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc151 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %96, i32 0, i32 0
  %call152 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc151)
  %tobool153 = icmp ne i32 %call152, 0
  br i1 %tobool153, label %if.end155, label %if.then154

if.then154:                                       ; preds = %if.end150
  store i32 -22, i32* %retval, align 4
  br label %return

if.end155:                                        ; preds = %if.end150
  %97 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %number_of_packets156 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %97, i32 0, i32 8
  %98 = load i32, i32* %number_of_packets156, align 4
  %conv157 = sext i32 %98 to i64
  %mul = mul i64 12, %conv157
  %conv158 = trunc i64 %mul to i32
  store i32 %conv158, i32* %isofrmlen, align 4
  %99 = load i32, i32* %isofrmlen, align 4
  %conv159 = zext i32 %99 to i64
  store i64 %conv159, i64* %size.addr.i512, align 8
  store i32 208, i32* %flags.addr.i513, align 4
  %100 = load i64, i64* %size.addr.i512, align 8
  %101 = load i32, i32* %flags.addr.i513, align 4
  %call.i514 = call i8* @__kmalloc(i64 %100, i32 %101) #5
  %102 = bitcast i8* %call.i514 to %struct.usbdevfs_iso_packet_desc*
  store %struct.usbdevfs_iso_packet_desc* %102, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %tobool161 = icmp ne %struct.usbdevfs_iso_packet_desc* %102, null
  br i1 %tobool161, label %if.end163, label %if.then162

if.then162:                                       ; preds = %if.end155
  store i32 -12, i32* %retval, align 4
  br label %return

if.end163:                                        ; preds = %if.end155
  %103 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %104 = bitcast %struct.usbdevfs_iso_packet_desc* %103 to i8*
  %105 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %iso_frame_desc.addr, align 8
  %106 = bitcast %struct.usbdevfs_iso_packet_desc* %105 to i8*
  %107 = load i32, i32* %isofrmlen, align 4
  %conv164 = zext i32 %107 to i64
  %call165 = call i64 @copy_from_user(i8* %104, i8* %106, i64 %conv164)
  %tobool166 = icmp ne i64 %call165, 0
  br i1 %tobool166, label %if.then167, label %if.end168

if.then167:                                       ; preds = %if.end163
  store i32 -14, i32* %ret, align 4
  br label %error

if.end168:                                        ; preds = %if.end163
  store i32 0, i32* %u, align 4
  store i32 0, i32* %totlen, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end168
  %108 = load i32, i32* %u, align 4
  %109 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %number_of_packets169 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %109, i32 0, i32 8
  %110 = load i32, i32* %number_of_packets169, align 4
  %cmp170 = icmp ult i32 %108, %110
  br i1 %cmp170, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %111 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %112 = load i32, i32* %u, align 4
  %idxprom172 = zext i32 %112 to i64
  %arrayidx173 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %111, i64 %idxprom172
  %length = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx173, i32 0, i32 0
  %113 = load i32, i32* %length, align 4
  %cmp174 = icmp ugt i32 %113, 49152
  br i1 %cmp174, label %if.then176, label %if.end177

if.then176:                                       ; preds = %for.body
  store i32 -22, i32* %ret, align 4
  br label %error

if.end177:                                        ; preds = %for.body
  %114 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %115 = load i32, i32* %u, align 4
  %idxprom178 = zext i32 %115 to i64
  %arrayidx179 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %114, i64 %idxprom178
  %length180 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx179, i32 0, i32 0
  %116 = load i32, i32* %length180, align 4
  %117 = load i32, i32* %totlen, align 4
  %add181 = add i32 %117, %116
  store i32 %add181, i32* %totlen, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end177
  %118 = load i32, i32* %u, align 4
  %inc = add i32 %118, 1
  store i32 %inc, i32* %u, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %119 = load i32, i32* %u, align 4
  %conv182 = zext i32 %119 to i64
  %mul183 = mul i64 %conv182, 16
  %conv184 = trunc i64 %mul183 to i32
  store i32 %conv184, i32* %u, align 4
  %120 = load i32, i32* %totlen, align 4
  %121 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length185 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %121, i32 0, i32 5
  store i32 %120, i32* %buffer_length185, align 8
  br label %sw.epilog186

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog186:                                     ; preds = %for.end, %interrupt_urb, %if.end133, %do.end
  %122 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length187 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %122, i32 0, i32 5
  %123 = load i32, i32* %buffer_length187, align 8
  %cmp188 = icmp uge i32 %123, 2146483647
  br i1 %cmp188, label %if.then190, label %if.end191

if.then190:                                       ; preds = %sw.epilog186
  store i32 -22, i32* %ret, align 4
  br label %error

if.end191:                                        ; preds = %sw.epilog186
  %124 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length192 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %124, i32 0, i32 5
  %125 = load i32, i32* %buffer_length192, align 8
  %cmp193 = icmp sgt i32 %125, 0
  br i1 %cmp193, label %land.lhs.true195, label %if.end207

land.lhs.true195:                                 ; preds = %if.end191
  %126 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer196 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %126, i32 0, i32 4
  %127 = load i8*, i8** %buffer196, align 8
  %128 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length197 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %128, i32 0, i32 5
  %129 = load i32, i32* %buffer_length197, align 8
  %conv198 = sext i32 %129 to i64
  %call199 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call199, i32 0, i32 6
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %130 = load i64, i64* %seg, align 8
  %131 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %127, i64 %conv198, i64 %130) #7, !srcloc !35
  %asmresult = extractvalue { i64, i64 } %131, 0
  %asmresult200 = extractvalue { i64, i64 } %131, 1
  store i64 %asmresult, i64* %flag, align 8
  store i64 %asmresult200, i64* %roksum, align 8
  %132 = load i64, i64* %flag, align 8
  store i64 %132, i64* %tmp, align 8
  %133 = load i64, i64* %tmp, align 8
  %cmp201 = icmp eq i64 %133, 0
  %lnot = xor i1 %cmp201, true
  %lnot203 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot203 to i32
  %conv204 = sext i32 %lnot.ext to i64
  %tobool205 = icmp ne i64 %conv204, 0
  br i1 %tobool205, label %if.end207, label %if.then206

if.then206:                                       ; preds = %land.lhs.true195
  store i32 -14, i32* %ret, align 4
  br label %error

if.end207:                                        ; preds = %land.lhs.true195, %if.end191
  %134 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %number_of_packets208 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %134, i32 0, i32 8
  %135 = load i32, i32* %number_of_packets208, align 4
  %call209 = call %struct.async* @alloc_async(i32 %135)
  store %struct.async* %call209, %struct.async** %as, align 8
  %136 = load %struct.async*, %struct.async** %as, align 8
  %tobool210 = icmp ne %struct.async* %136, null
  br i1 %tobool210, label %if.end212, label %if.then211

if.then211:                                       ; preds = %if.end207
  store i32 -12, i32* %ret, align 4
  br label %error

if.end212:                                        ; preds = %if.end207
  %137 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length213 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %137, i32 0, i32 5
  %138 = load i32, i32* %buffer_length213, align 8
  %conv214 = sext i32 %138 to i64
  %add215 = add i64 280, %conv214
  %139 = load i32, i32* %num_sgs, align 4
  %conv216 = sext i32 %139 to i64
  %mul217 = mul i64 %conv216, 32
  %add218 = add i64 %add215, %mul217
  %140 = load i32, i32* %u, align 4
  %conv219 = zext i32 %140 to i64
  %add220 = add i64 %conv219, %add218
  %conv221 = trunc i64 %add220 to i32
  store i32 %conv221, i32* %u, align 4
  %141 = load i32, i32* %u, align 4
  %call222 = call i32 @usbfs_increase_memory_usage(i32 %141)
  store i32 %call222, i32* %ret, align 4
  %142 = load i32, i32* %ret, align 4
  %tobool223 = icmp ne i32 %142, 0
  br i1 %tobool223, label %if.then224, label %if.end225

if.then224:                                       ; preds = %if.end212
  br label %error

if.end225:                                        ; preds = %if.end212
  %143 = load i32, i32* %u, align 4
  %144 = load %struct.async*, %struct.async** %as, align 8
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %144, i32 0, i32 9
  store i32 %143, i32* %mem_usage, align 8
  %145 = load i32, i32* %num_sgs, align 4
  %tobool226 = icmp ne i32 %145, 0
  br i1 %tobool226, label %if.then227, label %if.else275

if.then227:                                       ; preds = %if.end225
  %146 = load i32, i32* %num_sgs, align 4
  %conv228 = sext i32 %146 to i64
  %mul229 = mul i64 %conv228, 32
  store i64 %mul229, i64* %size.addr.i515, align 8
  store i32 208, i32* %flags.addr.i516, align 4
  %147 = load i64, i64* %size.addr.i515, align 8
  %148 = load i32, i32* %flags.addr.i516, align 4
  %call.i517 = call i8* @__kmalloc(i64 %147, i32 %148) #5
  %149 = bitcast i8* %call.i517 to %struct.scatterlist*
  %150 = load %struct.async*, %struct.async** %as, align 8
  %urb = getelementptr inbounds %struct.async, %struct.async* %150, i32 0, i32 8
  %151 = load %struct.urb*, %struct.urb** %urb, align 8
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %151, i32 0, i32 16
  store %struct.scatterlist* %149, %struct.scatterlist** %sg, align 8
  %152 = load %struct.async*, %struct.async** %as, align 8
  %urb231 = getelementptr inbounds %struct.async, %struct.async* %152, i32 0, i32 8
  %153 = load %struct.urb*, %struct.urb** %urb231, align 8
  %sg232 = getelementptr inbounds %struct.urb, %struct.urb* %153, i32 0, i32 16
  %154 = load %struct.scatterlist*, %struct.scatterlist** %sg232, align 8
  %tobool233 = icmp ne %struct.scatterlist* %154, null
  br i1 %tobool233, label %if.end235, label %if.then234

if.then234:                                       ; preds = %if.then227
  store i32 -12, i32* %ret, align 4
  br label %error

if.end235:                                        ; preds = %if.then227
  %155 = load i32, i32* %num_sgs, align 4
  %156 = load %struct.async*, %struct.async** %as, align 8
  %urb236 = getelementptr inbounds %struct.async, %struct.async* %156, i32 0, i32 8
  %157 = load %struct.urb*, %struct.urb** %urb236, align 8
  %num_sgs237 = getelementptr inbounds %struct.urb, %struct.urb* %157, i32 0, i32 18
  store i32 %155, i32* %num_sgs237, align 4
  %158 = load %struct.async*, %struct.async** %as, align 8
  %urb238 = getelementptr inbounds %struct.async, %struct.async* %158, i32 0, i32 8
  %159 = load %struct.urb*, %struct.urb** %urb238, align 8
  %sg239 = getelementptr inbounds %struct.urb, %struct.urb* %159, i32 0, i32 16
  %160 = load %struct.scatterlist*, %struct.scatterlist** %sg239, align 8
  %161 = load %struct.async*, %struct.async** %as, align 8
  %urb240 = getelementptr inbounds %struct.async, %struct.async* %161, i32 0, i32 8
  %162 = load %struct.urb*, %struct.urb** %urb240, align 8
  %num_sgs241 = getelementptr inbounds %struct.urb, %struct.urb* %162, i32 0, i32 18
  %163 = load i32, i32* %num_sgs241, align 4
  call void @sg_init_table(%struct.scatterlist* %160, i32 %163)
  %164 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length242 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %164, i32 0, i32 5
  %165 = load i32, i32* %buffer_length242, align 8
  store i32 %165, i32* %totlen, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond243

for.cond243:                                      ; preds = %for.inc272, %if.end235
  %166 = load i32, i32* %i, align 4
  %167 = load %struct.async*, %struct.async** %as, align 8
  %urb244 = getelementptr inbounds %struct.async, %struct.async* %167, i32 0, i32 8
  %168 = load %struct.urb*, %struct.urb** %urb244, align 8
  %num_sgs245 = getelementptr inbounds %struct.urb, %struct.urb* %168, i32 0, i32 18
  %169 = load i32, i32* %num_sgs245, align 4
  %cmp246 = icmp slt i32 %166, %169
  br i1 %cmp246, label %for.body248, label %for.end274

for.body248:                                      ; preds = %for.cond243
  %170 = load i32, i32* %totlen, align 4
  %cmp249 = icmp ugt i32 %170, 16384
  br i1 %cmp249, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body248
  br label %cond.end

cond.false:                                       ; preds = %for.body248
  %171 = load i32, i32* %totlen, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 16384, %cond.true ], [ %171, %cond.false ]
  store i32 %cond, i32* %u, align 4
  %172 = load i32, i32* %u, align 4
  %conv251 = zext i32 %172 to i64
  store i64 %conv251, i64* %size.addr.i518, align 8
  store i32 208, i32* %flags.addr.i519, align 4
  %173 = load i64, i64* %size.addr.i518, align 8
  %174 = load i32, i32* %flags.addr.i519, align 4
  %call.i520 = call i8* @__kmalloc(i64 %173, i32 %174) #5
  store i8* %call.i520, i8** %buf, align 8
  %175 = load i8*, i8** %buf, align 8
  %tobool253 = icmp ne i8* %175, null
  br i1 %tobool253, label %if.end255, label %if.then254

if.then254:                                       ; preds = %cond.end
  store i32 -12, i32* %ret, align 4
  br label %error

if.end255:                                        ; preds = %cond.end
  %176 = load %struct.async*, %struct.async** %as, align 8
  %urb256 = getelementptr inbounds %struct.async, %struct.async* %176, i32 0, i32 8
  %177 = load %struct.urb*, %struct.urb** %urb256, align 8
  %sg257 = getelementptr inbounds %struct.urb, %struct.urb* %177, i32 0, i32 16
  %178 = load %struct.scatterlist*, %struct.scatterlist** %sg257, align 8
  %179 = load i32, i32* %i, align 4
  %idxprom258 = sext i32 %179 to i64
  %arrayidx259 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %178, i64 %idxprom258
  %180 = load i8*, i8** %buf, align 8
  %181 = load i32, i32* %u, align 4
  call void @sg_set_buf(%struct.scatterlist* %arrayidx259, i8* %180, i32 %181)
  %182 = load i32, i32* %is_in, align 4
  %tobool260 = icmp ne i32 %182, 0
  br i1 %tobool260, label %if.end270, label %if.then261

if.then261:                                       ; preds = %if.end255
  %183 = load i8*, i8** %buf, align 8
  %184 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer262 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %184, i32 0, i32 4
  %185 = load i8*, i8** %buffer262, align 8
  %186 = load i32, i32* %u, align 4
  %conv263 = zext i32 %186 to i64
  %call264 = call i64 @copy_from_user(i8* %183, i8* %185, i64 %conv263)
  %tobool265 = icmp ne i64 %call264, 0
  br i1 %tobool265, label %if.then266, label %if.end267

if.then266:                                       ; preds = %if.then261
  store i32 -14, i32* %ret, align 4
  br label %error

if.end267:                                        ; preds = %if.then261
  %187 = load i32, i32* %u, align 4
  %188 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer268 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %188, i32 0, i32 4
  %189 = load i8*, i8** %buffer268, align 8
  %idx.ext = zext i32 %187 to i64
  %add.ptr269 = getelementptr i8, i8* %189, i64 %idx.ext
  store i8* %add.ptr269, i8** %buffer268, align 8
  br label %if.end270

if.end270:                                        ; preds = %if.end267, %if.end255
  %190 = load i32, i32* %u, align 4
  %191 = load i32, i32* %totlen, align 4
  %sub271 = sub i32 %191, %190
  store i32 %sub271, i32* %totlen, align 4
  br label %for.inc272

for.inc272:                                       ; preds = %if.end270
  %192 = load i32, i32* %i, align 4
  %inc273 = add nsw i32 %192, 1
  store i32 %inc273, i32* %i, align 4
  br label %for.cond243

for.end274:                                       ; preds = %for.cond243
  br label %if.end313

if.else275:                                       ; preds = %if.end225
  %193 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length276 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %193, i32 0, i32 5
  %194 = load i32, i32* %buffer_length276, align 8
  %cmp277 = icmp sgt i32 %194, 0
  br i1 %cmp277, label %if.then279, label %if.end312

if.then279:                                       ; preds = %if.else275
  %195 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length280 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %195, i32 0, i32 5
  %196 = load i32, i32* %buffer_length280, align 8
  %conv281 = sext i32 %196 to i64
  store i64 %conv281, i64* %size.addr.i521, align 8
  store i32 208, i32* %flags.addr.i522, align 4
  %197 = load i64, i64* %size.addr.i521, align 8
  %198 = load i32, i32* %flags.addr.i522, align 4
  %call.i523 = call i8* @__kmalloc(i64 %197, i32 %198) #5
  %199 = load %struct.async*, %struct.async** %as, align 8
  %urb283 = getelementptr inbounds %struct.async, %struct.async* %199, i32 0, i32 8
  %200 = load %struct.urb*, %struct.urb** %urb283, align 8
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %200, i32 0, i32 14
  store i8* %call.i523, i8** %transfer_buffer, align 8
  %201 = load %struct.async*, %struct.async** %as, align 8
  %urb284 = getelementptr inbounds %struct.async, %struct.async* %201, i32 0, i32 8
  %202 = load %struct.urb*, %struct.urb** %urb284, align 8
  %transfer_buffer285 = getelementptr inbounds %struct.urb, %struct.urb* %202, i32 0, i32 14
  %203 = load i8*, i8** %transfer_buffer285, align 8
  %tobool286 = icmp ne i8* %203, null
  br i1 %tobool286, label %if.end288, label %if.then287

if.then287:                                       ; preds = %if.then279
  store i32 -12, i32* %ret, align 4
  br label %error

if.end288:                                        ; preds = %if.then279
  %204 = load i32, i32* %is_in, align 4
  %tobool289 = icmp ne i32 %204, 0
  br i1 %tobool289, label %if.else300, label %if.then290

if.then290:                                       ; preds = %if.end288
  %205 = load %struct.async*, %struct.async** %as, align 8
  %urb291 = getelementptr inbounds %struct.async, %struct.async* %205, i32 0, i32 8
  %206 = load %struct.urb*, %struct.urb** %urb291, align 8
  %transfer_buffer292 = getelementptr inbounds %struct.urb, %struct.urb* %206, i32 0, i32 14
  %207 = load i8*, i8** %transfer_buffer292, align 8
  %208 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer293 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %208, i32 0, i32 4
  %209 = load i8*, i8** %buffer293, align 8
  %210 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length294 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %210, i32 0, i32 5
  %211 = load i32, i32* %buffer_length294, align 8
  %conv295 = sext i32 %211 to i64
  %call296 = call i64 @copy_from_user(i8* %207, i8* %209, i64 %conv295)
  %tobool297 = icmp ne i64 %call296, 0
  br i1 %tobool297, label %if.then298, label %if.end299

if.then298:                                       ; preds = %if.then290
  store i32 -14, i32* %ret, align 4
  br label %error

if.end299:                                        ; preds = %if.then290
  br label %if.end311

if.else300:                                       ; preds = %if.end288
  %212 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type301 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %212, i32 0, i32 0
  %213 = load i8, i8* %type301, align 8
  %conv302 = zext i8 %213 to i32
  %cmp303 = icmp eq i32 %conv302, 0
  br i1 %cmp303, label %if.then305, label %if.end310

if.then305:                                       ; preds = %if.else300
  %214 = load %struct.async*, %struct.async** %as, align 8
  %urb306 = getelementptr inbounds %struct.async, %struct.async* %214, i32 0, i32 8
  %215 = load %struct.urb*, %struct.urb** %urb306, align 8
  %transfer_buffer307 = getelementptr inbounds %struct.urb, %struct.urb* %215, i32 0, i32 14
  %216 = load i8*, i8** %transfer_buffer307, align 8
  %217 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length308 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %217, i32 0, i32 5
  %218 = load i32, i32* %buffer_length308, align 8
  %conv309 = sext i32 %218 to i64
  call void @llvm.memset.p0i8.i64(i8* %216, i8 0, i64 %conv309, i32 1, i1 false)
  br label %if.end310

if.end310:                                        ; preds = %if.then305, %if.else300
  br label %if.end311

if.end311:                                        ; preds = %if.end310, %if.end299
  br label %if.end312

if.end312:                                        ; preds = %if.end311, %if.else275
  br label %if.end313

if.end313:                                        ; preds = %if.end312, %for.end274
  %219 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev314 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %219, i32 0, i32 1
  %220 = load %struct.usb_device*, %struct.usb_device** %dev314, align 8
  %221 = load %struct.async*, %struct.async** %as, align 8
  %urb315 = getelementptr inbounds %struct.async, %struct.async* %221, i32 0, i32 8
  %222 = load %struct.urb*, %struct.urb** %urb315, align 8
  %dev316 = getelementptr inbounds %struct.urb, %struct.urb* %222, i32 0, i32 8
  store %struct.usb_device* %220, %struct.usb_device** %dev316, align 8
  %223 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type317 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %223, i32 0, i32 0
  %224 = load i8, i8* %type317, align 8
  %conv318 = zext i8 %224 to i32
  %shl = shl i32 %conv318, 30
  %225 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev319 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %225, i32 0, i32 1
  %226 = load %struct.usb_device*, %struct.usb_device** %dev319, align 8
  %227 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint320 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %227, i32 0, i32 1
  %228 = load i8, i8* %endpoint320, align 1
  %conv321 = zext i8 %228 to i32
  %and322 = and i32 %conv321, 15
  %call323 = call i32 @__create_pipe(%struct.usb_device* %226, i32 %and322)
  %or324 = or i32 %shl, %call323
  %229 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %endpoint325 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %229, i32 0, i32 1
  %230 = load i8, i8* %endpoint325, align 1
  %conv326 = zext i8 %230 to i32
  %and327 = and i32 %conv326, 128
  %or328 = or i32 %or324, %and327
  %231 = load %struct.async*, %struct.async** %as, align 8
  %urb329 = getelementptr inbounds %struct.async, %struct.async* %231, i32 0, i32 8
  %232 = load %struct.urb*, %struct.urb** %urb329, align 8
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %232, i32 0, i32 10
  store i32 %or328, i32* %pipe, align 8
  %233 = load i32, i32* %is_in, align 4
  %tobool330 = icmp ne i32 %233, 0
  %234 = zext i1 %tobool330 to i64
  %cond331 = select i1 %tobool330, i32 512, i32 0
  store i32 %cond331, i32* %u, align 4
  %235 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags332 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %235, i32 0, i32 3
  %236 = load i32, i32* %flags332, align 8
  %and333 = and i32 %236, 2
  %tobool334 = icmp ne i32 %and333, 0
  br i1 %tobool334, label %if.then335, label %if.end337

if.then335:                                       ; preds = %if.end313
  %237 = load i32, i32* %u, align 4
  %or336 = or i32 %237, 2
  store i32 %or336, i32* %u, align 4
  br label %if.end337

if.end337:                                        ; preds = %if.then335, %if.end313
  %238 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags338 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %238, i32 0, i32 3
  %239 = load i32, i32* %flags338, align 8
  %and339 = and i32 %239, 1
  %tobool340 = icmp ne i32 %and339, 0
  br i1 %tobool340, label %if.then341, label %if.end343

if.then341:                                       ; preds = %if.end337
  %240 = load i32, i32* %u, align 4
  %or342 = or i32 %240, 1
  store i32 %or342, i32* %u, align 4
  br label %if.end343

if.end343:                                        ; preds = %if.then341, %if.end337
  %241 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags344 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %241, i32 0, i32 3
  %242 = load i32, i32* %flags344, align 8
  %and345 = and i32 %242, 32
  %tobool346 = icmp ne i32 %and345, 0
  br i1 %tobool346, label %if.then347, label %if.end349

if.then347:                                       ; preds = %if.end343
  %243 = load i32, i32* %u, align 4
  %or348 = or i32 %243, 32
  store i32 %or348, i32* %u, align 4
  br label %if.end349

if.end349:                                        ; preds = %if.then347, %if.end343
  %244 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags350 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %244, i32 0, i32 3
  %245 = load i32, i32* %flags350, align 8
  %and351 = and i32 %245, 64
  %tobool352 = icmp ne i32 %and351, 0
  br i1 %tobool352, label %if.then353, label %if.end355

if.then353:                                       ; preds = %if.end349
  %246 = load i32, i32* %u, align 4
  %or354 = or i32 %246, 64
  store i32 %or354, i32* %u, align 4
  br label %if.end355

if.end355:                                        ; preds = %if.then353, %if.end349
  %247 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags356 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %247, i32 0, i32 3
  %248 = load i32, i32* %flags356, align 8
  %and357 = and i32 %248, 128
  %tobool358 = icmp ne i32 %and357, 0
  br i1 %tobool358, label %if.then359, label %if.end361

if.then359:                                       ; preds = %if.end355
  %249 = load i32, i32* %u, align 4
  %or360 = or i32 %249, 128
  store i32 %or360, i32* %u, align 4
  br label %if.end361

if.end361:                                        ; preds = %if.then359, %if.end355
  %250 = load i32, i32* %u, align 4
  %251 = load %struct.async*, %struct.async** %as, align 8
  %urb362 = getelementptr inbounds %struct.async, %struct.async* %251, i32 0, i32 8
  %252 = load %struct.urb*, %struct.urb** %urb362, align 8
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %252, i32 0, i32 13
  store i32 %250, i32* %transfer_flags, align 4
  %253 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length363 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %253, i32 0, i32 5
  %254 = load i32, i32* %buffer_length363, align 8
  %255 = load %struct.async*, %struct.async** %as, align 8
  %urb364 = getelementptr inbounds %struct.async, %struct.async* %255, i32 0, i32 8
  %256 = load %struct.urb*, %struct.urb** %urb364, align 8
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %256, i32 0, i32 19
  store i32 %254, i32* %transfer_buffer_length, align 8
  %257 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %258 = bitcast %struct.usb_ctrlrequest* %257 to i8*
  %259 = load %struct.async*, %struct.async** %as, align 8
  %urb365 = getelementptr inbounds %struct.async, %struct.async* %259, i32 0, i32 8
  %260 = load %struct.urb*, %struct.urb** %urb365, align 8
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %260, i32 0, i32 21
  store i8* %258, i8** %setup_packet, align 8
  store %struct.usb_ctrlrequest* null, %struct.usb_ctrlrequest** %dr, align 8
  %261 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %261, i32 0, i32 7
  %262 = load i32, i32* %start_frame, align 8
  %263 = load %struct.async*, %struct.async** %as, align 8
  %urb366 = getelementptr inbounds %struct.async, %struct.async* %263, i32 0, i32 8
  %264 = load %struct.urb*, %struct.urb** %urb366, align 8
  %start_frame367 = getelementptr inbounds %struct.urb, %struct.urb* %264, i32 0, i32 23
  store i32 %262, i32* %start_frame367, align 8
  %265 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %number_of_packets368 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %265, i32 0, i32 8
  %266 = load i32, i32* %number_of_packets368, align 4
  %267 = load %struct.async*, %struct.async** %as, align 8
  %urb369 = getelementptr inbounds %struct.async, %struct.async* %267, i32 0, i32 8
  %268 = load %struct.urb*, %struct.urb** %urb369, align 8
  %number_of_packets370 = getelementptr inbounds %struct.urb, %struct.urb* %268, i32 0, i32 24
  store i32 %266, i32* %number_of_packets370, align 4
  %269 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %type371 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %269, i32 0, i32 0
  %270 = load i8, i8* %type371, align 8
  %conv372 = zext i8 %270 to i32
  %cmp373 = icmp eq i32 %conv372, 0
  br i1 %cmp373, label %if.then379, label %lor.lhs.false375

lor.lhs.false375:                                 ; preds = %if.end361
  %271 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev376 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %271, i32 0, i32 1
  %272 = load %struct.usb_device*, %struct.usb_device** %dev376, align 8
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %272, i32 0, i32 4
  %273 = load i32, i32* %speed, align 4
  %cmp377 = icmp eq i32 %273, 3
  br i1 %cmp377, label %if.then379, label %if.else394

if.then379:                                       ; preds = %lor.lhs.false375, %if.end361
  store i32 15, i32* %_min1, align 4
  %274 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc380 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %274, i32 0, i32 0
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc380, i32 0, i32 5
  %275 = load i8, i8* %bInterval, align 2
  %conv381 = zext i8 %275 to i32
  %sub382 = sub nsw i32 %conv381, 1
  store i32 %sub382, i32* %_min2, align 4
  %cmp383 = icmp eq i32* %_min1, %_min2
  %conv384 = zext i1 %cmp383 to i32
  %276 = load i32, i32* %_min1, align 4
  %277 = load i32, i32* %_min2, align 4
  %cmp386 = icmp slt i32 %276, %277
  br i1 %cmp386, label %cond.true388, label %cond.false389

cond.true388:                                     ; preds = %if.then379
  %278 = load i32, i32* %_min1, align 4
  br label %cond.end390

cond.false389:                                    ; preds = %if.then379
  %279 = load i32, i32* %_min2, align 4
  br label %cond.end390

cond.end390:                                      ; preds = %cond.false389, %cond.true388
  %cond391 = phi i32 [ %278, %cond.true388 ], [ %279, %cond.false389 ]
  store i32 %cond391, i32* %tmp385, align 4
  %280 = load i32, i32* %tmp385, align 4
  %shl392 = shl i32 1, %280
  %281 = load %struct.async*, %struct.async** %as, align 8
  %urb393 = getelementptr inbounds %struct.async, %struct.async* %281, i32 0, i32 8
  %282 = load %struct.urb*, %struct.urb** %urb393, align 8
  %interval = getelementptr inbounds %struct.urb, %struct.urb* %282, i32 0, i32 25
  store i32 %shl392, i32* %interval, align 8
  br label %if.end400

if.else394:                                       ; preds = %lor.lhs.false375
  %283 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc395 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %283, i32 0, i32 0
  %bInterval396 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc395, i32 0, i32 5
  %284 = load i8, i8* %bInterval396, align 2
  %conv397 = zext i8 %284 to i32
  %285 = load %struct.async*, %struct.async** %as, align 8
  %urb398 = getelementptr inbounds %struct.async, %struct.async* %285, i32 0, i32 8
  %286 = load %struct.urb*, %struct.urb** %urb398, align 8
  %interval399 = getelementptr inbounds %struct.urb, %struct.urb* %286, i32 0, i32 25
  store i32 %conv397, i32* %interval399, align 8
  br label %if.end400

if.end400:                                        ; preds = %if.else394, %cond.end390
  %287 = load %struct.async*, %struct.async** %as, align 8
  %288 = bitcast %struct.async* %287 to i8*
  %289 = load %struct.async*, %struct.async** %as, align 8
  %urb401 = getelementptr inbounds %struct.async, %struct.async* %289, i32 0, i32 8
  %290 = load %struct.urb*, %struct.urb** %urb401, align 8
  %context = getelementptr inbounds %struct.urb, %struct.urb* %290, i32 0, i32 27
  store i8* %288, i8** %context, align 8
  %291 = load %struct.async*, %struct.async** %as, align 8
  %urb402 = getelementptr inbounds %struct.async, %struct.async* %291, i32 0, i32 8
  %292 = load %struct.urb*, %struct.urb** %urb402, align 8
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %292, i32 0, i32 28
  store void (%struct.urb*)* @async_completed, void (%struct.urb*)** %complete, align 8
  store i32 0, i32* %u, align 4
  store i32 0, i32* %totlen, align 4
  br label %for.cond403

for.cond403:                                      ; preds = %for.inc424, %if.end400
  %293 = load i32, i32* %u, align 4
  %294 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %number_of_packets404 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %294, i32 0, i32 8
  %295 = load i32, i32* %number_of_packets404, align 4
  %cmp405 = icmp ult i32 %293, %295
  br i1 %cmp405, label %for.body407, label %for.end426

for.body407:                                      ; preds = %for.cond403
  %296 = load i32, i32* %totlen, align 4
  %297 = load %struct.async*, %struct.async** %as, align 8
  %urb408 = getelementptr inbounds %struct.async, %struct.async* %297, i32 0, i32 8
  %298 = load %struct.urb*, %struct.urb** %urb408, align 8
  %iso_frame_desc409 = getelementptr inbounds %struct.urb, %struct.urb* %298, i32 0, i32 29
  %299 = load i32, i32* %u, align 4
  %idxprom410 = zext i32 %299 to i64
  %arrayidx411 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc409, i64 0, i64 %idxprom410
  %offset = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx411, i32 0, i32 0
  store i32 %296, i32* %offset, align 8
  %300 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %301 = load i32, i32* %u, align 4
  %idxprom412 = zext i32 %301 to i64
  %arrayidx413 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %300, i64 %idxprom412
  %length414 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx413, i32 0, i32 0
  %302 = load i32, i32* %length414, align 4
  %303 = load %struct.async*, %struct.async** %as, align 8
  %urb415 = getelementptr inbounds %struct.async, %struct.async* %303, i32 0, i32 8
  %304 = load %struct.urb*, %struct.urb** %urb415, align 8
  %iso_frame_desc416 = getelementptr inbounds %struct.urb, %struct.urb* %304, i32 0, i32 29
  %305 = load i32, i32* %u, align 4
  %idxprom417 = zext i32 %305 to i64
  %arrayidx418 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc416, i64 0, i64 %idxprom417
  %length419 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx418, i32 0, i32 1
  store i32 %302, i32* %length419, align 4
  %306 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %307 = load i32, i32* %u, align 4
  %idxprom420 = zext i32 %307 to i64
  %arrayidx421 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %306, i64 %idxprom420
  %length422 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx421, i32 0, i32 0
  %308 = load i32, i32* %length422, align 4
  %309 = load i32, i32* %totlen, align 4
  %add423 = add i32 %309, %308
  store i32 %add423, i32* %totlen, align 4
  br label %for.inc424

for.inc424:                                       ; preds = %for.body407
  %310 = load i32, i32* %u, align 4
  %inc425 = add i32 %310, 1
  store i32 %inc425, i32* %u, align 4
  br label %for.cond403

for.end426:                                       ; preds = %for.cond403
  %311 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %312 = bitcast %struct.usbdevfs_iso_packet_desc* %311 to i8*
  call void @kfree(i8* %312)
  store %struct.usbdevfs_iso_packet_desc* null, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %313 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %314 = load %struct.async*, %struct.async** %as, align 8
  %ps427 = getelementptr inbounds %struct.async, %struct.async* %314, i32 0, i32 1
  store %struct.dev_state* %313, %struct.dev_state** %ps427, align 8
  %315 = load i8*, i8** %arg.addr, align 8
  %316 = load %struct.async*, %struct.async** %as, align 8
  %userurb = getelementptr inbounds %struct.async, %struct.async* %316, i32 0, i32 7
  store i8* %315, i8** %userurb, align 8
  %317 = load i32, i32* %is_in, align 4
  %tobool428 = icmp ne i32 %317, 0
  br i1 %tobool428, label %land.lhs.true429, label %if.else435

land.lhs.true429:                                 ; preds = %for.end426
  %318 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer_length430 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %318, i32 0, i32 5
  %319 = load i32, i32* %buffer_length430, align 8
  %cmp431 = icmp sgt i32 %319, 0
  br i1 %cmp431, label %if.then433, label %if.else435

if.then433:                                       ; preds = %land.lhs.true429
  %320 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %buffer434 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %320, i32 0, i32 4
  %321 = load i8*, i8** %buffer434, align 8
  %322 = load %struct.async*, %struct.async** %as, align 8
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %322, i32 0, i32 6
  store i8* %321, i8** %userbuffer, align 8
  br label %if.end437

if.else435:                                       ; preds = %land.lhs.true429, %for.end426
  %323 = load %struct.async*, %struct.async** %as, align 8
  %userbuffer436 = getelementptr inbounds %struct.async, %struct.async* %323, i32 0, i32 6
  store i8* null, i8** %userbuffer436, align 8
  br label %if.end437

if.end437:                                        ; preds = %if.else435, %if.then433
  %324 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %signr = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %324, i32 0, i32 10
  %325 = load i32, i32* %signr, align 4
  %326 = load %struct.async*, %struct.async** %as, align 8
  %signr438 = getelementptr inbounds %struct.async, %struct.async* %326, i32 0, i32 4
  store i32 %325, i32* %signr438, align 8
  %327 = load i32, i32* %ifnum, align 4
  %328 = load %struct.async*, %struct.async** %as, align 8
  %ifnum439 = getelementptr inbounds %struct.async, %struct.async* %328, i32 0, i32 5
  store i32 %327, i32* %ifnum439, align 4
  %329 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %329, %struct.task_struct** %pfo_ret__.i, align 8
  %330 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %330, %struct.task_struct** %tmp.i, align 8
  %331 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %call441 = call %struct.pid* @task_pid(%struct.task_struct* %331)
  %call442 = call %struct.pid* @get_pid(%struct.pid* %call441)
  %332 = load %struct.async*, %struct.async** %as, align 8
  %pid = getelementptr inbounds %struct.async, %struct.async* %332, i32 0, i32 2
  store %struct.pid* %call442, %struct.pid** %pid, align 8
  br label %do.body443

do.body443:                                       ; preds = %if.end437
  br label %do.end444

do.end444:                                        ; preds = %do.body443
  %333 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %333, %struct.task_struct** %pfo_ret__.i524, align 8
  %334 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i524, align 8
  store %struct.task_struct* %334, %struct.task_struct** %tmp.i525, align 8
  %335 = load %struct.task_struct*, %struct.task_struct** %tmp.i525, align 8
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %335, i32 0, i32 63
  %336 = load %struct.cred*, %struct.cred** %cred, align 8
  store %struct.cred* %336, %struct.cred** %tmp445, align 8
  %337 = load %struct.cred*, %struct.cred** %tmp445, align 8
  %call447 = call %struct.cred* @get_cred(%struct.cred* %337)
  %338 = load %struct.async*, %struct.async** %as, align 8
  %cred448 = getelementptr inbounds %struct.async, %struct.async* %338, i32 0, i32 3
  store %struct.cred* %call447, %struct.cred** %cred448, align 8
  %339 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %339, %struct.task_struct** %pfo_ret__.i526, align 8
  %340 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i526, align 8
  store %struct.task_struct* %340, %struct.task_struct** %tmp.i527, align 8
  %341 = load %struct.task_struct*, %struct.task_struct** %tmp.i527, align 8
  %342 = load %struct.async*, %struct.async** %as, align 8
  %secid = getelementptr inbounds %struct.async, %struct.async* %342, i32 0, i32 11
  call void @security_task_getsecid(%struct.task_struct* %341, i32* %secid)
  %343 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev450 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %343, i32 0, i32 1
  %344 = load %struct.usb_device*, %struct.usb_device** %dev450, align 8
  %345 = load %struct.async*, %struct.async** %as, align 8
  %userurb451 = getelementptr inbounds %struct.async, %struct.async* %345, i32 0, i32 7
  %346 = load i8*, i8** %userurb451, align 8
  %347 = load %struct.async*, %struct.async** %as, align 8
  %urb452 = getelementptr inbounds %struct.async, %struct.async* %347, i32 0, i32 8
  %348 = load %struct.urb*, %struct.urb** %urb452, align 8
  %pipe453 = getelementptr inbounds %struct.urb, %struct.urb* %348, i32 0, i32 10
  %349 = load i32, i32* %pipe453, align 8
  %350 = load %struct.async*, %struct.async** %as, align 8
  %urb454 = getelementptr inbounds %struct.async, %struct.async* %350, i32 0, i32 8
  %351 = load %struct.urb*, %struct.urb** %urb454, align 8
  %transfer_buffer_length455 = getelementptr inbounds %struct.urb, %struct.urb* %351, i32 0, i32 19
  %352 = load i32, i32* %transfer_buffer_length455, align 8
  call void @snoop_urb(%struct.usb_device* %344, i8* %346, i32 %349, i32 %352, i32 0, i32 0, i8* null, i32 0)
  %353 = load i32, i32* %is_in, align 4
  %tobool456 = icmp ne i32 %353, 0
  br i1 %tobool456, label %if.end461, label %if.then457

if.then457:                                       ; preds = %do.end444
  %354 = load %struct.async*, %struct.async** %as, align 8
  %urb458 = getelementptr inbounds %struct.async, %struct.async* %354, i32 0, i32 8
  %355 = load %struct.urb*, %struct.urb** %urb458, align 8
  %356 = load %struct.async*, %struct.async** %as, align 8
  %urb459 = getelementptr inbounds %struct.async, %struct.async* %356, i32 0, i32 8
  %357 = load %struct.urb*, %struct.urb** %urb459, align 8
  %transfer_buffer_length460 = getelementptr inbounds %struct.urb, %struct.urb* %357, i32 0, i32 19
  %358 = load i32, i32* %transfer_buffer_length460, align 8
  call void @snoop_urb_data(%struct.urb* %355, i32 %358)
  br label %if.end461

if.end461:                                        ; preds = %if.then457, %do.end444
  %359 = load %struct.async*, %struct.async** %as, align 8
  call void @async_newpending(%struct.async* %359)
  %360 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc462 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %360, i32 0, i32 0
  %call463 = call i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %desc462)
  %tobool464 = icmp ne i32 %call463, 0
  br i1 %tobool464, label %if.then465, label %if.else495

if.then465:                                       ; preds = %if.end461
  %361 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %361, i32 0, i32 3
  call void @spin_lock_irq(%struct.spinlock* %lock)
  %362 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc466 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %362, i32 0, i32 0
  %call467 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %desc466)
  %363 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc468 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %363, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc468, i32 0, i32 2
  %364 = load i8, i8* %bEndpointAddress, align 2
  %conv469 = zext i8 %364 to i32
  %and470 = and i32 %conv469, 128
  %shr = ashr i32 %and470, 3
  %or471 = or i32 %call467, %shr
  %conv472 = trunc i32 %or471 to i8
  %365 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr = getelementptr inbounds %struct.async, %struct.async* %365, i32 0, i32 12
  store i8 %conv472, i8* %bulk_addr, align 4
  %366 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %uurb.addr, align 8
  %flags473 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %366, i32 0, i32 3
  %367 = load i32, i32* %flags473, align 8
  %and474 = and i32 %367, 4
  %tobool475 = icmp ne i32 %and474, 0
  br i1 %tobool475, label %if.then476, label %if.else477

if.then476:                                       ; preds = %if.then465
  %368 = load %struct.async*, %struct.async** %as, align 8
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %368, i32 0, i32 13
  store i8 1, i8* %bulk_status, align 1
  br label %if.end482

if.else477:                                       ; preds = %if.then465
  %369 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr478 = getelementptr inbounds %struct.async, %struct.async* %369, i32 0, i32 12
  %370 = load i8, i8* %bulk_addr478, align 4
  %conv479 = zext i8 %370 to i32
  %shl480 = shl i32 1, %conv479
  %neg = xor i32 %shl480, -1
  %371 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %disabled_bulk_eps = getelementptr inbounds %struct.dev_state, %struct.dev_state* %371, i32 0, i32 13
  %372 = load i32, i32* %disabled_bulk_eps, align 4
  %and481 = and i32 %372, %neg
  store i32 %and481, i32* %disabled_bulk_eps, align 4
  br label %if.end482

if.end482:                                        ; preds = %if.else477, %if.then476
  %373 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %disabled_bulk_eps483 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %373, i32 0, i32 13
  %374 = load i32, i32* %disabled_bulk_eps483, align 4
  %375 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr484 = getelementptr inbounds %struct.async, %struct.async* %375, i32 0, i32 12
  %376 = load i8, i8* %bulk_addr484, align 4
  %conv485 = zext i8 %376 to i32
  %shl486 = shl i32 1, %conv485
  %and487 = and i32 %374, %shl486
  %tobool488 = icmp ne i32 %and487, 0
  br i1 %tobool488, label %if.then489, label %if.else490

if.then489:                                       ; preds = %if.end482
  store i32 -121, i32* %ret, align 4
  br label %if.end493

if.else490:                                       ; preds = %if.end482
  %377 = load %struct.async*, %struct.async** %as, align 8
  %urb491 = getelementptr inbounds %struct.async, %struct.async* %377, i32 0, i32 8
  %378 = load %struct.urb*, %struct.urb** %urb491, align 8
  %call492 = call i32 @usb_submit_urb(%struct.urb* %378, i32 32)
  store i32 %call492, i32* %ret, align 4
  br label %if.end493

if.end493:                                        ; preds = %if.else490, %if.then489
  %379 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock494 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %379, i32 0, i32 3
  call void @spin_unlock_irq(%struct.spinlock* %lock494)
  br label %if.end498

if.else495:                                       ; preds = %if.end461
  %380 = load %struct.async*, %struct.async** %as, align 8
  %urb496 = getelementptr inbounds %struct.async, %struct.async* %380, i32 0, i32 8
  %381 = load %struct.urb*, %struct.urb** %urb496, align 8
  %call497 = call i32 @usb_submit_urb(%struct.urb* %381, i32 208)
  store i32 %call497, i32* %ret, align 4
  br label %if.end498

if.end498:                                        ; preds = %if.else495, %if.end493
  %382 = load i32, i32* %ret, align 4
  %tobool499 = icmp ne i32 %382, 0
  br i1 %tobool499, label %if.then500, label %if.end508

if.then500:                                       ; preds = %if.end498
  %383 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev501 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %383, i32 0, i32 1
  %384 = load %struct.usb_device*, %struct.usb_device** %dev501, align 8
  %dev502 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %384, i32 0, i32 11
  %385 = load i32, i32* %ret, align 4
  %call503 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %dev502, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.48, i32 0, i32 0), i32 %385)
  %386 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev504 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %386, i32 0, i32 1
  %387 = load %struct.usb_device*, %struct.usb_device** %dev504, align 8
  %388 = load %struct.async*, %struct.async** %as, align 8
  %userurb505 = getelementptr inbounds %struct.async, %struct.async* %388, i32 0, i32 7
  %389 = load i8*, i8** %userurb505, align 8
  %390 = load %struct.async*, %struct.async** %as, align 8
  %urb506 = getelementptr inbounds %struct.async, %struct.async* %390, i32 0, i32 8
  %391 = load %struct.urb*, %struct.urb** %urb506, align 8
  %pipe507 = getelementptr inbounds %struct.urb, %struct.urb* %391, i32 0, i32 10
  %392 = load i32, i32* %pipe507, align 8
  %393 = load i32, i32* %ret, align 4
  call void @snoop_urb(%struct.usb_device* %387, i8* %389, i32 %392, i32 0, i32 %393, i32 1, i8* null, i32 0)
  %394 = load %struct.async*, %struct.async** %as, align 8
  call void @async_removepending(%struct.async* %394)
  br label %error

if.end508:                                        ; preds = %if.end498
  store i32 0, i32* %retval, align 4
  br label %return

error:                                            ; preds = %if.then500, %if.then298, %if.then287, %if.then266, %if.then254, %if.then234, %if.then224, %if.then211, %if.then206, %if.then190, %if.then176, %if.then167, %if.then76, %if.then68, %if.then61
  %395 = load %struct.usbdevfs_iso_packet_desc*, %struct.usbdevfs_iso_packet_desc** %isopkt, align 8
  %396 = bitcast %struct.usbdevfs_iso_packet_desc* %395 to i8*
  call void @kfree(i8* %396)
  %397 = load %struct.usb_ctrlrequest*, %struct.usb_ctrlrequest** %dr, align 8
  %398 = bitcast %struct.usb_ctrlrequest* %397 to i8*
  call void @kfree(i8* %398)
  %399 = load %struct.async*, %struct.async** %as, align 8
  %tobool509 = icmp ne %struct.async* %399, null
  br i1 %tobool509, label %if.then510, label %if.end511

if.then510:                                       ; preds = %error
  %400 = load %struct.async*, %struct.async** %as, align 8
  call void @free_async(%struct.async* %400)
  br label %if.end511

if.end511:                                        ; preds = %if.then510, %error
  %401 = load i32, i32* %ret, align 4
  store i32 %401, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end511, %if.end508, %sw.default, %if.then162, %if.then154, %if.then149, %if.then138, %sw.bb121, %if.then56, %if.then52, %if.then47, %if.then41, %if.then20, %if.then16, %if.then2, %if.then
  %402 = load i32, i32* %retval, align 4
  ret i32 %402
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %1 = load i8, i8* %bmAttributes, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %1 = load i8, i8* %bmAttributes, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %1 = load i8, i8* %bmAttributes, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %1 = load i8, i8* %bmAttributes, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.async* @alloc_async(i32 %numisoframes) #0 {
entry:
  %retval = alloca %struct.async*, align 8
  %numisoframes.addr = alloca i32, align 4
  %as = alloca %struct.async*, align 8
  store i32 %numisoframes, i32* %numisoframes.addr, align 4
  %call = call i8* @kzalloc(i64 88, i32 208)
  %0 = bitcast i8* %call to %struct.async*
  store %struct.async* %0, %struct.async** %as, align 8
  %1 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.async* null, %struct.async** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %numisoframes.addr, align 4
  %call1 = call %struct.urb* @usb_alloc_urb(i32 %2, i32 208)
  %3 = load %struct.async*, %struct.async** %as, align 8
  %urb = getelementptr inbounds %struct.async, %struct.async* %3, i32 0, i32 8
  store %struct.urb* %call1, %struct.urb** %urb, align 8
  %4 = load %struct.async*, %struct.async** %as, align 8
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %4, i32 0, i32 8
  %5 = load %struct.urb*, %struct.urb** %urb2, align 8
  %tobool3 = icmp ne %struct.urb* %5, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %6 = load %struct.async*, %struct.async** %as, align 8
  %7 = bitcast %struct.async* %6 to i8*
  call void @kfree(i8* %7)
  store %struct.async* null, %struct.async** %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %8 = load %struct.async*, %struct.async** %as, align 8
  store %struct.async* %8, %struct.async** %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %9 = load %struct.async*, %struct.async** %retval, align 8
  ret %struct.async* %9
}

declare void @sg_init_table(%struct.scatterlist*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @sg_set_buf(%struct.scatterlist* %sg, i8* %buf, i32 %buflen) #0 {
entry:
  %sg.addr = alloca %struct.scatterlist*, align 8
  %buf.addr = alloca i8*, align 8
  %buflen.addr = alloca i32, align 4
  store %struct.scatterlist* %sg, %struct.scatterlist** %sg.addr, align 8
  store i8* %buf, i8** %buf.addr, align 8
  store i32 %buflen, i32* %buflen.addr, align 4
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %1 = load i8*, i8** %buf.addr, align 8
  %2 = ptrtoint i8* %1 to i64
  %call = call i64 @__phys_addr_nodebug(i64 %2)
  %shr = lshr i64 %call, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %3 = load i32, i32* %buflen.addr, align 4
  %4 = load i8*, i8** %buf.addr, align 8
  %5 = ptrtoint i8* %4 to i64
  %and = and i64 %5, 4095
  %conv = trunc i64 %and to i32
  call void @sg_set_page(%struct.scatterlist* %0, %struct.page* %add.ptr, i32 %3, i32 %conv)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #3

; Function Attrs: noinline nounwind optnone uwtable
define internal void @async_completed(%struct.urb* %urb) #0 {
entry:
  %urb.addr = alloca %struct.urb*, align 8
  %as = alloca %struct.async*, align 8
  %ps = alloca %struct.dev_state*, align 8
  %sinfo = alloca %struct.siginfo, align 8
  %pid = alloca %struct.pid*, align 8
  %secid = alloca i32, align 4
  %cred = alloca %struct.cred*, align 8
  %signr = alloca i32, align 4
  store %struct.urb* %urb, %struct.urb** %urb.addr, align 8
  %0 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %context = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 27
  %1 = load i8*, i8** %context, align 8
  %2 = bitcast i8* %1 to %struct.async*
  store %struct.async* %2, %struct.async** %as, align 8
  %3 = load %struct.async*, %struct.async** %as, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %3, i32 0, i32 1
  %4 = load %struct.dev_state*, %struct.dev_state** %ps1, align 8
  store %struct.dev_state* %4, %struct.dev_state** %ps, align 8
  store %struct.pid* null, %struct.pid** %pid, align 8
  store i32 0, i32* %secid, align 4
  store %struct.cred* null, %struct.cred** %cred, align 8
  %5 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %lock)
  %6 = load %struct.async*, %struct.async** %as, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  %7 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %7, i32 0, i32 5
  call void @list_move_tail(%struct.list_head* %asynclist, %struct.list_head* %async_completed)
  %8 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %status = getelementptr inbounds %struct.urb, %struct.urb* %8, i32 0, i32 12
  %9 = load i32, i32* %status, align 8
  %10 = load %struct.async*, %struct.async** %as, align 8
  %status2 = getelementptr inbounds %struct.async, %struct.async* %10, i32 0, i32 10
  store i32 %9, i32* %status2, align 4
  %11 = load %struct.async*, %struct.async** %as, align 8
  %signr3 = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 4
  %12 = load i32, i32* %signr3, align 8
  store i32 %12, i32* %signr, align 4
  %13 = load i32, i32* %signr, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %14 = load %struct.async*, %struct.async** %as, align 8
  %signr4 = getelementptr inbounds %struct.async, %struct.async* %14, i32 0, i32 4
  %15 = load i32, i32* %signr4, align 8
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %15, i32* %si_signo, align 8
  %16 = load %struct.async*, %struct.async** %as, align 8
  %status5 = getelementptr inbounds %struct.async, %struct.async* %16, i32 0, i32 10
  %17 = load i32, i32* %status5, align 4
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 %17, i32* %si_errno, align 4
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8
  %18 = load %struct.async*, %struct.async** %as, align 8
  %userurb = getelementptr inbounds %struct.async, %struct.async* %18, i32 0, i32 7
  %19 = load i8*, i8** %userurb, align 8
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.32* %_sifields to %struct.anon.37*
  %_addr = getelementptr inbounds %struct.anon.37, %struct.anon.37* %_sigfault, i32 0, i32 0
  store i8* %19, i8** %_addr, align 8
  %20 = load %struct.async*, %struct.async** %as, align 8
  %pid6 = getelementptr inbounds %struct.async, %struct.async* %20, i32 0, i32 2
  %21 = load %struct.pid*, %struct.pid** %pid6, align 8
  %call = call %struct.pid* @get_pid(%struct.pid* %21)
  store %struct.pid* %call, %struct.pid** %pid, align 8
  %22 = load %struct.async*, %struct.async** %as, align 8
  %cred7 = getelementptr inbounds %struct.async, %struct.async* %22, i32 0, i32 3
  %23 = load %struct.cred*, %struct.cred** %cred7, align 8
  %call8 = call %struct.cred* @get_cred(%struct.cred* %23)
  store %struct.cred* %call8, %struct.cred** %cred, align 8
  %24 = load %struct.async*, %struct.async** %as, align 8
  %secid9 = getelementptr inbounds %struct.async, %struct.async* %24, i32 0, i32 11
  %25 = load i32, i32* %secid9, align 8
  store i32 %25, i32* %secid, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %26 = load i8, i8* @usbfs_snoop, align 1
  %tobool10 = trunc i8 %26 to i1
  br i1 %tobool10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %do.body
  %27 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %27, i32 0, i32 8
  %28 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %28, i32 0, i32 11
  %call13 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev12, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.50, i32 0, i32 0))
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end14
  %29 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %dev15 = getelementptr inbounds %struct.urb, %struct.urb* %29, i32 0, i32 8
  %30 = load %struct.usb_device*, %struct.usb_device** %dev15, align 8
  %31 = load %struct.async*, %struct.async** %as, align 8
  %userurb16 = getelementptr inbounds %struct.async, %struct.async* %31, i32 0, i32 7
  %32 = load i8*, i8** %userurb16, align 8
  %33 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %33, i32 0, i32 10
  %34 = load i32, i32* %pipe, align 8
  %35 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %35, i32 0, i32 20
  %36 = load i32, i32* %actual_length, align 4
  %37 = load %struct.async*, %struct.async** %as, align 8
  %status17 = getelementptr inbounds %struct.async, %struct.async* %37, i32 0, i32 10
  %38 = load i32, i32* %status17, align 4
  call void @snoop_urb(%struct.usb_device* %30, i8* %32, i32 %34, i32 %36, i32 %38, i32 1, i8* null, i32 0)
  %39 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %39, i32 0, i32 13
  %40 = load i32, i32* %transfer_flags, align 4
  %and = and i32 %40, 512
  %cmp = icmp eq i32 %and, 128
  br i1 %cmp, label %if.then18, label %if.end20

if.then18:                                        ; preds = %do.end
  %41 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %42 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %actual_length19 = getelementptr inbounds %struct.urb, %struct.urb* %42, i32 0, i32 20
  %43 = load i32, i32* %actual_length19, align 4
  call void @snoop_urb_data(%struct.urb* %41, i32 %43)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %do.end
  %44 = load %struct.async*, %struct.async** %as, align 8
  %status21 = getelementptr inbounds %struct.async, %struct.async* %44, i32 0, i32 10
  %45 = load i32, i32* %status21, align 4
  %cmp22 = icmp slt i32 %45, 0
  br i1 %cmp22, label %land.lhs.true, label %if.end35

land.lhs.true:                                    ; preds = %if.end20
  %46 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr = getelementptr inbounds %struct.async, %struct.async* %46, i32 0, i32 12
  %47 = load i8, i8* %bulk_addr, align 4
  %conv = zext i8 %47 to i32
  %tobool23 = icmp ne i32 %conv, 0
  br i1 %tobool23, label %land.lhs.true24, label %if.end35

land.lhs.true24:                                  ; preds = %land.lhs.true
  %48 = load %struct.async*, %struct.async** %as, align 8
  %status25 = getelementptr inbounds %struct.async, %struct.async* %48, i32 0, i32 10
  %49 = load i32, i32* %status25, align 4
  %cmp26 = icmp ne i32 %49, -104
  br i1 %cmp26, label %land.lhs.true28, label %if.end35

land.lhs.true28:                                  ; preds = %land.lhs.true24
  %50 = load %struct.async*, %struct.async** %as, align 8
  %status29 = getelementptr inbounds %struct.async, %struct.async* %50, i32 0, i32 10
  %51 = load i32, i32* %status29, align 4
  %cmp30 = icmp ne i32 %51, -2
  br i1 %cmp30, label %if.then32, label %if.end35

if.then32:                                        ; preds = %land.lhs.true28
  %52 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %53 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr33 = getelementptr inbounds %struct.async, %struct.async* %53, i32 0, i32 12
  %54 = load i8, i8* %bulk_addr33, align 4
  %conv34 = zext i8 %54 to i32
  call void @cancel_bulk_urbs(%struct.dev_state* %52, i32 %conv34)
  br label %if.end35

if.end35:                                         ; preds = %if.then32, %land.lhs.true28, %land.lhs.true24, %land.lhs.true, %if.end20
  %55 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %lock36 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %55, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %lock36)
  %56 = load i32, i32* %signr, align 4
  %tobool37 = icmp ne i32 %56, 0
  br i1 %tobool37, label %if.then38, label %if.end41

if.then38:                                        ; preds = %if.end35
  %si_signo39 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  %57 = load i32, i32* %si_signo39, align 8
  %58 = load %struct.pid*, %struct.pid** %pid, align 8
  %59 = load %struct.cred*, %struct.cred** %cred, align 8
  %60 = load i32, i32* %secid, align 4
  %call40 = call i32 @kill_pid_info_as_cred(i32 %57, %struct.siginfo* %sinfo, %struct.pid* %58, %struct.cred* %59, i32 %60)
  %61 = load %struct.pid*, %struct.pid** %pid, align 8
  call void @put_pid(%struct.pid* %61)
  %62 = load %struct.cred*, %struct.cred** %cred, align 8
  call void @put_cred(%struct.cred* %62)
  br label %if.end41

if.end41:                                         ; preds = %if.then38, %if.end35
  %63 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %wait = getelementptr inbounds %struct.dev_state, %struct.dev_state* %63, i32 0, i32 6
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 1, i8* null)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.pid* @get_pid(%struct.pid* %pid) #0 {
entry:
  %pid.addr = alloca %struct.pid*, align 8
  store %struct.pid* %pid, %struct.pid** %pid.addr, align 8
  %0 = load %struct.pid*, %struct.pid** %pid.addr, align 8
  %tobool = icmp ne %struct.pid* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.pid*, %struct.pid** %pid.addr, align 8
  %count = getelementptr inbounds %struct.pid, %struct.pid* %1, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.pid*, %struct.pid** %pid.addr, align 8
  ret %struct.pid* %2
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.pid* @task_pid(%struct.task_struct* %task) #0 {
entry:
  %task.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %task, %struct.task_struct** %task.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %task.addr, align 8
  %pids = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 43
  %arrayidx = getelementptr inbounds [3 x %struct.pid_link], [3 x %struct.pid_link]* %pids, i64 0, i64 0
  %pid = getelementptr inbounds %struct.pid_link, %struct.pid_link* %arrayidx, i32 0, i32 1
  %1 = load %struct.pid*, %struct.pid** %pid, align 8
  ret %struct.pid* %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.cred* @get_cred(%struct.cred* %cred) #0 {
entry:
  %cred.addr = alloca %struct.cred*, align 8
  %nonconst_cred = alloca %struct.cred*, align 8
  store %struct.cred* %cred, %struct.cred** %cred.addr, align 8
  %0 = load %struct.cred*, %struct.cred** %cred.addr, align 8
  store %struct.cred* %0, %struct.cred** %nonconst_cred, align 8
  %1 = load %struct.cred*, %struct.cred** %cred.addr, align 8
  call void @validate_creds(%struct.cred* %1)
  %2 = load %struct.cred*, %struct.cred** %nonconst_cred, align 8
  %call = call %struct.cred* @get_new_cred(%struct.cred* %2)
  ret %struct.cred* %call
}

declare void @security_task_getsecid(%struct.task_struct*, i32*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @snoop_urb_data(%struct.urb* %urb, i32 %len) #0 {
entry:
  %urb.addr = alloca %struct.urb*, align 8
  %len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %size = alloca i32, align 4
  store %struct.urb* %urb, %struct.urb** %urb.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load i8, i8* @usbfs_snoop, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  %1 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %1, i32 0, i32 18
  %2 = load i32, i32* %num_sgs, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %3 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 14
  %4 = load i8*, i8** %transfer_buffer, align 8
  %5 = load i32, i32* %len.addr, align 4
  %conv = zext i32 %5 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %4, i64 %conv, i1 zeroext true)
  br label %for.end

if.end2:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end2
  %6 = load i32, i32* %i, align 4
  %7 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %num_sgs3 = getelementptr inbounds %struct.urb, %struct.urb* %7, i32 0, i32 18
  %8 = load i32, i32* %num_sgs3, align 4
  %cmp4 = icmp slt i32 %6, %8
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %9 = load i32, i32* %len.addr, align 4
  %tobool6 = icmp ne i32 %9, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %10 = phi i1 [ false, %for.cond ], [ %tobool6, %land.rhs ]
  br i1 %10, label %for.body, label %for.end.loopexit

for.body:                                         ; preds = %land.end
  %11 = load i32, i32* %len.addr, align 4
  %cmp7 = icmp ugt i32 %11, 16384
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %12 = load i32, i32* %len.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 16384, %cond.true ], [ %12, %cond.false ]
  store i32 %cond, i32* %size, align 4
  %13 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %13, i32 0, i32 16
  %14 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %14, i64 %idxprom
  %call = call i8* @sg_virt(%struct.scatterlist* %arrayidx)
  %16 = load i32, i32* %size, align 4
  %conv9 = sext i32 %16 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %call, i64 %conv9, i1 zeroext true)
  %17 = load i32, i32* %size, align 4
  %18 = load i32, i32* %len.addr, align 4
  %sub = sub i32 %18, %17
  store i32 %sub, i32* %len.addr, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %19 = load i32, i32* %i, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end.loopexit:                                 ; preds = %land.end
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %if.then1, %if.then
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @async_newpending(%struct.async* %as) #0 {
entry:
  %as.addr = alloca %struct.async*, align 8
  %ps = alloca %struct.dev_state*, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.async* %as, %struct.async** %as.addr, align 8
  %0 = load %struct.async*, %struct.async** %as.addr, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 1
  %1 = load %struct.dev_state*, %struct.dev_state** %ps1, align 8
  store %struct.dev_state* %1, %struct.dev_state** %ps, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body2

do.body2:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %2 = load i32, i32* %tmp, align 4
  %3 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  store i64 %call3, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body2
  br label %do.end4

do.end4:                                          ; preds = %do.end
  %4 = load %struct.async*, %struct.async** %as.addr, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %4, i32 0, i32 0
  %5 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 4
  call void @list_add_tail(%struct.list_head* %asynclist, %struct.list_head* %async_pending)
  %6 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %lock5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %6, i32 0, i32 3
  %7 = load i64, i64* %flags, align 8
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock5, i64 %7)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %1 = load i8, i8* %bmAttributes, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 2
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @spin_lock_irq(%struct.spinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.spinlock*, align 8
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr, align 8
  %0 = load %struct.spinlock*, %struct.spinlock** %lock.addr, align 8
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %1 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %epd.addr = alloca %struct.usb_endpoint_descriptor*, align 8
  store %struct.usb_endpoint_descriptor* %epd, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %0 = load %struct.usb_endpoint_descriptor*, %struct.usb_endpoint_descriptor** %epd.addr, align 8
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 2
  %1 = load i8, i8* %bEndpointAddress, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

declare i32 @usb_submit_urb(%struct.urb*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @spin_unlock_irq(%struct.spinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.spinlock*, align 8
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr, align 8
  %0 = load %struct.spinlock*, %struct.spinlock** %lock.addr, align 8
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %1 to %struct.raw_spinlock*
  call void @__raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @async_removepending(%struct.async* %as) #0 {
entry:
  %as.addr = alloca %struct.async*, align 8
  %ps = alloca %struct.dev_state*, align 8
  %flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.async* %as, %struct.async** %as.addr, align 8
  %0 = load %struct.async*, %struct.async** %as.addr, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 1
  %1 = load %struct.dev_state*, %struct.dev_state** %ps1, align 8
  store %struct.dev_state* %1, %struct.dev_state** %ps, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body2

do.body2:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %2 = load i32, i32* %tmp, align 4
  %3 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  store i64 %call3, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body2
  br label %do.end4

do.end4:                                          ; preds = %do.end
  %4 = load %struct.async*, %struct.async** %as.addr, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %4, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  %5 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %lock5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 3
  %6 = load i64, i64* %flags, align 8
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock5, i64 %6)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @free_async(%struct.async* %as) #0 {
entry:
  %as.addr = alloca %struct.async*, align 8
  %i = alloca i32, align 4
  store %struct.async* %as, %struct.async** %as.addr, align 8
  %0 = load %struct.async*, %struct.async** %as.addr, align 8
  %pid = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 2
  %1 = load %struct.pid*, %struct.pid** %pid, align 8
  call void @put_pid(%struct.pid* %1)
  %2 = load %struct.async*, %struct.async** %as.addr, align 8
  %cred = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 3
  %3 = load %struct.cred*, %struct.cred** %cred, align 8
  %tobool = icmp ne %struct.cred* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.async*, %struct.async** %as.addr, align 8
  %cred1 = getelementptr inbounds %struct.async, %struct.async* %4, i32 0, i32 3
  %5 = load %struct.cred*, %struct.cred** %cred1, align 8
  call void @put_cred(%struct.cred* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %7 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb = getelementptr inbounds %struct.async, %struct.async* %7, i32 0, i32 8
  %8 = load %struct.urb*, %struct.urb** %urb, align 8
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %8, i32 0, i32 18
  %9 = load i32, i32* %num_sgs, align 4
  %cmp = icmp slt i32 %6, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %10, i32 0, i32 8
  %11 = load %struct.urb*, %struct.urb** %urb2, align 8
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %11, i32 0, i32 16
  %12 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %12, i64 %idxprom
  %call = call %struct.page* @sg_page(%struct.scatterlist* %arrayidx)
  %tobool3 = icmp ne %struct.page* %call, null
  br i1 %tobool3, label %if.then4, label %if.end10

if.then4:                                         ; preds = %for.body
  %14 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb5 = getelementptr inbounds %struct.async, %struct.async* %14, i32 0, i32 8
  %15 = load %struct.urb*, %struct.urb** %urb5, align 8
  %sg6 = getelementptr inbounds %struct.urb, %struct.urb* %15, i32 0, i32 16
  %16 = load %struct.scatterlist*, %struct.scatterlist** %sg6, align 8
  %17 = load i32, i32* %i, align 4
  %idxprom7 = sext i32 %17 to i64
  %arrayidx8 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %16, i64 %idxprom7
  %call9 = call i8* @sg_virt(%struct.scatterlist* %arrayidx8)
  call void @kfree(i8* %call9)
  br label %if.end10

if.end10:                                         ; preds = %if.then4, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end10
  %18 = load i32, i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb11 = getelementptr inbounds %struct.async, %struct.async* %19, i32 0, i32 8
  %20 = load %struct.urb*, %struct.urb** %urb11, align 8
  %sg12 = getelementptr inbounds %struct.urb, %struct.urb* %20, i32 0, i32 16
  %21 = load %struct.scatterlist*, %struct.scatterlist** %sg12, align 8
  %22 = bitcast %struct.scatterlist* %21 to i8*
  call void @kfree(i8* %22)
  %23 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb13 = getelementptr inbounds %struct.async, %struct.async* %23, i32 0, i32 8
  %24 = load %struct.urb*, %struct.urb** %urb13, align 8
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %24, i32 0, i32 14
  %25 = load i8*, i8** %transfer_buffer, align 8
  call void @kfree(i8* %25)
  %26 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb14 = getelementptr inbounds %struct.async, %struct.async* %26, i32 0, i32 8
  %27 = load %struct.urb*, %struct.urb** %urb14, align 8
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %27, i32 0, i32 21
  %28 = load i8*, i8** %setup_packet, align 8
  call void @kfree(i8* %28)
  %29 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb15 = getelementptr inbounds %struct.async, %struct.async* %29, i32 0, i32 8
  %30 = load %struct.urb*, %struct.urb** %urb15, align 8
  call void @usb_free_urb(%struct.urb* %30)
  %31 = load %struct.async*, %struct.async** %as.addr, align 8
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %31, i32 0, i32 9
  %32 = load i32, i32* %mem_usage, align 8
  call void @usbfs_decrease_memory_usage(i32 %32)
  %33 = load %struct.async*, %struct.async** %as.addr, align 8
  %34 = bitcast %struct.async* %33 to i8*
  call void @kfree(i8* %34)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #0 {
entry:
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %or = or i32 %1, 32768
  store i64 %0, i64* %size.addr.i, align 8
  store i32 %or, i32* %flags.addr.i, align 4
  %2 = load i64, i64* %size.addr.i, align 8
  %3 = load i32, i32* %flags.addr.i, align 4
  %call.i = call i8* @__kmalloc(i64 %2, i32 %3) #5
  ret i8* %call.i
}

declare %struct.urb* @usb_alloc_urb(i32, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %page, i32 %len, i32 %offset) #0 {
entry:
  %sg.addr = alloca %struct.scatterlist*, align 8
  %page.addr = alloca %struct.page*, align 8
  %len.addr = alloca i32, align 4
  %offset.addr = alloca i32, align 4
  store %struct.scatterlist* %sg, %struct.scatterlist** %sg.addr, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  store i32 %offset, i32* %offset.addr, align 4
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %1 = load %struct.page*, %struct.page** %page.addr, align 8
  call void @sg_assign_page(%struct.scatterlist* %0, %struct.page* %1)
  %2 = load i32, i32* %offset.addr, align 4
  %3 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %offset1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %3, i32 0, i32 1
  store i32 %2, i32* %offset1, align 8
  %4 = load i32, i32* %len.addr, align 4
  %5 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %length = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %5, i32 0, i32 2
  store i32 %4, i32* %length, align 4
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i64 @__phys_addr_nodebug(i64 %x) #0 {
entry:
  %x.addr = alloca i64, align 8
  %y = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8
  %0 = load i64, i64* %x.addr, align 8
  %sub = sub i64 %0, -2147483648
  store i64 %sub, i64* %y, align 8
  %1 = load i64, i64* %y, align 8
  %2 = load i64, i64* %x.addr, align 8
  %3 = load i64, i64* %y, align 8
  %cmp = icmp ugt i64 %2, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64, i64* @phys_base, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %4, %cond.true ], [ 131939247849472, %cond.false ]
  %add = add i64 %1, %cond
  store i64 %add, i64* %x.addr, align 8
  %5 = load i64, i64* %x.addr, align 8
  ret i64 %5
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page) #0 {
entry:
  %sg.addr = alloca %struct.scatterlist*, align 8
  %page.addr = alloca %struct.page*, align 8
  %page_link = alloca i64, align 8
  store %struct.scatterlist* %sg, %struct.scatterlist** %sg.addr, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %page_link1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %0, i32 0, i32 0
  %1 = load i64, i64* %page_link1, align 8
  %and = and i64 %1, 3
  store i64 %and, i64* %page_link, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %2 = load %struct.page*, %struct.page** %page.addr, align 8
  %3 = ptrtoint %struct.page* %2 to i64
  %and2 = and i64 %3, 3
  %tobool = icmp ne i64 %and2, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool4 = icmp ne i64 %conv, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body5

do.body5:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.49, i32 0, i32 0), i32 65, i64 12) #5, !srcloc !36
  br label %do.body6

do.body6:                                         ; preds = %do.cond, %do.body5
  br label %do.cond

do.cond:                                          ; preds = %do.body6
  br i1 true, label %do.body6, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end8

do.end8:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end8, %do.body
  br label %do.end10

do.end10:                                         ; preds = %if.end
  %4 = load i64, i64* %page_link, align 8
  %5 = load %struct.page*, %struct.page** %page.addr, align 8
  %6 = ptrtoint %struct.page* %5 to i64
  %or = or i64 %4, %6
  %7 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %page_link11 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %7, i32 0, i32 0
  store i64 %or, i64* %page_link11, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.spinlock*, align 8
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr, align 8
  %0 = load %struct.spinlock*, %struct.spinlock** %lock.addr, align 8
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %1 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @cancel_bulk_urbs(%struct.dev_state* %ps, i32 %bulk_addr) #0 {
entry:
  %ps.addr = alloca %struct.dev_state*, align 8
  %bulk_addr.addr = alloca i32, align 4
  %urb = alloca %struct.urb*, align 8
  %as = alloca %struct.async*, align 8
  %__mptr = alloca %struct.list_head*, align 8
  %tmp = alloca %struct.async*, align 8
  %__mptr12 = alloca %struct.list_head*, align 8
  %tmp15 = alloca %struct.async*, align 8
  %__mptr17 = alloca %struct.list_head*, align 8
  %tmp20 = alloca %struct.async*, align 8
  %__mptr39 = alloca %struct.list_head*, align 8
  %tmp42 = alloca %struct.async*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i32 %bulk_addr, i32* %bulk_addr.addr, align 4
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %1, %struct.list_head** %__mptr, align 8
  %2 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.async*
  store %struct.async* %4, %struct.async** %tmp, align 8
  %5 = load %struct.async*, %struct.async** %tmp, align 8
  store %struct.async* %5, %struct.async** %as, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load %struct.async*, %struct.async** %as, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  %7 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_pending1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %7, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr2 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 12
  %9 = load i8, i8* %bulk_addr2, align 4
  %conv = zext i8 %9 to i32
  %10 = load i32, i32* %bulk_addr.addr, align 4
  %cmp3 = icmp eq i32 %conv, %10
  br i1 %cmp3, label %if.then, label %if.end11

if.then:                                          ; preds = %for.body
  %11 = load %struct.async*, %struct.async** %as, align 8
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 13
  %12 = load i8, i8* %bulk_status, align 1
  %conv5 = zext i8 %12 to i32
  %cmp6 = icmp ne i32 %conv5, 1
  br i1 %cmp6, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  br label %rescan.preheader

if.end:                                           ; preds = %if.then
  %13 = load %struct.async*, %struct.async** %as, align 8
  %bulk_status9 = getelementptr inbounds %struct.async, %struct.async* %13, i32 0, i32 13
  store i8 2, i8* %bulk_status9, align 1
  %14 = load %struct.async*, %struct.async** %as, align 8
  %bulk_addr10 = getelementptr inbounds %struct.async, %struct.async* %14, i32 0, i32 12
  store i8 0, i8* %bulk_addr10, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end11
  %15 = load %struct.async*, %struct.async** %as, align 8
  %asynclist13 = getelementptr inbounds %struct.async, %struct.async* %15, i32 0, i32 0
  %next14 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist13, i32 0, i32 0
  %16 = load %struct.list_head*, %struct.list_head** %next14, align 8
  store %struct.list_head* %16, %struct.list_head** %__mptr12, align 8
  %17 = load %struct.list_head*, %struct.list_head** %__mptr12, align 8
  %18 = bitcast %struct.list_head* %17 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %18, i64 0
  %19 = bitcast i8* %add.ptr16 to %struct.async*
  store %struct.async* %19, %struct.async** %tmp15, align 8
  %20 = load %struct.async*, %struct.async** %tmp15, align 8
  store %struct.async* %20, %struct.async** %as, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %21 = load i32, i32* %bulk_addr.addr, align 4
  %shl = shl i32 1, %21
  %22 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %disabled_bulk_eps = getelementptr inbounds %struct.dev_state, %struct.dev_state* %22, i32 0, i32 13
  %23 = load i32, i32* %disabled_bulk_eps, align 4
  %or = or i32 %23, %shl
  store i32 %or, i32* %disabled_bulk_eps, align 4
  br label %rescan.preheader

rescan.preheader:                                 ; preds = %if.then8, %for.end
  br label %rescan

rescan:                                           ; preds = %rescan.preheader, %if.then32
  %24 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_pending18 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %24, i32 0, i32 4
  %next19 = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending18, i32 0, i32 0
  %25 = load %struct.list_head*, %struct.list_head** %next19, align 8
  store %struct.list_head* %25, %struct.list_head** %__mptr17, align 8
  %26 = load %struct.list_head*, %struct.list_head** %__mptr17, align 8
  %27 = bitcast %struct.list_head* %26 to i8*
  %add.ptr21 = getelementptr inbounds i8, i8* %27, i64 0
  %28 = bitcast i8* %add.ptr21 to %struct.async*
  store %struct.async* %28, %struct.async** %tmp20, align 8
  %29 = load %struct.async*, %struct.async** %tmp20, align 8
  store %struct.async* %29, %struct.async** %as, align 8
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc38, %rescan
  %30 = load %struct.async*, %struct.async** %as, align 8
  %asynclist23 = getelementptr inbounds %struct.async, %struct.async* %30, i32 0, i32 0
  %31 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_pending24 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %31, i32 0, i32 4
  %cmp25 = icmp ne %struct.list_head* %asynclist23, %async_pending24
  br i1 %cmp25, label %for.body27, label %for.end44

for.body27:                                       ; preds = %for.cond22
  %32 = load %struct.async*, %struct.async** %as, align 8
  %bulk_status28 = getelementptr inbounds %struct.async, %struct.async* %32, i32 0, i32 13
  %33 = load i8, i8* %bulk_status28, align 1
  %conv29 = zext i8 %33 to i32
  %cmp30 = icmp eq i32 %conv29, 2
  br i1 %cmp30, label %if.then32, label %if.end37

if.then32:                                        ; preds = %for.body27
  %34 = load %struct.async*, %struct.async** %as, align 8
  %bulk_status33 = getelementptr inbounds %struct.async, %struct.async* %34, i32 0, i32 13
  store i8 0, i8* %bulk_status33, align 1
  %35 = load %struct.async*, %struct.async** %as, align 8
  %urb34 = getelementptr inbounds %struct.async, %struct.async* %35, i32 0, i32 8
  %36 = load %struct.urb*, %struct.urb** %urb34, align 8
  store %struct.urb* %36, %struct.urb** %urb, align 8
  %37 = load %struct.urb*, %struct.urb** %urb, align 8
  %call = call %struct.urb* @usb_get_urb(%struct.urb* %37)
  %38 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %38, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %lock)
  %39 = load %struct.urb*, %struct.urb** %urb, align 8
  %call35 = call i32 @usb_unlink_urb(%struct.urb* %39)
  %40 = load %struct.urb*, %struct.urb** %urb, align 8
  call void @usb_free_urb(%struct.urb* %40)
  %41 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock36 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %41, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %lock36)
  br label %rescan

if.end37:                                         ; preds = %for.body27
  br label %for.inc38

for.inc38:                                        ; preds = %if.end37
  %42 = load %struct.async*, %struct.async** %as, align 8
  %asynclist40 = getelementptr inbounds %struct.async, %struct.async* %42, i32 0, i32 0
  %next41 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist40, i32 0, i32 0
  %43 = load %struct.list_head*, %struct.list_head** %next41, align 8
  store %struct.list_head* %43, %struct.list_head** %__mptr39, align 8
  %44 = load %struct.list_head*, %struct.list_head** %__mptr39, align 8
  %45 = bitcast %struct.list_head* %44 to i8*
  %add.ptr43 = getelementptr inbounds i8, i8* %45, i64 0
  %46 = bitcast i8* %add.ptr43 to %struct.async*
  store %struct.async* %46, %struct.async** %tmp42, align 8
  %47 = load %struct.async*, %struct.async** %tmp42, align 8
  store %struct.async* %47, %struct.async** %as, align 8
  br label %for.cond22

for.end44:                                        ; preds = %for.cond22
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.spinlock*, align 8
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr, align 8
  %0 = load %struct.spinlock*, %struct.spinlock** %lock.addr, align 8
  %1 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %1 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

declare i32 @kill_pid_info_as_cred(i32, %struct.siginfo*, %struct.pid*, %struct.cred*, i32) #1

declare void @put_pid(%struct.pid*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @put_cred(%struct.cred* %_cred) #0 {
entry:
  %_cred.addr = alloca %struct.cred*, align 8
  %cred = alloca %struct.cred*, align 8
  store %struct.cred* %_cred, %struct.cred** %_cred.addr, align 8
  %0 = load %struct.cred*, %struct.cred** %_cred.addr, align 8
  store %struct.cred* %0, %struct.cred** %cred, align 8
  %1 = load %struct.cred*, %struct.cred** %cred, align 8
  call void @validate_creds(%struct.cred* %1)
  %2 = load %struct.cred*, %struct.cred** %cred, align 8
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %2, i32 0, i32 0
  %call = call i32 @atomic_dec_and_test(%struct.atomic_t* %usage)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.cred*, %struct.cred** %cred, align 8
  call void @__put_cred(%struct.cred* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

declare void @_raw_spin_lock(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare i32 @usb_unlink_urb(%struct.urb*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @__raw_spin_unlock(%struct.raw_spinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.raw_spinlock*, align 8
  store %struct.raw_spinlock* %lock, %struct.raw_spinlock** %lock.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.raw_spinlock*, %struct.raw_spinlock** %lock.addr, align 8
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %0)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !37
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @do_raw_spin_unlock(%struct.raw_spinlock* %lock) #0 {
entry:
  %lock.addr.i.i = alloca %struct.arch_spinlock*, align 8
  %__ret.i.i = alloca i8, align 1
  %tmp.i.i = alloca i8, align 1
  %lock.addr.i = alloca %struct.arch_spinlock*, align 8
  %lock.addr = alloca %struct.raw_spinlock*, align 8
  store %struct.raw_spinlock* %lock, %struct.raw_spinlock** %lock.addr, align 8
  %0 = load %struct.raw_spinlock*, %struct.raw_spinlock** %lock.addr, align 8
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %0, i32 0, i32 0
  store %struct.arch_spinlock* %raw_lock, %struct.arch_spinlock** %lock.addr.i, align 8
  %1 = load %struct.arch_spinlock*, %struct.arch_spinlock** %lock.addr.i, align 8
  store %struct.arch_spinlock* %1, %struct.arch_spinlock** %lock.addr.i.i, align 8
  store i8 1, i8* %__ret.i.i, align 1
  %2 = load %struct.arch_spinlock*, %struct.arch_spinlock** %lock.addr.i.i, align 8
  %3 = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %2, i32 0, i32 0
  %tickets.i.i = bitcast %union.anon.1* %3 to %struct.__raw_tickets*
  %head.i.i = getelementptr inbounds %struct.__raw_tickets, %struct.__raw_tickets* %tickets.i.i, i32 0, i32 0
  call void asm sideeffect "addb ${1:b}, $0\0A", "=*m,qi,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i8* %head.i.i, i32 1, i8* %head.i.i) #5, !srcloc !38
  %4 = load i8, i8* %__ret.i.i, align 1
  store i8 %4, i8* %tmp.i.i, align 1
  %5 = load i8, i8* %tmp.i.i, align 1
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @validate_creds(%struct.cred* %cred) #0 {
entry:
  %cred.addr = alloca %struct.cred*, align 8
  store %struct.cred* %cred, %struct.cred** %cred.addr, align 8
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @atomic_dec_and_test(%struct.atomic_t* %v) #0 {
entry:
  %v.addr = alloca %struct.atomic_t*, align 8
  %c = alloca i8, align 1
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  %0 = load %struct.atomic_t*, %struct.atomic_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %0, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #5, !srcloc !39
  %1 = load i8, i8* %c, align 1
  %conv = zext i8 %1 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare void @__put_cred(%struct.cred*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @atomic_inc(%struct.atomic_t* %v) #0 {
entry:
  %v.addr = alloca %struct.atomic_t*, align 8
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  %0 = load %struct.atomic_t*, %struct.atomic_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %0, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #5, !srcloc !40
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.cred* @get_new_cred(%struct.cred* %cred) #0 {
entry:
  %cred.addr = alloca %struct.cred*, align 8
  store %struct.cred* %cred, %struct.cred** %cred.addr, align 8
  %0 = load %struct.cred*, %struct.cred** %cred.addr, align 8
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %0, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %usage)
  %1 = load %struct.cred*, %struct.cred** %cred.addr, align 8
  ret %struct.cred* %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @sg_virt(%struct.scatterlist* %sg) #0 {
entry:
  %page.addr.i = alloca %struct.page*, align 8
  %sg.addr = alloca %struct.scatterlist*, align 8
  store %struct.scatterlist* %sg, %struct.scatterlist** %sg.addr, align 8
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %call = call %struct.page* @sg_page(%struct.scatterlist* %0)
  store %struct.page* %call, %struct.page** %page.addr.i, align 8
  %1 = load %struct.page*, %struct.page** %page.addr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %1 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %2 = inttoptr i64 %add.i to i8*
  %3 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %offset = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %3, i32 0, i32 1
  %4 = load i32, i32* %offset, align 8
  %idx.ext = zext i32 %4 to i64
  %add.ptr = getelementptr i8, i8* %2, i64 %idx.ext
  ret i8* %add.ptr
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.page* @sg_page(%struct.scatterlist* %sg) #0 {
entry:
  %sg.addr = alloca %struct.scatterlist*, align 8
  store %struct.scatterlist* %sg, %struct.scatterlist** %sg.addr, align 8
  %0 = load %struct.scatterlist*, %struct.scatterlist** %sg.addr, align 8
  %page_link = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %0, i32 0, i32 0
  %1 = load i64, i64* %page_link, align 8
  %and = and i64 %1, -4
  %2 = inttoptr i64 %and to %struct.page*
  ret %struct.page* %2
}

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: noinline nounwind optnone uwtable
define internal void @__raw_spin_unlock_irq(%struct.raw_spinlock* %lock) #0 {
entry:
  %lock.addr = alloca %struct.raw_spinlock*, align 8
  store %struct.raw_spinlock* %lock, %struct.raw_spinlock** %lock.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.raw_spinlock*, %struct.raw_spinlock** %lock.addr, align 8
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %0)
  br label %do.body1

do.body1:                                         ; preds = %do.end
  br label %do.body2

do.body2:                                         ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.body2
  call void @arch_local_irq_enable()
  br label %do.end4

do.end4:                                          ; preds = %do.end3
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !41
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @arch_local_irq_enable() #0 {
entry:
  call void @native_irq_enable()
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @native_irq_enable() #0 {
entry:
  call void asm sideeffect "sti", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !42
  ret void
}

declare i8* @compat_alloc_user_space(i64) #1

declare i64 @copy_in_user(i8*, i8*, i32) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i8* @compat_ptr(i32 %uptr) #0 {
entry:
  %uptr.addr = alloca i32, align 4
  store i32 %uptr, i32* %uptr.addr, align 4
  %0 = load i32, i32* %uptr.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = inttoptr i64 %conv to i8*
  ret i8* %1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @get_urb32(%struct.usbdevfs_urb* %kurb, %struct.usbdevfs_urb32* %uurb) #0 {
entry:
  %retval = alloca i32, align 4
  %kurb.addr = alloca %struct.usbdevfs_urb*, align 8
  %uurb.addr = alloca %struct.usbdevfs_urb32*, align 8
  %uptr = alloca i32, align 4
  %flag = alloca i64, align 8
  %roksum = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__gu_err = alloca i32, align 4
  %__gu_val = alloca i64, align 8
  %tmp7 = alloca i32, align 4
  %__gu_err10 = alloca i32, align 4
  %__gu_val11 = alloca i64, align 8
  %tmp18 = alloca i32, align 4
  %__gu_err21 = alloca i32, align 4
  %__gu_val22 = alloca i64, align 8
  %tmp29 = alloca i32, align 4
  %__gu_err32 = alloca i32, align 4
  %__gu_val33 = alloca i64, align 8
  %tmp40 = alloca i32, align 4
  %__gu_err43 = alloca i32, align 4
  %__gu_val44 = alloca i64, align 8
  %tmp51 = alloca i32, align 4
  %__gu_err54 = alloca i32, align 4
  %__gu_val55 = alloca i64, align 8
  %tmp62 = alloca i32, align 4
  %__gu_err65 = alloca i32, align 4
  %__gu_val66 = alloca i64, align 8
  %tmp73 = alloca i32, align 4
  %__gu_err76 = alloca i32, align 4
  %__gu_val77 = alloca i64, align 8
  %tmp84 = alloca i32, align 4
  %__gu_err87 = alloca i32, align 4
  %__gu_val88 = alloca i64, align 8
  %tmp95 = alloca i32, align 4
  %__gu_err98 = alloca i32, align 4
  %__gu_val99 = alloca i64, align 8
  %tmp106 = alloca i32, align 4
  %__gu_err108 = alloca i32, align 4
  %__gu_val109 = alloca i64, align 8
  %tmp115 = alloca i32, align 4
  %__gu_err121 = alloca i32, align 4
  %__gu_val122 = alloca i64, align 8
  %tmp128 = alloca i32, align 4
  store %struct.usbdevfs_urb* %kurb, %struct.usbdevfs_urb** %kurb.addr, align 8
  store %struct.usbdevfs_urb32* %uurb, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %0 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %call = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 6
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %1 = load i64, i64* %seg, align 8
  %2 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(%struct.usbdevfs_urb32* %0, i64 44, i64 %1) #7, !srcloc !43
  %asmresult = extractvalue { i64, i64 } %2, 0
  %asmresult1 = extractvalue { i64, i64 } %2, 1
  store i64 %asmresult, i64* %flag, align 8
  store i64 %asmresult1, i64* %roksum, align 8
  %3 = load i64, i64* %flag, align 8
  store i64 %3, i64* %tmp, align 8
  %4 = load i64, i64* %tmp, align 8
  %cmp = icmp eq i64 %4, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %__gu_err, align 4
  %5 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %type = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %5, i32 0, i32 0
  %6 = bitcast i8* %type to %struct.__large_struct*
  %7 = load i32, i32* %__gu_err, align 4
  %8 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movb $2,${1:b}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %6, i32 -14, i32 %7) #5, !srcloc !44
  %asmresult3 = extractvalue { i32, i64 } %8, 0
  %asmresult4 = extractvalue { i32, i64 } %8, 1
  store i32 %asmresult3, i32* %__gu_err, align 4
  store i64 %asmresult4, i64* %__gu_val, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %9 = load i64, i64* %__gu_val, align 8
  %conv5 = trunc i64 %9 to i8
  %10 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %type6 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %10, i32 0, i32 0
  store i8 %conv5, i8* %type6, align 8
  %11 = load i32, i32* %__gu_err, align 4
  store i32 %11, i32* %tmp7, align 4
  %12 = load i32, i32* %tmp7, align 4
  %tobool8 = icmp ne i32 %12, 0
  br i1 %tobool8, label %if.then, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %do.end
  br label %do.body12

do.body12:                                        ; preds = %lor.lhs.false9
  store i32 0, i32* %__gu_err10, align 4
  %13 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %13, i32 0, i32 1
  %14 = bitcast i8* %endpoint to %struct.__large_struct*
  %15 = load i32, i32* %__gu_err10, align 4
  %16 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movb $2,${1:b}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %14, i32 -14, i32 %15) #5, !srcloc !45
  %asmresult13 = extractvalue { i32, i64 } %16, 0
  %asmresult14 = extractvalue { i32, i64 } %16, 1
  store i32 %asmresult13, i32* %__gu_err10, align 4
  store i64 %asmresult14, i64* %__gu_val11, align 8
  br label %do.end15

do.end15:                                         ; preds = %do.body12
  %17 = load i64, i64* %__gu_val11, align 8
  %conv16 = trunc i64 %17 to i8
  %18 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %endpoint17 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %18, i32 0, i32 1
  store i8 %conv16, i8* %endpoint17, align 1
  %19 = load i32, i32* %__gu_err10, align 4
  store i32 %19, i32* %tmp18, align 4
  %20 = load i32, i32* %tmp18, align 4
  %tobool19 = icmp ne i32 %20, 0
  br i1 %tobool19, label %if.then, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %do.end15
  br label %do.body23

do.body23:                                        ; preds = %lor.lhs.false20
  store i32 0, i32* %__gu_err21, align 4
  %21 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %status = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %21, i32 0, i32 2
  %22 = bitcast i32* %status to %struct.__large_struct*
  %23 = load i32, i32* %__gu_err21, align 4
  %24 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %22, i32 -14, i32 %23) #5, !srcloc !46
  %asmresult24 = extractvalue { i32, i64 } %24, 0
  %asmresult25 = extractvalue { i32, i64 } %24, 1
  store i32 %asmresult24, i32* %__gu_err21, align 4
  store i64 %asmresult25, i64* %__gu_val22, align 8
  br label %do.end26

do.end26:                                         ; preds = %do.body23
  %25 = load i64, i64* %__gu_val22, align 8
  %conv27 = trunc i64 %25 to i32
  %26 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %status28 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %26, i32 0, i32 2
  store i32 %conv27, i32* %status28, align 4
  %27 = load i32, i32* %__gu_err21, align 4
  store i32 %27, i32* %tmp29, align 4
  %28 = load i32, i32* %tmp29, align 4
  %tobool30 = icmp ne i32 %28, 0
  br i1 %tobool30, label %if.then, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %do.end26
  br label %do.body34

do.body34:                                        ; preds = %lor.lhs.false31
  store i32 0, i32* %__gu_err32, align 4
  %29 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %flags = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %29, i32 0, i32 3
  %30 = bitcast i32* %flags to %struct.__large_struct*
  %31 = load i32, i32* %__gu_err32, align 4
  %32 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %30, i32 -14, i32 %31) #5, !srcloc !47
  %asmresult35 = extractvalue { i32, i64 } %32, 0
  %asmresult36 = extractvalue { i32, i64 } %32, 1
  store i32 %asmresult35, i32* %__gu_err32, align 4
  store i64 %asmresult36, i64* %__gu_val33, align 8
  br label %do.end37

do.end37:                                         ; preds = %do.body34
  %33 = load i64, i64* %__gu_val33, align 8
  %conv38 = trunc i64 %33 to i32
  %34 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %flags39 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %34, i32 0, i32 3
  store i32 %conv38, i32* %flags39, align 8
  %35 = load i32, i32* %__gu_err32, align 4
  store i32 %35, i32* %tmp40, align 4
  %36 = load i32, i32* %tmp40, align 4
  %tobool41 = icmp ne i32 %36, 0
  br i1 %tobool41, label %if.then, label %lor.lhs.false42

lor.lhs.false42:                                  ; preds = %do.end37
  br label %do.body45

do.body45:                                        ; preds = %lor.lhs.false42
  store i32 0, i32* %__gu_err43, align 4
  %37 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %37, i32 0, i32 5
  %38 = bitcast i32* %buffer_length to %struct.__large_struct*
  %39 = load i32, i32* %__gu_err43, align 4
  %40 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %38, i32 -14, i32 %39) #5, !srcloc !48
  %asmresult46 = extractvalue { i32, i64 } %40, 0
  %asmresult47 = extractvalue { i32, i64 } %40, 1
  store i32 %asmresult46, i32* %__gu_err43, align 4
  store i64 %asmresult47, i64* %__gu_val44, align 8
  br label %do.end48

do.end48:                                         ; preds = %do.body45
  %41 = load i64, i64* %__gu_val44, align 8
  %conv49 = trunc i64 %41 to i32
  %42 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %buffer_length50 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %42, i32 0, i32 5
  store i32 %conv49, i32* %buffer_length50, align 8
  %43 = load i32, i32* %__gu_err43, align 4
  store i32 %43, i32* %tmp51, align 4
  %44 = load i32, i32* %tmp51, align 4
  %tobool52 = icmp ne i32 %44, 0
  br i1 %tobool52, label %if.then, label %lor.lhs.false53

lor.lhs.false53:                                  ; preds = %do.end48
  br label %do.body56

do.body56:                                        ; preds = %lor.lhs.false53
  store i32 0, i32* %__gu_err54, align 4
  %45 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %actual_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %45, i32 0, i32 6
  %46 = bitcast i32* %actual_length to %struct.__large_struct*
  %47 = load i32, i32* %__gu_err54, align 4
  %48 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %46, i32 -14, i32 %47) #5, !srcloc !49
  %asmresult57 = extractvalue { i32, i64 } %48, 0
  %asmresult58 = extractvalue { i32, i64 } %48, 1
  store i32 %asmresult57, i32* %__gu_err54, align 4
  store i64 %asmresult58, i64* %__gu_val55, align 8
  br label %do.end59

do.end59:                                         ; preds = %do.body56
  %49 = load i64, i64* %__gu_val55, align 8
  %conv60 = trunc i64 %49 to i32
  %50 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %actual_length61 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %50, i32 0, i32 6
  store i32 %conv60, i32* %actual_length61, align 4
  %51 = load i32, i32* %__gu_err54, align 4
  store i32 %51, i32* %tmp62, align 4
  %52 = load i32, i32* %tmp62, align 4
  %tobool63 = icmp ne i32 %52, 0
  br i1 %tobool63, label %if.then, label %lor.lhs.false64

lor.lhs.false64:                                  ; preds = %do.end59
  br label %do.body67

do.body67:                                        ; preds = %lor.lhs.false64
  store i32 0, i32* %__gu_err65, align 4
  %53 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %53, i32 0, i32 7
  %54 = bitcast i32* %start_frame to %struct.__large_struct*
  %55 = load i32, i32* %__gu_err65, align 4
  %56 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %54, i32 -14, i32 %55) #5, !srcloc !50
  %asmresult68 = extractvalue { i32, i64 } %56, 0
  %asmresult69 = extractvalue { i32, i64 } %56, 1
  store i32 %asmresult68, i32* %__gu_err65, align 4
  store i64 %asmresult69, i64* %__gu_val66, align 8
  br label %do.end70

do.end70:                                         ; preds = %do.body67
  %57 = load i64, i64* %__gu_val66, align 8
  %conv71 = trunc i64 %57 to i32
  %58 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %start_frame72 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %58, i32 0, i32 7
  store i32 %conv71, i32* %start_frame72, align 8
  %59 = load i32, i32* %__gu_err65, align 4
  store i32 %59, i32* %tmp73, align 4
  %60 = load i32, i32* %tmp73, align 4
  %tobool74 = icmp ne i32 %60, 0
  br i1 %tobool74, label %if.then, label %lor.lhs.false75

lor.lhs.false75:                                  ; preds = %do.end70
  br label %do.body78

do.body78:                                        ; preds = %lor.lhs.false75
  store i32 0, i32* %__gu_err76, align 4
  %61 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %number_of_packets = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %61, i32 0, i32 8
  %62 = bitcast i32* %number_of_packets to %struct.__large_struct*
  %63 = load i32, i32* %__gu_err76, align 4
  %64 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %62, i32 -14, i32 %63) #5, !srcloc !51
  %asmresult79 = extractvalue { i32, i64 } %64, 0
  %asmresult80 = extractvalue { i32, i64 } %64, 1
  store i32 %asmresult79, i32* %__gu_err76, align 4
  store i64 %asmresult80, i64* %__gu_val77, align 8
  br label %do.end81

do.end81:                                         ; preds = %do.body78
  %65 = load i64, i64* %__gu_val77, align 8
  %conv82 = trunc i64 %65 to i32
  %66 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %number_of_packets83 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %66, i32 0, i32 8
  store i32 %conv82, i32* %number_of_packets83, align 4
  %67 = load i32, i32* %__gu_err76, align 4
  store i32 %67, i32* %tmp84, align 4
  %68 = load i32, i32* %tmp84, align 4
  %tobool85 = icmp ne i32 %68, 0
  br i1 %tobool85, label %if.then, label %lor.lhs.false86

lor.lhs.false86:                                  ; preds = %do.end81
  br label %do.body89

do.body89:                                        ; preds = %lor.lhs.false86
  store i32 0, i32* %__gu_err87, align 4
  %69 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %error_count = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %69, i32 0, i32 9
  %70 = bitcast i32* %error_count to %struct.__large_struct*
  %71 = load i32, i32* %__gu_err87, align 4
  %72 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %70, i32 -14, i32 %71) #5, !srcloc !52
  %asmresult90 = extractvalue { i32, i64 } %72, 0
  %asmresult91 = extractvalue { i32, i64 } %72, 1
  store i32 %asmresult90, i32* %__gu_err87, align 4
  store i64 %asmresult91, i64* %__gu_val88, align 8
  br label %do.end92

do.end92:                                         ; preds = %do.body89
  %73 = load i64, i64* %__gu_val88, align 8
  %conv93 = trunc i64 %73 to i32
  %74 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %error_count94 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %74, i32 0, i32 9
  store i32 %conv93, i32* %error_count94, align 8
  %75 = load i32, i32* %__gu_err87, align 4
  store i32 %75, i32* %tmp95, align 4
  %76 = load i32, i32* %tmp95, align 4
  %tobool96 = icmp ne i32 %76, 0
  br i1 %tobool96, label %if.then, label %lor.lhs.false97

lor.lhs.false97:                                  ; preds = %do.end92
  br label %do.body100

do.body100:                                       ; preds = %lor.lhs.false97
  store i32 0, i32* %__gu_err98, align 4
  %77 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %signr = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %77, i32 0, i32 10
  %78 = bitcast i32* %signr to %struct.__large_struct*
  %79 = load i32, i32* %__gu_err98, align 4
  %80 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %78, i32 -14, i32 %79) #5, !srcloc !53
  %asmresult101 = extractvalue { i32, i64 } %80, 0
  %asmresult102 = extractvalue { i32, i64 } %80, 1
  store i32 %asmresult101, i32* %__gu_err98, align 4
  store i64 %asmresult102, i64* %__gu_val99, align 8
  br label %do.end103

do.end103:                                        ; preds = %do.body100
  %81 = load i64, i64* %__gu_val99, align 8
  %conv104 = trunc i64 %81 to i32
  %82 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %signr105 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %82, i32 0, i32 10
  store i32 %conv104, i32* %signr105, align 4
  %83 = load i32, i32* %__gu_err98, align 4
  store i32 %83, i32* %tmp106, align 4
  %84 = load i32, i32* %tmp106, align 4
  %tobool107 = icmp ne i32 %84, 0
  br i1 %tobool107, label %if.then, label %if.end

if.then:                                          ; preds = %do.end103, %do.end92, %do.end81, %do.end70, %do.end59, %do.end48, %do.end37, %do.end26, %do.end15, %do.end, %entry
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end103
  br label %do.body110

do.body110:                                       ; preds = %if.end
  store i32 0, i32* %__gu_err108, align 4
  %85 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %buffer = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %85, i32 0, i32 4
  %86 = bitcast i32* %buffer to %struct.__large_struct*
  %87 = load i32, i32* %__gu_err108, align 4
  %88 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %86, i32 -14, i32 %87) #5, !srcloc !54
  %asmresult111 = extractvalue { i32, i64 } %88, 0
  %asmresult112 = extractvalue { i32, i64 } %88, 1
  store i32 %asmresult111, i32* %__gu_err108, align 4
  store i64 %asmresult112, i64* %__gu_val109, align 8
  br label %do.end113

do.end113:                                        ; preds = %do.body110
  %89 = load i64, i64* %__gu_val109, align 8
  %conv114 = trunc i64 %89 to i32
  store i32 %conv114, i32* %uptr, align 4
  %90 = load i32, i32* %__gu_err108, align 4
  store i32 %90, i32* %tmp115, align 4
  %91 = load i32, i32* %tmp115, align 4
  %tobool116 = icmp ne i32 %91, 0
  br i1 %tobool116, label %if.then117, label %if.end118

if.then117:                                       ; preds = %do.end113
  store i32 -14, i32* %retval, align 4
  br label %return

if.end118:                                        ; preds = %do.end113
  %92 = load i32, i32* %uptr, align 4
  %call119 = call i8* @compat_ptr(i32 %92)
  %93 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %buffer120 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %93, i32 0, i32 4
  store i8* %call119, i8** %buffer120, align 8
  br label %do.body123

do.body123:                                       ; preds = %if.end118
  store i32 0, i32* %__gu_err121, align 4
  %94 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %uurb.addr, align 8
  %usercontext = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %94, i32 0, i32 11
  %95 = bitcast i32* %usercontext to %struct.__large_struct*
  %96 = load i32, i32* %__gu_err121, align 4
  %97 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %95, i32 -14, i32 %96) #5, !srcloc !55
  %asmresult124 = extractvalue { i32, i64 } %97, 0
  %asmresult125 = extractvalue { i32, i64 } %97, 1
  store i32 %asmresult124, i32* %__gu_err121, align 4
  store i64 %asmresult125, i64* %__gu_val122, align 8
  br label %do.end126

do.end126:                                        ; preds = %do.body123
  %98 = load i64, i64* %__gu_val122, align 8
  %conv127 = trunc i64 %98 to i32
  store i32 %conv127, i32* %uptr, align 4
  %99 = load i32, i32* %__gu_err121, align 4
  store i32 %99, i32* %tmp128, align 4
  %100 = load i32, i32* %tmp128, align 4
  %tobool129 = icmp ne i32 %100, 0
  br i1 %tobool129, label %if.then130, label %if.end131

if.then130:                                       ; preds = %do.end126
  store i32 -14, i32* %retval, align 4
  br label %return

if.end131:                                        ; preds = %do.end126
  %101 = load i32, i32* %uptr, align 4
  %call132 = call i8* @compat_ptr(i32 %101)
  %102 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %kurb.addr, align 8
  %usercontext133 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %102, i32 0, i32 11
  store i8* %call132, i8** %usercontext133, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end131, %if.then130, %if.then117, %if.then
  %103 = load i32, i32* %retval, align 4
  ret i32 %103
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.async* @reap_as(%struct.dev_state* %ps) #0 {
entry:
  %pfo_ret__.i21 = alloca %struct.task_struct*, align 8
  %tmp.i22 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i19 = alloca %struct.task_struct*, align 8
  %tmp.i20 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i17 = alloca %struct.task_struct*, align 8
  %tmp.i18 = alloca %struct.task_struct*, align 8
  %pfo_ret__.i = alloca %struct.task_struct*, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %ps.addr = alloca %struct.dev_state*, align 8
  %wait = alloca %struct.__wait_queue, align 8
  %as = alloca %struct.async*, align 8
  %dev = alloca %struct.usb_device*, align 8
  %__ret = alloca i64, align 8
  %tmp = alloca i64, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 1
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %0, %struct.task_struct** %pfo_ret__.i, align 8
  %1 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i, align 8
  store %struct.task_struct* %1, %struct.task_struct** %tmp.i, align 8
  %2 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  %3 = bitcast %struct.task_struct* %2 to i8*
  store i8* %3, i8** %private, align 8
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  store %struct.list_head* null, %struct.list_head** %next, align 8
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  store %struct.list_head* null, %struct.list_head** %prev, align 8
  store %struct.async* null, %struct.async** %as, align 8
  %4 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %4, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8
  store %struct.usb_device* %5, %struct.usb_device** %dev, align 8
  %6 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %wait2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %6, i32 0, i32 6
  call void @add_wait_queue(%struct.__wait_queue_head* %wait2, %struct.__wait_queue* %wait)
  br label %for.cond

for.cond:                                         ; preds = %if.end9, %entry
  br label %do.body

do.body:                                          ; preds = %for.cond
  %7 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %7, %struct.task_struct** %pfo_ret__.i17, align 8
  %8 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i17, align 8
  store %struct.task_struct* %8, %struct.task_struct** %tmp.i18, align 8
  %9 = load %struct.task_struct*, %struct.task_struct** %tmp.i18, align 8
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %9, i32 0, i32 0
  store volatile i64 1, i64* %state, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %10 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %call4 = call %struct.async* @async_getcompleted(%struct.dev_state* %10)
  store %struct.async* %call4, %struct.async** %as, align 8
  %11 = load %struct.async*, %struct.async** %as, align 8
  %tobool = icmp ne %struct.async* %11, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  br label %for.end

if.end:                                           ; preds = %do.end
  %12 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %12, %struct.task_struct** %pfo_ret__.i19, align 8
  %13 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i19, align 8
  store %struct.task_struct* %13, %struct.task_struct** %tmp.i20, align 8
  %14 = load %struct.task_struct*, %struct.task_struct** %tmp.i20, align 8
  %call6 = call i32 @signal_pending(%struct.task_struct* %14)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  br label %for.end

if.end9:                                          ; preds = %if.end
  %15 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev10)
  call void @schedule()
  %16 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %dev11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %16, i32 0, i32 11
  call void @device_lock(%struct.device* %dev11)
  br label %for.cond

for.end:                                          ; preds = %if.then8, %if.then
  %17 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %wait12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %17, i32 0, i32 6
  call void @remove_wait_queue(%struct.__wait_queue_head* %wait12, %struct.__wait_queue* %wait)
  br label %do.body13

do.body13:                                        ; preds = %for.end
  store volatile i64 0, i64* %__ret, align 8
  %18 = load volatile i64, i64* %__ret, align 8
  %19 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #6, !srcloc !3
  store %struct.task_struct* %19, %struct.task_struct** %pfo_ret__.i21, align 8
  %20 = load %struct.task_struct*, %struct.task_struct** %pfo_ret__.i21, align 8
  store %struct.task_struct* %20, %struct.task_struct** %tmp.i22, align 8
  %21 = load %struct.task_struct*, %struct.task_struct** %tmp.i22, align 8
  %state15 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %21, i32 0, i32 0
  %22 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state15, i64 %18, i64* %state15) #5, !srcloc !56
  store volatile i64 %22, i64* %__ret, align 8
  %23 = load volatile i64, i64* %__ret, align 8
  store i64 %23, i64* %tmp, align 8
  %24 = load i64, i64* %tmp, align 8
  br label %do.end16

do.end16:                                         ; preds = %do.body13
  %25 = load %struct.async*, %struct.async** %as, align 8
  ret %struct.async* %25
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @processcompl_compat(%struct.async* %as, i8** %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %as.addr = alloca %struct.async*, align 8
  %arg.addr = alloca i8**, align 8
  %urb = alloca %struct.urb*, align 8
  %userurb = alloca %struct.usbdevfs_urb32*, align 8
  %addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__ret_pu13 = alloca i32, align 4
  %__pu_val14 = alloca i32, align 4
  %tmp17 = alloca i32, align 4
  %__ret_pu21 = alloca i32, align 4
  %__pu_val22 = alloca i32, align 4
  %tmp24 = alloca i32, align 4
  %__ret_pu31 = alloca i32, align 4
  %__pu_val32 = alloca i32, align 4
  %tmp38 = alloca i32, align 4
  %__ret_pu42 = alloca i32, align 4
  %__pu_val43 = alloca i32, align 4
  %tmp52 = alloca i32, align 4
  %__ret_pu57 = alloca i32, align 4
  %__pu_val58 = alloca i32, align 4
  %tmp60 = alloca i32, align 4
  store %struct.async* %as, %struct.async** %as.addr, align 8
  store i8** %arg, i8*** %arg.addr, align 8
  %0 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %1 = load %struct.urb*, %struct.urb** %urb1, align 8
  store %struct.urb* %1, %struct.urb** %urb, align 8
  %2 = load %struct.async*, %struct.async** %as.addr, align 8
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 7
  %3 = load i8*, i8** %userurb2, align 8
  %4 = bitcast i8* %3 to %struct.usbdevfs_urb32*
  store %struct.usbdevfs_urb32* %4, %struct.usbdevfs_urb32** %userurb, align 8
  %5 = load %struct.async*, %struct.async** %as.addr, align 8
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 7
  %6 = load i8*, i8** %userurb3, align 8
  store i8* %6, i8** %addr, align 8
  %7 = load %struct.async*, %struct.async** %as.addr, align 8
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %7, i32 0, i32 6
  %8 = load i8*, i8** %userbuffer, align 8
  %tobool = icmp ne i8* %8, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %9 = load %struct.urb*, %struct.urb** %urb, align 8
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %9, i32 0, i32 20
  %10 = load i32, i32* %actual_length, align 4
  %tobool4 = icmp ne i32 %10, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %11 = load %struct.async*, %struct.async** %as.addr, align 8
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 6
  %12 = load i8*, i8** %userbuffer5, align 8
  %13 = load %struct.urb*, %struct.urb** %urb, align 8
  %call = call i32 @copy_urb_data_to_user(i8* %12, %struct.urb* %13)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end, %land.lhs.true, %entry
  call void @might_fault()
  %14 = load %struct.async*, %struct.async** %as.addr, align 8
  %status = getelementptr inbounds %struct.async, %struct.async* %14, i32 0, i32 10
  %15 = load i32, i32* %status, align 4
  store i32 %15, i32* %__pu_val, align 4
  %16 = load i32, i32* %__pu_val, align 4
  %17 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %userurb, align 8
  %status9 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %17, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %16, i32* %status9) #5, !srcloc !57
  store i32 %18, i32* %__ret_pu, align 4
  %19 = load i32, i32* %__ret_pu, align 4
  store i32 %19, i32* %tmp, align 4
  %20 = load i32, i32* %tmp, align 4
  %tobool10 = icmp ne i32 %20, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end8
  call void @might_fault()
  %21 = load %struct.urb*, %struct.urb** %urb, align 8
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %21, i32 0, i32 20
  %22 = load i32, i32* %actual_length15, align 4
  store i32 %22, i32* %__pu_val14, align 4
  %23 = load i32, i32* %__pu_val14, align 4
  %24 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %userurb, align 8
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %24, i32 0, i32 6
  %25 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %23, i32* %actual_length16) #5, !srcloc !58
  store i32 %25, i32* %__ret_pu13, align 4
  %26 = load i32, i32* %__ret_pu13, align 4
  store i32 %26, i32* %tmp17, align 4
  %27 = load i32, i32* %tmp17, align 4
  %tobool18 = icmp ne i32 %27, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end12
  store i32 -14, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.end12
  call void @might_fault()
  %28 = load %struct.urb*, %struct.urb** %urb, align 8
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %28, i32 0, i32 26
  %29 = load i32, i32* %error_count, align 4
  store i32 %29, i32* %__pu_val22, align 4
  %30 = load i32, i32* %__pu_val22, align 4
  %31 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %userurb, align 8
  %error_count23 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %31, i32 0, i32 9
  %32 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %30, i32* %error_count23) #5, !srcloc !59
  store i32 %32, i32* %__ret_pu21, align 4
  %33 = load i32, i32* %__ret_pu21, align 4
  store i32 %33, i32* %tmp24, align 4
  %34 = load i32, i32* %tmp24, align 4
  %tobool25 = icmp ne i32 %34, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end20
  %35 = load %struct.urb*, %struct.urb** %urb, align 8
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %35, i32 0, i32 9
  %36 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %36, i32 0, i32 0
  %call28 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end56

if.then30:                                        ; preds = %if.end27
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then30
  %37 = load i32, i32* %i, align 4
  %38 = load %struct.urb*, %struct.urb** %urb, align 8
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %38, i32 0, i32 24
  %39 = load i32, i32* %number_of_packets, align 4
  %cmp = icmp ult i32 %37, %39
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %40 = load %struct.urb*, %struct.urb** %urb, align 8
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %40, i32 0, i32 29
  %41 = load i32, i32* %i, align 4
  %idxprom = zext i32 %41 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length33 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx, i32 0, i32 2
  %42 = load i32, i32* %actual_length33, align 8
  store i32 %42, i32* %__pu_val32, align 4
  %43 = load i32, i32* %__pu_val32, align 4
  %44 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %userurb, align 8
  %iso_frame_desc34 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %44, i32 0, i32 12
  %45 = load i32, i32* %i, align 4
  %idxprom35 = zext i32 %45 to i64
  %arrayidx36 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc34, i64 0, i64 %idxprom35
  %actual_length37 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx36, i32 0, i32 1
  %46 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %43, i32* %actual_length37) #5, !srcloc !60
  store i32 %46, i32* %__ret_pu31, align 4
  %47 = load i32, i32* %__ret_pu31, align 4
  store i32 %47, i32* %tmp38, align 4
  %48 = load i32, i32* %tmp38, align 4
  %tobool39 = icmp ne i32 %48, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %for.body
  store i32 -14, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %for.body
  call void @might_fault()
  %49 = load %struct.urb*, %struct.urb** %urb, align 8
  %iso_frame_desc44 = getelementptr inbounds %struct.urb, %struct.urb* %49, i32 0, i32 29
  %50 = load i32, i32* %i, align 4
  %idxprom45 = zext i32 %50 to i64
  %arrayidx46 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc44, i64 0, i64 %idxprom45
  %status47 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx46, i32 0, i32 3
  %51 = load i32, i32* %status47, align 4
  store i32 %51, i32* %__pu_val43, align 4
  %52 = load i32, i32* %__pu_val43, align 4
  %53 = load %struct.usbdevfs_urb32*, %struct.usbdevfs_urb32** %userurb, align 8
  %iso_frame_desc48 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %53, i32 0, i32 12
  %54 = load i32, i32* %i, align 4
  %idxprom49 = zext i32 %54 to i64
  %arrayidx50 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc48, i64 0, i64 %idxprom49
  %status51 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx50, i32 0, i32 2
  %55 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %52, i32* %status51) #5, !srcloc !61
  store i32 %55, i32* %__ret_pu42, align 4
  %56 = load i32, i32* %__ret_pu42, align 4
  store i32 %56, i32* %tmp52, align 4
  %57 = load i32, i32* %tmp52, align 4
  %tobool53 = icmp ne i32 %57, 0
  br i1 %tobool53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.end41
  store i32 -14, i32* %retval, align 4
  br label %return

if.end55:                                         ; preds = %if.end41
  br label %for.inc

for.inc:                                          ; preds = %if.end55
  %58 = load i32, i32* %i, align 4
  %inc = add i32 %58, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end56

if.end56:                                         ; preds = %for.end, %if.end27
  call void @might_fault()
  %59 = load i8*, i8** %addr, align 8
  %call59 = call i32 @ptr_to_compat(i8* %59)
  store i32 %call59, i32* %__pu_val58, align 4
  %60 = load i32, i32* %__pu_val58, align 4
  %61 = load i8**, i8*** %arg.addr, align 8
  %62 = bitcast i8** %61 to i32*
  %63 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %60, i32* %62) #5, !srcloc !62
  store i32 %63, i32* %__ret_pu57, align 4
  %64 = load i32, i32* %__ret_pu57, align 4
  store i32 %64, i32* %tmp60, align 4
  %65 = load i32, i32* %tmp60, align 4
  %tobool61 = icmp ne i32 %65, 0
  br i1 %tobool61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end56
  store i32 -14, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %if.end56
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end63, %if.then62, %if.then54, %if.then40, %if.then26, %if.then19, %if.then11, %if.then7
  %66 = load i32, i32* %retval, align 4
  ret i32 %66
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #0 {
entry:
  %p.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %p, %struct.task_struct** %p.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %p.addr, align 8
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %0, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %conv2 = trunc i64 %conv to i32
  ret i32 %conv2
}

declare i32 @default_wake_function(%struct.__wait_queue*, i32, i32, i8*) #1

declare void @add_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.async* @async_getcompleted(%struct.dev_state* %ps) #0 {
entry:
  %ps.addr = alloca %struct.dev_state*, align 8
  %flags = alloca i64, align 8
  %as = alloca %struct.async*, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__mptr = alloca %struct.list_head*, align 8
  %tmp6 = alloca %struct.async*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store %struct.async* null, %struct.async** %as, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.body1

do.body1:                                         ; preds = %do.body
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %0 = load i32, i32* %tmp, align 4
  %1 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  store i64 %call2, i64* %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body1
  br label %do.end3

do.end3:                                          ; preds = %do.end
  %2 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 5
  %call4 = call i32 @list_empty(%struct.list_head* %async_completed)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end3
  %3 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_completed5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 5
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_completed5, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %4, %struct.list_head** %__mptr, align 8
  %5 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 0
  %7 = bitcast i8* %add.ptr to %struct.async*
  store %struct.async* %7, %struct.async** %tmp6, align 8
  %8 = load %struct.async*, %struct.async** %tmp6, align 8
  store %struct.async* %8, %struct.async** %as, align 8
  %9 = load %struct.async*, %struct.async** %as, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  br label %if.end

if.end:                                           ; preds = %if.then, %do.end3
  %10 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %lock7 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %10, i32 0, i32 3
  %11 = load i64, i64* %flags, align 8
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock7, i64 %11)
  %12 = load %struct.async*, %struct.async** %as, align 8
  ret %struct.async* %12
}

declare void @schedule() #1

declare void @remove_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @copy_urb_data_to_user(i8* %userbuffer, %struct.urb* %urb) #0 {
entry:
  %dst.addr.i15 = alloca i8*, align 8
  %src.addr.i16 = alloca i8*, align 8
  %size.addr.i17 = alloca i32, align 4
  %dst.addr.i = alloca i8*, align 8
  %src.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %userbuffer.addr = alloca i8*, align 8
  %urb.addr = alloca %struct.urb*, align 8
  %i = alloca i32, align 4
  %len = alloca i32, align 4
  %size = alloca i32, align 4
  store i8* %userbuffer, i8** %userbuffer.addr, align 8
  store %struct.urb* %urb, %struct.urb** %urb.addr, align 8
  %0 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 24
  %1 = load i32, i32* %number_of_packets, align 4
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %2, i32 0, i32 19
  %3 = load i32, i32* %transfer_buffer_length, align 8
  store i32 %3, i32* %len, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4
  store i32 %5, i32* %len, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %6, i32 0, i32 18
  %7 = load i32, i32* %num_sgs, align 4
  %cmp1 = icmp eq i32 %7, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %8 = load i8*, i8** %userbuffer.addr, align 8
  %9 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %9, i32 0, i32 14
  %10 = load i8*, i8** %transfer_buffer, align 8
  %11 = load i32, i32* %len, align 4
  store i8* %8, i8** %dst.addr.i, align 8
  store i8* %10, i8** %src.addr.i, align 8
  store i32 %11, i32* %size.addr.i, align 4
  call void @might_fault() #5
  %12 = load i8*, i8** %dst.addr.i, align 8
  %13 = load i8*, i8** %src.addr.i, align 8
  %14 = load i32, i32* %size.addr.i, align 4
  %call.i = call i64 @_copy_to_user(i8* %12, i8* %13, i32 %14) #5
  %conv.i = trunc i64 %call.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.then2
  store i32 -14, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.then2
  store i32 0, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %15 = load i32, i32* %i, align 4
  %16 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %num_sgs6 = getelementptr inbounds %struct.urb, %struct.urb* %16, i32 0, i32 18
  %17 = load i32, i32* %num_sgs6, align 4
  %cmp7 = icmp ult i32 %15, %17
  br i1 %cmp7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %18 = load i32, i32* %len, align 4
  %tobool8 = icmp ne i32 %18, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %19 = phi i1 [ false, %for.cond ], [ %tobool8, %land.rhs ]
  br i1 %19, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %20 = load i32, i32* %len, align 4
  %cmp9 = icmp ugt i32 %20, 16384
  br i1 %cmp9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %21 = load i32, i32* %len, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 16384, %cond.true ], [ %21, %cond.false ]
  store i32 %cond, i32* %size, align 4
  %22 = load i8*, i8** %userbuffer.addr, align 8
  %23 = load %struct.urb*, %struct.urb** %urb.addr, align 8
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %23, i32 0, i32 16
  %24 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8
  %25 = load i32, i32* %i, align 4
  %idxprom = zext i32 %25 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %24, i64 %idxprom
  %call10 = call i8* @sg_virt(%struct.scatterlist* %arrayidx)
  %26 = load i32, i32* %size, align 4
  store i8* %22, i8** %dst.addr.i15, align 8
  store i8* %call10, i8** %src.addr.i16, align 8
  store i32 %26, i32* %size.addr.i17, align 4
  call void @might_fault() #5
  %27 = load i8*, i8** %dst.addr.i15, align 8
  %28 = load i8*, i8** %src.addr.i16, align 8
  %29 = load i32, i32* %size.addr.i17, align 4
  %call.i18 = call i64 @_copy_to_user(i8* %27, i8* %28, i32 %29) #5
  %conv.i19 = trunc i64 %call.i18 to i32
  %tobool12 = icmp ne i32 %conv.i19, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %cond.end
  store i32 -14, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %cond.end
  %30 = load i32, i32* %size, align 4
  %31 = load i8*, i8** %userbuffer.addr, align 8
  %idx.ext = zext i32 %30 to i64
  %add.ptr = getelementptr inbounds i8, i8* %31, i64 %idx.ext
  store i8* %add.ptr, i8** %userbuffer.addr, align 8
  %32 = load i32, i32* %size, align 4
  %33 = load i32, i32* %len, align 4
  %sub = sub i32 %33, %32
  store i32 %sub, i32* %len, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %34 = load i32, i32* %i, align 4
  %inc = add i32 %34, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then13, %if.end4, %if.then3
  %35 = load i32, i32* %retval, align 4
  ret i32 %35
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #0 {
entry:
  %tsk.addr = alloca %struct.task_struct*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.task_struct* %tsk, %struct.task_struct** %tsk.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load %struct.task_struct*, %struct.task_struct** %tsk.addr, align 8
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 1
  %1 = load i8*, i8** %stack, align 8
  %2 = bitcast i8* %1 to %struct.thread_info*
  %3 = load i32, i32* %flag.addr, align 4
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* %2, i32 %3)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #0 {
entry:
  %ti.addr = alloca %struct.thread_info*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.thread_info* %ti, %struct.thread_info** %ti.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load i32, i32* %flag.addr, align 4
  %1 = load %struct.thread_info*, %struct.thread_info** %ti.addr, align 8
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %1, i32 0, i32 2
  %2 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit(i32 %0, i64* %2)
  ret i32 %call
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @proc_ioctl(%struct.dev_state* %ps, %struct.usbdevfs_ioctl* %ctl) #0 {
entry:
  %dst.addr.i = alloca i8*, align 8
  %src.addr.i = alloca i8*, align 8
  %size.addr.i95 = alloca i32, align 4
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %ctl.addr = alloca %struct.usbdevfs_ioctl*, align 8
  %size = alloca i32, align 4
  %buf = alloca i8*, align 8
  %retval1 = alloca i32, align 4
  %intf = alloca %struct.usb_interface*, align 8
  %driver = alloca %struct.usb_driver*, align 8
  %__mptr = alloca %struct.device_driver*, align 8
  %tmp = alloca %struct.usb_driver*, align 8
  %__mptr55 = alloca %struct.device_driver*, align 8
  %tmp58 = alloca %struct.usb_driver*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store %struct.usbdevfs_ioctl* %ctl, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  store i8* null, i8** %buf, align 8
  store i32 0, i32* %retval1, align 4
  store %struct.usb_interface* null, %struct.usb_interface** %intf, align 8
  store %struct.usb_driver* null, %struct.usb_driver** %driver, align 8
  %0 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ioctl_code = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %0, i32 0, i32 1
  %1 = load i32, i32* %ioctl_code, align 4
  %shr = ashr i32 %1, 16
  %and = and i32 %shr, 16383
  store i32 %and, i32* %size, align 4
  %cmp = icmp sgt i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end17

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %size, align 4
  %conv = sext i32 %2 to i64
  store i64 %conv, i64* %size.addr.i, align 8
  store i32 208, i32* %flags.addr.i, align 4
  %3 = load i64, i64* %size.addr.i, align 8
  %4 = load i32, i32* %flags.addr.i, align 4
  %call.i = call i8* @__kmalloc(i64 %3, i32 %4) #5
  store i8* %call.i, i8** %buf, align 8
  %cmp2 = icmp eq i8* %call.i, null
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %5 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ioctl_code5 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %5, i32 0, i32 1
  %6 = load i32, i32* %ioctl_code5, align 4
  %shr6 = ashr i32 %6, 30
  %and7 = and i32 %shr6, 3
  %and8 = and i32 %and7, 1
  %tobool = icmp ne i32 %and8, 0
  br i1 %tobool, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end
  %7 = load i8*, i8** %buf, align 8
  %8 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %data = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %8, i32 0, i32 2
  %9 = load i8*, i8** %data, align 8
  %10 = load i32, i32* %size, align 4
  %conv10 = sext i32 %10 to i64
  %call11 = call i64 @copy_from_user(i8* %7, i8* %9, i64 %conv10)
  %tobool12 = icmp ne i64 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.then9
  %11 = load i8*, i8** %buf, align 8
  call void @kfree(i8* %11)
  store i32 -14, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.then9
  br label %if.end16

if.else:                                          ; preds = %if.end
  %12 = load i8*, i8** %buf, align 8
  %13 = load i32, i32* %size, align 4
  %conv15 = sext i32 %13 to i64
  call void @llvm.memset.p0i8.i64(i8* %12, i8 0, i64 %conv15, i32 1, i1 false)
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.end14
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %entry
  %14 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %call18 = call i32 @connected(%struct.dev_state* %14)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end17
  %15 = load i8*, i8** %buf, align 8
  call void @kfree(i8* %15)
  store i32 -19, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  %16 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %16, i32 0, i32 1
  %17 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 3
  %18 = load i32, i32* %state, align 8
  %cmp22 = icmp ne i32 %18, 7
  br i1 %cmp22, label %if.then24, label %if.else25

if.then24:                                        ; preds = %if.end21
  store i32 -113, i32* %retval1, align 4
  br label %if.end76

if.else25:                                        ; preds = %if.end21
  %19 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev26 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %19, i32 0, i32 1
  %20 = load %struct.usb_device*, %struct.usb_device** %dev26, align 8
  %21 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ifno = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %21, i32 0, i32 0
  %22 = load i32, i32* %ifno, align 8
  %call27 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %20, i32 %22)
  store %struct.usb_interface* %call27, %struct.usb_interface** %intf, align 8
  %tobool28 = icmp ne %struct.usb_interface* %call27, null
  br i1 %tobool28, label %if.else30, label %if.then29

if.then29:                                        ; preds = %if.else25
  store i32 -22, i32* %retval1, align 4
  br label %if.end75

if.else30:                                        ; preds = %if.else25
  %23 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ioctl_code31 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %23, i32 0, i32 1
  %24 = load i32, i32* %ioctl_code31, align 4
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.else30
  %Pivot = icmp slt i32 %24, 21783
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %24, 21783
  br i1 %SwitchLeaf2, label %sw.bb42, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %24, 21782
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %25 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev32 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %25, i32 0, i32 7
  %driver33 = getelementptr inbounds %struct.device, %struct.device* %dev32, i32 0, i32 7
  %26 = load %struct.device_driver*, %struct.device_driver** %driver33, align 8
  %tobool34 = icmp ne %struct.device_driver* %26, null
  br i1 %tobool34, label %if.then35, label %if.else40

if.then35:                                        ; preds = %sw.bb
  %27 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev36 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %27, i32 0, i32 7
  %driver37 = getelementptr inbounds %struct.device, %struct.device* %dev36, i32 0, i32 7
  %28 = load %struct.device_driver*, %struct.device_driver** %driver37, align 8
  store %struct.device_driver* %28, %struct.device_driver** %__mptr, align 8
  %29 = load %struct.device_driver*, %struct.device_driver** %__mptr, align 8
  %30 = bitcast %struct.device_driver* %29 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %30, i64 -104
  %31 = bitcast i8* %add.ptr to %struct.usb_driver*
  store %struct.usb_driver* %31, %struct.usb_driver** %tmp, align 8
  %32 = load %struct.usb_driver*, %struct.usb_driver** %tmp, align 8
  store %struct.usb_driver* %32, %struct.usb_driver** %driver, align 8
  %33 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev38 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %33, i32 0, i32 7
  %call39 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %dev38, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.51, i32 0, i32 0))
  %34 = load %struct.usb_driver*, %struct.usb_driver** %driver, align 8
  %35 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  call void @usb_driver_release_interface(%struct.usb_driver* %34, %struct.usb_interface* %35)
  br label %if.end41

if.else40:                                        ; preds = %sw.bb
  store i32 -61, i32* %retval1, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.else40, %if.then35
  br label %sw.epilog

sw.bb42:                                          ; preds = %LeafBlock1
  %36 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev43 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %36, i32 0, i32 7
  %driver44 = getelementptr inbounds %struct.device, %struct.device* %dev43, i32 0, i32 7
  %37 = load %struct.device_driver*, %struct.device_driver** %driver44, align 8
  %tobool45 = icmp ne %struct.device_driver* %37, null
  br i1 %tobool45, label %if.else49, label %if.then46

if.then46:                                        ; preds = %sw.bb42
  %38 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev47 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %38, i32 0, i32 7
  %call48 = call i32 @device_attach(%struct.device* %dev47)
  store i32 %call48, i32* %retval1, align 4
  br label %if.end50

if.else49:                                        ; preds = %sw.bb42
  store i32 -16, i32* %retval1, align 4
  br label %if.end50

if.end50:                                         ; preds = %if.else49, %if.then46
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %39 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev51 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %39, i32 0, i32 7
  %driver52 = getelementptr inbounds %struct.device, %struct.device* %dev51, i32 0, i32 7
  %40 = load %struct.device_driver*, %struct.device_driver** %driver52, align 8
  %tobool53 = icmp ne %struct.device_driver* %40, null
  br i1 %tobool53, label %if.then54, label %if.end60

if.then54:                                        ; preds = %sw.default
  %41 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %dev56 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %41, i32 0, i32 7
  %driver57 = getelementptr inbounds %struct.device, %struct.device* %dev56, i32 0, i32 7
  %42 = load %struct.device_driver*, %struct.device_driver** %driver57, align 8
  store %struct.device_driver* %42, %struct.device_driver** %__mptr55, align 8
  %43 = load %struct.device_driver*, %struct.device_driver** %__mptr55, align 8
  %44 = bitcast %struct.device_driver* %43 to i8*
  %add.ptr59 = getelementptr inbounds i8, i8* %44, i64 -104
  %45 = bitcast i8* %add.ptr59 to %struct.usb_driver*
  store %struct.usb_driver* %45, %struct.usb_driver** %tmp58, align 8
  %46 = load %struct.usb_driver*, %struct.usb_driver** %tmp58, align 8
  store %struct.usb_driver* %46, %struct.usb_driver** %driver, align 8
  br label %if.end60

if.end60:                                         ; preds = %if.then54, %sw.default
  %47 = load %struct.usb_driver*, %struct.usb_driver** %driver, align 8
  %cmp61 = icmp eq %struct.usb_driver* %47, null
  br i1 %cmp61, label %if.then65, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end60
  %48 = load %struct.usb_driver*, %struct.usb_driver** %driver, align 8
  %unlocked_ioctl = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %48, i32 0, i32 3
  %49 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl, align 8
  %cmp63 = icmp eq i32 (%struct.usb_interface*, i32, i8*)* %49, null
  br i1 %cmp63, label %if.then65, label %if.else66

if.then65:                                        ; preds = %lor.lhs.false, %if.end60
  store i32 -25, i32* %retval1, align 4
  br label %if.end74

if.else66:                                        ; preds = %lor.lhs.false
  %50 = load %struct.usb_driver*, %struct.usb_driver** %driver, align 8
  %unlocked_ioctl67 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %50, i32 0, i32 3
  %51 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl67, align 8
  %52 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %53 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ioctl_code68 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %53, i32 0, i32 1
  %54 = load i32, i32* %ioctl_code68, align 4
  %55 = load i8*, i8** %buf, align 8
  %call69 = call i32 %51(%struct.usb_interface* %52, i32 %54, i8* %55)
  store i32 %call69, i32* %retval1, align 4
  %56 = load i32, i32* %retval1, align 4
  %cmp70 = icmp eq i32 %56, -515
  br i1 %cmp70, label %if.then72, label %if.end73

if.then72:                                        ; preds = %if.else66
  store i32 -25, i32* %retval1, align 4
  br label %if.end73

if.end73:                                         ; preds = %if.then72, %if.else66
  br label %if.end74

if.end74:                                         ; preds = %if.end73, %if.then65
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end74, %if.end50, %if.end41
  br label %if.end75

if.end75:                                         ; preds = %sw.epilog, %if.then29
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.then24
  %57 = load i32, i32* %retval1, align 4
  %cmp77 = icmp sge i32 %57, 0
  br i1 %cmp77, label %land.lhs.true, label %if.end94

land.lhs.true:                                    ; preds = %if.end76
  %58 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %ioctl_code79 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %58, i32 0, i32 1
  %59 = load i32, i32* %ioctl_code79, align 4
  %shr80 = ashr i32 %59, 30
  %and81 = and i32 %shr80, 3
  %and82 = and i32 %and81, 2
  %cmp83 = icmp ne i32 %and82, 0
  br i1 %cmp83, label %land.lhs.true85, label %if.end94

land.lhs.true85:                                  ; preds = %land.lhs.true
  %60 = load i32, i32* %size, align 4
  %cmp86 = icmp sgt i32 %60, 0
  br i1 %cmp86, label %land.lhs.true88, label %if.end94

land.lhs.true88:                                  ; preds = %land.lhs.true85
  %61 = load %struct.usbdevfs_ioctl*, %struct.usbdevfs_ioctl** %ctl.addr, align 8
  %data89 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %61, i32 0, i32 2
  %62 = load i8*, i8** %data89, align 8
  %63 = load i8*, i8** %buf, align 8
  %64 = load i32, i32* %size, align 4
  store i8* %62, i8** %dst.addr.i, align 8
  store i8* %63, i8** %src.addr.i, align 8
  store i32 %64, i32* %size.addr.i95, align 4
  call void @might_fault() #5
  %65 = load i8*, i8** %dst.addr.i, align 8
  %66 = load i8*, i8** %src.addr.i, align 8
  %67 = load i32, i32* %size.addr.i95, align 4
  %call.i96 = call i64 @_copy_to_user(i8* %65, i8* %66, i32 %67) #5
  %conv.i = trunc i64 %call.i96 to i32
  %cmp91 = icmp ne i32 %conv.i, 0
  br i1 %cmp91, label %if.then93, label %if.end94

if.then93:                                        ; preds = %land.lhs.true88
  store i32 -14, i32* %retval1, align 4
  br label %if.end94

if.end94:                                         ; preds = %if.then93, %land.lhs.true88, %land.lhs.true85, %land.lhs.true, %if.end76
  %68 = load i8*, i8** %buf, align 8
  call void @kfree(i8* %68)
  %69 = load i32, i32* %retval1, align 4
  store i32 %69, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end94, %if.then20, %if.then13, %if.then4
  %70 = load i32, i32* %retval, align 4
  ret i32 %70
}

declare void @usb_driver_release_interface(%struct.usb_driver*, %struct.usb_interface*) #1

declare i32 @device_attach(%struct.device*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.async* @async_getpending(%struct.dev_state* %ps, i8* %userurb) #0 {
entry:
  %retval = alloca %struct.async*, align 8
  %ps.addr = alloca %struct.dev_state*, align 8
  %userurb.addr = alloca i8*, align 8
  %as = alloca %struct.async*, align 8
  %__mptr = alloca %struct.list_head*, align 8
  %tmp = alloca %struct.async*, align 8
  %__mptr5 = alloca %struct.list_head*, align 8
  %tmp8 = alloca %struct.async*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i8* %userurb, i8** %userurb.addr, align 8
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %1, %struct.list_head** %__mptr, align 8
  %2 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.async*
  store %struct.async* %4, %struct.async** %tmp, align 8
  %5 = load %struct.async*, %struct.async** %tmp, align 8
  store %struct.async* %5, %struct.async** %as, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load %struct.async*, %struct.async** %as, align 8
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  %7 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_pending1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %7, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.async*, %struct.async** %as, align 8
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 7
  %9 = load i8*, i8** %userurb2, align 8
  %10 = load i8*, i8** %userurb.addr, align 8
  %cmp3 = icmp eq i8* %9, %10
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %11 = load %struct.async*, %struct.async** %as, align 8
  %asynclist4 = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist4)
  %12 = load %struct.async*, %struct.async** %as, align 8
  store %struct.async* %12, %struct.async** %retval, align 8
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %13 = load %struct.async*, %struct.async** %as, align 8
  %asynclist6 = getelementptr inbounds %struct.async, %struct.async* %13, i32 0, i32 0
  %next7 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist6, i32 0, i32 0
  %14 = load %struct.list_head*, %struct.list_head** %next7, align 8
  store %struct.list_head* %14, %struct.list_head** %__mptr5, align 8
  %15 = load %struct.list_head*, %struct.list_head** %__mptr5, align 8
  %16 = bitcast %struct.list_head* %15 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %16, i64 0
  %17 = bitcast i8* %add.ptr9 to %struct.async*
  store %struct.async* %17, %struct.async** %tmp8, align 8
  %18 = load %struct.async*, %struct.async** %tmp8, align 8
  store %struct.async* %18, %struct.async** %as, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store %struct.async* null, %struct.async** %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %19 = load %struct.async*, %struct.async** %retval, align 8
  ret %struct.async* %19
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @processcompl(%struct.async* %as, i8** %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %as.addr = alloca %struct.async*, align 8
  %arg.addr = alloca i8**, align 8
  %urb = alloca %struct.urb*, align 8
  %userurb = alloca %struct.usbdevfs_urb*, align 8
  %addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %__ret_pu = alloca i32, align 4
  %__pu_val = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__ret_pu13 = alloca i32, align 4
  %__pu_val14 = alloca i32, align 4
  %tmp17 = alloca i32, align 4
  %__ret_pu21 = alloca i32, align 4
  %__pu_val22 = alloca i32, align 4
  %tmp24 = alloca i32, align 4
  %__ret_pu31 = alloca i32, align 4
  %__pu_val32 = alloca i32, align 4
  %tmp38 = alloca i32, align 4
  %__ret_pu42 = alloca i32, align 4
  %__pu_val43 = alloca i32, align 4
  %tmp52 = alloca i32, align 4
  %__ret_pu57 = alloca i32, align 4
  %__pu_val58 = alloca i8*, align 8
  %tmp59 = alloca i32, align 4
  store %struct.async* %as, %struct.async** %as.addr, align 8
  store i8** %arg, i8*** %arg.addr, align 8
  %0 = load %struct.async*, %struct.async** %as.addr, align 8
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %1 = load %struct.urb*, %struct.urb** %urb1, align 8
  store %struct.urb* %1, %struct.urb** %urb, align 8
  %2 = load %struct.async*, %struct.async** %as.addr, align 8
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 7
  %3 = load i8*, i8** %userurb2, align 8
  %4 = bitcast i8* %3 to %struct.usbdevfs_urb*
  store %struct.usbdevfs_urb* %4, %struct.usbdevfs_urb** %userurb, align 8
  %5 = load %struct.async*, %struct.async** %as.addr, align 8
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 7
  %6 = load i8*, i8** %userurb3, align 8
  store i8* %6, i8** %addr, align 8
  %7 = load %struct.async*, %struct.async** %as.addr, align 8
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %7, i32 0, i32 6
  %8 = load i8*, i8** %userbuffer, align 8
  %tobool = icmp ne i8* %8, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %9 = load %struct.urb*, %struct.urb** %urb, align 8
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %9, i32 0, i32 20
  %10 = load i32, i32* %actual_length, align 4
  %tobool4 = icmp ne i32 %10, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %11 = load %struct.async*, %struct.async** %as.addr, align 8
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %11, i32 0, i32 6
  %12 = load i8*, i8** %userbuffer5, align 8
  %13 = load %struct.urb*, %struct.urb** %urb, align 8
  %call = call i32 @copy_urb_data_to_user(i8* %12, %struct.urb* %13)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  br label %err_out

if.end:                                           ; preds = %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end, %land.lhs.true, %entry
  call void @might_fault()
  %14 = load %struct.async*, %struct.async** %as.addr, align 8
  %status = getelementptr inbounds %struct.async, %struct.async* %14, i32 0, i32 10
  %15 = load i32, i32* %status, align 4
  store i32 %15, i32* %__pu_val, align 4
  %16 = load i32, i32* %__pu_val, align 4
  %17 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %userurb, align 8
  %status9 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %17, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %16, i32* %status9) #5, !srcloc !63
  store i32 %18, i32* %__ret_pu, align 4
  %19 = load i32, i32* %__ret_pu, align 4
  store i32 %19, i32* %tmp, align 4
  %20 = load i32, i32* %tmp, align 4
  %tobool10 = icmp ne i32 %20, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  br label %err_out

if.end12:                                         ; preds = %if.end8
  call void @might_fault()
  %21 = load %struct.urb*, %struct.urb** %urb, align 8
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %21, i32 0, i32 20
  %22 = load i32, i32* %actual_length15, align 4
  store i32 %22, i32* %__pu_val14, align 4
  %23 = load i32, i32* %__pu_val14, align 4
  %24 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %userurb, align 8
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %24, i32 0, i32 6
  %25 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %23, i32* %actual_length16) #5, !srcloc !64
  store i32 %25, i32* %__ret_pu13, align 4
  %26 = load i32, i32* %__ret_pu13, align 4
  store i32 %26, i32* %tmp17, align 4
  %27 = load i32, i32* %tmp17, align 4
  %tobool18 = icmp ne i32 %27, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end12
  br label %err_out

if.end20:                                         ; preds = %if.end12
  call void @might_fault()
  %28 = load %struct.urb*, %struct.urb** %urb, align 8
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %28, i32 0, i32 26
  %29 = load i32, i32* %error_count, align 4
  store i32 %29, i32* %__pu_val22, align 4
  %30 = load i32, i32* %__pu_val22, align 4
  %31 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %userurb, align 8
  %error_count23 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %31, i32 0, i32 9
  %32 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %30, i32* %error_count23) #5, !srcloc !65
  store i32 %32, i32* %__ret_pu21, align 4
  %33 = load i32, i32* %__ret_pu21, align 4
  store i32 %33, i32* %tmp24, align 4
  %34 = load i32, i32* %tmp24, align 4
  %tobool25 = icmp ne i32 %34, 0
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end20
  br label %err_out

if.end27:                                         ; preds = %if.end20
  %35 = load %struct.urb*, %struct.urb** %urb, align 8
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %35, i32 0, i32 9
  %36 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %36, i32 0, i32 0
  %call28 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end56

if.then30:                                        ; preds = %if.end27
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then30
  %37 = load i32, i32* %i, align 4
  %38 = load %struct.urb*, %struct.urb** %urb, align 8
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %38, i32 0, i32 24
  %39 = load i32, i32* %number_of_packets, align 4
  %cmp = icmp ult i32 %37, %39
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %40 = load %struct.urb*, %struct.urb** %urb, align 8
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %40, i32 0, i32 29
  %41 = load i32, i32* %i, align 4
  %idxprom = zext i32 %41 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length33 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx, i32 0, i32 2
  %42 = load i32, i32* %actual_length33, align 8
  store i32 %42, i32* %__pu_val32, align 4
  %43 = load i32, i32* %__pu_val32, align 4
  %44 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %userurb, align 8
  %iso_frame_desc34 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %44, i32 0, i32 12
  %45 = load i32, i32* %i, align 4
  %idxprom35 = zext i32 %45 to i64
  %arrayidx36 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc34, i64 0, i64 %idxprom35
  %actual_length37 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx36, i32 0, i32 1
  %46 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %43, i32* %actual_length37) #5, !srcloc !66
  store i32 %46, i32* %__ret_pu31, align 4
  %47 = load i32, i32* %__ret_pu31, align 4
  store i32 %47, i32* %tmp38, align 4
  %48 = load i32, i32* %tmp38, align 4
  %tobool39 = icmp ne i32 %48, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %for.body
  br label %err_out

if.end41:                                         ; preds = %for.body
  call void @might_fault()
  %49 = load %struct.urb*, %struct.urb** %urb, align 8
  %iso_frame_desc44 = getelementptr inbounds %struct.urb, %struct.urb* %49, i32 0, i32 29
  %50 = load i32, i32* %i, align 4
  %idxprom45 = zext i32 %50 to i64
  %arrayidx46 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc44, i64 0, i64 %idxprom45
  %status47 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx46, i32 0, i32 3
  %51 = load i32, i32* %status47, align 4
  store i32 %51, i32* %__pu_val43, align 4
  %52 = load i32, i32* %__pu_val43, align 4
  %53 = load %struct.usbdevfs_urb*, %struct.usbdevfs_urb** %userurb, align 8
  %iso_frame_desc48 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %53, i32 0, i32 12
  %54 = load i32, i32* %i, align 4
  %idxprom49 = zext i32 %54 to i64
  %arrayidx50 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc48, i64 0, i64 %idxprom49
  %status51 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx50, i32 0, i32 2
  %55 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %52, i32* %status51) #5, !srcloc !67
  store i32 %55, i32* %__ret_pu42, align 4
  %56 = load i32, i32* %__ret_pu42, align 4
  store i32 %56, i32* %tmp52, align 4
  %57 = load i32, i32* %tmp52, align 4
  %tobool53 = icmp ne i32 %57, 0
  br i1 %tobool53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.end41
  br label %err_out

if.end55:                                         ; preds = %if.end41
  br label %for.inc

for.inc:                                          ; preds = %if.end55
  %58 = load i32, i32* %i, align 4
  %inc = add i32 %58, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end56

if.end56:                                         ; preds = %for.end, %if.end27
  call void @might_fault()
  %59 = load i8*, i8** %addr, align 8
  store i8* %59, i8** %__pu_val58, align 8
  %60 = load i8*, i8** %__pu_val58, align 8
  %61 = load i8**, i8*** %arg.addr, align 8
  %62 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %60, i8** %61) #5, !srcloc !68
  %63 = ptrtoint i8* %62 to i64
  %64 = trunc i64 %63 to i32
  store i32 %64, i32* %__ret_pu57, align 4
  %65 = load i32, i32* %__ret_pu57, align 4
  store i32 %65, i32* %tmp59, align 4
  %66 = load i32, i32* %tmp59, align 4
  %tobool60 = icmp ne i32 %66, 0
  br i1 %tobool60, label %if.then61, label %if.end62

if.then61:                                        ; preds = %if.end56
  store i32 -14, i32* %retval, align 4
  br label %return

if.end62:                                         ; preds = %if.end56
  store i32 0, i32* %retval, align 4
  br label %return

err_out:                                          ; preds = %if.then54, %if.then40, %if.then26, %if.then19, %if.then11, %if.then7
  store i32 -14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_out, %if.end62, %if.then61
  %67 = load i32, i32* %retval, align 4
  ret i32 %67
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @releaseintf(%struct.dev_state* %ps, i32 %ifnum) #0 {
entry:
  %retval = alloca i32, align 4
  %ps.addr = alloca %struct.dev_state*, align 8
  %ifnum.addr = alloca i32, align 4
  %dev = alloca %struct.usb_device*, align 8
  %intf = alloca %struct.usb_interface*, align 8
  %err = alloca i32, align 4
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  store i32 %ifnum, i32* %ifnum.addr, align 4
  store i32 -22, i32* %err, align 4
  %0 = load i32, i32* %ifnum.addr, align 4
  %conv = zext i32 %0 to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %err, align 4
  store i32 %1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %dev2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8
  store %struct.usb_device* %3, %struct.usb_device** %dev, align 8
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8
  %5 = load i32, i32* %ifnum.addr, align 4
  %call = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %4, i32 %5)
  store %struct.usb_interface* %call, %struct.usb_interface** %intf, align 8
  %6 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  %tobool = icmp ne %struct.usb_interface* %6, null
  br i1 %tobool, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.end
  store i32 -2, i32* %err, align 4
  br label %if.end8

if.else:                                          ; preds = %if.end
  %7 = load i32, i32* %ifnum.addr, align 4
  %8 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %8, i32 0, i32 11
  %call4 = call i32 @test_and_clear_bit(i32 %7, i64* %ifclaimed)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.else
  %9 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8
  call void @usb_driver_release_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %9)
  store i32 0, i32* %err, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.then3
  %10 = load i32, i32* %err, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then
  %11 = load i32, i32* %retval, align 4
  ret i32 %11
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @test_and_clear_bit(i32 %nr, i64* %addr) #0 {
entry:
  %nr.addr = alloca i32, align 4
  %addr.addr = alloca i64*, align 8
  %oldbit = alloca i32, align 4
  store i32 %nr, i32* %nr.addr, align 4
  store i64* %addr, i64** %addr.addr, align 8
  %0 = load i64*, i64** %addr.addr, align 8
  %1 = load i32, i32* %nr.addr, align 4
  %2 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %0, i32 %1, i64* %0) #5, !srcloc !69
  store i32 %2, i32* %oldbit, align 4
  %3 = load i32, i32* %oldbit, align 4
  ret i32 %3
}

declare i32 @usb_hub_claim_port(%struct.usb_device*, i32, %struct.dev_state*) #1

declare i32 @usb_hub_release_port(%struct.usb_device*, i32, %struct.dev_state*) #1

declare i32 @strncmp(i8*, i8*, i64) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @imajor(%struct.inode* %inode) #0 {
entry:
  %inode.addr = alloca %struct.inode*, align 8
  store %struct.inode* %inode, %struct.inode** %inode.addr, align 8
  %0 = load %struct.inode*, %struct.inode** %inode.addr, align 8
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 13
  %1 = load i32, i32* %i_rdev, align 4
  %shr = lshr i32 %1, 20
  ret i32 %shr
}

; Function Attrs: noinline nounwind optnone uwtable
define internal %struct.usb_device* @usbdev_lookup_by_devt(i32 %devt) #0 {
entry:
  %retval = alloca %struct.usb_device*, align 8
  %devt.addr = alloca i32, align 4
  %dev = alloca %struct.device*, align 8
  %__mptr = alloca %struct.device*, align 8
  %tmp = alloca %struct.usb_device*, align 8
  store i32 %devt, i32* %devt.addr, align 4
  %0 = load i32, i32* %devt.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = inttoptr i64 %conv to i8*
  %call = call %struct.device* @bus_find_device(%struct.bus_type* @usb_bus_type, %struct.device* null, i8* %1, i32 (%struct.device*, i8*)* @match_devt)
  store %struct.device* %call, %struct.device** %dev, align 8
  %2 = load %struct.device*, %struct.device** %dev, align 8
  %tobool = icmp ne %struct.device* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.usb_device* null, %struct.usb_device** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.device*, %struct.device** %dev, align 8
  store %struct.device* %3, %struct.device** %__mptr, align 8
  %4 = load %struct.device*, %struct.device** %__mptr, align 8
  %5 = bitcast %struct.device* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -136
  %6 = bitcast i8* %add.ptr to %struct.usb_device*
  store %struct.usb_device* %6, %struct.usb_device** %tmp, align 8
  %7 = load %struct.usb_device*, %struct.usb_device** %tmp, align 8
  store %struct.usb_device* %7, %struct.usb_device** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load %struct.usb_device*, %struct.usb_device** %retval, align 8
  ret %struct.usb_device* %8
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usb_autoresume_device(%struct.usb_device* %udev) #0 {
entry:
  %udev.addr = alloca %struct.usb_device*, align 8
  store %struct.usb_device* %udev, %struct.usb_device** %udev.addr, align 8
  ret i32 0
}

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

declare void @usb_put_dev(%struct.usb_device*) #1

declare %struct.device* @bus_find_device(%struct.bus_type*, %struct.device*, i8*, i32 (%struct.device*, i8*)*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @match_devt(%struct.device* %dev, i8* %data) #0 {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %data.addr = alloca i8*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load %struct.device*, %struct.device** %dev.addr, align 8
  %devt = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 20
  %1 = load i32, i32* %devt, align 8
  %2 = load i8*, i8** %data.addr, align 8
  %3 = ptrtoint i8* %2 to i64
  %conv = trunc i64 %3 to i32
  %cmp = icmp eq i32 %1, %conv
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare void @usb_hub_release_all_ports(%struct.usb_device*, %struct.dev_state*) #1

; Function Attrs: noinline nounwind optnone uwtable
define internal void @destroy_all_async(%struct.dev_state* %ps) #0 {
entry:
  %ps.addr = alloca %struct.dev_state*, align 8
  store %struct.dev_state* %ps, %struct.dev_state** %ps.addr, align 8
  %0 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %1 = load %struct.dev_state*, %struct.dev_state** %ps.addr, align 8
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 4
  call void @destroy_async(%struct.dev_state* %0, %struct.list_head* %async_pending)
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define internal i32 @usbdev_notify(%struct.notifier_block* %self, i64 %action, i8* %dev) #0 {
entry:
  %self.addr = alloca %struct.notifier_block*, align 8
  %action.addr = alloca i64, align 8
  %dev.addr = alloca i8*, align 8
  store %struct.notifier_block* %self, %struct.notifier_block** %self.addr, align 8
  store i64 %action, i64* %action.addr, align 8
  store i8* %dev, i8** %dev.addr, align 8
  %0 = load i64, i64* %action.addr, align 8
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i64 %0, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i64 %0, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i64 %0, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = load i8*, i8** %dev.addr, align 8
  %2 = bitcast i8* %1 to %struct.usb_device*
  call void @usbdev_remove(%struct.usb_device* %2)
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %sw.bb1, %sw.bb
  ret i32 1
}

; Function Attrs: noinline nounwind optnone uwtable
define internal void @usbdev_remove(%struct.usb_device* %udev) #0 {
entry:
  %udev.addr = alloca %struct.usb_device*, align 8
  %ps = alloca %struct.dev_state*, align 8
  %sinfo = alloca %struct.siginfo, align 8
  %__mptr = alloca %struct.list_head*, align 8
  %tmp = alloca %struct.dev_state*, align 8
  store %struct.usb_device* %udev, %struct.usb_device** %udev.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 27
  %call = call i32 @list_empty(%struct.list_head* %filelist)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.usb_device*, %struct.usb_device** %udev.addr, align 8
  %filelist1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 27
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %filelist1, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8
  store %struct.list_head* %2, %struct.list_head** %__mptr, align 8
  %3 = load %struct.list_head*, %struct.list_head** %__mptr, align 8
  %4 = bitcast %struct.list_head* %3 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.dev_state*
  store %struct.dev_state* %5, %struct.dev_state** %tmp, align 8
  %6 = load %struct.dev_state*, %struct.dev_state** %tmp, align 8
  store %struct.dev_state* %6, %struct.dev_state** %ps, align 8
  %7 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  call void @destroy_all_async(%struct.dev_state* %7)
  %8 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %wait = getelementptr inbounds %struct.dev_state, %struct.dev_state* %8, i32 0, i32 6
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 0, i8* null)
  %9 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %9, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %list)
  %10 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %10, i32 0, i32 7
  %11 = load i32, i32* %discsignr, align 8
  %tobool2 = icmp ne i32 %11, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %12 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %discsignr3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %12, i32 0, i32 7
  %13 = load i32, i32* %discsignr3, align 8
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %13, i32* %si_signo, align 8
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 32, i32* %si_errno, align 4
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8
  %14 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 10
  %15 = load i8*, i8** %disccontext, align 8
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.32* %_sifields to %struct.anon.37*
  %_addr = getelementptr inbounds %struct.anon.37, %struct.anon.37* %_sigfault, i32 0, i32 0
  store i8* %15, i8** %_addr, align 8
  %16 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %discsignr4 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %16, i32 0, i32 7
  %17 = load i32, i32* %discsignr4, align 8
  %18 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %disc_pid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %18, i32 0, i32 8
  %19 = load %struct.pid*, %struct.pid** %disc_pid, align 8
  %20 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %cred = getelementptr inbounds %struct.dev_state, %struct.dev_state* %20, i32 0, i32 9
  %21 = load %struct.cred*, %struct.cred** %cred, align 8
  %22 = load %struct.dev_state*, %struct.dev_state** %ps, align 8
  %secid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %22, i32 0, i32 12
  %23 = load i32, i32* %secid, align 8
  %call5 = call i32 @kill_pid_info_as_cred(i32 %17, %struct.siginfo* %sinfo, %struct.pid* %19, %struct.cred* %21, i32 %23)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

attributes #0 = { noinline nounwind optnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind readnone speculatable }
attributes #5 = { nounwind }
attributes #6 = { nounwind readnone }
attributes #7 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{i32 -2147070007, i32 -2147069968, i32 -2147069947, i32 -2147069910, i32 -2147069887, i32 -2147070017}
!3 = !{i32 -2146838773}
!4 = !{i32 -2143885650}
!5 = !{i32 773303, i32 773324}
!6 = !{i32 -2143883507}
!7 = !{i32 -2143881136}
!8 = !{i32 -2143880548}
!9 = !{i32 -2143879953}
!10 = !{i32 -2143879178}
!11 = !{i32 -2143861819}
!12 = !{i32 -2143860245}
!13 = !{i32 -2143859791}
!14 = !{i32 -2143858487}
!15 = !{i32 -2143857836}
!16 = !{i32 -2143856514}
!17 = !{i32 -2143855856}
!18 = !{i32 -2143854462}
!19 = !{i32 -2143853776}
!20 = !{i32 -2143852204}
!21 = !{i32 -2143631442}
!22 = !{i32 -2143621362, i32 -2143621355, i32 -2143621341, i32 -2143621339, i32 -2143622012, i32 -2143621299, i32 -2143621251, i32 -2143621185, i32 -2143621123, i32 -2143621071, i32 -2143621932, i32 -2143621907, i32 -2143620866, i32 -2143621834, i32 -2143621809, i32 -2143620606, i32 -2143620682, i32 -2143620589, i32 -2143620638, i32 -2143622532, i32 -2143622491, i32 -2143619823, i32 -2143619809, i32 -2143619807, i32 -2143620480, i32 -2143619767, i32 -2143619719, i32 -2143619653, i32 -2143619591, i32 -2143619539, i32 -2143620400, i32 -2143620375, i32 -2143619334, i32 -2143620302, i32 -2143620277, i32 -2143619074, i32 -2143619150, i32 -2143619057, i32 -2143619106, i32 -2143622459, i32 -2143622420, i32 -2143622391, i32 -2143622345, i32 -2143622320, i32 -2143619040, i32 -2143618996, i32 -2143618973, i32 -2143618940, i32 -2143618909}
!23 = !{i32 -2143605022, i32 -2143605015, i32 -2143605001, i32 -2143604999, i32 -2143605672, i32 -2143604959, i32 -2143604911, i32 -2143604845, i32 -2143604783, i32 -2143604731, i32 -2143605592, i32 -2143605567, i32 -2143604526, i32 -2143605494, i32 -2143605469, i32 -2143604266, i32 -2143604342, i32 -2143604249, i32 -2143604298, i32 -2143606198, i32 -2143606157, i32 -2143603483, i32 -2143603469, i32 -2143603467, i32 -2143604140, i32 -2143603427, i32 -2143603379, i32 -2143603313, i32 -2143603251, i32 -2143603199, i32 -2143604060, i32 -2143604035, i32 -2143602994, i32 -2143603962, i32 -2143603937, i32 -2143602734, i32 -2143602810, i32 -2143602717, i32 -2143602766, i32 -2143606125, i32 -2143606086, i32 -2143606057, i32 -2143606011, i32 -2143605986, i32 -2143602700, i32 -2143602656, i32 -2143602633, i32 -2143602600, i32 -2143602569}
!24 = !{i32 -2143584713, i32 -2143584706, i32 -2143584692, i32 -2143584690, i32 -2143585363, i32 -2143584650, i32 -2143584602, i32 -2143584536, i32 -2143584474, i32 -2143584422, i32 -2143585283, i32 -2143585258, i32 -2143584217, i32 -2143585185, i32 -2143585160, i32 -2143583957, i32 -2143584033, i32 -2143583940, i32 -2143583989, i32 -2143585883, i32 -2143585842, i32 -2143583174, i32 -2143583160, i32 -2143583158, i32 -2143583831, i32 -2143583118, i32 -2143583070, i32 -2143583004, i32 -2143582942, i32 -2143582890, i32 -2143583751, i32 -2143583726, i32 -2143582685, i32 -2143583653, i32 -2143583628, i32 -2143582425, i32 -2143582501, i32 -2143582408, i32 -2143582457, i32 -2143585810, i32 -2143585771, i32 -2143585742, i32 -2143585696, i32 -2143585671, i32 -2143582391, i32 -2143582347, i32 -2143582324, i32 -2143582291, i32 -2143582260}
!25 = !{i32 -2143635500}
!26 = !{i32 -2143634902}
!27 = !{i32 -2143578171}
!28 = !{i32 -2143577252}
!29 = !{i32 -2143575670}
!30 = !{i32 -2146647980}
!31 = !{i32 369117, i32 369128}
!32 = !{i32 -2147070715, i32 -2147070676, i32 -2147070655, i32 -2147070618, i32 -2147070595, i32 -2147070725}
!33 = !{i32 -2146676595, i32 -2146676556, i32 -2146676535, i32 -2146676498, i32 -2146676475, i32 -2146676605}
!34 = !{i32 -2146676383, i32 -2146676344, i32 -2146676323, i32 -2146676286, i32 -2146676263, i32 -2146676393}
!35 = !{i32 -2143877018}
!36 = !{i32 -2144243575, i32 -2144243550, i32 -2144243280, i32 -2144243483, i32 -2144243452, i32 -2144243422}
!37 = !{i32 -2146564838}
!38 = !{i32 -2146580013}
!39 = !{i32 -2146675535, i32 -2146675496, i32 -2146675475, i32 -2146675438, i32 -2146675415, i32 -2146675545}
!40 = !{i32 -2146675959, i32 -2146675920, i32 -2146675899, i32 -2146675862, i32 -2146675839, i32 -2146675969}
!41 = !{i32 -2146563582}
!42 = !{i32 773745}
!43 = !{i32 -2143851354}
!44 = !{i32 -2143848770, i32 -2143848763, i32 -2143848749, i32 -2143848747, i32 -2143849420, i32 -2143848707, i32 -2143848659, i32 -2143848593, i32 -2143848531, i32 -2143848479, i32 -2143849340, i32 -2143849315, i32 -2143848274, i32 -2143849242, i32 -2143849217, i32 -2143848014, i32 -2143848090, i32 -2143847997, i32 -2143848046, i32 -2143849940, i32 -2143849899, i32 -2143847231, i32 -2143847217, i32 -2143847215, i32 -2143847888, i32 -2143847175, i32 -2143847127, i32 -2143847061, i32 -2143846999, i32 -2143846947, i32 -2143847808, i32 -2143847783, i32 -2143846742, i32 -2143847710, i32 -2143847685, i32 -2143846482, i32 -2143846558, i32 -2143846465, i32 -2143846514, i32 -2143849867, i32 -2143849828, i32 -2143849799, i32 -2143849753, i32 -2143849728, i32 -2143846448, i32 -2143846404, i32 -2143846381, i32 -2143846348, i32 -2143846317}
!45 = !{i32 -2143832480, i32 -2143832473, i32 -2143832459, i32 -2143832457, i32 -2143833130, i32 -2143832417, i32 -2143832369, i32 -2143832303, i32 -2143832241, i32 -2143832189, i32 -2143833050, i32 -2143833025, i32 -2143831984, i32 -2143832952, i32 -2143832927, i32 -2143831724, i32 -2143831800, i32 -2143831707, i32 -2143831756, i32 -2143833654, i32 -2143833613, i32 -2143830941, i32 -2143830927, i32 -2143830925, i32 -2143831598, i32 -2143830885, i32 -2143830837, i32 -2143830771, i32 -2143830709, i32 -2143830657, i32 -2143831518, i32 -2143831493, i32 -2143830452, i32 -2143831420, i32 -2143831395, i32 -2143830192, i32 -2143830268, i32 -2143830175, i32 -2143830224, i32 -2143833581, i32 -2143833542, i32 -2143833513, i32 -2143833467, i32 -2143833442, i32 -2143830158, i32 -2143830114, i32 -2143830091, i32 -2143830058, i32 -2143830027}
!46 = !{i32 -2143808680, i32 -2143808673, i32 -2143808659, i32 -2143808657, i32 -2143809330, i32 -2143808617, i32 -2143808569, i32 -2143808503, i32 -2143808441, i32 -2143808389, i32 -2143809250, i32 -2143809225, i32 -2143808184, i32 -2143809152, i32 -2143809127, i32 -2143807924, i32 -2143808000, i32 -2143807907, i32 -2143807956, i32 -2143809852, i32 -2143809811, i32 -2143807141, i32 -2143807127, i32 -2143807125, i32 -2143807798, i32 -2143807085, i32 -2143807037, i32 -2143806971, i32 -2143806909, i32 -2143806857, i32 -2143807718, i32 -2143807693, i32 -2143806652, i32 -2143807620, i32 -2143807595, i32 -2143806392, i32 -2143806468, i32 -2143806375, i32 -2143806424, i32 -2143809779, i32 -2143809740, i32 -2143809711, i32 -2143809665, i32 -2143809640, i32 -2143806358, i32 -2143806314, i32 -2143806291, i32 -2143806258, i32 -2143806227}
!47 = !{i32 -2143788359, i32 -2143788352, i32 -2143788338, i32 -2143788336, i32 -2143789009, i32 -2143788296, i32 -2143788248, i32 -2143788182, i32 -2143788120, i32 -2143788068, i32 -2143788929, i32 -2143788904, i32 -2143787863, i32 -2143788831, i32 -2143788806, i32 -2143787603, i32 -2143787679, i32 -2143787586, i32 -2143787635, i32 -2143789530, i32 -2143789489, i32 -2143786820, i32 -2143786806, i32 -2143786804, i32 -2143787477, i32 -2143786764, i32 -2143786716, i32 -2143786650, i32 -2143786588, i32 -2143786536, i32 -2143787397, i32 -2143787372, i32 -2143786331, i32 -2143787299, i32 -2143787274, i32 -2143786071, i32 -2143786147, i32 -2143786054, i32 -2143786103, i32 -2143789457, i32 -2143789418, i32 -2143789389, i32 -2143789343, i32 -2143789318, i32 -2143786037, i32 -2143785993, i32 -2143785970, i32 -2143785937, i32 -2143785906}
!48 = !{i32 -2143771959, i32 -2143771952, i32 -2143771938, i32 -2143771936, i32 -2143772609, i32 -2143771896, i32 -2143771848, i32 -2143771782, i32 -2143771720, i32 -2143771668, i32 -2143772529, i32 -2143772504, i32 -2143771463, i32 -2143772431, i32 -2143772406, i32 -2143771203, i32 -2143771279, i32 -2143771186, i32 -2143771235, i32 -2143773138, i32 -2143773097, i32 -2143770420, i32 -2143770406, i32 -2143770404, i32 -2143771077, i32 -2143770364, i32 -2143770316, i32 -2143770250, i32 -2143770188, i32 -2143770136, i32 -2143770997, i32 -2143770972, i32 -2143769931, i32 -2143770899, i32 -2143770874, i32 -2143769671, i32 -2143769747, i32 -2143769654, i32 -2143769703, i32 -2143773065, i32 -2143773026, i32 -2143772997, i32 -2143772951, i32 -2143772926, i32 -2143769637, i32 -2143769593, i32 -2143769570, i32 -2143769537, i32 -2143769506}
!49 = !{i32 -2143755527, i32 -2143755520, i32 -2143755506, i32 -2143755504, i32 -2143756177, i32 -2143755464, i32 -2143755416, i32 -2143755350, i32 -2143755288, i32 -2143755236, i32 -2143756097, i32 -2143756072, i32 -2143755031, i32 -2143755999, i32 -2143755974, i32 -2143754771, i32 -2143754847, i32 -2143754754, i32 -2143754803, i32 -2143756706, i32 -2143756665, i32 -2143753988, i32 -2143753974, i32 -2143753972, i32 -2143754645, i32 -2143753932, i32 -2143753884, i32 -2143753818, i32 -2143753756, i32 -2143753704, i32 -2143754565, i32 -2143754540, i32 -2143753499, i32 -2143754467, i32 -2143754442, i32 -2143753239, i32 -2143753315, i32 -2143753222, i32 -2143753271, i32 -2143756633, i32 -2143756594, i32 -2143756565, i32 -2143756519, i32 -2143756494, i32 -2143753205, i32 -2143753161, i32 -2143753138, i32 -2143753105, i32 -2143753074}
!50 = !{i32 -2143739131, i32 -2143739124, i32 -2143739110, i32 -2143739108, i32 -2143739781, i32 -2143739068, i32 -2143739020, i32 -2143738954, i32 -2143738892, i32 -2143738840, i32 -2143739701, i32 -2143739676, i32 -2143738635, i32 -2143739603, i32 -2143739578, i32 -2143738375, i32 -2143738451, i32 -2143738358, i32 -2143738407, i32 -2143740308, i32 -2143740267, i32 -2143737592, i32 -2143737578, i32 -2143737576, i32 -2143738249, i32 -2143737536, i32 -2143737488, i32 -2143737422, i32 -2143737360, i32 -2143737308, i32 -2143738169, i32 -2143738144, i32 -2143737103, i32 -2143738071, i32 -2143738046, i32 -2143736843, i32 -2143736919, i32 -2143736826, i32 -2143736875, i32 -2143740235, i32 -2143740196, i32 -2143740167, i32 -2143740121, i32 -2143740096, i32 -2143736809, i32 -2143736765, i32 -2143736742, i32 -2143736709, i32 -2143736678}
!51 = !{i32 -2143722635, i32 -2143722628, i32 -2143722614, i32 -2143722612, i32 -2143723285, i32 -2143722572, i32 -2143722524, i32 -2143722458, i32 -2143722396, i32 -2143722344, i32 -2143723205, i32 -2143723180, i32 -2143722139, i32 -2143723107, i32 -2143723082, i32 -2143721879, i32 -2143721955, i32 -2143721862, i32 -2143721911, i32 -2143723818, i32 -2143723777, i32 -2143721096, i32 -2143721082, i32 -2143721080, i32 -2143721753, i32 -2143721040, i32 -2143720992, i32 -2143720926, i32 -2143720864, i32 -2143720812, i32 -2143721673, i32 -2143721648, i32 -2143720607, i32 -2143721575, i32 -2143721550, i32 -2143720347, i32 -2143720423, i32 -2143720330, i32 -2143720379, i32 -2143723745, i32 -2143723706, i32 -2143723677, i32 -2143723631, i32 -2143723606, i32 -2143720313, i32 -2143720269, i32 -2143720246, i32 -2143720213, i32 -2143720182}
!52 = !{i32 -2143706223, i32 -2143706216, i32 -2143706202, i32 -2143706200, i32 -2143706873, i32 -2143706160, i32 -2143706112, i32 -2143706046, i32 -2143705984, i32 -2143705932, i32 -2143706793, i32 -2143706768, i32 -2143705727, i32 -2143706695, i32 -2143706670, i32 -2143705467, i32 -2143705543, i32 -2143705450, i32 -2143705499, i32 -2143707400, i32 -2143707359, i32 -2143704684, i32 -2143704670, i32 -2143704668, i32 -2143705341, i32 -2143704628, i32 -2143704580, i32 -2143704514, i32 -2143704452, i32 -2143704400, i32 -2143705261, i32 -2143705236, i32 -2143704195, i32 -2143705163, i32 -2143705138, i32 -2143703935, i32 -2143704011, i32 -2143703918, i32 -2143703967, i32 -2143707327, i32 -2143707288, i32 -2143707259, i32 -2143707213, i32 -2143707188, i32 -2143703901, i32 -2143703857, i32 -2143703834, i32 -2143703801, i32 -2143703770}
!53 = !{i32 -2143685882, i32 -2143685875, i32 -2143685861, i32 -2143685859, i32 -2143686532, i32 -2143685819, i32 -2143685771, i32 -2143685705, i32 -2143685643, i32 -2143685591, i32 -2143686452, i32 -2143686427, i32 -2143685386, i32 -2143686354, i32 -2143686329, i32 -2143685126, i32 -2143685202, i32 -2143685109, i32 -2143685158, i32 -2143687053, i32 -2143687012, i32 -2143684343, i32 -2143684329, i32 -2143684327, i32 -2143685000, i32 -2143684287, i32 -2143684239, i32 -2143684173, i32 -2143684111, i32 -2143684059, i32 -2143684920, i32 -2143684895, i32 -2143683854, i32 -2143684822, i32 -2143684797, i32 -2143683594, i32 -2143683670, i32 -2143683577, i32 -2143683626, i32 -2143686980, i32 -2143686941, i32 -2143686912, i32 -2143686866, i32 -2143686841, i32 -2143683560, i32 -2143683516, i32 -2143683493, i32 -2143683460, i32 -2143683429}
!54 = !{i32 -2143669621, i32 -2143669614, i32 -2143669600, i32 -2143669598, i32 -2143670271, i32 -2143669558, i32 -2143669510, i32 -2143669444, i32 -2143669382, i32 -2143669330, i32 -2143670191, i32 -2143670166, i32 -2143669125, i32 -2143670093, i32 -2143670068, i32 -2143668865, i32 -2143668941, i32 -2143668848, i32 -2143668897, i32 -2143670793, i32 -2143670752, i32 -2143668082, i32 -2143668068, i32 -2143668066, i32 -2143668739, i32 -2143668026, i32 -2143667978, i32 -2143667912, i32 -2143667850, i32 -2143667798, i32 -2143668659, i32 -2143668634, i32 -2143667593, i32 -2143668561, i32 -2143668536, i32 -2143667333, i32 -2143667409, i32 -2143667316, i32 -2143667365, i32 -2143670720, i32 -2143670681, i32 -2143670652, i32 -2143670606, i32 -2143670581, i32 -2143667299, i32 -2143667255, i32 -2143667232, i32 -2143667199, i32 -2143667168}
!55 = !{i32 -2143653276, i32 -2143653269, i32 -2143653255, i32 -2143653253, i32 -2143653926, i32 -2143653213, i32 -2143653165, i32 -2143653099, i32 -2143653037, i32 -2143652985, i32 -2143653846, i32 -2143653821, i32 -2143652780, i32 -2143653748, i32 -2143653723, i32 -2143652520, i32 -2143652596, i32 -2143652503, i32 -2143652552, i32 -2143654453, i32 -2143654412, i32 -2143651737, i32 -2143651723, i32 -2143651721, i32 -2143652394, i32 -2143651681, i32 -2143651633, i32 -2143651567, i32 -2143651505, i32 -2143651453, i32 -2143652314, i32 -2143652289, i32 -2143651248, i32 -2143652216, i32 -2143652191, i32 -2143650988, i32 -2143651064, i32 -2143650971, i32 -2143651020, i32 -2143654380, i32 -2143654341, i32 -2143654312, i32 -2143654266, i32 -2143654241, i32 -2143650954, i32 -2143650910, i32 -2143650887, i32 -2143650854, i32 -2143650823}
!56 = !{i32 -2143862060}
!57 = !{i32 -2143645750}
!58 = !{i32 -2143643984}
!59 = !{i32 -2143642195}
!60 = !{i32 -2143640160}
!61 = !{i32 -2143638076}
!62 = !{i32 -2143636255}
!63 = !{i32 -2143873859}
!64 = !{i32 -2143872096}
!65 = !{i32 -2143870310}
!66 = !{i32 -2143868278}
!67 = !{i32 -2143866197}
!68 = !{i32 -2143864003}
!69 = !{i32 -2147068328, i32 -2147068289, i32 -2147068268, i32 -2147068231, i32 -2147068208, i32 -2147068338, i32 367118}
