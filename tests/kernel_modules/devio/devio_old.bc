; ModuleID = 'drivers/usb/core/devio.bc'
source_filename = "drivers/usb/core/devio.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.atomic_t = type { i32 }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i16 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.atomic_t }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.file*, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.page = type { i64, %struct.address_space*, %struct.anon.15, %union.anon.21, %union.anon.23, [8 x i8] }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.40, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.41, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.42, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.7, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.vfsmount = type opaque
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%union.anon.7 = type { %struct.list_head }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [28 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.5 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.5 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.6, i32 }
%union.anon.6 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%struct.atomic64_t = type { i64 }
%union.anon.40 = type { i32 }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%union.anon.41 = type { %struct.callback_head }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type { i8*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.8 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.8 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.42 = type { %struct.pipe_inode_info* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.read_descriptor_t = type { i64, i64, %union.anon.14, i32 }
%union.anon.14 = type { i8* }
%struct.swap_info_struct = type opaque
%struct.anon.15 = type { %union.anon.16, %union.anon.17 }
%union.anon.16 = type { i64 }
%union.anon.17 = type { i64 }
%union.anon.21 = type { %struct.list_head }
%union.anon.23 = type { i64 }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.list_head }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t }
%union.arch_rwlock_t = type { i32 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.uprobes_state = type {}
%struct.task_rss_stat = type { i32, [3 x i32] }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.10, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.11, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.12, %union.anon.13 }
%union.anon.10 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.11 = type { i64 }
%union.anon.12 = type { %struct.list_head }
%union.anon.13 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, i32, i32, i8, i8 }
%struct.uid_gid_map = type { i32, [5 x %struct.uid_gid_extent] }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.24 }
%union.anon.24 = type { %struct.anon.25 }
%struct.anon.25 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.27, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.30 }
%union.anon.27 = type { %struct.anon.28 }
%struct.anon.28 = type { i64, i64 }
%union.anon.30 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.32 }
%union.anon.32 = type { %struct.anon.36, [80 x i8] }
%struct.anon.36 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.compat_robust_list, i32, i32 }
%struct.compat_robust_list = type { i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.usb_driver = type { i8*, i32 (%struct.usb_interface*, %struct.usb_device_id*)*, void (%struct.usb_interface*)*, i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, %struct.usb_device_id*, %struct.usb_dynids, %struct.usbdrv_wrap, i8 }
%struct.usb_interface = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device, %struct.device*, %struct.atomic_t, %struct.work_struct }
%struct.usb_host_interface = type { %struct.usb_interface_descriptor, i32, i8*, %struct.usb_host_endpoint*, i8* }
%struct.usb_interface_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.usb_host_endpoint = type <{ %struct.usb_endpoint_descriptor, %struct.usb_ss_ep_comp_descriptor, i8, %struct.list_head, i8*, %struct.ep_device*, i8*, i32, i32 }>
%struct.usb_endpoint_descriptor = type <{ i8, i8, i8, i8, i16, i8, i8, i8 }>
%struct.usb_ss_ep_comp_descriptor = type { i8, i8, i8, i8, i16 }
%struct.ep_device = type opaque
%struct.usb_interface_assoc_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.usb_device_id = type { i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8, i64 }
%struct.usb_dynids = type { %struct.spinlock, %struct.list_head }
%struct.usbdrv_wrap = type { %struct.device_driver, i32 }
%struct.cdev = type { %struct.kobject, %struct.module*, %struct.file_operations*, %struct.list_head, i32, i32 }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, i32, [64 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page* }
%struct.kmem_cache_order_objects = type { i64 }
%struct.kmem_cache_node = type opaque
%struct.dev_state = type { %struct.list_head, %struct.usb_device*, %struct.file*, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.__wait_queue_head, i32, %struct.pid*, %struct.cred*, i8*, i64, i32, i32 }
%struct.usb_device = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt*, i32, [2 x i32], %struct.usb_device*, %struct.usb_bus*, %struct.usb_host_endpoint, %struct.device, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config*, %struct.usb_host_config*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %struct.atomic_t, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_tt = type { %struct.usb_device*, i32, i32, %struct.spinlock, %struct.list_head, %struct.work_struct }
%struct.usb_bus = type { %struct.device*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.usb_devmap, %struct.usb_device*, %struct.usb_bus*, %struct.list_head, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_devmap = type { [2 x i64] }
%struct.mon_bus = type opaque
%struct.usb_device_descriptor = type { i8, i8, i16, i8, i8, i8, i8, i16, i16, i16, i8, i8, i8, i8 }
%struct.usb_host_bos = type { %struct.usb_bos_descriptor*, %struct.usb_ext_cap_descriptor*, %struct.usb_ss_cap_descriptor*, %struct.usb_ss_container_id_descriptor* }
%struct.usb_bos_descriptor = type <{ i8, i8, i16, i8 }>
%struct.usb_ext_cap_descriptor = type <{ i8, i8, i8, i32 }>
%struct.usb_ss_cap_descriptor = type { i8, i8, i8, i8, i16, i8, i8, i16 }
%struct.usb_ss_container_id_descriptor = type { i8, i8, i8, i8, [16 x i8] }
%struct.usb_host_config = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_config_descriptor = type <{ i8, i8, i16, i8, i8, i8, i8, i8 }>
%struct.usb_interface_cache = type { i32, %struct.kref, [0 x %struct.usb_host_interface] }
%struct.wusb_dev = type opaque
%struct.usb3_lpm_parameters = type { i32, i32, i32, i32 }
%struct.async = type { %struct.list_head, %struct.dev_state*, %struct.pid*, %struct.cred*, i32, i32, i8*, i8*, %struct.urb*, i32, i32, i32, i8, i8 }
%struct.urb = type { %struct.kref, i8*, %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, void (%struct.urb*)*, [0 x %struct.usb_iso_packet_descriptor] }
%struct.usb_anchor = type { %struct.list_head, %struct.__wait_queue_head, %struct.spinlock, i8 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.usb_iso_packet_descriptor = type { i32, i32, i32, i32 }
%struct.usbdevfs_ctrltransfer32 = type { i8, i8, i16, i16, i16, i32, i32 }
%struct.usbdevfs_bulktransfer32 = type { i32, i32, i32, i32 }
%struct.usbdevfs_ctrltransfer = type { i8, i8, i16, i16, i16, i32, i8* }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.mm_segment_t, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.map_segment = type opaque
%struct.mm_segment_t = type { i64 }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.43 }
%union.anon.43 = type { %struct.anon.44 }
%struct.anon.44 = type { i32*, i32, i32, i32, i64, i32* }
%struct.usbdevfs_bulktransfer = type { i32, i32, i32, i8* }
%struct.usbdevfs_getdriver = type { i32, [256 x i8] }
%struct.usbdevfs_connectinfo = type { i32, i8 }
%struct.usbdevfs_setinterface = type { i32, i32 }
%struct.usbdevfs_urb = type { i8, i8, i32, i32, i8*, i32, i32, i32, i32, i32, i32, i8*, [0 x %struct.usbdevfs_iso_packet_desc] }
%struct.usbdevfs_iso_packet_desc = type { i32, i32, i32 }
%struct.usbdevfs_disconnectsignal32 = type { i32, i32 }
%struct.usbdevfs_urb32 = type { i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [0 x %struct.usbdevfs_iso_packet_desc] }
%struct.usbdevfs_ioctl = type { i32, i32, i8* }
%struct.usbdevfs_ioctl32 = type { i32, i32, i32 }
%struct.__large_struct = type { [100 x i64] }
%struct.usbdevfs_disconnectsignal = type { i32, i8* }
%struct.usbdevfs_disconnect_claim = type { i32, i32, [256 x i8] }
%struct.usb_ctrlrequest = type { i8, i8, i16, i16, i16 }
%struct.anon.37 = type { i8*, i16 }
%struct.__raw_tickets = type { i8, i8 }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }

@usbfs_mutex = global %struct.mutex { %struct.atomic_t { i32 1 }, %struct.spinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 8) to %struct.list_head*) }, %struct.task_struct* null, i8* null }, align 8
@__param_str_usbfs_snoop = internal constant [20 x i8] c"usbcore.usbfs_snoop\00", align 16
@param_ops_bool = external global %struct.kernel_param_ops, align 8
@usbfs_snoop = internal global i8 0, align 1
@__param_usbfs_snoop = internal constant %struct.kernel_param { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__param_str_usbfs_snoop, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 420, i16 -1, %union.anon.5 { i8* @usbfs_snoop } }, section "__param", align 8
@__param_str_usbfs_memory_mb = internal constant [24 x i8] c"usbcore.usbfs_memory_mb\00", align 16
@param_ops_uint = external global %struct.kernel_param_ops, align 8
@usbfs_memory_mb = internal global i32 16, align 4
@__param_usbfs_memory_mb = internal constant %struct.kernel_param { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__param_str_usbfs_memory_mb, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_uint, i16 420, i16 -1, %union.anon.5 { i8* bitcast (i32* @usbfs_memory_mb to i8*) } }, section "__param", align 8
@.str = private unnamed_addr constant [6 x i8] c"usbfs\00", align 1
@usbfs_driver = global %struct.usb_driver { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0), i32 (%struct.usb_interface*, %struct.usb_device_id*)* @driver_probe, void (%struct.usb_interface*)* @driver_disconnect, i32 (%struct.usb_interface*, i32, i8*)* null, i32 (%struct.usb_interface*, i32)* @driver_suspend, i32 (%struct.usb_interface*)* @driver_resume, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, %struct.usb_device_id* null, %struct.usb_dynids zeroinitializer, %struct.usbdrv_wrap zeroinitializer, i8 0 }, align 8
@usbdev_file_operations = constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @usbdev_lseek, i64 (%struct.file*, i8*, i64, i64*)* @usbdev_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @usbdev_poll, i64 (%struct.file*, i32, i64)* @usbdev_ioctl, i64 (%struct.file*, i32, i64)* @usbdev_compat_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.1 = private unnamed_addr constant [11 x i8] c"usb_device\00", align 1
@.str.2 = private unnamed_addr constant [44 x i8] c"\013Unable to register minors for usb_device\0A\00", align 1
@usb_device_cdev = internal global %struct.cdev zeroinitializer, align 8
@.str.3 = private unnamed_addr constant [37 x i8] c"\013Unable to get usb_device major %d\0A\00", align 1
@usbdev_nb = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @usbdev_notify, %struct.notifier_block* null, i32 0 }, align 8
@smp_ops = external global %struct.smp_ops, align 8
@current_task = external global %struct.task_struct*, align 8
@.str.4 = private unnamed_addr constant [34 x i8] c"interface number %u out of range\0A\00", align 1
@.str.5 = private unnamed_addr constant [13 x i8] c"%s: CONTROL\0A\00", align 1
@__func__.usbdev_do_ioctl = private unnamed_addr constant [16 x i8] c"usbdev_do_ioctl\00", align 1
@.str.6 = private unnamed_addr constant [10 x i8] c"%s: BULK\0A\00", align 1
@.str.7 = private unnamed_addr constant [13 x i8] c"%s: RESETEP\0A\00", align 1
@.str.8 = private unnamed_addr constant [11 x i8] c"%s: RESET\0A\00", align 1
@.str.9 = private unnamed_addr constant [16 x i8] c"%s: CLEAR_HALT\0A\00", align 1
@.str.10 = private unnamed_addr constant [15 x i8] c"%s: GETDRIVER\0A\00", align 1
@.str.11 = private unnamed_addr constant [17 x i8] c"%s: CONNECTINFO\0A\00", align 1
@.str.12 = private unnamed_addr constant [18 x i8] c"%s: SETINTERFACE\0A\00", align 1
@.str.13 = private unnamed_addr constant [22 x i8] c"%s: SETCONFIGURATION\0A\00", align 1
@.str.14 = private unnamed_addr constant [15 x i8] c"%s: SUBMITURB\0A\00", align 1
@.str.15 = private unnamed_addr constant [15 x i8] c"%s: CONTROL32\0A\00", align 1
@.str.16 = private unnamed_addr constant [12 x i8] c"%s: BULK32\0A\00", align 1
@.str.17 = private unnamed_addr constant [18 x i8] c"%s: DISCSIGNAL32\0A\00", align 1
@.str.18 = private unnamed_addr constant [17 x i8] c"%s: SUBMITURB32\0A\00", align 1
@.str.19 = private unnamed_addr constant [15 x i8] c"%s: REAPURB32\0A\00", align 1
@.str.20 = private unnamed_addr constant [21 x i8] c"%s: REAPURBNDELAY32\0A\00", align 1
@.str.21 = private unnamed_addr constant [13 x i8] c"%s: IOCTL32\0A\00", align 1
@.str.22 = private unnamed_addr constant [16 x i8] c"%s: DISCARDURB\0A\00", align 1
@.str.23 = private unnamed_addr constant [13 x i8] c"%s: REAPURB\0A\00", align 1
@.str.24 = private unnamed_addr constant [19 x i8] c"%s: REAPURBNDELAY\0A\00", align 1
@.str.25 = private unnamed_addr constant [16 x i8] c"%s: DISCSIGNAL\0A\00", align 1
@.str.26 = private unnamed_addr constant [20 x i8] c"%s: CLAIMINTERFACE\0A\00", align 1
@.str.27 = private unnamed_addr constant [22 x i8] c"%s: RELEASEINTERFACE\0A\00", align 1
@.str.28 = private unnamed_addr constant [11 x i8] c"%s: IOCTL\0A\00", align 1
@.str.29 = private unnamed_addr constant [16 x i8] c"%s: CLAIM_PORT\0A\00", align 1
@.str.30 = private unnamed_addr constant [18 x i8] c"%s: RELEASE_PORT\0A\00", align 1
@.str.31 = private unnamed_addr constant [83 x i8] c"control urb: bRequestType=%02x bRequest=%02x wValue=%04x wIndex=%04x wLength=%04x\0A\00", align 1
@.str.32 = private unnamed_addr constant [3 x i8] c"\017\00", align 1
@.str.33 = private unnamed_addr constant [66 x i8] c"usbfs: USBDEVFS_CONTROL failed cmd %s rqt %u rq %u len %u ret %d\0A\00", align 1
@.str.34 = private unnamed_addr constant [62 x i8] c"usbfs: process %d (%s) did not claim interface %u before use\0A\00", align 1
@usbfs_memory_usage = internal global %struct.atomic_t zeroinitializer, align 4
@kernel_stack = external global i64, align 8
@snoop_urb.types = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.36, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0)], align 16
@.str.35 = private unnamed_addr constant [5 x i8] c"isoc\00", align 1
@.str.36 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str.37 = private unnamed_addr constant [5 x i8] c"ctrl\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"bulk\00", align 1
@snoop_urb.dirs = internal global [2 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.39, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.40, i32 0, i32 0)], align 16
@.str.39 = private unnamed_addr constant [4 x i8] c"out\00", align 1
@.str.40 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.41 = private unnamed_addr constant [35 x i8] c"userurb %p, ep%d %s-%s, length %u\0A\00", align 1
@.str.42 = private unnamed_addr constant [52 x i8] c"userurb %p, ep%d %s-%s, actual_length %u status %d\0A\00", align 1
@.str.43 = private unnamed_addr constant [35 x i8] c"ep%d %s-%s, length %u, timeout %d\0A\00", align 1
@.str.44 = private unnamed_addr constant [41 x i8] c"ep%d %s-%s, actual_length %u, status %d\0A\00", align 1
@.str.45 = private unnamed_addr constant [7 x i8] c"data: \00", align 1
@.str.46 = private unnamed_addr constant [20 x i8] c"include/linux/usb.h\00", align 1
@.str.47 = private unnamed_addr constant [62 x i8] c"usbfs: interface %d claimed by %s while '%s' sets config #%d\0A\00", align 1
@.str.48 = private unnamed_addr constant [35 x i8] c"usbfs: usb_submit_urb returned %d\0A\00", align 1
@.str.49 = private unnamed_addr constant [28 x i8] c"include/linux/scatterlist.h\00", align 1
@phys_base = external global i64, align 8
@.str.50 = private unnamed_addr constant [14 x i8] c"urb complete\0A\00", align 1
@.str.51 = private unnamed_addr constant [21 x i8] c"disconnect by usbfs\0A\00", align 1
@.str.52 = private unnamed_addr constant [35 x i8] c"port %d claimed by process %d: %s\0A\00", align 1
@usbdev_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.53 = private unnamed_addr constant [10 x i8] c"&ps->wait\00", align 1
@.str.54 = private unnamed_addr constant [26 x i8] c"opened by process %d: %s\0A\00", align 1
@usb_bus_type = external global %struct.bus_type, align 8
@llvm.used = appending global [2 x i8*] [i8* bitcast (%struct.kernel_param* @__param_usbfs_snoop to i8*), i8* bitcast (%struct.kernel_param* @__param_usbfs_memory_mb to i8*)], section "llvm.metadata"

; Function Attrs: noinline nounwind uwtable
define internal void @smp_send_stop() #0 {
  %1 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8
  call void %1(i32 0)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @smp_send_reschedule(i32) #0 {
  %2 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8
  call void %2(i32 %0)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @smp_prepare_cpus(i32) #0 {
  %2 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8
  call void %2(i32 %0)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @__cpu_up(i32, %struct.task_struct*) #0 {
  %3 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8
  %4 = call i32 %3(i32 %0, %struct.task_struct* %1)
  ret i32 %4
}

; Function Attrs: noinline nounwind uwtable
define internal void @smp_cpus_done(i32) #0 {
  %2 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8
  call void %2(i32 %0)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
  %1 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8
  call void %1()
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i8* @acpi_os_allocate(i64) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = icmp eq i64* %2, %3
  %7 = zext i1 %6 to i32
  %8 = call i64 @arch_local_save_flags()
  %9 = icmp eq i64* %4, %5
  %10 = zext i1 %9 to i32
  %11 = call i32 @arch_irqs_disabled_flags(i64 %8)
  %12 = icmp ne i32 %11, 0
  %13 = select i1 %12, i32 32, i32 208
  %14 = call i8* @kmalloc(i64 %0, i32 %13)
  ret i8* %14
}

; Function Attrs: noinline nounwind uwtable
define internal i8* @acpi_os_acquire_object(%struct.kmem_cache*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = icmp eq i64* %2, %3
  %7 = zext i1 %6 to i32
  %8 = call i64 @arch_local_save_flags()
  %9 = icmp eq i64* %4, %5
  %10 = zext i1 %9 to i32
  %11 = call i32 @arch_irqs_disabled_flags(i64 %8)
  %12 = icmp ne i32 %11, 0
  %13 = select i1 %12, i32 32, i32 208
  %14 = call i8* @kmem_cache_zalloc(%struct.kmem_cache* %0, i32 %13)
  ret i8* %14
}

; Function Attrs: noinline nounwind uwtable
define internal i64 @acpi_os_get_thread_id() #0 {
  %1 = call %struct.task_struct* @get_current()
  %2 = ptrtoint %struct.task_struct* %1 to i64
  ret i64 %2
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @driver_probe(%struct.usb_interface*, %struct.usb_device_id*) #0 {
  ret i32 -19
}

; Function Attrs: noinline nounwind uwtable
define internal void @driver_disconnect(%struct.usb_interface*) #0 {
  %2 = call i8* @usb_get_intfdata(%struct.usb_interface* %0)
  %3 = bitcast i8* %2 to %struct.dev_state*
  %4 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 0
  %5 = load %struct.usb_host_interface*, %struct.usb_host_interface** %4, align 8
  %6 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %5, i32 0, i32 0
  %7 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %6, i32 0, i32 2
  %8 = load i8, i8* %7, align 2
  %9 = zext i8 %8 to i32
  %10 = icmp ne %struct.dev_state* %3, null
  br i1 %10, label %11, label %25

; <label>:11:                                     ; preds = %1
  %12 = zext i32 %9 to i64
  %13 = icmp ult i64 %12, 64
  %14 = xor i1 %13, true
  %15 = xor i1 %14, true
  %16 = zext i1 %15 to i32
  %17 = sext i32 %16 to i64
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %19, label %21

; <label>:19:                                     ; preds = %11
  %20 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %20, i32 %9, i64* %20) #5, !srcloc !1
  br label %24

; <label>:21:                                     ; preds = %11
  %22 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 7
  %23 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %22, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.4, i32 0, i32 0), i32 %9)
  br label %24

; <label>:24:                                     ; preds = %21, %19
  call void @usb_set_intfdata(%struct.usb_interface* %0, i8* null)
  call void @destroy_async_on_interface(%struct.dev_state* %3, i32 %9)
  br label %25

; <label>:25:                                     ; preds = %1, %24
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @driver_suspend(%struct.usb_interface*, i32) #0 {
  %3 = alloca %struct.pm_message, align 4
  %4 = getelementptr inbounds %struct.pm_message, %struct.pm_message* %3, i32 0, i32 0
  store i32 %1, i32* %4, align 4
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @driver_resume(%struct.usb_interface*) #0 {
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define internal i64 @usbdev_lseek(%struct.file*, i64, i32) #0 {
  %4 = call %struct.inode* @file_inode(%struct.file* %0)
  %5 = getelementptr inbounds %struct.inode, %struct.inode* %4, i32 0, i32 23
  call void @mutex_lock(%struct.mutex* %5)
  switch i32 %2, label %14 [
    i32 0, label %6
    i32 1, label %8
  ]

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 9
  store i64 %1, i64* %7, align 8
  br label %.sink.split

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 9
  %10 = load i64, i64* %9, align 8
  %11 = add nsw i64 %10, %1
  store i64 %11, i64* %9, align 8
  br label %.sink.split

.sink.split:                                      ; preds = %6, %8
  %12 = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 9
  %13 = load i64, i64* %12, align 8
  br label %14

; <label>:14:                                     ; preds = %.sink.split, %3
  %.0 = phi i64 [ -22, %3 ], [ %13, %.sink.split ]
  %15 = call %struct.inode* @file_inode(%struct.file* %0)
  %16 = getelementptr inbounds %struct.inode, %struct.inode* %15, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %16)
  ret i64 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i64 @usbdev_read(%struct.file*, i8*, i64, i64*) #0 {
  %5 = alloca %struct.usb_device_descriptor, align 1
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %9 = load i8*, i8** %8, align 8
  %10 = bitcast i8* %9 to %struct.dev_state*
  %11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %10, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %11, align 8
  %13 = load i64, i64* %3, align 8
  %14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 11
  call void @device_lock(%struct.device* %14)
  %15 = call i32 @connected(%struct.dev_state* %10)
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %17, label %.critedge

; <label>:17:                                     ; preds = %4
  %18 = icmp slt i64 %13, 0
  br i1 %18, label %.critedge, label %19

; <label>:19:                                     ; preds = %17
  %20 = icmp ult i64 %13, 18
  br i1 %20, label %21, label %54

; <label>:21:                                     ; preds = %19
  %22 = icmp uge i64 18, 64
  %23 = bitcast %struct.usb_device_descriptor* %5 to i8*
  %24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 12
  %25 = bitcast %struct.usb_device_descriptor* %24 to i8*
  br i1 %22, label %26, label %28

; <label>:26:                                     ; preds = %21
  %27 = call i8* @__memcpy(i8* %23, i8* %25, i64 18)
  br label %29

; <label>:28:                                     ; preds = %21
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %25, i64 18, i32 1, i1 false)
  br label %29

; <label>:29:                                     ; preds = %26, %28
  %.0 = phi i8* [ %27, %26 ], [ %23, %28 ]
  %30 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %5, i32 0, i32 2
  %31 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %5, i32 0, i32 7
  %32 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %5, i32 0, i32 8
  %33 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %5, i32 0, i32 9
  %34 = sub i64 18, %13
  %35 = trunc i64 %34 to i32
  %36 = zext i32 %35 to i64
  %37 = icmp ugt i64 %36, %2
  %38 = trunc i64 %2 to i32
  %.03 = select i1 %37, i32 %38, i32 %35
  %39 = bitcast %struct.usb_device_descriptor* %5 to i8*
  %40 = getelementptr inbounds i8, i8* %39, i64 %13
  call void @might_fault() #5
  %41 = call i64 @_copy_to_user(i8* %1, i8* %40, i32 %.03) #5
  %42 = trunc i64 %41 to i32
  %43 = icmp ne i32 %42, 0
  br i1 %43, label %.critedge, label %44

; <label>:44:                                     ; preds = %29
  %45 = zext i32 %.03 to i64
  %46 = load i64, i64* %3, align 8
  %47 = add nsw i64 %46, %45
  store i64 %47, i64* %3, align 8
  %48 = zext i32 %.03 to i64
  %49 = getelementptr inbounds i8, i8* %1, i64 %48
  %50 = zext i32 %.03 to i64
  %51 = sub i64 %2, %50
  %52 = zext i32 %.03 to i64
  %53 = add nsw i64 0, %52
  br label %54

; <label>:54:                                     ; preds = %19, %44, %132
  %.110 = phi i8* [ %.211, %132 ], [ %49, %44 ], [ %1, %19 ]
  %.17 = phi i64 [ %.28, %132 ], [ %51, %44 ], [ %2, %19 ]
  %.15 = phi i64 [ %.2, %132 ], [ %53, %44 ], [ 0, %19 ]
  %.02 = phi i64 [ %134, %132 ], [ 18, %44 ], [ 18, %19 ]
  %.01 = phi i32 [ %135, %132 ], [ 0, %44 ], [ 0, %19 ]
  %55 = icmp ne i64 %.17, 0
  br i1 %55, label %56, label %.critedge

; <label>:56:                                     ; preds = %54
  %57 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 12
  %58 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %57, i32 0, i32 13
  %59 = load i8, i8* %58, align 1
  %60 = zext i8 %59 to i32
  %61 = icmp slt i32 %.01, %60
  br i1 %61, label %62, label %.critedge

; <label>:62:                                     ; preds = %56
  %63 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 18
  %64 = load i8**, i8*** %63, align 8
  %65 = sext i32 %.01 to i64
  %66 = getelementptr inbounds i8*, i8** %64, i64 %65
  %67 = load i8*, i8** %66, align 8
  %68 = bitcast i8* %67 to %struct.usb_config_descriptor*
  %69 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %68, i32 0, i32 2
  %70 = load i16, i16* %69, align 1
  %71 = zext i16 %70 to i32
  %72 = load i64, i64* %3, align 8
  %73 = zext i32 %71 to i64
  %74 = add nsw i64 %.02, %73
  %75 = icmp slt i64 %72, %74
  br i1 %75, label %76, label %132

; <label>:76:                                     ; preds = %62
  %77 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 14
  %78 = load %struct.usb_host_config*, %struct.usb_host_config** %77, align 8
  %79 = sext i32 %.01 to i64
  %80 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %78, i64 %79
  %81 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %80, i32 0, i32 0
  %82 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %81, i32 0, i32 2
  %83 = load i16, i16* %82, align 2
  %84 = zext i16 %83 to i32
  %85 = zext i32 %71 to i64
  %86 = load i64, i64* %3, align 8
  %87 = sub nsw i64 %86, %.02
  %88 = sub nsw i64 %85, %87
  %89 = trunc i64 %88 to i32
  %90 = zext i32 %89 to i64
  %91 = icmp ugt i64 %90, %.17
  %92 = trunc i64 %.17 to i32
  %. = select i1 %91, i32 %92, i32 %89
  %93 = zext i32 %84 to i64
  %94 = load i64, i64* %3, align 8
  %95 = sub nsw i64 %94, %.02
  %96 = icmp sgt i64 %93, %95
  br i1 %96, label %97, label %122

; <label>:97:                                     ; preds = %76
  %98 = load i64, i64* %3, align 8
  %99 = sub nsw i64 %98, %.02
  %100 = zext i32 %84 to i64
  %101 = sub nsw i64 %100, %99
  %102 = trunc i64 %101 to i32
  %103 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 18
  %104 = load i8**, i8*** %103, align 8
  %105 = sext i32 %.01 to i64
  %106 = getelementptr inbounds i8*, i8** %104, i64 %105
  %107 = load i8*, i8** %106, align 8
  %108 = load i64, i64* %3, align 8
  %109 = sub nsw i64 %108, %.02
  %110 = getelementptr inbounds i8, i8* %107, i64 %109
  store i32 %., i32* %6, align 4
  store i32 %102, i32* %7, align 4
  %111 = icmp eq i32* %6, %7
  %112 = zext i1 %111 to i32
  %113 = load i32, i32* %6, align 4
  %114 = load i32, i32* %7, align 4
  %115 = icmp ult i32 %113, %114
  %116 = load i32, i32* %6, align 4
  %117 = load i32, i32* %7, align 4
  %118 = select i1 %115, i32 %116, i32 %117
  call void @might_fault() #5
  %119 = call i64 @_copy_to_user(i8* %.110, i8* %110, i32 %118) #5
  %120 = trunc i64 %119 to i32
  %121 = icmp ne i32 %120, 0
  br i1 %121, label %.critedge, label %122

; <label>:122:                                    ; preds = %97, %76
  %123 = zext i32 %. to i64
  %124 = load i64, i64* %3, align 8
  %125 = add nsw i64 %124, %123
  store i64 %125, i64* %3, align 8
  %126 = zext i32 %. to i64
  %127 = getelementptr inbounds i8, i8* %.110, i64 %126
  %128 = zext i32 %. to i64
  %129 = sub i64 %.17, %128
  %130 = zext i32 %. to i64
  %131 = add nsw i64 %.15, %130
  br label %132

; <label>:132:                                    ; preds = %122, %62
  %.211 = phi i8* [ %127, %122 ], [ %.110, %62 ]
  %.28 = phi i64 [ %129, %122 ], [ %.17, %62 ]
  %.2 = phi i64 [ %131, %122 ], [ %.15, %62 ]
  %133 = zext i32 %71 to i64
  %134 = add nsw i64 %.02, %133
  %135 = add nsw i32 %.01, 1
  br label %54

.critedge:                                        ; preds = %56, %54, %97, %29, %17, %4
  %.3 = phi i64 [ -19, %4 ], [ -22, %17 ], [ -14, %29 ], [ -14, %97 ], [ %.15, %54 ], [ %.15, %56 ]
  %136 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 11
  call void @device_unlock(%struct.device* %136)
  ret i64 %.3
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usbdev_poll(%struct.file*, %struct.poll_table_struct*) #0 {
  %3 = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %4 = load i8*, i8** %3, align 8
  %5 = bitcast i8* %4 to %struct.dev_state*
  %6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 6
  call void @poll_wait(%struct.file* %0, %struct.__wait_queue_head* %6, %struct.poll_table_struct* %1)
  %7 = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 8
  %8 = load i32, i32* %7, align 4
  %9 = and i32 %8, 2
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %11, label %16

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 5
  %13 = call i32 @list_empty(%struct.list_head* %12)
  %14 = icmp ne i32 %13, 0
  %15 = or i32 0, 260
  %. = select i1 %14, i32 0, i32 %15
  br label %16

; <label>:16:                                     ; preds = %11, %2
  %.0 = phi i32 [ 0, %2 ], [ %., %11 ]
  %17 = call i32 @connected(%struct.dev_state* %5)
  %18 = icmp ne i32 %17, 0
  %19 = or i32 %.0, 24
  %.0. = select i1 %18, i32 %.0, i32 %19
  ret i32 %.0.
}

; Function Attrs: noinline nounwind uwtable
define internal i64 @usbdev_ioctl(%struct.file*, i32, i64) #0 {
  %4 = inttoptr i64 %2 to i8*
  %5 = call i64 @usbdev_do_ioctl(%struct.file* %0, i32 %1, i8* %4)
  %6 = trunc i64 %5 to i32
  %7 = sext i32 %6 to i64
  ret i64 %7
}

; Function Attrs: noinline nounwind uwtable
define internal i64 @usbdev_compat_ioctl(%struct.file*, i32, i64) #0 {
  %4 = trunc i64 %2 to i32
  %5 = call i8* @compat_ptr(i32 %4)
  %6 = call i64 @usbdev_do_ioctl(%struct.file* %0, i32 %1, i8* %5)
  %7 = trunc i64 %6 to i32
  %8 = sext i32 %7 to i64
  ret i64 %8
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usbdev_open(%struct.inode*, %struct.file*) #0 {
  %3 = alloca %struct.raw_spinlock, align 2
  %4 = call i8* @__kmalloc(i64 144, i32 208) #5
  %5 = bitcast i8* %4 to %struct.dev_state*
  %6 = icmp ne %struct.dev_state* %5, null
  br i1 %6, label %7, label %72

; <label>:7:                                      ; preds = %2
  call void @mutex_lock(%struct.mutex* @usbfs_mutex)
  %8 = call i32 @imajor(%struct.inode* %0)
  %9 = icmp eq i32 %8, 189
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %7
  %11 = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 13
  %12 = load i32, i32* %11, align 4
  %13 = call %struct.usb_device* @usbdev_lookup_by_devt(i32 %12)
  br label %14

; <label>:14:                                     ; preds = %10, %7
  %.01 = phi %struct.usb_device* [ %13, %10 ], [ null, %7 ]
  call void @mutex_unlock(%struct.mutex* @usbfs_mutex)
  %15 = icmp ne %struct.usb_device* %.01, null
  br i1 %15, label %16, label %72

; <label>:16:                                     ; preds = %14
  %17 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %.01, i32 0, i32 11
  call void @device_lock(%struct.device* %17)
  %18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %.01, i32 0, i32 3
  %19 = load i32, i32* %18, align 8
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %70, label %21

; <label>:21:                                     ; preds = %16
  %22 = call i32 @usb_autoresume_device(%struct.usb_device* %.01)
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %70, label %24

; <label>:24:                                     ; preds = %21
  %25 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 1
  store %struct.usb_device* %.01, %struct.usb_device** %25, align 8
  %26 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 2
  store %struct.file* %1, %struct.file** %26, align 8
  %27 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 3
  %28 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %27)
  %29 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 3
  %30 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %29, i32 0, i32 0
  %31 = bitcast %union.anon.0* %30 to %struct.raw_spinlock*
  %32 = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %3, i32 0, i32 0
  %33 = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %32, i32 0, i32 0
  %34 = bitcast %union.anon.1* %33 to i16*
  store i16 0, i16* %34, align 2
  %35 = bitcast %struct.raw_spinlock* %31 to i8*
  %36 = bitcast %struct.raw_spinlock* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %35, i8* %36, i64 2, i32 2, i1 false)
  %37 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 0
  call void @INIT_LIST_HEAD(%struct.list_head* %37)
  %38 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 4
  call void @INIT_LIST_HEAD(%struct.list_head* %38)
  %39 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 5
  call void @INIT_LIST_HEAD(%struct.list_head* %39)
  %40 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 6
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %40, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.53, i32 0, i32 0), %struct.lock_class_key* @usbdev_open.__key)
  %41 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 7
  store i32 0, i32* %41, align 8
  %42 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %43 = call %struct.pid* @task_pid(%struct.task_struct* %42)
  %44 = call %struct.pid* @get_pid(%struct.pid* %43)
  %45 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 8
  store %struct.pid* %44, %struct.pid** %45, align 8
  %46 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %47 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %46, i32 0, i32 63
  %48 = load %struct.cred*, %struct.cred** %47, align 8
  %49 = call %struct.cred* @get_cred(%struct.cred* %48)
  %50 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 9
  store %struct.cred* %49, %struct.cred** %50, align 8
  %51 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 10
  store i8* null, i8** %51, align 8
  %52 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 11
  store i64 0, i64* %52, align 8
  %53 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %54 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 12
  call void @security_task_getsecid(%struct.task_struct* %53, i32* %54)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !3
  %55 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 0
  %56 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %.01, i32 0, i32 27
  call void @list_add_tail(%struct.list_head* %55, %struct.list_head* %56)
  %57 = bitcast %struct.dev_state* %5 to i8*
  %58 = getelementptr inbounds %struct.file, %struct.file* %1, i32 0, i32 15
  store i8* %57, i8** %58, align 8
  %59 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %.01, i32 0, i32 11
  call void @device_unlock(%struct.device* %59)
  %60 = load i8, i8* @usbfs_snoop, align 1
  %61 = trunc i8 %60 to i1
  br i1 %61, label %62, label %74

; <label>:62:                                     ; preds = %24
  %63 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %.01, i32 0, i32 11
  %64 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %65 = call i32 @task_pid_nr(%struct.task_struct* %64)
  %66 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %67 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %66, i32 0, i32 64
  %68 = getelementptr inbounds [16 x i8], [16 x i8]* %67, i32 0, i32 0
  %69 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %63, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.54, i32 0, i32 0), i32 %65, i8* %68)
  br label %74

; <label>:70:                                     ; preds = %21, %16
  %.0 = phi i32 [ -19, %16 ], [ %22, %21 ]
  %71 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %.01, i32 0, i32 11
  call void @device_unlock(%struct.device* %71)
  call void @usb_put_dev(%struct.usb_device* %.01)
  br label %72

; <label>:72:                                     ; preds = %14, %2, %70
  %.1 = phi i32 [ %.0, %70 ], [ -12, %2 ], [ -19, %14 ]
  %73 = bitcast %struct.dev_state* %5 to i8*
  call void @kfree(i8* %73)
  br label %74

; <label>:74:                                     ; preds = %62, %24, %72
  %.02 = phi i32 [ %.1, %72 ], [ %22, %24 ], [ %22, %62 ]
  ret i32 %.02
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usbdev_release(%struct.inode*, %struct.file*) #0 {
  %3 = getelementptr inbounds %struct.file, %struct.file* %1, i32 0, i32 15
  %4 = load i8*, i8** %3, align 8
  %5 = bitcast i8* %4 to %struct.dev_state*
  %6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %6, align 8
  %8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 11
  call void @device_lock(%struct.device* %8)
  call void @usb_hub_release_all_ports(%struct.usb_device* %7, %struct.dev_state* %5)
  %9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %9)
  br label %10

; <label>:10:                                     ; preds = %23, %2
  %.01 = phi i32 [ 0, %2 ], [ %24, %23 ]
  %11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 11
  %12 = load i64, i64* %11, align 8
  %13 = icmp ne i64 %12, 0
  %14 = zext i32 %.01 to i64
  %15 = icmp ult i64 %14, 64
  %16 = select i1 %13, i1 %15, i1 false
  br i1 %16, label %17, label %25

; <label>:17:                                     ; preds = %10
  %18 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 11
  %19 = call i32 @variable_test_bit(i32 %.01, i64* %18)
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %21, label %23

; <label>:21:                                     ; preds = %17
  %22 = call i32 @releaseintf(%struct.dev_state* %5, i32 %.01)
  br label %23

; <label>:23:                                     ; preds = %17, %21
  %24 = add i32 %.01, 1
  br label %10

; <label>:25:                                     ; preds = %10
  call void @destroy_all_async(%struct.dev_state* %5)
  %26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 11
  call void @device_unlock(%struct.device* %26)
  call void @usb_put_dev(%struct.usb_device* %7)
  %27 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 8
  %28 = load %struct.pid*, %struct.pid** %27, align 8
  call void @put_pid(%struct.pid* %28)
  %29 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 9
  %30 = load %struct.cred*, %struct.cred** %29, align 8
  call void @put_cred(%struct.cred* %30)
  br label %31

; <label>:31:                                     ; preds = %34, %25
  %32 = call %struct.async* @async_getcompleted(%struct.dev_state* %5)
  %33 = icmp ne %struct.async* %32, null
  br i1 %33, label %34, label %35

; <label>:34:                                     ; preds = %31
  call void @free_async(%struct.async* %32)
  br label %31

; <label>:35:                                     ; preds = %31
  %36 = bitcast %struct.dev_state* %5 to i8*
  call void @kfree(i8* %36)
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define i32 @usb_devio_init() #0 section ".init.text" {
  %1 = call i32 @register_chrdev_region(i32 198180864, i32 8192, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i32 0, i32 0))
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %3, label %5

; <label>:3:                                      ; preds = %0
  %4 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.2, i32 0, i32 0))
  br label %11

; <label>:5:                                      ; preds = %0
  call void @cdev_init(%struct.cdev* @usb_device_cdev, %struct.file_operations* @usbdev_file_operations)
  %6 = call i32 @cdev_add(%struct.cdev* @usb_device_cdev, i32 198180864, i32 8192)
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %5
  %9 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.3, i32 0, i32 0), i32 189)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  br label %11

; <label>:10:                                     ; preds = %5
  call void @usb_register_notify(%struct.notifier_block* @usbdev_nb)
  br label %11

; <label>:11:                                     ; preds = %8, %10, %3
  %.0 = phi i32 [ %1, %3 ], [ %6, %8 ], [ %6, %10 ]
  ret i32 %.0
}

declare i32 @register_chrdev_region(i32, i32, i8*) #1

declare i32 @printk(i8*, ...) #1

declare void @cdev_init(%struct.cdev*, %struct.file_operations*) #1

declare i32 @cdev_add(%struct.cdev*, i32, i32) #1

declare void @usb_register_notify(%struct.notifier_block*) #1

declare void @unregister_chrdev_region(i32, i32) #1

; Function Attrs: noinline nounwind uwtable
define void @usb_devio_cleanup() #0 {
  call void @usb_unregister_notify(%struct.notifier_block* @usbdev_nb)
  call void @cdev_del(%struct.cdev* @usb_device_cdev)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  ret void
}

declare void @usb_unregister_notify(%struct.notifier_block*) #1

declare void @cdev_del(%struct.cdev*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64, i32) #2 {
  %3 = call i8* @__kmalloc(i64 %0, i32 %1)
  ret i8* %3
}

; Function Attrs: noinline nounwind uwtable
define internal i64 @arch_local_save_flags() #0 {
  %1 = call i64 @native_save_fl()
  ret i64 %1
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @arch_irqs_disabled_flags(i64) #0 {
  %2 = and i64 %0, 512
  %3 = icmp ne i64 %2, 0
  %4 = xor i1 %3, true
  %5 = zext i1 %4 to i32
  ret i32 %5
}

declare i8* @__kmalloc(i64, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal i64 @native_save_fl() #0 {
  %1 = alloca i64, align 8
  call void asm sideeffect "# __raw_save_flags\0A\09pushf ; pop $0", "=*rm,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %1) #5, !srcloc !4
  %2 = load i64, i64* %1, align 8
  ret i64 %2
}

; Function Attrs: noinline nounwind uwtable
define internal i8* @kmem_cache_zalloc(%struct.kmem_cache*, i32) #0 {
  %3 = or i32 %1, 32768
  %4 = call i8* @kmem_cache_alloc(%struct.kmem_cache* %0, i32 %3)
  ret i8* %4
}

declare i8* @kmem_cache_alloc(%struct.kmem_cache*, i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #2 {
  %1 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  ret %struct.task_struct* %1
}

; Function Attrs: noinline nounwind uwtable
define internal i8* @usb_get_intfdata(%struct.usb_interface*) #0 {
  %2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 7
  %3 = call i8* @dev_get_drvdata(%struct.device* %2)
  ret i8* %3
}

declare i32 @dev_warn(%struct.device*, i8*, ...) #1

; Function Attrs: noinline nounwind uwtable
define internal void @usb_set_intfdata(%struct.usb_interface*, i8*) #0 {
  %3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 7
  %4 = call i32 @dev_set_drvdata(%struct.device* %3, i8* %1)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @destroy_async_on_interface(%struct.dev_state*, i32) #0 {
  %3 = alloca %struct.list_head, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  call void @INIT_LIST_HEAD(%struct.list_head* %3)
  %6 = icmp eq i64* %4, %5
  %7 = zext i1 %6 to i32
  %8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %9 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %8)
  %10 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %9)
  %11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  %12 = getelementptr inbounds %struct.list_head, %struct.list_head* %11, i32 0, i32 0
  %13 = load %struct.list_head*, %struct.list_head** %12, align 8
  br label %14

; <label>:14:                                     ; preds = %26, %19, %2
  %.sink2 = phi %struct.list_head* [ %13, %2 ], [ %16, %19 ], [ %16, %26 ]
  %15 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink2, i32 0, i32 0
  %16 = load %struct.list_head*, %struct.list_head** %15, align 8
  %17 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  %18 = icmp ne %struct.list_head* %.sink2, %17
  br i1 %18, label %19, label %27

; <label>:19:                                     ; preds = %14
  %20 = bitcast %struct.list_head* %.sink2 to i8*
  %21 = getelementptr inbounds i8, i8* %20, i64 0
  %22 = bitcast i8* %21 to %struct.async*
  %23 = getelementptr inbounds %struct.async, %struct.async* %22, i32 0, i32 5
  %24 = load i32, i32* %23, align 4
  %25 = icmp eq i32 %1, %24
  br i1 %25, label %26, label %14

; <label>:26:                                     ; preds = %19
  call void @list_move_tail(%struct.list_head* %.sink2, %struct.list_head* %3)
  br label %14

; <label>:27:                                     ; preds = %14
  %28 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %28, i64 %10)
  call void @destroy_async(%struct.dev_state* %0, %struct.list_head* %3)
  ret void
}

declare i8* @dev_get_drvdata(%struct.device*) #1

declare i32 @dev_set_drvdata(%struct.device*, i8*) #1

; Function Attrs: noinline nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head*) #0 {
  %2 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %2, align 8
  %3 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 1
  store %struct.list_head* %0, %struct.list_head** %3, align 8
  ret void
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: noinline nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock*) #0 {
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %3 = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %3
}

; Function Attrs: noinline nounwind uwtable
define internal void @list_move_tail(%struct.list_head*, %struct.list_head*) #0 {
  call void @__list_del_entry(%struct.list_head* %0)
  call void @list_add_tail(%struct.list_head* %0, %struct.list_head* %1)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock*, i64) #0 {
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = icmp eq i64* %3, %4
  %6 = zext i1 %5 to i32
  %7 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %8 = bitcast %union.anon.0* %7 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %8, i64 %1)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @destroy_async(%struct.dev_state*, %struct.list_head*) #0 {
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = icmp eq i64* %3, %4
  %8 = zext i1 %7 to i32
  br label %9

; <label>:9:                                      ; preds = %16, %2
  %10 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %11 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %10)
  %12 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %11)
  %13 = call i32 @list_empty(%struct.list_head* %1)
  %14 = icmp ne i32 %13, 0
  %15 = xor i1 %14, true
  br i1 %15, label %16, label %29

; <label>:16:                                     ; preds = %9
  %17 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 0
  %18 = load %struct.list_head*, %struct.list_head** %17, align 8
  %19 = bitcast %struct.list_head* %18 to i8*
  %20 = getelementptr inbounds i8, i8* %19, i64 0
  %21 = bitcast i8* %20 to %struct.async*
  %22 = getelementptr inbounds %struct.async, %struct.async* %21, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %22)
  %23 = getelementptr inbounds %struct.async, %struct.async* %21, i32 0, i32 8
  %24 = load %struct.urb*, %struct.urb** %23, align 8
  %25 = call %struct.urb* @usb_get_urb(%struct.urb* %24)
  %26 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %26, i64 %12)
  call void @usb_kill_urb(%struct.urb* %24)
  call void @usb_free_urb(%struct.urb* %24)
  %27 = icmp eq i64* %5, %6
  %28 = zext i1 %27 to i32
  br label %9

; <label>:29:                                     ; preds = %9
  %30 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %30, i64 %12)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @__list_del_entry(%struct.list_head*) #0 {
  %2 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 1
  %3 = load %struct.list_head*, %struct.list_head** %2, align 8
  %4 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %4, align 8
  call void @__list_del(%struct.list_head* %3, %struct.list_head* %5)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @list_add_tail(%struct.list_head*, %struct.list_head*) #0 {
  %3 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 1
  %4 = load %struct.list_head*, %struct.list_head** %3, align 8
  call void @__list_add(%struct.list_head* %0, %struct.list_head* %4, %struct.list_head* %1)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @__list_del(%struct.list_head*, %struct.list_head*) #0 {
  %3 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 1
  store %struct.list_head* %0, %struct.list_head** %3, align 8
  %4 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 0
  store %struct.list_head* %1, %struct.list_head** %4, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @__list_add(%struct.list_head*, %struct.list_head*, %struct.list_head*) #0 {
  %4 = getelementptr inbounds %struct.list_head, %struct.list_head* %2, i32 0, i32 1
  store %struct.list_head* %0, %struct.list_head** %4, align 8
  %5 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 0
  store %struct.list_head* %2, %struct.list_head** %5, align 8
  %6 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 1
  store %struct.list_head* %1, %struct.list_head** %6, align 8
  %7 = getelementptr inbounds %struct.list_head, %struct.list_head* %1, i32 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %7, align 8
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

; Function Attrs: noinline nounwind uwtable
define internal i32 @list_empty(%struct.list_head*) #0 {
  %2 = getelementptr inbounds %struct.list_head, %struct.list_head* %0, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %2, align 8
  %4 = icmp eq %struct.list_head* %3, %0
  %5 = zext i1 %4 to i32
  ret i32 %5
}

; Function Attrs: noinline nounwind uwtable
define internal void @list_del_init(%struct.list_head*) #0 {
  call void @__list_del_entry(%struct.list_head* %0)
  call void @INIT_LIST_HEAD(%struct.list_head* %0)
  ret void
}

declare %struct.urb* @usb_get_urb(%struct.urb*) #1

declare void @usb_kill_urb(%struct.urb*) #1

declare void @usb_free_urb(%struct.urb*) #1

declare void @mutex_lock(%struct.mutex*) #1

; Function Attrs: noinline nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file*) #0 {
  %2 = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 2
  %3 = load %struct.inode*, %struct.inode** %2, align 8
  ret %struct.inode* %3
}

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: noinline nounwind uwtable
define internal void @device_lock(%struct.device*) #0 {
  %2 = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 5
  call void @mutex_lock(%struct.mutex* %2)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @connected(%struct.dev_state*) #0 {
  %2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 0
  %3 = call i32 @list_empty(%struct.list_head* %2)
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %11, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %6, align 8
  %8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 3
  %9 = load i32, i32* %8, align 8
  %10 = icmp ne i32 %9, 0
  br label %11

; <label>:11:                                     ; preds = %5, %1
  %12 = phi i1 [ false, %1 ], [ %10, %5 ]
  %13 = zext i1 %12 to i32
  ret i32 %13
}

declare i8* @__memcpy(i8*, i8*, i64) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #3

; Function Attrs: noinline nounwind uwtable
define internal void @device_unlock(%struct.device*) #0 {
  %2 = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %2)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @might_fault() #0 {
  %1 = call i32 @_cond_resched()
  ret void
}

declare i64 @_copy_to_user(i8*, i8*, i32) #1

declare i32 @_cond_resched() #1

; Function Attrs: noinline nounwind uwtable
define internal void @poll_wait(%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*) #0 {
  %4 = icmp ne %struct.poll_table_struct* %2, null
  br i1 %4, label %5, label %13

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %2, i32 0, i32 0
  %7 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %6, align 8
  %8 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %7, null
  %9 = icmp ne %struct.__wait_queue_head* %1, null
  %or.cond = and i1 %8, %9
  br i1 %or.cond, label %10, label %13

; <label>:10:                                     ; preds = %5
  %11 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %2, i32 0, i32 0
  %12 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %11, align 8
  call void %12(%struct.file* %0, %struct.__wait_queue_head* %1, %struct.poll_table_struct* %2)
  br label %13

; <label>:13:                                     ; preds = %10, %5, %3
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i64 @usbdev_do_ioctl(%struct.file*, i32, i8*) #0 {
  %4 = alloca %struct.timespec, align 8
  %5 = alloca %struct.timespec, align 8
  %6 = alloca %struct.timespec, align 8
  %7 = alloca %struct.timespec, align 8
  %8 = alloca %struct.timespec, align 8
  %9 = alloca %struct.timespec, align 8
  %10 = alloca %struct.timespec, align 8
  %11 = alloca %struct.timespec, align 8
  %12 = alloca %struct.timespec, align 8
  %13 = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 15
  %14 = load i8*, i8** %13, align 8
  %15 = bitcast i8* %14 to %struct.dev_state*
  %16 = call %struct.inode* @file_inode(%struct.file* %0)
  %17 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %15, i32 0, i32 1
  %18 = load %struct.usb_device*, %struct.usb_device** %17, align 8
  %19 = getelementptr inbounds %struct.file, %struct.file* %0, i32 0, i32 8
  %20 = load i32, i32* %19, align 4
  %21 = and i32 %20, 2
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %23, label %348

; <label>:23:                                     ; preds = %3
  %24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  call void @device_lock(%struct.device* %24)
  %25 = call i32 @connected(%struct.dev_state* %15)
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %23
  %28 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  call void @device_unlock(%struct.device* %28)
  br label %348

; <label>:29:                                     ; preds = %23
  switch i32 %1, label %333 [
    i32 -1072147200, label %30
    i32 -1072147198, label %49
    i32 -2147199741, label %68
    i32 21780, label %87
    i32 -2147199723, label %95
    i32 1090802952, label %114
    i32 1074287889, label %122
    i32 -2146937596, label %130
    i32 -2147199739, label %138
    i32 -2143791862, label %146
    i32 -1072671488, label %165
    i32 -1072671486, label %185
    i32 -2146937586, label %205
    i32 -2144578294, label %213
    i32 1074025740, label %232
    i32 1074025741, label %240
    i32 -1072933614, label %248
    i32 21771, label %257
    i32 1074287884, label %265
    i32 1074287885, label %273
    i32 -2146413298, label %281
    i32 -2147199729, label %289
    i32 -2147199728, label %297
    i32 -1072671470, label %305
    i32 -2147199720, label %313
    i32 -2147199719, label %321
    i32 -2147199718, label %329
    i32 -2130160357, label %331
  ]

; <label>:30:                                     ; preds = %29
  %31 = load i8, i8* @usbfs_snoop, align 1
  %32 = trunc i8 %31 to i1
  br i1 %32, label %33, label %36

; <label>:33:                                     ; preds = %30
  %34 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %35 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %34, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %36

; <label>:36:                                     ; preds = %30, %33
  %37 = call i32 @proc_control(%struct.dev_state* %15, i8* %2)
  %38 = icmp sge i32 %37, 0
  br i1 %38, label %39, label %333

; <label>:39:                                     ; preds = %36
  %40 = getelementptr inbounds %struct.inode, %struct.inode* %16, i32 0, i32 16
  %41 = call { i64, i64 } @current_kernel_time()
  %42 = bitcast %struct.timespec* %4 to { i64, i64 }*
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %42, i32 0, i32 0
  %44 = extractvalue { i64, i64 } %41, 0
  store i64 %44, i64* %43, align 8
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %42, i32 0, i32 1
  %46 = extractvalue { i64, i64 } %41, 1
  store i64 %46, i64* %45, align 8
  %47 = bitcast %struct.timespec* %40 to i8*
  %48 = bitcast %struct.timespec* %4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %47, i8* %48, i64 16, i32 8, i1 false)
  br label %333

; <label>:49:                                     ; preds = %29
  %50 = load i8, i8* @usbfs_snoop, align 1
  %51 = trunc i8 %50 to i1
  br i1 %51, label %52, label %55

; <label>:52:                                     ; preds = %49
  %53 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %54 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %53, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %55

; <label>:55:                                     ; preds = %49, %52
  %56 = call i32 @proc_bulk(%struct.dev_state* %15, i8* %2)
  %57 = icmp sge i32 %56, 0
  br i1 %57, label %58, label %333

; <label>:58:                                     ; preds = %55
  %59 = getelementptr inbounds %struct.inode, %struct.inode* %16, i32 0, i32 16
  %60 = call { i64, i64 } @current_kernel_time()
  %61 = bitcast %struct.timespec* %5 to { i64, i64 }*
  %62 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 0
  %63 = extractvalue { i64, i64 } %60, 0
  store i64 %63, i64* %62, align 8
  %64 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 1
  %65 = extractvalue { i64, i64 } %60, 1
  store i64 %65, i64* %64, align 8
  %66 = bitcast %struct.timespec* %59 to i8*
  %67 = bitcast %struct.timespec* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %66, i8* %67, i64 16, i32 8, i1 false)
  br label %333

; <label>:68:                                     ; preds = %29
  %69 = load i8, i8* @usbfs_snoop, align 1
  %70 = trunc i8 %69 to i1
  br i1 %70, label %71, label %74

; <label>:71:                                     ; preds = %68
  %72 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %73 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %72, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %74

; <label>:74:                                     ; preds = %68, %71
  %75 = call i32 @proc_resetep(%struct.dev_state* %15, i8* %2)
  %76 = icmp sge i32 %75, 0
  br i1 %76, label %77, label %333

; <label>:77:                                     ; preds = %74
  %78 = getelementptr inbounds %struct.inode, %struct.inode* %16, i32 0, i32 16
  %79 = call { i64, i64 } @current_kernel_time()
  %80 = bitcast %struct.timespec* %6 to { i64, i64 }*
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %80, i32 0, i32 0
  %82 = extractvalue { i64, i64 } %79, 0
  store i64 %82, i64* %81, align 8
  %83 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %80, i32 0, i32 1
  %84 = extractvalue { i64, i64 } %79, 1
  store i64 %84, i64* %83, align 8
  %85 = bitcast %struct.timespec* %78 to i8*
  %86 = bitcast %struct.timespec* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %85, i8* %86, i64 16, i32 8, i1 false)
  br label %333

; <label>:87:                                     ; preds = %29
  %88 = load i8, i8* @usbfs_snoop, align 1
  %89 = trunc i8 %88 to i1
  br i1 %89, label %90, label %93

; <label>:90:                                     ; preds = %87
  %91 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %92 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %91, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %93

; <label>:93:                                     ; preds = %87, %90
  %94 = call i32 @proc_resetdevice(%struct.dev_state* %15)
  br label %333

; <label>:95:                                     ; preds = %29
  %96 = load i8, i8* @usbfs_snoop, align 1
  %97 = trunc i8 %96 to i1
  br i1 %97, label %98, label %101

; <label>:98:                                     ; preds = %95
  %99 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %100 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %99, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %101

; <label>:101:                                    ; preds = %95, %98
  %102 = call i32 @proc_clearhalt(%struct.dev_state* %15, i8* %2)
  %103 = icmp sge i32 %102, 0
  br i1 %103, label %104, label %333

; <label>:104:                                    ; preds = %101
  %105 = getelementptr inbounds %struct.inode, %struct.inode* %16, i32 0, i32 16
  %106 = call { i64, i64 } @current_kernel_time()
  %107 = bitcast %struct.timespec* %7 to { i64, i64 }*
  %108 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %107, i32 0, i32 0
  %109 = extractvalue { i64, i64 } %106, 0
  store i64 %109, i64* %108, align 8
  %110 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %107, i32 0, i32 1
  %111 = extractvalue { i64, i64 } %106, 1
  store i64 %111, i64* %110, align 8
  %112 = bitcast %struct.timespec* %105 to i8*
  %113 = bitcast %struct.timespec* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %112, i8* %113, i64 16, i32 8, i1 false)
  br label %333

; <label>:114:                                    ; preds = %29
  %115 = load i8, i8* @usbfs_snoop, align 1
  %116 = trunc i8 %115 to i1
  br i1 %116, label %117, label %120

; <label>:117:                                    ; preds = %114
  %118 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %119 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %118, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %120

; <label>:120:                                    ; preds = %114, %117
  %121 = call i32 @proc_getdriver(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:122:                                    ; preds = %29
  %123 = load i8, i8* @usbfs_snoop, align 1
  %124 = trunc i8 %123 to i1
  br i1 %124, label %125, label %128

; <label>:125:                                    ; preds = %122
  %126 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %127 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %126, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %128

; <label>:128:                                    ; preds = %122, %125
  %129 = call i32 @proc_connectinfo(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:130:                                    ; preds = %29
  %131 = load i8, i8* @usbfs_snoop, align 1
  %132 = trunc i8 %131 to i1
  br i1 %132, label %133, label %136

; <label>:133:                                    ; preds = %130
  %134 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %135 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %134, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %136

; <label>:136:                                    ; preds = %130, %133
  %137 = call i32 @proc_setintf(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:138:                                    ; preds = %29
  %139 = load i8, i8* @usbfs_snoop, align 1
  %140 = trunc i8 %139 to i1
  br i1 %140, label %141, label %144

; <label>:141:                                    ; preds = %138
  %142 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %143 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %142, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %144

; <label>:144:                                    ; preds = %138, %141
  %145 = call i32 @proc_setconfig(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:146:                                    ; preds = %29
  %147 = load i8, i8* @usbfs_snoop, align 1
  %148 = trunc i8 %147 to i1
  br i1 %148, label %149, label %152

; <label>:149:                                    ; preds = %146
  %150 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %151 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %150, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %152

; <label>:152:                                    ; preds = %146, %149
  %153 = call i32 @proc_submiturb(%struct.dev_state* %15, i8* %2)
  %154 = icmp sge i32 %153, 0
  br i1 %154, label %155, label %333

; <label>:155:                                    ; preds = %152
  %156 = getelementptr inbounds %struct.inode, %struct.inode* %16, i32 0, i32 16
  %157 = call { i64, i64 } @current_kernel_time()
  %158 = bitcast %struct.timespec* %8 to { i64, i64 }*
  %159 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %158, i32 0, i32 0
  %160 = extractvalue { i64, i64 } %157, 0
  store i64 %160, i64* %159, align 8
  %161 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %158, i32 0, i32 1
  %162 = extractvalue { i64, i64 } %157, 1
  store i64 %162, i64* %161, align 8
  %163 = bitcast %struct.timespec* %156 to i8*
  %164 = bitcast %struct.timespec* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %163, i8* %164, i64 16, i32 8, i1 false)
  br label %333

; <label>:165:                                    ; preds = %29
  %166 = load i8, i8* @usbfs_snoop, align 1
  %167 = trunc i8 %166 to i1
  br i1 %167, label %168, label %171

; <label>:168:                                    ; preds = %165
  %169 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %170 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %169, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %171

; <label>:171:                                    ; preds = %165, %168
  %172 = bitcast i8* %2 to %struct.usbdevfs_ctrltransfer32*
  %173 = call i32 @proc_control_compat(%struct.dev_state* %15, %struct.usbdevfs_ctrltransfer32* %172)
  %174 = icmp sge i32 %173, 0
  br i1 %174, label %175, label %333

; <label>:175:                                    ; preds = %171
  %176 = getelementptr inbounds %struct.inode, %struct.inode* %16, i32 0, i32 16
  %177 = call { i64, i64 } @current_kernel_time()
  %178 = bitcast %struct.timespec* %9 to { i64, i64 }*
  %179 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %178, i32 0, i32 0
  %180 = extractvalue { i64, i64 } %177, 0
  store i64 %180, i64* %179, align 8
  %181 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %178, i32 0, i32 1
  %182 = extractvalue { i64, i64 } %177, 1
  store i64 %182, i64* %181, align 8
  %183 = bitcast %struct.timespec* %176 to i8*
  %184 = bitcast %struct.timespec* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %183, i8* %184, i64 16, i32 8, i1 false)
  br label %333

; <label>:185:                                    ; preds = %29
  %186 = load i8, i8* @usbfs_snoop, align 1
  %187 = trunc i8 %186 to i1
  br i1 %187, label %188, label %191

; <label>:188:                                    ; preds = %185
  %189 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %190 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %189, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %191

; <label>:191:                                    ; preds = %185, %188
  %192 = bitcast i8* %2 to %struct.usbdevfs_bulktransfer32*
  %193 = call i32 @proc_bulk_compat(%struct.dev_state* %15, %struct.usbdevfs_bulktransfer32* %192)
  %194 = icmp sge i32 %193, 0
  br i1 %194, label %195, label %333

; <label>:195:                                    ; preds = %191
  %196 = getelementptr inbounds %struct.inode, %struct.inode* %16, i32 0, i32 16
  %197 = call { i64, i64 } @current_kernel_time()
  %198 = bitcast %struct.timespec* %10 to { i64, i64 }*
  %199 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %198, i32 0, i32 0
  %200 = extractvalue { i64, i64 } %197, 0
  store i64 %200, i64* %199, align 8
  %201 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %198, i32 0, i32 1
  %202 = extractvalue { i64, i64 } %197, 1
  store i64 %202, i64* %201, align 8
  %203 = bitcast %struct.timespec* %196 to i8*
  %204 = bitcast %struct.timespec* %10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %203, i8* %204, i64 16, i32 8, i1 false)
  br label %333

; <label>:205:                                    ; preds = %29
  %206 = load i8, i8* @usbfs_snoop, align 1
  %207 = trunc i8 %206 to i1
  br i1 %207, label %208, label %211

; <label>:208:                                    ; preds = %205
  %209 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %210 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %209, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %211

; <label>:211:                                    ; preds = %205, %208
  %212 = call i32 @proc_disconnectsignal_compat(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:213:                                    ; preds = %29
  %214 = load i8, i8* @usbfs_snoop, align 1
  %215 = trunc i8 %214 to i1
  br i1 %215, label %216, label %219

; <label>:216:                                    ; preds = %213
  %217 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %218 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %217, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %219

; <label>:219:                                    ; preds = %213, %216
  %220 = call i32 @proc_submiturb_compat(%struct.dev_state* %15, i8* %2)
  %221 = icmp sge i32 %220, 0
  br i1 %221, label %222, label %333

; <label>:222:                                    ; preds = %219
  %223 = getelementptr inbounds %struct.inode, %struct.inode* %16, i32 0, i32 16
  %224 = call { i64, i64 } @current_kernel_time()
  %225 = bitcast %struct.timespec* %11 to { i64, i64 }*
  %226 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %225, i32 0, i32 0
  %227 = extractvalue { i64, i64 } %224, 0
  store i64 %227, i64* %226, align 8
  %228 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %225, i32 0, i32 1
  %229 = extractvalue { i64, i64 } %224, 1
  store i64 %229, i64* %228, align 8
  %230 = bitcast %struct.timespec* %223 to i8*
  %231 = bitcast %struct.timespec* %11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %230, i8* %231, i64 16, i32 8, i1 false)
  br label %333

; <label>:232:                                    ; preds = %29
  %233 = load i8, i8* @usbfs_snoop, align 1
  %234 = trunc i8 %233 to i1
  br i1 %234, label %235, label %238

; <label>:235:                                    ; preds = %232
  %236 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %237 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %236, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %238

; <label>:238:                                    ; preds = %232, %235
  %239 = call i32 @proc_reapurb_compat(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:240:                                    ; preds = %29
  %241 = load i8, i8* @usbfs_snoop, align 1
  %242 = trunc i8 %241 to i1
  br i1 %242, label %243, label %246

; <label>:243:                                    ; preds = %240
  %244 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %245 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %244, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %246

; <label>:246:                                    ; preds = %240, %243
  %247 = call i32 @proc_reapurbnonblock_compat(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:248:                                    ; preds = %29
  %249 = load i8, i8* @usbfs_snoop, align 1
  %250 = trunc i8 %249 to i1
  br i1 %250, label %251, label %254

; <label>:251:                                    ; preds = %248
  %252 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %253 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %252, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.21, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %254

; <label>:254:                                    ; preds = %248, %251
  %255 = call i32 @ptr_to_compat(i8* %2)
  %256 = call i32 @proc_ioctl_compat(%struct.dev_state* %15, i32 %255)
  br label %333

; <label>:257:                                    ; preds = %29
  %258 = load i8, i8* @usbfs_snoop, align 1
  %259 = trunc i8 %258 to i1
  br i1 %259, label %260, label %263

; <label>:260:                                    ; preds = %257
  %261 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %262 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %261, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %263

; <label>:263:                                    ; preds = %257, %260
  %264 = call i32 @proc_unlinkurb(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:265:                                    ; preds = %29
  %266 = load i8, i8* @usbfs_snoop, align 1
  %267 = trunc i8 %266 to i1
  br i1 %267, label %268, label %271

; <label>:268:                                    ; preds = %265
  %269 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %270 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %269, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %271

; <label>:271:                                    ; preds = %265, %268
  %272 = call i32 @proc_reapurb(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:273:                                    ; preds = %29
  %274 = load i8, i8* @usbfs_snoop, align 1
  %275 = trunc i8 %274 to i1
  br i1 %275, label %276, label %279

; <label>:276:                                    ; preds = %273
  %277 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %278 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %277, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %279

; <label>:279:                                    ; preds = %273, %276
  %280 = call i32 @proc_reapurbnonblock(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:281:                                    ; preds = %29
  %282 = load i8, i8* @usbfs_snoop, align 1
  %283 = trunc i8 %282 to i1
  br i1 %283, label %284, label %287

; <label>:284:                                    ; preds = %281
  %285 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %286 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %285, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %287

; <label>:287:                                    ; preds = %281, %284
  %288 = call i32 @proc_disconnectsignal(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:289:                                    ; preds = %29
  %290 = load i8, i8* @usbfs_snoop, align 1
  %291 = trunc i8 %290 to i1
  br i1 %291, label %292, label %295

; <label>:292:                                    ; preds = %289
  %293 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %294 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %293, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %295

; <label>:295:                                    ; preds = %289, %292
  %296 = call i32 @proc_claiminterface(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:297:                                    ; preds = %29
  %298 = load i8, i8* @usbfs_snoop, align 1
  %299 = trunc i8 %298 to i1
  br i1 %299, label %300, label %303

; <label>:300:                                    ; preds = %297
  %301 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %302 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %301, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %303

; <label>:303:                                    ; preds = %297, %300
  %304 = call i32 @proc_releaseinterface(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:305:                                    ; preds = %29
  %306 = load i8, i8* @usbfs_snoop, align 1
  %307 = trunc i8 %306 to i1
  br i1 %307, label %308, label %311

; <label>:308:                                    ; preds = %305
  %309 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %310 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %309, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.28, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %311

; <label>:311:                                    ; preds = %305, %308
  %312 = call i32 @proc_ioctl_default(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:313:                                    ; preds = %29
  %314 = load i8, i8* @usbfs_snoop, align 1
  %315 = trunc i8 %314 to i1
  br i1 %315, label %316, label %319

; <label>:316:                                    ; preds = %313
  %317 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %318 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %317, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.29, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %319

; <label>:319:                                    ; preds = %313, %316
  %320 = call i32 @proc_claim_port(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:321:                                    ; preds = %29
  %322 = load i8, i8* @usbfs_snoop, align 1
  %323 = trunc i8 %322 to i1
  br i1 %323, label %324, label %327

; <label>:324:                                    ; preds = %321
  %325 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  %326 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %325, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %327

; <label>:327:                                    ; preds = %321, %324
  %328 = call i32 @proc_release_port(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:329:                                    ; preds = %29
  %330 = call i32 @proc_get_capabilities(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:331:                                    ; preds = %29
  %332 = call i32 @proc_disconnect_claim(%struct.dev_state* %15, i8* %2)
  br label %333

; <label>:333:                                    ; preds = %219, %222, %191, %195, %171, %175, %152, %155, %101, %104, %74, %77, %55, %58, %36, %39, %331, %329, %327, %319, %311, %303, %295, %287, %279, %271, %263, %254, %246, %238, %211, %144, %136, %128, %120, %93, %29
  %.01 = phi i32 [ -25, %29 ], [ %332, %331 ], [ %330, %329 ], [ %328, %327 ], [ %320, %319 ], [ %312, %311 ], [ %304, %303 ], [ %296, %295 ], [ %288, %287 ], [ %280, %279 ], [ %272, %271 ], [ %264, %263 ], [ %256, %254 ], [ %247, %246 ], [ %239, %238 ], [ %212, %211 ], [ %145, %144 ], [ %137, %136 ], [ %129, %128 ], [ %121, %120 ], [ %94, %93 ], [ %37, %39 ], [ %37, %36 ], [ %56, %58 ], [ %56, %55 ], [ %75, %77 ], [ %75, %74 ], [ %102, %104 ], [ %102, %101 ], [ %153, %155 ], [ %153, %152 ], [ %173, %175 ], [ %173, %171 ], [ %193, %195 ], [ %193, %191 ], [ %220, %222 ], [ %220, %219 ]
  %334 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 11
  call void @device_unlock(%struct.device* %334)
  %335 = icmp sge i32 %.01, 0
  br i1 %335, label %336, label %346

; <label>:336:                                    ; preds = %333
  %337 = getelementptr inbounds %struct.inode, %struct.inode* %16, i32 0, i32 15
  %338 = call { i64, i64 } @current_kernel_time()
  %339 = bitcast %struct.timespec* %12 to { i64, i64 }*
  %340 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %339, i32 0, i32 0
  %341 = extractvalue { i64, i64 } %338, 0
  store i64 %341, i64* %340, align 8
  %342 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %339, i32 0, i32 1
  %343 = extractvalue { i64, i64 } %338, 1
  store i64 %343, i64* %342, align 8
  %344 = bitcast %struct.timespec* %337 to i8*
  %345 = bitcast %struct.timespec* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %344, i8* %345, i64 16, i32 8, i1 false)
  br label %346

; <label>:346:                                    ; preds = %336, %333
  %347 = sext i32 %.01 to i64
  br label %348

; <label>:348:                                    ; preds = %3, %346, %27
  %.0 = phi i64 [ %347, %346 ], [ -19, %27 ], [ -1, %3 ]
  ret i64 %.0
}

declare i32 @_dev_info(%struct.device*, i8*, ...) #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_control(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_ctrltransfer, align 8
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %15 = load %struct.usb_device*, %struct.usb_device** %14, align 8
  %16 = bitcast %struct.usbdevfs_ctrltransfer* %3 to i8*
  %17 = call i64 @copy_from_user(i8* %16, i8* %1, i64 24)
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %223, label %19

; <label>:19:                                     ; preds = %2
  %20 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 0
  %21 = load i8, i8* %20, align 8
  %22 = zext i8 %21 to i32
  %23 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 1
  %24 = load i8, i8* %23, align 1
  %25 = zext i8 %24 to i32
  %26 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 3
  %27 = load i16, i16* %26, align 4
  %28 = zext i16 %27 to i32
  %29 = call i32 @check_ctrlrecip(%struct.dev_state* %0, i32 %22, i32 %25, i32 %28)
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %223, label %31

; <label>:31:                                     ; preds = %19
  %32 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %33 = load i16, i16* %32, align 2
  %34 = zext i16 %33 to i32
  %35 = zext i32 %34 to i64
  %36 = icmp ugt i64 %35, 4096
  br i1 %36, label %223, label %37

; <label>:37:                                     ; preds = %31
  %38 = call i32 @usbfs_increase_memory_usage(i32 4296)
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %223, label %40

; <label>:40:                                     ; preds = %37
  %41 = call i64 @__get_free_pages(i32 208, i32 0)
  %42 = inttoptr i64 %41 to i8*
  %43 = icmp ne i8* %42, null
  br i1 %43, label %44, label %221

; <label>:44:                                     ; preds = %40
  %45 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 5
  %46 = load i32, i32* %45, align 8
  %47 = load i8, i8* @usbfs_snoop, align 1
  %48 = trunc i8 %47 to i1
  br i1 %48, label %49, label %67

; <label>:49:                                     ; preds = %44
  %50 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  %51 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 0
  %52 = load i8, i8* %51, align 8
  %53 = zext i8 %52 to i32
  %54 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 1
  %55 = load i8, i8* %54, align 1
  %56 = zext i8 %55 to i32
  %57 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 2
  %58 = call zeroext i16 @__le16_to_cpup(i16* %57)
  %59 = zext i16 %58 to i32
  %60 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 3
  %61 = call zeroext i16 @__le16_to_cpup(i16* %60)
  %62 = zext i16 %61 to i32
  %63 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %64 = call zeroext i16 @__le16_to_cpup(i16* %63)
  %65 = zext i16 %64 to i32
  %66 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %50, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @.str.31, i32 0, i32 0), i32 %53, i32 %56, i32 %59, i32 %62, i32 %65)
  br label %67

; <label>:67:                                     ; preds = %44, %49
  %68 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 0
  %69 = load i8, i8* %68, align 8
  %70 = zext i8 %69 to i32
  %71 = and i32 %70, 128
  %72 = icmp ne i32 %71, 0
  %73 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %74 = load i16, i16* %73, align 2
  br i1 %72, label %75, label %153

; <label>:75:                                     ; preds = %67
  %76 = zext i16 %74 to i32
  %77 = icmp ne i32 %76, 0
  br i1 %77, label %78, label %97

; <label>:78:                                     ; preds = %75
  %79 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 6
  %80 = load i8*, i8** %79, align 8
  %81 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %82 = load i16, i16* %81, align 2
  %83 = zext i16 %82 to i64
  %84 = call %struct.thread_info* @current_thread_info()
  %85 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %84, i32 0, i32 6
  %86 = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %85, i32 0, i32 0
  %87 = load i64, i64* %86, align 8
  %88 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %80, i64 %83, i64 %87) #6, !srcloc !5
  %89 = extractvalue { i64, i64 } %88, 0
  %90 = extractvalue { i64, i64 } %88, 1
  %91 = icmp eq i64 %89, 0
  %92 = xor i1 %91, true
  %93 = xor i1 %92, true
  %94 = zext i1 %93 to i32
  %95 = sext i32 %94 to i64
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %97, label %221

; <label>:97:                                     ; preds = %78, %75
  %98 = call i32 @__create_pipe(%struct.usb_device* %15, i32 0)
  %99 = or i32 -2147483648, %98
  %100 = or i32 %99, 128
  %101 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %102 = load i16, i16* %101, align 2
  %103 = zext i16 %102 to i32
  call void @snoop_urb(%struct.usb_device* %15, i8* null, i32 %100, i32 %103, i32 %46, i32 0, i8* null, i32 0)
  %104 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  call void @device_unlock(%struct.device* %104)
  %105 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 1
  %106 = load i8, i8* %105, align 1
  %107 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 0
  %108 = load i8, i8* %107, align 8
  %109 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 2
  %110 = load i16, i16* %109, align 2
  %111 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 3
  %112 = load i16, i16* %111, align 4
  %113 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %114 = load i16, i16* %113, align 2
  %115 = call i32 @usb_control_msg(%struct.usb_device* %15, i32 %100, i8 zeroext %106, i8 zeroext %108, i16 zeroext %110, i16 zeroext %112, i8* %42, i16 zeroext %114, i32 %46)
  %116 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  call void @device_lock(%struct.device* %116)
  store i32 %115, i32* %4, align 4
  store i32 0, i32* %5, align 4
  %117 = icmp eq i32* %4, %5
  %118 = zext i1 %117 to i32
  %119 = load i32, i32* %4, align 4
  %120 = load i32, i32* %5, align 4
  %121 = icmp sgt i32 %119, %120
  %122 = load i32, i32* %4, align 4
  %123 = load i32, i32* %5, align 4
  %124 = select i1 %121, i32 %122, i32 %123
  store i32 %115, i32* %6, align 4
  store i32 0, i32* %7, align 4
  %125 = icmp eq i32* %6, %7
  %126 = zext i1 %125 to i32
  %127 = load i32, i32* %6, align 4
  %128 = load i32, i32* %7, align 4
  %129 = icmp slt i32 %127, %128
  %130 = load i32, i32* %6, align 4
  %131 = load i32, i32* %7, align 4
  %132 = select i1 %129, i32 %130, i32 %131
  store i32 %115, i32* %8, align 4
  store i32 0, i32* %9, align 4
  %133 = icmp eq i32* %8, %9
  %134 = zext i1 %133 to i32
  %135 = load i32, i32* %8, align 4
  %136 = load i32, i32* %9, align 4
  %137 = icmp sgt i32 %135, %136
  %138 = load i32, i32* %8, align 4
  %139 = load i32, i32* %9, align 4
  %140 = select i1 %137, i32 %138, i32 %139
  call void @snoop_urb(%struct.usb_device* %15, i8* null, i32 %100, i32 %124, i32 %132, i32 1, i8* %42, i32 %140)
  %141 = icmp sgt i32 %115, 0
  br i1 %141, label %142, label %203

; <label>:142:                                    ; preds = %97
  %143 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %144 = load i16, i16* %143, align 2
  %145 = zext i16 %144 to i32
  %146 = icmp ne i32 %145, 0
  br i1 %146, label %147, label %203

; <label>:147:                                    ; preds = %142
  %148 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 6
  %149 = load i8*, i8** %148, align 8
  call void @might_fault() #5
  %150 = call i64 @_copy_to_user(i8* %149, i8* %42, i32 %115) #5
  %151 = trunc i64 %150 to i32
  %152 = icmp ne i32 %151, 0
  br i1 %152, label %221, label %203

; <label>:153:                                    ; preds = %67
  %154 = icmp ne i16 %74, 0
  br i1 %154, label %155, label %163

; <label>:155:                                    ; preds = %153
  %156 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 6
  %157 = load i8*, i8** %156, align 8
  %158 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %159 = load i16, i16* %158, align 2
  %160 = zext i16 %159 to i64
  %161 = call i64 @copy_from_user(i8* %42, i8* %157, i64 %160)
  %162 = icmp ne i64 %161, 0
  br i1 %162, label %221, label %163

; <label>:163:                                    ; preds = %155, %153
  %164 = call i32 @__create_pipe(%struct.usb_device* %15, i32 0)
  %165 = or i32 -2147483648, %164
  %166 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %167 = load i16, i16* %166, align 2
  %168 = zext i16 %167 to i32
  %169 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %170 = load i16, i16* %169, align 2
  %171 = zext i16 %170 to i32
  call void @snoop_urb(%struct.usb_device* %15, i8* null, i32 %165, i32 %168, i32 %46, i32 0, i8* %42, i32 %171)
  %172 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  call void @device_unlock(%struct.device* %172)
  %173 = call i32 @__create_pipe(%struct.usb_device* %15, i32 0)
  %174 = or i32 -2147483648, %173
  %175 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 1
  %176 = load i8, i8* %175, align 1
  %177 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 0
  %178 = load i8, i8* %177, align 8
  %179 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 2
  %180 = load i16, i16* %179, align 2
  %181 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 3
  %182 = load i16, i16* %181, align 4
  %183 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %184 = load i16, i16* %183, align 2
  %185 = call i32 @usb_control_msg(%struct.usb_device* %15, i32 %174, i8 zeroext %176, i8 zeroext %178, i16 zeroext %180, i16 zeroext %182, i8* %42, i16 zeroext %184, i32 %46)
  %186 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  call void @device_lock(%struct.device* %186)
  store i32 %185, i32* %10, align 4
  store i32 0, i32* %11, align 4
  %187 = icmp eq i32* %10, %11
  %188 = zext i1 %187 to i32
  %189 = load i32, i32* %10, align 4
  %190 = load i32, i32* %11, align 4
  %191 = icmp sgt i32 %189, %190
  %192 = load i32, i32* %10, align 4
  %193 = load i32, i32* %11, align 4
  %194 = select i1 %191, i32 %192, i32 %193
  store i32 %185, i32* %12, align 4
  store i32 0, i32* %13, align 4
  %195 = icmp eq i32* %12, %13
  %196 = zext i1 %195 to i32
  %197 = load i32, i32* %12, align 4
  %198 = load i32, i32* %13, align 4
  %199 = icmp slt i32 %197, %198
  %200 = load i32, i32* %12, align 4
  %201 = load i32, i32* %13, align 4
  %202 = select i1 %199, i32 %200, i32 %201
  call void @snoop_urb(%struct.usb_device* %15, i8* null, i32 %165, i32 %194, i32 %202, i32 1, i8* null, i32 0)
  br label %203

; <label>:203:                                    ; preds = %97, %142, %147, %163
  %.01 = phi i32 [ %185, %163 ], [ %115, %147 ], [ %115, %142 ], [ %115, %97 ]
  %204 = icmp slt i32 %.01, 0
  %205 = icmp ne i32 %.01, -32
  %or.cond = and i1 %204, %205
  br i1 %or.cond, label %206, label %221

; <label>:206:                                    ; preds = %203
  %207 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 11
  %208 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %209 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %208, i32 0, i32 64
  %210 = getelementptr inbounds [16 x i8], [16 x i8]* %209, i32 0, i32 0
  %211 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 0
  %212 = load i8, i8* %211, align 8
  %213 = zext i8 %212 to i32
  %214 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 1
  %215 = load i8, i8* %214, align 1
  %216 = zext i8 %215 to i32
  %217 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %3, i32 0, i32 4
  %218 = load i16, i16* %217, align 2
  %219 = zext i16 %218 to i32
  %220 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %207, i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.33, i32 0, i32 0), i8* %210, i32 %213, i32 %216, i32 %219, i32 %.01)
  br label %221

; <label>:221:                                    ; preds = %203, %206, %155, %147, %78, %40
  %.0 = phi i32 [ -12, %40 ], [ -22, %78 ], [ -14, %147 ], [ -14, %155 ], [ %.01, %206 ], [ %.01, %203 ]
  %222 = ptrtoint i8* %42 to i64
  call void @free_pages(i64 %222, i32 0)
  call void @usbfs_decrease_memory_usage(i32 4296)
  br label %223

; <label>:223:                                    ; preds = %37, %31, %19, %2, %221
  %.02 = phi i32 [ %.0, %221 ], [ -14, %2 ], [ %29, %19 ], [ -22, %31 ], [ %38, %37 ]
  ret i32 %.02
}

declare { i64, i64 } @current_kernel_time() #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_bulk(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_bulktransfer, align 8
  %4 = alloca i32, align 4
  %5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %5, align 8
  %7 = bitcast %struct.usbdevfs_bulktransfer* %3 to i8*
  %8 = call i64 @copy_from_user(i8* %7, i8* %1, i64 24)
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %115, label %10

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %11, align 8
  %13 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %3, i32 0, i32 0
  %14 = load i32, i32* %13, align 8
  %15 = call i32 @findintfep(%struct.usb_device* %12, i32 %14)
  %16 = icmp slt i32 %15, 0
  br i1 %16, label %115, label %17

; <label>:17:                                     ; preds = %10
  %18 = call i32 @checkintf(%struct.dev_state* %0, i32 %15)
  %19 = icmp ne i32 %18, 0
  br i1 %19, label %115, label %20

; <label>:20:                                     ; preds = %17
  %21 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %3, i32 0, i32 0
  %22 = load i32, i32* %21, align 8
  %23 = and i32 %22, 128
  %24 = icmp ne i32 %23, 0
  %25 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %3, i32 0, i32 0
  %26 = load i32, i32* %25, align 8
  %27 = and i32 %26, 127
  %28 = call i32 @__create_pipe(%struct.usb_device* %6, i32 %27)
  %29 = or i32 -1073741824, %28
  %30 = or i32 %29, 128
  %.02 = select i1 %24, i32 %30, i32 %29
  %31 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %3, i32 0, i32 0
  %32 = load i32, i32* %31, align 8
  %33 = and i32 %32, 128
  %34 = icmp ne i32 %33, 0
  %35 = xor i1 %34, true
  %36 = zext i1 %35 to i32
  %37 = call zeroext i16 @usb_maxpacket(%struct.usb_device* %6, i32 %.02, i32 %36)
  %38 = icmp ne i16 %37, 0
  br i1 %38, label %39, label %115

; <label>:39:                                     ; preds = %20
  %40 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %3, i32 0, i32 1
  %41 = load i32, i32* %40, align 4
  %42 = icmp uge i32 %41, 2146483647
  br i1 %42, label %115, label %43

; <label>:43:                                     ; preds = %39
  %44 = zext i32 %41 to i64
  %45 = add i64 %44, 192
  %46 = trunc i64 %45 to i32
  %47 = call i32 @usbfs_increase_memory_usage(i32 %46)
  %48 = icmp ne i32 %47, 0
  br i1 %48, label %115, label %49

; <label>:49:                                     ; preds = %43
  %50 = zext i32 %41 to i64
  %51 = call i8* @__kmalloc(i64 %50, i32 208) #5
  %52 = icmp ne i8* %51, null
  br i1 %52, label %53, label %111

; <label>:53:                                     ; preds = %49
  %54 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %3, i32 0, i32 2
  %55 = load i32, i32* %54, align 8
  %56 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %3, i32 0, i32 0
  %57 = load i32, i32* %56, align 8
  %58 = and i32 %57, 128
  %59 = icmp ne i32 %58, 0
  %60 = icmp ne i32 %41, 0
  br i1 %59, label %61, label %95

; <label>:61:                                     ; preds = %53
  br i1 %60, label %62, label %79

; <label>:62:                                     ; preds = %61
  %63 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %3, i32 0, i32 3
  %64 = load i8*, i8** %63, align 8
  %65 = zext i32 %41 to i64
  %66 = call %struct.thread_info* @current_thread_info()
  %67 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %66, i32 0, i32 6
  %68 = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %67, i32 0, i32 0
  %69 = load i64, i64* %68, align 8
  %70 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %64, i64 %65, i64 %69) #6, !srcloc !6
  %71 = extractvalue { i64, i64 } %70, 0
  %72 = extractvalue { i64, i64 } %70, 1
  %73 = icmp eq i64 %71, 0
  %74 = xor i1 %73, true
  %75 = xor i1 %74, true
  %76 = zext i1 %75 to i32
  %77 = sext i32 %76 to i64
  %78 = icmp ne i64 %77, 0
  br i1 %78, label %79, label %111

; <label>:79:                                     ; preds = %62, %61
  call void @snoop_urb(%struct.usb_device* %6, i8* null, i32 %.02, i32 %41, i32 %55, i32 0, i8* null, i32 0)
  %80 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 11
  call void @device_unlock(%struct.device* %80)
  %81 = call i32 @usb_bulk_msg(%struct.usb_device* %6, i32 %.02, i8* %51, i32 %41, i32* %4, i32 %55)
  %82 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 11
  call void @device_lock(%struct.device* %82)
  %83 = load i32, i32* %4, align 4
  %84 = load i32, i32* %4, align 4
  call void @snoop_urb(%struct.usb_device* %6, i8* null, i32 %.02, i32 %83, i32 %81, i32 1, i8* %51, i32 %84)
  %85 = icmp eq i32 %81, 0
  %86 = load i32, i32* %4, align 4
  %87 = icmp ne i32 %86, 0
  %or.cond = and i1 %85, %87
  br i1 %or.cond, label %88, label %107

; <label>:88:                                     ; preds = %79
  %89 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %3, i32 0, i32 3
  %90 = load i8*, i8** %89, align 8
  %91 = load i32, i32* %4, align 4
  call void @might_fault() #5
  %92 = call i64 @_copy_to_user(i8* %90, i8* %51, i32 %91) #5
  %93 = trunc i64 %92 to i32
  %94 = icmp ne i32 %93, 0
  br i1 %94, label %111, label %107

; <label>:95:                                     ; preds = %53
  br i1 %60, label %96, label %102

; <label>:96:                                     ; preds = %95
  %97 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %3, i32 0, i32 3
  %98 = load i8*, i8** %97, align 8
  %99 = zext i32 %41 to i64
  %100 = call i64 @copy_from_user(i8* %51, i8* %98, i64 %99)
  %101 = icmp ne i64 %100, 0
  br i1 %101, label %111, label %102

; <label>:102:                                    ; preds = %96, %95
  call void @snoop_urb(%struct.usb_device* %6, i8* null, i32 %.02, i32 %41, i32 %55, i32 0, i8* %51, i32 %41)
  %103 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 11
  call void @device_unlock(%struct.device* %103)
  %104 = call i32 @usb_bulk_msg(%struct.usb_device* %6, i32 %.02, i8* %51, i32 %41, i32* %4, i32 %55)
  %105 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 11
  call void @device_lock(%struct.device* %105)
  %106 = load i32, i32* %4, align 4
  call void @snoop_urb(%struct.usb_device* %6, i8* null, i32 %.02, i32 %106, i32 %104, i32 1, i8* null, i32 0)
  br label %107

; <label>:107:                                    ; preds = %79, %88, %102
  %.01 = phi i32 [ %104, %102 ], [ %81, %88 ], [ %81, %79 ]
  %108 = icmp slt i32 %.01, 0
  %109 = load i32, i32* %4, align 4
  %110 = select i1 %108, i32 %.01, i32 %109
  br label %111

; <label>:111:                                    ; preds = %107, %96, %88, %62, %49
  %.0 = phi i32 [ -12, %49 ], [ -22, %62 ], [ -14, %88 ], [ -14, %96 ], [ %110, %107 ]
  call void @kfree(i8* %51)
  %112 = zext i32 %41 to i64
  %113 = add i64 %112, 192
  %114 = trunc i64 %113 to i32
  call void @usbfs_decrease_memory_usage(i32 %114)
  br label %115

; <label>:115:                                    ; preds = %43, %39, %20, %17, %10, %2, %111
  %.03 = phi i32 [ %.0, %111 ], [ -14, %2 ], [ %15, %10 ], [ %18, %17 ], [ -22, %20 ], [ -22, %39 ], [ %47, %43 ]
  ret i32 %.03
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_resetep(%struct.dev_state*, i8*) #0 {
  call void @might_fault()
  %3 = bitcast i8* %1 to i32*
  %4 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %3, i64 4) #5, !srcloc !7
  %5 = extractvalue { i32*, i64 } %4, 0
  %6 = extractvalue { i32*, i64 } %4, 1
  %7 = ptrtoint i32* %5 to i64
  %8 = trunc i64 %7 to i32
  %9 = trunc i64 %6 to i32
  %10 = icmp ne i32 %8, 0
  br i1 %10, label %22, label %11

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %12, align 8
  %14 = call i32 @findintfep(%struct.usb_device* %13, i32 %9)
  %15 = icmp slt i32 %14, 0
  br i1 %15, label %22, label %16

; <label>:16:                                     ; preds = %11
  %17 = call i32 @checkintf(%struct.dev_state* %0, i32 %14)
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %22, label %19

; <label>:19:                                     ; preds = %16
  %20 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %21 = load %struct.usb_device*, %struct.usb_device** %20, align 8
  call void @usb_reset_endpoint(%struct.usb_device* %21, i32 %9)
  br label %22

; <label>:22:                                     ; preds = %16, %11, %2, %19
  %.0 = phi i32 [ 0, %19 ], [ -14, %2 ], [ %14, %11 ], [ %17, %16 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_resetdevice(%struct.dev_state*) #0 {
  %2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %2, align 8
  %4 = call i32 @usb_reset_device(%struct.usb_device* %3)
  ret i32 %4
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_clearhalt(%struct.dev_state*, i8*) #0 {
  call void @might_fault()
  %3 = bitcast i8* %1 to i32*
  %4 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %3, i64 4) #5, !srcloc !8
  %5 = extractvalue { i32*, i64 } %4, 0
  %6 = extractvalue { i32*, i64 } %4, 1
  %7 = ptrtoint i32* %5 to i64
  %8 = trunc i64 %7 to i32
  %9 = trunc i64 %6 to i32
  %10 = icmp ne i32 %8, 0
  br i1 %10, label %31, label %11

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %12, align 8
  %14 = call i32 @findintfep(%struct.usb_device* %13, i32 %9)
  %15 = icmp slt i32 %14, 0
  br i1 %15, label %31, label %16

; <label>:16:                                     ; preds = %11
  %17 = call i32 @checkintf(%struct.dev_state* %0, i32 %14)
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %31, label %19

; <label>:19:                                     ; preds = %16
  %20 = and i32 %9, 128
  %21 = icmp ne i32 %20, 0
  %22 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %23 = load %struct.usb_device*, %struct.usb_device** %22, align 8
  %24 = and i32 %9, 127
  %25 = call i32 @__create_pipe(%struct.usb_device* %23, i32 %24)
  %26 = or i32 -1073741824, %25
  %27 = or i32 %26, 128
  %.01 = select i1 %21, i32 %27, i32 %26
  %28 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %29 = load %struct.usb_device*, %struct.usb_device** %28, align 8
  %30 = call i32 @usb_clear_halt(%struct.usb_device* %29, i32 %.01)
  br label %31

; <label>:31:                                     ; preds = %16, %11, %2, %19
  %.0 = phi i32 [ %30, %19 ], [ -14, %2 ], [ %14, %11 ], [ %17, %16 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_getdriver(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_getdriver, align 4
  %4 = bitcast %struct.usbdevfs_getdriver* %3 to i8*
  %5 = call i64 @copy_from_user(i8* %4, i8* %1, i64 260)
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %33, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %8, align 8
  %10 = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %3, i32 0, i32 0
  %11 = load i32, i32* %10, align 4
  %12 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %9, i32 %11)
  %13 = icmp ne %struct.usb_interface* %12, null
  br i1 %13, label %14, label %33

; <label>:14:                                     ; preds = %7
  %15 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 7
  %16 = getelementptr inbounds %struct.device, %struct.device* %15, i32 0, i32 7
  %17 = load %struct.device_driver*, %struct.device_driver** %16, align 8
  %18 = icmp ne %struct.device_driver* %17, null
  br i1 %18, label %19, label %33

; <label>:19:                                     ; preds = %14
  %20 = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %3, i32 0, i32 1
  %21 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %22 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 7
  %23 = getelementptr inbounds %struct.device, %struct.device* %22, i32 0, i32 7
  %24 = load %struct.device_driver*, %struct.device_driver** %23, align 8
  %25 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %24, i32 0, i32 0
  %26 = load i8*, i8** %25, align 8
  %27 = call i64 @strlcpy(i8* %21, i8* %26, i64 256)
  %28 = bitcast %struct.usbdevfs_getdriver* %3 to i8*
  call void @might_fault() #5
  %29 = call i64 @_copy_to_user(i8* %1, i8* %28, i32 260) #5
  %30 = trunc i64 %29 to i32
  %31 = icmp ne i32 %30, 0
  %32 = select i1 %31, i32 -14, i32 0
  br label %33

; <label>:33:                                     ; preds = %19, %14, %7, %2
  %.01 = phi i32 [ -14, %2 ], [ %32, %19 ], [ -61, %14 ], [ -61, %7 ]
  ret i32 %.01
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_connectinfo(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_connectinfo, align 4
  %4 = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %3, i32 0, i32 0
  %5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %5, align 8
  %7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 0
  %8 = load i32, i32* %7, align 8
  store i32 %8, i32* %4, align 4
  %9 = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %3, i32 0, i32 1
  %10 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %11 = load %struct.usb_device*, %struct.usb_device** %10, align 8
  %12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %11, i32 0, i32 4
  %13 = load i32, i32* %12, align 4
  %14 = icmp eq i32 %13, 1
  %15 = zext i1 %14 to i32
  %16 = trunc i32 %15 to i8
  store i8 %16, i8* %9, align 4
  %17 = bitcast %struct.usbdevfs_connectinfo* %3 to i8*
  call void @might_fault() #5
  %18 = call i64 @_copy_to_user(i8* %1, i8* %17, i32 8) #5
  %19 = trunc i64 %18 to i32
  %20 = icmp ne i32 %19, 0
  %. = select i1 %20, i32 -14, i32 0
  ret i32 %.
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_setintf(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_setinterface, align 4
  %4 = bitcast %struct.usbdevfs_setinterface* %3 to i8*
  %5 = call i64 @copy_from_user(i8* %4, i8* %1, i64 8)
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %20, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %3, i32 0, i32 0
  %9 = load i32, i32* %8, align 4
  %10 = call i32 @checkintf(%struct.dev_state* %0, i32 %9)
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %20, label %12

; <label>:12:                                     ; preds = %7
  %13 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %14 = load %struct.usb_device*, %struct.usb_device** %13, align 8
  %15 = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %3, i32 0, i32 0
  %16 = load i32, i32* %15, align 4
  %17 = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %3, i32 0, i32 1
  %18 = load i32, i32* %17, align 4
  %19 = call i32 @usb_set_interface(%struct.usb_device* %14, i32 %16, i32 %18)
  br label %20

; <label>:20:                                     ; preds = %7, %2, %12
  %.0 = phi i32 [ %19, %12 ], [ -14, %2 ], [ %10, %7 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_setconfig(%struct.dev_state*, i8*) #0 {
  call void @might_fault()
  %3 = bitcast i8* %1 to i32*
  %4 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %3, i64 4) #5, !srcloc !9
  %5 = extractvalue { i32*, i64 } %4, 0
  %6 = extractvalue { i32*, i64 } %4, 1
  %7 = ptrtoint i32* %5 to i64
  %8 = trunc i64 %7 to i32
  %9 = trunc i64 %6 to i32
  %10 = icmp ne i32 %8, 0
  br i1 %10, label %76, label %11

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %12, align 8
  %14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 15
  %15 = load %struct.usb_host_config*, %struct.usb_host_config** %14, align 8
  %16 = icmp ne %struct.usb_host_config* %15, null
  br i1 %16, label %17, label %.loopexit

; <label>:17:                                     ; preds = %11, %57
  %.0 = phi i32 [ %58, %57 ], [ 0, %11 ]
  %18 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %15, i32 0, i32 0
  %19 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %18, i32 0, i32 3
  %20 = load i8, i8* %19, align 4
  %21 = zext i8 %20 to i32
  %22 = icmp slt i32 %.0, %21
  br i1 %22, label %23, label %.loopexit

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %15, i32 0, i32 3
  %25 = sext i32 %.0 to i64
  %26 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %24, i64 0, i64 %25
  %27 = load %struct.usb_interface*, %struct.usb_interface** %26, align 8
  %28 = call i32 @usb_interface_claimed(%struct.usb_interface* %27)
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %30, label %57

; <label>:30:                                     ; preds = %23
  %31 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %32 = load %struct.usb_device*, %struct.usb_device** %31, align 8
  %33 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %32, i32 0, i32 11
  %34 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %15, i32 0, i32 3
  %35 = sext i32 %.0 to i64
  %36 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %34, i64 0, i64 %35
  %37 = load %struct.usb_interface*, %struct.usb_interface** %36, align 8
  %38 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %37, i32 0, i32 1
  %39 = load %struct.usb_host_interface*, %struct.usb_host_interface** %38, align 8
  %40 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %39, i32 0, i32 0
  %41 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %40, i32 0, i32 2
  %42 = load i8, i8* %41, align 2
  %43 = zext i8 %42 to i32
  %44 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %15, i32 0, i32 3
  %45 = sext i32 %.0 to i64
  %46 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %44, i64 0, i64 %45
  %47 = load %struct.usb_interface*, %struct.usb_interface** %46, align 8
  %48 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %47, i32 0, i32 7
  %49 = getelementptr inbounds %struct.device, %struct.device* %48, i32 0, i32 7
  %50 = load %struct.device_driver*, %struct.device_driver** %49, align 8
  %51 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %50, i32 0, i32 0
  %52 = load i8*, i8** %51, align 8
  %53 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %54 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %53, i32 0, i32 64
  %55 = getelementptr inbounds [16 x i8], [16 x i8]* %54, i32 0, i32 0
  %56 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %33, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.47, i32 0, i32 0), i32 %43, i8* %52, i8* %55, i32 %9)
  br label %.loopexit

; <label>:57:                                     ; preds = %23
  %58 = add nsw i32 %.0, 1
  br label %17

.loopexit:                                        ; preds = %30, %17, %11
  %.1 = phi i32 [ 0, %11 ], [ -16, %30 ], [ 0, %17 ]
  %59 = icmp eq i32 %.1, 0
  br i1 %59, label %60, label %76

; <label>:60:                                     ; preds = %.loopexit
  %61 = icmp ne %struct.usb_host_config* %15, null
  br i1 %61, label %62, label %72

; <label>:62:                                     ; preds = %60
  %63 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %15, i32 0, i32 0
  %64 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %63, i32 0, i32 4
  %65 = load i8, i8* %64, align 1
  %66 = zext i8 %65 to i32
  %67 = icmp eq i32 %66, %9
  br i1 %67, label %68, label %72

; <label>:68:                                     ; preds = %62
  %69 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %70 = load %struct.usb_device*, %struct.usb_device** %69, align 8
  %71 = call i32 @usb_reset_configuration(%struct.usb_device* %70)
  br label %76

; <label>:72:                                     ; preds = %62, %60
  %73 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %74 = load %struct.usb_device*, %struct.usb_device** %73, align 8
  %75 = call i32 @usb_set_configuration(%struct.usb_device* %74, i32 %9)
  br label %76

; <label>:76:                                     ; preds = %.loopexit, %72, %68, %2
  %.02 = phi i32 [ -14, %2 ], [ %.1, %.loopexit ], [ %71, %68 ], [ %75, %72 ]
  ret i32 %.02
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_submiturb(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_urb, align 8
  %4 = bitcast %struct.usbdevfs_urb* %3 to i8*
  %5 = call i64 @copy_from_user(i8* %4, i8* %1, i64 56)
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %12, label %7

; <label>:7:                                      ; preds = %2
  %8 = bitcast i8* %1 to %struct.usbdevfs_urb*
  %9 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %8, i32 0, i32 12
  %10 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %9, i32 0, i32 0
  %11 = call i32 @proc_do_submiturb(%struct.dev_state* %0, %struct.usbdevfs_urb* %3, %struct.usbdevfs_iso_packet_desc* %10, i8* %1)
  br label %12

; <label>:12:                                     ; preds = %2, %7
  %.0 = phi i32 [ %11, %7 ], [ -14, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_control_compat(%struct.dev_state*, %struct.usbdevfs_ctrltransfer32*) #0 {
  %3 = call i8* @compat_alloc_user_space(i64 24)
  %4 = bitcast i8* %3 to %struct.usbdevfs_ctrltransfer*
  %5 = bitcast %struct.usbdevfs_ctrltransfer* %4 to i8*
  %6 = bitcast %struct.usbdevfs_ctrltransfer32* %1 to i8*
  %7 = call i64 @copy_in_user(i8* %5, i8* %6, i32 12)
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %28, label %9

; <label>:9:                                      ; preds = %2
  call void @might_fault()
  %10 = getelementptr inbounds %struct.usbdevfs_ctrltransfer32, %struct.usbdevfs_ctrltransfer32* %1, i32 0, i32 6
  %11 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %10, i64 4) #5, !srcloc !10
  %12 = extractvalue { i32*, i64 } %11, 0
  %13 = extractvalue { i32*, i64 } %11, 1
  %14 = ptrtoint i32* %12 to i64
  %15 = trunc i64 %14 to i32
  %16 = trunc i64 %13 to i32
  %17 = icmp ne i32 %15, 0
  br i1 %17, label %28, label %18

; <label>:18:                                     ; preds = %9
  call void @might_fault()
  %19 = call i8* @compat_ptr(i32 %16)
  %20 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %4, i32 0, i32 6
  %21 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %19, i8** %20) #5, !srcloc !11
  %22 = ptrtoint i8* %21 to i64
  %23 = trunc i64 %22 to i32
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %28, label %25

; <label>:25:                                     ; preds = %18
  %26 = bitcast %struct.usbdevfs_ctrltransfer* %4 to i8*
  %27 = call i32 @proc_control(%struct.dev_state* %0, i8* %26)
  br label %28

; <label>:28:                                     ; preds = %2, %9, %18, %25
  %.0 = phi i32 [ %27, %25 ], [ -14, %18 ], [ -14, %9 ], [ -14, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_bulk_compat(%struct.dev_state*, %struct.usbdevfs_bulktransfer32*) #0 {
  %3 = call i8* @compat_alloc_user_space(i64 24)
  %4 = bitcast i8* %3 to %struct.usbdevfs_bulktransfer*
  call void @might_fault()
  %5 = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %1, i32 0, i32 0
  %6 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %5, i64 4) #5, !srcloc !12
  %7 = extractvalue { i32*, i64 } %6, 0
  %8 = extractvalue { i32*, i64 } %6, 1
  %9 = ptrtoint i32* %7 to i64
  %10 = trunc i64 %9 to i32
  %11 = trunc i64 %8 to i32
  %12 = icmp ne i32 %10, 0
  br i1 %12, label %62, label %13

; <label>:13:                                     ; preds = %2
  call void @might_fault()
  %14 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %4, i32 0, i32 0
  %15 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %11, i32* %14) #5, !srcloc !13
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %62, label %17

; <label>:17:                                     ; preds = %13
  call void @might_fault()
  %18 = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %1, i32 0, i32 1
  %19 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %18, i64 4) #5, !srcloc !14
  %20 = extractvalue { i32*, i64 } %19, 0
  %21 = extractvalue { i32*, i64 } %19, 1
  %22 = ptrtoint i32* %20 to i64
  %23 = trunc i64 %22 to i32
  %24 = trunc i64 %21 to i32
  %25 = icmp ne i32 %23, 0
  br i1 %25, label %62, label %26

; <label>:26:                                     ; preds = %17
  call void @might_fault()
  %27 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %4, i32 0, i32 1
  %28 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %24, i32* %27) #5, !srcloc !15
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %62, label %30

; <label>:30:                                     ; preds = %26
  call void @might_fault()
  %31 = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %1, i32 0, i32 2
  %32 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %31, i64 4) #5, !srcloc !16
  %33 = extractvalue { i32*, i64 } %32, 0
  %34 = extractvalue { i32*, i64 } %32, 1
  %35 = ptrtoint i32* %33 to i64
  %36 = trunc i64 %35 to i32
  %37 = trunc i64 %34 to i32
  %38 = icmp ne i32 %36, 0
  br i1 %38, label %62, label %39

; <label>:39:                                     ; preds = %30
  call void @might_fault()
  %40 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %4, i32 0, i32 2
  %41 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %37, i32* %40) #5, !srcloc !17
  %42 = icmp ne i32 %41, 0
  br i1 %42, label %62, label %43

; <label>:43:                                     ; preds = %39
  call void @might_fault()
  %44 = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %1, i32 0, i32 3
  %45 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %44, i64 4) #5, !srcloc !18
  %46 = extractvalue { i32*, i64 } %45, 0
  %47 = extractvalue { i32*, i64 } %45, 1
  %48 = ptrtoint i32* %46 to i64
  %49 = trunc i64 %48 to i32
  %50 = trunc i64 %47 to i32
  %51 = icmp ne i32 %49, 0
  br i1 %51, label %62, label %52

; <label>:52:                                     ; preds = %43
  call void @might_fault()
  %53 = call i8* @compat_ptr(i32 %50)
  %54 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %4, i32 0, i32 3
  %55 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %53, i8** %54) #5, !srcloc !19
  %56 = ptrtoint i8* %55 to i64
  %57 = trunc i64 %56 to i32
  %58 = icmp ne i32 %57, 0
  br i1 %58, label %62, label %59

; <label>:59:                                     ; preds = %52
  %60 = bitcast %struct.usbdevfs_bulktransfer* %4 to i8*
  %61 = call i32 @proc_bulk(%struct.dev_state* %0, i8* %60)
  br label %62

; <label>:62:                                     ; preds = %2, %13, %17, %26, %30, %39, %43, %52, %59
  %.0 = phi i32 [ %61, %59 ], [ -14, %52 ], [ -14, %43 ], [ -14, %39 ], [ -14, %30 ], [ -14, %26 ], [ -14, %17 ], [ -14, %13 ], [ -14, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_disconnectsignal_compat(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_disconnectsignal32, align 4
  %4 = bitcast %struct.usbdevfs_disconnectsignal32* %3 to i8*
  %5 = call i64 @copy_from_user(i8* %4, i8* %1, i64 8)
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %15, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.usbdevfs_disconnectsignal32, %struct.usbdevfs_disconnectsignal32* %3, i32 0, i32 0
  %9 = load i32, i32* %8, align 4
  %10 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 7
  store i32 %9, i32* %10, align 8
  %11 = getelementptr inbounds %struct.usbdevfs_disconnectsignal32, %struct.usbdevfs_disconnectsignal32* %3, i32 0, i32 1
  %12 = load i32, i32* %11, align 4
  %13 = call i8* @compat_ptr(i32 %12)
  %14 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 10
  store i8* %13, i8** %14, align 8
  br label %15

; <label>:15:                                     ; preds = %2, %7
  %.0 = phi i32 [ 0, %7 ], [ -14, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_submiturb_compat(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_urb, align 8
  %4 = bitcast i8* %1 to %struct.usbdevfs_urb32*
  %5 = call i32 @get_urb32(%struct.usbdevfs_urb* %3, %struct.usbdevfs_urb32* %4)
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %12, label %7

; <label>:7:                                      ; preds = %2
  %8 = bitcast i8* %1 to %struct.usbdevfs_urb32*
  %9 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %8, i32 0, i32 12
  %10 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %9, i32 0, i32 0
  %11 = call i32 @proc_do_submiturb(%struct.dev_state* %0, %struct.usbdevfs_urb* %3, %struct.usbdevfs_iso_packet_desc* %10, i8* %1)
  br label %12

; <label>:12:                                     ; preds = %2, %7
  %.0 = phi i32 [ %11, %7 ], [ -14, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_reapurb_compat(%struct.dev_state*, i8*) #0 {
  %3 = call %struct.async* @reap_as(%struct.dev_state* %0)
  %4 = icmp ne %struct.async* %3, null
  br i1 %4, label %5, label %8

; <label>:5:                                      ; preds = %2
  %6 = bitcast i8* %1 to i8**
  %7 = call i32 @processcompl_compat(%struct.async* %3, i8** %6)
  call void @free_async(%struct.async* %3)
  br label %12

; <label>:8:                                      ; preds = %2
  %9 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %10 = call i32 @signal_pending(%struct.task_struct* %9)
  %11 = icmp ne i32 %10, 0
  %. = select i1 %11, i32 -4, i32 -5
  br label %12

; <label>:12:                                     ; preds = %8, %5
  %.0 = phi i32 [ %7, %5 ], [ %., %8 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_reapurbnonblock_compat(%struct.dev_state*, i8*) #0 {
  %3 = call %struct.async* @async_getcompleted(%struct.dev_state* %0)
  %4 = icmp ne %struct.async* %3, null
  br i1 %4, label %5, label %8

; <label>:5:                                      ; preds = %2
  %6 = bitcast i8* %1 to i8**
  %7 = call i32 @processcompl_compat(%struct.async* %3, i8** %6)
  call void @free_async(%struct.async* %3)
  br label %8

; <label>:8:                                      ; preds = %5, %2
  %.0 = phi i32 [ %7, %5 ], [ -11, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_ioctl_compat(%struct.dev_state*, i32) #0 {
  %3 = alloca %struct.usbdevfs_ioctl, align 8
  %4 = zext i32 %1 to i64
  %5 = trunc i64 %4 to i32
  %6 = call i8* @compat_ptr(i32 %5)
  %7 = bitcast i8* %6 to %struct.usbdevfs_ioctl32*
  %8 = call %struct.thread_info* @current_thread_info()
  %9 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %8, i32 0, i32 6
  %10 = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %9, i32 0, i32 0
  %11 = load i64, i64* %10, align 8
  %12 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(%struct.usbdevfs_ioctl32* %7, i64 12, i64 %11) #6, !srcloc !20
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = icmp eq i64 %13, 0
  %16 = xor i1 %15, true
  %17 = xor i1 %16, true
  %18 = zext i1 %17 to i32
  %19 = sext i32 %18 to i64
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %21, label %51

; <label>:21:                                     ; preds = %2
  %22 = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %7, i32 0, i32 0
  %23 = bitcast i32* %22 to %struct.__large_struct*
  %24 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %23, i32 -14, i32 0) #5, !srcloc !21
  %25 = extractvalue { i32, i64 } %24, 0
  %26 = extractvalue { i32, i64 } %24, 1
  %27 = trunc i64 %26 to i32
  %28 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %3, i32 0, i32 0
  store i32 %27, i32* %28, align 8
  %29 = icmp ne i32 %25, 0
  br i1 %29, label %51, label %30

; <label>:30:                                     ; preds = %21
  %31 = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %7, i32 0, i32 1
  %32 = bitcast i32* %31 to %struct.__large_struct*
  %33 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %32, i32 -14, i32 0) #5, !srcloc !22
  %34 = extractvalue { i32, i64 } %33, 0
  %35 = extractvalue { i32, i64 } %33, 1
  %36 = trunc i64 %35 to i32
  %37 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %3, i32 0, i32 1
  store i32 %36, i32* %37, align 4
  %38 = icmp ne i32 %34, 0
  br i1 %38, label %51, label %39

; <label>:39:                                     ; preds = %30
  %40 = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %7, i32 0, i32 2
  %41 = bitcast i32* %40 to %struct.__large_struct*
  %42 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %41, i32 -14, i32 0) #5, !srcloc !23
  %43 = extractvalue { i32, i64 } %42, 0
  %44 = extractvalue { i32, i64 } %42, 1
  %45 = trunc i64 %44 to i32
  %46 = icmp ne i32 %43, 0
  br i1 %46, label %51, label %47

; <label>:47:                                     ; preds = %39
  %48 = call i8* @compat_ptr(i32 %45)
  %49 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %3, i32 0, i32 2
  store i8* %48, i8** %49, align 8
  %50 = call i32 @proc_ioctl(%struct.dev_state* %0, %struct.usbdevfs_ioctl* %3)
  br label %51

; <label>:51:                                     ; preds = %2, %21, %30, %39, %47
  %.0 = phi i32 [ %50, %47 ], [ -14, %39 ], [ -14, %30 ], [ -14, %21 ], [ -14, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @ptr_to_compat(i8*) #0 {
  %2 = ptrtoint i8* %0 to i64
  %3 = trunc i64 %2 to i32
  ret i32 %3
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_unlinkurb(%struct.dev_state*, i8*) #0 {
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = icmp eq i64* %3, %4
  %6 = zext i1 %5 to i32
  %7 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %8 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %7)
  %9 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %8)
  %10 = call %struct.async* @async_getpending(%struct.dev_state* %0, i8* %1)
  %11 = icmp ne %struct.async* %10, null
  br i1 %11, label %14, label %12

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %13, i64 %9)
  br label %19

; <label>:14:                                     ; preds = %2
  %15 = getelementptr inbounds %struct.async, %struct.async* %10, i32 0, i32 8
  %16 = load %struct.urb*, %struct.urb** %15, align 8
  %17 = call %struct.urb* @usb_get_urb(%struct.urb* %16)
  %18 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %18, i64 %9)
  call void @usb_kill_urb(%struct.urb* %16)
  call void @usb_free_urb(%struct.urb* %16)
  br label %19

; <label>:19:                                     ; preds = %14, %12
  %.0 = phi i32 [ 0, %14 ], [ -22, %12 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_reapurb(%struct.dev_state*, i8*) #0 {
  %3 = call %struct.async* @reap_as(%struct.dev_state* %0)
  %4 = icmp ne %struct.async* %3, null
  br i1 %4, label %5, label %8

; <label>:5:                                      ; preds = %2
  %6 = bitcast i8* %1 to i8**
  %7 = call i32 @processcompl(%struct.async* %3, i8** %6)
  call void @free_async(%struct.async* %3)
  br label %12

; <label>:8:                                      ; preds = %2
  %9 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %10 = call i32 @signal_pending(%struct.task_struct* %9)
  %11 = icmp ne i32 %10, 0
  %. = select i1 %11, i32 -4, i32 -5
  br label %12

; <label>:12:                                     ; preds = %8, %5
  %.0 = phi i32 [ %7, %5 ], [ %., %8 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_reapurbnonblock(%struct.dev_state*, i8*) #0 {
  %3 = call %struct.async* @async_getcompleted(%struct.dev_state* %0)
  %4 = icmp ne %struct.async* %3, null
  br i1 %4, label %5, label %8

; <label>:5:                                      ; preds = %2
  %6 = bitcast i8* %1 to i8**
  %7 = call i32 @processcompl(%struct.async* %3, i8** %6)
  call void @free_async(%struct.async* %3)
  br label %8

; <label>:8:                                      ; preds = %5, %2
  %.0 = phi i32 [ %7, %5 ], [ -11, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_disconnectsignal(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_disconnectsignal, align 8
  %4 = bitcast %struct.usbdevfs_disconnectsignal* %3 to i8*
  %5 = call i64 @copy_from_user(i8* %4, i8* %1, i64 16)
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %14, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %3, i32 0, i32 0
  %9 = load i32, i32* %8, align 8
  %10 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 7
  store i32 %9, i32* %10, align 8
  %11 = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %3, i32 0, i32 1
  %12 = load i8*, i8** %11, align 8
  %13 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 10
  store i8* %12, i8** %13, align 8
  br label %14

; <label>:14:                                     ; preds = %2, %7
  %.0 = phi i32 [ 0, %7 ], [ -14, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_claiminterface(%struct.dev_state*, i8*) #0 {
  call void @might_fault()
  %3 = bitcast i8* %1 to i32*
  %4 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %3, i64 4) #5, !srcloc !24
  %5 = extractvalue { i32*, i64 } %4, 0
  %6 = extractvalue { i32*, i64 } %4, 1
  %7 = ptrtoint i32* %5 to i64
  %8 = trunc i64 %7 to i32
  %9 = trunc i64 %6 to i32
  %10 = icmp ne i32 %8, 0
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %2
  %12 = call i32 @claimintf(%struct.dev_state* %0, i32 %9)
  br label %13

; <label>:13:                                     ; preds = %2, %11
  %.0 = phi i32 [ %12, %11 ], [ -14, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_releaseinterface(%struct.dev_state*, i8*) #0 {
  call void @might_fault()
  %3 = bitcast i8* %1 to i32*
  %4 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %3, i64 4) #5, !srcloc !25
  %5 = extractvalue { i32*, i64 } %4, 0
  %6 = extractvalue { i32*, i64 } %4, 1
  %7 = ptrtoint i32* %5 to i64
  %8 = trunc i64 %7 to i32
  %9 = trunc i64 %6 to i32
  %10 = icmp ne i32 %8, 0
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %2
  %12 = call i32 @releaseintf(%struct.dev_state* %0, i32 %9)
  %13 = icmp slt i32 %12, 0
  br i1 %13, label %15, label %14

; <label>:14:                                     ; preds = %11
  call void @destroy_async_on_interface(%struct.dev_state* %0, i32 %9)
  br label %15

; <label>:15:                                     ; preds = %11, %2, %14
  %.0 = phi i32 [ 0, %14 ], [ -14, %2 ], [ %12, %11 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_ioctl_default(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_ioctl, align 8
  %4 = bitcast %struct.usbdevfs_ioctl* %3 to i8*
  %5 = call i64 @copy_from_user(i8* %4, i8* %1, i64 16)
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %9, label %7

; <label>:7:                                      ; preds = %2
  %8 = call i32 @proc_ioctl(%struct.dev_state* %0, %struct.usbdevfs_ioctl* %3)
  br label %9

; <label>:9:                                      ; preds = %2, %7
  %.0 = phi i32 [ %8, %7 ], [ -14, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_claim_port(%struct.dev_state*, i8*) #0 {
  call void @might_fault()
  %3 = bitcast i8* %1 to i32*
  %4 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %3, i64 4) #5, !srcloc !26
  %5 = extractvalue { i32*, i64 } %4, 0
  %6 = extractvalue { i32*, i64 } %4, 1
  %7 = ptrtoint i32* %5 to i64
  %8 = trunc i64 %7 to i32
  %9 = trunc i64 %6 to i32
  %10 = icmp ne i32 %8, 0
  br i1 %10, label %29, label %11

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %12, align 8
  %14 = call i32 @usb_hub_claim_port(%struct.usb_device* %13, i32 %9, %struct.dev_state* %0)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %29

; <label>:16:                                     ; preds = %11
  %17 = load i8, i8* @usbfs_snoop, align 1
  %18 = trunc i8 %17 to i1
  br i1 %18, label %19, label %29

; <label>:19:                                     ; preds = %16
  %20 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %21 = load %struct.usb_device*, %struct.usb_device** %20, align 8
  %22 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %21, i32 0, i32 11
  %23 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %24 = call i32 @task_pid_nr(%struct.task_struct* %23)
  %25 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %26 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %25, i32 0, i32 64
  %27 = getelementptr inbounds [16 x i8], [16 x i8]* %26, i32 0, i32 0
  %28 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %22, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.52, i32 0, i32 0), i32 %9, i32 %24, i8* %27)
  br label %29

; <label>:29:                                     ; preds = %11, %16, %19, %2
  %.0 = phi i32 [ -14, %2 ], [ %14, %19 ], [ %14, %16 ], [ %14, %11 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_release_port(%struct.dev_state*, i8*) #0 {
  call void @might_fault()
  %3 = bitcast i8* %1 to i32*
  %4 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %3, i64 4) #5, !srcloc !27
  %5 = extractvalue { i32*, i64 } %4, 0
  %6 = extractvalue { i32*, i64 } %4, 1
  %7 = ptrtoint i32* %5 to i64
  %8 = trunc i64 %7 to i32
  %9 = trunc i64 %6 to i32
  %10 = icmp ne i32 %8, 0
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %12, align 8
  %14 = call i32 @usb_hub_release_port(%struct.usb_device* %13, i32 %9, %struct.dev_state* %0)
  br label %15

; <label>:15:                                     ; preds = %2, %11
  %.0 = phi i32 [ %14, %11 ], [ -14, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_get_capabilities(%struct.dev_state*, i8*) #0 {
  %3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %3, align 8
  %5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 9
  %6 = load %struct.usb_bus*, %struct.usb_bus** %5, align 8
  %7 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %6, i32 0, i32 6
  %8 = load i8, i8* %7, align 1
  %9 = lshr i8 %8, 2
  %10 = and i8 %9, 1
  %11 = zext i8 %10 to i32
  %12 = icmp ne i32 %11, 0
  %13 = or i32 5, 2
  %. = select i1 %12, i32 5, i32 %13
  %14 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %15 = load %struct.usb_device*, %struct.usb_device** %14, align 8
  %16 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %15, i32 0, i32 9
  %17 = load %struct.usb_bus*, %struct.usb_bus** %16, align 8
  %18 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %17, i32 0, i32 7
  %19 = load i32, i32* %18, align 4
  %20 = icmp ne i32 %19, 0
  %21 = or i32 %., 8
  %.1 = select i1 %20, i32 %21, i32 %.
  call void @might_fault()
  %22 = bitcast i8* %1 to i32*
  %23 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %.1, i32* %22) #5, !srcloc !28
  %24 = icmp ne i32 %23, 0
  %.2 = select i1 %24, i32 -14, i32 0
  ret i32 %.2
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_disconnect_claim(%struct.dev_state*, i8*) #0 {
  %3 = alloca %struct.usbdevfs_disconnect_claim, align 4
  %4 = bitcast %struct.usbdevfs_disconnect_claim* %3 to i8*
  %5 = call i64 @copy_from_user(i8* %4, i8* %1, i64 264)
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %62, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %8, align 8
  %10 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %3, i32 0, i32 0
  %11 = load i32, i32* %10, align 4
  %12 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %9, i32 %11)
  %13 = icmp ne %struct.usb_interface* %12, null
  br i1 %13, label %14, label %62

; <label>:14:                                     ; preds = %7
  %15 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 7
  %16 = getelementptr inbounds %struct.device, %struct.device* %15, i32 0, i32 7
  %17 = load %struct.device_driver*, %struct.device_driver** %16, align 8
  %18 = icmp ne %struct.device_driver* %17, null
  br i1 %18, label %19, label %58

; <label>:19:                                     ; preds = %14
  %20 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 7
  %21 = getelementptr inbounds %struct.device, %struct.device* %20, i32 0, i32 7
  %22 = load %struct.device_driver*, %struct.device_driver** %21, align 8
  %23 = bitcast %struct.device_driver* %22 to i8*
  %24 = getelementptr inbounds i8, i8* %23, i64 -104
  %25 = bitcast i8* %24 to %struct.usb_driver*
  %26 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %3, i32 0, i32 1
  %27 = load i32, i32* %26, align 4
  %28 = and i32 %27, 1
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %30, label %40

; <label>:30:                                     ; preds = %19
  %31 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %3, i32 0, i32 2
  %32 = getelementptr inbounds [256 x i8], [256 x i8]* %31, i32 0, i32 0
  %33 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 7
  %34 = getelementptr inbounds %struct.device, %struct.device* %33, i32 0, i32 7
  %35 = load %struct.device_driver*, %struct.device_driver** %34, align 8
  %36 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %35, i32 0, i32 0
  %37 = load i8*, i8** %36, align 8
  %38 = call i32 @strncmp(i8* %32, i8* %37, i64 256)
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %62, label %40

; <label>:40:                                     ; preds = %30, %19
  %41 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %3, i32 0, i32 1
  %42 = load i32, i32* %41, align 4
  %43 = and i32 %42, 2
  %44 = icmp ne i32 %43, 0
  br i1 %44, label %45, label %55

; <label>:45:                                     ; preds = %40
  %46 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %3, i32 0, i32 2
  %47 = getelementptr inbounds [256 x i8], [256 x i8]* %46, i32 0, i32 0
  %48 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 7
  %49 = getelementptr inbounds %struct.device, %struct.device* %48, i32 0, i32 7
  %50 = load %struct.device_driver*, %struct.device_driver** %49, align 8
  %51 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %50, i32 0, i32 0
  %52 = load i8*, i8** %51, align 8
  %53 = call i32 @strncmp(i8* %47, i8* %52, i64 256)
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %62, label %55

; <label>:55:                                     ; preds = %45, %40
  %56 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 7
  %57 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %56, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.51, i32 0, i32 0))
  call void @usb_driver_release_interface(%struct.usb_driver* %25, %struct.usb_interface* %12)
  br label %58

; <label>:58:                                     ; preds = %55, %14
  %59 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %3, i32 0, i32 0
  %60 = load i32, i32* %59, align 4
  %61 = call i32 @claimintf(%struct.dev_state* %0, i32 %60)
  br label %62

; <label>:62:                                     ; preds = %45, %30, %7, %2, %58
  %.0 = phi i32 [ %61, %58 ], [ -14, %2 ], [ -22, %7 ], [ -16, %30 ], [ -16, %45 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i64 @copy_from_user(i8*, i8*, i64) #0 {
  %4 = call i64 @llvm.objectsize.i64.p0i8(i8* %0, i1 false)
  %5 = trunc i64 %4 to i32
  call void @might_fault()
  %6 = icmp eq i32 %5, -1
  %7 = sext i32 %5 to i64
  %8 = icmp uge i64 %7, %2
  %9 = select i1 %6, i1 true, i1 %8
  %10 = xor i1 %9, true
  %11 = xor i1 %10, true
  %12 = zext i1 %11 to i32
  %13 = sext i32 %12 to i64
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %15, label %18

; <label>:15:                                     ; preds = %3
  %16 = trunc i64 %2 to i32
  %17 = call i64 @_copy_from_user(i8* %0, i8* %1, i32 %16)
  br label %18

; <label>:18:                                     ; preds = %15, %3
  %.0 = phi i64 [ %17, %15 ], [ %2, %3 ]
  ret i64 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @check_ctrlrecip(%struct.dev_state*, i32, i32, i32) #0 {
  %5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %5, align 8
  %7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 3
  %8 = load i32, i32* %7, align 8
  %9 = icmp ne i32 %8, 4
  br i1 %9, label %10, label %22

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %12 = load %struct.usb_device*, %struct.usb_device** %11, align 8
  %13 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 3
  %14 = load i32, i32* %13, align 8
  %15 = icmp ne i32 %14, 6
  br i1 %15, label %16, label %22

; <label>:16:                                     ; preds = %10
  %17 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %18 = load %struct.usb_device*, %struct.usb_device** %17, align 8
  %19 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %18, i32 0, i32 3
  %20 = load i32, i32* %19, align 8
  %21 = icmp ne i32 %20, 7
  br i1 %21, label %59, label %22

; <label>:22:                                     ; preds = %16, %10, %4
  %23 = and i32 96, %1
  %24 = icmp eq i32 64, %23
  br i1 %24, label %59, label %25

; <label>:25:                                     ; preds = %22
  %26 = icmp eq i32 %1, 161
  %27 = icmp eq i32 %2, 0
  %or.cond = and i1 %26, %27
  br i1 %or.cond, label %28, label %44

; <label>:28:                                     ; preds = %25
  %29 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %30 = load %struct.usb_device*, %struct.usb_device** %29, align 8
  %31 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %30, i32 0, i32 15
  %32 = load %struct.usb_host_config*, %struct.usb_host_config** %31, align 8
  %33 = lshr i32 %3, 8
  %34 = and i32 %3, 255
  %35 = call %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %32, i32 %33, i32 %34)
  %36 = icmp ne %struct.usb_host_interface* %35, null
  br i1 %36, label %37, label %44

; <label>:37:                                     ; preds = %28
  %38 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %35, i32 0, i32 0
  %39 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %38, i32 0, i32 5
  %40 = load i8, i8* %39, align 1
  %41 = zext i8 %40 to i32
  %42 = icmp eq i32 %41, 7
  %43 = lshr i32 %3, 8
  %. = select i1 %42, i32 %43, i32 %3
  br label %44

; <label>:44:                                     ; preds = %37, %28, %25
  %.13 = phi i32 [ %3, %25 ], [ %3, %28 ], [ %., %37 ]
  %45 = and i32 %.13, 255
  %46 = and i32 %1, 31
  switch i32 %46, label %59 [
    i32 2, label %47
    i32 1, label %57
  ]

; <label>:47:                                     ; preds = %44
  %48 = and i32 %45, -129
  %49 = icmp eq i32 %48, 0
  br i1 %49, label %59, label %50

; <label>:50:                                     ; preds = %47
  %51 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %52 = load %struct.usb_device*, %struct.usb_device** %51, align 8
  %53 = call i32 @findintfep(%struct.usb_device* %52, i32 %45)
  %54 = icmp sge i32 %53, 0
  br i1 %54, label %55, label %59

; <label>:55:                                     ; preds = %50
  %56 = call i32 @checkintf(%struct.dev_state* %0, i32 %53)
  br label %59

; <label>:57:                                     ; preds = %44
  %58 = call i32 @checkintf(%struct.dev_state* %0, i32 %45)
  br label %59

; <label>:59:                                     ; preds = %44, %57, %55, %50, %47, %22, %16
  %.0 = phi i32 [ -113, %16 ], [ 0, %22 ], [ 0, %47 ], [ 0, %44 ], [ %58, %57 ], [ %56, %55 ], [ %53, %50 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usbfs_increase_memory_usage(i32) #0 {
  %2 = load volatile i32, i32* @usbfs_memory_mb, align 4
  %3 = icmp eq i32 %2, 0
  %4 = icmp ugt i32 %2, 2047
  %or.cond = or i1 %3, %4
  %5 = shl i32 %2, 20
  %.01 = select i1 %or.cond, i32 2146483647, i32 %5
  call void @atomic_add(i32 %0, %struct.atomic_t* @usbfs_memory_usage)
  %6 = call i32 @atomic_read(%struct.atomic_t* @usbfs_memory_usage)
  %7 = icmp ule i32 %6, %.01
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %1
  call void @atomic_sub(i32 %0, %struct.atomic_t* @usbfs_memory_usage)
  br label %9

; <label>:9:                                      ; preds = %1, %8
  %.0 = phi i32 [ -12, %8 ], [ 0, %1 ]
  ret i32 %.0
}

declare i64 @__get_free_pages(i32, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal zeroext i16 @__le16_to_cpup(i16*) #0 {
  %2 = load i16, i16* %0, align 2
  ret i16 %2
}

; Function Attrs: noinline nounwind uwtable
define internal %struct.thread_info* @current_thread_info() #0 {
  %1 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #4, !srcloc !29
  %2 = add i64 %1, 40
  %3 = sub i64 %2, 8192
  %4 = inttoptr i64 %3 to i8*
  %5 = bitcast i8* %4 to %struct.thread_info*
  ret %struct.thread_info* %5
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @__create_pipe(%struct.usb_device*, i32) #0 {
  %3 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %4 = load i32, i32* %3, align 8
  %5 = shl i32 %4, 8
  %6 = shl i32 %1, 15
  %7 = or i32 %5, %6
  ret i32 %7
}

; Function Attrs: noinline nounwind uwtable
define internal void @snoop_urb(%struct.usb_device*, i8*, i32, i32, i32, i32, i8*, i32) #0 {
  %9 = load i8, i8* @usbfs_snoop, align 1
  %10 = trunc i8 %9 to i1
  br i1 %10, label %11, label %45

; <label>:11:                                     ; preds = %8
  %12 = ashr i32 %2, 15
  %13 = and i32 %12, 15
  %14 = ashr i32 %2, 30
  %15 = and i32 %14, 3
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds [4 x i8*], [4 x i8*]* @snoop_urb.types, i64 0, i64 %16
  %18 = load i8*, i8** %17, align 8
  %19 = and i32 %2, 128
  %20 = icmp ne i32 %19, 0
  %21 = xor i1 %20, true
  %22 = xor i1 %21, true
  %23 = zext i1 %22 to i32
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds [2 x i8*], [2 x i8*]* @snoop_urb.dirs, i64 0, i64 %24
  %26 = load i8*, i8** %25, align 8
  %27 = icmp ne i8* %1, null
  %28 = icmp eq i32 %5, 0
  %29 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  br i1 %27, label %30, label %35

; <label>:30:                                     ; preds = %11
  br i1 %28, label %31, label %33

; <label>:31:                                     ; preds = %30
  %32 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %29, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.41, i32 0, i32 0), i8* %1, i32 %13, i8* %18, i8* %26, i32 %3)
  br label %40

; <label>:33:                                     ; preds = %30
  %34 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %29, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.42, i32 0, i32 0), i8* %1, i32 %13, i8* %18, i8* %26, i32 %3, i32 %4)
  br label %40

; <label>:35:                                     ; preds = %11
  br i1 %28, label %36, label %38

; <label>:36:                                     ; preds = %35
  %37 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %29, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.43, i32 0, i32 0), i32 %13, i8* %18, i8* %26, i32 %3, i32 %4)
  br label %40

; <label>:38:                                     ; preds = %35
  %39 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %29, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.44, i32 0, i32 0), i32 %13, i8* %18, i8* %26, i32 %3, i32 %4)
  br label %40

; <label>:40:                                     ; preds = %36, %38, %31, %33
  %41 = icmp ne i8* %6, null
  %42 = icmp ugt i32 %7, 0
  %or.cond = and i1 %41, %42
  br i1 %or.cond, label %43, label %45

; <label>:43:                                     ; preds = %40
  %44 = zext i32 %7 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %6, i64 %44, i1 zeroext true)
  br label %45

; <label>:45:                                     ; preds = %8, %43, %40
  ret void
}

declare i32 @usb_control_msg(%struct.usb_device*, i32, i8 zeroext, i8 zeroext, i16 zeroext, i16 zeroext, i8*, i16 zeroext, i32) #1

declare i32 @dev_printk(i8*, %struct.device*, i8*, ...) #1

declare void @free_pages(i64, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal void @usbfs_decrease_memory_usage(i32) #0 {
  call void @atomic_sub(i32 %0, %struct.atomic_t* @usbfs_memory_usage)
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1) #4

declare i64 @_copy_from_user(i8*, i8*, i32) #1

declare %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config*, i32, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @findintfep(%struct.usb_device*, i32) #0 {
  %3 = and i32 %1, -144
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %60, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 15
  %7 = load %struct.usb_host_config*, %struct.usb_host_config** %6, align 8
  %8 = icmp ne %struct.usb_host_config* %7, null
  br i1 %8, label %9, label %60

; <label>:9:                                      ; preds = %5, %58
  %.03 = phi i32 [ %59, %58 ], [ 0, %5 ]
  %10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 15
  %11 = load %struct.usb_host_config*, %struct.usb_host_config** %10, align 8
  %12 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %11, i32 0, i32 0
  %13 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %12, i32 0, i32 3
  %14 = load i8, i8* %13, align 4
  %15 = zext i8 %14 to i32
  %16 = icmp ult i32 %.03, %15
  br i1 %16, label %17, label %60

; <label>:17:                                     ; preds = %9
  %18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 15
  %19 = load %struct.usb_host_config*, %struct.usb_host_config** %18, align 8
  %20 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %19, i32 0, i32 3
  %21 = zext i32 %.03 to i64
  %22 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %20, i64 0, i64 %21
  %23 = load %struct.usb_interface*, %struct.usb_interface** %22, align 8
  br label %24

; <label>:24:                                     ; preds = %56, %17
  %.02 = phi i32 [ 0, %17 ], [ %57, %56 ]
  %25 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %23, i32 0, i32 2
  %26 = load i32, i32* %25, align 8
  %27 = icmp ult i32 %.02, %26
  br i1 %27, label %28, label %58

; <label>:28:                                     ; preds = %24
  %29 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %23, i32 0, i32 0
  %30 = load %struct.usb_host_interface*, %struct.usb_host_interface** %29, align 8
  %31 = zext i32 %.02 to i64
  %32 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %30, i64 %31
  br label %33

; <label>:33:                                     ; preds = %54, %28
  %.01 = phi i32 [ 0, %28 ], [ %55, %54 ]
  %34 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %32, i32 0, i32 0
  %35 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %34, i32 0, i32 4
  %36 = load i8, i8* %35, align 4
  %37 = zext i8 %36 to i32
  %38 = icmp ult i32 %.01, %37
  br i1 %38, label %39, label %56

; <label>:39:                                     ; preds = %33
  %40 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %32, i32 0, i32 3
  %41 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %40, align 8
  %42 = zext i32 %.01 to i64
  %43 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %41, i64 %42
  %44 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %43, i32 0, i32 0
  %45 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %44, i32 0, i32 2
  %46 = load i8, i8* %45, align 1
  %47 = zext i8 %46 to i32
  %48 = icmp eq i32 %47, %1
  br i1 %48, label %49, label %54

; <label>:49:                                     ; preds = %39
  %50 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %32, i32 0, i32 0
  %51 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %50, i32 0, i32 2
  %52 = load i8, i8* %51, align 2
  %53 = zext i8 %52 to i32
  br label %60

; <label>:54:                                     ; preds = %39
  %55 = add i32 %.01, 1
  br label %33

; <label>:56:                                     ; preds = %33
  %57 = add i32 %.02, 1
  br label %24

; <label>:58:                                     ; preds = %24
  %59 = add i32 %.03, 1
  br label %9

; <label>:60:                                     ; preds = %9, %5, %2, %49
  %.0 = phi i32 [ %53, %49 ], [ -22, %2 ], [ -3, %5 ], [ -2, %9 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @checkintf(%struct.dev_state*, i32) #0 {
  %3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %3, align 8
  %5 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 3
  %6 = load i32, i32* %5, align 8
  %7 = icmp ne i32 %6, 7
  br i1 %7, label %26, label %8

; <label>:8:                                      ; preds = %2
  %9 = zext i32 %1 to i64
  %10 = icmp uge i64 %9, 64
  br i1 %10, label %26, label %11

; <label>:11:                                     ; preds = %8
  %12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 11
  %13 = call i32 @variable_test_bit(i32 %1, i64* %12)
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %26, label %15

; <label>:15:                                     ; preds = %11
  %16 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %17 = load %struct.usb_device*, %struct.usb_device** %16, align 8
  %18 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %17, i32 0, i32 11
  %19 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %20 = call i32 @task_pid_nr(%struct.task_struct* %19)
  %21 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %22 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %21, i32 0, i32 64
  %23 = getelementptr inbounds [16 x i8], [16 x i8]* %22, i32 0, i32 0
  %24 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %18, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.34, i32 0, i32 0), i32 %20, i8* %23, i32 %1)
  %25 = call i32 @claimintf(%struct.dev_state* %0, i32 %1)
  br label %26

; <label>:26:                                     ; preds = %11, %8, %2, %15
  %.0 = phi i32 [ %25, %15 ], [ -113, %2 ], [ -22, %8 ], [ 0, %11 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @variable_test_bit(i32, i64*) #0 {
  %3 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %1, i32 %0) #5, !srcloc !30
  ret i32 %3
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @task_pid_nr(%struct.task_struct*) #0 {
  %2 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 34
  %3 = load i32, i32* %2, align 4
  ret i32 %3
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @claimintf(%struct.dev_state*, i32) #0 {
  %3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %3, align 8
  %5 = zext i32 %1 to i64
  %6 = icmp uge i64 %5, 64
  br i1 %6, label %21, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 11
  %9 = call i32 @variable_test_bit(i32 %1, i64* %8)
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %21, label %11

; <label>:11:                                     ; preds = %7
  %12 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %4, i32 %1)
  %13 = icmp ne %struct.usb_interface* %12, null
  br i1 %13, label %14, label %17

; <label>:14:                                     ; preds = %11
  %15 = bitcast %struct.dev_state* %0 to i8*
  %16 = call i32 @usb_driver_claim_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %12, i8* %15)
  br label %17

; <label>:17:                                     ; preds = %11, %14
  %.0 = phi i32 [ %16, %14 ], [ -2, %11 ]
  %18 = icmp eq i32 %.0, 0
  br i1 %18, label %19, label %21

; <label>:19:                                     ; preds = %17
  %20 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 11
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %20, i32 %1, i64* %20) #5, !srcloc !31
  br label %21

; <label>:21:                                     ; preds = %17, %19, %7, %2
  %.01 = phi i32 [ -22, %2 ], [ 0, %7 ], [ %.0, %19 ], [ %.0, %17 ]
  ret i32 %.01
}

declare %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device*, i32) #1

declare i32 @usb_driver_claim_interface(%struct.usb_driver*, %struct.usb_interface*, i8*) #1

; Function Attrs: noinline nounwind uwtable
define internal void @atomic_add(i32, %struct.atomic_t*) #0 {
  %3 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %1, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; addl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* %3, i32 %0, i32* %3) #5, !srcloc !32
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @atomic_read(%struct.atomic_t*) #0 {
  %2 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %0, i32 0, i32 0
  %3 = load volatile i32, i32* %2, align 4
  ret i32 %3
}

; Function Attrs: noinline nounwind uwtable
define internal void @atomic_sub(i32, %struct.atomic_t*) #0 {
  %3 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %1, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* %3, i32 %0, i32* %3) #5, !srcloc !33
  ret void
}

declare void @print_hex_dump(i8*, i8*, i32, i32, i32, i8*, i64, i1 zeroext) #1

; Function Attrs: noinline nounwind uwtable
define internal zeroext i16 @usb_maxpacket(%struct.usb_device*, i32, i32) #0 {
  %4 = ashr i32 %1, 15
  %5 = and i32 %4, 15
  %6 = icmp ne i32 %2, 0
  %7 = and i32 %1, 128
  %8 = icmp ne i32 %7, 0
  %9 = xor i1 %8, true
  %10 = xor i1 %9, true
  br i1 %6, label %11, label %27

; <label>:11:                                     ; preds = %3
  %12 = zext i1 %10 to i32
  %13 = icmp ne i32 %12, 0
  %14 = xor i1 %13, true
  %15 = xor i1 %14, true
  %16 = zext i1 %15 to i32
  %17 = sext i32 %16 to i64
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %19, label %20

; <label>:19:                                     ; preds = %11
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.46, i32 0, i32 0), i32 1773)
  br label %20

; <label>:20:                                     ; preds = %19, %11
  %21 = icmp ne i32 %12, 0
  %22 = xor i1 %21, true
  %23 = xor i1 %22, true
  %24 = zext i1 %23 to i32
  %25 = sext i32 %24 to i64
  %26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 17
  br label %44

; <label>:27:                                     ; preds = %3
  %28 = xor i1 %10, true
  %29 = zext i1 %28 to i32
  %30 = icmp ne i32 %29, 0
  %31 = xor i1 %30, true
  %32 = xor i1 %31, true
  %33 = zext i1 %32 to i32
  %34 = sext i32 %33 to i64
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %36, label %37

; <label>:36:                                     ; preds = %27
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.46, i32 0, i32 0), i32 1776)
  br label %37

; <label>:37:                                     ; preds = %36, %27
  %38 = icmp ne i32 %29, 0
  %39 = xor i1 %38, true
  %40 = xor i1 %39, true
  %41 = zext i1 %40 to i32
  %42 = sext i32 %41 to i64
  %43 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 16
  br label %44

; <label>:44:                                     ; preds = %37, %20
  %.sink2 = phi [16 x %struct.usb_host_endpoint*]* [ %43, %37 ], [ %26, %20 ]
  %45 = zext i32 %5 to i64
  %46 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %.sink2, i64 0, i64 %45
  %47 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %46, align 8
  %48 = icmp ne %struct.usb_host_endpoint* %47, null
  br i1 %48, label %49, label %53

; <label>:49:                                     ; preds = %44
  %50 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %47, i32 0, i32 0
  %51 = call i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %50)
  %52 = trunc i32 %51 to i16
  br label %53

; <label>:53:                                     ; preds = %44, %49
  %.0 = phi i16 [ %52, %49 ], [ 0, %44 ]
  ret i16 %.0
}

declare i32 @usb_bulk_msg(%struct.usb_device*, i32, i8*, i32, i32*, i32) #1

declare void @kfree(i8*) #1

declare void @warn_slowpath_null(i8*, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor*) #0 {
  %2 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 4
  %3 = load i16, i16* %2, align 1
  %4 = zext i16 %3 to i32
  ret i32 %4
}

declare void @usb_reset_endpoint(%struct.usb_device*, i32) #1

declare i32 @usb_reset_device(%struct.usb_device*) #1

declare i32 @usb_clear_halt(%struct.usb_device*, i32) #1

declare i64 @strlcpy(i8*, i8*, i64) #1

declare i32 @usb_set_interface(%struct.usb_device*, i32, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @usb_interface_claimed(%struct.usb_interface*) #0 {
  %2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 7
  %3 = getelementptr inbounds %struct.device, %struct.device* %2, i32 0, i32 7
  %4 = load %struct.device_driver*, %struct.device_driver** %3, align 8
  %5 = icmp ne %struct.device_driver* %4, null
  %6 = zext i1 %5 to i32
  ret i32 %6
}

declare i32 @usb_reset_configuration(%struct.usb_device*) #1

declare i32 @usb_set_configuration(%struct.usb_device*, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_do_submiturb(%struct.dev_state*, %struct.usbdevfs_urb*, %struct.usbdevfs_iso_packet_desc*, i8*) #0 {
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 3
  %8 = load i32, i32* %7, align 8
  %9 = and i32 %8, -232
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %645, label %11

; <label>:11:                                     ; preds = %4
  %12 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %13 = load i32, i32* %12, align 8
  %14 = icmp sgt i32 %13, 0
  br i1 %14, label %15, label %19

; <label>:15:                                     ; preds = %11
  %16 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 4
  %17 = load i8*, i8** %16, align 8
  %18 = icmp ne i8* %17, null
  br i1 %18, label %19, label %645

; <label>:19:                                     ; preds = %15, %11
  %20 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 0
  %21 = load i8, i8* %20, align 8
  %22 = zext i8 %21 to i32
  %23 = icmp eq i32 %22, 2
  br i1 %23, label %24, label %30

; <label>:24:                                     ; preds = %19
  %25 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 1
  %26 = load i8, i8* %25, align 1
  %27 = zext i8 %26 to i32
  %28 = and i32 %27, -129
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %41, label %30

; <label>:30:                                     ; preds = %24, %19
  %31 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %32 = load %struct.usb_device*, %struct.usb_device** %31, align 8
  %33 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 1
  %34 = load i8, i8* %33, align 1
  %35 = zext i8 %34 to i32
  %36 = call i32 @findintfep(%struct.usb_device* %32, i32 %35)
  %37 = icmp slt i32 %36, 0
  br i1 %37, label %645, label %38

; <label>:38:                                     ; preds = %30
  %39 = call i32 @checkintf(%struct.dev_state* %0, i32 %36)
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %645, label %41

; <label>:41:                                     ; preds = %38, %24
  %.0 = phi i32 [ -1, %24 ], [ %36, %38 ]
  %42 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 1
  %43 = load i8, i8* %42, align 1
  %44 = zext i8 %43 to i32
  %45 = and i32 %44, 128
  %46 = icmp ne i32 %45, 0
  %47 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %48 = load %struct.usb_device*, %struct.usb_device** %47, align 8
  %49 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %48, i32 0, i32 17
  %50 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %48, i32 0, i32 16
  %.sink21 = select i1 %46, [16 x %struct.usb_host_endpoint*]* %50, [16 x %struct.usb_host_endpoint*]* %49
  %.02 = select i1 %46, i32 1, i32 0
  %51 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 1
  %52 = load i8, i8* %51, align 1
  %53 = zext i8 %52 to i32
  %54 = and i32 %53, 15
  %55 = sext i32 %54 to i64
  %56 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %.sink21, i64 0, i64 %55
  %57 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %56, align 8
  %58 = icmp ne %struct.usb_host_endpoint* %57, null
  br i1 %58, label %59, label %645

; <label>:59:                                     ; preds = %41
  %60 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 0
  %61 = load i8, i8* %60, align 8
  %62 = zext i8 %61 to i32
  switch i32 %62, label %645 [
    i32 2, label %63
    i32 3, label %153
    i32 1, label %175
    i32 0, label %181
  ]

; <label>:63:                                     ; preds = %59
  %64 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %57, i32 0, i32 0
  %65 = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %64)
  %66 = icmp ne i32 %65, 0
  br i1 %66, label %67, label %645

; <label>:67:                                     ; preds = %63
  %68 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %69 = load i32, i32* %68, align 8
  %70 = icmp slt i32 %69, 8
  br i1 %70, label %645, label %71

; <label>:71:                                     ; preds = %67
  %72 = call i8* @__kmalloc(i64 8, i32 208) #5
  %73 = bitcast i8* %72 to %struct.usb_ctrlrequest*
  %74 = icmp ne %struct.usb_ctrlrequest* %73, null
  br i1 %74, label %75, label %645

; <label>:75:                                     ; preds = %71
  %76 = bitcast %struct.usb_ctrlrequest* %73 to i8*
  %77 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 4
  %78 = load i8*, i8** %77, align 8
  %79 = call i64 @copy_from_user(i8* %76, i8* %78, i64 8)
  %80 = icmp ne i64 %79, 0
  br i1 %80, label %640, label %81

; <label>:81:                                     ; preds = %75
  %82 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %83 = load i32, i32* %82, align 8
  %84 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 4
  %85 = call zeroext i16 @__le16_to_cpup(i16* %84)
  %86 = zext i16 %85 to i32
  %87 = add nsw i32 %86, 8
  %88 = icmp slt i32 %83, %87
  br i1 %88, label %640, label %89

; <label>:89:                                     ; preds = %81
  %90 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 0
  %91 = load i8, i8* %90, align 1
  %92 = zext i8 %91 to i32
  %93 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 1
  %94 = load i8, i8* %93, align 1
  %95 = zext i8 %94 to i32
  %96 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 3
  %97 = call zeroext i16 @__le16_to_cpup(i16* %96)
  %98 = zext i16 %97 to i32
  %99 = call i32 @check_ctrlrecip(%struct.dev_state* %0, i32 %92, i32 %95, i32 %98)
  %100 = icmp ne i32 %99, 0
  br i1 %100, label %640, label %101

; <label>:101:                                    ; preds = %89
  %102 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 8
  store i32 0, i32* %102, align 4
  %103 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 4
  %104 = call zeroext i16 @__le16_to_cpup(i16* %103)
  %105 = zext i16 %104 to i32
  %106 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  store i32 %105, i32* %106, align 8
  %107 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 4
  %108 = load i8*, i8** %107, align 8
  %109 = getelementptr i8, i8* %108, i64 8
  store i8* %109, i8** %107, align 8
  %110 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 0
  %111 = load i8, i8* %110, align 1
  %112 = zext i8 %111 to i32
  %113 = and i32 %112, 128
  %114 = icmp ne i32 %113, 0
  br i1 %114, label %115, label %124

; <label>:115:                                    ; preds = %101
  %116 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %117 = load i32, i32* %116, align 8
  %118 = icmp ne i32 %117, 0
  br i1 %118, label %119, label %124

; <label>:119:                                    ; preds = %115
  %120 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 1
  %121 = load i8, i8* %120, align 1
  %122 = zext i8 %121 to i32
  %123 = or i32 %122, 128
  br label %129

; <label>:124:                                    ; preds = %115, %101
  %125 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 1
  %126 = load i8, i8* %125, align 1
  %127 = zext i8 %126 to i32
  %128 = and i32 %127, -129
  br label %129

; <label>:129:                                    ; preds = %124, %119
  %.sink26 = phi i32 [ %128, %124 ], [ %123, %119 ]
  %.sink25 = phi i8* [ %125, %124 ], [ %120, %119 ]
  %.13 = phi i32 [ 1, %119 ], [ 0, %124 ]
  %130 = trunc i32 %.sink26 to i8
  store i8 %130, i8* %.sink25, align 1
  %131 = load i8, i8* @usbfs_snoop, align 1
  %132 = trunc i8 %131 to i1
  br i1 %132, label %133, label %230

; <label>:133:                                    ; preds = %129
  %134 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %135 = load %struct.usb_device*, %struct.usb_device** %134, align 8
  %136 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %135, i32 0, i32 11
  %137 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 0
  %138 = load i8, i8* %137, align 1
  %139 = zext i8 %138 to i32
  %140 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 1
  %141 = load i8, i8* %140, align 1
  %142 = zext i8 %141 to i32
  %143 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 2
  %144 = call zeroext i16 @__le16_to_cpup(i16* %143)
  %145 = zext i16 %144 to i32
  %146 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 3
  %147 = call zeroext i16 @__le16_to_cpup(i16* %146)
  %148 = zext i16 %147 to i32
  %149 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %73, i32 0, i32 4
  %150 = call zeroext i16 @__le16_to_cpup(i16* %149)
  %151 = zext i16 %150 to i32
  %152 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %136, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @.str.31, i32 0, i32 0), i32 %139, i32 %142, i32 %145, i32 %148, i32 %151)
  br label %230

; <label>:153:                                    ; preds = %59
  %154 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %57, i32 0, i32 0
  %155 = call i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %154)
  switch i32 %155, label %158 [
    i32 0, label %645
    i32 1, label %645
    i32 3, label %156
  ]

; <label>:156:                                    ; preds = %153
  %157 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 0
  store i8 1, i8* %157, align 8
  br label %179

; <label>:158:                                    ; preds = %153
  %159 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 8
  store i32 0, i32* %159, align 4
  %160 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %161 = load i32, i32* %160, align 8
  %162 = add nsw i32 %161, 16384
  %163 = sub nsw i32 %162, 1
  %164 = sdiv i32 %163, 16384
  %165 = icmp eq i32 %164, 1
  br i1 %165, label %174, label %166

; <label>:166:                                    ; preds = %158
  %167 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %168 = load %struct.usb_device*, %struct.usb_device** %167, align 8
  %169 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %168, i32 0, i32 9
  %170 = load %struct.usb_bus*, %struct.usb_bus** %169, align 8
  %171 = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %170, i32 0, i32 7
  %172 = load i32, i32* %171, align 4
  %173 = icmp ugt i32 %164, %172
  br i1 %173, label %174, label %230

; <label>:174:                                    ; preds = %166, %158
  br label %230

; <label>:175:                                    ; preds = %59
  %176 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %57, i32 0, i32 0
  %177 = call i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %176)
  %178 = icmp ne i32 %177, 0
  br i1 %178, label %179, label %645

; <label>:179:                                    ; preds = %175, %156
  %180 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 8
  store i32 0, i32* %180, align 4
  br label %230

; <label>:181:                                    ; preds = %59
  %182 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 8
  %183 = load i32, i32* %182, align 4
  %184 = icmp slt i32 %183, 1
  br i1 %184, label %645, label %185

; <label>:185:                                    ; preds = %181
  %186 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 8
  %187 = load i32, i32* %186, align 4
  %188 = icmp sgt i32 %187, 128
  br i1 %188, label %645, label %189

; <label>:189:                                    ; preds = %185
  %190 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %57, i32 0, i32 0
  %191 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %190)
  %192 = icmp ne i32 %191, 0
  br i1 %192, label %193, label %645

; <label>:193:                                    ; preds = %189
  %194 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 8
  %195 = load i32, i32* %194, align 4
  %196 = sext i32 %195 to i64
  %197 = mul i64 12, %196
  %198 = trunc i64 %197 to i32
  %199 = zext i32 %198 to i64
  %200 = call i8* @__kmalloc(i64 %199, i32 208) #5
  %201 = bitcast i8* %200 to %struct.usbdevfs_iso_packet_desc*
  %202 = icmp ne %struct.usbdevfs_iso_packet_desc* %201, null
  br i1 %202, label %203, label %645

; <label>:203:                                    ; preds = %193
  %204 = bitcast %struct.usbdevfs_iso_packet_desc* %201 to i8*
  %205 = bitcast %struct.usbdevfs_iso_packet_desc* %2 to i8*
  %206 = zext i32 %198 to i64
  %207 = call i64 @copy_from_user(i8* %204, i8* %205, i64 %206)
  %208 = icmp ne i64 %207, 0
  br i1 %208, label %640, label %209

; <label>:209:                                    ; preds = %203, %219
  %.011 = phi i32 [ %225, %219 ], [ 0, %203 ]
  %.08 = phi i32 [ %224, %219 ], [ 0, %203 ]
  %210 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 8
  %211 = load i32, i32* %210, align 4
  %212 = icmp ult i32 %.011, %211
  %213 = zext i32 %.011 to i64
  br i1 %212, label %214, label %226

; <label>:214:                                    ; preds = %209
  %215 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %201, i64 %213
  %216 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %215, i32 0, i32 0
  %217 = load i32, i32* %216, align 4
  %218 = icmp ugt i32 %217, 49152
  br i1 %218, label %640, label %219

; <label>:219:                                    ; preds = %214
  %220 = zext i32 %.011 to i64
  %221 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %201, i64 %220
  %222 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %221, i32 0, i32 0
  %223 = load i32, i32* %222, align 4
  %224 = add i32 %.08, %223
  %225 = add i32 %.011, 1
  br label %209

; <label>:226:                                    ; preds = %209
  %227 = mul i64 %213, 16
  %228 = trunc i64 %227 to i32
  %229 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  store i32 %.08, i32* %229, align 8
  br label %230

; <label>:230:                                    ; preds = %166, %174, %133, %129, %226, %179
  %.018 = phi %struct.usbdevfs_iso_packet_desc* [ %201, %226 ], [ null, %179 ], [ null, %129 ], [ null, %133 ], [ null, %174 ], [ null, %166 ]
  %.014 = phi %struct.usb_ctrlrequest* [ null, %226 ], [ null, %179 ], [ %73, %129 ], [ %73, %133 ], [ null, %174 ], [ null, %166 ]
  %.112 = phi i32 [ %228, %226 ], [ 0, %179 ], [ 8, %129 ], [ 8, %133 ], [ 0, %174 ], [ 0, %166 ]
  %.2 = phi i32 [ %.02, %226 ], [ %.02, %179 ], [ %.13, %129 ], [ %.13, %133 ], [ %.02, %174 ], [ %.02, %166 ]
  %.1 = phi i32 [ 0, %226 ], [ 0, %179 ], [ 0, %129 ], [ 0, %133 ], [ 0, %174 ], [ %164, %166 ]
  %231 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %232 = load i32, i32* %231, align 8
  %233 = icmp uge i32 %232, 2146483647
  br i1 %233, label %640, label %234

; <label>:234:                                    ; preds = %230
  %235 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %236 = load i32, i32* %235, align 8
  %237 = icmp sgt i32 %236, 0
  br i1 %237, label %238, label %257

; <label>:238:                                    ; preds = %234
  %239 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 4
  %240 = load i8*, i8** %239, align 8
  %241 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %242 = load i32, i32* %241, align 8
  %243 = sext i32 %242 to i64
  %244 = call %struct.thread_info* @current_thread_info()
  %245 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %244, i32 0, i32 6
  %246 = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %245, i32 0, i32 0
  %247 = load i64, i64* %246, align 8
  %248 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %240, i64 %243, i64 %247) #6, !srcloc !34
  %249 = extractvalue { i64, i64 } %248, 0
  %250 = extractvalue { i64, i64 } %248, 1
  %251 = icmp eq i64 %249, 0
  %252 = xor i1 %251, true
  %253 = xor i1 %252, true
  %254 = zext i1 %253 to i32
  %255 = sext i32 %254 to i64
  %256 = icmp ne i64 %255, 0
  br i1 %256, label %257, label %640

; <label>:257:                                    ; preds = %238, %234
  %258 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 8
  %259 = load i32, i32* %258, align 4
  %260 = call %struct.async* @alloc_async(i32 %259)
  %261 = icmp ne %struct.async* %260, null
  br i1 %261, label %262, label %640

; <label>:262:                                    ; preds = %257
  %263 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %264 = load i32, i32* %263, align 8
  %265 = sext i32 %264 to i64
  %266 = add i64 280, %265
  %267 = sext i32 %.1 to i64
  %268 = mul i64 %267, 32
  %269 = add i64 %266, %268
  %270 = zext i32 %.112 to i64
  %271 = add i64 %270, %269
  %272 = trunc i64 %271 to i32
  %273 = call i32 @usbfs_increase_memory_usage(i32 %272)
  %274 = icmp ne i32 %273, 0
  br i1 %274, label %640, label %275

; <label>:275:                                    ; preds = %262
  %276 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 9
  store i32 %272, i32* %276, align 8
  %277 = icmp ne i32 %.1, 0
  br i1 %277, label %278, label %338

; <label>:278:                                    ; preds = %275
  %279 = sext i32 %.1 to i64
  %280 = mul i64 %279, 32
  %281 = call i8* @__kmalloc(i64 %280, i32 208) #5
  %282 = bitcast i8* %281 to %struct.scatterlist*
  %283 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %284 = load %struct.urb*, %struct.urb** %283, align 8
  %285 = getelementptr inbounds %struct.urb, %struct.urb* %284, i32 0, i32 16
  store %struct.scatterlist* %282, %struct.scatterlist** %285, align 8
  %286 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %287 = load %struct.urb*, %struct.urb** %286, align 8
  %288 = getelementptr inbounds %struct.urb, %struct.urb* %287, i32 0, i32 16
  %289 = load %struct.scatterlist*, %struct.scatterlist** %288, align 8
  %290 = icmp ne %struct.scatterlist* %289, null
  br i1 %290, label %291, label %640

; <label>:291:                                    ; preds = %278
  %292 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %293 = load %struct.urb*, %struct.urb** %292, align 8
  %294 = getelementptr inbounds %struct.urb, %struct.urb* %293, i32 0, i32 18
  store i32 %.1, i32* %294, align 4
  %295 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %296 = load %struct.urb*, %struct.urb** %295, align 8
  %297 = getelementptr inbounds %struct.urb, %struct.urb* %296, i32 0, i32 16
  %298 = load %struct.scatterlist*, %struct.scatterlist** %297, align 8
  %299 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %300 = load %struct.urb*, %struct.urb** %299, align 8
  %301 = getelementptr inbounds %struct.urb, %struct.urb* %300, i32 0, i32 18
  %302 = load i32, i32* %301, align 4
  call void @sg_init_table(%struct.scatterlist* %298, i32 %302)
  %303 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %304 = load i32, i32* %303, align 8
  br label %305

; <label>:305:                                    ; preds = %335, %291
  %.19 = phi i32 [ %304, %291 ], [ %336, %335 ]
  %.07 = phi i32 [ 0, %291 ], [ %337, %335 ]
  %306 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %307 = load %struct.urb*, %struct.urb** %306, align 8
  %308 = getelementptr inbounds %struct.urb, %struct.urb* %307, i32 0, i32 18
  %309 = load i32, i32* %308, align 4
  %310 = icmp slt i32 %.07, %309
  br i1 %310, label %311, label %382

; <label>:311:                                    ; preds = %305
  %312 = icmp ugt i32 %.19, 16384
  %..19 = select i1 %312, i32 16384, i32 %.19
  %313 = zext i32 %..19 to i64
  %314 = call i8* @__kmalloc(i64 %313, i32 208) #5
  %315 = icmp ne i8* %314, null
  br i1 %315, label %316, label %640

; <label>:316:                                    ; preds = %311
  %317 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %318 = load %struct.urb*, %struct.urb** %317, align 8
  %319 = getelementptr inbounds %struct.urb, %struct.urb* %318, i32 0, i32 16
  %320 = load %struct.scatterlist*, %struct.scatterlist** %319, align 8
  %321 = sext i32 %.07 to i64
  %322 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %320, i64 %321
  call void @sg_set_buf(%struct.scatterlist* %322, i8* %314, i32 %..19)
  %323 = icmp ne i32 %.2, 0
  br i1 %323, label %335, label %324

; <label>:324:                                    ; preds = %316
  %325 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 4
  %326 = load i8*, i8** %325, align 8
  %327 = zext i32 %..19 to i64
  %328 = call i64 @copy_from_user(i8* %314, i8* %326, i64 %327)
  %329 = icmp ne i64 %328, 0
  br i1 %329, label %640, label %330

; <label>:330:                                    ; preds = %324
  %331 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 4
  %332 = load i8*, i8** %331, align 8
  %333 = zext i32 %..19 to i64
  %334 = getelementptr i8, i8* %332, i64 %333
  store i8* %334, i8** %331, align 8
  br label %335

; <label>:335:                                    ; preds = %330, %316
  %336 = sub i32 %.19, %..19
  %337 = add nsw i32 %.07, 1
  br label %305

; <label>:338:                                    ; preds = %275
  %339 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %340 = load i32, i32* %339, align 8
  %341 = icmp sgt i32 %340, 0
  br i1 %341, label %342, label %382

; <label>:342:                                    ; preds = %338
  %343 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %344 = load i32, i32* %343, align 8
  %345 = sext i32 %344 to i64
  %346 = call i8* @__kmalloc(i64 %345, i32 208) #5
  %347 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %348 = load %struct.urb*, %struct.urb** %347, align 8
  %349 = getelementptr inbounds %struct.urb, %struct.urb* %348, i32 0, i32 14
  store i8* %346, i8** %349, align 8
  %350 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %351 = load %struct.urb*, %struct.urb** %350, align 8
  %352 = getelementptr inbounds %struct.urb, %struct.urb* %351, i32 0, i32 14
  %353 = load i8*, i8** %352, align 8
  %354 = icmp ne i8* %353, null
  br i1 %354, label %355, label %640

; <label>:355:                                    ; preds = %342
  %356 = icmp ne i32 %.2, 0
  br i1 %356, label %369, label %357

; <label>:357:                                    ; preds = %355
  %358 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %359 = load %struct.urb*, %struct.urb** %358, align 8
  %360 = getelementptr inbounds %struct.urb, %struct.urb* %359, i32 0, i32 14
  %361 = load i8*, i8** %360, align 8
  %362 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 4
  %363 = load i8*, i8** %362, align 8
  %364 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %365 = load i32, i32* %364, align 8
  %366 = sext i32 %365 to i64
  %367 = call i64 @copy_from_user(i8* %361, i8* %363, i64 %366)
  %368 = icmp ne i64 %367, 0
  br i1 %368, label %640, label %382

; <label>:369:                                    ; preds = %355
  %370 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 0
  %371 = load i8, i8* %370, align 8
  %372 = zext i8 %371 to i32
  %373 = icmp eq i32 %372, 0
  br i1 %373, label %374, label %382

; <label>:374:                                    ; preds = %369
  %375 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %376 = load %struct.urb*, %struct.urb** %375, align 8
  %377 = getelementptr inbounds %struct.urb, %struct.urb* %376, i32 0, i32 14
  %378 = load i8*, i8** %377, align 8
  %379 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %380 = load i32, i32* %379, align 8
  %381 = sext i32 %380 to i64
  call void @llvm.memset.p0i8.i64(i8* %378, i8 0, i64 %381, i32 1, i1 false)
  br label %382

; <label>:382:                                    ; preds = %338, %369, %374, %357, %305
  %383 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %384 = load %struct.usb_device*, %struct.usb_device** %383, align 8
  %385 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %386 = load %struct.urb*, %struct.urb** %385, align 8
  %387 = getelementptr inbounds %struct.urb, %struct.urb* %386, i32 0, i32 8
  store %struct.usb_device* %384, %struct.usb_device** %387, align 8
  %388 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 0
  %389 = load i8, i8* %388, align 8
  %390 = zext i8 %389 to i32
  %391 = shl i32 %390, 30
  %392 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %393 = load %struct.usb_device*, %struct.usb_device** %392, align 8
  %394 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 1
  %395 = load i8, i8* %394, align 1
  %396 = zext i8 %395 to i32
  %397 = and i32 %396, 15
  %398 = call i32 @__create_pipe(%struct.usb_device* %393, i32 %397)
  %399 = or i32 %391, %398
  %400 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 1
  %401 = load i8, i8* %400, align 1
  %402 = zext i8 %401 to i32
  %403 = and i32 %402, 128
  %404 = or i32 %399, %403
  %405 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %406 = load %struct.urb*, %struct.urb** %405, align 8
  %407 = getelementptr inbounds %struct.urb, %struct.urb* %406, i32 0, i32 10
  store i32 %404, i32* %407, align 8
  %408 = icmp ne i32 %.2, 0
  %409 = select i1 %408, i32 512, i32 0
  %410 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 3
  %411 = load i32, i32* %410, align 8
  %412 = and i32 %411, 2
  %413 = icmp ne i32 %412, 0
  %414 = or i32 %409, 2
  %. = select i1 %413, i32 %414, i32 %409
  %415 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 3
  %416 = load i32, i32* %415, align 8
  %417 = and i32 %416, 1
  %418 = icmp ne i32 %417, 0
  %419 = or i32 %., 1
  %.3 = select i1 %418, i32 %419, i32 %.
  %420 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 3
  %421 = load i32, i32* %420, align 8
  %422 = and i32 %421, 32
  %423 = icmp ne i32 %422, 0
  %424 = or i32 %.3, 32
  %..3 = select i1 %423, i32 %424, i32 %.3
  %425 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 3
  %426 = load i32, i32* %425, align 8
  %427 = and i32 %426, 64
  %428 = icmp ne i32 %427, 0
  %429 = or i32 %..3, 64
  %.5 = select i1 %428, i32 %429, i32 %..3
  %430 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 3
  %431 = load i32, i32* %430, align 8
  %432 = and i32 %431, 128
  %433 = icmp ne i32 %432, 0
  %434 = or i32 %.5, 128
  %..5 = select i1 %433, i32 %434, i32 %.5
  %435 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %436 = load %struct.urb*, %struct.urb** %435, align 8
  %437 = getelementptr inbounds %struct.urb, %struct.urb* %436, i32 0, i32 13
  store i32 %..5, i32* %437, align 4
  %438 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %439 = load i32, i32* %438, align 8
  %440 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %441 = load %struct.urb*, %struct.urb** %440, align 8
  %442 = getelementptr inbounds %struct.urb, %struct.urb* %441, i32 0, i32 19
  store i32 %439, i32* %442, align 8
  %443 = bitcast %struct.usb_ctrlrequest* %.014 to i8*
  %444 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %445 = load %struct.urb*, %struct.urb** %444, align 8
  %446 = getelementptr inbounds %struct.urb, %struct.urb* %445, i32 0, i32 21
  store i8* %443, i8** %446, align 8
  %447 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 7
  %448 = load i32, i32* %447, align 8
  %449 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %450 = load %struct.urb*, %struct.urb** %449, align 8
  %451 = getelementptr inbounds %struct.urb, %struct.urb* %450, i32 0, i32 23
  store i32 %448, i32* %451, align 8
  %452 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 8
  %453 = load i32, i32* %452, align 4
  %454 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %455 = load %struct.urb*, %struct.urb** %454, align 8
  %456 = getelementptr inbounds %struct.urb, %struct.urb* %455, i32 0, i32 24
  store i32 %453, i32* %456, align 4
  %457 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 0
  %458 = load i8, i8* %457, align 8
  %459 = zext i8 %458 to i32
  %460 = icmp eq i32 %459, 0
  br i1 %460, label %467, label %461

; <label>:461:                                    ; preds = %382
  %462 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %463 = load %struct.usb_device*, %struct.usb_device** %462, align 8
  %464 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %463, i32 0, i32 4
  %465 = load i32, i32* %464, align 4
  %466 = icmp eq i32 %465, 3
  br i1 %466, label %467, label %482

; <label>:467:                                    ; preds = %461, %382
  store i32 15, i32* %5, align 4
  %468 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %57, i32 0, i32 0
  %469 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %468, i32 0, i32 5
  %470 = load i8, i8* %469, align 2
  %471 = zext i8 %470 to i32
  %472 = sub nsw i32 %471, 1
  store i32 %472, i32* %6, align 4
  %473 = icmp eq i32* %5, %6
  %474 = zext i1 %473 to i32
  %475 = load i32, i32* %5, align 4
  %476 = load i32, i32* %6, align 4
  %477 = icmp slt i32 %475, %476
  %478 = load i32, i32* %5, align 4
  %479 = load i32, i32* %6, align 4
  %480 = select i1 %477, i32 %478, i32 %479
  %481 = shl i32 1, %480
  br label %487

; <label>:482:                                    ; preds = %461
  %483 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %57, i32 0, i32 0
  %484 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %483, i32 0, i32 5
  %485 = load i8, i8* %484, align 2
  %486 = zext i8 %485 to i32
  br label %487

; <label>:487:                                    ; preds = %482, %467
  %.sink = phi i32 [ %486, %482 ], [ %481, %467 ]
  %488 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %489 = load %struct.urb*, %struct.urb** %488, align 8
  %490 = getelementptr inbounds %struct.urb, %struct.urb* %489, i32 0, i32 25
  store i32 %.sink, i32* %490, align 8
  %491 = bitcast %struct.async* %260 to i8*
  %492 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %493 = load %struct.urb*, %struct.urb** %492, align 8
  %494 = getelementptr inbounds %struct.urb, %struct.urb* %493, i32 0, i32 27
  store i8* %491, i8** %494, align 8
  %495 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %496 = load %struct.urb*, %struct.urb** %495, align 8
  %497 = getelementptr inbounds %struct.urb, %struct.urb* %496, i32 0, i32 28
  store void (%struct.urb*)* @async_completed, void (%struct.urb*)** %497, align 8
  br label %498

; <label>:498:                                    ; preds = %502, %487
  %.7 = phi i32 [ 0, %487 ], [ %524, %502 ]
  %.210 = phi i32 [ 0, %487 ], [ %523, %502 ]
  %499 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 8
  %500 = load i32, i32* %499, align 4
  %501 = icmp ult i32 %.7, %500
  br i1 %501, label %502, label %525

; <label>:502:                                    ; preds = %498
  %503 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %504 = load %struct.urb*, %struct.urb** %503, align 8
  %505 = getelementptr inbounds %struct.urb, %struct.urb* %504, i32 0, i32 29
  %506 = zext i32 %.7 to i64
  %507 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %505, i64 0, i64 %506
  %508 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %507, i32 0, i32 0
  store i32 %.210, i32* %508, align 8
  %509 = zext i32 %.7 to i64
  %510 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %.018, i64 %509
  %511 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %510, i32 0, i32 0
  %512 = load i32, i32* %511, align 4
  %513 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %514 = load %struct.urb*, %struct.urb** %513, align 8
  %515 = getelementptr inbounds %struct.urb, %struct.urb* %514, i32 0, i32 29
  %516 = zext i32 %.7 to i64
  %517 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %515, i64 0, i64 %516
  %518 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %517, i32 0, i32 1
  store i32 %512, i32* %518, align 4
  %519 = zext i32 %.7 to i64
  %520 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %.018, i64 %519
  %521 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %520, i32 0, i32 0
  %522 = load i32, i32* %521, align 4
  %523 = add i32 %.210, %522
  %524 = add i32 %.7, 1
  br label %498

; <label>:525:                                    ; preds = %498
  %526 = bitcast %struct.usbdevfs_iso_packet_desc* %.018 to i8*
  call void @kfree(i8* %526)
  %527 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 1
  store %struct.dev_state* %0, %struct.dev_state** %527, align 8
  %528 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 7
  store i8* %3, i8** %528, align 8
  %529 = icmp ne i32 %.2, 0
  br i1 %529, label %530, label %537

; <label>:530:                                    ; preds = %525
  %531 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 5
  %532 = load i32, i32* %531, align 8
  %533 = icmp sgt i32 %532, 0
  br i1 %533, label %534, label %537

; <label>:534:                                    ; preds = %530
  %535 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 4
  %536 = load i8*, i8** %535, align 8
  br label %537

; <label>:537:                                    ; preds = %525, %530, %534
  %.sink30 = phi i8* [ %536, %534 ], [ null, %530 ], [ null, %525 ]
  %538 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 6
  store i8* %.sink30, i8** %538, align 8
  %539 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 10
  %540 = load i32, i32* %539, align 4
  %541 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 4
  store i32 %540, i32* %541, align 8
  %542 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 5
  store i32 %.0, i32* %542, align 4
  %543 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %544 = call %struct.pid* @task_pid(%struct.task_struct* %543)
  %545 = call %struct.pid* @get_pid(%struct.pid* %544)
  %546 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 2
  store %struct.pid* %545, %struct.pid** %546, align 8
  %547 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %548 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %547, i32 0, i32 63
  %549 = load %struct.cred*, %struct.cred** %548, align 8
  %550 = call %struct.cred* @get_cred(%struct.cred* %549)
  %551 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 3
  store %struct.cred* %550, %struct.cred** %551, align 8
  %552 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %553 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 11
  call void @security_task_getsecid(%struct.task_struct* %552, i32* %553)
  %554 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %555 = load %struct.usb_device*, %struct.usb_device** %554, align 8
  %556 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 7
  %557 = load i8*, i8** %556, align 8
  %558 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %559 = load %struct.urb*, %struct.urb** %558, align 8
  %560 = getelementptr inbounds %struct.urb, %struct.urb* %559, i32 0, i32 10
  %561 = load i32, i32* %560, align 8
  %562 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %563 = load %struct.urb*, %struct.urb** %562, align 8
  %564 = getelementptr inbounds %struct.urb, %struct.urb* %563, i32 0, i32 19
  %565 = load i32, i32* %564, align 8
  call void @snoop_urb(%struct.usb_device* %555, i8* %557, i32 %561, i32 %565, i32 0, i32 0, i8* null, i32 0)
  %566 = icmp ne i32 %.2, 0
  br i1 %566, label %574, label %567

; <label>:567:                                    ; preds = %537
  %568 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %569 = load %struct.urb*, %struct.urb** %568, align 8
  %570 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %571 = load %struct.urb*, %struct.urb** %570, align 8
  %572 = getelementptr inbounds %struct.urb, %struct.urb* %571, i32 0, i32 19
  %573 = load i32, i32* %572, align 8
  call void @snoop_urb_data(%struct.urb* %569, i32 %573)
  br label %574

; <label>:574:                                    ; preds = %567, %537
  call void @async_newpending(%struct.async* %260)
  %575 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %57, i32 0, i32 0
  %576 = call i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %575)
  %577 = icmp ne i32 %576, 0
  br i1 %577, label %578, label %621

; <label>:578:                                    ; preds = %574
  %579 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_lock_irq(%struct.spinlock* %579)
  %580 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %57, i32 0, i32 0
  %581 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %580)
  %582 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %57, i32 0, i32 0
  %583 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %582, i32 0, i32 2
  %584 = load i8, i8* %583, align 2
  %585 = zext i8 %584 to i32
  %586 = and i32 %585, 128
  %587 = ashr i32 %586, 3
  %588 = or i32 %581, %587
  %589 = trunc i32 %588 to i8
  %590 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 12
  store i8 %589, i8* %590, align 4
  %591 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %1, i32 0, i32 3
  %592 = load i32, i32* %591, align 8
  %593 = and i32 %592, 4
  %594 = icmp ne i32 %593, 0
  br i1 %594, label %595, label %597

; <label>:595:                                    ; preds = %578
  %596 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 13
  store i8 1, i8* %596, align 1
  br label %606

; <label>:597:                                    ; preds = %578
  %598 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 12
  %599 = load i8, i8* %598, align 4
  %600 = zext i8 %599 to i32
  %601 = shl i32 1, %600
  %602 = xor i32 %601, -1
  %603 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 13
  %604 = load i32, i32* %603, align 4
  %605 = and i32 %604, %602
  store i32 %605, i32* %603, align 4
  br label %606

; <label>:606:                                    ; preds = %597, %595
  %607 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 13
  %608 = load i32, i32* %607, align 4
  %609 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 12
  %610 = load i8, i8* %609, align 4
  %611 = zext i8 %610 to i32
  %612 = shl i32 1, %611
  %613 = and i32 %608, %612
  %614 = icmp ne i32 %613, 0
  br i1 %614, label %619, label %615

; <label>:615:                                    ; preds = %606
  %616 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %617 = load %struct.urb*, %struct.urb** %616, align 8
  %618 = call i32 @usb_submit_urb(%struct.urb* %617, i32 32)
  br label %619

; <label>:619:                                    ; preds = %606, %615
  %.04 = phi i32 [ %618, %615 ], [ -121, %606 ]
  %620 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irq(%struct.spinlock* %620)
  br label %625

; <label>:621:                                    ; preds = %574
  %622 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %623 = load %struct.urb*, %struct.urb** %622, align 8
  %624 = call i32 @usb_submit_urb(%struct.urb* %623, i32 208)
  br label %625

; <label>:625:                                    ; preds = %621, %619
  %.15 = phi i32 [ %.04, %619 ], [ %624, %621 ]
  %626 = icmp ne i32 %.15, 0
  br i1 %626, label %627, label %645

; <label>:627:                                    ; preds = %625
  %628 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %629 = load %struct.usb_device*, %struct.usb_device** %628, align 8
  %630 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %629, i32 0, i32 11
  %631 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %630, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.48, i32 0, i32 0), i32 %.15)
  %632 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %633 = load %struct.usb_device*, %struct.usb_device** %632, align 8
  %634 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 7
  %635 = load i8*, i8** %634, align 8
  %636 = getelementptr inbounds %struct.async, %struct.async* %260, i32 0, i32 8
  %637 = load %struct.urb*, %struct.urb** %636, align 8
  %638 = getelementptr inbounds %struct.urb, %struct.urb* %637, i32 0, i32 10
  %639 = load i32, i32* %638, align 8
  call void @snoop_urb(%struct.usb_device* %633, i8* %635, i32 %639, i32 0, i32 %.15, i32 1, i8* null, i32 0)
  call void @async_removepending(%struct.async* %260)
  br label %640

; <label>:640:                                    ; preds = %357, %342, %324, %311, %278, %262, %257, %238, %230, %214, %203, %89, %81, %75, %627
  %.119 = phi %struct.usbdevfs_iso_packet_desc* [ null, %627 ], [ null, %75 ], [ null, %81 ], [ null, %89 ], [ %201, %203 ], [ %201, %214 ], [ %.018, %230 ], [ %.018, %238 ], [ %.018, %257 ], [ %.018, %262 ], [ %.018, %278 ], [ %.018, %311 ], [ %.018, %324 ], [ %.018, %342 ], [ %.018, %357 ]
  %.016 = phi %struct.async* [ %260, %627 ], [ null, %75 ], [ null, %81 ], [ null, %89 ], [ null, %203 ], [ null, %214 ], [ null, %230 ], [ null, %238 ], [ %260, %257 ], [ %260, %262 ], [ %260, %278 ], [ %260, %311 ], [ %260, %324 ], [ %260, %342 ], [ %260, %357 ]
  %.115 = phi %struct.usb_ctrlrequest* [ null, %627 ], [ %73, %75 ], [ %73, %81 ], [ %73, %89 ], [ null, %203 ], [ null, %214 ], [ %.014, %230 ], [ %.014, %238 ], [ %.014, %257 ], [ %.014, %262 ], [ %.014, %278 ], [ %.014, %311 ], [ %.014, %324 ], [ %.014, %342 ], [ %.014, %357 ]
  %.26 = phi i32 [ %.15, %627 ], [ -14, %75 ], [ -22, %81 ], [ %99, %89 ], [ -14, %203 ], [ -22, %214 ], [ -22, %230 ], [ -14, %238 ], [ -12, %257 ], [ %273, %262 ], [ -12, %278 ], [ -12, %311 ], [ -14, %324 ], [ -12, %342 ], [ -14, %357 ]
  %641 = bitcast %struct.usbdevfs_iso_packet_desc* %.119 to i8*
  call void @kfree(i8* %641)
  %642 = bitcast %struct.usb_ctrlrequest* %.115 to i8*
  call void @kfree(i8* %642)
  %643 = icmp ne %struct.async* %.016, null
  br i1 %643, label %644, label %645

; <label>:644:                                    ; preds = %640
  call void @free_async(%struct.async* %.016)
  br label %645

; <label>:645:                                    ; preds = %640, %644, %625, %59, %193, %189, %181, %185, %175, %153, %153, %71, %67, %63, %41, %38, %30, %15, %4
  %.020 = phi i32 [ -22, %4 ], [ -22, %15 ], [ %36, %30 ], [ %39, %38 ], [ -2, %41 ], [ -22, %63 ], [ -22, %67 ], [ -12, %71 ], [ -22, %153 ], [ -22, %153 ], [ -22, %175 ], [ -22, %185 ], [ -22, %181 ], [ -22, %189 ], [ -12, %193 ], [ -22, %59 ], [ 0, %625 ], [ %.26, %644 ], [ %.26, %640 ]
  ret i32 %.020
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor*) #0 {
  %2 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %3 = load i8, i8* %2, align 1
  %4 = zext i8 %3 to i32
  %5 = and i32 %4, 3
  %6 = icmp eq i32 %5, 0
  %7 = zext i1 %6 to i32
  ret i32 %7
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor*) #0 {
  %2 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %3 = load i8, i8* %2, align 1
  %4 = zext i8 %3 to i32
  %5 = and i32 %4, 3
  ret i32 %5
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor*) #0 {
  %2 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %3 = load i8, i8* %2, align 1
  %4 = zext i8 %3 to i32
  %5 = and i32 %4, 3
  %6 = icmp eq i32 %5, 3
  %7 = zext i1 %6 to i32
  ret i32 %7
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor*) #0 {
  %2 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %3 = load i8, i8* %2, align 1
  %4 = zext i8 %3 to i32
  %5 = and i32 %4, 3
  %6 = icmp eq i32 %5, 1
  %7 = zext i1 %6 to i32
  ret i32 %7
}

; Function Attrs: noinline nounwind uwtable
define internal %struct.async* @alloc_async(i32) #0 {
  %2 = call i8* @kzalloc(i64 88, i32 208)
  %3 = bitcast i8* %2 to %struct.async*
  %4 = icmp ne %struct.async* %3, null
  br i1 %4, label %5, label %13

; <label>:5:                                      ; preds = %1
  %6 = call %struct.urb* @usb_alloc_urb(i32 %0, i32 208)
  %7 = getelementptr inbounds %struct.async, %struct.async* %3, i32 0, i32 8
  store %struct.urb* %6, %struct.urb** %7, align 8
  %8 = getelementptr inbounds %struct.async, %struct.async* %3, i32 0, i32 8
  %9 = load %struct.urb*, %struct.urb** %8, align 8
  %10 = icmp ne %struct.urb* %9, null
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %5
  %12 = bitcast %struct.async* %3 to i8*
  call void @kfree(i8* %12)
  br label %13

; <label>:13:                                     ; preds = %5, %1, %11
  %.0 = phi %struct.async* [ null, %11 ], [ null, %1 ], [ %3, %5 ]
  ret %struct.async* %.0
}

declare void @sg_init_table(%struct.scatterlist*, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal void @sg_set_buf(%struct.scatterlist*, i8*, i32) #0 {
  %4 = ptrtoint i8* %1 to i64
  %5 = call i64 @__phys_addr_nodebug(i64 %4)
  %6 = lshr i64 %5, 12
  %7 = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %6
  %8 = ptrtoint i8* %1 to i64
  %9 = and i64 %8, 4095
  %10 = trunc i64 %9 to i32
  call void @sg_set_page(%struct.scatterlist* %0, %struct.page* %7, i32 %2, i32 %10)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #3

; Function Attrs: noinline nounwind uwtable
define internal void @async_completed(%struct.urb*) #0 {
  %2 = alloca %struct.siginfo, align 8
  %3 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 27
  %4 = load i8*, i8** %3, align 8
  %5 = bitcast i8* %4 to %struct.async*
  %6 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 1
  %7 = load %struct.dev_state*, %struct.dev_state** %6, align 8
  %8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %7, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %8)
  %9 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 0
  %10 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %7, i32 0, i32 5
  call void @list_move_tail(%struct.list_head* %9, %struct.list_head* %10)
  %11 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 12
  %12 = load i32, i32* %11, align 8
  %13 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 10
  store i32 %12, i32* %13, align 4
  %14 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 4
  %15 = load i32, i32* %14, align 8
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %17, label %38

; <label>:17:                                     ; preds = %1
  %18 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 4
  %19 = load i32, i32* %18, align 8
  %20 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %2, i32 0, i32 0
  store i32 %19, i32* %20, align 8
  %21 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 10
  %22 = load i32, i32* %21, align 4
  %23 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %2, i32 0, i32 1
  store i32 %22, i32* %23, align 4
  %24 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %2, i32 0, i32 2
  store i32 -4, i32* %24, align 8
  %25 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 7
  %26 = load i8*, i8** %25, align 8
  %27 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %2, i32 0, i32 3
  %28 = bitcast %union.anon.32* %27 to %struct.anon.37*
  %29 = getelementptr inbounds %struct.anon.37, %struct.anon.37* %28, i32 0, i32 0
  store i8* %26, i8** %29, align 8
  %30 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 2
  %31 = load %struct.pid*, %struct.pid** %30, align 8
  %32 = call %struct.pid* @get_pid(%struct.pid* %31)
  %33 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 3
  %34 = load %struct.cred*, %struct.cred** %33, align 8
  %35 = call %struct.cred* @get_cred(%struct.cred* %34)
  %36 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 11
  %37 = load i32, i32* %36, align 8
  br label %38

; <label>:38:                                     ; preds = %1, %17
  %.02 = phi %struct.pid* [ %32, %17 ], [ null, %1 ]
  %.01 = phi i32 [ %37, %17 ], [ 0, %1 ]
  %.0 = phi %struct.cred* [ %35, %17 ], [ null, %1 ]
  %39 = load i8, i8* @usbfs_snoop, align 1
  %40 = trunc i8 %39 to i1
  br i1 %40, label %41, label %46

; <label>:41:                                     ; preds = %38
  %42 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 8
  %43 = load %struct.usb_device*, %struct.usb_device** %42, align 8
  %44 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %43, i32 0, i32 11
  %45 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %44, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.50, i32 0, i32 0))
  br label %46

; <label>:46:                                     ; preds = %38, %41
  %47 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 8
  %48 = load %struct.usb_device*, %struct.usb_device** %47, align 8
  %49 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 7
  %50 = load i8*, i8** %49, align 8
  %51 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 10
  %52 = load i32, i32* %51, align 8
  %53 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %54 = load i32, i32* %53, align 4
  %55 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 10
  %56 = load i32, i32* %55, align 4
  call void @snoop_urb(%struct.usb_device* %48, i8* %50, i32 %52, i32 %54, i32 %56, i32 1, i8* null, i32 0)
  %57 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 13
  %58 = load i32, i32* %57, align 4
  %59 = and i32 %58, 512
  %60 = icmp eq i32 %59, 128
  br i1 %60, label %61, label %64

; <label>:61:                                     ; preds = %46
  %62 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %63 = load i32, i32* %62, align 4
  call void @snoop_urb_data(%struct.urb* %0, i32 %63)
  br label %64

; <label>:64:                                     ; preds = %61, %46
  %65 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 10
  %66 = load i32, i32* %65, align 4
  %67 = icmp slt i32 %66, 0
  br i1 %67, label %68, label %85

; <label>:68:                                     ; preds = %64
  %69 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 12
  %70 = load i8, i8* %69, align 4
  %71 = zext i8 %70 to i32
  %72 = icmp ne i32 %71, 0
  br i1 %72, label %73, label %85

; <label>:73:                                     ; preds = %68
  %74 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 10
  %75 = load i32, i32* %74, align 4
  %76 = icmp ne i32 %75, -104
  br i1 %76, label %77, label %85

; <label>:77:                                     ; preds = %73
  %78 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 10
  %79 = load i32, i32* %78, align 4
  %80 = icmp ne i32 %79, -2
  br i1 %80, label %81, label %85

; <label>:81:                                     ; preds = %77
  %82 = getelementptr inbounds %struct.async, %struct.async* %5, i32 0, i32 12
  %83 = load i8, i8* %82, align 4
  %84 = zext i8 %83 to i32
  call void @cancel_bulk_urbs(%struct.dev_state* %7, i32 %84)
  br label %85

; <label>:85:                                     ; preds = %81, %77, %73, %68, %64
  %86 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %7, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %86)
  %87 = icmp ne i32 %15, 0
  br i1 %87, label %88, label %92

; <label>:88:                                     ; preds = %85
  %89 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %2, i32 0, i32 0
  %90 = load i32, i32* %89, align 8
  %91 = call i32 @kill_pid_info_as_cred(i32 %90, %struct.siginfo* %2, %struct.pid* %.02, %struct.cred* %.0, i32 %.01)
  call void @put_pid(%struct.pid* %.02)
  call void @put_cred(%struct.cred* %.0)
  br label %92

; <label>:92:                                     ; preds = %88, %85
  %93 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %7, i32 0, i32 6
  call void @__wake_up(%struct.__wait_queue_head* %93, i32 3, i32 1, i8* null)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal %struct.pid* @get_pid(%struct.pid*) #0 {
  %2 = icmp ne %struct.pid* %0, null
  br i1 %2, label %3, label %5

; <label>:3:                                      ; preds = %1
  %4 = getelementptr inbounds %struct.pid, %struct.pid* %0, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %4)
  br label %5

; <label>:5:                                      ; preds = %3, %1
  ret %struct.pid* %0
}

; Function Attrs: noinline nounwind uwtable
define internal %struct.pid* @task_pid(%struct.task_struct*) #0 {
  %2 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 43
  %3 = getelementptr inbounds [3 x %struct.pid_link], [3 x %struct.pid_link]* %2, i64 0, i64 0
  %4 = getelementptr inbounds %struct.pid_link, %struct.pid_link* %3, i32 0, i32 1
  %5 = load %struct.pid*, %struct.pid** %4, align 8
  ret %struct.pid* %5
}

; Function Attrs: noinline nounwind uwtable
define internal %struct.cred* @get_cred(%struct.cred*) #0 {
  call void @validate_creds(%struct.cred* %0)
  %2 = call %struct.cred* @get_new_cred(%struct.cred* %0)
  ret %struct.cred* %2
}

declare void @security_task_getsecid(%struct.task_struct*, i32*) #1

; Function Attrs: noinline nounwind uwtable
define internal void @snoop_urb_data(%struct.urb*, i32) #0 {
  %3 = load i8, i8* @usbfs_snoop, align 1
  %4 = trunc i8 %3 to i1
  br i1 %4, label %5, label %.loopexit

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 18
  %7 = load i32, i32* %6, align 4
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %5
  %10 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 14
  %11 = load i8*, i8** %10, align 8
  %12 = zext i32 %1 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %11, i64 %12, i1 zeroext true)
  br label %.loopexit

; <label>:13:                                     ; preds = %5, %18
  %.01 = phi i32 [ %26, %18 ], [ %1, %5 ]
  %.0 = phi i32 [ %27, %18 ], [ 0, %5 ]
  %14 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 18
  %15 = load i32, i32* %14, align 4
  %16 = icmp slt i32 %.0, %15
  %17 = icmp ne i32 %.01, 0
  %. = select i1 %16, i1 %17, i1 false
  br i1 %., label %18, label %.loopexit

; <label>:18:                                     ; preds = %13
  %19 = icmp ugt i32 %.01, 16384
  %..01 = select i1 %19, i32 16384, i32 %.01
  %20 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 16
  %21 = load %struct.scatterlist*, %struct.scatterlist** %20, align 8
  %22 = sext i32 %.0 to i64
  %23 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %21, i64 %22
  %24 = call i8* @sg_virt(%struct.scatterlist* %23)
  %25 = sext i32 %..01 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %24, i64 %25, i1 zeroext true)
  %26 = sub i32 %.01, %..01
  %27 = add nsw i32 %.0, 1
  br label %13

.loopexit:                                        ; preds = %13, %2, %9
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @async_newpending(%struct.async*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 1
  %5 = load %struct.dev_state*, %struct.dev_state** %4, align 8
  %6 = icmp eq i64* %2, %3
  %7 = zext i1 %6 to i32
  %8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 3
  %9 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %8)
  %10 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %9)
  %11 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 0
  %12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 4
  call void @list_add_tail(%struct.list_head* %11, %struct.list_head* %12)
  %13 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %13, i64 %10)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor*) #0 {
  %2 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 3
  %3 = load i8, i8* %2, align 1
  %4 = zext i8 %3 to i32
  %5 = and i32 %4, 3
  %6 = icmp eq i32 %5, 2
  %7 = zext i1 %6 to i32
  ret i32 %7
}

; Function Attrs: noinline nounwind uwtable
define internal void @spin_lock_irq(%struct.spinlock*) #0 {
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %3 = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %3)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor*) #0 {
  %2 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %0, i32 0, i32 2
  %3 = load i8, i8* %2, align 1
  %4 = zext i8 %3 to i32
  %5 = and i32 %4, 15
  ret i32 %5
}

declare i32 @usb_submit_urb(%struct.urb*, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal void @spin_unlock_irq(%struct.spinlock*) #0 {
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %3 = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  call void @__raw_spin_unlock_irq(%struct.raw_spinlock* %3)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @async_removepending(%struct.async*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 1
  %5 = load %struct.dev_state*, %struct.dev_state** %4, align 8
  %6 = icmp eq i64* %2, %3
  %7 = zext i1 %6 to i32
  %8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 3
  %9 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %8)
  %10 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %9)
  %11 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %11)
  %12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %5, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %12, i64 %10)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @free_async(%struct.async*) #0 {
  %2 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 2
  %3 = load %struct.pid*, %struct.pid** %2, align 8
  call void @put_pid(%struct.pid* %3)
  %4 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 3
  %5 = load %struct.cred*, %struct.cred** %4, align 8
  %6 = icmp ne %struct.cred* %5, null
  br i1 %6, label %7, label %10

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 3
  %9 = load %struct.cred*, %struct.cred** %8, align 8
  call void @put_cred(%struct.cred* %9)
  br label %10

; <label>:10:                                     ; preds = %1, %7, %33
  %.0 = phi i32 [ %34, %33 ], [ 0, %7 ], [ 0, %1 ]
  %11 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %12 = load %struct.urb*, %struct.urb** %11, align 8
  %13 = getelementptr inbounds %struct.urb, %struct.urb* %12, i32 0, i32 18
  %14 = load i32, i32* %13, align 4
  %15 = icmp slt i32 %.0, %14
  %16 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %17 = load %struct.urb*, %struct.urb** %16, align 8
  %18 = getelementptr inbounds %struct.urb, %struct.urb* %17, i32 0, i32 16
  %19 = load %struct.scatterlist*, %struct.scatterlist** %18, align 8
  br i1 %15, label %20, label %35

; <label>:20:                                     ; preds = %10
  %21 = sext i32 %.0 to i64
  %22 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %19, i64 %21
  %23 = call %struct.page* @sg_page(%struct.scatterlist* %22)
  %24 = icmp ne %struct.page* %23, null
  br i1 %24, label %25, label %33

; <label>:25:                                     ; preds = %20
  %26 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %27 = load %struct.urb*, %struct.urb** %26, align 8
  %28 = getelementptr inbounds %struct.urb, %struct.urb* %27, i32 0, i32 16
  %29 = load %struct.scatterlist*, %struct.scatterlist** %28, align 8
  %30 = sext i32 %.0 to i64
  %31 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %29, i64 %30
  %32 = call i8* @sg_virt(%struct.scatterlist* %31)
  call void @kfree(i8* %32)
  br label %33

; <label>:33:                                     ; preds = %20, %25
  %34 = add nsw i32 %.0, 1
  br label %10

; <label>:35:                                     ; preds = %10
  %36 = bitcast %struct.scatterlist* %19 to i8*
  call void @kfree(i8* %36)
  %37 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %38 = load %struct.urb*, %struct.urb** %37, align 8
  %39 = getelementptr inbounds %struct.urb, %struct.urb* %38, i32 0, i32 14
  %40 = load i8*, i8** %39, align 8
  call void @kfree(i8* %40)
  %41 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %42 = load %struct.urb*, %struct.urb** %41, align 8
  %43 = getelementptr inbounds %struct.urb, %struct.urb* %42, i32 0, i32 21
  %44 = load i8*, i8** %43, align 8
  call void @kfree(i8* %44)
  %45 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %46 = load %struct.urb*, %struct.urb** %45, align 8
  call void @usb_free_urb(%struct.urb* %46)
  %47 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 9
  %48 = load i32, i32* %47, align 8
  call void @usbfs_decrease_memory_usage(i32 %48)
  %49 = bitcast %struct.async* %0 to i8*
  call void @kfree(i8* %49)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i8* @kzalloc(i64, i32) #0 {
  %3 = or i32 %1, 32768
  %4 = call i8* @__kmalloc(i64 %0, i32 %3) #5
  ret i8* %4
}

declare %struct.urb* @usb_alloc_urb(i32, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal void @sg_set_page(%struct.scatterlist*, %struct.page*, i32, i32) #0 {
  call void @sg_assign_page(%struct.scatterlist* %0, %struct.page* %1)
  %5 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %0, i32 0, i32 1
  store i32 %3, i32* %5, align 8
  %6 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %0, i32 0, i32 2
  store i32 %2, i32* %6, align 4
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i64 @__phys_addr_nodebug(i64) #0 {
  %2 = sub i64 %0, -2147483648
  %3 = icmp ugt i64 %0, %2
  %4 = load i64, i64* @phys_base, align 8
  %5 = select i1 %3, i64 %4, i64 131939247849472
  %6 = add i64 %2, %5
  ret i64 %6
}

; Function Attrs: noinline nounwind uwtable
define internal void @sg_assign_page(%struct.scatterlist*, %struct.page*) #0 {
  %3 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %0, i32 0, i32 0
  %4 = load i64, i64* %3, align 8
  %5 = and i64 %4, 3
  %6 = ptrtoint %struct.page* %1 to i64
  %7 = and i64 %6, 3
  %8 = icmp ne i64 %7, 0
  %9 = xor i1 %8, true
  %10 = xor i1 %9, true
  %11 = zext i1 %10 to i32
  %12 = sext i32 %11 to i64
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %14, label %16

; <label>:14:                                     ; preds = %2
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.49, i32 0, i32 0), i32 65, i64 12) #5, !srcloc !35
  br label %15

; <label>:15:                                     ; preds = %15, %14
  br label %15

; <label>:16:                                     ; preds = %2
  %17 = ptrtoint %struct.page* %1 to i64
  %18 = or i64 %5, %17
  %19 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %0, i32 0, i32 0
  store i64 %18, i64* %19, align 8
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @spin_lock(%struct.spinlock*) #0 {
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %3 = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %3)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @cancel_bulk_urbs(%struct.dev_state*, i32) #0 {
  %3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  br label %4

; <label>:4:                                      ; preds = %26, %2
  %.sink = phi %struct.list_head* [ %27, %26 ], [ %3, %2 ]
  %5 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %5, align 8
  %7 = bitcast %struct.list_head* %6 to i8*
  %8 = getelementptr inbounds i8, i8* %7, i64 0
  %9 = bitcast i8* %8 to %struct.async*
  %10 = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 0
  %11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  %12 = icmp ne %struct.list_head* %10, %11
  br i1 %12, label %13, label %28

; <label>:13:                                     ; preds = %4
  %14 = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 12
  %15 = load i8, i8* %14, align 4
  %16 = zext i8 %15 to i32
  %17 = icmp eq i32 %16, %1
  br i1 %17, label %18, label %26

; <label>:18:                                     ; preds = %13
  %19 = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 13
  %20 = load i8, i8* %19, align 1
  %21 = zext i8 %20 to i32
  %22 = icmp ne i32 %21, 1
  br i1 %22, label %.preheader, label %23

; <label>:23:                                     ; preds = %18
  %24 = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 13
  store i8 2, i8* %24, align 1
  %25 = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 12
  store i8 0, i8* %25, align 4
  br label %26

; <label>:26:                                     ; preds = %13, %23
  %27 = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 0
  br label %4

; <label>:28:                                     ; preds = %4
  %29 = shl i32 1, %1
  %30 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 13
  %31 = load i32, i32* %30, align 4
  %32 = or i32 %31, %29
  store i32 %32, i32* %30, align 4
  br label %.preheader

.preheader:                                       ; preds = %28, %18, %48
  %33 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  br label %34

; <label>:34:                                     ; preds = %56, %.preheader
  %.sink7 = phi %struct.list_head* [ %57, %56 ], [ %33, %.preheader ]
  %35 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink7, i32 0, i32 0
  %36 = load %struct.list_head*, %struct.list_head** %35, align 8
  %37 = bitcast %struct.list_head* %36 to i8*
  %38 = getelementptr inbounds i8, i8* %37, i64 0
  %39 = bitcast i8* %38 to %struct.async*
  %40 = getelementptr inbounds %struct.async, %struct.async* %39, i32 0, i32 0
  %41 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  %42 = icmp ne %struct.list_head* %40, %41
  br i1 %42, label %43, label %58

; <label>:43:                                     ; preds = %34
  %44 = getelementptr inbounds %struct.async, %struct.async* %39, i32 0, i32 13
  %45 = load i8, i8* %44, align 1
  %46 = zext i8 %45 to i32
  %47 = icmp eq i32 %46, 2
  br i1 %47, label %48, label %56

; <label>:48:                                     ; preds = %43
  %49 = getelementptr inbounds %struct.async, %struct.async* %39, i32 0, i32 13
  store i8 0, i8* %49, align 1
  %50 = getelementptr inbounds %struct.async, %struct.async* %39, i32 0, i32 8
  %51 = load %struct.urb*, %struct.urb** %50, align 8
  %52 = call %struct.urb* @usb_get_urb(%struct.urb* %51)
  %53 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %53)
  %54 = call i32 @usb_unlink_urb(%struct.urb* %51)
  call void @usb_free_urb(%struct.urb* %51)
  %55 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %55)
  br label %.preheader

; <label>:56:                                     ; preds = %43
  %57 = getelementptr inbounds %struct.async, %struct.async* %39, i32 0, i32 0
  br label %34

; <label>:58:                                     ; preds = %34
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @spin_unlock(%struct.spinlock*) #0 {
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %0, i32 0, i32 0
  %3 = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %3)
  ret void
}

declare i32 @kill_pid_info_as_cred(i32, %struct.siginfo*, %struct.pid*, %struct.cred*, i32) #1

declare void @put_pid(%struct.pid*) #1

; Function Attrs: noinline nounwind uwtable
define internal void @put_cred(%struct.cred*) #0 {
  call void @validate_creds(%struct.cred* %0)
  %2 = getelementptr inbounds %struct.cred, %struct.cred* %0, i32 0, i32 0
  %3 = call i32 @atomic_dec_and_test(%struct.atomic_t* %2)
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %5, label %6

; <label>:5:                                      ; preds = %1
  call void @__put_cred(%struct.cred* %0)
  br label %6

; <label>:6:                                      ; preds = %5, %1
  ret void
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

declare void @_raw_spin_lock(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare i32 @usb_unlink_urb(%struct.urb*) #1

; Function Attrs: noinline nounwind uwtable
define internal void @__raw_spin_unlock(%struct.raw_spinlock*) #0 {
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %0)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !36
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @do_raw_spin_unlock(%struct.raw_spinlock*) #0 {
  %2 = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %0, i32 0, i32 0
  %3 = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %2, i32 0, i32 0
  %4 = bitcast %union.anon.1* %3 to %struct.__raw_tickets*
  %5 = getelementptr inbounds %struct.__raw_tickets, %struct.__raw_tickets* %4, i32 0, i32 0
  call void asm sideeffect "addb ${1:b}, $0\0A", "=*m,qi,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i8* %5, i32 1, i8* %5) #5, !srcloc !37
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @validate_creds(%struct.cred*) #0 {
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @atomic_dec_and_test(%struct.atomic_t*) #0 {
  %2 = alloca i8, align 1
  %3 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %0, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %3, i8* %2, i32* %3) #5, !srcloc !38
  %4 = load i8, i8* %2, align 1
  %5 = zext i8 %4 to i32
  %6 = icmp ne i32 %5, 0
  %7 = zext i1 %6 to i32
  ret i32 %7
}

declare void @__put_cred(%struct.cred*) #1

; Function Attrs: noinline nounwind uwtable
define internal void @atomic_inc(%struct.atomic_t*) #0 {
  %2 = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %0, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %2, i32* %2) #5, !srcloc !39
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal %struct.cred* @get_new_cred(%struct.cred*) #0 {
  %2 = getelementptr inbounds %struct.cred, %struct.cred* %0, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %2)
  ret %struct.cred* %0
}

; Function Attrs: noinline nounwind uwtable
define internal i8* @sg_virt(%struct.scatterlist*) #0 {
  %2 = call %struct.page* @sg_page(%struct.scatterlist* %0)
  %3 = ptrtoint %struct.page* %2 to i64
  %4 = sub i64 %3, -24189255811072
  %5 = sdiv exact i64 %4, 64
  %6 = shl i64 %5, 12
  %7 = add i64 %6, -131941395333120
  %8 = inttoptr i64 %7 to i8*
  %9 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %0, i32 0, i32 1
  %10 = load i32, i32* %9, align 8
  %11 = zext i32 %10 to i64
  %12 = getelementptr i8, i8* %8, i64 %11
  ret i8* %12
}

; Function Attrs: noinline nounwind uwtable
define internal %struct.page* @sg_page(%struct.scatterlist*) #0 {
  %2 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %0, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = and i64 %3, -4
  %5 = inttoptr i64 %4 to %struct.page*
  ret %struct.page* %5
}

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: noinline nounwind uwtable
define internal void @__raw_spin_unlock_irq(%struct.raw_spinlock*) #0 {
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %0)
  call void @arch_local_irq_enable()
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !40
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @arch_local_irq_enable() #0 {
  call void @native_irq_enable()
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal void @native_irq_enable() #0 {
  call void asm sideeffect "sti", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !41
  ret void
}

declare i8* @compat_alloc_user_space(i64) #1

declare i64 @copy_in_user(i8*, i8*, i32) #1

; Function Attrs: noinline nounwind uwtable
define internal i8* @compat_ptr(i32) #0 {
  %2 = zext i32 %0 to i64
  %3 = inttoptr i64 %2 to i8*
  ret i8* %3
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @get_urb32(%struct.usbdevfs_urb*, %struct.usbdevfs_urb32*) #0 {
  %3 = call %struct.thread_info* @current_thread_info()
  %4 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %3, i32 0, i32 6
  %5 = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %4, i32 0, i32 0
  %6 = load i64, i64* %5, align 8
  %7 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(%struct.usbdevfs_urb32* %1, i64 44, i64 %6) #6, !srcloc !42
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = extractvalue { i64, i64 } %7, 1
  %10 = icmp eq i64 %8, 0
  %11 = xor i1 %10, true
  %12 = xor i1 %11, true
  %13 = zext i1 %12 to i32
  %14 = sext i32 %13 to i64
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %16, label %127

; <label>:16:                                     ; preds = %2
  %17 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 0
  %18 = bitcast i8* %17 to %struct.__large_struct*
  %19 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movb $2,${1:b}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %18, i32 -14, i32 0) #5, !srcloc !43
  %20 = extractvalue { i32, i64 } %19, 0
  %21 = extractvalue { i32, i64 } %19, 1
  %22 = trunc i64 %21 to i8
  %23 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 0
  store i8 %22, i8* %23, align 8
  %24 = icmp ne i32 %20, 0
  br i1 %24, label %127, label %25

; <label>:25:                                     ; preds = %16
  %26 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 1
  %27 = bitcast i8* %26 to %struct.__large_struct*
  %28 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movb $2,${1:b}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %27, i32 -14, i32 0) #5, !srcloc !44
  %29 = extractvalue { i32, i64 } %28, 0
  %30 = extractvalue { i32, i64 } %28, 1
  %31 = trunc i64 %30 to i8
  %32 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 1
  store i8 %31, i8* %32, align 1
  %33 = icmp ne i32 %29, 0
  br i1 %33, label %127, label %34

; <label>:34:                                     ; preds = %25
  %35 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 2
  %36 = bitcast i32* %35 to %struct.__large_struct*
  %37 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %36, i32 -14, i32 0) #5, !srcloc !45
  %38 = extractvalue { i32, i64 } %37, 0
  %39 = extractvalue { i32, i64 } %37, 1
  %40 = trunc i64 %39 to i32
  %41 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 2
  store i32 %40, i32* %41, align 4
  %42 = icmp ne i32 %38, 0
  br i1 %42, label %127, label %43

; <label>:43:                                     ; preds = %34
  %44 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 3
  %45 = bitcast i32* %44 to %struct.__large_struct*
  %46 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %45, i32 -14, i32 0) #5, !srcloc !46
  %47 = extractvalue { i32, i64 } %46, 0
  %48 = extractvalue { i32, i64 } %46, 1
  %49 = trunc i64 %48 to i32
  %50 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 3
  store i32 %49, i32* %50, align 8
  %51 = icmp ne i32 %47, 0
  br i1 %51, label %127, label %52

; <label>:52:                                     ; preds = %43
  %53 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 5
  %54 = bitcast i32* %53 to %struct.__large_struct*
  %55 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %54, i32 -14, i32 0) #5, !srcloc !47
  %56 = extractvalue { i32, i64 } %55, 0
  %57 = extractvalue { i32, i64 } %55, 1
  %58 = trunc i64 %57 to i32
  %59 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 5
  store i32 %58, i32* %59, align 8
  %60 = icmp ne i32 %56, 0
  br i1 %60, label %127, label %61

; <label>:61:                                     ; preds = %52
  %62 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 6
  %63 = bitcast i32* %62 to %struct.__large_struct*
  %64 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %63, i32 -14, i32 0) #5, !srcloc !48
  %65 = extractvalue { i32, i64 } %64, 0
  %66 = extractvalue { i32, i64 } %64, 1
  %67 = trunc i64 %66 to i32
  %68 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 6
  store i32 %67, i32* %68, align 4
  %69 = icmp ne i32 %65, 0
  br i1 %69, label %127, label %70

; <label>:70:                                     ; preds = %61
  %71 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 7
  %72 = bitcast i32* %71 to %struct.__large_struct*
  %73 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %72, i32 -14, i32 0) #5, !srcloc !49
  %74 = extractvalue { i32, i64 } %73, 0
  %75 = extractvalue { i32, i64 } %73, 1
  %76 = trunc i64 %75 to i32
  %77 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 7
  store i32 %76, i32* %77, align 8
  %78 = icmp ne i32 %74, 0
  br i1 %78, label %127, label %79

; <label>:79:                                     ; preds = %70
  %80 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 8
  %81 = bitcast i32* %80 to %struct.__large_struct*
  %82 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %81, i32 -14, i32 0) #5, !srcloc !50
  %83 = extractvalue { i32, i64 } %82, 0
  %84 = extractvalue { i32, i64 } %82, 1
  %85 = trunc i64 %84 to i32
  %86 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 8
  store i32 %85, i32* %86, align 4
  %87 = icmp ne i32 %83, 0
  br i1 %87, label %127, label %88

; <label>:88:                                     ; preds = %79
  %89 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 9
  %90 = bitcast i32* %89 to %struct.__large_struct*
  %91 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %90, i32 -14, i32 0) #5, !srcloc !51
  %92 = extractvalue { i32, i64 } %91, 0
  %93 = extractvalue { i32, i64 } %91, 1
  %94 = trunc i64 %93 to i32
  %95 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 9
  store i32 %94, i32* %95, align 8
  %96 = icmp ne i32 %92, 0
  br i1 %96, label %127, label %97

; <label>:97:                                     ; preds = %88
  %98 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 10
  %99 = bitcast i32* %98 to %struct.__large_struct*
  %100 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %99, i32 -14, i32 0) #5, !srcloc !52
  %101 = extractvalue { i32, i64 } %100, 0
  %102 = extractvalue { i32, i64 } %100, 1
  %103 = trunc i64 %102 to i32
  %104 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 10
  store i32 %103, i32* %104, align 4
  %105 = icmp ne i32 %101, 0
  br i1 %105, label %127, label %106

; <label>:106:                                    ; preds = %97
  %107 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 4
  %108 = bitcast i32* %107 to %struct.__large_struct*
  %109 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %108, i32 -14, i32 0) #5, !srcloc !53
  %110 = extractvalue { i32, i64 } %109, 0
  %111 = extractvalue { i32, i64 } %109, 1
  %112 = trunc i64 %111 to i32
  %113 = icmp ne i32 %110, 0
  br i1 %113, label %127, label %114

; <label>:114:                                    ; preds = %106
  %115 = call i8* @compat_ptr(i32 %112)
  %116 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 4
  store i8* %115, i8** %116, align 8
  %117 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %1, i32 0, i32 11
  %118 = bitcast i32* %117 to %struct.__large_struct*
  %119 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %118, i32 -14, i32 0) #5, !srcloc !54
  %120 = extractvalue { i32, i64 } %119, 0
  %121 = extractvalue { i32, i64 } %119, 1
  %122 = trunc i64 %121 to i32
  %123 = icmp ne i32 %120, 0
  br i1 %123, label %127, label %124

; <label>:124:                                    ; preds = %114
  %125 = call i8* @compat_ptr(i32 %122)
  %126 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %0, i32 0, i32 11
  store i8* %125, i8** %126, align 8
  br label %127

; <label>:127:                                    ; preds = %114, %106, %2, %16, %25, %34, %43, %52, %61, %70, %79, %88, %97, %124
  %.0 = phi i32 [ 0, %124 ], [ -14, %97 ], [ -14, %88 ], [ -14, %79 ], [ -14, %70 ], [ -14, %61 ], [ -14, %52 ], [ -14, %43 ], [ -14, %34 ], [ -14, %25 ], [ -14, %16 ], [ -14, %2 ], [ -14, %106 ], [ -14, %114 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal %struct.async* @reap_as(%struct.dev_state*) #0 {
  %2 = alloca %struct.__wait_queue, align 8
  %3 = alloca i64, align 8
  %4 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %2, i32 0, i32 0
  store i32 0, i32* %4, align 8
  %5 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %2, i32 0, i32 1
  %6 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %7 = bitcast %struct.task_struct* %6 to i8*
  store i8* %7, i8** %5, align 8
  %8 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %2, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %8, align 8
  %9 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %2, i32 0, i32 3
  %10 = getelementptr inbounds %struct.list_head, %struct.list_head* %9, i32 0, i32 0
  store %struct.list_head* null, %struct.list_head** %10, align 8
  %11 = getelementptr inbounds %struct.list_head, %struct.list_head* %9, i32 0, i32 1
  store %struct.list_head* null, %struct.list_head** %11, align 8
  %12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %13 = load %struct.usb_device*, %struct.usb_device** %12, align 8
  %14 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 6
  call void @add_wait_queue(%struct.__wait_queue_head* %14, %struct.__wait_queue* %2)
  br label %15

; <label>:15:                                     ; preds = %24, %1
  %16 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %17 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %16, i32 0, i32 0
  store volatile i64 1, i64* %17, align 8
  %18 = call %struct.async* @async_getcompleted(%struct.dev_state* %0)
  %19 = icmp ne %struct.async* %18, null
  br i1 %19, label %27, label %20

; <label>:20:                                     ; preds = %15
  %21 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %22 = call i32 @signal_pending(%struct.task_struct* %21)
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %27, label %24

; <label>:24:                                     ; preds = %20
  %25 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 11
  call void @device_unlock(%struct.device* %25)
  call void @schedule()
  %26 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 11
  call void @device_lock(%struct.device* %26)
  br label %15

; <label>:27:                                     ; preds = %20, %15
  %28 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 6
  call void @remove_wait_queue(%struct.__wait_queue_head* %28, %struct.__wait_queue* %2)
  store volatile i64 0, i64* %3, align 8
  %29 = load volatile i64, i64* %3, align 8
  %30 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !2
  %31 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %30, i32 0, i32 0
  %32 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %31, i64 %29, i64* %31) #5, !srcloc !55
  store volatile i64 %32, i64* %3, align 8
  %33 = load volatile i64, i64* %3, align 8
  ret %struct.async* %18
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @processcompl_compat(%struct.async*, i8**) #0 {
  %3 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %4 = load %struct.urb*, %struct.urb** %3, align 8
  %5 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 7
  %6 = load i8*, i8** %5, align 8
  %7 = bitcast i8* %6 to %struct.usbdevfs_urb32*
  %8 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 7
  %9 = load i8*, i8** %8, align 8
  %10 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 6
  %11 = load i8*, i8** %10, align 8
  %12 = icmp ne i8* %11, null
  br i1 %12, label %13, label %22

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 20
  %15 = load i32, i32* %14, align 4
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %17, label %22

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 6
  %19 = load i8*, i8** %18, align 8
  %20 = call i32 @copy_urb_data_to_user(i8* %19, %struct.urb* %4)
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %81, label %22

; <label>:22:                                     ; preds = %17, %13, %2
  call void @might_fault()
  %23 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 10
  %24 = load i32, i32* %23, align 4
  %25 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %7, i32 0, i32 2
  %26 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %24, i32* %25) #5, !srcloc !56
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %81, label %28

; <label>:28:                                     ; preds = %22
  call void @might_fault()
  %29 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 20
  %30 = load i32, i32* %29, align 4
  %31 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %7, i32 0, i32 6
  %32 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %30, i32* %31) #5, !srcloc !57
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %81, label %34

; <label>:34:                                     ; preds = %28
  call void @might_fault()
  %35 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 26
  %36 = load i32, i32* %35, align 4
  %37 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %7, i32 0, i32 9
  %38 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %36, i32* %37) #5, !srcloc !58
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %81, label %40

; <label>:40:                                     ; preds = %34
  %41 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 9
  %42 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %41, align 8
  %43 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %42, i32 0, i32 0
  %44 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %43)
  %45 = icmp ne i32 %44, 0
  br i1 %45, label %46, label %76

; <label>:46:                                     ; preds = %40, %74
  %.01 = phi i32 [ %75, %74 ], [ 0, %40 ]
  %47 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 24
  %48 = load i32, i32* %47, align 4
  %49 = icmp ult i32 %.01, %48
  br i1 %49, label %50, label %76

; <label>:50:                                     ; preds = %46
  call void @might_fault()
  %51 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 29
  %52 = zext i32 %.01 to i64
  %53 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %51, i64 0, i64 %52
  %54 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %53, i32 0, i32 2
  %55 = load i32, i32* %54, align 8
  %56 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %7, i32 0, i32 12
  %57 = zext i32 %.01 to i64
  %58 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %56, i64 0, i64 %57
  %59 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %58, i32 0, i32 1
  %60 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %55, i32* %59) #5, !srcloc !59
  %61 = icmp ne i32 %60, 0
  br i1 %61, label %81, label %62

; <label>:62:                                     ; preds = %50
  call void @might_fault()
  %63 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 29
  %64 = zext i32 %.01 to i64
  %65 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %63, i64 0, i64 %64
  %66 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %65, i32 0, i32 3
  %67 = load i32, i32* %66, align 4
  %68 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %7, i32 0, i32 12
  %69 = zext i32 %.01 to i64
  %70 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %68, i64 0, i64 %69
  %71 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %70, i32 0, i32 2
  %72 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %67, i32* %71) #5, !srcloc !60
  %73 = icmp ne i32 %72, 0
  br i1 %73, label %81, label %74

; <label>:74:                                     ; preds = %62
  %75 = add i32 %.01, 1
  br label %46

; <label>:76:                                     ; preds = %46, %40
  call void @might_fault()
  %77 = call i32 @ptr_to_compat(i8* %9)
  %78 = bitcast i8** %1 to i32*
  %79 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %77, i32* %78) #5, !srcloc !61
  %80 = icmp ne i32 %79, 0
  %. = select i1 %80, i32 -14, i32 0
  br label %81

; <label>:81:                                     ; preds = %76, %62, %50, %34, %28, %22, %17
  %.0 = phi i32 [ -14, %17 ], [ -14, %22 ], [ -14, %28 ], [ -14, %34 ], [ -14, %50 ], [ -14, %62 ], [ %., %76 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct*) #0 {
  %2 = call i32 @test_tsk_thread_flag(%struct.task_struct* %0, i32 2)
  %3 = icmp ne i32 %2, 0
  %4 = xor i1 %3, true
  %5 = xor i1 %4, true
  %6 = zext i1 %5 to i32
  %7 = sext i32 %6 to i64
  %8 = trunc i64 %7 to i32
  ret i32 %8
}

declare i32 @default_wake_function(%struct.__wait_queue*, i32, i32, i8*) #1

declare void @add_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: noinline nounwind uwtable
define internal %struct.async* @async_getcompleted(%struct.dev_state*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = icmp eq i64* %2, %3
  %5 = zext i1 %4 to i32
  %6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %7 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %6)
  %8 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %7)
  %9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 5
  %10 = call i32 @list_empty(%struct.list_head* %9)
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %20, label %12

; <label>:12:                                     ; preds = %1
  %13 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 5
  %14 = getelementptr inbounds %struct.list_head, %struct.list_head* %13, i32 0, i32 0
  %15 = load %struct.list_head*, %struct.list_head** %14, align 8
  %16 = bitcast %struct.list_head* %15 to i8*
  %17 = getelementptr inbounds i8, i8* %16, i64 0
  %18 = bitcast i8* %17 to %struct.async*
  %19 = getelementptr inbounds %struct.async, %struct.async* %18, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %19)
  br label %20

; <label>:20:                                     ; preds = %12, %1
  %.0 = phi %struct.async* [ null, %1 ], [ %18, %12 ]
  %21 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %21, i64 %8)
  ret %struct.async* %.0
}

declare void @schedule() #1

declare void @remove_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @copy_urb_data_to_user(i8*, %struct.urb*) #0 {
  %3 = getelementptr inbounds %struct.urb, %struct.urb* %1, i32 0, i32 24
  %4 = load i32, i32* %3, align 4
  %5 = icmp sgt i32 %4, 0
  br i1 %5, label %6, label %9

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.urb, %struct.urb* %1, i32 0, i32 19
  %8 = load i32, i32* %7, align 8
  br label %12

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.urb, %struct.urb* %1, i32 0, i32 20
  %11 = load i32, i32* %10, align 4
  br label %12

; <label>:12:                                     ; preds = %9, %6
  %.0 = phi i32 [ %8, %6 ], [ %11, %9 ]
  %13 = getelementptr inbounds %struct.urb, %struct.urb* %1, i32 0, i32 18
  %14 = load i32, i32* %13, align 4
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %22

; <label>:16:                                     ; preds = %12
  %17 = getelementptr inbounds %struct.urb, %struct.urb* %1, i32 0, i32 14
  %18 = load i8*, i8** %17, align 8
  call void @might_fault() #5
  %19 = call i64 @_copy_to_user(i8* %0, i8* %18, i32 %.0) #5
  %20 = trunc i64 %19 to i32
  %21 = icmp ne i32 %20, 0
  %. = select i1 %21, i32 -14, i32 0
  br label %42

; <label>:22:                                     ; preds = %12, %37
  %.02 = phi i8* [ %39, %37 ], [ %0, %12 ]
  %.01 = phi i32 [ %41, %37 ], [ 0, %12 ]
  %.1 = phi i32 [ %40, %37 ], [ %.0, %12 ]
  %23 = getelementptr inbounds %struct.urb, %struct.urb* %1, i32 0, i32 18
  %24 = load i32, i32* %23, align 4
  %25 = icmp ult i32 %.01, %24
  %26 = icmp ne i32 %.1, 0
  %.4 = select i1 %25, i1 %26, i1 false
  br i1 %.4, label %27, label %42

; <label>:27:                                     ; preds = %22
  %28 = icmp ugt i32 %.1, 16384
  %..1 = select i1 %28, i32 16384, i32 %.1
  %29 = getelementptr inbounds %struct.urb, %struct.urb* %1, i32 0, i32 16
  %30 = load %struct.scatterlist*, %struct.scatterlist** %29, align 8
  %31 = zext i32 %.01 to i64
  %32 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %30, i64 %31
  %33 = call i8* @sg_virt(%struct.scatterlist* %32)
  call void @might_fault() #5
  %34 = call i64 @_copy_to_user(i8* %.02, i8* %33, i32 %..1) #5
  %35 = trunc i64 %34 to i32
  %36 = icmp ne i32 %35, 0
  br i1 %36, label %42, label %37

; <label>:37:                                     ; preds = %27
  %38 = zext i32 %..1 to i64
  %39 = getelementptr inbounds i8, i8* %.02, i64 %38
  %40 = sub i32 %.1, %..1
  %41 = add i32 %.01, 1
  br label %22

; <label>:42:                                     ; preds = %22, %27, %16
  %.03 = phi i32 [ %., %16 ], [ -14, %27 ], [ 0, %22 ]
  ret i32 %.03
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct*, i32) #0 {
  %3 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 1
  %4 = load i8*, i8** %3, align 8
  %5 = bitcast i8* %4 to %struct.thread_info*
  %6 = call i32 @test_ti_thread_flag(%struct.thread_info* %5, i32 %1)
  ret i32 %6
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info*, i32) #0 {
  %3 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %0, i32 0, i32 2
  %4 = bitcast i32* %3 to i64*
  %5 = call i32 @variable_test_bit(i32 %1, i64* %4)
  ret i32 %5
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @proc_ioctl(%struct.dev_state*, %struct.usbdevfs_ioctl*) #0 {
  %3 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %1, i32 0, i32 1
  %4 = load i32, i32* %3, align 4
  %5 = ashr i32 %4, 16
  %6 = and i32 %5, 16383
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %28

; <label>:8:                                      ; preds = %2
  %9 = sext i32 %6 to i64
  %10 = call i8* @__kmalloc(i64 %9, i32 208) #5
  %11 = icmp eq i8* %10, null
  br i1 %11, label %112, label %12

; <label>:12:                                     ; preds = %8
  %13 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %1, i32 0, i32 1
  %14 = load i32, i32* %13, align 4
  %15 = ashr i32 %14, 30
  %16 = and i32 %15, 3
  %17 = and i32 %16, 1
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %19, label %26

; <label>:19:                                     ; preds = %12
  %20 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %1, i32 0, i32 2
  %21 = load i8*, i8** %20, align 8
  %22 = sext i32 %6 to i64
  %23 = call i64 @copy_from_user(i8* %10, i8* %21, i64 %22)
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %25, label %28

; <label>:25:                                     ; preds = %19
  call void @kfree(i8* %10)
  br label %112

; <label>:26:                                     ; preds = %12
  %27 = sext i32 %6 to i64
  call void @llvm.memset.p0i8.i64(i8* %10, i8 0, i64 %27, i32 1, i1 false)
  br label %28

; <label>:28:                                     ; preds = %26, %19, %2
  %.02 = phi i8* [ null, %2 ], [ %10, %19 ], [ %10, %26 ]
  %29 = call i32 @connected(%struct.dev_state* %0)
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %32, label %31

; <label>:31:                                     ; preds = %28
  call void @kfree(i8* %.02)
  br label %112

; <label>:32:                                     ; preds = %28
  %33 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %34 = load %struct.usb_device*, %struct.usb_device** %33, align 8
  %35 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %34, i32 0, i32 3
  %36 = load i32, i32* %35, align 8
  %37 = icmp ne i32 %36, 7
  br i1 %37, label %95, label %38

; <label>:38:                                     ; preds = %32
  %39 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %40 = load %struct.usb_device*, %struct.usb_device** %39, align 8
  %41 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %1, i32 0, i32 0
  %42 = load i32, i32* %41, align 8
  %43 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %40, i32 %42)
  %44 = icmp ne %struct.usb_interface* %43, null
  br i1 %44, label %45, label %95

; <label>:45:                                     ; preds = %38
  %46 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %1, i32 0, i32 1
  %47 = load i32, i32* %46, align 4
  switch i32 %47, label %70 [
    i32 21782, label %48
    i32 21783, label %62
  ]

; <label>:48:                                     ; preds = %45
  %49 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %43, i32 0, i32 7
  %50 = getelementptr inbounds %struct.device, %struct.device* %49, i32 0, i32 7
  %51 = load %struct.device_driver*, %struct.device_driver** %50, align 8
  %52 = icmp ne %struct.device_driver* %51, null
  br i1 %52, label %53, label %95

; <label>:53:                                     ; preds = %48
  %54 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %43, i32 0, i32 7
  %55 = getelementptr inbounds %struct.device, %struct.device* %54, i32 0, i32 7
  %56 = load %struct.device_driver*, %struct.device_driver** %55, align 8
  %57 = bitcast %struct.device_driver* %56 to i8*
  %58 = getelementptr inbounds i8, i8* %57, i64 -104
  %59 = bitcast i8* %58 to %struct.usb_driver*
  %60 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %43, i32 0, i32 7
  %61 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %60, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.51, i32 0, i32 0))
  call void @usb_driver_release_interface(%struct.usb_driver* %59, %struct.usb_interface* %43)
  br label %95

; <label>:62:                                     ; preds = %45
  %63 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %43, i32 0, i32 7
  %64 = getelementptr inbounds %struct.device, %struct.device* %63, i32 0, i32 7
  %65 = load %struct.device_driver*, %struct.device_driver** %64, align 8
  %66 = icmp ne %struct.device_driver* %65, null
  br i1 %66, label %95, label %67

; <label>:67:                                     ; preds = %62
  %68 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %43, i32 0, i32 7
  %69 = call i32 @device_attach(%struct.device* %68)
  br label %95

; <label>:70:                                     ; preds = %45
  %71 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %43, i32 0, i32 7
  %72 = getelementptr inbounds %struct.device, %struct.device* %71, i32 0, i32 7
  %73 = load %struct.device_driver*, %struct.device_driver** %72, align 8
  %74 = icmp ne %struct.device_driver* %73, null
  br i1 %74, label %75, label %82

; <label>:75:                                     ; preds = %70
  %76 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %43, i32 0, i32 7
  %77 = getelementptr inbounds %struct.device, %struct.device* %76, i32 0, i32 7
  %78 = load %struct.device_driver*, %struct.device_driver** %77, align 8
  %79 = bitcast %struct.device_driver* %78 to i8*
  %80 = getelementptr inbounds i8, i8* %79, i64 -104
  %81 = bitcast i8* %80 to %struct.usb_driver*
  br label %82

; <label>:82:                                     ; preds = %75, %70
  %.0 = phi %struct.usb_driver* [ %81, %75 ], [ null, %70 ]
  %83 = icmp eq %struct.usb_driver* %.0, null
  br i1 %83, label %95, label %84

; <label>:84:                                     ; preds = %82
  %85 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %.0, i32 0, i32 3
  %86 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %85, align 8
  %87 = icmp eq i32 (%struct.usb_interface*, i32, i8*)* %86, null
  br i1 %87, label %95, label %88

; <label>:88:                                     ; preds = %84
  %89 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %.0, i32 0, i32 3
  %90 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %89, align 8
  %91 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %1, i32 0, i32 1
  %92 = load i32, i32* %91, align 4
  %93 = call i32 %90(%struct.usb_interface* %43, i32 %92, i8* %.02)
  %94 = icmp eq i32 %93, -515
  %. = select i1 %94, i32 -25, i32 %93
  br label %95

; <label>:95:                                     ; preds = %38, %88, %84, %82, %67, %62, %53, %48, %32
  %.6 = phi i32 [ -113, %32 ], [ -22, %38 ], [ 0, %53 ], [ -61, %48 ], [ %69, %67 ], [ -16, %62 ], [ %., %88 ], [ -25, %84 ], [ -25, %82 ]
  %96 = icmp sge i32 %.6, 0
  br i1 %96, label %97, label %111

; <label>:97:                                     ; preds = %95
  %98 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %1, i32 0, i32 1
  %99 = load i32, i32* %98, align 4
  %100 = ashr i32 %99, 30
  %101 = and i32 %100, 3
  %102 = and i32 %101, 2
  %103 = icmp ne i32 %102, 0
  %104 = icmp sgt i32 %6, 0
  %or.cond = and i1 %103, %104
  br i1 %or.cond, label %105, label %111

; <label>:105:                                    ; preds = %97
  %106 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %1, i32 0, i32 2
  %107 = load i8*, i8** %106, align 8
  call void @might_fault() #5
  %108 = call i64 @_copy_to_user(i8* %107, i8* %.02, i32 %6) #5
  %109 = trunc i64 %108 to i32
  %110 = icmp ne i32 %109, 0
  %..6 = select i1 %110, i32 -14, i32 %.6
  br label %111

; <label>:111:                                    ; preds = %105, %97, %95
  %.7 = phi i32 [ %.6, %97 ], [ %.6, %95 ], [ %..6, %105 ]
  call void @kfree(i8* %.02)
  br label %112

; <label>:112:                                    ; preds = %8, %111, %31, %25
  %.03 = phi i32 [ -14, %25 ], [ %.7, %111 ], [ -19, %31 ], [ -12, %8 ]
  ret i32 %.03
}

declare void @usb_driver_release_interface(%struct.usb_driver*, %struct.usb_interface*) #1

declare i32 @device_attach(%struct.device*) #1

; Function Attrs: noinline nounwind uwtable
define internal %struct.async* @async_getpending(%struct.dev_state*, i8*) #0 {
  %3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  br label %4

; <label>:4:                                      ; preds = %13, %2
  %.sink = phi %struct.list_head* [ %3, %2 ], [ %17, %13 ]
  %5 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %5, align 8
  %7 = bitcast %struct.list_head* %6 to i8*
  %8 = getelementptr inbounds i8, i8* %7, i64 0
  %9 = bitcast i8* %8 to %struct.async*
  %10 = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 0
  %11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  %12 = icmp ne %struct.list_head* %10, %11
  br i1 %12, label %13, label %19

; <label>:13:                                     ; preds = %4
  %14 = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 7
  %15 = load i8*, i8** %14, align 8
  %16 = icmp eq i8* %15, %1
  %17 = getelementptr inbounds %struct.async, %struct.async* %9, i32 0, i32 0
  br i1 %16, label %18, label %4

; <label>:18:                                     ; preds = %13
  call void @list_del_init(%struct.list_head* %17)
  br label %19

; <label>:19:                                     ; preds = %4, %18
  %.0 = phi %struct.async* [ %9, %18 ], [ null, %4 ]
  ret %struct.async* %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @processcompl(%struct.async*, i8**) #0 {
  %3 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %4 = load %struct.urb*, %struct.urb** %3, align 8
  %5 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 7
  %6 = load i8*, i8** %5, align 8
  %7 = bitcast i8* %6 to %struct.usbdevfs_urb*
  %8 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 7
  %9 = load i8*, i8** %8, align 8
  %10 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 6
  %11 = load i8*, i8** %10, align 8
  %12 = icmp ne i8* %11, null
  br i1 %12, label %13, label %22

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 20
  %15 = load i32, i32* %14, align 4
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %17, label %22

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 6
  %19 = load i8*, i8** %18, align 8
  %20 = call i32 @copy_urb_data_to_user(i8* %19, %struct.urb* %4)
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %81, label %22

; <label>:22:                                     ; preds = %17, %13, %2
  call void @might_fault()
  %23 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 10
  %24 = load i32, i32* %23, align 4
  %25 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %7, i32 0, i32 2
  %26 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %24, i32* %25) #5, !srcloc !62
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %81, label %28

; <label>:28:                                     ; preds = %22
  call void @might_fault()
  %29 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 20
  %30 = load i32, i32* %29, align 4
  %31 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %7, i32 0, i32 6
  %32 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %30, i32* %31) #5, !srcloc !63
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %81, label %34

; <label>:34:                                     ; preds = %28
  call void @might_fault()
  %35 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 26
  %36 = load i32, i32* %35, align 4
  %37 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %7, i32 0, i32 9
  %38 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %36, i32* %37) #5, !srcloc !64
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %81, label %40

; <label>:40:                                     ; preds = %34
  %41 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 9
  %42 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %41, align 8
  %43 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %42, i32 0, i32 0
  %44 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %43)
  %45 = icmp ne i32 %44, 0
  br i1 %45, label %46, label %76

; <label>:46:                                     ; preds = %40, %74
  %.01 = phi i32 [ %75, %74 ], [ 0, %40 ]
  %47 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 24
  %48 = load i32, i32* %47, align 4
  %49 = icmp ult i32 %.01, %48
  br i1 %49, label %50, label %76

; <label>:50:                                     ; preds = %46
  call void @might_fault()
  %51 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 29
  %52 = zext i32 %.01 to i64
  %53 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %51, i64 0, i64 %52
  %54 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %53, i32 0, i32 2
  %55 = load i32, i32* %54, align 8
  %56 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %7, i32 0, i32 12
  %57 = zext i32 %.01 to i64
  %58 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %56, i64 0, i64 %57
  %59 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %58, i32 0, i32 1
  %60 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %55, i32* %59) #5, !srcloc !65
  %61 = icmp ne i32 %60, 0
  br i1 %61, label %81, label %62

; <label>:62:                                     ; preds = %50
  call void @might_fault()
  %63 = getelementptr inbounds %struct.urb, %struct.urb* %4, i32 0, i32 29
  %64 = zext i32 %.01 to i64
  %65 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %63, i64 0, i64 %64
  %66 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %65, i32 0, i32 3
  %67 = load i32, i32* %66, align 4
  %68 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %7, i32 0, i32 12
  %69 = zext i32 %.01 to i64
  %70 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %68, i64 0, i64 %69
  %71 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %70, i32 0, i32 2
  %72 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %67, i32* %71) #5, !srcloc !66
  %73 = icmp ne i32 %72, 0
  br i1 %73, label %81, label %74

; <label>:74:                                     ; preds = %62
  %75 = add i32 %.01, 1
  br label %46

; <label>:76:                                     ; preds = %46, %40
  call void @might_fault()
  %77 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %9, i8** %1) #5, !srcloc !67
  %78 = ptrtoint i8* %77 to i64
  %79 = trunc i64 %78 to i32
  %80 = icmp ne i32 %79, 0
  %. = select i1 %80, i32 -14, i32 0
  br label %81

; <label>:81:                                     ; preds = %17, %22, %28, %34, %50, %62, %76
  %.0 = phi i32 [ %., %76 ], [ -14, %62 ], [ -14, %50 ], [ -14, %34 ], [ -14, %28 ], [ -14, %22 ], [ -14, %17 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @releaseintf(%struct.dev_state*, i32) #0 {
  %3 = zext i32 %1 to i64
  %4 = icmp uge i64 %3, 64
  br i1 %4, label %15, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  %7 = load %struct.usb_device*, %struct.usb_device** %6, align 8
  %8 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %7, i32 %1)
  %9 = icmp ne %struct.usb_interface* %8, null
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %5
  %11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 11
  %12 = call i32 @test_and_clear_bit(i32 %1, i64* %11)
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %14, label %15

; <label>:14:                                     ; preds = %10
  call void @usb_driver_release_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %8)
  br label %15

; <label>:15:                                     ; preds = %5, %14, %10, %2
  %.0 = phi i32 [ -22, %2 ], [ -2, %5 ], [ 0, %14 ], [ -22, %10 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @test_and_clear_bit(i32, i64*) #0 {
  %3 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %1, i32 %0, i64* %1) #5, !srcloc !68
  ret i32 %3
}

declare i32 @usb_hub_claim_port(%struct.usb_device*, i32, %struct.dev_state*) #1

declare i32 @usb_hub_release_port(%struct.usb_device*, i32, %struct.dev_state*) #1

declare i32 @strncmp(i8*, i8*, i64) #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @imajor(%struct.inode*) #0 {
  %2 = getelementptr inbounds %struct.inode, %struct.inode* %0, i32 0, i32 13
  %3 = load i32, i32* %2, align 4
  %4 = lshr i32 %3, 20
  ret i32 %4
}

; Function Attrs: noinline nounwind uwtable
define internal %struct.usb_device* @usbdev_lookup_by_devt(i32) #0 {
  %2 = zext i32 %0 to i64
  %3 = inttoptr i64 %2 to i8*
  %4 = call %struct.device* @bus_find_device(%struct.bus_type* @usb_bus_type, %struct.device* null, i8* %3, i32 (%struct.device*, i8*)* @match_devt)
  %5 = icmp ne %struct.device* %4, null
  %6 = bitcast %struct.device* %4 to i8*
  %7 = getelementptr inbounds i8, i8* %6, i64 -136
  %8 = bitcast i8* %7 to %struct.usb_device*
  %.0 = select i1 %5, %struct.usb_device* %8, %struct.usb_device* null
  ret %struct.usb_device* %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usb_autoresume_device(%struct.usb_device*) #0 {
  ret i32 0
}

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

declare void @usb_put_dev(%struct.usb_device*) #1

declare %struct.device* @bus_find_device(%struct.bus_type*, %struct.device*, i8*, i32 (%struct.device*, i8*)*) #1

; Function Attrs: noinline nounwind uwtable
define internal i32 @match_devt(%struct.device*, i8*) #0 {
  %3 = getelementptr inbounds %struct.device, %struct.device* %0, i32 0, i32 20
  %4 = load i32, i32* %3, align 8
  %5 = ptrtoint i8* %1 to i64
  %6 = trunc i64 %5 to i32
  %7 = icmp eq i32 %4, %6
  %8 = zext i1 %7 to i32
  ret i32 %8
}

declare void @usb_hub_release_all_ports(%struct.usb_device*, %struct.dev_state*) #1

; Function Attrs: noinline nounwind uwtable
define internal void @destroy_all_async(%struct.dev_state*) #0 {
  %2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  call void @destroy_async(%struct.dev_state* %0, %struct.list_head* %2)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @usbdev_notify(%struct.notifier_block*, i64, i8*) #0 {
  %cond = icmp eq i64 %1, 2
  br i1 %cond, label %4, label %6

; <label>:4:                                      ; preds = %3
  %5 = bitcast i8* %2 to %struct.usb_device*
  call void @usbdev_remove(%struct.usb_device* %5)
  br label %6

; <label>:6:                                      ; preds = %3, %4
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define internal void @usbdev_remove(%struct.usb_device*) #0 {
  %2 = alloca %struct.siginfo, align 8
  br label %3

; <label>:3:                                      ; preds = %8, %20, %1
  %4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 27
  %5 = call i32 @list_empty(%struct.list_head* %4)
  %6 = icmp ne i32 %5, 0
  %7 = xor i1 %6, true
  br i1 %7, label %8, label %40

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 27
  %10 = getelementptr inbounds %struct.list_head, %struct.list_head* %9, i32 0, i32 0
  %11 = load %struct.list_head*, %struct.list_head** %10, align 8
  %12 = bitcast %struct.list_head* %11 to i8*
  %13 = getelementptr inbounds i8, i8* %12, i64 0
  %14 = bitcast i8* %13 to %struct.dev_state*
  call void @destroy_all_async(%struct.dev_state* %14)
  %15 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 6
  call void @__wake_up(%struct.__wait_queue_head* %15, i32 3, i32 0, i8* null)
  %16 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %16)
  %17 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 7
  %18 = load i32, i32* %17, align 8
  %19 = icmp ne i32 %18, 0
  br i1 %19, label %20, label %3

; <label>:20:                                     ; preds = %8
  %21 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 7
  %22 = load i32, i32* %21, align 8
  %23 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %2, i32 0, i32 0
  store i32 %22, i32* %23, align 8
  %24 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %2, i32 0, i32 1
  store i32 32, i32* %24, align 4
  %25 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %2, i32 0, i32 2
  store i32 -4, i32* %25, align 8
  %26 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 10
  %27 = load i8*, i8** %26, align 8
  %28 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %2, i32 0, i32 3
  %29 = bitcast %union.anon.32* %28 to %struct.anon.37*
  %30 = getelementptr inbounds %struct.anon.37, %struct.anon.37* %29, i32 0, i32 0
  store i8* %27, i8** %30, align 8
  %31 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 7
  %32 = load i32, i32* %31, align 8
  %33 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 8
  %34 = load %struct.pid*, %struct.pid** %33, align 8
  %35 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 9
  %36 = load %struct.cred*, %struct.cred** %35, align 8
  %37 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %14, i32 0, i32 12
  %38 = load i32, i32* %37, align 8
  %39 = call i32 @kill_pid_info_as_cred(i32 %32, %struct.siginfo* %2, %struct.pid* %34, %struct.cred* %36, i32 %38)
  br label %3

; <label>:40:                                     ; preds = %3
  ret void
}

attributes #0 = { noinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind readnone }
attributes #5 = { nounwind }
attributes #6 = { nounwind readonly }

!llvm.ident = !{!0}

!0 = !{!"clang version 4.0.1 (tags/RELEASE_401/final)"}
!1 = !{i32 -2147072454, i32 -2147072415, i32 -2147072394, i32 -2147072357, i32 -2147072334, i32 -2147072464}
!2 = !{i32 -2146841220}
!3 = !{i32 -2143888076}
!4 = !{i32 770856, i32 770877}
!5 = !{i32 -2143885933}
!6 = !{i32 -2143883562}
!7 = !{i32 -2143882974}
!8 = !{i32 -2143882379}
!9 = !{i32 -2143881604}
!10 = !{i32 -2143864245}
!11 = !{i32 -2143862671}
!12 = !{i32 -2143862217}
!13 = !{i32 -2143860913}
!14 = !{i32 -2143860262}
!15 = !{i32 -2143858940}
!16 = !{i32 -2143858282}
!17 = !{i32 -2143856888}
!18 = !{i32 -2143856202}
!19 = !{i32 -2143854630}
!20 = !{i32 -2143633868}
!21 = !{i32 -2143623788, i32 -2143623781, i32 -2143623767, i32 -2143623765, i32 -2143624438, i32 -2143623725, i32 -2143623677, i32 -2143623611, i32 -2143623549, i32 -2143623497, i32 -2143624358, i32 -2143624333, i32 -2143623292, i32 -2143624260, i32 -2143624235, i32 -2143623032, i32 -2143623108, i32 -2143623015, i32 -2143623064, i32 -2143624958, i32 -2143624917, i32 -2143622249, i32 -2143622235, i32 -2143622233, i32 -2143622906, i32 -2143622193, i32 -2143622145, i32 -2143622079, i32 -2143622017, i32 -2143621965, i32 -2143622826, i32 -2143622801, i32 -2143621760, i32 -2143622728, i32 -2143622703, i32 -2143621500, i32 -2143621576, i32 -2143621483, i32 -2143621532, i32 -2143624885, i32 -2143624846, i32 -2143624817, i32 -2143624771, i32 -2143624746, i32 -2143621466, i32 -2143621422, i32 -2143621399, i32 -2143621366, i32 -2143621335}
!22 = !{i32 -2143607448, i32 -2143607441, i32 -2143607427, i32 -2143607425, i32 -2143608098, i32 -2143607385, i32 -2143607337, i32 -2143607271, i32 -2143607209, i32 -2143607157, i32 -2143608018, i32 -2143607993, i32 -2143606952, i32 -2143607920, i32 -2143607895, i32 -2143606692, i32 -2143606768, i32 -2143606675, i32 -2143606724, i32 -2143608624, i32 -2143608583, i32 -2143605909, i32 -2143605895, i32 -2143605893, i32 -2143606566, i32 -2143605853, i32 -2143605805, i32 -2143605739, i32 -2143605677, i32 -2143605625, i32 -2143606486, i32 -2143606461, i32 -2143605420, i32 -2143606388, i32 -2143606363, i32 -2143605160, i32 -2143605236, i32 -2143605143, i32 -2143605192, i32 -2143608551, i32 -2143608512, i32 -2143608483, i32 -2143608437, i32 -2143608412, i32 -2143605126, i32 -2143605082, i32 -2143605059, i32 -2143605026, i32 -2143604995}
!23 = !{i32 -2143587139, i32 -2143587132, i32 -2143587118, i32 -2143587116, i32 -2143587789, i32 -2143587076, i32 -2143587028, i32 -2143586962, i32 -2143586900, i32 -2143586848, i32 -2143587709, i32 -2143587684, i32 -2143586643, i32 -2143587611, i32 -2143587586, i32 -2143586383, i32 -2143586459, i32 -2143586366, i32 -2143586415, i32 -2143588309, i32 -2143588268, i32 -2143585600, i32 -2143585586, i32 -2143585584, i32 -2143586257, i32 -2143585544, i32 -2143585496, i32 -2143585430, i32 -2143585368, i32 -2143585316, i32 -2143586177, i32 -2143586152, i32 -2143585111, i32 -2143586079, i32 -2143586054, i32 -2143584851, i32 -2143584927, i32 -2143584834, i32 -2143584883, i32 -2143588236, i32 -2143588197, i32 -2143588168, i32 -2143588122, i32 -2143588097, i32 -2143584817, i32 -2143584773, i32 -2143584750, i32 -2143584717, i32 -2143584686}
!24 = !{i32 -2143637926}
!25 = !{i32 -2143637328}
!26 = !{i32 -2143580597}
!27 = !{i32 -2143579678}
!28 = !{i32 -2143578096}
!29 = !{i32 -2146650420}
!30 = !{i32 366670, i32 366681}
!31 = !{i32 -2147073162, i32 -2147073123, i32 -2147073102, i32 -2147073065, i32 -2147073042, i32 -2147073172}
!32 = !{i32 -2146679035, i32 -2146678996, i32 -2146678975, i32 -2146678938, i32 -2146678915, i32 -2146679045}
!33 = !{i32 -2146678823, i32 -2146678784, i32 -2146678763, i32 -2146678726, i32 -2146678703, i32 -2146678833}
!34 = !{i32 -2143879444}
!35 = !{i32 -2144246001, i32 -2144245976, i32 -2144245706, i32 -2144245909, i32 -2144245878, i32 -2144245848}
!36 = !{i32 -2146567271}
!37 = !{i32 -2146582446}
!38 = !{i32 -2146677975, i32 -2146677936, i32 -2146677915, i32 -2146677878, i32 -2146677855, i32 -2146677985}
!39 = !{i32 -2146678399, i32 -2146678360, i32 -2146678339, i32 -2146678302, i32 -2146678279, i32 -2146678409}
!40 = !{i32 -2146566015}
!41 = !{i32 771298}
!42 = !{i32 -2143853780}
!43 = !{i32 -2143851196, i32 -2143851189, i32 -2143851175, i32 -2143851173, i32 -2143851846, i32 -2143851133, i32 -2143851085, i32 -2143851019, i32 -2143850957, i32 -2143850905, i32 -2143851766, i32 -2143851741, i32 -2143850700, i32 -2143851668, i32 -2143851643, i32 -2143850440, i32 -2143850516, i32 -2143850423, i32 -2143850472, i32 -2143852366, i32 -2143852325, i32 -2143849657, i32 -2143849643, i32 -2143849641, i32 -2143850314, i32 -2143849601, i32 -2143849553, i32 -2143849487, i32 -2143849425, i32 -2143849373, i32 -2143850234, i32 -2143850209, i32 -2143849168, i32 -2143850136, i32 -2143850111, i32 -2143848908, i32 -2143848984, i32 -2143848891, i32 -2143848940, i32 -2143852293, i32 -2143852254, i32 -2143852225, i32 -2143852179, i32 -2143852154, i32 -2143848874, i32 -2143848830, i32 -2143848807, i32 -2143848774, i32 -2143848743}
!44 = !{i32 -2143834906, i32 -2143834899, i32 -2143834885, i32 -2143834883, i32 -2143835556, i32 -2143834843, i32 -2143834795, i32 -2143834729, i32 -2143834667, i32 -2143834615, i32 -2143835476, i32 -2143835451, i32 -2143834410, i32 -2143835378, i32 -2143835353, i32 -2143834150, i32 -2143834226, i32 -2143834133, i32 -2143834182, i32 -2143836080, i32 -2143836039, i32 -2143833367, i32 -2143833353, i32 -2143833351, i32 -2143834024, i32 -2143833311, i32 -2143833263, i32 -2143833197, i32 -2143833135, i32 -2143833083, i32 -2143833944, i32 -2143833919, i32 -2143832878, i32 -2143833846, i32 -2143833821, i32 -2143832618, i32 -2143832694, i32 -2143832601, i32 -2143832650, i32 -2143836007, i32 -2143835968, i32 -2143835939, i32 -2143835893, i32 -2143835868, i32 -2143832584, i32 -2143832540, i32 -2143832517, i32 -2143832484, i32 -2143832453}
!45 = !{i32 -2143811106, i32 -2143811099, i32 -2143811085, i32 -2143811083, i32 -2143811756, i32 -2143811043, i32 -2143810995, i32 -2143810929, i32 -2143810867, i32 -2143810815, i32 -2143811676, i32 -2143811651, i32 -2143810610, i32 -2143811578, i32 -2143811553, i32 -2143810350, i32 -2143810426, i32 -2143810333, i32 -2143810382, i32 -2143812278, i32 -2143812237, i32 -2143809567, i32 -2143809553, i32 -2143809551, i32 -2143810224, i32 -2143809511, i32 -2143809463, i32 -2143809397, i32 -2143809335, i32 -2143809283, i32 -2143810144, i32 -2143810119, i32 -2143809078, i32 -2143810046, i32 -2143810021, i32 -2143808818, i32 -2143808894, i32 -2143808801, i32 -2143808850, i32 -2143812205, i32 -2143812166, i32 -2143812137, i32 -2143812091, i32 -2143812066, i32 -2143808784, i32 -2143808740, i32 -2143808717, i32 -2143808684, i32 -2143808653}
!46 = !{i32 -2143790785, i32 -2143790778, i32 -2143790764, i32 -2143790762, i32 -2143791435, i32 -2143790722, i32 -2143790674, i32 -2143790608, i32 -2143790546, i32 -2143790494, i32 -2143791355, i32 -2143791330, i32 -2143790289, i32 -2143791257, i32 -2143791232, i32 -2143790029, i32 -2143790105, i32 -2143790012, i32 -2143790061, i32 -2143791956, i32 -2143791915, i32 -2143789246, i32 -2143789232, i32 -2143789230, i32 -2143789903, i32 -2143789190, i32 -2143789142, i32 -2143789076, i32 -2143789014, i32 -2143788962, i32 -2143789823, i32 -2143789798, i32 -2143788757, i32 -2143789725, i32 -2143789700, i32 -2143788497, i32 -2143788573, i32 -2143788480, i32 -2143788529, i32 -2143791883, i32 -2143791844, i32 -2143791815, i32 -2143791769, i32 -2143791744, i32 -2143788463, i32 -2143788419, i32 -2143788396, i32 -2143788363, i32 -2143788332}
!47 = !{i32 -2143774385, i32 -2143774378, i32 -2143774364, i32 -2143774362, i32 -2143775035, i32 -2143774322, i32 -2143774274, i32 -2143774208, i32 -2143774146, i32 -2143774094, i32 -2143774955, i32 -2143774930, i32 -2143773889, i32 -2143774857, i32 -2143774832, i32 -2143773629, i32 -2143773705, i32 -2143773612, i32 -2143773661, i32 -2143775564, i32 -2143775523, i32 -2143772846, i32 -2143772832, i32 -2143772830, i32 -2143773503, i32 -2143772790, i32 -2143772742, i32 -2143772676, i32 -2143772614, i32 -2143772562, i32 -2143773423, i32 -2143773398, i32 -2143772357, i32 -2143773325, i32 -2143773300, i32 -2143772097, i32 -2143772173, i32 -2143772080, i32 -2143772129, i32 -2143775491, i32 -2143775452, i32 -2143775423, i32 -2143775377, i32 -2143775352, i32 -2143772063, i32 -2143772019, i32 -2143771996, i32 -2143771963, i32 -2143771932}
!48 = !{i32 -2143757953, i32 -2143757946, i32 -2143757932, i32 -2143757930, i32 -2143758603, i32 -2143757890, i32 -2143757842, i32 -2143757776, i32 -2143757714, i32 -2143757662, i32 -2143758523, i32 -2143758498, i32 -2143757457, i32 -2143758425, i32 -2143758400, i32 -2143757197, i32 -2143757273, i32 -2143757180, i32 -2143757229, i32 -2143759132, i32 -2143759091, i32 -2143756414, i32 -2143756400, i32 -2143756398, i32 -2143757071, i32 -2143756358, i32 -2143756310, i32 -2143756244, i32 -2143756182, i32 -2143756130, i32 -2143756991, i32 -2143756966, i32 -2143755925, i32 -2143756893, i32 -2143756868, i32 -2143755665, i32 -2143755741, i32 -2143755648, i32 -2143755697, i32 -2143759059, i32 -2143759020, i32 -2143758991, i32 -2143758945, i32 -2143758920, i32 -2143755631, i32 -2143755587, i32 -2143755564, i32 -2143755531, i32 -2143755500}
!49 = !{i32 -2143741557, i32 -2143741550, i32 -2143741536, i32 -2143741534, i32 -2143742207, i32 -2143741494, i32 -2143741446, i32 -2143741380, i32 -2143741318, i32 -2143741266, i32 -2143742127, i32 -2143742102, i32 -2143741061, i32 -2143742029, i32 -2143742004, i32 -2143740801, i32 -2143740877, i32 -2143740784, i32 -2143740833, i32 -2143742734, i32 -2143742693, i32 -2143740018, i32 -2143740004, i32 -2143740002, i32 -2143740675, i32 -2143739962, i32 -2143739914, i32 -2143739848, i32 -2143739786, i32 -2143739734, i32 -2143740595, i32 -2143740570, i32 -2143739529, i32 -2143740497, i32 -2143740472, i32 -2143739269, i32 -2143739345, i32 -2143739252, i32 -2143739301, i32 -2143742661, i32 -2143742622, i32 -2143742593, i32 -2143742547, i32 -2143742522, i32 -2143739235, i32 -2143739191, i32 -2143739168, i32 -2143739135, i32 -2143739104}
!50 = !{i32 -2143725061, i32 -2143725054, i32 -2143725040, i32 -2143725038, i32 -2143725711, i32 -2143724998, i32 -2143724950, i32 -2143724884, i32 -2143724822, i32 -2143724770, i32 -2143725631, i32 -2143725606, i32 -2143724565, i32 -2143725533, i32 -2143725508, i32 -2143724305, i32 -2143724381, i32 -2143724288, i32 -2143724337, i32 -2143726244, i32 -2143726203, i32 -2143723522, i32 -2143723508, i32 -2143723506, i32 -2143724179, i32 -2143723466, i32 -2143723418, i32 -2143723352, i32 -2143723290, i32 -2143723238, i32 -2143724099, i32 -2143724074, i32 -2143723033, i32 -2143724001, i32 -2143723976, i32 -2143722773, i32 -2143722849, i32 -2143722756, i32 -2143722805, i32 -2143726171, i32 -2143726132, i32 -2143726103, i32 -2143726057, i32 -2143726032, i32 -2143722739, i32 -2143722695, i32 -2143722672, i32 -2143722639, i32 -2143722608}
!51 = !{i32 -2143708649, i32 -2143708642, i32 -2143708628, i32 -2143708626, i32 -2143709299, i32 -2143708586, i32 -2143708538, i32 -2143708472, i32 -2143708410, i32 -2143708358, i32 -2143709219, i32 -2143709194, i32 -2143708153, i32 -2143709121, i32 -2143709096, i32 -2143707893, i32 -2143707969, i32 -2143707876, i32 -2143707925, i32 -2143709826, i32 -2143709785, i32 -2143707110, i32 -2143707096, i32 -2143707094, i32 -2143707767, i32 -2143707054, i32 -2143707006, i32 -2143706940, i32 -2143706878, i32 -2143706826, i32 -2143707687, i32 -2143707662, i32 -2143706621, i32 -2143707589, i32 -2143707564, i32 -2143702300, i32 -2143702376, i32 -2143702283, i32 -2143702332, i32 -2143709753, i32 -2143709714, i32 -2143709685, i32 -2143709639, i32 -2143709614, i32 -2143702266, i32 -2143702222, i32 -2143702199, i32 -2143702166, i32 -2143702135}
!52 = !{i32 -2143688308, i32 -2143688301, i32 -2143688287, i32 -2143688285, i32 -2143688958, i32 -2143688245, i32 -2143688197, i32 -2143688131, i32 -2143688069, i32 -2143688017, i32 -2143688878, i32 -2143688853, i32 -2143687812, i32 -2143688780, i32 -2143688755, i32 -2143687552, i32 -2143687628, i32 -2143687535, i32 -2143687584, i32 -2143689479, i32 -2143689438, i32 -2143686769, i32 -2143686755, i32 -2143686753, i32 -2143687426, i32 -2143686713, i32 -2143686665, i32 -2143686599, i32 -2143686537, i32 -2143686485, i32 -2143687346, i32 -2143687321, i32 -2143686280, i32 -2143687248, i32 -2143687223, i32 -2143686020, i32 -2143686096, i32 -2143686003, i32 -2143686052, i32 -2143689406, i32 -2143689367, i32 -2143689338, i32 -2143689292, i32 -2143689267, i32 -2143685986, i32 -2143685942, i32 -2143685919, i32 -2143685886, i32 -2143685855}
!53 = !{i32 -2143672047, i32 -2143672040, i32 -2143672026, i32 -2143672024, i32 -2143672697, i32 -2143671984, i32 -2143671936, i32 -2143671870, i32 -2143671808, i32 -2143671756, i32 -2143672617, i32 -2143672592, i32 -2143671551, i32 -2143672519, i32 -2143672494, i32 -2143671291, i32 -2143671367, i32 -2143671274, i32 -2143671323, i32 -2143673219, i32 -2143673178, i32 -2143670508, i32 -2143670494, i32 -2143670492, i32 -2143671165, i32 -2143670452, i32 -2143670404, i32 -2143670338, i32 -2143670276, i32 -2143670224, i32 -2143671085, i32 -2143671060, i32 -2143670019, i32 -2143670987, i32 -2143670962, i32 -2143669759, i32 -2143669835, i32 -2143669742, i32 -2143669791, i32 -2143673146, i32 -2143673107, i32 -2143673078, i32 -2143673032, i32 -2143673007, i32 -2143669725, i32 -2143669681, i32 -2143669658, i32 -2143669625, i32 -2143669594}
!54 = !{i32 -2143655702, i32 -2143655695, i32 -2143655681, i32 -2143655679, i32 -2143656352, i32 -2143655639, i32 -2143655591, i32 -2143655525, i32 -2143655463, i32 -2143655411, i32 -2143656272, i32 -2143656247, i32 -2143655206, i32 -2143656174, i32 -2143656149, i32 -2143654946, i32 -2143655022, i32 -2143654929, i32 -2143654978, i32 -2143656879, i32 -2143656838, i32 -2143654163, i32 -2143654149, i32 -2143654147, i32 -2143654820, i32 -2143654107, i32 -2143654059, i32 -2143653993, i32 -2143653931, i32 -2143653879, i32 -2143654740, i32 -2143654715, i32 -2143653674, i32 -2143654642, i32 -2143654617, i32 -2143653414, i32 -2143653490, i32 -2143653397, i32 -2143653446, i32 -2143656806, i32 -2143656767, i32 -2143656738, i32 -2143656692, i32 -2143656667, i32 -2143653380, i32 -2143653336, i32 -2143653313, i32 -2143653280, i32 -2143653249}
!55 = !{i32 -2143864486}
!56 = !{i32 -2143648176}
!57 = !{i32 -2143646410}
!58 = !{i32 -2143644621}
!59 = !{i32 -2143642586}
!60 = !{i32 -2143640502}
!61 = !{i32 -2143638681}
!62 = !{i32 -2143876285}
!63 = !{i32 -2143874522}
!64 = !{i32 -2143872736}
!65 = !{i32 -2143870704}
!66 = !{i32 -2143868623}
!67 = !{i32 -2143866429}
!68 = !{i32 -2147070775, i32 -2147070736, i32 -2147070715, i32 -2147070678, i32 -2147070655, i32 -2147070785, i32 364671}
